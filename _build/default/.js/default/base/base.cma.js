// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Base__
//# shape: Base__:[[]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0], Base$0 = [0, Base];
   runtime.caml_register_global(0, Base$0, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool0
//# shape: Base__Bool0:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bool0 = [0];
   runtime.caml_register_global(0, Base_Bool0, "Base__Bool0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Globalize
//# shape: Base__Globalize:[F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(2),F(2),F(3),F(2)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_dup = runtime.caml_obj_dup;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function globalize_bool(b){return b;}
   function globalize_char(c){return c;}
   function globalize_unit(u){return u;}
   function globalize_array(param, a){return caml_obj_dup(a);}
   function globalize_list(f, param){
    if(! param) return 0;
    var xs = param[2], x = param[1], a = globalize_list(f, xs);
    return [0, caml_call1(f, x), a];
   }
   function globalize_option(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function globalize_result(globalize_a, globalize_b, t){
    if(0 === t[0]){var a = t[1]; return [0, caml_call1(globalize_a, a)];}
    var b = t[1];
    return [1, caml_call1(globalize_b, b)];
   }
   function globalize_ref(param, r){return [0, r[1]];}
   function globalize_lazy_t(param, t){return t;}
   var
    Base_Globalize =
      [0,
       globalize_bool,
       globalize_char,
       caml_obj_dup,
       function(a){return a;},
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       caml_obj_dup,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref];
   runtime.caml_register_global(0, Base_Globalize, "Base__Globalize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Base__Bool0
//# shape: Base__Poly0:[F(2)*,F(2)*,F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_compare = runtime.caml_compare;
   function descending(x, y){return caml_compare(y, x);}
   function max(x, y){
    return runtime.caml_csel_value(runtime.caml_greaterequal(x, y), x, y);
   }
   function min(x, y){
    return runtime.caml_csel_value(runtime.caml_lessequal(x, y), x, y);
   }
   var Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(0, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Bool0, Base__Poly0, Shadow_stdlib, Stdlib, Stdlib__MoreLabels, Stdlib__StdLabels
//# shape: Base__Import0:[N,N,N,N,N,N,N,N,N,N,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),F(1)*,F(2),F(1),F(1),F(1),F(4),F(1),N,[F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1)*,N,N,N,N,N,N,F(2)*,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),F(2),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),N,F(1)*,F(2),F(1),F(1),F(1),F(4),F(1),N,[F(2),F(1),F(1),F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(3),F(1)*,F(1),F(1),F(2),F(1),F(1)*->F(1),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(3)*,F(4)*],[F(1)*],[F(1)*]],F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)*,[F(2)*,F(2)*,F(2),F(2)],F(2)*,F(2)*,F(2),F(2),[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],F(2),F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1),F(1)*,F(1),F(1)*,F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal,
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Stdlib = global_data.Stdlib,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    invalid_arg = Stdlib[1],
    failwith = Stdlib[2],
    Exit$0 = Stdlib[3],
    Match_failure = Stdlib[4],
    Assert_failure = Stdlib[5],
    Invalid_argument = Stdlib[6],
    Failure = Stdlib[7],
    Not_found$0 = Stdlib[8],
    Out_of_memory = Stdlib[9],
    Stack_overflow = Stdlib[10],
    Sys_error = Stdlib[11],
    End_of_file = Stdlib[12],
    Division_by_zero = Stdlib[13],
    Sys_blocked_io = Stdlib[14],
    Undefined_recursive_module = Stdlib[15],
    min = Stdlib[16],
    max = Stdlib[17],
    abs = Stdlib[18],
    max_int$0 = Stdlib[19],
    min_int$0 = Stdlib[20],
    lnot = Stdlib[21],
    infinity$0 = Stdlib[22],
    neg_infinity$0 = Stdlib[23],
    nan$0 = Stdlib[24],
    max_float$0 = Stdlib[25],
    min_float$0 = Stdlib[26],
    epsilon_float$0 = Stdlib[27],
    symbol_concat = Stdlib[28],
    char_of_int$0 = Stdlib[29],
    string_of_bool$0 = Stdlib[30],
    bool_of_string_opt$0 = Stdlib[31],
    bool_of_string$0 = Stdlib[32],
    string_of_int$0 = Stdlib[33],
    int_of_string_opt$0 = Stdlib[34],
    string_of_float$0 = Stdlib[35],
    float_of_string_opt$0 = Stdlib[36],
    symbol$0 = Stdlib[37],
    stdin$0 = Stdlib[38],
    stdout$0 = Stdlib[39],
    stderr$0 = Stdlib[40],
    print_char$0 = Stdlib[41],
    print_string$0 = Stdlib[42],
    print_bytes$0 = Stdlib[43],
    print_int$0 = Stdlib[44],
    print_float$0 = Stdlib[45],
    print_endline$0 = Stdlib[46],
    print_newline$0 = Stdlib[47],
    prerr_char$0 = Stdlib[48],
    prerr_string$0 = Stdlib[49],
    prerr_bytes$0 = Stdlib[50],
    prerr_int$0 = Stdlib[51],
    prerr_float$0 = Stdlib[52],
    prerr_endline$0 = Stdlib[53],
    prerr_newline$0 = Stdlib[54],
    read_line$0 = Stdlib[55],
    read_int_opt$0 = Stdlib[56],
    read_int$0 = Stdlib[57],
    read_float_opt$0 = Stdlib[58],
    read_float$0 = Stdlib[59],
    open_out$0 = Stdlib[60],
    open_out_bin$0 = Stdlib[61],
    open_out_gen$0 = Stdlib[62],
    flush$0 = Stdlib[63],
    flush_all$0 = Stdlib[64],
    output_char$0 = Stdlib[65],
    output_string$0 = Stdlib[66],
    output_bytes$0 = Stdlib[67],
    output$0 = Stdlib[68],
    output_substring$0 = Stdlib[69],
    output_byte$0 = Stdlib[70],
    output_binary_int$0 = Stdlib[71],
    output_value$0 = Stdlib[72],
    seek_out$0 = Stdlib[73],
    pos_out$0 = Stdlib[74],
    out_channel_length$0 = Stdlib[75],
    close_out$0 = Stdlib[76],
    close_out_noerr$0 = Stdlib[77],
    set_binary_mode_out$0 = Stdlib[78],
    open_in$0 = Stdlib[79],
    open_in_bin$0 = Stdlib[80],
    open_in_gen$0 = Stdlib[81],
    input_char$0 = Stdlib[82],
    input_line$0 = Stdlib[83],
    input$0 = Stdlib[84],
    really_input$0 = Stdlib[85],
    really_input_string$0 = Stdlib[86],
    input_byte$0 = Stdlib[87],
    input_binary_int$0 = Stdlib[88],
    input_value$0 = Stdlib[89],
    seek_in$0 = Stdlib[90],
    pos_in$0 = Stdlib[91],
    in_channel_length$0 = Stdlib[92],
    close_in$0 = Stdlib[93],
    close_in_noerr$0 = Stdlib[94],
    set_binary_mode_in$0 = Stdlib[95],
    LargeFile = Stdlib[96],
    string_of_format$0 = Stdlib[97],
    symbol$1 = Stdlib[98],
    exit$0 = Stdlib[99],
    at_exit$0 = Stdlib[100],
    valid_float_lexem$0 = Stdlib[101],
    unsafe_really_input$0 = Stdlib[102],
    do_at_exit$0 = Stdlib[103],
    do_domain_local_at_exit$0 = Stdlib[104],
    Hashtbl = Stdlib_MoreLabels[1],
    Map = Stdlib_MoreLabels[2],
    Set = Stdlib_MoreLabels[3],
    Stdlib$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found$0,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol_concat,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$0,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$1,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       do_domain_local_at_exit$0,
       Hashtbl,
       Map,
       Set];
   function bool_to_int(x){return x;}
   function symbol$2(b, a){return b !== a ? 1 : 0;}
   var symbol$3 = runtime.caml_mul;
   function symbol$4(b, a){return Math.pow(b, a);}
   function symbol$5(b, a){return b * a;}
   function symbol$6(b, a){return b + a | 0;}
   function symbol$7(b, a){return b + a;}
   function symbol$8(b, a){return b - a | 0;}
   function symbol$9(b, a){return b - a;}
   var symbol$10 = runtime.caml_div;
   function symbol$11(b, a){return b / a;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$0(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    symbol$12 = caml_lessthan,
    symbol$13 = caml_lessequal,
    symbol$14 = caml_notequal,
    symbol$15 = caml_equal,
    symbol$16 = caml_greaterthan,
    symbol$17 = caml_greaterequal;
   function ascending$0(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$0(x, y){return Base_Poly0[2].call(null, x, y);}
   var
    compare = caml_int_compare,
    compare_local = caml_int_compare,
    equal = caml_equal,
    equal_local = caml_equal;
   function max$1(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$1(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       ascending$0,
       descending$0,
       compare,
       compare_local,
       equal,
       equal_local,
       max$1,
       min$1];
   function ascending$1(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$1(x, y){return Base_Poly0[2].call(null, x, y);}
   function max$2(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$2(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$1, descending$1, max$2, min$2],
    symbol$18 = caml_lessthan,
    symbol$19 = caml_lessequal,
    symbol$20 = caml_notequal,
    symbol$21 = caml_equal,
    symbol$22 = caml_greaterthan,
    symbol$23 = caml_greaterequal;
   function ascending$2(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$2(x, y){return Base_Poly0[2].call(null, x, y);}
   var
    compare$0 = caml_int_compare,
    compare_local$0 = caml_int_compare,
    equal$0 = caml_equal,
    equal_local$0 = caml_equal;
   function max$3(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$3(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$2,
       descending$2,
       compare$0,
       compare_local$0,
       equal$0,
       equal_local$0,
       max$3,
       min$3];
   function symbol$24(x, y){return x < y ? 1 : 0;}
   function symbol$25(x, y){return x <= y ? 1 : 0;}
   function symbol$26(x, y){return x !== y ? 1 : 0;}
   function symbol$27(x, y){return x === y ? 1 : 0;}
   function symbol$28(x, y){return y < x ? 1 : 0;}
   function symbol$29(x, y){return y <= x ? 1 : 0;}
   function ascending$3(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$3(x, y){return Base_Poly0[2].call(null, x, y);}
   var compare$1 = caml_int_compare, compare_local$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function equal_local$1(x, y){return x === y ? 1 : 0;}
   function max$4(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$4(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       ascending$3,
       descending$3,
       compare$1,
       compare_local$1,
       equal$1,
       equal_local$1,
       max$4,
       min$4];
   function symbol$30(x, y){return x < y ? 1 : 0;}
   function symbol$31(x, y){return x <= y ? 1 : 0;}
   function symbol$32(x, y){return x !== y ? 1 : 0;}
   function symbol$33(x, y){return x === y ? 1 : 0;}
   function symbol$34(x, y){return y < x ? 1 : 0;}
   function symbol$35(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$4(x, y){return Base_Poly0[2].call(null, x, y);}
   var compare$2 = caml_int_compare, compare_local$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function equal_local$2(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$5(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       ascending$4,
       descending$4,
       compare$2,
       compare_local$2,
       equal$2,
       equal_local$2,
       max$5,
       min$5];
   function symbol$36(x, y){return x < y ? 1 : 0;}
   function symbol$37(x, y){return x <= y ? 1 : 0;}
   function symbol$38(x, y){return x !== y ? 1 : 0;}
   function symbol$39(x, y){return x === y ? 1 : 0;}
   function symbol$40(x, y){return y < x ? 1 : 0;}
   function symbol$41(x, y){return y <= x ? 1 : 0;}
   var ascending$5 = caml_int_compare;
   function descending$5(x, y){return caml_int_compare(y, x);}
   var compare$3 = caml_int_compare;
   function equal$3(x, y){return x === y ? 1 : 0;}
   var compare_local$3 = caml_int_compare;
   function equal_local$3(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$6(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       ascending$5,
       descending$5,
       compare$3,
       equal$3,
       compare_local$3,
       equal_local$3,
       max$6,
       min$6];
   function ascending$6(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$6(x, y){return Base_Poly0[2].call(null, x, y);}
   var compare_local$4 = runtime.caml_float_compare;
   function equal_local$4(x, y){return x === y ? 1 : 0;}
   function max$7(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$7(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Float_replace_polymorphic_comp =
      [0,
       ascending$6,
       descending$6,
       compare_local$4,
       equal_local$4,
       max$7,
       min$7],
    symbol$42 = runtime.caml_string_lessthan,
    symbol$43 = caml_string_lessequal,
    symbol$44 = runtime.caml_string_notequal,
    symbol$45 = caml_string_equal,
    symbol$46 = runtime.caml_string_greaterthan,
    symbol$47 = caml_string_greaterequal;
   function ascending$7(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$7(x, y){return Base_Poly0[2].call(null, x, y);}
   var
    compare$4 = caml_string_compare,
    compare_local$5 = caml_string_compare,
    equal$4 = caml_string_equal,
    equal_local$5 = caml_string_equal;
   function max$8(x, y){
    return runtime.caml_csel_value(caml_string_greaterequal(x, y), x, y);
   }
   function min$8(x, y){
    return runtime.caml_csel_value(caml_string_lessequal(x, y), x, y);
   }
   var
    String_replace_polymorphic_com =
      [0,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       ascending$7,
       descending$7,
       compare$4,
       compare_local$5,
       equal$4,
       equal_local$5,
       max$8,
       min$8],
    symbol$48 = runtime.caml_bytes_lessthan,
    symbol$49 = caml_bytes_lessequal,
    symbol$50 = runtime.caml_bytes_notequal,
    symbol$51 = caml_bytes_equal,
    symbol$52 = runtime.caml_bytes_greaterthan,
    symbol$53 = caml_bytes_greaterequal;
   function ascending$8(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending$8(x, y){return Base_Poly0[2].call(null, x, y);}
   var
    compare$5 = caml_bytes_compare,
    compare_local$6 = caml_bytes_compare,
    equal$5 = caml_bytes_equal,
    equal_local$6 = caml_bytes_equal;
   function max$9(x, y){
    return runtime.caml_csel_value(caml_bytes_greaterequal(x, y), x, y);
   }
   function min$9(x, y){
    return runtime.caml_csel_value(caml_bytes_lessequal(x, y), x, y);
   }
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       ascending$8,
       descending$8,
       compare$5,
       compare_local$6,
       equal$5,
       equal_local$6,
       max$9,
       min$9];
   function symbol$54(a){return - a | 0;}
   function symbol$55(a){return - a;}
   function asr(b, a){return b >> a;}
   function land(b, a){return b & a;}
   function lor(b, a){return b | a;}
   function lsl(b, a){return b << a;}
   function lsr(b, a){return b >>> a | 0;}
   function lxor(b, a){return b ^ a;}
   var mod = runtime.caml_mod;
   function fst(a){return a[1];}
   function snd(a){return a[2];}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib$0,
       bool_to_int,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max$0,
       min$0,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$0,
       symbol_concat,
       symbol$54,
       symbol$55,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Stdlib
//# shape: Base__Int0:[F(1)*,F(1),F(1),F(1)*,F(1)*,N,N,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    to_string = Stdlib[33],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib[34];
   function to_float(a){return a;}
   function of_float(a){return a | 0;}
   var max_value = Stdlib[19], min_value = Stdlib[20];
   function succ(a){return a + 1 | 0;}
   function pred(a){return a - 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       of_string_opt,
       to_float,
       of_float,
       max_value,
       min_value,
       succ,
       pred];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
//# shape: Base__Printf:[F(2),F(1),F(2),F(2),F(3),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return ksprintf
            (function(s, param){return Base_Import0[124].call(null, s);}, fmt);
   }
   function invalid_argf(fmt){
    return ksprintf
            (function(s, param){return Base_Import0[126].call(null, s);}, fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
//# shape: Base__Sys0:[[N],N,N,N,N,N,N,N,N,N,N,F(1),F(1),N,F(1),N,F(1),F(1),F(2)*,F(1),F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0);
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[49],
    runtime_warnings_enabled = Stdlib_Sys[50],
    a =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function Make_immediate64(b, a){return Stdlib_Sys[51][1].call(null, b, a);}
   function getenv_exn(var$){
    try{var b = caml_sys_getenv(var$); return b;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Base_Import0[85][8])
      return caml_call2(Base_Printf[6].call(null, a), var$, 0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function getenv(var$){
    try{var x = caml_sys_getenv(var$);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Base_Import0[85][8]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       Make_immediate64,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Import0, Base__Int0, Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
//# shape: Base__Array0:[F(1),[],N,F(2)*,F(2)*,F(1)*,F(2)*,F(5),F(1)*,F(1)*,F(4),F(2),F(3),F(1),F(3),F(1),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels,
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11],
    create = caml_make_vect,
    create_local = caml_make_vect,
    create_float_uninitialized = runtime.caml_make_float_vect,
    append = Stdlib_ArrayLabels[4],
    blit = Stdlib_ArrayLabels[9],
    concat = Stdlib_ArrayLabels[5],
    copy = Stdlib_ArrayLabels[7],
    fill = Stdlib_ArrayLabels[8],
    cst_Array_init = "Array.init";
   function init(len, f){
    if(0 === len) return [0];
    if(0 > len) return Base_Import0[126].call(null, cst_Array_init);
    var
     x = caml_call1(f, 0),
     res = caml_make_vect(len, x),
     a = Base_Int0[9].call(null, len),
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      res[i + 1] = caml_call1(f, i);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return res;
   }
   var
    make_matrix = Stdlib_ArrayLabels[2],
    of_list = Stdlib_ArrayLabels[11],
    sub = Stdlib_ArrayLabels[6],
    to_list = Stdlib_ArrayLabels[10];
   function fold(t, init, f){
    var
     r = [0, init],
     a = Base_Import0[93].call(null, t.length - 1, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      r[1] = caml_call2(f, r[1], t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r[1];
   }
   function fold_right(t, f, init){
    var r = [0, init], a = Base_Import0[93].call(null, t.length - 1, 1);
    if(a >= 0){
     var i = a;
     for(;;){
      r[1] = caml_call2(f, t[i + 1], r[1]);
      var b = i - 1 | 0;
      if(0 === i) break;
      i = b;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var a = Base_Import0[93].call(null, t.length - 1, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call1(f, t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var a = Base_Import0[93].call(null, t.length - 1, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i, t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function map(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     x = caml_call1(f, t[1]),
     r = caml_make_vect(len, x),
     a = Base_Import0[93].call(null, len, 1),
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      r[i + 1] = caml_call1(f, t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   function mapi(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     x = caml_call2(f, 0, t[1]),
     r = caml_make_vect(len, x),
     a = Base_Import0[93].call(null, len, 1),
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      r[i + 1] = caml_call2(f, i, t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   function stable_sort(t, compare){
    return Stdlib_ArrayLabels[36].call(null, compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[i + 1],
     elt_j = caml_check_bound(t, j)[j + 1];
    t[i + 1] = elt_j;
    t[j + 1] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(10, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
//# shape: Base__Char0:[F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1),F(2)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[3];
   function to_int(a){return a;}
   function unsafe_of_int(a){return a;}
   var uppercase = Stdlib_Char[4];
   function int_is_ok(i){
    var a = 0 <= i ? 1 : 0, b = a ? i <= 255 ? 1 : 0 : a;
    return b;
   }
   var
    a =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call2(failwithf(a), i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       0,
       255,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
//# shape: Base__Hash_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Base__Import0, Stdlib__ListLabels
//# shape: Base__List0:[F(1),F(2),F(1),F(1),F(1),F(2),F(3),F(3),F(4),F(2),F(3),F(2),F(3),F(2),F(2),F(2),F(2),F(3),F(1),F(3),F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst_List_fold_left2 = "List.fold_left2",
    Base_Import0 = global_data.Base__Import0,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[6],
    rev_append = Stdlib_ListLabels[13],
    tl_exn = Stdlib_ListLabels[7],
    unzip = Stdlib_ListLabels[57],
    cst_List_exists2 = "List.exists2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_iter2 = "List.iter2",
    cst_List_rev_map2 = "List.rev_map2";
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = Base_Import0[91].call(null, len, 1);
     len = len$0;
     param = l;
    }
   }
   function exists(t$0, f){
    var t = t$0;
    for(;;){
     if(! t) return 0;
     var xs = t[2], x = t[1];
     if(caml_call1(f, x)) return 1;
     t = xs;
    }
   }
   function exists2_ok(l1$1, l2$1, f){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        a = caml_call2(f, a1, a2);
       if(a) return a;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 0;
     return Base_Import0[126].call(null, cst_List_exists2);
    }
   }
   function fold(t$0, init$1, f){
    var t = t$0, init = init$1;
    for(;;){
     if(! t) return init;
     var l = t[2], a = t[1], init$0 = caml_call2(f, init, a);
     t = l;
     init = init$0;
    }
   }
   function fold2_ok(l1$1, l2$1, init$1, f){
    var l1 = l1$1, l2 = l2$1, init = init$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        init$0 = caml_call3(f, init, a1, a2);
       l1 = l1$0;
       l2 = l2$0;
       init = init$0;
       continue;
      }
     }
     else if(! l2) return init;
     return Base_Import0[126].call(null, cst_List_fold_left2);
    }
   }
   function for_all(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var xs = t$0[2], x = t$0[1];
      if(! (1 - caml_call1(f, x))){t$0 = xs; continue;}
      var a = 1;
     }
     else
      var a = 0;
     return 1 - a;
    }
   }
   function for_all2_ok(l1$1, l2$1, f){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        a = caml_call2(f, a1, a2);
       if(! a) return a;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 1;
     return Base_Import0[126].call(null, cst_List_for_all2);
    }
   }
   function iter(t$0, f){
    var t = t$0;
    for(;;){
     if(! t) return 0;
     var l = t[2], a = t[1];
     caml_call1(f, a);
     t = l;
    }
   }
   function iter2_ok(l1$1, l2$1, f){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
       caml_call2(f, a1, a2);
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return 0;
     return Base_Import0[126].call(null, cst_List_iter2);
    }
   }
   function nontail_map(t, f){
    if(! t) return 0;
    var xs = t[2], x = t[1], y = caml_call1(f, x);
    return [0, y, nontail_map(xs, f)];
   }
   function nontail_mapi(t, f){return Stdlib_ListLabels[21].call(null, f, t);}
   function partition(t, f){return Stdlib_ListLabels[47].call(null, f, t);}
   function rev_map(l$0, f){
    var accu = 0, param = l$0;
    for(;;){
     if(! param) return accu;
     var l = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l;
    }
   }
   function rev_map2_ok(l1$1, l2$1, f){
    var accu = 0, l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1 = l1$0;
       l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return accu;
     return Base_Import0[126].call(null, cst_List_rev_map2);
    }
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return rev_append(rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    if(! l) return init;
    var t = rev(l), init$1 = init, t$0 = t;
    for(;;){
     if(! t$0) return init$1;
     var l$0 = t$0[2], a = t$0[1], init$0 = caml_call2(f, a, init$1);
     init$1 = init$0;
     t$0 = l$0;
    }
   }
   function fold_right2_ok(l1, l2, f, init){
    if(! l1 && ! l2) return init;
    var
     l2$0 = rev(l2),
     l1$0 = rev(l1),
     init$1 = init,
     l2$2 = l2$0,
     l1$2 = l1$0;
    for(;;){
     if(l1$2){
      if(l2$2){
       var
        l2$1 = l2$2[2],
        a2 = l2$2[1],
        l1$1 = l1$2[2],
        a1 = l1$2[1],
        init$0 = caml_call3(f, a1, a2, init$1);
       init$1 = init$0;
       l2$2 = l2$1;
       l1$2 = l1$1;
       continue;
      }
     }
     else if(! l2$2) return init$1;
     return Base_Import0[126].call(null, cst_List_fold_left2);
    }
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok];
   runtime.caml_register_global(7, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
//# shape: Base__Hash:[F(1)*,N,F(2),F(2),F(2),F(2),F(1)*,F(2)*,F(1),[F(2)*,F(1)*],F(2)*,F(2),N,F(3)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function hash_fold_int32(s, x){return caml_call2(hash_fold_int, s, x);}
    var f = Base_Char0[4];
    function hash_fold_char(s, x){return caml_call2(hash_fold_int, s, f(x));}
    function hash_fold_bool(s, x){
     var a = x ? 1 : 0;
     return caml_call2(hash_fold_int, s, a);
    }
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, Base_List0[5].call(null, list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x);
      s = s$0;
      list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var a = runtime.caml_obj_tag(x);
     a:
     if(250 === a)
      var b = x[1];
     else{
      if(246 !== a && 244 !== a){var b = x; break a;}
      var b = CamlinternalLazy[2].call(null, x);
     }
     return caml_call2(hash_fold_elem, s, b);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[i + 1],
       i$0 = Base_Import0[91].call(null, i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e);
      s = s$0;
      i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      a = caml_call1(Hash[6], 0),
      b = hash_fold_nativeint(caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_int64(x){
     var
      a = caml_call1(Hash[6], 0),
      b = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_int32(x){
     var
      a = caml_call1(Hash[6], 0),
      b = hash_fold_int32(caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_char(x){
     var
      a = caml_call1(Hash[6], 0),
      b = hash_fold_char(caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_int(x){
     var
      a = caml_call1(Hash[6], 0),
      b = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_bool(x){
     var
      a = caml_call1(Hash[6], 0),
      b = hash_fold_bool(caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_string(x){
     var
      a = caml_call1(Hash[6], 0),
      b = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_float(x){
     var
      a = caml_call1(Hash[6], 0),
      b = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, a), x);
     return caml_call1(Hash[8], b);
    }
    function hash_unit(x){
     var a = caml_call1(Hash[6], 0), s = caml_call2(Hash[7], 0, a);
     return caml_call1(Hash[8], s);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      a = caml_call1(Hash[6], 0),
      b = caml_call2(folder, caml_call2(Hash[7], seed, a), x);
     return caml_call1(Hash[8], b);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){var seed = opt ? opt[1] : 0; return seed;}
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return Base_Int0[1].call(null, state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(b, a){return runtime.Base_internalhash_fold_int(b, a);},
         function(b, a){return runtime.Base_internalhash_fold_int64(b, a);},
         function(b, a){return runtime.Base_internalhash_fold_float(b, a);},
         function(b, a){return runtime.Base_internalhash_fold_string(b, a);},
         alloc,
         reset,
         function(a){return runtime.Base_internalhash_get_hash_value(a);},
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     a = Base_Import0[119].call(null, t, 21),
     b = Base_Import0[117].call(null, t),
     t$0 = Base_Import0[91].call(null, b, a),
     c = Base_Import0[120].call(null, t$0, 24),
     t$1 = Base_Import0[121].call(null, t$0, c),
     d = Base_Import0[119].call(null, t$1, 8),
     e = Base_Import0[119].call(null, t$1, 3),
     f = Base_Import0[91].call(null, t$1, e),
     t$2 = Base_Import0[91].call(null, f, d),
     g = Base_Import0[120].call(null, t$2, 14),
     t$3 = Base_Import0[121].call(null, t$2, g),
     h = Base_Import0[119].call(null, t$3, 4),
     i = Base_Import0[119].call(null, t$3, 2),
     j = Base_Import0[91].call(null, t$3, i),
     t$4 = Base_Import0[91].call(null, j, h),
     k = Base_Import0[120].call(null, t$4, 28),
     t$5 = Base_Import0[121].call(null, t$4, k),
     l = Base_Import0[119].call(null, t$5, 31);
    return Base_Import0[91].call(null, t$5, l);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    Base_Hash =
      [0,
       F,
       description,
       function(b, a){return runtime.Base_internalhash_fold_int(b, a);},
       function(b, a){return runtime.Base_internalhash_fold_int64(b, a);},
       function(b, a){return runtime.Base_internalhash_fold_float(b, a);},
       function(b, a){return runtime.Base_internalhash_fold_string(b, a);},
       alloc,
       reset,
       function(a){return runtime.Base_internalhash_get_hash_value(a);},
       For_tests,
       create,
       of_fold,
       [0,
        hash_fold_nativeint,
        hash_fold_int64,
        hash_fold_int32,
        hash_fold_char,
        hash_fold_int,
        hash_fold_bool,
        hash_fold_string,
        hash_fold_float,
        hash_fold_unit,
        hash_fold_option,
        hash_fold_list,
        hash_fold_lazy_t,
        hash_fold_ref_frozen,
        hash_fold_array_frozen,
        hash_nativeint,
        hash_int64,
        hash_int32,
        hash_char,
        hash_int,
        hash_bool,
        hash_string,
        function(a){return runtime.Base_hash_double(a);},
        hash_unit],
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
//# shape: Base__Ppx_compare_lib:[F(3),F(3),[],[],N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int_compare = runtime.caml_int_compare,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    a =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."],
    b =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, b, param){
    return caml_call1
            (Base_Printf[4].call(null, Base_Import0[124], a), type_name);
   }
   function equal_abstract(type_name, a, param){
    return caml_call1
            (Base_Printf[4].call(null, Base_Import0[124], b), type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_bool_local = caml_int_compare,
    compare_char = caml_int_compare,
    compare_char_local = caml_int_compare,
    compare_float = caml_float_compare,
    compare_float_local = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int_local = caml_int_compare,
    compare_int32 = caml_int_compare,
    compare_int32_local = caml_int_compare;
   function compare_int64(b, a){return caml_int64_compare(b, a);}
   function compare_int64_local(b, a){return caml_int64_compare(b, a);}
   var
    compare_nativeint = caml_int_compare,
    compare_nativeint_local = caml_int_compare,
    compare_string = caml_string_compare,
    compare_string_local = caml_string_compare,
    compare_bytes = caml_bytes_compare,
    compare_bytes_local = caml_bytes_compare,
    compare_unit = caml_int_compare,
    compare_unit_local = caml_int_compare;
   function compare_array_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[i + 1], r = b[i + 1], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = Base_Import0[91].call(null, i, 1);
     i = i$0;
    }
   }
   function compare_array(compare_elt, a, b){
    return compare_array_local(compare_elt, a, b);
   }
   function compare_list(compare_elt, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var
      ys = b[2],
      y = b[1],
      xs = a[2],
      x = a[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     a = xs;
     b = ys;
    }
   }
   function compare_list_local(compare_elt_local, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var
      ys = b[2],
      y = b[1],
      xs = a[2],
      x = a[1],
      res = caml_call2(compare_elt_local, x, y);
     if(0 !== res) return res;
     a = xs;
     b = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_option_local(compare_elt_local, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt_local, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function compare_ref_local(compare_elt, a, b){return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(b, a){return b === a ? 1 : 0;}
   function equal_bool_local(b, a){return b === a ? 1 : 0;}
   function equal_char(b, a){return b === a ? 1 : 0;}
   function equal_char_local(b, a){return b === a ? 1 : 0;}
   function equal_int(b, a){return b === a ? 1 : 0;}
   function equal_int_local(b, a){return b === a ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int32_local = caml_equal,
    equal_int64 = caml_equal,
    equal_int64_local = caml_equal,
    equal_nativeint = caml_equal,
    equal_nativeint_local = caml_equal,
    equal_string = caml_string_equal,
    equal_string_local = caml_string_equal,
    equal_bytes = caml_bytes_equal,
    equal_bytes_local = caml_bytes_equal;
   function equal_unit(b, a){return b === a ? 1 : 0;}
   function equal_unit_local(b, a){return b === a ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_float_local(x, y){
    return caml_float_compare(x, y) === 0 ? 1 : 0;
   }
   function equal_array_local(equal_elt, a, b){
    var c = a === b ? 1 : 0;
    if(c)
     var d = c;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      e = len_a === len_b ? 1 : 0;
     if(e){
      var i = 0;
      for(;;){
       var f = i === len_a ? 1 : 0;
       if(f)
        var g = f;
       else{
        var l = a[i + 1], r = b[i + 1], h = caml_call2(equal_elt, l, r);
        if(h){var i$0 = Base_Import0[91].call(null, i, 1); i = i$0; continue;}
        var g = h;
       }
       return g;
      }
     }
     var d = e;
    }
    return d;
   }
   function equal_array(equal_elt, a, b){
    return equal_array_local(equal_elt, a, b);
   }
   function equal_list(equal_elt, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(a){
      if(b){
       var
        ys = b[2],
        y = b[1],
        xs = a[2],
        x = a[1],
        c = caml_call2(equal_elt, x, y);
       if(! c) return c;
       a = xs;
       b = ys;
       continue;
      }
     }
     else if(! b) return 1;
     return 0;
    }
   }
   function equal_list_local(equal_elt_local, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(a){
      if(b){
       var
        ys = b[2],
        y = b[1],
        xs = a[2],
        x = a[1],
        c = caml_call2(equal_elt_local, x, y);
       if(! c) return c;
       a = xs;
       b = ys;
       continue;
      }
     }
     else if(! b) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_option_local(equal_elt_local, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt_local, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   function equal_ref_local(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_bytes,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_bytes,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref,
        compare_bool_local,
        compare_char_local,
        compare_float_local,
        compare_int_local,
        compare_int32_local,
        compare_int64_local,
        compare_nativeint_local,
        compare_string_local,
        compare_bytes_local,
        compare_unit_local,
        compare_array_local,
        compare_list_local,
        compare_option_local,
        compare_ref_local,
        equal_bool_local,
        equal_char_local,
        equal_float_local,
        equal_int_local,
        equal_int32_local,
        equal_int64_local,
        equal_nativeint_local,
        equal_string_local,
        equal_bytes_local,
        equal_unit_local,
        equal_array_local,
        equal_list_local,
        equal_option_local,
        equal_ref_local]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
//# shape: Base__Ppx_hash_lib:[[],[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
//# shape: Base__Sexp:[F(1),F(2),F(1),F(1)*,F(1)*,F(2),F(2),N,N,F(2),N,F(2),F(3),F(2),F(2),F(2),F(1),F(1),N,N,N,F(2),F(2),N,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[5][36], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3
            (Base_Ppx_compare_lib[5][40], compare_local, a_005, b_006);
   }
   function compare(a, b){return compare_local(a, b);}
   function globalize(x_009){
    if(0 === x_009[0]){
     var arg_010 = x_009[1];
     return [0, Base_Globalize[9].call(null, arg_010)];
    }
    var arg_011 = x_009[1];
    return [1, Base_Globalize[13].call(null, globalize, arg_011)];
   }
   var letrec_function_context = [];
   function hash_fold_t(hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = Base_Hash[3].call(null, hsv, 0);
     return caml_call2(Base_Hash[13][7], hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = Base_Hash[3].call(null, hsv, 1);
    return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
   }
   function hash(x){return caml_call1(letrec_function_context[1], x);}
   function func(arg){
    var hsv = Base_Hash[11].call(null, 0, 0), a = hash_fold_t(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   runtime.caml_update_dummy(letrec_function_context, [0, func]);
   var t_sexp_grammar = Sexplib0_Sexp_conv[61];
   function invariant(param){return 0;}
   function equal_local(a, b){return 0 === compare_local(a, b) ? 1 : 0;}
   var
    Base_Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       equal_local,
       compare_local,
       t_sexp_grammar,
       invariant,
       0];
   runtime.caml_register_global(5, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
//# shape: Base__Import:[N,N,N,N,N,N,N,N,N,N,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),F(1)*,F(2),F(1),F(1),F(1),F(4),F(1),N,[F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1)*,N,N,N,N,N,N,F(2)*,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),F(2),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),N,F(1)*,F(2),F(1),F(1),F(1),F(4),F(1),N,[F(2),F(1),F(1),F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(3),F(1)*,F(1),F(1),F(2),F(1),F(1)*->F(1),F(1)*->F(1),F(1)*->F(1),F(2),F(2),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(3)*,F(4)*],[F(1)*],[F(1)*]],F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)*,[F(2)*,F(2)*,F(2),F(2)],F(2)*,F(2)*,F(2),F(2),[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],[F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)],F(2),F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1),F(1)*,F(1),F(1)*,F(1),N,N,N,N,F(2),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(2),F(2),F(2),F(3),F(4),F(2),F(2),F(3),F(1)*,F(1)*,N,N,F(2),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(3),F(4),F(2),F(2),F(3),F(1),F(1),F(2),F(2),N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,N,F(1),F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(2),F(2),F(3),F(2)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    do_domain_local_at_exit = Base_Import0[84],
    Stdlib = Base_Import0[85],
    bool_to_int = Base_Import0[86],
    symbol$0 = Base_Import0[87],
    symbol$1 = Base_Import0[88],
    symbol$2 = Base_Import0[89],
    symbol$3 = Base_Import0[90],
    symbol$4 = Base_Import0[91],
    symbol$5 = Base_Import0[92],
    symbol$6 = Base_Import0[93],
    symbol$7 = Base_Import0[94],
    symbol$8 = Base_Import0[95],
    symbol$9 = Base_Import0[96],
    Int_replace_polymorphic_compar = Base_Import0[97],
    ascending = Base_Import0[98],
    descending = Base_Import0[99],
    max = Base_Import0[100],
    min = Base_Import0[101],
    Int32_replace_polymorphic_comp = Base_Import0[102],
    Int64_replace_polymorphic_comp = Base_Import0[103],
    Nativeint_replace_polymorphic_ = Base_Import0[104],
    Bool_replace_polymorphic_compa = Base_Import0[105],
    Char_replace_polymorphic_compa = Base_Import0[106],
    Uchar_replace_polymorphic_comp = Base_Import0[107],
    Float_replace_polymorphic_comp = Base_Import0[108],
    String_replace_polymorphic_com = Base_Import0[109],
    Bytes_replace_polymorphic_comp = Base_Import0[110],
    symbol$10 = Base_Import0[111],
    symbol_concat = Base_Import0[112],
    symbol$11 = Base_Import0[113],
    symbol$12 = Base_Import0[114],
    asr = Base_Import0[115],
    land = Base_Import0[116],
    lnot = Base_Import0[117],
    lor = Base_Import0[118],
    lsl = Base_Import0[119],
    lsr = Base_Import0[120],
    lxor = Base_Import0[121],
    mod = Base_Import0[122],
    abs = Base_Import0[123],
    failwith = Base_Import0[124],
    fst = Base_Import0[125],
    invalid_arg = Base_Import0[126],
    snd = Base_Import0[127],
    float_of_string = Base_Import0[128],
    am_testing = Base_Import0[129],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    sexp_grammar_with_tags = Sexplib0_Sexp_conv[49],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv[50],
    unit_sexp_grammar = Sexplib0_Sexp_conv[51],
    bool_sexp_grammar = Sexplib0_Sexp_conv[52],
    string_sexp_grammar = Sexplib0_Sexp_conv[53],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[54],
    char_sexp_grammar = Sexplib0_Sexp_conv[55],
    int_sexp_grammar = Sexplib0_Sexp_conv[56],
    float_sexp_grammar = Sexplib0_Sexp_conv[57],
    int32_sexp_grammar = Sexplib0_Sexp_conv[58],
    int64_sexp_grammar = Sexplib0_Sexp_conv[59],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[60],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    ref_sexp_grammar = Sexplib0_Sexp_conv[62],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[63],
    option_sexp_grammar = Sexplib0_Sexp_conv[64],
    list_sexp_grammar = Sexplib0_Sexp_conv[65],
    array_sexp_grammar = Sexplib0_Sexp_conv[66],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[67],
    fun_sexp_grammar = Sexplib0_Sexp_conv[68],
    sexp_of_exn = Sexplib0_Sexp_conv[69],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[70],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[71],
    Exn_converter = Sexplib0_Sexp_conv[72],
    b = Base_Hash[13],
    hash_fold_nativeint = b[1],
    hash_fold_int64 = b[2],
    hash_fold_int32 = b[3],
    hash_fold_char = b[4],
    hash_fold_int = b[5],
    hash_fold_bool = b[6],
    hash_fold_string = b[7],
    hash_fold_float = b[8],
    hash_fold_unit = b[9],
    hash_fold_option = b[10],
    hash_fold_list = b[11],
    hash_fold_lazy_t = b[12],
    hash_fold_ref_frozen = b[13],
    hash_fold_array_frozen = b[14],
    hash_nativeint = b[15],
    hash_int64 = b[16],
    hash_int32 = b[17],
    hash_char = b[18],
    hash_int = b[19],
    hash_bool = b[20],
    hash_string = b[21],
    hash_float = b[22],
    hash_unit = b[23],
    a = Base_Ppx_compare_lib[5],
    compare_bool = a[1],
    compare_char = a[2],
    compare_float = a[3],
    compare_int = a[4],
    compare_int32 = a[5],
    compare_int64 = a[6],
    compare_nativeint = a[7],
    compare_string = a[8],
    compare_bytes = a[9],
    compare_unit = a[10],
    compare_array = a[11],
    compare_list = a[12],
    compare_option = a[13],
    compare_ref = a[14],
    equal_bool = a[15],
    equal_char = a[16],
    equal_float = a[17],
    equal_int = a[18],
    equal_int32 = a[19],
    equal_int64 = a[20],
    equal_nativeint = a[21],
    equal_string = a[22],
    equal_bytes = a[23],
    equal_unit = a[24],
    equal_array = a[25],
    equal_list = a[26],
    equal_option = a[27],
    equal_ref = a[28],
    compare_bool_local = a[29],
    compare_char_local = a[30],
    compare_float_local = a[31],
    compare_int_local = a[32],
    compare_int32_local = a[33],
    compare_int64_local = a[34],
    compare_nativeint_local = a[35],
    compare_string_local = a[36],
    compare_bytes_local = a[37],
    compare_unit_local = a[38],
    compare_array_local = a[39],
    compare_list_local = a[40],
    compare_option_local = a[41],
    compare_ref_local = a[42],
    equal_bool_local = a[43],
    equal_char_local = a[44],
    equal_float_local = a[45],
    equal_int_local = a[46],
    equal_int32_local = a[47],
    equal_int64_local = a[48],
    equal_nativeint_local = a[49],
    equal_string_local = a[50],
    equal_bytes_local = a[51],
    equal_unit_local = a[52],
    equal_array_local = a[53],
    equal_list_local = a[54],
    equal_option_local = a[55],
    equal_ref_local = a[56],
    globalize_bool = Base_Globalize[1],
    globalize_char = Base_Globalize[2],
    globalize_float = Base_Globalize[3],
    globalize_int = Base_Globalize[4],
    globalize_int32 = Base_Globalize[5],
    globalize_int64 = Base_Globalize[6],
    globalize_nativeint = Base_Globalize[7],
    globalize_bytes = Base_Globalize[8],
    globalize_string = Base_Globalize[9],
    globalize_unit = Base_Globalize[10],
    globalize_array = Base_Globalize[11],
    globalize_lazy_t = Base_Globalize[12],
    globalize_list = Base_Globalize[13],
    globalize_option = Base_Globalize[14],
    globalize_result = Base_Globalize[15],
    globalize_ref = Base_Globalize[16],
    Not_found_s = Base_Sexp[8],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol_concat,
       symbol$11,
       symbol$12,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_bytes,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_bytes,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       compare_bool_local,
       compare_char_local,
       compare_float_local,
       compare_int_local,
       compare_int32_local,
       compare_int64_local,
       compare_nativeint_local,
       compare_string_local,
       compare_bytes_local,
       compare_unit_local,
       compare_array_local,
       compare_list_local,
       compare_option_local,
       compare_ref_local,
       equal_bool_local,
       equal_char_local,
       equal_float_local,
       equal_int_local,
       equal_int32_local,
       equal_int64_local,
       equal_nativeint_local,
       equal_string_local,
       equal_bytes_local,
       equal_unit_local,
       equal_array_local,
       equal_list_local,
       equal_option_local,
       equal_ref_local,
       globalize_bool,
       globalize_char,
       globalize_float,
       globalize_int,
       globalize_int32,
       globalize_int64,
       globalize_nativeint,
       globalize_bytes,
       globalize_string,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref,
       Not_found_s];
   runtime.caml_register_global(6, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
//# shape: Base__Word_size:[F(1)*,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    a = [0, "W64"],
    b = [0, "W32"];
   function sexp_of_t(param){return param ? a : b;}
   function num_bits(param){return param ? 64 : 32;}
   var
    match = Base_Sys0[7],
    cst_unknown_word_size = "unknown word size",
    word_size =
      32 === match
       ? 0
       : 64 === match ? 1 : Base_Import[124].call(null, cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
//# shape: Base__Formatter:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
//# shape: Base__Pretty_printer:[F(1)*,F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(Base_Import[112].call(null, M[2], cst_pp));
    return [0, pp];
   }
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var a = caml_call1(M[2], t);
         return Stdlib_Format[13].call(null, formatter, a);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       function(a){return [0, Register_pp(a)[1]];},
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
//# shape: Base__Exn:[F(1),N,N,N,F(1)*,F(1),F(2),F(2),F(2),F(1),F(1),F(3),F(2),F(2),F(1),F(2),F(1),F(1),F(1),[F(1)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[85][99],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    a = [0, "exn.ml.Finally"],
    b = [0, cst_src_exn_ml, 19, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Finally,
     function(param){
      var tag = param[1];
      if(tag !== Finally)
       throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
      var
       arg1_002 = param[3],
       arg0_001 = param[2],
       res0_003 = sexp_of_t(arg0_001),
       res1_004 = sexp_of_t(arg1_002);
      return [1, [0, a, [0, res0_003, [0, res1_004, 0]]]];
     });
   var
    Reraised = [248, "Base__Exn.Reraised", caml_fresh_oo_id(0)],
    c = [0, "exn.ml.Reraised"],
    d = [0, cst_src_exn_ml, 32, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Reraised,
     function(param){
      var tag = param[1];
      if(tag !== Reraised)
       throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
      var
       arg1_006 = param[3],
       arg0_005 = param[2],
       res0_007 = Base_Import[136].call(null, arg0_005),
       res1_008 = sexp_of_t(arg1_006);
      return [1, [0, c, [0, res0_007, [0, res1_008, 0]]]];
     });
   var
    Sexp = [248, "Base__Exn.Sexp", caml_fresh_oo_id(0)],
    e = [0, cst_src_exn_ml, 53, 6];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Sexp,
     function(param){
      var tag = param[1];
      if(tag !== Sexp)
       throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
      var t = param[2];
      return t;
     });
   var f = [0, 2];
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = Stdlib_Printexc[12].call(null, 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    return Base_Printf[4].call
            (null, function(str, param){return reraise(exc, str);}, format);
   }
   function to_string(exc){
    var a = Base_Import[198].call(null, exc);
    return Base_Sexp[16].call(null, f, a);
   }
   function to_string_mach(exc){
    var a = Base_Import[198].call(null, exc);
    return Base_Sexp[17].call(null, a);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = Stdlib_Printexc[12].call(null, 0);
     try{caml_call1(finally$, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$, x);
    return res;
   }
   function protect(f, finally$){return protectx(f, 0, finally$);}
   function does_raise(f){
    try{caml_call1(f, 0); var a = 0; return a;}catch(exn){return 1;}
   }
   function pp(ppf, t){
    var match = Base_Import[200].call(null, t);
    if(match){
     var sexp = match[1];
     return Base_Sexp[12].call(null, ppf, sexp);
    }
    var a = Stdlib_Printexc[1].call(null, t);
    return Stdlib_Format[13].call(null, ppf, a);
   }
   var
    include = Base_Pretty_printer[3].call(null, [0, pp, module_name]),
    pp$0 = include[1],
    g =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    h =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call2(Stdlib_Format[141].call(null, g), pp$0, exc);
    if(Stdlib_Printexc[8].call(null, 0))
     Stdlib_Printexc[13].call(null, Base_Import[85][40], raw_backtrace);
    return Base_Import[85][63].call(null, Base_Import[85][40]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var a = caml_call1(f, 0); return a;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = Stdlib_Printexc[12].call(null, 0);
     if(do_at_exit) try{Base_Import[85][103].call(null, 0);}catch(exn){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(exn){try{Stdlib_Printf[3].call(null, h);}catch(exn){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(a){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var a = caml_call1(func, 0); return a;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = Stdlib_Printexc[12].call(null, 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return Stdlib_Printexc[16].call(null, print_with_backtrace);
   }
   function clear_backtrace(a){
    return runtime.Base_clear_caml_backtrace_pos(a);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(a){return runtime.Base_caml_exn_is_most_recent_exn(a);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
//# shape: Base__With_return:[F(1),F(1),F(2)*->F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_Return = "Return",
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$(a){
     if(1 - is_alive[1])
      Base_Import[124].call(null, cst_use_of_return_from_a_with_);
     return Base_Exn[6].call(null, [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     var tag = exn[1];
     if(tag !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$){
              caml_call1(f, function(a){return caml_call1(return$, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
//# shape: Base__Variant:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
//# shape: Base__Variantslib:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
//# shape: Base__Fn:[F(2)*,F(2),F(1),F(3),F(3),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n$1, f, x$1){
    var n = n$1, x = x$1;
    for(;;){
     if(0 >= n) return x;
     var x$0 = caml_call1(f, x), n$0 = Base_Import[93].call(null, n, 1);
     n = n$0;
     x = x$0;
    }
   }
   var Base_Fn = [0, const$, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
//# shape: Base__Monad_intf:[F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$ = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$ = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$ = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$ = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$ = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$ = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
//# shape: Base__Monad:[F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(M){
    var bind = M[1], return$ = M[3];
    function map_via_bind(ma, f){
     return caml_call2
             (M[1],
              ma,
              function(a){
               var b = caml_call1(f, a);
               return caml_call1(M[3], b);
              });
    }
    var match = M[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var Monad_infix = [0, symbol_bind, symbol_map];
    function both(a, b){
     function f(a){
      function f(b){return [0, a, b];}
      return caml_call2(map, b, f);
     }
     return caml_call2(bind, a, f);
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$, symbol_bind, symbol_map, Let_syntax];
    function join(t){function f(t){return t;} return caml_call2(bind, t, f);}
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$, Base_List0[19].call(null, vs));
     var ts = param[2], t = param[1];
     function f(v){return loop([0, v, vs], ts);}
     return caml_call2(bind, t, f);
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$, 0);
     var ts = param[2], t = param[1];
     function f(param){return all_unit(ts);}
     return caml_call2(bind, t, f);
    }
    return [0,
            bind,
            return$,
            ,
            map,
            Monad_infix,
            symbol_bind,
            symbol_map,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$ = M[3],
     a = Make_general([0, bind, map, return$]);
    return [0,
            a[6],
            a[7],
            a[8],
            a[5],
            a[1],
            a[2],
            a[4],
            a[9],
            a[10],
            a[11],
            a[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$ = M[3],
     a = Make_general([0, bind, map, return$]);
    return [0,
            a[6],
            a[7],
            a[8],
            a[5],
            a[1],
            a[2],
            a[4],
            a[9],
            a[10],
            a[11],
            a[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$ = M[3],
     a = Make_general([0, bind, map, return$]);
    return [0,
            a[6],
            a[7],
            a[8],
            a[5],
            a[1],
            a[2],
            a[4],
            a[9],
            a[10],
            a[11],
            a[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$ = M[2],
     map = M[3],
     a = Make_general([0, bind, map, return$]);
    return [0,
            a[6],
            a[7],
            a[5],
            a[1],
            a[2],
            a[4],
            a[9],
            a[10],
            a[11],
            a[12],
            a[8]];
   }
   function Make2_local(M){
    var bind = M[1], return$ = M[3];
    function map_via_bind(ma, f){
     var
      res =
        caml_call2
         (M[1],
          ma,
          function(a){var b = caml_call1(f, a); return caml_call1(M[3], b);});
     return res;
    }
    var match = M[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var Monad_infix = [0, symbol_bind, symbol_map];
    function both(a, b){
     var
      res =
        caml_call2
         (bind,
          a,
          function(a){
           var res = caml_call2(map, b, function(b){return [0, a, b];});
           return res;
          });
     return res;
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$, symbol_bind, symbol_map, Let_syntax];
    function join(t){function f(a){return a;} return caml_call2(bind, t, f);}
    function ignore_m(t){
     var res = caml_call2(map, t, function(param){return 0;});
     return res;
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$, Base_List0[19].call(null, vs));
     var ts = param[2], t = param[1];
     function f(v){return loop([0, v, vs], ts);}
     return caml_call2(bind, t, f);
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$, 0);
     var ts = param[2], t = param[1];
     function f(param){return all_unit(ts);}
     return caml_call2(bind, t, f);
    }
    return [0,
            bind,
            return$,
            ,
            map,
            Monad_infix,
            symbol_bind,
            symbol_map,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_local(M){
    var
     bind = M[1],
     return$ = M[2],
     map = M[3],
     a = Make2_local([0, bind, map, return$]);
    return [0,
            a[6],
            a[7],
            a[5],
            a[1],
            a[2],
            a[4],
            a[9],
            a[10],
            a[11],
            a[12],
            a[8]];
   }
   function Of_monad_general(Monad, M){
    function return$(a){
     var b = caml_call1(Monad[3], a);
     return caml_call1(M[2], b);
    }
    function bind(t, f){
     var
      a = caml_call1(M[1], t),
      b =
        caml_call2
         (Monad[1],
          a,
          function(a){var b = caml_call1(f, a); return caml_call1(M[1], b);});
     return caml_call1(M[2], b);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var a = caml_call1(M[1], t), b = caml_call2(Monad[2], a, f);
         return caml_call1(M[2], b);
        }];
    return Make_general([0, bind, map, return$]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function map(a, f){return caml_call1(f, a);}
   function symbol_map(a, f){return caml_call1(f, a);}
   function symbol_bind(a, f){return caml_call1(f, a);}
   function return$(a){return a;}
   function both(a, b){return [0, a, b];}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$, bind, map, both, Open_on_rhs],
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       Make_local,
       function(b){
        var a = Make2_local(b);
        return [0,
                a[6],
                a[7],
                a[8],
                a[5],
                a[1],
                a[2],
                a[4],
                a[9],
                a[10],
                a[11],
                a[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$ = Monad[5],
         map = Monad[6],
         a =
           Of_monad_general([0, bind, map, return$], [0, to_monad, of_monad]);
        return [0,
                a[6],
                a[7],
                a[5],
                a[1],
                a[2],
                a[4],
                a[9],
                a[10],
                a[11],
                a[12],
                a[8]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$ = Monad[6],
         map = Monad[7],
         a =
           Of_monad_general([0, bind, map, return$], [0, to_monad, of_monad]);
        return [0,
                a[6],
                a[7],
                a[8],
                a[5],
                a[1],
                a[2],
                a[4],
                a[9],
                a[10],
                a[11],
                a[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$ = Monad[6],
         map = Monad[7],
         a =
           Of_monad_general([0, bind, map, return$], [0, to_monad, of_monad]);
        return [0,
                a[6],
                a[7],
                a[8],
                a[5],
                a[1],
                a[2],
                a[4],
                a[9],
                a[10],
                a[11],
                a[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$ = Monad[6],
         map = Monad[7],
         a =
           Of_monad_general([0, bind, map, return$], [0, to_monad, of_monad]);
        return [0,
                a[6],
                a[7],
                a[8],
                a[5],
                a[1],
                a[2],
                a[4],
                a[9],
                a[10],
                a[11],
                a[12]];
       },
       [0,
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        bind,
        function(a){return a;},
        map,
        function(a){return a;},
        function(a){return 0;},
        function(a){return a;},
        function(a){return 0;},
        [0, return$, symbol_bind, symbol_map, Let_syntax]]];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
//# shape: Base__T:[]
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
//# shape: Base__Applicative_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
//# shape: Base__Applicative:[[N,N,N,N,N,N,N,N,N,N,N,N,N],F(2)*,F(1)*,F(2)*,F(3)*,F(1)*,F(1)*,F(1)*,F(1)*,F(3)*,F(3)*,F(3)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(T, X){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(T, X){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S(T1, T2, X){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(include){
    var return$ = include[1], symbol = include[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$, f), t);
    }
    var match = include[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     function b(x, xs){return [0, x, xs];}
     var a = caml_call1(return$, 0);
     return Base_List0[20].call
             (null,
              ts,
              function(a){return function(c){return map2(a, c, b);};},
              a);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol, caml_call1(return$, function(param, y){return y;}), u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol, caml_call1(return$, function(x, param){return x;}), u),
              v);
    }
    function all_unit(ts){
     var a = caml_call1(return$, 0);
     return Base_List0[8].call(null, ts, a, symbol$0);
    }
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$ = X[1], apply = X[2], map = X[3];
    return Make3([0, return$, apply, map]);
   }
   function Make(X){
    var return$ = X[1], apply = X[2], map = X[3];
    return Make2([0, return$, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$ = X[1],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$0 = X[1],
     map = X[2],
     both = X[3],
     Let_syntax = [0, return$0, map, both, , , , , Impl],
     Let_syntax$0 =
       [0, return$, , , symbol, symbol$0, symbol$1, symbol_map, Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$ = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(include){
    var return$ = include[1], map2 = include[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$, f), t);}
    var match = include[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     return caml_call3
             (map2,
              caml_call3(map2, ta, tb, f),
              tc,
              function(fab, c){return caml_call1(fab, c);});
    }
    function all(ts){
     function b(x, xs){return [0, x, xs];}
     var a = caml_call1(return$, 0);
     return Base_List0[20].call
             (null,
              ts,
              function(c){
               var a = caml_call1(map2, c);
               return function(c){return caml_call2(a, c, b);};
              },
              a);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var a = caml_call1(return$, 0);
     return Base_List0[8].call(null, ts, a, symbol$0);
    }
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$ = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$, map2, map]);
   }
   function Make_using_map2(X){
    var return$ = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$, map2, map]);
   }
   function Make3_using_map2_local(include){
    var return$ = include[1], map2 = include[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){
     return caml_call3
             (map2, caml_call1(return$, 0), t, function(param){return f;});
    }
    var match = include[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var map$0 = match[2], map = map$0;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     var
      res =
        caml_call3
         (map2,
          both(ta, tb),
          tc,
          function(param, c){
           var b = param[2], a = param[1];
           return caml_call3(f, a, b, c);
          });
     return res;
    }
    function all(ts){
     function b(x, xs){return [0, x, xs];}
     var a = caml_call1(return$, 0);
     return Base_List0[20].call
             (null,
              ts,
              function(c){
               var a = caml_call1(map2, c);
               return function(c){return caml_call2(a, c, b);};
              },
              a);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var a = caml_call1(return$, 0);
     return Base_List0[8].call(null, ts, a, symbol$0);
    }
    return [0,
            return$,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2_local(X){
    var return$ = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2_local([0, return$, map2, map]);
   }
   function Make_using_map2_local(X){
    var return$ = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2_local([0, return$, map2, map]);
   }
   function Of_monad2(M){
    var return$ = M[6];
    function apply(mf, mx){
     return caml_call2(M[5], mf, function(f){return caml_call2(M[7], mx, f);});
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$ = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$(a){
     var b = caml_call1(F[1], a);
     return caml_call1(G[1], b);
    }
    function apply(tf, tx){
     var a = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], a, tx);
    }
    function custom_map(t, f){
     var a = F[2];
     return caml_call2(G[2], t, function(b){return caml_call2(a, b, f);});
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$, apply, map]),
     return$0 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$0,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$(a){
     var b = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), b];
    }
    function apply(tf, tx){
     var
      a = Base_Import[127].call(null, tx),
      b = Base_Import[127].call(null, tf),
      c = caml_call2(G[8], b, a),
      d = Base_Import[125].call(null, tx),
      e = Base_Import[125].call(null, tf);
     return [0, caml_call2(F[8], e, d), c];
    }
    function custom_map(t, f){
     var
      a = Base_Import[127].call(null, t),
      b = caml_call2(G[2], a, f),
      c = Base_Import[125].call(null, t);
     return [0, caml_call2(F[2], c, f), b];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$, apply, map]),
     return$0 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$0,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function return$(a){return a;}
   function map2(a, b, f){return caml_call2(f, a, b);}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make_using_map2_local([0, return$, map2, map]),
    return$0 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply = include[8],
    map2$0 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    Ident =
      [0,
       return$0,
       map$0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       symbol_map,
       apply,
       map2$0,
       map3,
       all,
       all_unit,
       Applicative_infix],
    Base_Applicative =
      [0,
       Ident,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S3_to_S,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$ = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         a =
           Make_let_syntax2
             ([0, return$, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         b = a[8];
        return [0,
                [0, a[1], a[4], a[5], a[6], a[7], [0, b[1], b[2], b[3], b[8]]]];
       },
       function(e, d, c){
        var a = Make_let_syntax2(e, d, c)[1], b = a[8];
        return [0,
                [0, a[1], a[4], a[5], a[6], a[7], [0, b[1], b[2], b[3], b[8]]]];
       },
       function(e, d, c){
        var a = Make_let_syntax3(e, d, c)[1], b = a[8];
        return [0,
                [0, a[1], a[4], a[5], a[6], a[7], [0, b[1], b[2], b[3], b[8]]]];
       },
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Make_using_map2_local,
       Make2_using_map2_local,
       Make3_using_map2_local,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
//# shape: Base__Comparator:[F(2)*,[N],[],F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0];
   function of_module(M){return M[1];}
   function to_module(t){return [0, t];}
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare, a = [0, "_"];
   function sexp_of_t(param){return a;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var b = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), b];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var c = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), c];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var b = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), b];
    }
    return [0, comparator];
   }
   function Derived2_phantom(M){
    function comparator(a, b){
     var c = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), c];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       of_module,
       to_module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom,
       Derived2_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
//# shape: Base__Comparisons:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
//# shape: Base__Either0:[F(4),F(4),F(4),F(3),F(3),F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_017 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    a = [0, cst_First$0],
    b = [0, cst_Second$0],
    cst_Second = cst_Second$0,
    cst_First = cst_First$0;
   function compare_local(cmp_f, cmp_s, a_007, b_008){
    if(a_007 === b_008) return 0;
    if(0 === a_007[0]){
     var a_009 = a_007[1];
     if(0 !== b_008[0]) return -1;
     var b_010 = b_008[1];
     return caml_call2(cmp_f, a_009, b_010);
    }
    var a_011 = a_007[1];
    if(0 === b_008[0]) return 1;
    var b_012 = b_008[1];
    return caml_call2(cmp_s, a_011, b_012);
   }
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = Base_Hash[3].call(null, hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = Base_Hash[3].call(null, hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_013, of_s_014, sexp_019){
    a:
    {
     if(0 === sexp_019[0]){
      var a = sexp_019[1];
      b:
      if(a !== cst_First$0){
       if(a !== cst_Second$0){
        if(a === cst_first) break b;
        if(a !== cst_second) break a;
       }
       return Sexplib0_Sexp_conv_error[9].call
               (null, error_source_017, sexp_019);
      }
      return Sexplib0_Sexp_conv_error[9].call
              (null, error_source_017, sexp_019);
     }
     var match = sexp_019[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_017, sexp_019);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_017, sexp_019);
     var tag_020 = match$0[1];
     b:
     if(tag_020 !== cst_First$0){
      if(tag_020 !== cst_Second$0){
       if(tag_020 === cst_first) break b;
       if(tag_020 !== cst_second) break a;
      }
      var sexp_args_026 = match[2];
      if(sexp_args_026 && ! sexp_args_026[2]){
       var
        arg0_027 = sexp_args_026[1],
        res0_028 = caml_call1(of_s_014, arg0_027);
       return [1, res0_028];
      }
      return Sexplib0_Sexp_conv_error[8].call
              (null, error_source_017, tag_020, sexp_019);
     }
     var sexp_args_021 = match[2];
     if(sexp_args_021 && ! sexp_args_021[2]){
      var
       arg0_022 = sexp_args_021[1],
       res0_023 = caml_call1(of_f_013, arg0_022);
      return [0, res0_023];
     }
     return Sexplib0_Sexp_conv_error[8].call
             (null, error_source_017, tag_020, sexp_019);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_017, sexp_019);
   }
   function sexp_of_t(of_f_031, of_s_032, param){
    if(0 === param[0]){
     var arg0_033 = param[1], res0_034 = caml_call1(of_f_031, arg0_033);
     return [1, [0, a, [0, res0_034, 0]]];
    }
    var arg0_035 = param[1], res0_036 = caml_call1(of_s_032, arg0_035);
    return [1, [0, b, [0, res0_036, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0,
       compare_local,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar];
   runtime.caml_register_global(15, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
//# shape: Base__Field:[[F(1)*],F(1)*,F(2),F(3),F(1)*,F(3),F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(a){return a;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var a = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, a);
   }
   function updater(param){
    var match = param[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(param[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Base__Import, Base__Int0, Base__Printf, Base__Sys0, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint
//# shape: Base__Int_conversions:[F(1),F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1),F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1)*,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    a =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"];
   function convert_failure(x, a$0, b, to_string){
    var c = caml_call1(to_string, x);
    return caml_call4(Base_Printf[6].call(null, a), a$0, b, c, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = Base_Word_size[2].call(null, Base_Word_size[3]),
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    b = caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    g = [0, cst_src_int_conversions_ml, 19, 9],
    f = [0, cst_src_int_conversions_ml, 82, 9],
    e = [0, cst_src_int_conversions_ml, 103, 9],
    d = [0, cst_src_int_conversions_ml, 155, 9],
    c = [0, cst_src_int_conversions_ml, 183, 9],
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int_to_string = Base_Import[85][33],
    int32_to_string = Stdlib_Int32[14],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15];
   function int32_to_int_trunc(a){return a;}
   function int_to_int32_trunc(a){return a;}
   if(num_bits_int <= 32)
    var int_is_representable_as_int32 = function(param){return 1;};
   else
    var
     min$6 = min_int32,
     max$6 = max_int32,
     int_is_representable_as_int32 =
       function(x){
        var
         a = caml_call2(Base_Import[228], min$6, x) <= 0 ? 1 : 0,
         b = a ? caml_call2(Base_Import[228], x, max$6) <= 0 ? 1 : 0 : a;
        return b;
       };
   if(32 <= num_bits_int)
    var int32_is_representable_as_int = function(param){return 1;};
   else
    var
     min$5 = Base_Int0[7],
     max$5 = Base_Int0[6],
     int32_is_representable_as_int =
       function(x){
        var
         a = caml_call2(Base_Import[229], min$5, x) <= 0 ? 1 : 0,
         b = a ? caml_call2(Base_Import[229], x, max$5) <= 0 ? 1 : 0 : a;
        return b;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){
    return int32_is_representable_as_int(x) ? [0, x] : 0;
   }
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, int_to_string);
   }
   function int32_to_int_exn(x){
    return int32_is_representable_as_int(x)
            ? x
            : convert_failure(x, cst_int32$0, cst_int$0, int32_to_string);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min$4 = caml_int64_of_int32(Base_Int0[7]),
    max$4 = caml_int64_of_int32(Base_Int0[6]);
   function int64_is_representable_as_int(x){
    var
     a = caml_call2(Base_Import[230], min$4, x) <= 0 ? 1 : 0,
     b = a ? caml_call2(Base_Import[230], x, max$4) <= 0 ? 1 : 0 : a;
    return b;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (runtime.caml_int64_add(x, b),
               cst_int64,
               cst_int$1,
               int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   function int_to_nativeint(a){return a;}
   function nativeint_to_int_trunc(a){return a;}
   if(num_bits_nativeint <= num_bits_int)
    var nativeint_is_representable_as_ = function(param){return 1;};
   else
    var
     min$3 = Base_Int0[7],
     max$3 = Base_Int0[6],
     nativeint_is_representable_as_ =
       function(x){
        var
         a = caml_call2(Base_Import[231], min$3, x) <= 0 ? 1 : 0,
         b = a ? caml_call2(Base_Import[231], x, max$3) <= 0 ? 1 : 0 : a;
        return b;
       };
   function nativeint_to_int(x){
    return nativeint_is_representable_as_(x) ? [0, x] : 0;
   }
   function nativeint_to_int_exn(x){
    return nativeint_is_representable_as_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$2 = caml_int64_of_int32(min_int32),
    max$2 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     a = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
     b = a ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : a;
    return b;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
   function int32_to_nativeint(a){return a;}
   function nativeint_to_int32_trunc(a){return a;}
   if(num_bits_nativeint <= 32)
    var nativeint_is_representable_as_$0 = function(param){return 1;};
   else
    var
     min$1 = min_int32,
     max$1 = max_int32,
     nativeint_is_representable_as_$0 =
       function(x){
        var
         a = caml_call2(Base_Import[231], min$1, x) <= 0 ? 1 : 0,
         b = a ? caml_call2(Base_Import[231], x, max$1) <= 0 ? 1 : 0 : a;
        return b;
       };
   function nativeint_to_int32(x){
    return nativeint_is_representable_as_$0(x) ? [0, x] : 0;
   }
   function nativeint_to_int32_exn(x){
    return nativeint_is_representable_as_$0(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$0 = caml_int64_of_int32(min_nativeint),
     max$0 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         a = caml_call2(Base_Import[230], min$0, x) <= 0 ? 1 : 0,
         b = a ? caml_call2(Base_Import[230], x, max$0) <= 0 ? 1 : 0 : a;
        return b;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min = caml_int64_shift_right(min_int64, 1),
    max = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     a = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     b = a ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : a;
    return b;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   var
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint];
   runtime.caml_register_global
    (33, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
//# shape: Base__Uchar0:[F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1)*,F(1)*,F(2)*,F(2)*,N,N,N,N,F(1),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    byte_order_mark = Stdlib_Uchar[3],
    replacement_char = Stdlib_Uchar[4],
    utf_8_byte_length = Stdlib_Uchar[23],
    utf_16_byte_length = Stdlib_Uchar[24],
    utf_decode_is_valid = Stdlib_Uchar[18],
    utf_decode_uchar = Stdlib_Uchar[19],
    utf_decode_length = Stdlib_Uchar[20],
    utf_decode = Stdlib_Uchar[21],
    utf_decode_invalid = Stdlib_Uchar[22],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       utf_8_byte_length,
       utf_16_byte_length,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Char0, Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib, Stdlib__StringLabels
//# shape: Base__String0:[[],N,F(2)*,F(1),F(2)*,F(1),F(1),F(2),F(3),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Import0 = global_data.Base__Import0,
    Base_Char0 = global_data.Base__Char0,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Base_Sys0 = global_data.Base__Sys0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol_concat = Base_Import0[112],
    capitalize = Stdlib_StringLabels[28],
    compare = Stdlib_StringLabels[10],
    escaped = Stdlib_StringLabels[25],
    lowercase = Stdlib_StringLabels[27],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[16],
    uncapitalize = Stdlib_StringLabels[29],
    uppercase = Stdlib_StringLabels[26],
    is_valid_utf_8 = Stdlib_StringLabels[44],
    is_valid_utf_16le = Stdlib_StringLabels[48],
    is_valid_utf_16be = Stdlib_StringLabels[46],
    cst_index_out_of_bounds = "index out of bounds",
    dummy = 0;
   function get_utf_8_uchar(t, byte_pos){
    return Stdlib_StringLabels[43].call(null, t, byte_pos);
   }
   function get_utf_16le_uchar(t, byte_pos){
    return Stdlib_StringLabels[47].call(null, t, byte_pos);
   }
   function get_utf_16be_uchar(t, byte_pos){
    return Stdlib_StringLabels[45].call(null, t, byte_pos);
   }
   function get_utf_32_uchar(get_int32, t, byte_pos){
    var
     len = caml_ml_string_length(t),
     a = 0 <= byte_pos ? 1 : 0,
     match = a ? byte_pos < len ? 1 : 0 : a;
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_index_out_of_bounds], 1);
    var bytes_read = Base_Import0[93].call(null, len, byte_pos);
    if(2 >= bytes_read - 1 >>> 0)
     return Base_Uchar0[22].call(null, bytes_read);
    var int32 = caml_call2(get_int32, t, byte_pos);
    if(! Base_Int_conversions[11].call(null, int32))
     return Base_Uchar0[22].call(null, 4);
    var int = Base_Int_conversions[8].call(null, int32);
    if(! Base_Uchar0[3].call(null, int)) return Base_Uchar0[22].call(null, 4);
    var b = Base_Uchar0[6].call(null, int);
    return Base_Uchar0[21].call(null, 4, b);
   }
   function get_utf_32le_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[61], t, byte_pos);
   }
   function get_utf_32be_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[60], t, byte_pos);
   }
   function concat(opt, l){
    var sep = opt ? opt[1] : cst$0;
    if(! l) return cst;
    if(l[2]) return Stdlib_StringLabels[7].call(null, sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){
    var a = Base_Import0[93].call(null, caml_ml_string_length(t), 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call1(f, runtime.caml_string_unsafe_get(t, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var b = caml_string_get(t, Base_Import0[93].call(null, pos[1], 1));
      if(Base_Char0[12].call(null, b, 13)){var a = 2; break a;}
     }
     var a = 1;
    }
    pos[1] = Base_Import0[93].call(null, pos[1], a);
    eol[1] = Base_Import0[91].call(null, pos[1], 1);
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, Base_Import0[93].call(null, n, 1)],
     eol = [0, n],
     ac = [0, 0],
     a = caml_string_get(t, pos[1]);
    if(Base_Char0[12].call(null, a, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var d = ac[1]; return [0, sub(t, 0, eol[1]), d];}
     var b = caml_string_get(t, pos[1]);
     if(Base_Char0[12].call(null, b, 10)){
      var start = Base_Import0[91].call(null, pos[1], 1), c = ac[1];
      ac[1] =
       [0, sub(t, start, Base_Import0[93].call(null, eol[1], start)), c];
      back_up_at_newline(t, pos, eol);
     }
     else
      pos[1]--;
    }
   }
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol_concat,
       capitalize,
       compare,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       uppercase,
       is_valid_utf_8,
       is_valid_utf_16le,
       is_valid_utf_16be,
       get_utf_8_uchar,
       get_utf_16le_uchar,
       get_utf_16be_uchar,
       get_utf_32le_uchar,
       get_utf_32be_uchar,
       concat,
       iter,
       split_lines];
   runtime.caml_register_global(10, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__String0
//# shape: Base__Source_code_position0:[[F(2),F(2),F(2),F(1),F(1)*],F(2),F(2),F(2),F(1),N,F(4),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Comparator = global_data.Base__Comparator,
    a = [0, "pos_cnum"],
    b = [0, "pos_bol"],
    c = [0, "pos_lnum"],
    d = [0, "pos_fname"];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    var n = caml_call2(Base_Import[260], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[256], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[256], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[256], a_001[4], b_002[4]) : n$1;
   }
   function compare(a, b){return compare_local(a, b);}
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = Base_Hash[11].call(null, 0, 0), a = hash_fold_t(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = Base_Import[139].call(null, pos_cnum_010),
     bnds_003 = [0, [1, [0, a, [0, arg_011, 0]]], 0],
     arg_009 = Base_Import[139].call(null, pos_bol_008),
     bnds_003$0 = [0, [1, [0, b, [0, arg_009, 0]]], bnds_003],
     arg_007 = Base_Import[139].call(null, pos_lnum_006),
     bnds_003$1 = [0, [1, [0, c, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = Base_Import[136].call(null, pos_fname_004),
     bnds_003$2 = [0, [1, [0, d, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare_local, compare, hash_fold_t, hash, sexp_of_t],
    include = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     a = Base_Import[93].call(null, pos_cnum, pos_bol),
     b = [0, cst, [0, Base_Int0[1].call(null, a), 0]],
     c = [0, pos_fname, [0, cst$0, [0, Base_Int0[1].call(null, pos_lnum), b]]];
    return Base_String0[20].call(null, 0, c);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare_local,
       compare,
       hash_fold_t,
       hash,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (11, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
//# shape: Base__Invariant_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
//# shape: Base__List1:[F(1),F(2),F(1),F(1),F(1),F(2),F(3),F(3),F(4),F(2),F(3),F(2),F(3),F(2),F(2),F(2),F(2),F(3),F(1),F(3),F(4),F(1)*,F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    rev_append = Base_List0[2],
    tl_exn = Base_List0[3],
    unzip = Base_List0[4],
    length = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    rev = Base_List0[19],
    fold_right = Base_List0[20],
    fold_right2_ok = Base_List0[21];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){var a = rev(snd); return [0, rev(fst), a];}
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0]){
      var y = match[1], fst$0 = [0, y, fst];
      t$0 = t$1;
      fst = fst$0;
     }
     else{var y$0 = match[1], snd$0 = [0, y$0, snd]; t$0 = t$1; snd = snd$0;}
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Printf, Sexplib0__Sexp_conv_error
//# shape: Base__Result:[F(3),F(3),F(2)*,F(4),F(4),F(4),F(4),F(4),F(3),N,N,N,N,N,N,N,N,N,N,N,F(3),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1)*,F(2)*,F(2),F(2),N,F(2),F(4),F(1),F(1),F(1)*,F(1)*,F(2)*,F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    a = [0, cst_Ok$0],
    b = [0, cst_Error$0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0;
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var a = sexp_007[1];
      b:
      if(a !== cst_Error$0){
       if(a !== cst_Ok$0){
        if(a === cst_error) break b;
        if(a !== cst_ok) break a;
       }
       return Sexplib0_Sexp_conv_error[9].call
               (null, error_source_005, sexp_007);
      }
      return Sexplib0_Sexp_conv_error[9].call
              (null, error_source_005, sexp_007);
     }
     var match = sexp_007[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_005, sexp_007);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_005, sexp_007);
     var tag_008 = match$0[1];
     b:
     if(tag_008 !== cst_Error$0){
      if(tag_008 !== cst_Ok$0){
       if(tag_008 === cst_error) break b;
       if(tag_008 !== cst_ok) break a;
      }
      var sexp_args_009 = match[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return Sexplib0_Sexp_conv_error[8].call
              (null, error_source_005, tag_008, sexp_007);
     }
     var sexp_args_014 = match[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return Sexplib0_Sexp_conv_error[8].call
             (null, error_source_005, tag_008, sexp_007);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, a, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, b, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare_local(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 0;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return -1;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 1;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(a_027 === b_028) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal_local(cmp_a, cmp_b, a_045, b_046){
    if(a_045 === b_046) return 1;
    if(0 === a_045[0]){
     var a_047 = a_045[1];
     if(0 !== b_046[0]) return 0;
     var b_048 = b_046[1];
     return caml_call2(cmp_a, a_047, b_048);
    }
    var a_049 = a_045[1];
    if(0 === b_046[0]) return 0;
    var b_050 = b_046[1];
    return caml_call2(cmp_b, a_049, b_050);
   }
   function equal(cmp_a, cmp_b, a_039, b_040){
    if(a_039 === b_040) return 1;
    if(0 === a_039[0]){
     var a_041 = a_039[1];
     if(0 !== b_040[0]) return 0;
     var b_042 = b_040[1];
     return caml_call2(cmp_a, a_041, b_042);
    }
    var a_043 = a_039[1];
    if(0 === b_040[0]) return 0;
    var b_044 = b_040[1];
    return caml_call2(cmp_b, a_043, b_044);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = Base_Hash[3].call(null, hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = Base_Hash[3].call(null, hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   var globalize = Base_Import[295];
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$(x){return [0, x];}
   var
    include = Base_Monad[6].call(null, [0, bind, map, return$]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$0 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return Base_Printf[4].call(null, fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$1(e){return [1, e];}
   var
    Error = Base_Monad[6].call(null, [0, bind$1, map$1, return$1]),
    c = [0, 0];
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? c : [1, error];}
   function try_with(f){
    try{var a = [0, caml_call1(f, 0)]; return a;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return Base_Import[124].call(null, str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = Base_List1[23].call(null, l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    return caml_call2(map$0, combine_errors(l), function(param){return 0;});
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       equal,
       equal_local,
       hash_fold_t,
       globalize,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(20, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
//# shape: Base__Container_intf:[[[]],[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Base_Container_intf = [0, Export, Continue_or_stop];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
//# shape: Base__Container:[F(3),F(3),F(3),F(3),F(2),F(2),F(4),F(4),F(5),F(2),F(4),F(3),F(3),F(3),F(3),F(3),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_List0 = global_data.Base__List0,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? Base_Import[91].call(null, n, 1) : n;
             });
   }
   function sum(fold, M, t, f){
    return caml_call3
            (fold,
             t,
             M[1],
             function(n, a){
              var b = caml_call1(f, a);
              return caml_call2(M[2], n, b);
             });
   }
   function fold_result(fold, init, f, t){
    return with_return
            (function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return with_return
            (function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return Base_Import[91].call(null, acc, 1);});
   }
   function is_empty(iter, c){
    return with_return
            (function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function mem(iter, c, x, equal){
    return with_return
            (function(r){
              caml_call2
               (iter,
                c,
                function(y){
                 var a = caml_call2(equal, x, y);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function exists(iter, c, f){
    return with_return
            (function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var a = caml_call1(f, x);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return with_return
            (function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var a = 1 - caml_call1(f, x);
                 return a ? caml_call1(r, 0) : a;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return with_return
            (function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return with_return
            (function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var a = caml_call1(f, x);
                 return a ? caml_call1(r, [0, x]) : a;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var a = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return Base_List0[19].call(null, a);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var b = caml_call1(length, c);
        array[1] = Base_Array0[4].call(null, b, x);
       }
       var a = i[1];
       runtime.caml_check_bound(array[1], a)[a + 1] = x;
       i[1]++;
       return 0;
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function mem$0(t, x, equal){return mem(iter$0, t, x, equal);}
    function sum$0(m, t){return function(a){return sum(fold, m, t, a);};}
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            mem$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function Make_gen_with_creators(T){
    var
     include = Make_gen([0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     concat_of_array = T[7];
    function append(a, b){
     return caml_call1(concat, caml_call1(concat_of_array, [0, a, b]));
    }
    function concat_map(t, f){
     var a = caml_call1(to_array, t);
     return caml_call1
             (concat,
              caml_call1(concat_of_array, Base_Array0[21].call(null, a, f)));
    }
    function filter_map(t, f){
     return concat_map
             (t,
              function(x){
               var match = caml_call1(f, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function map(t, f){
     return filter_map(t, function(x){return [0, caml_call1(f, x)];});
    }
    function filter(t, f){
     return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
    }
    function partition_map(t, f){
     var
      a = caml_call1(to_array, t),
      array = Base_Array0[21].call(null, a, f),
      xs =
        Base_Array0[18].call
         (null,
          array,
          function(either, acc){
           if(0 !== either[0]) return acc;
           var x = either[1];
           return [0, x, acc];
          },
          0),
      ys =
        Base_Array0[18].call
         (null,
          array,
          function(either, acc){
           if(0 === either[0]) return acc;
           var x = either[1];
           return [0, x, acc];
          },
          0),
      b = caml_call1(of_list, ys);
     return [0, caml_call1(of_list, xs), b];
    }
    function partition_tf(t, f){
     return partition_map
             (t, function(x){return caml_call1(f, x) ? [0, x] : [1, x];});
    }
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       mem,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         a = include[3];
        function mem(t, x){return caml_call3(a, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       Make_gen,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         of_list = T[4],
         of_array = T[5],
         concat = T[6],
         include =
           Make_gen_with_creators
            ([0, fold, iter, length, of_list, of_array, concat, of_array]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         of_list$0 = include[18],
         of_array$0 = include[19],
         append = include[20],
         concat$0 = include[21],
         map = include[22],
         filter = include[23],
         filter_map = include[24],
         concat_map = include[25],
         partition_tf = include[26],
         partition_map = include[27];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         of_list = T[5],
         of_array = T[6],
         concat = T[7],
         concat_of_array = Base_Array0[16],
         include =
           Make_gen_with_creators
            ([0,
              fold,
              iter,
              length,
              of_list,
              of_array,
              concat,
              concat_of_array]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         of_list$0 = include[18],
         of_array$0 = include[19],
         append = include[20],
         concat$0 = include[21],
         map = include[22],
         filter = include[23],
         filter_map = include[24],
         concat_map = include[25],
         partition_tf = include[26],
         partition_map = include[27],
         a = include[3];
        function mem(t, x){return caml_call3(a, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map];
       },
       Make_gen_with_creators];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
//# shape: Base__Indexed_container_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Array0, Base__Container, Base__Import, Base__Indexed_container_intf, Base__With_return
//# shape: Base__Indexed_container:[F(4),F(3),F(3),F(3),F(3),F(3),F(3),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Container = global_data.Base__Container,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold,
      t,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return Base_Import[91].call(null, i, 1);
      });
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = Base_Import[91].call(null, i[1], 1);
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){
              return caml_call2(f, i, a)
                      ? Base_Import[91].call(null, n, 1)
                      : n;
             });
   }
   function existsi(iteri, c, f){
    return with_return
            (function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var a = caml_call2(f, i, x);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return with_return
            (function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var a = 1 - caml_call2(f, i, x);
                 return a ? caml_call1(r, 0) : a;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return with_return
            (function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return with_return
            (function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var a = caml_call2(f, i, x);
                 return a ? caml_call1(r, [0, [0, i, x]]) : a;
                });
              return 0;
             });
   }
   function Make_gen_with_container(T, include){
    var
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function Make_gen(T){
    var
     C = Base_Container[19].call(null, [0, T[1], T[2], T[3]]),
     include = Make_gen_with_container(T, C),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   function Make_gen_with_creators(T){
    var
     C =
       Base_Container[22].call
        (null, [0, T[5], T[6], T[7], T[2], T[3], T[4], T[1]]),
     of_list = C[18],
     of_array = C[19],
     append = C[20],
     concat = C[21],
     map = C[22],
     filter = C[23],
     filter_map = C[24],
     concat_map = C[25],
     partition_tf = C[26],
     partition_map = C[27],
     include =
       Make_gen_with_container
        ([0, T[5], T[6], T[7], T[8], T[9]],
         [0,
          C[1],
          C[2],
          C[3],
          C[4],
          C[5],
          C[6],
          C[7],
          C[8],
          C[9],
          C[10],
          C[11],
          C[12],
          C[13],
          C[14],
          C[15],
          C[16],
          C[17]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    function derived_init(n, f){
     return caml_call1(of_array, Base_Array0[12].call(null, n, f));
    }
    var match = T[10];
    if(typeof match === "number")
     var init = derived_init;
    else
     var init$0 = match[2], init = init$0;
    function derived_concat_mapi(t, f){
     var a = caml_call1(to_array, t), b = Base_Array0[22].call(null, a, f);
     return caml_call1(concat, caml_call1(T[1], b));
    }
    var match$0 = T[11];
    if(typeof match$0 === "number")
     var concat_mapi = derived_concat_mapi;
    else
     var concat_mapi$0 = match$0[2], concat_mapi = concat_mapi$0;
    function filter_mapi(t, f){
     return caml_call2
             (concat_mapi,
              t,
              function(i, x){
               var match = caml_call2(f, i, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function mapi(t, f){
     return filter_mapi(t, function(i, x){return [0, caml_call2(f, i, x)];});
    }
    function filteri(t, f){
     return filter_mapi
             (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
    }
    return [0,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            init,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         iteri = T[5],
         foldi = T[6],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24],
         a = include[3];
        function mem(t, x){return caml_call3(a, t, x, T[1][1]);}
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       Make_gen,
       function(T){
        var
         of_list = T[1],
         of_array = T[2],
         concat = T[3],
         fold = T[4],
         iter = T[5],
         length = T[6],
         iteri = T[7],
         foldi = T[8],
         init = T[9],
         concat_mapi = T[10],
         include =
           Make_gen_with_creators
            ([0,
              of_array,
              of_list,
              of_array,
              concat,
              fold,
              iter,
              length,
              iteri,
              foldi,
              init,
              concat_mapi]),
         of_list$0 = include[1],
         of_array$0 = include[2],
         append = include[3],
         concat$0 = include[4],
         map = include[5],
         filter = include[6],
         filter_map = include[7],
         concat_map = include[8],
         partition_tf = include[9],
         partition_map = include[10],
         length$0 = include[11],
         is_empty = include[12],
         mem = include[13],
         iter$0 = include[14],
         fold$0 = include[15],
         fold_result = include[16],
         fold_until = include[17],
         exists = include[18],
         for_all = include[19],
         count = include[20],
         sum = include[21],
         find = include[22],
         find_map = include[23],
         to_list = include[24],
         to_array = include[25],
         min_elt = include[26],
         max_elt = include[27],
         foldi$0 = include[28],
         iteri$0 = include[29],
         existsi = include[30],
         for_alli = include[31],
         counti = include[32],
         findi = include[33],
         find_mapi = include[34],
         init$0 = include[35],
         mapi = include[36],
         filteri = include[37],
         filter_mapi = include[38],
         concat_mapi$0 = include[39];
        return [0,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi,
                init$0,
                mapi,
                filteri,
                filter_mapi,
                concat_mapi$0];
       },
       function(T){
        var
         of_list = T[2],
         of_array = T[3],
         concat = T[4],
         fold = T[5],
         iter = T[6],
         length = T[7],
         iteri = T[8],
         foldi = T[9],
         init = T[10],
         concat_mapi = T[11],
         concat_of_array = Base_Array0[16],
         include =
           Make_gen_with_creators
            ([0,
              concat_of_array,
              of_list,
              of_array,
              concat,
              fold,
              iter,
              length,
              iteri,
              foldi,
              init,
              concat_mapi]),
         of_list$0 = include[1],
         of_array$0 = include[2],
         append = include[3],
         concat$0 = include[4],
         map = include[5],
         filter = include[6],
         filter_map = include[7],
         concat_map = include[8],
         partition_tf = include[9],
         partition_map = include[10],
         length$0 = include[11],
         is_empty = include[12],
         iter$0 = include[14],
         fold$0 = include[15],
         fold_result = include[16],
         fold_until = include[17],
         exists = include[18],
         for_all = include[19],
         count = include[20],
         sum = include[21],
         find = include[22],
         find_map = include[23],
         to_list = include[24],
         to_array = include[25],
         min_elt = include[26],
         max_elt = include[27],
         foldi$0 = include[28],
         iteri$0 = include[29],
         existsi = include[30],
         for_alli = include[31],
         counti = include[32],
         findi = include[33],
         find_mapi = include[34],
         init$0 = include[35],
         mapi = include[36],
         filteri = include[37],
         filter_mapi = include[38],
         concat_mapi$0 = include[39],
         a = include[13];
        function mem(t, x){return caml_call3(a, t, x, T[1][1]);}
        return [0,
                of_list$0,
                of_array$0,
                append,
                concat$0,
                map,
                filter,
                filter_map,
                concat_map,
                partition_tf,
                partition_map,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi,
                init$0,
                mapi,
                filteri,
                filter_mapi,
                concat_mapi$0];
       },
       Make_gen_with_creators];
   runtime.caml_register_global
    (4, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
//# shape: Base__Lazy:[F(3),F(3),F(3),F(3),F(2)*,N,F(2),F(2),F(1)*,N,N,N,N,N,N,N,N,N,N,N,N,F(1),F(1),F(1),F(1),F(1),[F(2)]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145];
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Import[192].call(null, a_sexp_grammar);
   }
   var globalize = Base_Globalize[12];
   function compare_local(compare_a, t1, t2){
    if(t1 === t2) return 0;
    var a = caml_obj_tag(t2);
    a:
    if(250 === a)
     var b = t2[1];
    else{
     if(246 !== a && 244 !== a){var b = t2; break a;}
     var b = CamlinternalLazy[2].call(null, t2);
    }
    var c = caml_obj_tag(t1);
    a:
    if(250 === c)
     var d = t1[1];
    else{
     if(246 !== c && 244 !== c){var d = t1; break a;}
     var d = CamlinternalLazy[2].call(null, t1);
    }
    return caml_call2(compare_a, d, b);
   }
   function compare(compare_a, t1, t2){
    return compare_local(compare_a, t1, t2);
   }
   function equal_local(equal_a, t1, t2){
    if(t1 === t2) return 1;
    var a = caml_obj_tag(t2);
    a:
    if(250 === a)
     var b = t2[1];
    else{
     if(246 !== a && 244 !== a){var b = t2; break a;}
     var b = CamlinternalLazy[2].call(null, t2);
    }
    var c = caml_obj_tag(t1);
    a:
    if(250 === c)
     var d = t1[1];
    else{
     if(246 !== c && 244 !== c){var d = t1; break a;}
     var d = CamlinternalLazy[2].call(null, t1);
    }
    return caml_call2(equal_a, d, b);
   }
   function equal(equal_a, t1, t2){return equal_local(equal_a, t1, t2);}
   var hash_fold_t = Base_Hash[13][12];
   function peek(t){
    if(! is_val(t)) return 0;
    var a = caml_obj_tag(t);
    a:
    if(250 === a)
     var b = t[1];
    else{
     if(246 !== a && 244 !== a){var b = t; break a;}
     var b = CamlinternalLazy[2].call(null, t);
    }
    return [0, b];
   }
   function return$(x){return from_val(x);}
   function bind(t, f){
    return [246,
            function(param){
             var b = caml_obj_tag(t);
             a:
             if(250 === b)
              var c = t[1];
             else{
              if(246 !== b && 244 !== b){var c = t; break a;}
              var c = CamlinternalLazy[2].call(null, t);
             }
             var a = caml_call1(f, c), d = caml_obj_tag(a);
             if(250 === d) return a[1];
             if(246 !== d && 244 !== d) return a;
             return CamlinternalLazy[2].call(null, a);
            }];
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return [246,
                function(param){
                 var a = caml_obj_tag(t);
                 a:
                 if(250 === a)
                  var b = t[1];
                 else{
                  if(246 !== a && 244 !== a){var b = t; break a;}
                  var b = CamlinternalLazy[2].call(null, t);
                 }
                 return caml_call1(f, b);
                }];
       }],
    include = Base_Monad[1].call(null, [0, bind, return$, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$0 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_unforced_lazy = "<unforced lazy>";
   function sexp_of_t$0(sexp_of_a, t){
    if(! is_val(t)) return Base_Import[136].call(null, cst_unforced_lazy);
    var a = caml_obj_tag(t);
    a:
    if(250 === a)
     var b = t[1];
    else{
     if(246 !== a && 244 !== a){var b = t; break a;}
     var b = CamlinternalLazy[2].call(null, t);
    }
    return caml_call1(sexp_of_a, b);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$0,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       peek,
       T_unforcing];
   runtime.caml_register_global(7, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
//# shape: Base__Info_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
//# shape: Base__Ordered_collection_common0:[F(4),F(3),[F(3)]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    a =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    b = [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    c =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call2(invalid_argf(a), pos, 0);
    if(len < 0) caml_call2(invalid_argf(b), len, 0);
    var d = Base_Import[93].call(null, total_length, len) < pos ? 1 : 0;
    return d ? caml_call4(invalid_argf(c), pos, len, total_length, 0) : d;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = Base_Import[91].call(null, pos, len),
     b = Base_Import[93].call(null, total_length, stop),
     c = Base_Import[118].call(null, pos, len),
     d = Base_Import[118].call(null, c, stop),
     a = Base_Import[118].call(null, d, b) < 0 ? 1 : 0;
    return a ? slow_check_pos_len_exn(pos, len, total_length) : a;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    var pos = opt ? opt[1] : 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = Base_Import[93].call(null, total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Stdlib__Bigarray, Stdlib__Domain, Stdlib__Random
//# shape: Base__Random_repr:[[F(1)*],F(2),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random;
   function of_state(a){return a;}
   var Repr = [0, of_state];
   function assign(t, state){
    var dst = caml_call1(Stdlib_Domain[10][2], t);
    return runtime.caml_ba_blit(state, dst);
   }
   function make(state){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[19][19], v);
    }
    var
     t =
       caml_call2
        (Stdlib_Domain[10][1],
         [0, split_from_parent],
         function(param){return state;});
    caml_call1(Stdlib_Domain[10][2], t);
    return t;
   }
   function make_lazy(f){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[19][19], v);
    }
    return caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], f);
   }
   function get_state(t){return caml_call1(Stdlib_Domain[10][2], t);}
   var Base_Random_repr = [0, Repr, assign, make, make_lazy, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Printf, Base__Random_repr, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
//# shape: Base__Random:[F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(1),F(1),F(1),N,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests",
    dummy = 0;
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var a = Base_Import[129];
    if(! a) return a;
    if(allow_in_tests && allow_in_tests[1]) return;
    return Base_Import[124].call(null, cst_initializing_Random_with_a);
   }
   function bits(t){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call1(Stdlib_Random[19][4], a);
   }
   function bits64(t){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call1(Stdlib_Random[19][17], a);
   }
   function bool(t){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call1(Stdlib_Random[19][15], a);
   }
   function int(t, x){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call2(Stdlib_Random[19][5], a, x);
   }
   function int32(t, x){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call2(Stdlib_Random[19][8], a, x);
   }
   function int64(t, x){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call2(Stdlib_Random[19][12], a, x);
   }
   function nativeint(t, x){
    var a = Base_Random_repr[5].call(null, t);
    return caml_call2(Stdlib_Random[19][10], a, x);
   }
   function make(seed){
    var a = caml_call1(Stdlib_Random[19][1], seed);
    return Base_Random_repr[3].call(null, a);
   }
   function copy(t){
    var
     a = Base_Random_repr[5].call(null, t),
     b = caml_call1(Stdlib_Random[19][3], a);
    return Base_Random_repr[3].call(null, b);
   }
   function char(t){var a = int(t, 256); return Base_Char0[5].call(null, a);}
   function ascii(t){var a = int(t, 128); return Base_Char0[5].call(null, a);}
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return Base_Random_repr[4].call(null, Stdlib_Random[19][2]);
   }
   var
    assign = Base_Random_repr[2],
    cst_float = "float",
    cst_int64 = "int64",
    b = caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    a =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"];
   if(Base_Import[129]){
    var t = Stdlib_Random[20].call(null, 0);
    Stdlib_Random[1].call(null, 137);
    var default$ = Base_Random_repr[3].call(null, t);
   }
   else
    var default$ = make_self_init(0, 0);
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int(t, bound);
   }
   var int$0 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     a = caml_int64_shift_left(bits$0(state), 60),
     b = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), a);
    return caml_int64_xor(bits$0(state), b);
   }
   function bits$1(state){return bits(state);}
   function full_range_int32(state){
    var a = bits$1(state) << 30;
    return bits$1(state) ^ a;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     b = caml_call1(string_of_bound, upper_bound),
     c = caml_call1(string_of_bound, lower_bound);
    return caml_call4(Base_Printf[6].call(null, a), name, c, b, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = Base_Import[93].call(null, hi, lo);
    if(diff === Base_Int0[6]){
     var
      a = Base_Int0[6],
      b = full_range_int(state),
      c = Base_Import[116].call(null, b, a);
     return Base_Import[91].call(null, lo, c);
    }
    if(0 <= diff){
     var d = int$0(state, Base_Int0[8].call(null, diff));
     return Base_Import[91].call(null, lo, d);
    }
    for(;;){
     var int = full_range_int(state);
     if(lo <= int && int <= hi) return int;
    }
   }
   function int32_incl(state, lo, hi){
    if(Base_Import[102][5].call(null, lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(Base_Import[102][4].call(null, diff, Stdlib_Int32[9])){
     var a = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & a) | 0;
    }
    if(Base_Import[102][6].call(null, diff, 0))
     return lo + int32(state, Stdlib_Int32[6].call(null, diff)) | 0;
    for(;;){
     var int = full_range_int32(state);
     if
      (Base_Import[102][6].call(null, int, lo)
       && Base_Import[102][2].call(null, int, hi))
      return int;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(Base_Import[104][5].call(null, lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(Base_Import[104][4].call(null, diff, Stdlib_Nativeint[10])){
     var a = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & a) | 0;
    }
    if(Base_Import[104][6].call(null, diff, 0))
     return lo + nativeint(state, Stdlib_Nativeint[6].call(null, diff)) | 0;
    for(;;){
     var int = full_range_nativeint(state);
     if
      (Base_Import[104][6].call(null, int, lo)
       && Base_Import[104][2].call(null, int, hi))
      return int;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var a = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), a));
    }
    if(caml_greaterequal(diff, b))
     return caml_int64_add(lo, int64(state, Stdlib_Int64[6].call(null, diff)));
    for(;;){
     var int = full_range_int64(state);
     if(caml_greaterequal(int, lo) && runtime.caml_lessequal(int, hi))
      return int;
    }
   }
   function float(state, hi){
    for(;;){
     var
      scale = 9.313225746154785e-10,
      r1 = bits(state),
      r2 = bits(state),
      a = Base_Import[90].call(null, r1, scale),
      b = Base_Import[92].call(null, a, r2),
      result = Base_Import[90].call(null, b, scale);
     if(result < 1.) return Base_Import[90].call(null, result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_float, lo, hi, Base_Import[85][35]);
    var a = float(state, Base_Import[94].call(null, hi, lo));
    return Base_Import[92].call(null, lo, a);
   }
   function bits$2(param){return bits(default$);}
   function bits64$0(param){return bits64(default$);}
   function int$1(x){return int$0(default$, x);}
   function int32$0(x){return int32(default$, x);}
   function nativeint$0(x){return nativeint(default$, x);}
   function int64$0(x){return int64(default$, x);}
   function float$0(x){return float(default$, x);}
   function int_incl$0(x, y){return int_incl(default$, x, y);}
   function int32_incl$0(x, y){return int32_incl(default$, x, y);}
   function nativeint_incl$0(x, y){return nativeint_incl(default$, x, y);}
   function int64_incl$0(x, y){return int64_incl(default$, x, y);}
   function float_range$0(x, y){return float_range(default$, x, y);}
   function bool$0(param){return bool(default$);}
   function char$0(param){return char(default$);}
   function ascii$0(param){return ascii(default$);}
   function full_init(seed){
    return assign(default$, caml_call1(Stdlib_Random[19][1], seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return assign(default$, Base_Random_repr[5].call(null, s));
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$2,
       bits64$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$0,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$0,
       ascii$0,
       [0,
        default$,
        make,
        make_self_init,
        copy,
        bits,
        bits64,
        int$0,
        int32,
        nativeint,
        int64,
        float,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char,
        ascii],
       set_state];
   runtime.caml_register_global(22, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
//# shape: Base__Array_permute:[F(1),[],N,F(2)*,F(2)*,F(1)*,F(2)*,F(5),F(1)*,F(1)*,F(4),F(2),F(3),F(1),F(3),F(1),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(3),F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    blit = Base_Array0[8],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24];
   function permute(a, opt, len, t){
    var
     random_state = a ? a[1] : Base_Random[19][1],
     pos = opt ? opt[1] : 0,
     total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = Base_Import[93].call(null, total_length, pos);
    Base_Ordered_collection_common[2].call(null, pos, len$0, total_length);
    var num_swaps = Base_Import[93].call(null, len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = Base_Import[91].call(null, pos, i),
       b = Base_Import[91].call(null, i, 1),
       c = caml_call2(Base_Random[19][7], random_state, b),
       random_i = Base_Import[91].call(null, pos, c);
      swap(t, this_i, random_i);
      var d = i - 1 | 0;
      if(1 === i) break;
      i = d;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
//# shape: Base__Equal:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
//# shape: Base__Ordering:[F(2)*,F(2)*,F(2),F(1),F(1),F(1)*,N,N,F(2)*,F(2)*,F(1)*,F(1)*,[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare,
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare_local = caml_int_compare,
    compare = caml_int_compare,
    a = [0, cst_Less],
    b = [0, cst_Equal],
    c = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var a = 0; break;
      case 1:
       var a = 1; break;
      default: var a = 2;
    }
    return Base_Hash[3].call(null, hsv, a);
   }
   function hash(arg){
    var hsv = Base_Hash[11].call(null, 0, 0), a = hash_fold_t(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var a = sexp_006[1];
      b:
      if(a !== cst_Equal){
       c:
       if(a !== cst_Greater){
        if(a !== cst_Less){
         if(a === cst_equal) break b;
         if(a === cst_greater) break c;
         if(a !== cst_less) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var match = sexp_006[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_005, sexp_006);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_005, sexp_006);
     var b = match$0[1];
     b:
     if(b !== cst_Equal){
      c:
      if(b !== cst_Greater){
       if(b !== cst_Less){
        if(b === cst_equal) break b;
        if(b === cst_greater) break c;
        if(b !== cst_less) break a;
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_005, sexp_006);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_005, sexp_006);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_005, sexp_006);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return a;case 1: return b;default: return c;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   function equal_local(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       equal_local,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Printf, Base__Random, Base__Result, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_grammar
//# shape: Base__List:[F(3),F(3),F(2),N,F(2),F(2),F(1)*,F(1)*,F(1),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(3),F(1)*,F(2),F(3),F(3),F(4),F(2),F(2),F(2),F(3),F(2),F(2),F(1)*,F(1),F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(2),N,F(2),F(2),N,F(2),F(1)*,F(2),N,N,N,N,N,N,F(1)*,F(2),F(2),F(1),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(4),F(4),F(4),F(4),F(3),F(3),F(3),F(3),F(2),F(2),F(1),F(2),F(2),F(2),F(3),F(1)*,F(1)*,F(1),F(1),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(4),F(4),F(4),F(4),F(3),F(3),F(3),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(1),F(3),F(3),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(5),F(6),F(2),F(2),F(1),N,F(3),F(2),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(2)*,F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),[F(2)],F(1),F(1),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_List_map2$1 = "List.map2",
    cst_List_map3$1 = "List.map3",
    cst_List_range_stride_function$2 =
      "List.range': stride function cannot change direction",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    error_source_036 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    rev_append = Base_List1[2],
    tl_exn = Base_List1[3],
    length = Base_List1[5],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    rev = Base_List1[19],
    fold_right = Base_List1[20],
    fold_right2_ok = Base_List1[21],
    is_empty = Base_List1[22],
    partition_map = Base_List1[23],
    invalid_argf = Base_Printf[7],
    globalize = Base_Import[293],
    t_of_sexp = Base_Import[173],
    sexp_of_t = Base_Import[149],
    a = [0, "Ok"],
    b = [0, "Unequal_lengths"],
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    cst_List_range_stride_function$0 = cst_List_range_stride_function$2,
    cst_List_range_stride_function$1 = cst_List_range_stride_function$2,
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    c =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    d =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    e =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    cst_iter2_exn = "iter2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_fold_right2_exn = "fold_right2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_exists2_exn = "exists2_exn";
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Import[194].call(null, a_sexp_grammar);
   }
   function compare_local(cmp_a, a_014, b_015){
    if(a_014 === b_015) return 0;
    if(! a_014) return b_015 ? 1 : 0;
    var a_016 = a_014[1];
    if(! b_015) return -1;
    var b_017 = b_015[1];
    return caml_call2(cmp_a, a_016, b_017);
   }
   function compare(cmp_a, a_010, b_011){
    if(a_010 === b_011) return 0;
    if(! a_010) return b_011 ? 1 : 0;
    var a_012 = a_010[1];
    if(! b_011) return -1;
    var b_013 = b_011[1];
    return caml_call2(cmp_a, a_012, b_013);
   }
   function sexp_of_t$0(of_a_018, param){
    if(! param) return b;
    var arg0_019 = param[1], res0_020 = caml_call1(of_a_018, arg0_019);
    return [1, [0, a, [0, res0_020, 0]]];
   }
   function invariant(f, t){return iter(t, f);}
   function of_list(t){return t;}
   function singleton(x){return [0, x, 0];}
   function range(compare, stride, a, opt, start_i, stop_i){
    var
     start = a ? a[1] : 104758188,
     stop = opt ? opt[1] : -160346914,
     next_i = caml_call1(stride, start_i);
    function order(x, y){
     var a = caml_call2(compare, x, y);
     return Base_Ordering[11].call(null, a);
    }
    function raise_stride_cannot_return_sam(param){
     return Base_Import[126].call(null, cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i_to_stop_order = order(start_i$0, stop_i);
    a:
    {
     switch(i_to_stop_order){
       case 0:
        if(847855481 <= initial_stride_order) break a; break;
       case 1:
        return 104758188 <= stop ? [0, start_i$0, 0] : 0;
       default: if(847855481 > initial_stride_order) break a;
     }
     return 0;
    }
    var next_i$0 = caml_call1(stride, start_i$0);
    a:
    {
     switch(order(start_i$0, next_i$0)){
       case 0:
        if(847855481 > initial_stride_order) break a; break;
       case 1:
        return raise_stride_cannot_return_sam(0);
       default: if(847855481 <= initial_stride_order) break a;
     }
     var block = [0, start_i$0, 24029], dst = block, offset = 1, i = next_i$0;
     for(;;){
      var i_to_stop_order$0 = order(i, stop_i);
      b:
      {
       c:
       {
        switch(i_to_stop_order$0){
          case 0:
           if(847855481 <= initial_stride_order) break c; break;
          case 1:
           if(104758188 <= stop){dst[offset + 1] = [0, i, 0]; break b;}
           dst[offset + 1] = 0;
           break b;
          default: if(847855481 > initial_stride_order) break c;
        }
        dst[offset + 1] = 0;
        break b;
       }
       var next_i$1 = caml_call1(stride, i);
       c:
       {
        switch(order(i, next_i$1)){
          case 0:
           if(847855481 > initial_stride_order) break c; break;
          case 1:
           dst[offset + 1] = raise_stride_cannot_return_sam(0); break b;
          default: if(847855481 <= initial_stride_order) break c;
        }
        var dst$0 = [0, i, 24029];
        dst[offset + 1] = dst$0;
        dst = dst$0;
        offset = 1;
        i = next_i$1;
        continue;
       }
       dst[offset + 1] =
        Base_Import[126].call(null, cst_List_range_stride_function$1);
      }
      return block;
     }
    }
    return Base_Import[126].call(null, cst_List_range_stride_function$0);
   }
   function range$0(b, a, opt, start_i, stop_i){
    var
     stride = b ? b[1] : 1,
     start = a ? a[1] : 104758188,
     stop = opt ? opt[1] : -160346914;
    if(0 === stride)
     Base_Import[126].call(null, cst_List_range_stride_must_be_);
    return range
            (runtime.caml_int_compare,
             function(x){return Base_Import[91].call(null, x, stride);},
             [0, start],
             [0, stop],
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = Base_Import[93].call(null, n$0, 1);
     t$0 = t$1;
     n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(match){var a = match[1]; return a;}
    var b = length(t);
    return caml_call3(invalid_argf(c), n, b, 0);
   }
   function unordered_append(l1, l2){
    if(l1){if(l2) return rev_append(l1, l2); var l = l1;} else var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = Base_Import[91].call(null, shared_length, 1);
       a = a$0;
       b = b$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     a = length(tail_of_b),
     b = Base_Import[91].call(null, shared_length, a),
     c = length(tail_of_a),
     e = Base_Import[91].call(null, shared_length, c);
    return caml_call4(invalid_argf(d), name, e, b, 0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = Base_Import[91].call(null, shared_length, 1);
       a = a$0;
       b = b$0;
       c = c$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     a = length(tail_of_a),
     n1 = Base_Import[91].call(null, shared_length, a),
     b = length(tail_of_b),
     n2 = Base_Import[91].call(null, shared_length, b),
     c = length(tail_of_c),
     n3 = Base_Import[91].call(null, shared_length, c);
    return caml_call6(invalid_argf(e), name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return iter2_ok(a, b, f);};});
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return iter2_ok(l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return rev_map2_ok(a, b, f);};});
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return rev_map2_ok(l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return fold2_ok(a, b, init, f);};});
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return fold2_ok(l1, l2, init, f);
   }
   function fold_right2(l1, l2, f, init){
    return check_length2
            (l1,
             l2,
             function(a){
              return function(b){return fold_right2_ok(a, b, f, init);};
             });
   }
   function fold_right2_exn(l1, l2, f, init){
    check_length2_exn(cst_fold_right2_exn, l1, l2);
    return fold_right2_ok(l1, l2, f, init);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return for_all2_ok(a, b, f);};});
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return for_all2_ok(l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return exists2_ok(a, b, f);};});
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return exists2_ok(l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], c = caml_call2(equal, a, b);
     if(c) return c;
     param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)){
      var accu$0 = [0, x, accu];
      accu = accu$0;
      param = l;
     }
     else
      param = l;
    }
   }
   function filter(l$1, f){
    var l = l$1;
    for(;;){
     if(! l) return 0;
     var tl = l[2], hd = l[1];
     if(caml_call1(f, hd)) break;
     l = tl;
    }
    var block = [0, hd, 24029], dst = block, offset = 1, l$0 = tl;
    for(;;){
     if(! l$0){dst[offset + 1] = 0; return block;}
     var tl$0 = l$0[2], hd$0 = l$0[1];
     if(caml_call1(f, hd$0)){
      var dst$0 = [0, hd$0, 24029];
      dst[offset + 1] = dst$0;
      dst = dst$0;
      offset = 1;
      l$0 = tl$0;
     }
     else
      l$0 = tl$0;
    }
   }
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     param = l;
    }
   }
   var not_found = [0, Base_Import[297], [0, "List.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     param = l;
    }
   }
   var not_found$0 = [0, Base_Import[297], [0, "List.find_exn: not found"]];
   function find_exn(t$1, f){
    var t = t$1;
    for(;;){
     if(! t) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$0 = t[2], x = t[1];
     if(caml_call1(f, x)) return x;
     t = t$0;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[297], [0, "List.findi_exn: not found"]];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var
    not_found$2 = [0, Base_Import[297], [0, "List.find_mapi_exn: not found"]];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], a = caml_call2(f, i, hd);
     if(! a) return a;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], a = caml_call2(f, i, hd);
     if(a) return a;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   var
    of_array = Base_Array0[16],
    to_array = Base_Array0[14],
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_map2_exn = "map2_exn",
    f = [0, cst_src_list_ml, 476, 11],
    cst_rev_map3_exn = "rev_map3_exn",
    cst_List_map3 = cst_List_map3$1,
    cst_List_map3$0 = cst_List_map3$1,
    cst_map3_exn = "map3_exn",
    g =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_List_reduce_exn = "List.reduce_exn",
    h = [0, cst_src_list_ml, 626, 14],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn";
   function to_list(t){return t;}
   function append(l1$0, l2){
    if(! l2) return l1$0;
    if(! l1$0) return l2;
    var match = l1$0[2], x1 = l1$0[1];
    if(! match) return [0, x1, l2];
    var match$0 = match[2], x2 = match[1];
    if(! match$0) return [0, x1, [0, x2, l2]];
    var match$1 = match$0[2], x3 = match$0[1];
    if(! match$1) return [0, x1, [0, x2, [0, x3, l2]]];
    var match$2 = match$1[2], x4 = match$1[1];
    if(! match$2) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match$2[2],
     x5 = match$2[1],
     block = [0, x5, 24029],
     dst = block,
     offset = 1,
     l1 = tl;
    for(;;){
     if(l1){
      var match$3 = l1[2], x1$0 = l1[1];
      if(match$3){
       var match$4 = match$3[2], x2$0 = match$3[1];
       if(match$4){
        var match$5 = match$4[2], x3$0 = match$4[1];
        if(match$5){
         var match$6 = match$5[2], x4$0 = match$5[1];
         if(match$6){
          var tl$0 = match$6[2], x5$0 = match$6[1], dst$0 = [0, x5$0, 24029];
          dst[offset + 1] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, dst$0]]]];
          dst = dst$0;
          offset = 1;
          l1 = tl$0;
          continue;
         }
         dst[offset + 1] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, l2]]]];
        }
        else
         dst[offset + 1] = [0, x1$0, [0, x2$0, [0, x3$0, l2]]];
       }
       else
        dst[offset + 1] = [0, x1$0, [0, x2$0, l2]];
      }
      else
       dst[offset + 1] = [0, x1$0, l2];
     }
     else
      dst[offset + 1] = l2;
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
   }
   function map(l, f){
    if(! l) return 0;
    var
     tl = l[2],
     x = l[1],
     block = [0, caml_call1(f, x), 24029],
     dst = block,
     offset = 1,
     l$0 = tl;
    for(;;){
     if(! l$0){dst[offset + 1] = 0; return block;}
     var tl$0 = l$0[2], x$0 = l$0[1], dst$0 = [0, caml_call1(f, x$0), 24029];
     dst[offset + 1] = dst$0;
     dst = dst$0;
     offset = 1;
     l$0 = tl$0;
    }
   }
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call2(f, x1, x2), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1){
          var
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call2(f, x1$0, x2$0), 24029];
          dst[offset + 1] = dst$0;
          dst = dst$0;
          offset = 1;
          l1$1 = l1$2;
          l2$1 = l2$2;
          continue;
         }
        }
        else if(! l2$1){dst[offset + 1] = 0; break a;}
        dst[offset + 1] = Base_Import[126].call(null, cst_List_map2$0);
       }
       return block;
      }
     }
    }
    else if(! l2) return 0;
    return Base_Import[126].call(null, cst_List_map2);
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(a){return function(b){return map2_ok(a, b, f);};});
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f$0){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f$0, x1, x2, x3), ac];
       l1$0 = l1$1;
       l2$0 = l2$1;
       l3$0 = l3$1;
       ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(a){
              return function(c){
               function b(b, d){return rev_map3_ok(a, c, b, d);}
               return function(a){return b(a, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    if(l1){
     if(l2 && l3){
      var
       l3$0 = l3[2],
       x3 = l3[1],
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call3(f, x1, x2, x3), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0,
       l3$1 = l3$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1 && l3$1){
          var
           l3$2 = l3$1[2],
           x3$0 = l3$1[1],
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call3(f, x1$0, x2$0, x3$0), 24029];
          dst[offset + 1] = dst$0;
          dst = dst$0;
          offset = 1;
          l1$1 = l1$2;
          l2$1 = l2$2;
          l3$1 = l3$2;
          continue;
         }
        }
        else if(! l2$1 && ! l3$1){dst[offset + 1] = 0; break a;}
        dst[offset + 1] = Base_Import[126].call(null, cst_List_map3$0);
       }
       return block;
      }
     }
    }
    else if(! l2 && ! l3) return 0;
    return Base_Import[126].call(null, cst_List_map3);
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(a){
              return function(c){
               function b(b, d){return map3_ok(a, c, b, d);}
               return function(a){return b(a, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1$1, l2$1, f){
    var l1 = l1$1, l2 = l2$1;
    for(;;){
     if(! l1) return l2;
     var l1$0 = l1[2], h = l1[1], l2$0 = [0, caml_call1(f, h), l2];
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function unzip(list){
    var list$2 = rev(list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function unzip3(list){
    var list$2 = rev(list), list$0 = list$2, l1 = 0, l2 = 0, l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
     l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{var c = map2_ok(l1, l2, function(a, b){return [0, a, b];}); return c;}
    catch(exn){
     var a = length(l2), b = length(l1);
     return caml_call3(invalid_argf(g), b, a, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     acc = acc$0;
     param = t;
    }
   }
   function mapi(l, f){
    var i$2 = 0;
    if(! l) return 0;
    var
     t = l[2],
     h = l[1],
     block = [0, caml_call2(f, i$2, h), 24029],
     i = Base_Import[91].call(null, i$2, 1),
     dst = block,
     offset = 1,
     i$0 = i,
     param = t;
    for(;;){
     if(! param){dst[offset + 1] = 0; return block;}
     var
      t$0 = param[2],
      h$0 = param[1],
      block0_arg0 = caml_call2(f, i$0, h$0),
      block$0 = [0, block0_arg0, 24029];
     dst[offset + 1] = block$0;
     var i$1 = Base_Import[91].call(null, i$0, 1);
     dst = block$0;
     offset = 1;
     i$0 = i$1;
     param = t$0;
    }
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    fold
     (l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return Base_Import[91].call(null, i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     a =
       fold
        (t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], a = caml_call3(f, i, acc, v);
          return [0, Base_Import[91].call(null, i, 1), a];
         });
    return Base_Import[127].call(null, a);
   }
   function filteri(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(caml_call2(f, pos, hd)) break;
     var pos$1 = Base_Import[91].call(null, pos, 1);
     pos = pos$1;
     l$0 = tl;
    }
    var
     block = [0, hd, 24029],
     pos$0 = Base_Import[91].call(null, pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[offset + 1] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1];
     if(caml_call2(f, pos$2, hd$0)){
      var block$0 = [0, hd$0, 24029];
      dst[offset + 1] = block$0;
      var pos$3 = Base_Import[91].call(null, pos$2, 1);
      dst = block$0;
      offset = 1;
      pos$2 = pos$3;
      l$1 = tl$0;
     }
     else{
      var pos$4 = Base_Import[91].call(null, pos$2, 1);
      pos$2 = pos$4;
      l$1 = tl$0;
     }
    }
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, fold(tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return Base_Import[126].call(null, cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num$1, acc$1, x$1){
     var num = num$1, acc = acc$1, x = x$1;
     for(;;){
      if(0 === Base_Import[116].call(null, num, 1)) return [0, x, acc];
      if(! acc) throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
      var
       acc$0 = acc[2],
       y = acc[1],
       x$0 = caml_call2(f, y, x),
       num$0 = Base_Import[115].call(null, num, 1);
      num = num$0;
      acc = acc$0;
      x = x$0;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0, fold(xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return Base_Import[126].call(null, cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$){
    var pos = [0, 0], l$0 = [0, l];
    function take_group(param){
     var group = l$0[1];
     if(group){
      var tl = group[2];
      if(tl){
       var y = tl[1], x = group[1];
       pos[1] = Base_Import[91].call(null, pos[1], 1);
       l$0[1] = tl;
       if(caml_call3(break$, pos[1], x, y)) return [0, x, 0];
       var block = [0, x, 24029], dst = block, offset = 1;
       for(;;){
        var group$0 = l$0[1];
        a:
        {
         if(group$0){
          var tl$0 = group$0[2];
          if(tl$0){
           var y$0 = tl$0[1], x$0 = group$0[1];
           pos[1] = Base_Import[91].call(null, pos[1], 1);
           l$0[1] = tl$0;
           if(caml_call3(break$, pos[1], x$0, y$0)){dst[offset + 1] = [0, x$0, 0]; break a;
           }
           var dst$0 = [0, x$0, 24029];
           dst[offset + 1] = dst$0;
           dst = dst$0;
           offset = 1;
           continue;
          }
         }
         l$0[1] = 0;
         dst[offset + 1] = group$0;
        }
        return block;
       }
      }
     }
     l$0[1] = 0;
     return group;
    }
    if(is_empty(l$0[1])) return 0;
    var
     group = take_group(0),
     block = [0, group, 24029],
     dst = block,
     offset = 1;
    for(;;){
     if(is_empty(l$0[1])){dst[offset + 1] = 0; return block;}
     var group$0 = take_group(0), dst$0 = [0, group$0, 24029];
     dst[offset + 1] = dst$0;
     dst = dst$0;
     offset = 1;
    }
   }
   function group(l, break$){
    return groupi(l, function(param, x, y){return caml_call2(break$, x, y);});
   }
   function merge(l1, l2, compare){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    if(0 < caml_call2(compare, h1, h2)){
     var block = [0, h2, 24029];
     merge_dps(block, 1, l1, t2, compare);
     return block;
    }
    var block$0 = [0, h1, 24029];
    merge_dps(block$0, 1, t1, l2, compare);
    return block$0;
   }
   function merge_dps(dst$2, offset$0, l1$0, l2$0, compare){
    var dst = dst$2, offset = offset$0, l1 = l1$0, l2 = l2$0;
    for(;;){
     if(! l1){dst[offset + 1] = l2; return;}
     if(! l2){dst[offset + 1] = l1; return;}
     var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
     if(0 < caml_call2(compare, h1, h2)){
      var dst$0 = [0, h2, 24029];
      dst[offset + 1] = dst$0;
      dst = dst$0;
      offset = 1;
      l2 = t2;
     }
     else{
      var dst$1 = [0, h1, 24029];
      dst[offset + 1] = dst$1;
      dst = dst$1;
      offset = 1;
      l1 = t1;
     }
    }
   }
   function stable_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = Base_Import[115].call(null, n, 1),
      n2 = Base_Import[93].call(null, n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = Base_Import[115].call(null, n, 1),
      n2 = Base_Import[93].call(null, n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    var len = length(l);
    if(2 > len) return l;
    var a = sort(len, l);
    return Base_Import[125].call(null, a);
   }
   function sort_and_group(l, compare){
    return group
            (stable_sort(l, compare),
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function dedup_and_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 <= c$0
            ? 0 < c$0 ? [0, x2, [0, x1, 0]] : [0, x2, 0]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 <= c$1)
         if(0 < c$1){
          var c$2 = caml_call2(cmp, x1$0, x3);
          if(0 <= c$2)
           if(0 < c$2)
            var
             c$3 = caml_call2(cmp, x2$0, x3),
             s$0 =
               0 <= c$3
                ? 0
                  < c$3
                  ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                  : [0, x3, [0, x1$0, 0]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]];
           else
            var s$0 = [0, x2$0, [0, x3, 0]];
          else
           var s$0 = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         }
         else
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           s$0 =
             0 <= c$4
              ? 0 < c$4 ? [0, x3, [0, x2$0, 0]] : [0, x3, 0]
              : [0, x2$0, [0, x3, 0]];
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 <= c$5)
          if(0 < c$5)
           var
            c$6 = caml_call2(cmp, x1$0, x3),
            s$0 =
              0 <= c$6
               ? 0
                 < c$6
                 ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                 : [0, x3, [0, x2$0, 0]]
               : [0, x1$0, [0, x3, [0, x2$0, 0]]];
          else
           var s$0 = [0, x1$0, [0, x3, 0]];
         else
          var s$0 = [0, x1$0, [0, x2$0, [0, x3, 0]]];
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = Base_Import[115].call(null, n, 1),
      n2 = Base_Import[93].call(null, n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 < c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        if(0 <= c){l1 = t1; continue;}
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 < c$0
            ? [0, x1, [0, x2, 0]]
            : 0 <= c$0 ? [0, x2, 0] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var a = l[2];
      if(a){
       var match$2 = a[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = a[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 < c$1){
         var c$2 = caml_call2(cmp, x2$0, x3);
         if(0 < c$2)
          var s$0 = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else if(0 <= c$2)
          var s$0 = [0, x1$0, [0, x3, 0]];
         else
          var
           c$3 = caml_call2(cmp, x1$0, x3),
           s$0 =
             0 < c$3
              ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : 0
                <= c$3
                ? [0, x3, [0, x2$0, 0]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]];
        }
        else if(0 <= c$1)
         var
          c$4 = caml_call2(cmp, x2$0, x3),
          s$0 =
            0 < c$4
             ? [0, x2$0, [0, x3, 0]]
             : 0 <= c$4 ? [0, x3, 0] : [0, x3, [0, x2$0, 0]];
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 < c$5)
          var s$0 = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else if(0 <= c$5)
          var s$0 = [0, x2$0, [0, x3, 0]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           s$0 =
             0 < c$6
              ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, 0]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = Base_Import[115].call(null, n, 1),
      n2 = Base_Import[93].call(null, n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 > c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        if(0 < c){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        l1 = t1;
        continue;
       }
       var b = rev_append(l1, accu);
      }
      else
       var b = rev_append(l2, accu);
      return [0, b, tl$0];
     }
    }
    var len = length(l);
    if(2 > len) return l;
    var a = sort(len, l);
    return Base_Import[125].call(null, a);
   }
   function stable_dedup(list, compare){
    if(list && list[2]){
     var
      dedups = rev_map(list, function(elt){return [0, elt, 1];}),
      unique =
        dedup_and_sort
         (dedups, function(x, y){return caml_call2(compare, x[1], y[1]);});
     iter(unique, function(dedup){dedup[2] = 0; return 0;});
     return fold
             (dedups,
              0,
              function(acc, dedup){
               return dedup[2] ? acc : [0, dedup[1], acc];
              });
    }
    return list;
   }
   function concat_mapi(l, f){
    function outer_loop_dps$0(counter, dst, offset, pos, param){
     if(! param){dst[offset + 1] = 0; return;}
     var tl = param[2], hd = param[1];
     if(! tl){dst[offset + 1] = caml_call2(f, pos, hd); return;}
     var a = caml_call2(f, pos, hd), b = Base_Import[91].call(null, pos, 1);
     if(counter >= 50)
      return caml_trampoline_return
              (inner_loop_dps$0, [0, dst, offset, b, a, tl]);
     var counter$0 = counter + 1 | 0;
     return inner_loop_dps$0(counter$0, dst, offset, b, a, tl);
    }
    function outer_loop_dps(dst, offset, pos, param){
     return caml_trampoline(outer_loop_dps$0(0, dst, offset, pos, param));
    }
    function inner_loop_dps$0(counter, dst$1, offset$0, pos, l1$0, l2){
     var dst = dst$1, offset = offset$0, l1 = l1$0;
     for(;;){
      if(! l1){
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, dst, offset, pos, l2]);
       var counter$4 = counter + 1 | 0;
       return outer_loop_dps$0(counter$4, dst, offset, pos, l2);
      }
      var match = l1[2], x1 = l1[1];
      if(! match){
       var d = [0, x1, 24029];
       dst[offset + 1] = d;
       var h = 1;
       if(counter >= 50)
        return caml_trampoline_return(outer_loop_dps$0, [0, d, h, pos, l2]);
       var counter$3 = counter + 1 | 0;
       return outer_loop_dps$0(counter$3, d, h, pos, l2);
      }
      var match$0 = match[2], x2 = match[1];
      if(! match$0){
       var c = [0, x2, 24029];
       dst[offset + 1] = [0, x1, c];
       var g = 1;
       if(counter >= 50)
        return caml_trampoline_return(outer_loop_dps$0, [0, c, g, pos, l2]);
       var counter$2 = counter + 1 | 0;
       return outer_loop_dps$0(counter$2, c, g, pos, l2);
      }
      var match$1 = match$0[2], x3 = match$0[1];
      if(! match$1){
       var b = [0, x3, 24029];
       dst[offset + 1] = [0, x1, [0, x2, b]];
       var f = 1;
       if(counter >= 50)
        return caml_trampoline_return(outer_loop_dps$0, [0, b, f, pos, l2]);
       var counter$1 = counter + 1 | 0;
       return outer_loop_dps$0(counter$1, b, f, pos, l2);
      }
      var match$2 = match$1[2], x4 = match$1[1];
      if(! match$2){
       var a = [0, x4, 24029];
       dst[offset + 1] = [0, x1, [0, x2, [0, x3, a]]];
       var e = 1;
       if(counter >= 50)
        return caml_trampoline_return(outer_loop_dps$0, [0, a, e, pos, l2]);
       var counter$0 = counter + 1 | 0;
       return outer_loop_dps$0(counter$0, a, e, pos, l2);
      }
      var tl = match$2[2], x5 = match$2[1], dst$0 = [0, x5, 24029];
      dst[offset + 1] = [0, x1, [0, x2, [0, x3, [0, x4, dst$0]]]];
      dst = dst$0;
      offset = 1;
      l1 = tl;
     }
    }
    function inner_loop_dps(dst, offset, pos, l1, l2){
     return caml_trampoline(inner_loop_dps$0(0, dst, offset, pos, l1, l2));
    }
    var pos = 0, param = l;
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     if(! tl) return caml_call2(f, pos, hd);
     var
      l1 = caml_call2(f, pos, hd),
      pos$0 = Base_Import[91].call(null, pos, 1);
     if(l1) break;
     pos = pos$0;
     param = tl;
    }
    var match = l1[2], x1 = l1[1];
    if(! match){
     var block$3 = [0, x1, 24029];
     outer_loop_dps(block$3, 1, pos$0, tl);
     return block$3;
    }
    var match$0 = match[2], x2 = match[1];
    if(! match$0){
     var block$2 = [0, x2, 24029];
     outer_loop_dps(block$2, 1, pos$0, tl);
     return [0, x1, block$2];
    }
    var match$1 = match$0[2], x3 = match$0[1];
    if(! match$1){
     var block$1 = [0, x3, 24029];
     outer_loop_dps(block$1, 1, pos$0, tl);
     return [0, x1, [0, x2, block$1]];
    }
    var match$2 = match$1[2], x4 = match$1[1];
    if(match$2){
     var tl$0 = match$2[2], x5 = match$2[1], block = [0, x5, 24029];
     inner_loop_dps(block, 1, pos$0, tl$0, tl);
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
    var block$0 = [0, x4, 24029];
    outer_loop_dps(block$0, 1, pos$0, tl);
    return [0, x1, [0, x2, [0, x3, block$0]]];
   }
   function concat_map(l, f){
    return concat_mapi(l, function(param, x){return caml_call1(f, x);});
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      Base_Applicative[13].call(null, [0, singleton, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = Base_Monad[1].call(null, [0, concat_map, singleton, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, singleton, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, singleton, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map],
    cst_List_last = "List.last",
    i = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    j = [0, cst_src_list_ml, 1111, 4],
    k = [1, 0],
    l = [1, 0],
    m = [1, 0],
    n = [0, cst_src_list_ml, 1305, 12];
   function last_exn(list$1){
    var list = list$1;
    for(;;){
     if(! list) return Base_Import[126].call(null, cst_List_last);
     var x = list[1];
     if(! list[2]) return x;
     var list$0 = list[2];
     list = list$0;
    }
   }
   function last(list$1){
    var list = list$1;
    for(;;){
     if(! list) return 0;
     var x = list[1];
     if(! list[2]) return [0, x];
     var list$0 = list[2];
     list = list$0;
    }
   }
   function is_prefix(list$1, prefix$1, equal){
    var list = list$1, prefix = prefix$1;
    for(;;){
     if(! prefix) return 1;
     var prefix$0 = prefix[2], hd = prefix[1];
     if(! list) return 0;
     var list$0 = list[2], hd$0 = list[1], a = caml_call2(equal, hd, hd$0);
     if(! a) return a;
     list = list$0;
     prefix = prefix$0;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     a1$0 = a2;
     t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    var which_to_keep = opt ? opt[1] : 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$1 = list[1],
     to_keep = to_keep$1,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return rev([0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep))
      if(847656566 <= which_to_keep){
       to_keep = to_keep$0;
       param = tl;
      }
      else
       param = tl;
     else{
      var accum$0 = [0, to_keep, accum];
      to_keep = to_keep$0;
      accum = accum$0;
      param = tl;
     }
    }
   }
   function find_a_dup(l, compare){
    var sorted = stable_sort(l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    var sorted = stable_sort(l, compare);
    if(! sorted) return 0;
    var
     sorted$4 = sorted[2],
     prev$3 = sorted[1],
     sorted$0 = sorted$4,
     prev = prev$3,
     already_recorded = 0;
    for(;;){
     if(! sorted$0) return 0;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === caml_call2(compare, prev, prev$0)){
      if(! already_recorded) break;
      sorted$0 = sorted$1;
      prev = prev$0;
      already_recorded = 1;
     }
     else{sorted$0 = sorted$1; prev = prev$0; already_recorded = 0;}
    }
    var
     block = [0, prev$0, 24029],
     dst = block,
     offset = 1,
     sorted$2 = sorted$1,
     prev$1 = prev$0,
     already_recorded$0 = 1;
    for(;;){
     if(! sorted$2){dst[offset + 1] = 0; return block;}
     var sorted$3 = sorted$2[2], prev$2 = sorted$2[1];
     if(0 === caml_call2(compare, prev$1, prev$2))
      if(already_recorded$0){
       sorted$2 = sorted$3;
       prev$1 = prev$2;
       already_recorded$0 = 1;
      }
      else{
       var dst$0 = [0, prev$2, 24029];
       dst[offset + 1] = dst$0;
       dst = dst$0;
       offset = 1;
       sorted$2 = sorted$3;
       prev$1 = prev$2;
       already_recorded$0 = 1;
      }
     else{sorted$2 = sorted$3; prev$1 = prev$2; already_recorded$0 = 0;}
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], a = caml_call2(equal, x, x$0);
      if(a){t = xs; continue;}
      var b = a;
     }
     else
      var b = 1;
     return b ? [0, x$0] : 0;
    }
   }
   function count(t, f){return Base_Container[2].call(null, fold, t, f);}
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function min_elt(t, compare){
    return Base_Container[3].call(null, fold, t, compare);
   }
   function max_elt(t, compare){
    return Base_Container[4].call(null, fold, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? Base_Import[91].call(null, count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call2(invalid_argf(i), n, 0);
    var i$0 = n, accum = 0;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
     if(0 === i$0) return accum;
     var
      accum$0 = [0, caml_call1(f, Base_Import[93].call(null, i$0, 1)), accum],
      i$1 = Base_Import[93].call(null, i$0, 1);
     i$0 = i$1;
     accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var x = match[1], accum$0 = [0, x, accum];
      l$0 = tl;
      accum = accum$0;
     }
     else
      l$0 = tl;
    }
   }
   function filter_map(l$1, f){
    var l = l$1;
    for(;;){
     if(! l) return 0;
     var tl = l[2], hd = l[1], match = caml_call1(f, hd);
     if(match) break;
     l = tl;
    }
    var
     x = match[1],
     block = [0, x, 24029],
     dst = block,
     offset = 1,
     l$0 = tl;
    for(;;){
     if(! l$0){dst[offset + 1] = 0; return block;}
     var tl$0 = l$0[2], hd$0 = l$0[1], match$0 = caml_call1(f, hd$0);
     if(match$0){
      var x$0 = match$0[1], dst$0 = [0, x$0, 24029];
      dst[offset + 1] = dst$0;
      dst = dst$0;
      offset = 1;
      l$0 = tl$0;
     }
     else
      l$0 = tl$0;
    }
   }
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match){
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = Base_Import[91].call(null, i, 1);
      i = i$0;
      l$0 = tl;
      accum = accum$0;
     }
     else{var i$1 = Base_Import[91].call(null, i, 1); i = i$1; l$0 = tl;}
    }
   }
   function filter_mapi(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, pos, hd);
     if(match) break;
     var pos$1 = Base_Import[91].call(null, pos, 1);
     pos = pos$1;
     l$0 = tl;
    }
    var
     x = match[1],
     block = [0, x, 24029],
     pos$0 = Base_Import[91].call(null, pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[offset + 1] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1], match$0 = caml_call2(f, pos$2, hd$0);
     if(match$0){
      var x$0 = match$0[1], block$0 = [0, x$0, 24029];
      dst[offset + 1] = block$0;
      var pos$3 = Base_Import[91].call(null, pos$2, 1);
      dst = block$0;
      offset = 1;
      pos$2 = pos$3;
      l$1 = tl$0;
     }
     else{
      var pos$4 = Base_Import[91].call(null, pos$2, 1);
      pos$2 = pos$4;
      l$1 = tl$0;
     }
    }
   }
   function filter_opt(l){return filter_map(l, function(a){return a;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){var a = rev(trd), b = rev(snd); return [0, rev(fst), b, a];}
     var
      t$1 = t$0[2],
      x = t$0[1],
      match = caml_call1(f, x),
      variant = match[1];
     if(4152137 === variant){
      var y = match[2], snd$0 = [0, y, snd];
      t$0 = t$1;
      snd = snd$0;
     }
     else if(4202758 <= variant){
      var y$0 = match[2], trd$0 = [0, y$0, trd];
      t$0 = t$1;
      trd = trd$0;
     }
     else{var y$1 = match[2], fst$0 = [0, y$1, fst]; t$0 = t$1; fst = fst$0;}
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return partition_map(t, f$0);
   }
   function partition_result(t){return partition_map(t, Base_Result[38]);}
   function t_of_sexp$0(of_a_028, of_b_029, x_037){
    return Base_Import[173].call
            (null,
             function(sexp_035){
              if(0 !== sexp_035[0]){
               var a = sexp_035[1];
               if(a){
                var b = a[2];
                if(b && ! b[2]){
                 var
                  arg1_032 = b[1],
                  arg0_031 = a[1],
                  res0_033 = caml_call1(of_a_028, arg0_031),
                  res1_034 = caml_call1(of_b_029, arg1_032);
                 return [0, res0_033, res1_034];
                }
               }
              }
              return Sexplib0_Sexp_conv_error[4].call
                      (null, error_source_036, 2, sexp_035);
             },
             x_037);
   }
   function sexp_of_t$1(of_a_038, of_b_039, x_044){
    return Base_Import[149].call
            (null,
             function(param){
              var
               arg1_041 = param[2],
               arg0_040 = param[1],
               res0_042 = caml_call1(of_a_038, arg0_040),
               res1_043 = caml_call1(of_b_039, arg1_041);
              return [1, [0, res0_042, [0, res1_043, 0]]];
             },
             x_044);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    var
     a =
       Base_Import[194].call
        (null,
         [2,
          [0,
           [5, [0, Sexplib0_Sexp_grammar[6], k, a_sexp_grammar]],
           [0, [5, [0, Sexplib0_Sexp_grammar[7], l, b_sexp_grammar]], 0]]]);
    return [5, [0, Sexplib0_Sexp_grammar[5], m, a]];
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, n], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[127])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(a, param){
                var y = param[1], x = a[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(a, param){
                var y = param[1], x = a[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var param = t;
    for(;;){
     if(param){
      var l = param[2], x$0 = param[1], key$0 = x$0[1];
      if(! caml_call2(equal, key, key$0)){param = l; continue;}
      var match = [0, x$0];
     }
     else
      var match = 0;
     if(! match) return 0;
     var x = match[1];
     return [0, Base_Import[127].call(null, x)];
    }
   }
   var
    not_found$3 = [0, Base_Import[297], [0, "List.Assoc.find_exn: not found"]],
    cst_List_sub = "List.sub",
    o =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list";
   function find_exn$0(t$1, equal, key$0){
    var t = t$1;
    for(;;){
     if(! t) throw caml_maybe_attach_backtrace(not_found$3, 1);
     var t$0 = t[2], match = t[1], value = match[2], key = match[1];
     if(caml_call2(equal, key$0, key)) return value;
     t = t$0;
    }
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var b = pos < 0 ? 1 : 0;
    if(b)
     var a = b;
    else{
     var c = len < 0 ? 1 : 0;
     if(c)
      var a = c;
     else
      var d = length(l), a = Base_Import[93].call(null, d, len) < pos ? 1 : 0;
    }
    if(a) Base_Import[126].call(null, cst_List_sub);
    var stop = Base_Import[91].call(null, pos, len), i = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(i >= pos) break;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     l$0 = tl;
    }
    if(i >= stop) return 0;
    var
     block = [0, hd, 24029],
     i$1 = Base_Import[91].call(null, i, 1),
     dst = block,
     offset = 1,
     i$2 = i$1,
     l$1 = tl;
    for(;;){
     if(l$1){
      var tl$0 = l$1[2], hd$0 = l$1[1];
      if(i$2 < pos){
       var i$3 = Base_Import[91].call(null, i$2, 1);
       i$2 = i$3;
       l$1 = tl$0;
       continue;
      }
      if(i$2 < stop){
       var block$0 = [0, hd$0, 24029];
       dst[offset + 1] = block$0;
       var i$4 = Base_Import[91].call(null, i$2, 1);
       dst = block$0;
       offset = 1;
       i$2 = i$4;
       l$1 = tl$0;
       continue;
      }
      dst[offset + 1] = 0;
     }
     else
      dst[offset + 1] = 0;
     return block;
    }
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return [0, t_orig, 0];
     var tl = t[2], hd = t[1];
     if(0 === n$0) return [0, rev(accum), t];
     var accum$0 = [0, hd, accum], n$1 = Base_Import[93].call(null, n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return t_orig;
     var tl = t[2], hd = t[1];
     if(0 === n$0) return rev(accum);
     var accum$0 = [0, hd, accum], n$1 = Base_Import[93].call(null, n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function drop(t$0, n$1){
    var t = t$0, n = n$1;
    for(;;){
     if(t){
      var tl = t[2];
      if(0 < n){
       var n$0 = Base_Import[93].call(null, n, 1);
       t = tl;
       n = n$0;
       continue;
      }
     }
     return t;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call2(invalid_argf(o), length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return rev(acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc];
     acc = acc$0;
     l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       t = tl;
       continue;
      }
     }
     return [0, rev(acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       param = tl;
       continue;
      }
     }
     return rev(acc);
    }
   }
   function drop_while(t$0, f){
    var t = t$0;
    for(;;){
     if(t){var tl = t[2], hd = t[1]; if(caml_call1(f, hd)){t = tl; continue;}}
     return t;
    }
   }
   function drop_last(t){
    var match = rev(t);
    if(! match) return 0;
    var lst = match[2];
    return [0, rev(lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return Base_Import[124].call(null, cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(is_empty(list2)) return 0;
    var l1 = list1;
    for(;;){
     if(! l1) return 0;
     var l1$0 = l1[2], x1 = l1[1];
     if(list2) break;
     l1 = l1$0;
    }
    var
     l2 = list2[2],
     x2 = list2[1],
     block = [0, [0, x1, x2], 24029],
     l2$2 = l2,
     l1$2 = l1$0,
     x1$1 = x1,
     offset$0 = 1,
     dst$1 = block;
    for(;;){
     var dst = dst$1, offset = offset$0, l2$0 = l2$2;
     for(;;){
      if(! l2$0){
       if(l1$2){
        var l1$1 = l1$2[2], x1$0 = l1$2[1];
        l2$2 = list2;
        l1$2 = l1$1;
        x1$1 = x1$0;
        offset$0 = offset;
        dst$1 = dst;
        break;
       }
       dst[offset + 1] = 0;
       return block;
      }
      var l2$1 = l2$0[2], x2$0 = l2$0[1], dst$0 = [0, [0, x1$1, x2$0], 24029];
      dst[offset + 1] = dst$0;
      dst = dst$0;
      offset = 1;
      l2$0 = l2$1;
     }
    }
   }
   function concat(l){return fold_right(l, append, 0);}
   function concat_no_order(l){
    return fold(l, 0, function(acc, l){return rev_append(l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        a = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! a) return a;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        a = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! a) return a;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var
    Infix = [0, append],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list";
   function permute(opt, list){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    if(list){
     var a = list[2];
     if(a){
      if(a[2]){
       var arr = Base_Array0[14].call(null, list);
       Base_Array_permute[25].call(null, [0, random_state], 0, 0, arr);
       return Base_Array0[16].call(null, arr);
      }
      var y = a[1], x = list[1];
      return caml_call1(Base_Random[19][17], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    if(is_empty(list))
     return Base_Import[124].call(null, cst_List_random_element_exn_em);
    var a = length(list);
    return nth_exn(list, caml_call2(Base_Random[19][7], random_state, a));
   }
   function random_element(opt, list){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    try{var a = [0, random_element_exn([0, random_state], list)]; return a;}
    catch(exn){return 0;}
   }
   function compare$0(cmp, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     a = xs;
     b = ys;
    }
   }
   function compare_local$0(cmp, a$0, b$0){
    var a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     a = xs;
     b = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal_with_local_closure(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        a = caml_call2(equal, x1, x2);
       if(! a) return a;
       t1$0 = t1$1;
       t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function equal(f, x, y){return equal_with_local_closure(f, x, y);}
   function equal_local(equal_a_local, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        a = caml_call2(equal_a_local, x1, x2);
       if(! a) return a;
       t1$0 = t1$1;
       t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t){
       if(! column_acc && ! trimmed_rows) return [0, rev(columns)];
       if(found_empty) return 0;
       var
        column = do_rev ? rev(column_acc) : column_acc,
        do_rev$0 = 1 - do_rev,
        columns$0 = [0, column, columns];
       rows = trimmed_rows;
       columns = columns$0;
       do_rev = do_rev$0;
       break;
      }
      var match = t[1];
      if(match){
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc];
       t = tl;
       column_acc = column_acc$0;
       trimmed_rows = trimmed;
      }
      else{var tl$0 = t[2]; t = tl$0; found_empty = 1;}
     }
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248,
       "Base__List.Transpose_got_lists_of_different_lengths",
       runtime.caml_fresh_oo_id(0)],
    p = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    q = [0, cst_src_list_ml, 1588, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Transpose_got_lists_of_differe,
     function(param){
      var tag = param[1];
      if(tag !== Transpose_got_lists_of_differe)
       throw caml_maybe_attach_backtrace([0, Assert_failure, q], 1);
      var
       arg0_045 = param[2],
       res0_046 = Base_Import[149].call(null, Base_Import[139], arg0_045);
      return [1, [0, p, [0, res0_046, 0]]];
     });
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1];
    return [0,
            x,
            fold_right(xs, function(y, acc){return [0, sep, [0, y, acc]];}, 0)];
   }
   function fold_result(t, init, f){
    return Base_Container[8].call(null, fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return Base_Container[9].call(null, fold, init, f, finish, t);
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = length(list),
     suffix_len = length(suffix),
     a = suffix_len <= list_len ? 1 : 0;
    return a
            ? equal_with_local_closure
              (equal_elt,
               drop(list, Base_Import[93].call(null, list_len, suffix_len)),
               suffix)
            : a;
   }
   var
    Base_List =
      [0,
       compare$0,
       compare_local$0,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       of_list,
       of_array,
       append,
       concat,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       length,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        singleton,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, singleton, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       singleton,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       [0, compare, compare_local, sexp_of_t$0],
       singleton,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       fold_right2_exn,
       fold_right2,
       for_all2_exn,
       for_all2,
       exists2_exn,
       exists2,
       rev_filter,
       partition3_map,
       partition_result,
       split_n,
       stable_sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi_exn,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold,
       unzip,
       unzip3,
       zip,
       zip_exn,
       rev_mapi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       stable_dedup,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       range$0,
       range,
       rev_filter_map,
       rev_filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       equal_local,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(62, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
//# shape: Base__Info:[F(2),F(2),F(2),F(2),F(1)*,F(2),F(1),F(1)*,F(1),N,F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(5),F(1)*,F(1),F(2)*,F(2)*,F(2)*,F(4)*,F(1)*,F(2),F(1),N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    a = [0, [0, "cycle while computing message"]],
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_List = global_data.Base__List,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    b = [0, "Could_not_construct"],
    c = [0, "String"],
    d = [0, "Exn"],
    e = [0, "Sexp"],
    f = [0, "Tag_sexp"],
    g = [0, "Tag_t"],
    h = [0, "Tag_arg"],
    i = [0, "Of_list"],
    j = [0, "With_backtrace"];
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = Base_Sexp[5].call(null, arg0_001);
       return [1, [0, b, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = Base_Import[136].call(null, arg0_003);
       return [1, [0, c, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = Base_Import[198].call(null, arg0_005);
       return [1, [0, d, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = Base_Sexp[5].call(null, arg0_007);
       return [1, [0, e, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = Base_Import[136].call(null, arg0_009),
        res1_013 = Base_Sexp[5].call(null, arg1_010),
        res2_014 =
          Base_Import[146].call(null, Base_Source_code_position0[9], arg2_011);
       return [1, [0, f, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = Base_Import[136].call(null, arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, g, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = Base_Import[136].call(null, arg0_019),
        res1_023 = Base_Sexp[5].call(null, arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, h, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = Base_Import[146].call(null, Base_Import[139], arg0_025),
        res1_028 = Base_Import[149].call(null, sexp_of_t, arg1_026);
       return [1, [0, i, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = Base_Import[136].call(null, arg1_030);
       return [1, [0, j, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, Base_Exn[1].call(null, exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         a = [0, Base_Source_code_position0[9].call(null, here$0), 0];
       else
        var a = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, a]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === runtime.caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var ts = t[2], b = Base_List[63].call(null, ts);
       return Base_List[20].call
               (null, b, ac, function(ac, t){return to_sexps_hum(t, ac);});
      default:
       var
        backtrace = t[2],
        t$2 = t[1],
        c = Base_String0[22].call(null, backtrace),
        d = [0, Base_Import[149].call(null, Base_Import[136], c), 0];
       return [0, [1, [0, to_sexp_hum(t$2), d]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function globalize_info(param){return param;}
   function compute_info$0(counter, info$3, stack$3){
    var info = info$3, stack = stack$3;
    for(;;){
     var match = info[1];
     if(typeof match === "number"){
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, a, stack]);
      var counter$0 = counter + 1 | 0;
      return compute_message(counter$0, a, stack);
     }
     if(0 !== match[0]){
      var message = match[1];
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, message, stack]);
      var counter$1 = counter + 1 | 0;
      return compute_message(counter$1, message, stack);
     }
     var cons = match[1];
     info[1] = 0;
     var stack$0 = [0, [0, info], stack];
     switch(cons[0]){
       case 0:
        var lazy_info = cons[1];
        try{
         var b = caml_obj_tag(lazy_info);
         a:
         if(250 === b)
          var info$0 = lazy_info[1];
         else{
          if(246 !== b && 244 !== b){var info$0 = lazy_info; break a;}
          var info$0 = CamlinternalLazy[2].call(null, lazy_info);
         }
         info = info$0;
         stack = stack$0;
        }
        catch(exn$0){
         var
          exn = caml_wrap_exception(exn$0),
          c = [0, Base_Exn[1].call(null, exn)];
         if(counter >= 50)
          return caml_trampoline_return(compute_message, [0, c, stack$0]);
         var counter$2 = counter + 1 | 0;
         return compute_message(counter$2, c, stack$0);
        }
        break;
       case 1:
        var infos = cons[1], d = 0;
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, infos, d, stack$0]);
        var counter$3 = counter + 1 | 0;
        return compute_info_list(counter$3, infos, d, stack$0);
       case 2:
        var
         info$1 = cons[3],
         arg = cons[2],
         tag = cons[1],
         stack$1 = [0, [1, tag, arg], stack$0];
        info = info$1;
        stack = stack$1;
        break;
       default:
        var
         info$2 = cons[2],
         tag$0 = cons[1],
         stack$2 = [0, [2, tag$0], stack$0];
        info = info$2;
        stack = stack$2;
     }
    }
   }
   function compute_info(info, stack){
    return caml_trampoline(compute_info$0(0, info, stack));
   }
   function compute_info_list(counter, fwd_prefix, rev_suffix, stack){
    if(fwd_prefix){
     var
      fwd_prefix$0 = fwd_prefix[2],
      info = fwd_prefix[1],
      a = [0, [3, fwd_prefix$0, rev_suffix], stack];
     if(counter >= 50)
      return caml_trampoline_return(compute_info$0, [0, info, a]);
     var counter$1 = counter + 1 | 0;
     return compute_info$0(counter$1, info, a);
    }
    var
     infos =
       Base_List[20].call
        (null,
         rev_suffix,
         0,
         function(tail, message){
          if(7 !== message[0]) return [0, message, tail];
          var messages = message[2];
          return Base_Import[111].call(null, messages, tail);
         }),
     b = [7, 0, infos];
    if(counter >= 50)
     return caml_trampoline_return(compute_message, [0, b, stack]);
    var counter$0 = counter + 1 | 0;
    return compute_message(counter$0, b, stack);
   }
   function compute_message(counter, message$2, stack$4){
    var message = message$2, stack = stack$4;
    for(;;){
     if(! stack) return message;
     var match = stack[1];
     switch(match[0]){
       case 0:
        var stack$0 = stack[2], info = match[1];
        info[1] = [1, message];
        stack = stack$0;
        break;
       case 1:
        var
         stack$1 = stack[2],
         arg = match[2],
         tag = match[1],
         message$0 = [6, tag, arg, message];
        message = message$0;
        stack = stack$1;
        break;
       case 2:
        var
         stack$2 = stack[2],
         tag$0 = match[1],
         message$1 = [5, tag$0, message];
        message = message$1;
        stack = stack$2;
        break;
       default:
        var
         stack$3 = stack[2],
         rev_suffix = match[2],
         fwd_prefix = match[1],
         a = [0, message, rev_suffix];
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, fwd_prefix, a, stack$3]);
        var counter$0 = counter + 1 | 0;
        return compute_info_list(counter$0, fwd_prefix, a, stack$3);
     }
    }
   }
   function to_message(info){return compute_info(info, 0);}
   function of_message(message){return [0, [1, message]];}
   function of_cons(cons){return [0, [0, cons]];}
   function of_lazy_cons(lazy_cons){
    return of_cons
            ([0,
              [246,
               function(param){
                var a = caml_obj_tag(lazy_cons);
                a:
                if(250 === a)
                 var b = lazy_cons[1];
                else{
                 if(246 !== a && 244 !== a){var b = lazy_cons; break a;}
                 var b = CamlinternalLazy[2].call(null, lazy_cons);
                }
                return of_cons(b);
               }]]);
   }
   function of_lazy_message(lazy_message){
    return of_cons
            ([0,
              [246,
               function(param){
                var a = caml_obj_tag(lazy_message);
                a:
                if(250 === a)
                 var b = lazy_message[1];
                else{
                 if(246 !== a && 244 !== a){var b = lazy_message; break a;}
                 var b = CamlinternalLazy[2].call(null, lazy_message);
                }
                return of_message(b);
               }]]);
   }
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return of_message([3, sexp]);}
   function compare(t1, t2){
    var a = sexp_of_t$0(t2), b = sexp_of_t$0(t1);
    return Base_Sexp[7].call(null, b, a);
   }
   function compare_local(t1, t2){return compare(t1, t2);}
   function equal(t1, t2){
    var a = sexp_of_t$0(t2), b = sexp_of_t$0(t1);
    return Base_Sexp[6].call(null, b, a);
   }
   function equal_local(t1, t2){return equal(t1, t2);}
   function hash_fold_t(state, t){
    var a = sexp_of_t$0(t);
    return Base_Sexp[2].call(null, state, a);
   }
   function hash(t){return Base_Hash[14].call(null, 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var a = to_sexp_hum(message);
    return Base_Sexp[16].call(null, 0, a);
   }
   function to_string_mach(t){
    var a = sexp_of_t$0(t);
    return Base_Sexp[17].call(null, a);
   }
   function of_lazy(l){
    return of_lazy_message
            ([246,
              function(param){
               var a = caml_obj_tag(l);
               a:
               if(250 === a)
                var b = l[1];
               else{
                if(246 !== a && 244 !== a){var b = l; break a;}
                var b = CamlinternalLazy[2].call(null, l);
               }
               return [1, b];
              }]);
   }
   function of_lazy_sexp(l){
    return of_lazy_message
            ([246,
              function(param){
               var a = caml_obj_tag(l);
               a:
               if(250 === a)
                var b = l[1];
               else{
                if(246 !== a && 244 !== a){var b = l; break a;}
                var b = CamlinternalLazy[2].call(null, l);
               }
               return [3, b];
              }]);
   }
   function of_lazy_t(lazy_info){return of_cons([0, lazy_info]);}
   function of_string(message){return of_message([1, message]);}
   function createf(format){
    return Base_Printf[4].call(null, of_string, format);
   }
   function of_thunk(f){
    return of_lazy_message
            ([246, function(param){return [1, caml_call1(f, 0)];}]);
   }
   function create(here, strict, tag, x, sexp_of_x){
    return strict
            ? of_message([4, tag, caml_call1(sexp_of_x, x), here])
            : of_lazy_message
              ([246,
                function(param){
                 return [4, tag, caml_call1(sexp_of_x, x), here];
                }]);
   }
   function create_s(sexp){return of_message([3, sexp]);}
   function tag(t, tag){return of_cons([3, tag, t]);}
   function tag_s_lazy(t, tag){
    return of_lazy_cons
            ([246,
              function(param){
               var a = caml_obj_tag(tag);
               a:
               if(250 === a)
                var b = tag[1];
               else{
                if(246 !== a && 244 !== a){var b = tag; break a;}
                var b = CamlinternalLazy[2].call(null, tag);
               }
               return [2, cst, b, t];
              }]);
   }
   function tag_s(t, tag){return of_cons([2, cst$0, tag, t]);}
   function tag_arg(t, tag, x, sexp_of_x){
    return of_lazy_cons
            ([246,
              function(param){return [2, tag, caml_call1(sexp_of_x, x), t];}]);
   }
   function of_list(ts){return of_cons([1, ts]);}
   var
    Exn = [248, "Base__Info.Exn", runtime.caml_fresh_oo_id(0)],
    k = [0, "src/info.ml", 261, 6];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Exn,
     function(param){
      var tag = param[1];
      if(tag !== Exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
      var t = param[2];
      return sexp_of_t$0(t);
     });
   function to_exn(info){
    var match = info[1];
    a:
    {
     if(typeof match !== "number" && 0 !== match[0]){var a = 1; break a;}
     var a = 0;
    }
    if(! a) return [0, Exn, info];
    var match$0 = to_message(info);
    if(2 !== match$0[0]) return [0, Exn, info];
    var exn = match$0[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var backtrace$0 = [0, Stdlib_Printexc[6].call(null, 0)];
     else
      var s = match[2], backtrace$0 = [0, s];
    }
    else
     var backtrace$0 = 0;
    var tag = exn[1];
    if(tag === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return of_lazy_message
             ([246, function(param){return [8, to_message(t), backtrace$1];}]);
    }
    if(! backtrace$0) return of_message([2, exn]);
    var backtrace$2 = backtrace$0[1];
    return of_lazy_message
            ([246,
              function(param){
               return [8, [3, Base_Exn[1].call(null, exn)], backtrace$2];
              }]);
   }
   function pp(ppf, t){
    var a = to_string_hum(t);
    return Stdlib_Format[13].call(null, ppf, a);
   }
   var
    include = Base_Pretty_printer[3].call(null, [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize_info,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(30, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
//# shape: Base__Error:[F(2),F(2),F(2),F(2),F(1)*,F(2),F(1),F(1)*,F(1),N,F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(5),F(1)*,F(1),F(2)*,F(2)*,F(2)*,F(4)*,F(1)*,F(2),F(1),N,N,F(1),F(1),F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    compare_local = Base_Info[2],
    equal = Base_Info[3],
    equal_local = Base_Info[4],
    globalize = Base_Info[5],
    hash_fold_t = Base_Info[6],
    hash = Base_Info[7],
    t_of_sexp = Base_Info[8],
    sexp_of_t = Base_Info[9],
    invariant = Base_Info[11],
    to_string_hum = Base_Info[12],
    to_string_mach = Base_Info[13],
    of_string = Base_Info[14],
    of_lazy = Base_Info[15],
    of_lazy_sexp = Base_Info[16],
    of_thunk = Base_Info[17],
    of_lazy_t = Base_Info[18],
    create = Base_Info[19],
    create_s = Base_Info[20],
    createf = Base_Info[21],
    tag = Base_Info[22],
    tag_s = Base_Info[23],
    tag_s_lazy = Base_Info[24],
    tag_arg = Base_Info[25],
    of_list = Base_Info[26],
    of_exn = Base_Info[27],
    to_exn = Base_Info[28],
    pp = Base_Info[29],
    Internal_repr = Base_Info[30];
   function raise(t){throw caml_maybe_attach_backtrace(to_exn(t), 1);}
   function raise_s(sexp){return raise(create_s(sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = Base_Pretty_printer[3].call(null, [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
//# shape: Base__Invariant:[F(4),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32],
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed",
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field";
   function invariant(here, t, sexp_of_t, f){
    try{var d = caml_call1(f, 0); return d;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      a = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      b = [0, [0, cst_exn, Base_Import[198].call(null, exn)], a],
      c = [0, [0, cst$0, Base_Source_code_position0[9].call(null, here)], b];
     return raise_s(Base_Sexp[10].call(null, cst_invariant_failed, c));
    }
   }
   function check_field(t, f, field){
    try{var d = caml_call1(f, Base_Field[3].call(null, field, t)); return d;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      a = [0, [0, cst_exn$0, Base_Import[198].call(null, exn)], 0],
      b = Base_Field[2].call(null, field),
      c = [0, [0, cst_field, Base_Import[136].call(null, b)], a];
     return raise_s(Base_Sexp[10].call(null, cst_problem_with_field, c));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
//# shape: Base__Or_error:[F(3),F(3),F(3),F(3),F(2),F(3),F(2),F(2),F(1)*,N,N,N,N,N,F(3),N,N,F(2),N,N,N,N,N,N,N,F(1),F(1),N,F(1)*,F(1)*,F(2),F(2),F(1)*,F(1),F(2),F(2),F(2)*,F(5),F(1)*,F(1)*,F(1),F(2),F(2),F(2),F(4),F(1),N,F(2),F(2),F(1),F(1),F(1),F(1),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative;
   function compare_local(cmp_a, a_007, b_008){
    return Base_Result[5].call(null, cmp_a, Base_Error[2], a_007, b_008);
   }
   function compare(cmp_a, a_001, b_002){
    return Base_Result[4].call(null, cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal_local(cmp_a, a_019, b_020){
    return Base_Result[7].call(null, cmp_a, Base_Error[4], a_019, b_020);
   }
   function equal(cmp_a, a_013, b_014){
    return Base_Result[6].call(null, cmp_a, Base_Error[3], a_013, b_014);
   }
   function globalize(globalize_a_026, x_027){
    return Base_Result[9].call(null, globalize_a_026, Base_Error[5], x_027);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return Base_Result[8].call(null, hash_fold_a, Base_Error[6], hsv, arg);
   }
   function t_of_sexp(of_a_030, x_032){
    return Base_Result[1].call(null, of_a_030, Base_Error[8], x_032);
   }
   function sexp_of_t(of_a_033, x_034){
    return Base_Result[2].call(null, of_a_033, Base_Error[9], x_034);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Result[3].call(null, a_sexp_grammar, Base_Error[10]);
   }
   var
    symbol_bind = Base_Result[10],
    symbol_map = Base_Result[11],
    bind = Base_Result[14],
    ignore_m = Base_Result[17],
    join = Base_Result[16],
    map = Base_Result[33],
    return$ = Base_Result[15];
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return Base_Error[11].call(null, error);
   }
   function map2(a, b, f){
    if(0 === a[0]){
     var x = a[1];
     if(0 === b[0]){var y = b[1]; return [0, caml_call2(f, x, y)];}
     var e = b;
    }
    else{
     var e1 = a[1];
     if(0 !== b[0]){
      var e2 = b[1];
      return [1, Base_Error[26].call(null, [0, e1, [0, e2, 0]])];
     }
     var e = a;
    }
    return e;
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      Base_Applicative[16].call(null, [0, return$, map2, map$0]),
    symbol = For_applicative[6],
    symbol$0 = For_applicative[5],
    symbol$1 = For_applicative[4],
    apply = For_applicative[8],
    both = For_applicative[3],
    map3 = For_applicative[10],
    include = Base_Result[13],
    symbol_bind$0 = include[1],
    symbol_map$0 = include[2],
    Open_on_rhs = [0],
    ok = Base_Result[26],
    is_ok = Base_Result[24],
    is_error = Base_Result[25],
    a = [0, 3553398];
   function try_with(opt, f){
    var backtrace = opt ? opt[1] : 0;
    try{var c = [0, caml_call1(f, 0)]; return c;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), b = backtrace ? a : 0;
     return [1, Base_Error[27].call(null, b, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return Base_Error[31].call(null, err);
   }
   function of_exn(backtrace, exn){
    return [1, Base_Error[27].call(null, backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   var
    of_option = Base_Result[30],
    cst_unimplemented = "unimplemented",
    b = [0, "src/or_error.ml", 192, 21];
   function error(here, strict, message, a, sexp_of_a){
    return [1, Base_Error[19].call(null, here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, Base_Error[20].call(null, sexp)];}
   function error_string(message){
    return [1, Base_Error[14].call(null, message)];
   }
   function errorf(format){
    return Base_Printf[4].call(null, error_string, format);
   }
   function tag(t, tag){
    var a = Base_Error[22];
    return Base_Result[34].call(null, t, function(b){return a(b, tag);});
   }
   function tag_s(t, tag){
    var a = Base_Error[23];
    return Base_Result[34].call(null, t, function(b){return a(b, tag);});
   }
   function tag_s_lazy(t, tag){
    var a = Base_Error[24];
    return Base_Result[34].call(null, t, function(b){return a(b, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return Base_Result[34].call
            (null,
             t,
             function(e){
              return Base_Error[25].call(null, e, message, a, sexp_of_a);
             });
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[136]);
   }
   function error_of_list_if_necessary(list){
    if(list && ! list[2]){var e = list[1]; return e;}
    return Base_Error[26].call(null, list);
   }
   function all(list){
    var match = Base_Result[36].call(null, list);
    if(0 === match[0]){var x = match[1]; return [0, x];}
    var errs = match[1];
    return [1, error_of_list_if_necessary(errs)];
   }
   function all_unit(list){
    var match = Base_Result[36].call(null, list);
    if(0 === match[0]) return [0, 0];
    var errs = match[1];
    return [1, error_of_list_if_necessary(errs)];
   }
   function combine_errors(list){
    var on_error = Base_Error[26], match = Base_Result[36].call(null, list);
    if(0 === match[0]){var x = match[1]; return [0, x];}
    var errs = match[1];
    return [1, on_error(errs)];
   }
   function combine_errors_unit(list){
    var on_error = Base_Error[26], match = Base_Result[36].call(null, list);
    if(0 === match[0]) return [0, 0];
    var errs = match[1];
    return [1, on_error(errs)];
   }
   function filter_ok_at_least_one(l){
    var
     match = Base_List[16].call(null, l, Base_Result[38]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, Base_Error[26].call(null, errs)];
   }
   function find_ok(l){
    var match = Base_List[28].call(null, l, Base_Result[26]);
    if(match){var x = match[1]; return [0, x];}
    var
     a =
       Base_List[53].call
        (null,
         l,
         function(param){
          if(0 === param[0])
           throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
          var err = param[1];
          return err;
         });
    return [1, Base_Error[26].call(null, a)];
   }
   function find_map_ok(l, f){
    return Base_With_return[1].call
            (null,
             function(param){
              var
               a =
                 Base_List[53].call
                  (null,
                   l,
                   function(elt){
                    var x = caml_call1(f, elt);
                    if(0 === x[0]) return caml_call1(param, x);
                    var err = x[1];
                    return err;
                   });
              return [1, Base_Error[26].call(null, a)];
             });
   }
   var
    map$1 = Base_Result[33],
    iter = Base_Result[31],
    iter_error = Base_Result[32],
    Base_Or_error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol$1,
       symbol$0,
       symbol,
       apply,
       map2,
       map3,
       For_applicative[13],
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[13],
       bind,
       return$,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$,
        symbol_bind$0,
        symbol_map$0,
        [0, return$, bind, map, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       of_option,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
//# shape: Base__Sign0:[F(1),F(1)*,N,F(2)*,F(2)*,F(2),N,[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*],F(1),F(1),F(1)*,F(1)*,N,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    a = [0, cst_Neg],
    b = [0, cst_Zero],
    c = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var a = sexp_004[1];
      b:
      if(a !== cst_Neg){
       c:
       if(a !== cst_Pos){
        if(a !== cst_Zero){
         if(a === cst_neg) break b;
         if(a === cst_pos) break c;
         if(a !== cst_zero) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var match = sexp_004[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_003, sexp_004);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_003, sexp_004);
     var b = match$0[1];
     b:
     if(b !== cst_Neg){
      c:
      if(b !== cst_Pos){
       if(b !== cst_Zero){
        if(b === cst_neg) break b;
        if(b === cst_pos) break c;
        if(b !== cst_zero) break a;
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_003, sexp_004);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_003, sexp_004);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_003, sexp_004);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return a;case 1: return b;default: return c;
    }
   }
   var compare_local = caml_int_compare, compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var a = 0; break;
      case 1:
       var a = 1; break;
      default: var a = 2;
    }
    return Base_Hash[3].call(null, hsv, a);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending(x, y){return Base_Poly0[2].call(null, x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       equal_local,
       max,
       min];
   function of_string(s){return t_of_sexp(Base_Import[136].call(null, s));}
   function to_string(t){
    var a = sexp_of_t(t);
    return Base_Import[160].call(null, a);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare_local,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
//# shape: Base__Comparable_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
//# shape: Base__Comparable:[F(3),F(4),F(3),F(3),F(3),F(3),F(3),F(1)*,F(1)*,F(2)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    a = [0, cst_src_comparable_ml, 47, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    b = [0, cst_src_comparable_ml, 135, 4],
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1;
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Comparisons(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Comparisons([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var a = caml_call2(symbol$0, low, t);
     return a ? caml_call2(symbol$0, t, high) : a;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      a = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      b = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], a],
      c = Base_Sexp[10].call(null, cst_clamp_requires_min_max$0, b);
     return Base_Or_error[39].call(null, c);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = Base_Comparator[7].call(null, T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var a = caml_call1(T[2], t), b = caml_call1(T[2], t$0);
     return caml_call2(C[1], b, a);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var a = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), a);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function compare_reversed(cmp, x, y){return caml_call2(cmp, y, x);}
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       compare_reversed,
       equal,
       max,
       min,
       Infix,
       Comparisons,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var a = caml_lessequal(low, t), b = a ? caml_lessequal(t, high) : a;
         return b;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          a = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          b = [0, [0, cst_min, caml_call1(T[1], min)], a],
          c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
         return Base_Or_error[39].call(null, c);
        }
        var
         include = Base_Comparator[7].call(null, [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       function(c){
        var a = c[3], b = c[1];
        function is_positive(t){return 0 < caml_call2(b, t, a) ? 1 : 0;}
        function is_non_negative(t){return 0 <= caml_call2(b, t, a) ? 1 : 0;}
        function is_negative(t){return caml_call2(b, t, a) < 0 ? 1 : 0;}
        function is_non_positive(t){return caml_call2(b, t, a) <= 0 ? 1 : 0;}
        function sign(t){
         var c = caml_call2(b, t, a);
         return Base_Sign0[14].call(null, c);
        }
        return [0,
                is_positive,
                is_non_negative,
                is_negative,
                is_non_positive,
                sign];
       }];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import
//# shape: Base__Hashable_intf:[[F(2)*,F(3)*,F(1)*,N,F(1)*,F(1)*],F(2)*,F(3)*,F(1)*,N,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function equal(a, b){
    var d = a === b ? 1 : 0;
    if(d)
     var c = d;
    else{
     var e = a[1] === b[1] ? 1 : 0;
     if(e)
      var f = a[2] === b[2] ? 1 : 0, c = f ? a[3] === b[3] ? 1 : 0 : f;
     else
      var c = e;
    }
    return c;
   }
   var
    hash_param = Base_Import[85][105][30],
    hash = Base_Import[85][105][28],
    a = [0, "_"],
    poly = [0, hash, runtime.caml_compare, function(param){return a;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    Base_Hashable_intf =
      [0, Hashable, equal, hash_param, hash, poly, of_key, to_key];
   runtime.caml_register_global(2, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
//# shape: Base__Hashable:[F(2)*,N,F(1)*,F(1)*,F(3)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
//# shape: Base__Stringable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
//# shape: Base__Identifiable_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
//# shape: Base__Identifiable:[F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         a = Base_Comparable[11].call(null, [0, T[1], T[5]]),
         symbol = a[1],
         symbol$0 = a[2],
         symbol$1 = a[3],
         symbol$2 = a[4],
         symbol$3 = a[5],
         symbol$4 = a[6],
         equal = a[7],
         compare = a[8],
         min = a[9],
         max = a[10],
         ascending = a[11],
         descending = a[12],
         between = a[13],
         clamp_exn = a[14],
         clamp = a[15],
         comparator = a[16],
         include = Base_Pretty_printer[2].call(null, [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         a = Base_Comparable[12].call(null, [0, T[5], T[9]]),
         symbol = a[1],
         symbol$0 = a[2],
         symbol$1 = a[3],
         symbol$2 = a[4],
         symbol$3 = a[5],
         symbol$4 = a[6],
         equal = a[7],
         compare = a[8],
         min = a[9],
         max = a[10],
         ascending = a[11],
         descending = a[12],
         between = a[13],
         clamp_exn = a[14],
         clamp = a[15],
         comparator = a[16],
         include = Base_Pretty_printer[2].call(null, [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       }];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
//# shape: Base__Unit:[N,F(1)*,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    globalize = Base_Import[290],
    hash_fold_t = Base_Import[210],
    func = Base_Import[224];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[158],
    sexp_of_t = Base_Import[134],
    t_sexp_grammar = Base_Import[180],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function compare(a, param){return 0;}
   function compare_local(a, param){return 0;}
   function equal_local(a, param){return 1;}
   function of_string(param){
    return param !== cst$0
            ? Base_Import[124].call(null, cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      Base_Identifiable[1].call
       (null,
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Error, Base__Ordered_collection_common0, Stdlib
//# shape: Base__Ordered_collection_common:[F(4),F(3),[F(3)],F(4)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Error = global_data.Base__Error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{var a = [0, get_pos_len_exn(pos, len, 0, total_length)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return [1, Base_Error[14].call(null, s)];
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Import, Base__Ordered_collection_common
//# shape: Base__Binary_search:[F(8),F(7)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     c = caml_call1(length, t),
     match = Base_Ordered_collection_common[1].call(null, pos, len, 0, c),
     len$0 = match[2],
     pos$0 = match[1],
     d = Base_Import[91].call(null, pos$0, len$0),
     hi$0 = Base_Import[93].call(null, d, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= Base_Import[93].call(null, hi, lo$1)){var lo = lo$1; break;}
     var
      a = Base_Import[93].call(null, hi, lo$1),
      b = Base_Import[95].call(null, a, 2),
      mid = Base_Import[91].call(null, lo$1, b);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      hi = mid;
     else{var lo$2 = Base_Import[91].call(null, mid, 1); lo$1 = lo$2;}
    }
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = Base_Import[91].call(null, lo, 1);
     lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     a = caml_call1(length, t),
     match = Base_Ordered_collection_common[1].call(null, pos, len, 0, a),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0],
         [0, len$0],
         t,
         get,
         length,
         function(x){return 1 - caml_call1(pred, x);});
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, Base_Import[93].call(null, i, 1)];
    }
    var b = Base_Import[91].call(null, pos$0, len$0);
    return [0, Base_Import[93].call(null, b, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(2, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
//# shape: Base__Binary_searchable_intf:[[N],[N]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
//# shape: Base__Binary_searchable:[F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return Base_Binary_search[1].call
             (null, pos, len, t, length, get, compare, how, v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return Base_Binary_search[2].call
             (null, pos, len, t, length, get, segment_of, how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], a = Make_gen([0, get, length]);
        return [0, a[3], a[4]];
       },
       function(T){
        var get = T[1], length = T[2], a = Make_gen([0, get, length]);
        return [0, a[3], a[4]];
       }];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
//# shape: Base__Blit_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib__BytesLabels
//# shape: Base__Bytes0:[[],N,F(5),F(5),F(2)*,F(1),F(1)*,F(3),F(3),F(3),F(4),F(3),F(3),F(1),F(4),F(2),F(2),F(2),F(3),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[40],
    copy = Stdlib_BytesLabels[4],
    create = caml_create_bytes,
    set_uchar_utf_8 = Stdlib_BytesLabels[51],
    set_uchar_utf_16le = Stdlib_BytesLabels[57],
    set_uchar_utf_16be = Stdlib_BytesLabels[54];
   function set_utf_32_uchar(set_int32, bytes, idx, uchar){
    var
     a = Base_Uchar0[8].call(null, uchar),
     b = Base_Int_conversions[3].call(null, a);
    caml_call1(caml_call2(set_int32, bytes, idx), b);
    return 4;
   }
   var a = Stdlib_BytesLabels[83];
   function set_uchar_utf_32le(b, c, d){return set_utf_32_uchar(a, b, c, d);}
   var
    b = Stdlib_BytesLabels[82],
    cst_Bytes_create_local = "Bytes.create_local";
   function set_uchar_utf_32be(a, c, d){return set_utf_32_uchar(b, a, c, d);}
   function create_local(len){
    if(Base_Sys0[10] < len)
     Base_Import0[126].call(null, cst_Bytes_create_local);
    return runtime.Base_unsafe_create_local_bytes(len);
   }
   var fill = Stdlib_BytesLabels[10], make = Stdlib_BytesLabels[1];
   function map(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     a = Base_Import0[93].call(null, l, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(t, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   function mapi(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     a = Base_Import0[93].call(null, l, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(t, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return r;
   }
   var
    sub = Stdlib_BytesLabels[7],
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       set_uchar_utf_8,
       set_uchar_utf_16le,
       set_uchar_utf_16be,
       set_utf_32_uchar,
       set_uchar_utf_32le,
       set_uchar_utf_32be,
       create_local,
       fill,
       make,
       map,
       mapi,
       sub,
       to_string,
       of_string];
   runtime.caml_register_global(6, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Import, Base__Ordered_collection_common
//# shape: Base__Blit:[F(1)*,F(2)*,F(2)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var b = caml_call1(Src[1], src);
     Base_Ordered_collection_common[2].call(null, src_pos, len, b);
     var c = caml_call1(Dst[1], dst);
     Base_Ordered_collection_common[2].call(null, dst_pos, len, c);
     var a = 0 < len ? 1 : 0;
     return a ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len) : a;
    }
    function blito(src, b, a, dst, opt, param){
     var src_pos = b ? b[1] : 0;
     if(a)
      var src_len = a[1];
     else
      var
       c = caml_call1(Src[1], src),
       src_len = Base_Import[93].call(null, c, src_pos);
     var dst_pos = opt ? opt[1] : 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var a = caml_call1(Src[1], src);
     Base_Ordered_collection_common[2].call(null, pos, len, a);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     var pos = opt ? opt[1] : 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       a = caml_call1(Src[1], src),
       i$0 = Base_Import[93].call(null, a, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     return caml_string_of_bytes(caml_call3(To_bytes[4], src, pos, len));
    }
    function subo(pos, len, src){
     return caml_string_of_bytes(caml_call3(To_bytes[5], pos, len, src));
    }
    return [0, sub, subo];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       function(Src, Dst){
        var length = Dst[1];
        function create_like(len, param){return caml_call1(Dst[2], len);}
        var
         unsafe_blit = Dst[3],
         length$0 = Src[1],
         a = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
        return [0, a[2], a[3], a[1], a[4], a[5]];
       },
       Make_to_string,
       function(b){
        var c = [0, b[2], b[1], b[3]], a = Make_gen([0, c[1]], c);
        return [0, a[2], a[3], a[1], a[4], a[5]];
       },
       function(b){
        var a = Make_gen([0, b[2]], [0, b[2], b[1], b[3]]);
        return [0, a[2], a[3], a[1], a[4], a[5]];
       }];
   runtime.caml_register_global(2, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Base__Bool0, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
//# shape: Base__Bool:[N,F(1)*,N,N,F(1),F(1),F(1)*,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,F(2)*,F(2)*,F(1)*,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    globalize = Base_Import[281],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[159],
    sexp_of_t = Base_Import[135],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t],
    a =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"];
   function of_string(s){
    return s !== "false"
            ? s !== "true" ? caml_call2(invalid_argf(a), s, 0) : 1
            : 0;
   }
   var
    to_string = Base_Import[85][30],
    include = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 = Base_Pretty_printer[2].call(null, [0, module_name, to_string]),
    pp = include$0[1],
    b = [0, cst_src_bool_ml, 59, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var a = Base_Import[105][2].call(null, low, t);
    return a ? Base_Import[105][2].call(null, t, high) : a;
   }
   function clamp_unchecked(t, min, max){
    return Base_Import[105][1].call(null, t, min)
            ? min
            : Base_Import[105][2].call(null, t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(Base_Import[105][2].call(null, min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function clamp(t, min, max){
    if(! Base_Import[105][5].call(null, min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function to_int(x){return Base_Import[86].call(null, x);}
   function symbol(a, b){
    var c = to_int(b), d = to_int(a), x = Base_Import[118].call(null, d, c);
    return x;
   }
   function symbol$0(a, b){
    var c = to_int(b), d = to_int(a), x = Base_Import[116].call(null, d, c);
    return x;
   }
   var c = [0, cst_src_bool_ml, 86, 9];
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[105],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     compare_local = include$1[10],
     equal = include$1[11],
     equal_local = include$1[12],
     max = include$1[13],
     min = include$1[14],
     Base_Bool =
       [0,
        all,
        globalize,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        compare_local,
        equal_local,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
//# shape: Base__Either_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__With_return
//# shape: Base__Either:[F(4),F(4),F(4),F(3),F(3),F(2)*,F(3),F(1)*,F(1)*,F(3),F(3),F(3),F(4),F(4),N,N,F(1)*,F(1)*,F(1)*,F(1)*,[]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare_local = Base_Either0[1],
    compare = Base_Either0[2],
    hash_fold_t = Base_Either0[3],
    t_of_sexp = Base_Either0[4],
    sexp_of_t = Base_Either0[5],
    t_sexp_grammar = Base_Either0[6];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function local_equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$ = M[1],
     other = M[2],
     focus = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         var
          res =
            caml_call2
             (bind,
              t,
              function(x){return caml_call1(return$, caml_call1(f, x));});
         return res;
        }],
     include = Base_Monad[6].call(null, [0, bind, map, return$]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$0 = include[6],
     join = include[8],
     ignore_m = include[9],
     map$0 = [0, -198771759, include[7]];
    function map2(t1, t2, f){
     return caml_call2
             (bind$0,
              t1,
              function(x){
               return caml_call2
                       (bind$0,
                        t2,
                        function(y){
                         return caml_call1(return$0, caml_call2(f, x, y));
                        });
              });
    }
    var
     App = Base_Applicative[17].call(null, [0, return$0, map2, map$0]),
     return$1 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply = App[8],
     map2$0 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function combine_all(ts$1, f){
     var acc$1 = 0, param$0 = ts$1;
     for(;;){
      if(! param$0)
       return caml_call1(return$1, Base_List0[19].call(null, acc$1));
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var acc$2 = [0, match$0[1], acc$1];
      acc$1 = acc$2;
      param$0 = ts$0;
     }
     var acc$3 = match$0[1], acc = acc$3, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       param = ts;
      else{var acc$0 = caml_call2(f, acc, match[1]); acc = acc$0; param = ts;}
     }
    }
    function combine_all_unit(ts$1, f){
     var param$0 = ts$1;
     for(;;){
      if(! param$0) return caml_call1(return$1, 0);
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      param$0 = ts$0;
     }
     var acc$1 = match$0[1], acc = acc$1, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       param = ts;
      else{var acc$0 = caml_call2(f, acc, match[1]); acc = acc$0; param = ts;}
     }
    }
    function to_option(t){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? [0, match[1]] : 0;
    }
    function value(t, default$){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? match[1] : default$;
    }
    function with_return(f){
     return Base_With_return[1].call
             (null,
              function(ret){
               return caml_call1
                       (other,
                        caml_call1(f, Base_With_return[3].call(null, ret, return$1)));
              });
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$1,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2$0,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function focus(t){
    if(0 === t[0]){var x = t[1]; return [0, x];}
    var y = t[1];
    return [1, y];
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, focus, combine, bind]);
   function focus$0(t){
    if(0 === t[0]){var y = t[1]; return [1, y];}
    var x = t[1];
    return [0, x];
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, focus$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       local_equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(5, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
//# shape: Base__Option:[N,N,F(2),N,F(1)*,F(3),F(3),F(2),F(2),F(2),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(2)*,F(4),F(3),F(2),F(3),F(3),F(1)*,F(2),F(2),F(2),F(2),F(2),F(1)*,F(1)*,F(2),F(3),F(2),F(1),F(1),F(1)*,F(2)*,F(2)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare_local = Base_Import[265],
    compare = Base_Import[237],
    globalize = Base_Import[294],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Import[193].call(null, a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$, f){
    if(! o) return default$;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$){
    if(! t) return default$;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       a = Base_Source_code_position0[9],
       b = Base_Error[9],
       c = Base_Import[147],
       d = value(message, cst),
       error$0 =
         Base_Error[19].call
          (null, 0, 0, d, [0, e, p], function(d){return c(b, a, d);});
     else if(message)
      var
       m = message[1],
       error$0 =
         Base_Error[19].call(null, 0, 0, m, p, Base_Source_code_position0[9]);
     else
      var
       error$0 =
         Base_Error[19].call
          (null, 0, 0, cst_Option_value_exn, p, Base_Source_code_position0[9]);
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], error$0 = Base_Error[22].call(null, e$0, m$0);
     else
      var error$0 = e$0;
    }
    else if(message)
     var m$1 = message[1], error$0 = Base_Error[14].call(null, m$1);
    else
     var error$0 = Base_Error[14].call(null, cst_Option_value_exn_None);
    return Base_Error[31].call(null, error$0);
   }
   function value_or_thunk(o, default$){
    if(! o) return caml_call1(default$, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function equal_local(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(exn){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(exn){return 0;}
   }
   function return$(x){return [0, x];}
   var
    map =
      [0,
       -198771759,
       function(t, f){
        if(! t) return 0;
        var a = t[1];
        return [0, caml_call1(f, a)];
       }];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    include = Base_Monad[5].call(null, [0, bind, return$, map]),
    symbol_bind = include[1],
    Monad_infix = include[3],
    bind$0 = include[4],
    join = include[7],
    ignore_m = include[8],
    Let_syntax = include[11];
   function return$0(x){return [0, x];}
   var map$0 = [0, -198771759, include[6]];
   function map2(x, y, f){
    if(x && y){
     var y$0 = y[1], x$0 = x[1];
     return [0, caml_call2(f, x$0, y$0)];
    }
    return 0;
   }
   var
    include$0 = Base_Applicative[16].call(null, [0, return$0, map2, map$0]),
    return$1 = include$0[1],
    map$1 = include$0[2],
    both = include$0[3],
    symbol = include$0[4],
    symbol$0 = include$0[5],
    symbol$1 = include$0[6],
    symbol_map = include$0[7],
    apply = include$0[8],
    map2$0 = include$0[9],
    map3 = include$0[10],
    all = include$0[11],
    all_unit = include$0[12],
    Applicative_infix = include$0[13],
    Base_Option =
      [0,
       compare,
       compare_local,
       globalize,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       equal_local,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2$0,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$1,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some];
   runtime.caml_register_global(8, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
//# shape: Base__Ppx_enumerate_lib:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Base__Array0, Base__Bool, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Result, CamlinternalLazy, Sexplib0__Sexp_conv_error
//# shape: Base__Sequence:[F(2)*,F(2),F(3),F(3),F(3),F(3),F(3),F(1),F(1),F(2),F(3),F(3),F(4),F(2),F(2),F(2),F(3),F(2),F(2),F(1),F(1),F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(2),N,N,N,N,N,N,N,N,N,N,N,N,F(1),[F(3)],F(2)*,F(2)*,F(3)*,F(5)*,F(2),F(2),F(3)*,F(3)*,F(2)*,F(2)*,F(2)*,F(3),F(3)*,N,F(3)*,F(1),F(1),F(1),F(1),F(2),F(2),F(2)*,F(1),F(2),F(2),F(1)*,F(1)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2),F(2)*,F(5)*,F(2)*,F(2),F(2),F(1)*,F(3),F(2),F(2),F(2),F(2)*,F(2)*,F(2),F(2),F(2),F(2)*,F(2)*,F(2),[F(2)*],F(2),F(2),F(2)*,F(1),F(1)*,F(1),F(4),F(5),F(4),F(1),F(1)*,F(1)*,F(1)*,F(1),F(2),F(3),F(1)*,F(1)*->F(1),N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    cst_state = "state",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    init = [0, 0, 0],
    error_source_057 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Base_Bool = global_data.Base__Bool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    b = [0, "Done"],
    c = [0, cst_state],
    d = [0, "Skip"],
    e = [0, cst_state],
    f = [0, "value"],
    g = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return b;
    if(0 === param[0]){
     var
      state_004 = param[1],
      arg_005 = caml_call1(of_s_002, state_004),
      bnds_003 = [0, [1, [0, c, [0, arg_005, 0]]], 0];
     return [1, [0, d, bnds_003]];
    }
    var
     state_009 = param[2],
     value_007 = param[1],
     arg_010 = caml_call1(of_s_002, state_009),
     bnds_006 = [0, [1, [0, e, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(of_a_001, value_007),
     bnds_006$0 = [0, [1, [0, f, [0, arg_008, 0]]], bnds_006];
    return [1, [0, g, bnds_006$0]];
   }
   var Step = [0, sexp_of_t], T = [0], h = [0, "src/sequence.ml", 304, 14];
   function globalize(a, param){
    var next = param[2], state = param[1];
    return [0, state, next];
   }
   function view(t){return t;}
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f, acc, 0, function(a){return loop(s$0, next, finish, f, a);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(a){return loop(s$1, next, finish, f, a);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    function f$0(s){
     var match = caml_call1(f, s);
     if(! match) return 0;
     var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
     return [1, a, s$0];
    }
    return [0, init, f$0];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             var variant = state[1];
             if(301075099 <= variant){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(init){
    function f(param){
     if(! param) return 0;
     var l = param[2], x = param[1];
     return [1, x, l];
    }
    return [0, init, f];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1], v$0 = caml_call2(f, v, a);
      seed = seed$1;
      v = v$0;
     }
    }
   }
   function to_list_rev(t){
    var next = t[2], seed$2 = t[1], v$0 = 0, seed$1 = seed$2;
    for(;;){
     var match = caml_call1(next, seed$1);
     if(typeof match === "number") return v$0;
     if(0 === match[0]){
      var seed = match[1];
      seed$1 = seed;
     }
     else{
      var seed$0 = match[2], a = match[1], v = [0, a, v$0];
      v$0 = v;
      seed$1 = seed$0;
     }
    }
   }
   function to_list(param){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]) break;
     var s$1 = match[1];
     s$0 = s$1;
    }
    var
     s$2 = match[2],
     a = match[1],
     block = [0, a, 24029],
     dst = block,
     offset = 1,
     s$3 = s$2;
    for(;;){
     var match$0 = caml_call1(next, s$3);
     if(typeof match$0 === "number"){dst[offset + 1] = 0; return block;}
     if(0 === match$0[0]){
      var s$4 = match$0[1];
      s$3 = s$4;
     }
     else{
      var s$5 = match$0[2], a$0 = match$0[1], dst$0 = [0, a$0, 24029];
      dst[offset + 1] = dst$0;
      dst = dst$0;
      offset = 1;
      s$3 = s$5;
     }
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var a = to_list(t);
    return Base_Import[149].call(null, sexp_of_a, a);
   }
   function range(b, a, opt, start_v, stop_v){
    var
     stride = b ? b[1] : 1,
     start = a ? a[1] : 104758188,
     stop = opt ? opt[1] : -160346914,
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, Base_Import[91].call(null, i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, Base_Import[91].call(null, i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, Base_Import[91].call(null, i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, Base_Import[91].call(null, i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : Base_Import[91].call(null, start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    function f(t_lazy){
     var a = caml_obj_tag(t_lazy);
     a:
     if(250 === a)
      var match = t_lazy[1];
     else{
      if(246 !== a && 244 !== a){var match = t_lazy; break a;}
      var match = CamlinternalLazy[2].call(null, t_lazy);
     }
     var next = match[2], s = match[1], match$0 = caml_call1(next, s);
     if(typeof match$0 === "number") return 0;
     if(0 === match$0[0]){
      var s$0 = match$0[1], v = [0, s$0, next];
      return [0, v];
     }
     var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
     return [1, x, v$0];
    }
    return [0, t_lazy, f];
   }
   function a(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              b = [0, Base_Import[91].call(null, i, 1), s$1];
             return [1, caml_call2(f, i, a), b];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, Base_Import[91].call(null, i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var b = Base_Import[127];
    return a
            (filter
              (mapi(t, function(i, s){return [0, i, s];}),
               function(param){
                var s = param[2], i = param[1];
                return caml_call2(f, i, s);
               }),
             b);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      i = i$0;
      s = s$1;
     }
    }
   }
   function to_array(t){
    var next = t[2], seed$2 = t[1], v$0 = init, seed$1 = seed$2;
    for(;;){
     var match = caml_call1(next, seed$1);
     if(typeof match === "number") break;
     if(0 === match[0]){
      var seed = match[1];
      seed$1 = seed;
     }
     else{
      var
       seed$0 = match[2],
       a$0 = match[1],
       i = v$0[2],
       l = v$0[1],
       v = [0, [0, a$0, l], Base_Import[91].call(null, i, 1)];
      v$0 = v;
      seed$1 = seed$0;
     }
    }
    var len = v$0[2], l$0 = v$0[1];
    if(! l$0) return [0];
    var
     l$1 = l$0[2],
     x = l$0[1],
     a = Base_Array0[4].call(null, len, x),
     i$2 = Base_Import[93].call(null, len, 2),
     i$0 = i$2,
     l$2 = l$1;
    for(;;){
     if(! l$2){
      if(-1 === i$0) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
     }
     var l$3 = l$2[2], x$0 = l$2[1];
     runtime.caml_check_bound(a, i$0)[i$0 + 1] = x$0;
     var i$1 = Base_Import[93].call(null, i$0, 1);
     i$0 = i$1;
     l$2 = l$3;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      s = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return [0, a]; s = match[2];}
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = Base_Import[91].call(null, i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      s = match[1];
     else{var a = match[1]; if(! caml_call1(f, a)) return 0; s = match[2];}
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var s$1 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      s = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; s = match[2];}
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var s$1 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1];
     s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      s = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      s = match[2];
     }
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    function f$0(param){
     var
      rest = param[2],
      match = param[1],
      next = match[2],
      seed = match[1],
      match$0 = caml_call1(next, seed);
     if(typeof match$0 === "number"){
      var
       next$0 = rest[2],
       seed$0 = rest[1],
       match$1 = caml_call1(next$0, seed$0);
      if(typeof match$1 === "number") return 0;
      if(0 === match$1[0]){
       var s = match$1[1];
       return [0, [0, empty, [0, s, next$0]]];
      }
      var s$0 = match$1[2], a = match$1[1];
      return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
     }
     if(0 === match$0[0]){
      var s$1 = match$0[1];
      return [0, [0, [0, s$1, next], rest]];
     }
     var s$2 = match$0[2], a$0 = match$0[1];
     return [1, a$0, [0, [0, s$2, next], rest]];
    }
    var init = [0, empty, t];
    return [0, init, f$0];
   }
   function return$(x){
    function f(param){
     if(! param) return 0;
     var x = param[1];
     return [1, x, 0];
    }
    var init = [0, x];
    return [0, init, f];
   }
   var
    map = [0, -198771759, a],
    include = Base_Monad[1].call(null, [0, bind, return$, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$0 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_Sequence_nth = cst_Sequence_nth$1,
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    i = [0, cst_Left$0],
    j = [0, cst_Right$0],
    k = [0, cst_Both$0],
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    cst_hd_exn = "hd_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_drop = "Sequence.drop";
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(0 === i) return [0, a];
      var i$0 = Base_Import[93].call(null, i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return Base_Import[126].call(null, cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return Base_Import[124].call(null, cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare_local(cmp_a, cmp_b, a_023, b_024){
    if(a_023 === b_024) return 0;
    switch(a_023[0]){
      case 0:
       var a_025 = a_023[1];
       if(0 !== b_024[0]) return -1;
       var b_026 = b_024[1];
       return caml_call2(cmp_a, a_025, b_026);
      case 1:
       var a_027 = a_023[1];
       switch(b_024[0]){
         case 1:
          var b_028 = b_024[1]; return caml_call2(cmp_b, a_027, b_028);
         case 2:
          return -1;
       }
       break;
      default:
       var a_031 = a_023[2], a_029 = a_023[1];
       switch(b_024[0]){
         case 1:
          return 1;
         case 2:
          var
           b_032 = b_024[2],
           b_030 = b_024[1],
           n = caml_call2(cmp_a, a_029, b_030);
          return 0 === n ? caml_call2(cmp_b, a_031, b_032) : n;
       }
    }
    return 1;
   }
   function compare(cmp_a, cmp_b, a_013, b_014){
    if(a_013 === b_014) return 0;
    switch(a_013[0]){
      case 0:
       var a_015 = a_013[1];
       if(0 !== b_014[0]) return -1;
       var b_016 = b_014[1];
       return caml_call2(cmp_a, a_015, b_016);
      case 1:
       var a_017 = a_013[1];
       switch(b_014[0]){
         case 1:
          var b_018 = b_014[1]; return caml_call2(cmp_b, a_017, b_018);
         case 2:
          return -1;
       }
       break;
      default:
       var a_021 = a_013[2], a_019 = a_013[1];
       switch(b_014[0]){
         case 1:
          return 1;
         case 2:
          var
           b_022 = b_014[2],
           b_020 = b_014[1],
           n = caml_call2(cmp_a, a_019, b_020);
          return 0 === n ? caml_call2(cmp_b, a_021, b_022) : n;
       }
    }
    return 1;
   }
   function equal_local(cmp_a, cmp_b, a_043, b_044){
    if(a_043 === b_044) return 1;
    switch(a_043[0]){
      case 0:
       var a_045 = a_043[1];
       if(0 !== b_044[0]) return 0;
       var b_046 = b_044[1];
       return caml_call2(cmp_a, a_045, b_046);
      case 1:
       var a_047 = a_043[1];
       switch(b_044[0]){
         case 1:
          var b_048 = b_044[1]; return caml_call2(cmp_b, a_047, b_048);
         case 2:
          return 0;
       }
       break;
      default:
       var a_051 = a_043[2], a_049 = a_043[1];
       switch(b_044[0]){
         case 1:
          return 0;
         case 2:
          var
           b_052 = b_044[2],
           b_050 = b_044[1],
           a = caml_call2(cmp_a, a_049, b_050);
          return a ? caml_call2(cmp_b, a_051, b_052) : a;
       }
    }
    return 0;
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 1;
    switch(a_033[0]){
      case 0:
       var a_035 = a_033[1];
       if(0 !== b_034[0]) return 0;
       var b_036 = b_034[1];
       return caml_call2(cmp_a, a_035, b_036);
      case 1:
       var a_037 = a_033[1];
       switch(b_034[0]){
         case 1:
          var b_038 = b_034[1]; return caml_call2(cmp_b, a_037, b_038);
         case 2:
          return 0;
       }
       break;
      default:
       var a_041 = a_033[2], a_039 = a_033[1];
       switch(b_034[0]){
         case 1:
          return 0;
         case 2:
          var
           b_042 = b_034[2],
           b_040 = b_034[1],
           a = caml_call2(cmp_a, a_039, b_040);
          return a ? caml_call2(cmp_b, a_041, b_042) : a;
       }
    }
    return 0;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = Base_Hash[3].call(null, hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = Base_Hash[3].call(null, hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = Base_Hash[3].call(null, hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_053, of_b_054, sexp_059){
    a:
    {
     if(0 === sexp_059[0]){
      var a = sexp_059[1];
      b:
      if(a !== cst_Both$0){
       c:
       if(a !== cst_Left$0){
        if(a !== cst_Right$0){
         if(a === cst_both) break b;
         if(a === cst_left) break c;
         if(a !== cst_right) break a;
        }
        return Sexplib0_Sexp_conv_error[9].call
                (null, error_source_057, sexp_059);
       }
       return Sexplib0_Sexp_conv_error[9].call
               (null, error_source_057, sexp_059);
      }
      return Sexplib0_Sexp_conv_error[9].call
              (null, error_source_057, sexp_059);
     }
     var match = sexp_059[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_057, sexp_059);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_057, sexp_059);
     var tag_060 = match$0[1];
     b:
     if(tag_060 !== cst_Both$0){
      c:
      if(tag_060 !== cst_Left$0){
       if(tag_060 !== cst_Right$0){
        if(tag_060 === cst_both) break b;
        if(tag_060 === cst_left) break c;
        if(tag_060 !== cst_right) break a;
       }
       var sexp_args_066 = match[2];
       if(sexp_args_066 && ! sexp_args_066[2]){
        var
         arg0_067 = sexp_args_066[1],
         res0_068 = caml_call1(of_b_054, arg0_067);
        return [1, res0_068];
       }
       return Sexplib0_Sexp_conv_error[8].call
               (null, error_source_057, tag_060, sexp_059);
      }
      var sexp_args_061 = match[2];
      if(sexp_args_061 && ! sexp_args_061[2]){
       var
        arg0_062 = sexp_args_061[1],
        res0_063 = caml_call1(of_a_053, arg0_062);
       return [0, res0_063];
      }
      return Sexplib0_Sexp_conv_error[8].call
              (null, error_source_057, tag_060, sexp_059);
     }
     var sexp_args_071 = match[2];
     if(sexp_args_071){
      var b = sexp_args_071[2];
      if(b && ! b[2]){
       var
        arg1_073 = b[1],
        arg0_072 = sexp_args_071[1],
        res0_074 = caml_call1(of_a_053, arg0_072),
        res1_075 = caml_call1(of_b_054, arg1_073);
       return [2, res0_074, res1_075];
      }
     }
     return Sexplib0_Sexp_conv_error[8].call
             (null, error_source_057, tag_060, sexp_059);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_057, sexp_059);
   }
   function sexp_of_t$1(of_a_078, of_b_079, param){
    switch(param[0]){
      case 0:
       var arg0_080 = param[1], res0_081 = caml_call1(of_a_078, arg0_080);
       return [1, [0, i, [0, res0_081, 0]]];
      case 1:
       var arg0_082 = param[1], res0_083 = caml_call1(of_b_079, arg0_082);
       return [1, [0, j, [0, res0_083, 0]]];
      default:
       var
        arg1_085 = param[2],
        arg0_084 = param[1],
        res0_086 = caml_call1(of_a_078, arg0_084),
        res1_087 = caml_call1(of_b_079, arg1_085);
       return [1, [0, k, [0, res0_086, [0, res1_087, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   function merge_with_duplicates(a, param, compare){
    var next2 = param[2], s2 = param[1], next1 = a[2], s1 = a[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    return caml_call2
            (map$0,
             merge_with_duplicates(s1, s2, compare),
             function(param){var x = param[1]; return x;});
   }
   function merge_sorted(a, param, compare){
    var next2 = param[2], s2 = param[1], next1 = a[2], s1 = a[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return Base_Import[124].call(null, cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1]; s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return Base_Import[124].call(null, cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    return filter_map
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, Base_List1[19].call(null, accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, Base_List1[19].call(null, accum), empty];
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = Base_Import[93].call(null, i, 1);
      s$0 = s$2;
      i = i$0;
      accum = accum$0;
     }
    }
   }
   function chunks_exn(init, n){
    if(0 >= n) return Base_Import[126].call(null, cst_Sequence_chunks_exn);
    function f(t){
     var match = split_n(t, n), xs = match[1];
     if(! xs) return 0;
     var t$0 = match[2];
     return [1, xs, t$0];
    }
    return [0, init, f];
   }
   function findi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return [0, [0, i, a]];
      var s$1 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return Base_Import[124].call(null, cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             var variant = param[1];
             if(472258093 <= variant){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){
    function f(a){return a;}
    return caml_call2(bind$0, s, f);
   }
   function concat_mapi(s, f){
    function f$0(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    var s$0 = mapi(s, function(i, s){return [0, i, s];});
    return caml_call2(bind$0, s$0, f$0);
   }
   function zip(a, param){
    var next2 = param[2], s2 = param[1], next1 = a[2], s1 = a[1];
    function next(param){
     var c = param[1];
     if(typeof c !== "number"){
      if(0 !== c[0]){
       var match = param[2], s1$0 = c[2], a = c[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, c, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = c[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(a, param){
    var next2 = param[2], s2 = param[1], next1 = a[2], s1 = a[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0]){
      var seed$1 = match[1];
      seed$0 = seed$1;
     }
     else{
      var seed$2 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      i = i$0;
      seed$0 = seed$2;
     }
    }
   }
   function length_is_bounded_by(opt, max, t){
    var min = opt ? opt[1] : -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number"){
      var variant = match$0[1];
      if(16394 === variant){var len = match$0[2]; if(min <= len) return 1;}
     }
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], acc$0 = Base_Import[91].call(null, acc, 1);
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function iteri(s, f){
    var
     t = mapi(s, function(i, s){return [0, i, s];}),
     next = t[2],
     seed$2 = t[1],
     seed$1 = seed$2;
    for(;;){
     var match = caml_call1(next, seed$1);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var seed = match[1];
      seed$1 = seed;
     }
     else{
      var seed$0 = match[2], a = match[1], s$0 = a[2], i = a[1];
      caml_call2(f, i, s$0);
      seed$1 = seed$0;
     }
    }
   }
   function foldi(s, init, f){
    var
     t = mapi(s, function(i, s){return [0, i, s];}),
     next = t[2],
     seed$2 = t[1],
     acc = init,
     seed$1 = seed$2;
    for(;;){
     var match = caml_call1(next, seed$1);
     if(typeof match === "number") return acc;
     if(0 === match[0]){
      var seed = match[1];
      seed$1 = seed;
     }
     else{
      var
       seed$0 = match[2],
       a = match[1],
       s$0 = a[2],
       i = a[1],
       v = caml_call3(f, i, acc, s$0);
      acc = v;
      seed$1 = seed$0;
     }
    }
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return Base_Import[124].call(null, cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$){
    var next = param[2], s = param[1];
    function f(param){
     if(! param) return 0;
     var
      match = param[1],
      s = match[2],
      acc = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 !== "number" && 0 === match$0[0]){
      var s$2 = match$0[1];
      return [0, [0, [0, acc, s$2]]];
     }
     if(acc){
      if(typeof match$0 === "number")
       return [1, Base_List1[19].call(null, acc), 0];
      var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
      return caml_call2(break$, prev, cur)
              ? [1,
                Base_List1[19].call(null, acc),
                [0, [0, [0, cur, 0], s$0]]]
              : [0, [0, [0, [0, cur, acc], s$0]]];
     }
     if(typeof match$0 === "number") return 0;
     var s$1 = match$0[2], cur$0 = match$0[1];
     return [0, [0, [0, [0, cur$0, 0], s$1]]];
    }
    var init = [0, [0, 0, s]];
    return [0, init, f];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a];
      last_elt = last_elt$0;
      s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){
    var next = s[2], seed$2 = s[1], acc = 0, seed$1 = seed$2;
    for(;;){
     var match = caml_call1(next, seed$1);
     if(typeof match === "number") return acc;
     if(0 === match[0]){
      var seed = match[1];
      seed$1 = seed;
     }
     else{
      var
       seed$0 = match[2],
       elt = match[1],
       a = caml_call1(f, elt),
       b = Base_Bool[31].call(null, a),
       v = Base_Import[91].call(null, acc, b);
      acc = v;
      seed$1 = seed$0;
     }
    }
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(i, acc, elt){
              var a = caml_call2(f, i, elt), b = Base_Bool[31].call(null, a);
              return Base_Import[91].call(null, acc, b);
             });
   }
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function min_elt(t, compare){
    return Base_Container[3].call(null, fold, t, compare);
   }
   function max_elt(t, compare){
    return Base_Container[4].call(null, fold, t, compare);
   }
   function init$0(n, f){
    function f$0(i){
     if(n <= i) return 0;
     var a = Base_Import[91].call(null, i, 1);
     return [1, caml_call1(f, i), a];
    }
    return [0, 0, f$0];
   }
   function sub(s, pos, len){
    var a = pos < 0 ? 1 : 0, b = a || (len < 0 ? 1 : 0);
    if(b) Base_Import[124].call(null, cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= Base_Import[93].call(null, i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, Base_Import[91].call(null, i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, Base_Import[91].call(null, i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) Base_Import[124].call(null, cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, Base_Import[91].call(null, i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) Base_Import[124].call(null, cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, Base_Import[91].call(null, i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, Base_Import[91].call(null, i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             var variant = param[1];
             if(316735838 <= variant){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             var variant = param[1];
             if(316735838 <= variant){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var
    Infix = [0, append],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn",
    cst_Bug_This_branch_should_be_ = "Bug: This branch should be unreachable";
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var variant = param[1];
             if(815032112 === variant){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > variant){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(init){
    function f(x){return [1, x, x];}
    return [0, init, f];
   }
   function cycle_list_exn(xs){
    if(Base_List1[22].call(null, xs))
     Base_Import[126].call(null, cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function f(param){return s;}
    var s$0 = repeat(0);
    return caml_call2(bind$0, s$0, f);
   }
   function cartesian_product(sa, sb){
    function f(a){return zip(repeat(a), sb);}
    return caml_call2(bind$0, sa, f);
   }
   function singleton(x){return caml_call1(return$0, x);}
   function delayed_fold(s, init, f, finish){
    return delayed_fold_step
            (s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$, t, init, f){
    return delayed_fold_step
            (t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$);
   }
   function iter_m(bind, return$, t, f){
    return delayed_fold_step
            (t,
             0,
             function(param, option, k){
              if(! option) return caml_call2(bind, caml_call1(return$, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[15], acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(b){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1];
                s$0 = s$1;
               }
              }]];
    }
    return [0,
            memoize(s),
            function(param){
             var l = param[1], a = caml_obj_tag(l);
             if(250 === a) return l[1];
             if(246 !== a && 244 !== a) return l;
             return CamlinternalLazy[2].call(null, l);
            }];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], i$0 = Base_Import[91].call(null, i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      s$0 = s$2;
     }
    }
   }
   function skip_loop(s$0, next$0){
    var s = s$0;
    for(;;){
     var next = caml_call1(next$0, s);
     if(typeof next !== "number" && 0 === next[0]){var state = next[1]; s = state; continue;}
     return next;
    }
   }
   function compare$0(compare_a, l, param){
    var
     next_r = param[2],
     s_r$1 = param[1],
     next_l = l[2],
     s_l$1 = l[1],
     s_l = s_l$1,
     s_r = s_r$1;
    for(;;){
     var l$0 = skip_loop(s_l, next_l), match = skip_loop(s_r, next_r);
     if(typeof l$0 === "number"){
      if(typeof match === "number") return 0;
      if(0 !== match[0]) return -1;
     }
     else if(0 !== l$0[0]){
      if(typeof match === "number") return 1;
      if(0 !== match[0]){
       var c = caml_call2(compare_a, l$0[1], match[1]);
       if(0 !== c) return c;
       var s_r$0 = match[2], s_l$0 = l$0[2];
       s_l = s_l$0;
       s_r = s_r$0;
       continue;
      }
     }
     return Base_Import[124].call(null, cst_Bug_This_branch_should_be_);
    }
   }
   function compare_local$0(compare_a_local, t1, t2){
    var a = globalize(0, t2);
    return compare$0
            (function(x, y){return caml_call2(compare_a_local, x, y);},
             globalize(0, t1),
             a);
   }
   function equal$0(equal_a, t1, t2){
    return for_all
            (zip_full(t1, t2),
             function(param){
              var variant = param[1];
              if(737457313 !== variant) return 0;
              var match = param[2], a2 = match[2], a1 = match[1];
              return caml_call2(equal_a, a1, a2);
             });
   }
   function equal_local$0(equal_a_local, t1, t2){
    var a = globalize(0, t2);
    return equal$0
            (function(x, y){return caml_call2(equal_a_local, x, y);},
             globalize(0, t1),
             a);
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return Base_List1[22].call(null, done_stack)
              ? 0
              : [0, [0, Base_List1[19].call(null, done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, Base_List1[19].call(null, done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, Base_List1[19].call(null, done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, Base_List1[19].call(null, [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(init){
    function f(seq){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var tl = match[2], hd = match[1];
     return [1, hd, tl];
    }
    return [0, init, f];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state$2){
     var state = state$2;
     for(;;){
      var match = caml_call1(next, state);
      if(typeof match === "number") return 0;
      if(0 !== match[0]) break;
      var state$0 = match[1];
      state = state$0;
     }
     var state$1 = match[2], hd = match[1];
     return [0, hd, function(param){return loop(state$1);}];
    }
    return function(param){return loop(state);};
   }
   function return$1(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = Base_Monad[2].call(null, [0, bind$1, map$1, return$1]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$2 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11],
    l = [0, 0];
   function yield$(e, k){return [0, [1, e, k]];}
   function to_steps(t){return caml_call1(t, function(param){return l;});}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$2);
   }
   function run(t){
    function init(param){return to_steps(t);}
    function f(thunk){var step = caml_call1(thunk, 0)[1]; return step;}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       globalize,
       sexp_of_t$0,
       equal$0,
       equal_local$0,
       compare$0,
       compare_local$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$0,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_sorted,
       [0,
        compare,
        compare_local,
        equal,
        equal_local,
        hash_fold_t,
        t_of_sexp,
        sexp_of_t$1,
        t_sexp_grammar],
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init$0,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$2,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$,
        of_sequence,
        run],
       [0, next_step, delayed_fold_step, T, view]];
   runtime.caml_register_global(51, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexp_grammar, Sexplib0__Sexpable
//# shape: Base__Sexpable:[F(2)*,F(2)*,F(2)*,F(2)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var a = caml_call1(M[2], s); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return Base_Import[157].call(null, exn, sexp);
     }
    }
    function sexp_of_t(t){
     var a = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], a);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var a = caml_call1(M[2], s); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return Base_Import[157].call(null, exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var a = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, a);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var a = caml_call1(M[2], s); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return Base_Import[157].call(null, exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var a = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, a);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var a = caml_call1(M[2], s); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return Base_Import[157].call(null, exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var a = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, a);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return Base_Import[156].call(null, cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var a = caml_call1(M[1], s); return a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return Base_Import[157].call(null, exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    var
     t_sexp_grammar = Sexplib0_Sexp_grammar[1].call(null, Base_Import[182]);
    return [0, t_sexp_grammar, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(3, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Bool, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
//# shape: Base__Array:[N,N,F(2)*,F(2),F(2),F(1)*,N,N,F(1),F(1)*,F(2)*,F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(1)*,F(2),F(3),F(3),F(4),F(2),F(2),F(2),F(3),F(2),F(2),F(1),F(1)*,F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),N,F(2)*,F(2)*,F(1)*,F(3),F(1),F(1)*,F(1)*,F(4),N,N,N,N,N,F(3),F(3),F(3),F(3),F(3),N,F(2),F(2),F(2),F(3),F(2),F(2),F(1),F(1),F(1),F(3),F(3),F(4),F(3),F(3),F(3),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(4),F(2),F(2),F(2),F(2),F(1),F(2),F(1),F(3),F(3),F(1)*,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bool = global_data.Base__Bool,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24],
    compare_local = Base_Import[263],
    compare = Base_Import[235],
    globalize = Base_Import[291],
    t_of_sexp = Base_Import[174],
    sexp_of_t = Base_Import[150];
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Import[195].call(null, a_sexp_grammar);
   }
   function Sorter(S){
    var get = S[1], set = S[2], length = S[3];
    function swap(arr, i, j){
     var tmp = caml_call2(get, arr, i);
     caml_call3(set, arr, i, caml_call2(get, arr, j));
     return caml_call3(set, arr, j, tmp);
    }
    function sort(arr, compare, left, right){
     var a = Base_Import[91].call(null, left, 1);
     if(right >= a){
      var pos = a;
      a:
      for(;;){
       var v = caml_call2(get, arr, pos), final_pos = pos;
       for(;;){
        var i_next = Base_Import[93].call(null, final_pos, 1);
        if
         (left <= i_next
          && 0 < caml_call2(compare, caml_call2(get, arr, i_next), v)){
         caml_call3(set, arr, final_pos, caml_call2(get, arr, i_next));
         final_pos = i_next;
         continue;
        }
        caml_call3(set, arr, final_pos, v);
        var b = pos + 1 | 0;
        if(right === pos) break a;
        pos = b;
        break;
       }
      }
     }
     return 0;
    }
    var Insertion_sort = [0, sort];
    function heapify(arr, compare, root$0, left, right){
     var root = root$0;
     for(;;){
      var
       relative_root = Base_Import[93].call(null, root, left),
       b = Base_Import[88].call(null, 2, relative_root),
       c = Base_Import[91].call(null, b, left),
       left_child = Base_Import[91].call(null, c, 1),
       d = Base_Import[88].call(null, 2, relative_root),
       e = Base_Import[91].call(null, d, left),
       right_child = Base_Import[91].call(null, e, 2);
      if(left_child <= right)
       var
        f = caml_call2(get, arr, root),
        largest =
          0 < caml_call2(compare, caml_call2(get, arr, left_child), f)
           ? left_child
           : root;
      else
       var largest = root;
      if(right_child <= right)
       var
        g = caml_call2(get, arr, largest),
        largest$0 =
          0 < caml_call2(compare, caml_call2(get, arr, right_child), g)
           ? right_child
           : largest;
      else
       var largest$0 = largest;
      var a = largest$0 !== root ? 1 : 0;
      if(! a) return a;
      swap(arr, root, largest$0);
      root = largest$0;
     }
    }
    function sort$0(arr, compare, left, right){
     var
      c = Base_Import[91].call(null, left, right),
      a = Base_Import[95].call(null, c, 2);
     if(a >= left){
      var i = a;
      for(;;){
       heapify(arr, compare, i, left, right);
       var d = i - 1 | 0;
       if(left === i) break;
       i = d;
      }
     }
     var b = Base_Import[91].call(null, left, 1);
     if(right >= b){
      var i$0 = right;
      for(;;){
       swap(arr, left, i$0);
       heapify(arr, compare, left, left, Base_Import[93].call(null, i$0, 1));
       var e = i$0 - 1 | 0;
       if(b === i$0) break;
       i$0 = e;
      }
     }
     return 0;
    }
    var Heap_sort = [0, sort$0];
    function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
     function compare_and_swap(i, j){
      var
       b = caml_call2(get, arr, j),
       a = 0 < caml_call2(compare, caml_call2(get, arr, i), b) ? 1 : 0;
      return a ? swap(arr, i, j) : a;
     }
     compare_and_swap(m1, m2);
     compare_and_swap(m4, m5);
     compare_and_swap(m1, m3);
     compare_and_swap(m2, m3);
     compare_and_swap(m1, m4);
     compare_and_swap(m3, m4);
     compare_and_swap(m2, m5);
     compare_and_swap(m2, m3);
     return compare_and_swap(m4, m5);
    }
    function intro_sort(arr, max_depth$1, compare, left$1, right){
     var max_depth = max_depth$1, left = left$1;
     for(;;){
      var
       b = Base_Import[93].call(null, right, left),
       len = Base_Import[91].call(null, b, 1);
      if(32 >= len) return sort(arr, compare, left, right);
      if(0 > max_depth) return sort$0(arr, compare, left, right);
      var
       max_depth$0 = Base_Import[93].call(null, max_depth, 1),
       a = Base_Import[93].call(null, right, left),
       sixth = Base_Import[95].call(null, a, 6),
       m1 = Base_Import[91].call(null, left, sixth),
       m2 = Base_Import[91].call(null, m1, sixth),
       m3 = Base_Import[91].call(null, m2, sixth),
       m4 = Base_Import[91].call(null, m3, sixth),
       m5 = Base_Import[91].call(null, m4, sixth);
      five_element_sort(arr, compare, m1, m2, m3, m4, m5);
      var
       m2_val = caml_call2(get, arr, m2),
       m3_val = caml_call2(get, arr, m3),
       m4_val = caml_call2(get, arr, m4),
       match =
         0 === caml_call2(compare, m2_val, m3_val)
          ? [0, m2_val, m3_val, 1]
          : 0
            === caml_call2(compare, m3_val, m4_val)
            ? [0, m3_val, m4_val, 1]
            : [0, m2_val, m4_val, 0],
       middle_sorted = match[3],
       pivot2 = match[2],
       pivot1 = match[1],
       l$0 = left,
       p$1 = left,
       r$2 = right;
      for(;;){
       if(r$2 < p$1){
        intro_sort
         (arr, max_depth$0, compare, left, Base_Import[93].call(null, l$0, 1));
        if(1 - middle_sorted) intro_sort(arr, max_depth$0, compare, l$0, r$2);
        var left$0 = Base_Import[91].call(null, r$2, 1);
        max_depth = max_depth$0;
        left = left$0;
        break;
       }
       var pv = caml_call2(get, arr, p$1);
       if(0 <= caml_call2(compare, pv, pivot1))
        if(0 < caml_call2(compare, pv, pivot2)){
         var r = r$2;
         for(;;){
          if
           (p$1 < r
            && 0 < caml_call2(compare, caml_call2(get, arr, r), pivot2)){
           var r$0 = Base_Import[93].call(null, r, 1);
           r = r$0;
           continue;
          }
          swap(arr, r, p$1);
          var r$1 = Base_Import[93].call(null, r, 1);
          r$2 = r$1;
          break;
         }
        }
        else{var p = Base_Import[91].call(null, p$1, 1); p$1 = p;}
       else{
        swap(arr, p$1, l$0);
        var
         p$0 = Base_Import[91].call(null, p$1, 1),
         l = Base_Import[91].call(null, l$0, 1);
        l$0 = l;
        p$1 = p$0;
       }
      }
     }
    }
    function sort$1(arr, compare, left, right){
     return intro_sort(arr, 32, compare, left, right);
    }
    var Intro_sort = [0, sort$1, five_element_sort];
    function sort$2(pos, len, arr, compare){
     var
      a = caml_call1(length, arr),
      match = Base_Ordered_collection_common[1].call(null, pos, len, 0, a),
      len$0 = match[2],
      pos$0 = match[1],
      b = Base_Import[91].call(null, pos$0, len$0);
     return sort$1(arr, compare, pos$0, Base_Import[93].call(null, b, 1));
    }
    return [0, , , , , Insertion_sort, Heap_sort, Intro_sort, sort$2];
   }
   function get(b, a){return b[a + 1];}
   function set(c, b, a){c[b + 1] = a; return 0;}
   function length(a){return a.length - 1;}
   var
    Sort = Sorter([0, get, set, length]),
    sort = Sort[8],
    a = [0, cst_src_array_ml, 486, 14],
    b =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    cst_Array_iter2_exn = "Array.iter2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    c = [0, "Array.findi_exn: not found"],
    d = [0, "Array.find_exn: not found"];
   function of_array(t){return t;}
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var i = [0, Base_Import[93].call(null, t.length - 1, 1)], result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[i[1] + 1],
       elt_i_minus_1 = t[Base_Import[93].call(null, i[1], 1) + 1];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var i = [0, Base_Import[93].call(null, t.length - 1, 1)], result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[i[1] + 1],
       elt_i_minus_1 = t[Base_Import[93].call(null, i[1], 1) + 1];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return copy(a2);
    if(0 === l2) return copy(a1);
    var b = a1[Base_Import[93].call(null, l1, 1) + 1];
    if(0 <= caml_call2(compare, a2[1], b)) return append(a1, a2);
    var c = a2[Base_Import[93].call(null, l2, 1) + 1];
    if(0 < caml_call2(compare, a1[1], c)) return append(a2, a1);
    var
     len = Base_Import[91].call(null, l1, l2),
     merged = create(len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     a = Base_Import[93].call(null, len, 1),
     d = 0;
    if(a >= 0){
     var i = d;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[a1_index[1] + 1], a2[a2_index[1] + 1])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[i + 1] = a1[a1_index[1] + 1];
       a1_index[1] = Base_Import[91].call(null, a1_index[1], 1);
      }
      else{
       merged[i + 1] = a2[a2_index[1] + 1];
       a2_index[1] = Base_Import[91].call(null, a2_index[1], 1);
      }
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return merged;
   }
   function copy_matrix(a){return map(a, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return Base_Container[8].call(null, fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return Base_Container[9].call(null, fold, init, f, finish, t);
   }
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function extremal_element(t, compare, keep_left_if){
    if(is_empty(t)) return 0;
    var
     result = [0, t[1]],
     a = Base_Import[93].call(null, t.length - 1, 1),
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      var x = t[i + 1], c = result[1];
      result[1] =
       runtime.caml_csel_value
        (caml_call1(keep_left_if, caml_call2(compare, x, result[1])), x, c);
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return [0, result[1]];
   }
   function min_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return compare_result < 0 ? 1 : 0;});
   }
   function max_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return 0 < compare_result ? 1 : 0;});
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     a = Base_Import[93].call(null, t.length - 1, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function count(t, f){
    var
     result = [0, 0],
     a = Base_Import[93].call(null, t.length - 1, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = caml_call1(f, t[i + 1]), d = Base_Bool[31].call(null, c);
      result[1] = Base_Import[91].call(null, result[1], d);
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return result[1];
   }
   function counti(t, f){
    var
     result = [0, 0],
     a = Base_Import[93].call(null, t.length - 1, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = caml_call2(f, i, t[i + 1]), d = Base_Bool[31].call(null, c);
      result[1] = Base_Import[91].call(null, result[1], d);
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return result[1];
   }
   function concat_map(t, f){return concat(to_list(map(t, f)));}
   function concat_mapi(t, f){return concat(to_list(mapi(t, f)));}
   function rev_inplace(t){
    var i = [0, 0], j = [0, Base_Import[93].call(null, t.length - 1, 1)];
    for(;;){if(i[1] >= j[1]) return 0; swap(t, i[1], j[1]); i[1]++; j[1]--;}
   }
   function rev(t){var t$0 = copy(t); rev_inplace(t$0); return t$0;}
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a$0 = l[1],
     c = Base_List[45].call(null, l$0),
     len = Base_Import[91].call(null, 1, c),
     t = create(len, a$0),
     r = [0, l$0],
     b = Base_Import[93].call(null, len, 2);
    if(b >= 0){
     var i = b;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
      var l$1 = match[2], a$1 = match[1];
      caml_check_bound(t, i)[i + 1] = a$1;
      r[1] = l$1;
      var d = i - 1 | 0;
      if(0 === i) break;
      i = d;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     b = caml_call1(f, hd),
     c = Base_List[45].call(null, tl),
     a = create(Base_Import[91].call(null, 1, c), b),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[i + 1] = caml_call1(f, hd$0);
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     b = caml_call2(f, 0, hd),
     c = Base_List[45].call(null, tl),
     a = create(Base_Import[91].call(null, 1, c), b),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[i + 1] = caml_call2(f, i, hd$0);
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     b = Base_Import[93].call(null, t.length - 1, 1),
     c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      var match = caml_call2(f, i, t[i + 1]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = create(t.length - 1, a);
       r[1][k[1] + 1] = a;
       k[1]++;
      }
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return k[1] === t.length - 1 ? r[1] : 0 < k[1] ? sub(r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(a){return a;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, a = n1 !== n2 ? 1 : 0;
    return a ? caml_call4(invalid_argf(b), name, n1, n2, 0) : a;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return iteri(t1, function(i, x1){return caml_call2(f, x1, t2[i + 1]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return init
            (t1.length - 1,
             function(i){return caml_call2(f, t1[i + 1], t2[i + 1]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[i + 1]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var i = [0, Base_Import[93].call(null, t.length - 1, 1)], result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[i[1] + 1])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var i = [0, Base_Import[93].call(null, t.length - 1, 1)], result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[i[1] + 1])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var i = [0, Base_Import[93].call(null, t.length - 1, 1)], result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[i[1] + 1])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, Base_Import[93].call(null, length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[i[1] + 1])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, Base_Import[93].call(null, t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[i[1] + 1], t2[i[1] + 1])){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_local_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, Base_Import[93].call(null, t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[i[1] + 1], t2[i[1] + 1])){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){return for_all2_local_exn(t1, t2, f);}
   function equal_local(equal, t1, t2){
    var a = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return a ? for_all2_local_exn(t1, t2, equal) : a;
   }
   function equal(equal, t1, t2){return equal_local(equal, t1, t2);}
   function map_inplace(t, f){
    var a = Base_Import[93].call(null, t.length - 1, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      t[i + 1] = caml_call1(f, t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[i[1] + 1];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
       continue;
      }
      i[1]++;
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, [0, i, value]];},
             function(param){return 0;});
   }
   function findi_exn(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, i, value];},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[297], c], 1);
             });
   }
   function find_exn(t, f){
    return findi_internal
            (t,
             function(i, x){return caml_call1(f, x);},
             function(param, value){return value;},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[297], d], 1);
             });
   }
   function find(t, f){
    var a = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2
            (Base_Option[24], a, function(param){var x = param[2]; return x;});
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(Base_Option[52].call(null, value_found[1]) && i[1] < length){
      var value = t[i[1] + 1];
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found = [0, Base_Import[297], [0, "Array.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(Base_Option[52].call(null, value_found[1]) && i[1] < length){
      var value = t[i[1] + 1];
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found$0 = [0, Base_Import[297], [0, "Array.find_mapi_exn: not found"]],
    cst_Array_reduce_exn = "Array.reduce_exn";
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[i[1] + 1];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; i[1]++;}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var r = [0, t[1]], a = Base_Import[93].call(null, t.length - 1, 1), b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      r[1] = caml_call2(f, r[1], t[i + 1]);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return Base_Import[126].call(null, cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var
    permute = Base_Array_permute[25],
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_transpose_exn = "Array.transpose_exn";
   function random_element_exn(opt, t){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    if(is_empty(t))
     return Base_Import[124].call(null, cst_Array_random_element_exn_e);
    var a = caml_call2(Base_Random[19][7], random_state, t.length - 1);
    return caml_check_bound(t, a)[a + 1];
   }
   function random_element(opt, t){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    try{var a = [0, random_element_exn([0, random_state], t)]; return a;}
    catch(exn){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? Base_Import[124].call(null, cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = create(n, x),
     res2 = create(n, y),
     a = Base_Import[93].call(null, n, 1),
     b = 1;
    if(a >= 1){
     var i = b;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[i + 1],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[i + 1] = x$0;
      caml_check_bound(res2, i)[i + 1] = y$0;
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = copy(t);
    sort(0, 0, t1, compare);
    return t1;
   }
   function partition_mapi(t, f){
    var
     both = mapi(t, f),
     firsts =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     seconds =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, firsts, seconds];
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];});
   }
   function partition_map(t, f){
    return partition_mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(param, x){return caml_call1(f, x);});
   }
   function last(t){
    var a = Base_Import[93].call(null, t.length - 1, 1);
    return caml_check_bound(t, a)[a + 1];
   }
   function to_sequence_mutable(t){
    return Base_Sequence[44].call
            (null,
             0,
             function(i){
              if(t.length - 1 <= i) return 0;
              var a = Base_Import[91].call(null, i, 1);
              return [1, caml_check_bound(t, i)[i + 1], a];
             });
   }
   function to_sequence(t){return to_sequence_mutable(copy(t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      d = caml_check_bound(t2, 0)[1],
      e = [0, caml_check_bound(t1, 0)[1], d],
      t = create(Base_Import[88].call(null, n1, n2), e),
      r = [0, 0],
      a = Base_Import[93].call(null, n1, 1),
      f = 0;
     if(a >= 0){
      var i1 = f;
      for(;;){
       var b = Base_Import[93].call(null, n2, 1), g = 0;
       if(b >= 0){
        var i2 = g;
        for(;;){
         var
          i = caml_check_bound(t2, i2)[i2 + 1],
          j = [0, caml_check_bound(t1, i1)[i1 + 1], i],
          c = r[1];
         caml_check_bound(t, c)[c + 1] = j;
         r[1]++;
         var k = i2 + 1 | 0;
         if(b === i2) break;
         i2 = k;
        }
       }
       var h = i1 + 1 | 0;
       if(a === i1) break;
       i1 = h;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              init
               (depth,
                function(d){
                 return init
                         (width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[w + 1], d)
                                   [d + 1];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return Base_Import[126].call(null, cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(b, a){return caml_check_bound(b, a)[a + 1];}
   function length$0(a){return a.length - 1;}
   var
    include = Base_Binary_searchable[2].call(null, [0, get$0, length$0]),
    binary_search = include[1],
    binary_search_segmented = include[2],
    e = [0, cst_src_array_ml, 917, 6];
   function length$1(a){return a.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1) return create(len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      Base_Blit[4].call(null, [0, create_like, length$1, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){return iter(t, invariant_a);}
   var
    Base_Array =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       of_list,
       of_array,
       append,
       map,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       make_matrix,
       copy_matrix,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi_exn,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       equal_local,
       to_sequence,
       to_sequence_mutable,
       [0,
        [0, Sort[5], Sort[6], Sort[7]],
        function(a){return [0, Sorter(a)[8]];}]];
   runtime.caml_register_global(29, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
//# shape: Base__Floatable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Base__Import, Base__Import0, Base__Option, Base__Printf, Ocaml_intrinsics_kernel__Float, Stdlib__Float, Stdlib__Int64
//# shape: Base__Float0:[F(1)*,F(1)*,F(2)*,F(1)*,F(1),F(1),N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(2)*,F(2),F(1)*,F(2)*,F(1)*,F(1)*,F(1),F(1)*,F(2)*,F(1)*,F(1)*,F(1),[F(2),F(2)],F(3),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float;
   function ceil(a){return Math.ceil(a);}
   function floor(a){return Math.floor(a);}
   function mod_float(b, a){return b % a;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    float_of_string_opt = Base_Import[85][36],
    nan = Base_Import[85][24],
    infinity = Base_Import[85][22],
    neg_infinity = Base_Import[85][23],
    max_finite_value = Base_Import[85][25],
    epsilon_float = Base_Import[85][27],
    classify_float = runtime.caml_classify_float;
   function abs_float(a){return Math.abs(a);}
   var
    is_integer = Stdlib_Float[18],
    a =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function symbol(b, a){return Math.pow(b, a);}
   function symbol$0(a$0, b){
    if(b < 0.) caml_call3(Base_Printf[7].call(null, a), a$0, b, 0);
    var m = a$0 % b;
    return m < 0. ? Base_Import[92].call(null, m, b) : m;
   }
   var
    frexp = runtime.caml_frexp_float,
    ldexp = runtime.caml_ldexp_float,
    b = [0, caml_int64_create_lo_mi_hi(0, 0, 0)],
    c = caml_int64_create_lo_mi_hi(0, 0, 0),
    d = caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    e = caml_int64_create_lo_mi_hi(1, 0, 0),
    f = [0, cst_src_float0_ml, 190, 4],
    g = [0, cst_src_float0_ml, 186, 4];
   function is_nan(x){return x !== x ? 1 : 0;}
   function to_int64_preserve_order(t){
    return t !== t
            ? 0
            : t
              === 0.
              ? b
              : 0.
                < t
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(Base_Import[114].call(null, t)))];
   }
   function to_int64_preserve_order_exn(x){
    var a = to_int64_preserve_order(x);
    return Base_Option[31].call(null, 0, 0, 0, a);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, c)
            ? caml_int64_float_of_bits(x)
            : Base_Import
               [114].call
              (null, caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[85][24];
    var x = match[1], a = 759637122 <= dir ? d : e;
    return of_int64_preserve_order(runtime.caml_int64_add(x, a));
   }
   function upper_bound_for_int(num_bits){
    var exp = Base_Import[93].call(null, num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(Base_Import[94].call(null, x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = Base_Import[93].call(null, num_bits, 1),
     min_int_as_float = Base_Import[114].call(null, Math.pow(2., exp));
    if(53 <= Base_Import[93].call(null, num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, Base_Import[94].call(null, min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
   }
   function min(a, b){return runtime.caml_sse2_float64_min_bytecode(a, b);}
   function max(a, b){return runtime.caml_sse2_float64_max_bytecode(a, b);}
   var Intrinsics_with_weird_nan_beha = [0, min, max];
   function clamp_unchecked
   (to_clamp_maybe_nan, min_which_is_not_nan, max_which_is_not_nan){
    var
     t_maybe_nan =
       runtime.caml_sse2_float64_max_bytecode
        (min_which_is_not_nan, to_clamp_maybe_nan);
    return runtime.caml_sse2_float64_min_bytecode
            (max_which_is_not_nan, t_maybe_nan);
   }
   var x = 0.;
   function box(f){return Base_Import[92].call(null, f, x);}
   var
    include = Base_Import[108],
    ascending = include[1],
    descending = include[2],
    compare_local = include[3],
    equal_local = include[4],
    max$0 = include[5],
    min$0 = include[6],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       float_of_string_opt,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       Intrinsics_with_weird_nan_beha,
       clamp_unchecked,
       box,
       ascending,
       descending,
       compare_local,
       equal_local,
       max$0,
       min$0];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
//# shape: Base__Intable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
//# shape: Base__Int_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Int_conversions
//# shape: Base__Pow_overflow_bounds:[N,N,N,N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_dup = runtime.caml_obj_dup,
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      caml_obj_dup
       ([0,
         2147483647,
         2147483647,
         46340,
         1290,
         215,
         73,
         35,
         21,
         14,
         10,
         8,
         7,
         5,
         5,
         4,
         4,
         3,
         3,
         3,
         3,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1,
         1]),
    overflow_bound_max_int_value = Base_Import[120].call(null, -1, 1),
    switcher = Base_Int_conversions[30] - 31 | 0,
    d = [0, "src/pow_overflow_bounds.ml", 216, 9],
    e =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    a =
      [0,
       caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       caml_int64_create_lo_mi_hi(16777215, 127, 0),
       caml_int64_create_lo_mi_hi(1664510, 0, 0),
       caml_int64_create_lo_mi_hi(46340, 0, 0),
       caml_int64_create_lo_mi_hi(5404, 0, 0),
       caml_int64_create_lo_mi_hi(1290, 0, 0),
       caml_int64_create_lo_mi_hi(463, 0, 0),
       caml_int64_create_lo_mi_hi(215, 0, 0),
       caml_int64_create_lo_mi_hi(118, 0, 0),
       caml_int64_create_lo_mi_hi(73, 0, 0),
       caml_int64_create_lo_mi_hi(49, 0, 0),
       caml_int64_create_lo_mi_hi(35, 0, 0),
       caml_int64_create_lo_mi_hi(27, 0, 0),
       caml_int64_create_lo_mi_hi(21, 0, 0),
       caml_int64_create_lo_mi_hi(17, 0, 0),
       caml_int64_create_lo_mi_hi(14, 0, 0),
       caml_int64_create_lo_mi_hi(12, 0, 0),
       caml_int64_create_lo_mi_hi(10, 0, 0),
       caml_int64_create_lo_mi_hi(9, 0, 0),
       caml_int64_create_lo_mi_hi(8, 0, 0),
       caml_int64_create_lo_mi_hi(7, 0, 0),
       caml_int64_create_lo_mi_hi(7, 0, 0),
       caml_int64_create_lo_mi_hi(6, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(1, 0, 0),
       caml_int64_create_lo_mi_hi(1, 0, 0)],
    b =
      [0,
       caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       caml_int64_create_lo_mi_hi(324403, 181, 0),
       caml_int64_create_lo_mi_hi(2097151, 0, 0),
       caml_int64_create_lo_mi_hi(55108, 0, 0),
       caml_int64_create_lo_mi_hi(6208, 0, 0),
       caml_int64_create_lo_mi_hi(1448, 0, 0),
       caml_int64_create_lo_mi_hi(511, 0, 0),
       caml_int64_create_lo_mi_hi(234, 0, 0),
       caml_int64_create_lo_mi_hi(127, 0, 0),
       caml_int64_create_lo_mi_hi(78, 0, 0),
       caml_int64_create_lo_mi_hi(52, 0, 0),
       caml_int64_create_lo_mi_hi(38, 0, 0),
       caml_int64_create_lo_mi_hi(28, 0, 0),
       caml_int64_create_lo_mi_hi(22, 0, 0),
       caml_int64_create_lo_mi_hi(18, 0, 0),
       caml_int64_create_lo_mi_hi(15, 0, 0),
       caml_int64_create_lo_mi_hi(13, 0, 0),
       caml_int64_create_lo_mi_hi(11, 0, 0),
       caml_int64_create_lo_mi_hi(9, 0, 0),
       caml_int64_create_lo_mi_hi(8, 0, 0),
       caml_int64_create_lo_mi_hi(7, 0, 0),
       caml_int64_create_lo_mi_hi(7, 0, 0),
       caml_int64_create_lo_mi_hi(6, 0, 0),
       caml_int64_create_lo_mi_hi(6, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(5, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(4, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(3, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(2, 0, 0),
       caml_int64_create_lo_mi_hi(1, 0, 0)],
    c =
      [0,
       caml_int64_create_lo_mi_hi(1, 0, 32768),
       caml_int64_create_lo_mi_hi(1, 0, 32768),
       caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
    var
     int_positive_overflow_bounds =
       [0,
        -1,
        -1,
        2147483647,
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else
    var
     int_positive_overflow_bounds =
       switcher
        ? Base_Array0
           [21].call
          (null, int32_positive_overflow_bounds, function(a){return a;})
        : caml_obj_dup(e);
   var
    int63_on_int64_positive_overfl = caml_obj_dup(a),
    int64_positive_overflow_bounds = caml_obj_dup(b),
    int64_negative_overflow_bounds = caml_obj_dup(c),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
//# shape: Base__Int_math:[F(1),[F(2),F(2),F(2)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    a =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati],
    b = [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow];
   function negative_exponent(param){
    return caml_call1(Base_Printf[7].call(null, a), 0);
   }
   function overflow(param){
    return caml_call1(Base_Printf[7].call(null, b), 0);
   }
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var b = 1 < Base_Import[123].call(null, base) ? 1 : 0;
    if(b){
     var c = 63 < exponent ? 1 : 0;
     if(c)
      var a = c;
     else
      var
       d =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[exponent + 1],
       a = d < Base_Import[123].call(null, base) ? 1 : 0;
    }
    else
     var a = b;
    if(a) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var
    abs = Stdlib_Int64[8],
    c = caml_int64_create_lo_mi_hi(0, 0, 0),
    d = caml_int64_create_lo_mi_hi(1, 0, 0),
    e = caml_int64_create_lo_mi_hi(63, 0, 0),
    f = caml_int64_create_lo_mi_hi(0, 0, 0),
    g = caml_int64_create_lo_mi_hi(0, 0, 0),
    h = caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    i = caml_int64_create_lo_mi_hi(0, 0, 0),
    j = caml_int64_create_lo_mi_hi(1, 0, 0),
    k = caml_int64_create_lo_mi_hi(63, 0, 0);
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, c)) negative_exponent(0);
    var o = caml_greaterthan(base, d), i = o || caml_lessthan(base, h);
    if(i){
     var j = caml_greaterthan(exponent, e);
     if(j)
      var a = j;
     else{
      var k = runtime.caml_greaterequal(base, f);
      if(k)
       var
        l = caml_int64_to_int32(exponent),
        b =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], l)[l + 1]);
      else
       var b = k;
      if(b)
       var a = b;
      else{
       var m = caml_lessthan(base, g);
       if(m)
        var
         n = caml_int64_to_int32(exponent),
         a =
           caml_lessthan
            (base, caml_check_bound(Base_Pow_overflow_bounds[9], n)[n + 1]);
       else
        var a = m;
      }
     }
    }
    else
     var a = i;
    if(a) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, i)) negative_exponent(0);
    var b = caml_greaterthan(abs(base), j);
    if(b){
     var c = caml_greaterthan(exponent, k);
     if(c)
      var a = c;
     else
      var
       d = caml_int64_to_int32(exponent),
       e = caml_check_bound(Base_Pow_overflow_bounds[6], d)[d + 1],
       a = caml_greaterthan(abs(base), e);
    }
    else
     var a = b;
    if(a) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    l =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    m =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var a = caml_call1(X[4], y), b = caml_call1(X[4], x);
          caml_call3(invalid_argf(l), b, a, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var a = caml_call1(X[4], y), b = caml_call1(X[4], x);
          caml_call3(invalid_argf(m), b, a, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var c = caml_call2(X[5], x, one), d = caml_call2(X[8], c, y);
         return caml_call2(X[6], d, one);
        }
        function symbol$1(x, y){
         var a = caml_call1(X[2], y), b = caml_call1(X[2], x);
         return Base_Import[96].call(null, b, a);
        }
        function round_down(i, modulus){
         var a = symbol(i, modulus);
         return caml_call2(X[6], i, a);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var a = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], a, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         var dir = opt ? opt[1] : 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
//# shape: Base__Staged:[F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(a){return a;}
   function unstage(a){return a;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_intf
//# shape: Base__Bytes_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bytes_intf = [0];
   runtime.caml_register_global(0, Base_Bytes_intf, "Base__Bytes_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
//# shape: Base__Char:[N,F(1)*,N,N,N,N,N,N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,N,N,N,N,F(2),N,F(2)*,F(2)*,F(1)*,[F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*],F(1)*,F(1)*,F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),N,N,N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[282],
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[184],
    a = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function to_string(t){return Base_String0[8].call(null, 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call2(failwithf(a), s, 0);
   }
   var
    include =
      Base_Identifiable[1].call
       (null,
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24],
    b = [0, [1, 0], "%C"];
   function pp(fmt, c){
    return caml_call1(Stdlib_Format[139].call(null, fmt)(b), c);
   }
   function invariant(param){return 0;}
   var
    c = Base_Array0[12].call(null, 256, unsafe_of_int),
    all = Base_Array0[16].call(null, c),
    d =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit";
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 !== param) break a;} else if(9 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var a = param - 48 | 0;
    a:
    {
     if(42 < a >>> 0){
      if(25 < a - 49 >>> 0) break a;
     }
     else if(6 >= a - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var a = to_int(48), b = to_int(t);
    return Base_Import[93].call(null, b, a);
   }
   function get_digit_exn(t){
    return is_digit(t) ? get_digit_unsafe(t) : caml_call2(failwithf(d), t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var a = param - 48 | 0;
    a:
    {
     if(22 < a >>> 0){
      if(5 < a - 49 >>> 0) break a;
     }
     else if(6 >= a - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        c = to_int(97),
        d = to_int(t),
        e = Base_Import[93].call(null, d, c);
       return Base_Import[91].call(null, e, 10);
      }
     }
     else if(71 > t){
      var f = to_int(65), g = to_int(t), h = Base_Import[93].call(null, g, f);
      return Base_Import[91].call(null, h, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var i = to_int(48), j = to_int(t);
     return Base_Import[93].call(null, j, i);
    }
    var
     a = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     b = Base_Sexp[10].call(null, cst_Char_get_hex_digit_exn_not, a);
    return Base_Error[32].call(null, b);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[106][6],
    symbol$0 = Base_Import[106][2],
    symbol$1 = Base_Import[106][4],
    symbol$2 = Base_Import[106][5],
    symbol$3 = Base_Import[106][1],
    symbol$4 = Base_Import[106][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[162],
    sexp_of_t$1 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var a = lowercase(c2), b = lowercase(c1);
    return Base_Import[106][9].call(null, b, a);
   }
   function compare_local(c1, c2){return compare$0(c1, c2);}
   function hash_fold_t$1(state, t){
    var a = lowercase(t);
    return caml_call2(Base_Import[205], state, a);
   }
   function hash$1(t){return Base_Hash[14].call(null, 0, hash_fold_t$1, t);}
   var
    include$0 = Base_Comparable[11].call(null, [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16];
   function equal_local(t1, t2){
    var a = compare$0(t1, t2);
    return caml_call2(Base_Import[242], a, 0);
   }
   var
    include$1 = Base_Import[106],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$0 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_Char =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local$0,
       compare_local$0,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0,
        equal_local,
        compare_local]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
//# shape: Base__Bytes_tr:[F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = Base_Bytes0[7].call(null, 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, Base_Char[34].call(null, i$3));
     var k = i$3 + 1 | 0;
     if(255 === i$3) break;
     i$3 = k;
    }
    var
     a =
       Base_Import0[97][4].call
        (null,
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     e = 0;
    if(a >= 0){
     var i$2 = e;
     for(;;){
      var
       index$0 = Base_Char[32].call(null, caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var j = i$2 + 1 | 0;
      if(a === i$2) break;
      i$2 = j;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     b =
       Base_Import0[97][4].call
        (null,
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     c = caml_ml_string_length(target) - 1 | 0;
    if(c >= b){
     var i$1 = b;
     for(;;){
      var
       index = Base_Char[32].call(null, caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var h = i$1 + 1 | 0;
      if(c === i$1) break;
      i$1 = h;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     g = caml_bytes_unsafe_get(tr_map, Base_Char[32].call(null, first_target));
    if(! Base_Char[15].call(null, g, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var d = 0;
      else{
       var f = Base_Char[34].call(null, i);
       if(! Base_Char[15].call(null, caml_bytes_unsafe_get(tr_map, i), f)){var i$0 = i + 1 | 0; i = i$0; continue;}
       var d = 1;
      }
      if(d) break;
      return 0;
     }
    }
    return [0, runtime.caml_string_of_bytes(tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String_intf
//# shape: Base__String_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_String_intf = [0];
   runtime.caml_register_global(0, Base_String_intf, "Base__String_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Indexed_container, Base__Int0, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Printf, Base__Sequence, Base__Sexp, Base__Sexpable, Base__Staged, Base__String0, Base__String_intf, Base__Uchar0, CamlinternalLazy, Stdlib__Format
//# shape: Base__String:[F(1)*,N,F(3),F(3),F(3),F(1),F(1),F(2)*,F(2),F(2),F(2),F(2),F(2),F(1)*,F(2),F(3),F(3),F(4),F(2),F(2),F(2),F(3),F(2),F(2),F(1),F(1),F(1)*->F(1),F(1)*->F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),N,F(1),F(1)*,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2),F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,F(2),N,F(2)*,F(1)*,N,F(2),F(2),F(2)*,F(2),F(1),F(4),F(1),F(1),F(1),F(1),N,F(2),F(2),F(3),F(3),F(2),F(2),F(3),F(3),F(1)*,F(1),N,F(3),F(3),F(3),F(3),F(2),F(2),F(3),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(3),F(3),F(2),F(2),F(2),F(3),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2)*,F(2)*,F(1),F(1),F(3),F(3),F(2),N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$15 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$2 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$14 = cst$15,
    cst$13 = cst$15,
    cst$12 = cst$15,
    cst$11 = cst$15,
    cst$10 = cst$15,
    cst$8 = cst$15,
    cst$9 = cst$15,
    cst$6 = cst$15,
    cst$7 = cst$15,
    cst$5 = cst$15,
    cst$4 = cst$15,
    cst$3 = cst$15,
    cst$2 = cst$15,
    cst$1 = cst$15,
    cst$0 = cst$15,
    cst = cst$15,
    codec_name = "UTF-8",
    module_name = "Base.String.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$0 = "Base.String.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$1 = "Base.String.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$2 = "Base.String.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$3 = "Base.String.Utf32be",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Sequence = global_data.Base__Sequence,
    Base_Sexp = global_data.Base__Sexp,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Or_error = global_data.Base__Or_error,
    Base_Option = global_data.Base__Option,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol_concat = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    escaped = Base_String0[6],
    lowercase = Base_String0[7],
    make = Base_String0[8],
    uncapitalize = Base_String0[10],
    uppercase = Base_String0[11],
    is_valid_utf_8 = Base_String0[12],
    is_valid_utf_16le = Base_String0[13],
    is_valid_utf_16be = Base_String0[14],
    get_utf_8_uchar = Base_String0[15],
    get_utf_16le_uchar = Base_String0[16],
    get_utf_16be_uchar = Base_String0[17],
    get_utf_32le_uchar = Base_String0[18],
    get_utf_32be_uchar = Base_String0[19],
    concat = Base_String0[20],
    iter = Base_String0[21],
    split_lines = Base_String0[22],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[32],
    stage = Base_Staged[1],
    globalize = Base_Import[289],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include[1],
    a = [0, "String.index_exn: not found"],
    b = [0, "String.index_from_exn: not found"],
    cst_String_index_from_exn = "String.index_from_exn",
    c = [0, "String.rindex_exn: not found"],
    d = [0, "String.rindex_from_exn: not found"],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    e = [0, cst_case_sensitive],
    f = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    g = [0, "kmp_array"],
    h = [0, cst_case_sensitive],
    i = [0, cst_pattern];
   function invariant(param){return 0;}
   function unsafe_sub(src, pos, len){
    if(0 === len) return cst;
    var dst = Base_Bytes0[7].call(null, len);
    caml_blit_string(src, pos, dst, 0, len);
    return caml_string_of_bytes(dst);
   }
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    Base_Ordered_collection_common[2].call
     (null, pos, len, caml_ml_string_length(src));
    return unsafe_sub(src, pos, len);
   }
   function subo(opt, len, src){
    var pos = opt ? opt[1] : 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = Base_Import[93].call(null, caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char){
    var
     pos$1 = opt ? opt[1] : 0,
     total_length = caml_ml_string_length(t),
     d = Base_Import[93].call(null, total_length, pos$1),
     len$0 = Base_Option[30].call(null, len, d);
    Base_Ordered_collection_common[2].call(null, pos$1, len$0, total_length);
    var end = Base_Import[91].call(null, pos$1, len$0), pos = pos$1;
    for(;;){
     var a = pos < end ? 1 : 0;
     if(a){
      var b = Base_Char[16].call(null, caml_string_unsafe_get(t, pos), char);
      if(! b){
       var pos$0 = Base_Import[91].call(null, pos, 1);
       pos = pos$0;
       continue;
      }
      var c = b;
     }
     else
      var c = a;
     return c;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index(string, char){
    var
     found = Base_Option[49],
     len = caml_ml_string_length(string),
     pos$0 = 0;
    for(;;){
     if(len <= pos$0) return 0;
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$0), char))
      return found(pos$0);
     var pos = Base_Import[91].call(null, pos$0, 1);
     pos$0 = pos;
    }
   }
   function index_exn(string, char){
    var len = caml_ml_string_length(string), pos$0 = 0;
    for(;;){
     if(len <= pos$0)
      throw caml_maybe_attach_backtrace([0, Base_Import[297], a], 1);
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$0), char))
      return pos$0;
     var pos = Base_Import[91].call(null, pos$0, 1);
     pos$0 = pos;
    }
   }
   function index_from(string, pos, char){
    var
     found = Base_Option[49],
     len = caml_ml_string_length(string),
     pos$1 = pos;
    for(;;){
     if(len <= pos$1) return 0;
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
      return found(pos$1);
     var pos$0 = Base_Import[91].call(null, pos$1, 1);
     pos$1 = pos$0;
    }
   }
   function index_from_exn(string, pos, char){
    var len = caml_ml_string_length(string);
    if(0 <= pos && len >= pos){
     var pos$1 = pos;
     for(;;){
      if(len <= pos$1)
       throw caml_maybe_attach_backtrace([0, Base_Import[297], b], 1);
      if
       (Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
       return pos$1;
      var pos$0 = Base_Import[91].call(null, pos$1, 1);
      pos$1 = pos$0;
     }
    }
    return Base_Import[126].call(null, cst_String_index_from_exn);
   }
   function rindex(string, char){
    var
     pos = Base_Import[93].call(null, caml_ml_string_length(string), 1),
     found = Base_Option[49],
     pos$1 = pos;
    for(;;){
     if(0 > pos$1) return 0;
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
      return found(pos$1);
     var pos$0 = Base_Import[93].call(null, pos$1, 1);
     pos$1 = pos$0;
    }
   }
   function rindex_exn(string, char){
    var
     pos = Base_Import[93].call(null, caml_ml_string_length(string), 1),
     pos$1 = pos;
    for(;;){
     if(0 > pos$1)
      throw caml_maybe_attach_backtrace([0, Base_Import[297], c], 1);
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
      return pos$1;
     var pos$0 = Base_Import[93].call(null, pos$1, 1);
     pos$1 = pos$0;
    }
   }
   function rindex_from(string, pos, char){
    var found = Base_Option[49], pos$1 = pos;
    for(;;){
     if(0 > pos$1) return 0;
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
      return found(pos$1);
     var pos$0 = Base_Import[93].call(null, pos$1, 1);
     pos$1 = pos$0;
    }
   }
   function rindex_from_exn(string, pos, char){
    if(-1 <= pos && caml_ml_string_length(string) > pos){
     var pos$1 = pos;
     for(;;){
      if(0 > pos$1)
       throw caml_maybe_attach_backtrace([0, Base_Import[297], d], 1);
      if
       (Base_Char[16].call(null, caml_string_unsafe_get(string, pos$1), char))
       return pos$1;
      var pos$0 = Base_Import[93].call(null, pos$1, 1);
      pos$1 = pos$0;
     }
    }
    return Base_Import[126].call(null, cst_String_rindex_from_exn);
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     a =
       [0,
        [1, [0, e, [0, Base_Import[135].call(null, case_sensitive), 0]]],
        0];
    return [1,
            [0, [1, [0, f, [0, Base_Import[136].call(null, pattern), 0]]], a]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[Base_Import[93].call(null, matched_chars$0[1], 1) + 1];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = Base_Import[91].call(null, matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[16] : Base_Char[55][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = Base_Array0[4].call(null, n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var matched_chars = [0, 0], a = Base_Import[93].call(null, n, 1), b = 1;
     if(a >= 1){
      var i = b;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[i + 1] = matched_chars[1];
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param, text){
    var
     pos = opt ? opt[1] : 0,
     kmp_array = param[3],
     case_sensitive = param[2],
     pattern = param[1];
    if
     (0 <= pos
      &&
       Base_Import[93].call
        (null, caml_ml_string_length(text), caml_ml_string_length(pattern))
       >= pos){
     var
      char_equal = get_char_equal(case_sensitive),
      j = [0, pos],
      matched_chars = [0, 0],
      k = caml_ml_string_length(pattern),
      n = caml_ml_string_length(text);
     for(;;){
      if(j[1] < n && matched_chars[1] < k){
       var next_text_char = caml_string_unsafe_get(text, j[1]);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
       j[1] = Base_Import[91].call(null, j[1], 1);
       continue;
      }
      return matched_chars[1] === k ? Base_Import[93].call(null, j[1], k) : -1;
     }
    }
    return -1;
   }
   function matches(t, str){return 0 <= index_internal(0, t, str) ? 1 : 0;}
   function index$0(pos, t, in$){
    var p = index_internal(pos, t, in$);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$){
    var p = index_internal(pos, t, in$);
    if(0 <= p) return p;
    var a = [0, [0, cst_substring, Base_Import[136].call(null, t[1])], 0];
    return raise_s(Base_Sexp[10].call(null, cst_Substring_not_found, a));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var a = Base_Import[91].call(null, 1, caml_ml_string_length(text));
     return Base_List[40].call(null, a, function(a){return a;});
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     b = 0;
    if(n >= 0){
     var j = b;
     for(;;){
      if(matched_chars[1] === k){
       var c = found[1];
       found[1] = [0, Base_Import[93].call(null, j, k), c];
       matched_chars[1] =
        may_overlap ? kmp_array[Base_Import[93].call(null, k, 1) + 1] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var d = j + 1 | 0;
      if(n === j) break;
      j = d;
     }
    }
    return Base_List[63].call(null, found[1]);
   }
   function replace_first(pos, t, s, with$){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$),
     a = Base_Import[91].call(null, len_s, len_with),
     b = Base_Import[93].call(null, a, len_t),
     dst = Base_Bytes0[7].call(null, b);
    Base_Bytes0[4].call(null, s, 0, dst, 0, i);
    Base_Bytes0[4].call(null, with$, 0, dst, i, len_with);
    var
     c = Base_Import[93].call(null, len_s, i),
     d = Base_Import[93].call(null, c, len_t),
     e = Base_Import[91].call(null, i, len_with),
     f = Base_Import[91].call(null, i, len_t);
    Base_Bytes0[4].call(null, s, f, dst, e, d);
    return caml_string_of_bytes(dst);
   }
   function replace_all(t, s, with$){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$),
     num_matches = Base_List[45].call(null, matches),
     a = Base_Import[93].call(null, len_with, len_t),
     b = Base_Import[88].call(null, a, num_matches),
     c = Base_Import[91].call(null, len_s, b),
     dst = Base_Bytes0[7].call(null, c),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    Base_List[19].call
     (null,
      matches,
      function(i){
       var len = Base_Import[93].call(null, i, next_src_pos[1]);
       Base_Bytes0[4].call
        (null, s, next_src_pos[1], dst, next_dst_pos[1], len);
       var a = Base_Import[91].call(null, next_dst_pos[1], len);
       Base_Bytes0[4].call(null, with$, 0, dst, a, len_with);
       var b = Base_Import[91].call(null, next_dst_pos[1], len);
       next_dst_pos[1] = Base_Import[91].call(null, b, len_with);
       var c = Base_Import[91].call(null, next_src_pos[1], len);
       next_src_pos[1] = Base_Import[91].call(null, c, len_t);
       return 0;
      });
    var d = Base_Import[93].call(null, len_s, next_src_pos[1]);
    Base_Bytes0[4].call(null, s, next_src_pos[1], dst, next_dst_pos[1], d);
    return caml_string_of_bytes(dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s),
     a =
       Base_Import[111].call(null, matches, [0, caml_ml_string_length(s), 0]),
     b = [0, Base_Import[113].call(null, pattern_len), matches];
    return Base_List[98].call
            (null,
             b,
             a,
             function(i, j){
              var
               a = Base_Import[93].call(null, j, i),
               b = Base_Import[93].call(null, a, pattern_len);
              return sub(s, Base_Import[91].call(null, i, pattern_len), b);
             });
   }
   function equal_local(a_003, b_004){
    if(a_003 === b_004) return 1;
    var a = caml_call2(Base_Import[274], a_003[1], b_004[1]);
    if(a){
     var b = caml_call2(Base_Import[267], a_003[2], b_004[2]);
     if(b)
      return caml_call3
              (Base_Import[277], Base_Import[270], a_003[3], b_004[3]);
     var c = b;
    }
    else
     var c = a;
    return c;
   }
   function equal(a, b){return equal_local(a, b);}
   function sexp_of_t$1(param){
    var
     kmp_array_012 = param[3],
     case_sensitive_010 = param[2],
     pattern_008 = param[1],
     arg_013 = Base_Import[150].call(null, Base_Import[139], kmp_array_012),
     bnds_007 = [0, [1, [0, g, [0, arg_013, 0]]], 0],
     arg_011 = Base_Import[135].call(null, case_sensitive_010),
     bnds_007$0 = [0, [1, [0, h, [0, arg_011, 0]]], bnds_007],
     arg_009 = Base_Import[136].call(null, pattern_008),
     bnds_007$1 = [0, [1, [0, i, [0, arg_009, 0]]], bnds_007$0];
    return [1, bnds_007$1];
   }
   function representation(a){return a;}
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var a = create(pattern, case_sensitive);
    return function(b){return replace_first(pos, a, t, b);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var a = create(pattern, case_sensitive);
    return function(b){return replace_all(a, t, b);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var a = substr_index_gen(case_sensitive, 0, t, substring);
    return Base_Option[53].call(null, a);
   }
   var j = 1;
   function substr_index(a, b, c){return substr_index_gen(j, a, b, c);}
   var k = 1;
   function substr_index_exn(a, b, c){
    return substr_index_exn_gen(k, a, b, c);
   }
   var l = 1;
   function substr_index_all(a, b, c){
    return substr_index_all_gen(l, a, b, c);
   }
   var m = 1;
   function substr_replace_first(a, b, c){
    return substr_replace_first_gen(m, a, b, c);
   }
   var n = 1;
   function substr_replace_all(a, b){return substr_replace_all_gen(n, a, b);}
   var
    o = 1,
    p =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"];
   function is_substring(a, b){return is_substring_gen(o, a, b);}
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     b = str_pos$1 < 0 ? 1 : 0,
     c = b || (str_len < str_pos$1 ? 1 : 0);
    if(c) caml_call3(invalid_argf(p), str_pos$1, str_len, 0);
    var a = Base_Import[91].call(null, str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! a) return a;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = Base_Import[91].call(null, sub_pos, 1),
      str_pos$0 = Base_Import[91].call(null, str_pos, 1);
     str_pos = str_pos$0;
     sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     a = suffix_len <= string_len ? 1 : 0;
    return a
            ? is_substring_at_gen
              (string,
               Base_Import[93].call(null, string_len, suffix_len),
               suffix,
               char_equal)
            : a;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     a = prefix_len <= string_len ? 1 : 0;
    return a ? is_substring_at_gen(string, 0, prefix, char_equal) : a;
   }
   var
    t_of_sexp$0 = Base_Import[160],
    sexp_of_t$2 = Base_Import[136],
    t_sexp_grammar$0 = Base_Import[182];
   function compare_local(string1, string2){
    if(string1 === string2) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      a = Base_Char[37].call(null, c2),
      b = Base_Char[37].call(null, c1),
      c = Base_Char[17].call(null, b, a);
     if(0 !== c) return c;
     var pos$0 = Base_Import[91].call(null, pos, 1);
     pos = pos$0;
    }
   }
   function compare$0(a, b){return compare_local(a, b);}
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     a = Base_Import[93].call(null, len, 1),
     b = 0;
    if(a >= 0){
     var pos = b;
     for(;;){
      var c = Base_Char[37].call(null, caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], c);
      var d = pos + 1 | 0;
      if(a === pos) break;
      pos = d;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return Base_Hash[14].call(null, 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[55][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[55][12]);
   }
   var q = 0;
   function substr_index$0(a, b, c){return substr_index_gen(q, a, b, c);}
   var r = 0;
   function substr_index_exn$0(a, b, c){
    return substr_index_exn_gen(r, a, b, c);
   }
   var s = 0;
   function substr_index_all$0(a, b, c){
    return substr_index_all_gen(s, a, b, c);
   }
   var t = 0;
   function substr_replace_first$0(a, b, c){
    return substr_replace_first_gen(t, a, b, c);
   }
   var u = 0;
   function substr_replace_all$0(a, b){
    return substr_replace_all_gen(u, a, b);
   }
   var v = 0;
   function is_substring$0(a, b){return is_substring_gen(v, a, b);}
   var w = Base_Char[55][12];
   function is_substring_at(a){
    return function(c){
     function b(b, d){return is_substring_at_gen(a, c, b, d);}
     return function(a){return b(a, w);};};
   }
   var
    include$0 = Base_Comparable[11].call(null, [0, compare$0, sexp_of_t$2]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16],
    x = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"],
    y = [0, "String.lsplit2_exn: not found"],
    z = [0, "String.rsplit2_exn: not found"],
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    cst_drop_prefix = "drop_prefix",
    cst_drop_suffix = "drop_suffix",
    cst_prefix = "prefix",
    cst_suffix = "suffix",
    A = [0, cst_src_string_ml, 761, 17],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    B = [0, cst_src_string_ml, 925, 4],
    C =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    D =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    E = [0, [3, 0, 0], "%S"],
    F = [0, cst$15, cst$15],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    G = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_is_char_escaping = "is_char_escaping",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_literal = "is_char_literal",
    cst_index_from = "index_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$2,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$2,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    H = [0, cst_src_string_ml, 1858, 19],
    I = [0, cst_src_string_ml, 1872, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    J =
      [0,
       [2,
        0,
        [11, ".get: invalid ", [2, 0, [11, " encoding at given position", 0]]]],
       "%s.get: invalid %s encoding at given position"],
    cst_pos$1 = cst_pos$2,
    cst_of_string_invalid = ".of_string: invalid ",
    K = [0, cst_src_string_ml, 1996, 4],
    L = [0, cst_src_string_ml, 2006, 4],
    M = [0, cst_src_string_ml, 2020, 4],
    N = [0, cst$15];
   function of_string(a){return a;}
   function to_string(a){return a;}
   function init(n, f){
    if(n < 0) caml_call2(invalid_argf(x), n, 0);
    var
     t = Base_Bytes0[7].call(null, n),
     a = Base_Import[93].call(null, n, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return caml_string_of_bytes(t);
   }
   function to_list(s){
    var
     i$1 = Base_Import[93].call(null, caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = Base_Import[93].call(null, i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = Base_Import[91].call(null, i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = Base_Bytes0[7].call(null, len),
     a = Base_Import[93].call(null, len, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = Base_Import[93].call(null, len, 1);
      caml_bytes_unsafe_set
       (res, i, caml_string_unsafe_get(t, Base_Import[93].call(null, c, i)));
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return caml_string_of_bytes(res);
   }
   function lsplit2_exn(string, delim){
    var len = caml_ml_string_length(string), pos = 0;
    for(;;){
     if(len <= pos)
      throw caml_maybe_attach_backtrace([0, Base_Import[297], y], 1);
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos), delim)){
      var
       a = Base_Import[93].call(null, len, pos),
       b = Base_Import[93].call(null, a, 1),
       c = sub(string, Base_Import[91].call(null, pos, 1), b);
      return [0, sub(string, 0, pos), c];
     }
     var pos$0 = Base_Import[91].call(null, pos, 1);
     pos = pos$0;
    }
   }
   function rsplit2_exn(string, delim){
    var
     len = caml_ml_string_length(string),
     pos$1 = Base_Import[93].call(null, len, 1),
     pos = pos$1;
    for(;;){
     if(0 > pos)
      throw caml_maybe_attach_backtrace([0, Base_Import[297], z], 1);
     if(Base_Char[16].call(null, caml_string_unsafe_get(string, pos), delim)){
      var
       a = Base_Import[93].call(null, len, pos),
       b = Base_Import[93].call(null, a, 1),
       c = sub(string, Base_Import[91].call(null, pos, 1), b);
      return [0, sub(string, 0, pos), c];
     }
     var pos$0 = Base_Import[93].call(null, pos, 1);
     pos = pos$0;
    }
   }
   function lsplit2(line, on){
    try{var a = [0, lsplit2_exn(line, on)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Base_Import[297] && exn !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(exn, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var a = [0, rsplit2_exn(line, on)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Base_Import[297] && exn !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(exn, 0);
     return 0;
    }
   }
   function char_list_mem(l$0, c){
    var l = l$0;
    for(;;){
     if(! l) return 0;
     var tl = l[2], hd = l[1], a = Base_Char[16].call(null, hd, c);
     if(a) return a;
     l = tl;
    }
   }
   function split_gen(str, on){
    var variant = on[1];
    if(552554919 <= variant)
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return Base_Char[16].call(null, c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     last_pos$4 = Base_Import[93].call(null, last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = last_pos$4;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0))){
      var
       pos1 = Base_Import[91].call(null, last_pos$0, 1),
       sub_str = sub(str, pos1, Base_Import[93].call(null, last_pos$1, pos1)),
       last_pos$2 = Base_Import[93].call(null, last_pos$0, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      last_pos$1 = last_pos$0;
      last_pos$0 = last_pos$2;
     }
     else{
      var last_pos$3 = Base_Import[93].call(null, last_pos$0, 1);
      last_pos$0 = last_pos$3;
     }
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[16]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[16]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[16]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var a = sub(t, pos, len); return a;}catch(exn){return on_error;}
    var b = symbol_concat(name, cst_expecting_nonnegative_argu);
    return Base_Import[126].call(null, b);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             Base_Import[93].call(null, caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             Base_Import[93].call(null, caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             Base_Import[93].call(null, caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    var pos = opt ? opt[1] : 0, n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], i = pos$0;
    else
     var i = Base_Import[93].call(null, caml_ml_string_length(t), 1);
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = Base_Import[93].call(null, i, 1);
     i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    var drop = opt ? opt[1] : Base_Char[45], match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === Base_Import[93].call(null, caml_ml_string_length(t), 1)
            ? t
            : prefix(t, Base_Import[91].call(null, i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    var drop = opt ? opt[1] : Base_Char[45], match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    var
     drop = opt ? opt[1] : Base_Char[45],
     length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, Base_Import[93].call(null, length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, A], 1);
     var last = match$0[1], a = Base_Import[93].call(null, last, first);
     return sub(t, first, Base_Import[91].call(null, a, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = Base_Bytes0[7].call(null, l),
     a = Base_Import[93].call(null, l, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = Base_Bytes0[7].call(null, l),
     a = Base_Import[93].call(null, l, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function to_array(s){
    return Base_Array0[12].call
            (null,
             caml_ml_string_length(s),
             function(i){return caml_string_get(s, i);});
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var a = i < len ? 1 : 0;
     if(a){
      var b = caml_call1(f, caml_string_get(s, i));
      if(! b){var i$0 = Base_Import[91].call(null, i, 1); i = i$0; continue;}
      var c = b;
     }
     else
      var c = a;
     return c;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var a = i === len ? 1 : 0;
     if(a)
      var b = a;
     else{
      var c = caml_call1(f, caml_string_get(s, i));
      if(c){var i$0 = Base_Import[91].call(null, i, 1); i = i$0; continue;}
      var b = c;
     }
     return b;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function iteri(t, f){
    var a = Base_Import[93].call(null, caml_ml_string_length(t), 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function count(t, f){return Base_Container[2].call(null, fold, t, f);}
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function min_elt(t){
    var a = Base_Container[3];
    return function(b){return a(fold, t, b);};
   }
   function max_elt(t){
    var a = Base_Container[4];
    return function(b){return a(fold, t, b);};
   }
   function fold_result(t, init, f){
    return Base_Container[8].call(null, fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return Base_Container[9].call(null, fold, init, f, finish, t);
   }
   function find_mapi(t, f){
    return Base_Indexed_container[7].call(null, iteri, t, f);
   }
   function findi(t, f){
    return Base_Indexed_container[6].call(null, iteri, t, f);
   }
   function counti(t, f){
    return Base_Indexed_container[3].call(null, foldi, t, f);
   }
   function for_alli(t, f){
    return Base_Indexed_container[5].call(null, iteri, t, f);
   }
   function existsi(t, f){
    return Base_Indexed_container[4].call(null, iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var a = i < len ? 1 : 0;
     if(a){
      var b = Base_Char[16].call(null, c, caml_string_unsafe_get(t, i));
      if(! b){var i$0 = Base_Import[91].call(null, i, 1); i = i$0; continue;}
      var d = b;
     }
     else
      var d = a;
     return d;
    }
   }
   function tr(target, replacement, s){
    return Base_Char[16].call(null, target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return Base_Char[16].call(null, c, target) ? replacement : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target)) return stage(function(a){return a;});
    if(is_empty(replacement))
     return Base_Import[126].call(null, cst_tr_multi_replacement_is_em);
    var match = Base_Bytes_tr[1].call(null, target, replacement);
    if(! match) return stage(function(a){return a;});
    var tr_map = match[1];
    return stage
            (function(s){
              var len = caml_ml_string_length(s), i$0 = 0;
              for(;;){
               var d = i$0 < len ? 1 : 0;
               if(! d){var b = d; break;}
               var
                c = caml_string_get(s, i$0),
                e =
                  caml_string_unsafe_get(tr_map, Base_Char[32].call(null, c)),
                a = Base_Char[15].call(null, c, e);
               if(a){var b = a; break;}
               var i = Base_Import[91].call(null, i$0, 1);
               i$0 = i;
              }
              return b
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, Base_Char[32].call(null, c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return concat(sep, Base_Array0[16].call(null, ar));
   }
   function concat_map(sep, s, f){
    var a = to_array(s);
    return concat_array(sep, Base_Array0[21].call(null, a, f));
   }
   function concat_mapi(sep, t, f){
    var a = to_array(t);
    return concat_array(sep, Base_Array0[22].call(null, a, f));
   }
   function concat_lines(opt, lines$3){
    var
     crlf = opt ? opt[1] : 0,
     newline_len = crlf ? 2 : 1,
     lines = lines$3,
     sum = 0;
    for(;;){
     if(! lines) break;
     var
      lines$0 = lines[2],
      line = lines[1],
      a = Base_Import[91].call(null, sum, caml_ml_string_length(line)),
      sum$0 = Base_Import[91].call(null, a, newline_len);
     lines = lines$0;
     sum = sum$0;
    }
    var buf = Base_Bytes0[7].call(null, sum), lines$1 = lines$3, written = 0;
    for(;;){
     if(! lines$1){
      if(written === sum) return caml_string_of_bytes(buf);
      throw caml_maybe_attach_backtrace([0, Assert_failure, B], 1);
     }
     var lines$2 = lines$1[2], line$0 = lines$1[1];
     caml_blit_string(line$0, 0, buf, written, caml_ml_string_length(line$0));
     var
      pos = Base_Import[91].call(null, written, caml_ml_string_length(line$0)),
      pos$0 =
        crlf
         ? (caml_bytes_unsafe_set
            (buf, pos, 13),
           Base_Import[91].call(null, pos, 1))
         : pos;
     caml_bytes_unsafe_set(buf, pos$0, 10);
     var pos$1 = Base_Import[91].call(null, pos$0, 1);
     lines$1 = lines$2;
     written = pos$1;
    }
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     a = Base_Import[93].call(null, n, 1),
     out = Base_Bytes0[7].call(null, a);
    Base_Bytes0[4].call(null, t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       b = Base_Import[93].call(null, n, 1);
      return out_pos[1] === b ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){caml_bytes_set(out, out_pos[1], c); out_pos[1]++;}
     i[1]++;
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var a = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], a)) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     b = Base_Import[93].call(null, n, 1),
     out = Base_Bytes0[7].call(null, b);
    Base_Bytes0[4].call(null, t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       d = Base_Import[93].call(null, n, 1);
      return out_pos[1] === d ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      out_pos[1]++;
     }
     i[1]++;
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call3(invalid_argf(C), s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call3(invalid_argf(D), s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return Base_List[20].call(null, rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var a = Base_Import[93].call(null, caml_ml_string_length(t), i);
    return Base_Import[93].call(null, a, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far$1){
    var len_so_far = len_so_far$1;
    for(;;){
     if(max_len <= len_so_far) return max_len;
     var
      c = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far)),
      d = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far));
     if(! Base_Char[16].call(null, d, c)) return len_so_far;
     var len_so_far$0 = Base_Import[91].call(null, len_so_far, 1);
     len_so_far = len_so_far$0;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       Base_Import[101].call
        (null, caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first$0, list$0, get_pos, max_len$1){
    var first = first$0, list = list$0, max_len = max_len$1;
    for(;;){
     if(! list) return max_len;
     var
      rest = list[2],
      second = list[1],
      max_len$0 =
        common_generic2_length_loop(first, second, get_pos, max_len, 0);
     first = second;
     list = rest;
     max_len = max_len$0;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call1(Stdlib_Format[139].call(null, ppf)(E), string);
   }
   function of_char(c){return make(1, c);}
   function of_char_list(l){
    var a = Base_List[45].call(null, l), t = Base_Bytes0[7].call(null, a);
    Base_List[34].call
     (null, l, function(i, c){return caml_bytes_set(t, i, c);});
    return caml_string_of_bytes(t);
   }
   function of_array(a){
    return init
            (a.length - 1, function(b){return caml_check_bound(a, b)[b + 1];});
   }
   function to_sequence(t){
    var len = caml_ml_string_length(t);
    return Base_Sequence[44].call
            (null,
             0,
             function(pos){
              return len <= pos
                      ? 0
                      : [1,
                        caml_string_unsafe_get(t, pos),
                        Base_Import[91].call(null, pos, 1)];
             });
   }
   function of_sequence(s){
    return of_char_list(Base_Sequence[20].call(null, s));
   }
   function pad_right(opt, s, len){
    var char = opt ? opt[1] : 32, src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var res = Base_Bytes0[7].call(null, len);
    Base_Bytes0[4].call(null, s, 0, res, 0, src_len);
    var a = Base_Import[93].call(null, len, src_len);
    Base_Bytes0[15].call(null, res, src_len, a, char);
    return caml_string_of_bytes(res);
   }
   function pad_left(opt, s, len){
    var char = opt ? opt[1] : 32, src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var
     res = Base_Bytes0[7].call(null, len),
     a = Base_Import[93].call(null, len, src_len);
    Base_Bytes0[4].call(null, s, 0, res, a, src_len);
    var b = Base_Import[93].call(null, len, src_len);
    Base_Bytes0[15].call(null, res, 0, b, char);
    return caml_string_of_bytes(res);
   }
   function local_copy_prefix(src, prefix_len, buffer_len){
    var dst = Base_Bytes0[14].call(null, buffer_len);
    caml_blit_string(src, 0, dst, 0, prefix_len);
    return dst;
   }
   function local_copy_to_string(buf, pos){
    var str = caml_string_of_bytes(buf);
    return unsafe_sub(str, 0, pos);
   }
   function filter_mapi(src, f){
    var src_len = caml_ml_string_length(src), pos = 0;
    for(;;){
     if(pos === src_len) return src;
     var
      c1 = caml_string_unsafe_get(src, pos),
      src_pos$0 = Base_Int0[8].call(null, pos),
      option = caml_call2(f, pos, c1);
     if(! option) break;
     var c2 = option[1];
     if(! Base_Char[16].call(null, c1, c2)) break;
     pos = src_pos$0;
    }
    var copy = local_copy_prefix(src, pos, src_len);
    if(option){
     var c$0 = option[1];
     caml_bytes_unsafe_set(copy, pos, c$0);
     var dst_pos$0 = src_pos$0;
    }
    else
     var dst_pos$0 = pos;
    var dst_pos = [0, dst_pos$0], a = Base_Import[93].call(null, src_len, 1);
    if(a >= src_pos$0){
     var src_pos = src_pos$0;
     for(;;){
      var
       match = caml_call2(f, src_pos, caml_string_unsafe_get(src, src_pos));
      if(match){
       var c = match[1];
       caml_bytes_unsafe_set(copy, dst_pos[1], c);
       dst_pos[1]++;
      }
      var b = src_pos + 1 | 0;
      if(a === src_pos) break;
      src_pos = b;
     }
    }
    return local_copy_to_string(copy, dst_pos[1]);
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, c){return caml_call1(f, c);});
   }
   function partition_map_difference
   (src, f, len, src_pos$0, fst_pos$0, snd_pos$0, either){
    var
     fsts = local_copy_prefix(src, fst_pos$0, len),
     snds = local_copy_prefix(src, snd_pos$0, len);
    if(0 === either[0]){
     var c$1 = either[1];
     caml_bytes_unsafe_set(fsts, fst_pos$0, c$1);
     var
      snd_pos$1 = snd_pos$0,
      fst_pos$1 = Base_Import[91].call(null, fst_pos$0, 1);
    }
    else{
     var c$2 = either[1];
     caml_bytes_unsafe_set(snds, snd_pos$0, c$2);
     var
      snd_pos$2 = Base_Import[91].call(null, snd_pos$0, 1),
      snd_pos$1 = snd_pos$2,
      fst_pos$1 = fst_pos$0;
    }
    var
     src_pos$1 = Base_Import[91].call(null, src_pos$0, 1),
     fst_pos = [0, fst_pos$1],
     snd_pos = [0, snd_pos$1],
     a = Base_Import[93].call(null, len, 1);
    if(a >= src_pos$1){
     var src_pos = src_pos$1;
     for(;;){
      var match = caml_call1(f, caml_string_unsafe_get(src, src_pos));
      if(0 === match[0]){
       var c = match[1];
       caml_bytes_unsafe_set(fsts, fst_pos[1], c);
       fst_pos[1]++;
      }
      else{
       var c$0 = match[1];
       caml_bytes_unsafe_set(snds, snd_pos[1], c$0);
       snd_pos[1]++;
      }
      var d = src_pos + 1 | 0;
      if(a === src_pos) break;
      src_pos = d;
     }
    }
    var b = local_copy_to_string(snds, snd_pos[1]);
    return [0, local_copy_to_string(fsts, fst_pos[1]), b];
   }
   function partition_map(src, f){
    var len = caml_ml_string_length(src);
    if(0 === len) return F;
    var c1$1 = caml_string_unsafe_get(src, 0), either$1 = caml_call1(f, c1$1);
    if(0 === either$1[0]){
     var c2$1 = either$1[1];
     if(Base_Char[16].call(null, c1$1, c2$1)){
      var pos = 1;
      for(;;){
       if(pos === len) return [0, src, cst$8];
       var c1 = caml_string_unsafe_get(src, pos), either = caml_call1(f, c1);
       if(0 === either[0]){
        var c2 = either[1];
        if(Base_Char[16].call(null, c1, c2)){
         var pos$0 = Base_Import[91].call(null, pos, 1);
         pos = pos$0;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos, pos, 0, either);
      }
     }
    }
    else{
     var c2$2 = either$1[1];
     if(Base_Char[16].call(null, c1$1, c2$2)){
      var pos$1 = 1;
      for(;;){
       if(pos$1 === len) return [0, cst$9, src];
       var
        c1$0 = caml_string_unsafe_get(src, pos$1),
        either$0 = caml_call1(f, c1$0);
       if(0 !== either$0[0]){
        var c2$0 = either$0[1];
        if(Base_Char[16].call(null, c1$0, c2$0)){
         var pos$2 = Base_Import[91].call(null, pos$1, 1);
         pos$1 = pos$2;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos$1, 0, pos$1, either$0);
      }
     }
    }
    return partition_map_difference(src, f, len, 0, 0, 0, either$1);
   }
   function partition_tf(t, f){
    return partition_map
            (t, function(c){return caml_call1(f, c) ? [0, c] : [1, c];});
   }
   function edit_distance(s2, s1){
    if(caml_ml_string_length(s2) <= caml_ml_string_length(s1))
     var s2$0 = s1, s1$0 = s2;
    else
     var s2$0 = s2, s1$0 = s1;
    var
     o = Base_Import[91].call(null, 1, caml_ml_string_length(s1$0)),
     p = Base_Import[88].call(null, 2, o),
     table = Base_Array0[5].call(null, p, 0);
    function at(i, j){
     var
      a = Base_Import[122].call(null, j, 2),
      b = Base_Import[88].call(null, i, 2);
     return Base_Import[91].call(null, b, a);
    }
    var a = caml_ml_string_length(s1$0), q = 1;
    if(a >= 1){
     var i$0 = q;
     for(;;){
      var n = at(i$0, 0);
      caml_check_bound(table, n)[n + 1] = i$0;
      var D = i$0 + 1 | 0;
      if(a === i$0) break;
      i$0 = D;
     }
    }
    var b = caml_ml_string_length(s2$0), r = 1;
    if(b >= 1){
     var j = r;
     for(;;){
      var d = at(0, j);
      caml_check_bound(table, d)[d + 1] = j;
      var e = caml_ml_string_length(s1$0), s = 1;
      if(e >= 1){
       var i = s;
       for(;;){
        var
         u = caml_string_get(s2$0, Base_Import[93].call(null, j, 1)),
         v = caml_string_get(s1$0, Base_Import[93].call(null, i, 1));
        if(Base_Char[16].call(null, v, u)){
         var
          w = Base_Import[93].call(null, j, 1),
          f = at(Base_Import[93].call(null, i, 1), w),
          x = caml_check_bound(table, f)[f + 1],
          g = at(i, j);
         caml_check_bound(table, g)[g + 1] = x;
        }
        else{
         var
          z = Base_Import[93].call(null, j, 1),
          h = at(Base_Import[93].call(null, i, 1), z),
          sub = caml_check_bound(table, h)[h + 1],
          k = at(Base_Import[93].call(null, i, 1), j),
          add = caml_check_bound(table, k)[k + 1],
          l = at(i, Base_Import[93].call(null, j, 1)),
          del = caml_check_bound(table, l)[l + 1],
          A = Base_Import[101].call(null, add, del),
          B = Base_Import[101].call(null, sub, A),
          C = Base_Import[91].call(null, 1, B),
          m = at(i, j);
         caml_check_bound(table, m)[m + 1] = C;
        }
        var y = i + 1 | 0;
        if(e === i) break;
        i = y;
       }
      }
      var t = j + 1 | 0;
      if(b === j) break;
      j = t;
     }
    }
    var c = at(caml_ml_string_length(s1$0), caml_ml_string_length(s2$0));
    return caml_check_bound(table, c)[c + 1];
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[137][7], escapeworthy_map, Base_Char[16], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = Base_Array0[4].call(null, 256, -1),
     vals = Base_Array0[4].call(null, 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = Base_Char[32].call(null, c_to);
     else
      var k$0 = Base_Char[32].call(null, c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[k + 1]) break;
     var a = Base_Char[32].call(null, v);
     if(caml_check_bound(vals, a)[a + 1]) break;
     var j = Base_Char[32].call(null, v);
     caml_check_bound(arr, k)[k + 1] = j;
     var b = Base_Char[32].call(null, v);
     caml_check_bound(vals, b)[b + 1] = 1;
     param = l;
    }
    var
     c = Base_Import[138],
     d = Base_Import[138],
     e = Base_Import[147],
     f =
       [0,
        [0,
         cst_escapeworthy_map,
         Base_Import[149].call
          (null, function(a){return e(d, c, a);}, escapeworthy_map$0)],
        0],
     g = [0, [0, cst_c_to, Base_Import[138].call(null, c_to)], f],
     h = [0, [0, cst_c_from, Base_Import[138].call(null, c_from)], g],
     i = Base_Sexp[10].call(null, cst_escapeworthy_map_not_one_t, h);
    return Base_Or_error[39].call(null, i);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              len$0 = caml_ml_string_length(src),
              to_escape$0 = 0,
              i$0 = 0;
             for(;;){
              if(i$0 === len$0) break;
              var
               c = caml_string_get(src, i$0),
               a = Base_Char[32].call(null, c),
               n = caml_check_bound(escapeworthy, a)[a + 1],
               ac =
                 -1 === n
                  ? to_escape$0
                  : (to_escape_len
                     [1]++,
                    [0, [0, i$0, Base_Char[35].call(null, n)], to_escape$0]),
               i = Base_Import[91].call(null, i$0, 1);
              to_escape$0 = ac;
              i$0 = i;
             }
             if(! to_escape$0) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                Base_Import[91].call(null, last_idx, to_escape_len[1]),
              dst = Base_Bytes0[7].call(null, last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape$0;
             for(;;){
              if(! param){
               Base_Bytes0[4].call(null, src, 0, dst, 0, last_idx$0);
               return caml_string_of_bytes(dst);
              }
              var
               to_escape = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               b = Base_Import[93].call(null, last_idx$0, last_idx$1),
               len = Base_Import[93].call(null, b, 1),
               dst_pos = Base_Import[93].call(null, last_dst_pos$0, len),
               d = Base_Import[91].call(null, last_idx$1, 1);
              Base_Bytes0[4].call(null, src, d, dst, dst_pos, len);
              var last_dst_pos$1 = Base_Import[93].call(null, dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                Base_Import[91].call(null, last_dst_pos$1, 1),
                escaped_char);
              last_idx$0 = last_idx$1;
              last_dst_pos$0 = last_dst_pos$1;
              param = to_escape;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var a = escape_gen(escapeworthy_map, escape_char);
    return stage(Base_Or_error[34].call(null, a));
   }
   function escape(escapeworthy, escape_char){
    var
     a = Base_List[126].call(null, escapeworthy, Base_Char[17]),
     escapeworthy_map =
       Base_List[53].call(null, a, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                a = caml_string_get(src, i),
                status$0 =
                  Base_Char[16].call(null, a, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = Base_Import[91].call(null, i, 1);
              i = i$0;
              status = status$0;
              to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              b = Base_List[45].call(null, to_unescape),
              c = Base_Import[93].call(null, caml_ml_string_length(src), b),
              dst = Base_Bytes0[7].call(null, c);
             function loop(last_idx$1, last_dst_pos$1, param$0){
              var
               last_idx = last_idx$1,
               last_dst_pos = last_dst_pos$1,
               param = param$0;
              for(;;){
               if(! param)
                return Base_Bytes0[4].call(null, src, 0, dst, 0, last_idx);
               var
                to_unescape = param[2],
                last_idx$0 = param[1],
                b = Base_Import[93].call(null, last_idx, last_idx$0),
                len = Base_Import[93].call(null, b, 2),
                dst_pos = Base_Import[93].call(null, last_dst_pos, len),
                c = Base_Import[91].call(null, last_idx$0, 2);
               Base_Bytes0[4].call(null, src, c, dst, dst_pos, len);
               var
                last_dst_pos$0 = Base_Import[93].call(null, dst_pos, 1),
                d =
                  caml_string_get
                   (src, Base_Import[91].call(null, last_idx$0, 1)),
                a = Base_Char[32].call(null, d),
                n = caml_check_bound(escapeworthy, a)[a + 1],
                e =
                  -1 === n
                   ? caml_string_get
                     (src, Base_Import[91].call(null, last_idx$0, 1))
                   : Base_Char[35].call(null, n);
               caml_bytes_set(dst, last_dst_pos$0, e);
               last_idx = last_idx$0;
               last_dst_pos = last_dst_pos$0;
               param = to_unescape;
              }
             }
             if
              (idx < Base_Import[93].call(null, caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (Base_Import[93].call(null, caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_string_of_bytes(dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var a = unescape_gen(escapeworthy_map, escape_char);
    return stage(Base_Or_error[34].call(null, a));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = Base_Import[93].call(null, pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var a = caml_string_get(str, p);
      if(! Base_Char[15].call(null, a, escape_char)){
       var
        cnt$0 = Base_Import[91].call(null, cnt, 1),
        p$0 = Base_Import[93].call(null, p, 1);
       p = p$0;
       cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var a = caml_string_get(str, i);
    return Base_Char[16].call(null, a, escape_char) ? -767030498 : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     a = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === Base_Import[122].call(null, a, 2) ? 1 : 0,
     b = caml_string_get(str, pos),
     match = Base_Char[16].call(null, b, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     b = caml_ml_string_length(str) <= pos ? 1 : 0,
     a = b || (pos < 0 ? 1 : 0);
    return a ? caml_call2(invalid_argf(G), function_name, 0) : a;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var a = -512962225 === status ? 1 : 0;
      if(a){
       var b = caml_string_get(str, i);
       if(Base_Char[16].call(null, b, char)) return [0, i];
      }
     }
     var i$0 = Base_Import[91].call(null, i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var status$0 = update_escape_status(str, escape_char, i$0, status);
     i = i$0;
     status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char){
    var match = index_from$0(str, escape_char, pos, char);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     a = [0, [0, cst_char, Base_Import[138].call(null, char)], 0],
     b = [0, [0, cst_pos, Base_Import[139].call(null, pos)], a],
     c =
       [0, [0, cst_escape_char, Base_Import[138].call(null, escape_char)], b],
     d = [0, [0, cst_str, sexp_of_t(str)], c];
    return raise_s(Base_Sexp[10].call(null, cst_index_from_exn_not_found, d));
   }
   function index$1(str, escape_char, char){
    return index_from$0(str, escape_char, 0, char);
   }
   function index_exn$1(str, escape_char, char){
    return index_from_exn$0(str, escape_char, 0, char);
   }
   function rindex_from$0(str, escape_char, pos, char){
    check_bound(str, pos, cst_rindex_from);
    if(Base_Char[16].call(null, char, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === Base_Import[122].call(null, escape_chars, 2)){
      var a = caml_string_get(str, pos$0);
      if(Base_Char[16].call(null, a, char)) return [0, pos$0];
     }
     var
      b = Base_Import[93].call(null, pos$0, escape_chars),
      pos$1 = Base_Import[93].call(null, b, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char){
    var match = rindex_from$0(str, escape_char, pos, char);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     a = [0, [0, cst_char$0, Base_Import[138].call(null, char)], 0],
     b = [0, [0, cst_pos$0, Base_Import[139].call(null, pos)], a],
     c =
       [0,
        [0, cst_escape_char$0, Base_Import[138].call(null, escape_char)],
        b],
     d = [0, [0, cst_str$0, sexp_of_t(str)], c];
    return raise_s(Base_Sexp[10].call(null, cst_rindex_from_exn_not_found, d));
   }
   function rindex$0(str, escape_char, char){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               Base_Import[93].call(null, caml_ml_string_length(str), 1),
               char);
   }
   function rindex_exn$0(str, escape_char, char){
    return rindex_from_exn$0
            (str,
             escape_char,
             Base_Import[93].call(null, caml_ml_string_length(str), 1),
             char);
   }
   function split_gen$0(str, escape_char, on){
    var variant = on[1];
    if(552554919 <= variant)
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return Base_Char[16].call(null, c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       a =
         [0,
          sub(str, last_pos, Base_Import[93].call(null, len, last_pos)),
          acc];
      return Base_List[63].call(null, a);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      b = -512962225 === status$0 ? 1 : 0;
     if(b && is_delim(caml_string_get(str, pos))){
      var
       sub_str = sub(str, last_pos, Base_Import[93].call(null, pos, last_pos)),
       pos$0 = Base_Import[91].call(null, pos, 1),
       last_pos$0 = Base_Import[91].call(null, pos, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      status = status$0;
      last_pos = last_pos$0;
      pos = pos$0;
      continue;
     }
     var pos$1 = Base_Import[91].call(null, pos, 1);
     status = status$0;
     pos = pos$1;
    }
   }
   function split$0(str, on){
    var a = [0, -1044422954, on];
    return function(b){return split_gen$0(str, b, a);};
   }
   function split_on_chars$0(str, chars){
    var a = [0, 552554919, chars];
    return function(b){return split_gen$0(str, b, a);};
   }
   function split_at(str, pos){
    var
     a = Base_Import[93].call(null, caml_ml_string_length(str), pos),
     b = Base_Import[93].call(null, a, 1),
     c = sub(str, Base_Import[91].call(null, pos, 1), b);
    return [0, sub(str, 0, pos), c];
   }
   function lsplit2$0(str, on, escape_char){
    var a = index$1(str, escape_char, on);
    return caml_call2
            (Base_Option[24], a, function(x){return split_at(str, x);});
   }
   function rsplit2$0(str, on, escape_char){
    var a = rindex$0(str, escape_char, on);
    return caml_call2
            (Base_Option[24], a, function(x){return split_at(str, x);});
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var a = 1 - caml_call1(drop, c);
              if(a)
               var b = a;
              else{
               var d = is_char_escaping(t, escape_char, i);
               if(! d) return is_char_escaped(t, escape_char, i);
               var b = d;
              }
              return b;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var a = 1 - caml_call1(drop, c);
              if(a)
               var b = a;
              else{
               var d = is_char_escaping(t, escape_char, i);
               if(! d) return is_char_escaped(t, escape_char, i);
               var b = d;
              }
              return b;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[45],
     match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$10;
    var i = match[1];
    return i === Base_Import[93].call(null, caml_ml_string_length(t), 1)
            ? t
            : prefix(t, Base_Import[91].call(null, i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[45],
     match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$11;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    var
     drop = opt ? opt[1] : Base_Char[45],
     length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, Base_Import[93].call(null, length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$12;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, H], 1);
     var last = match$0[1], a = Base_Import[93].call(null, last, first);
     return sub(t, first, Base_Import[91].call(null, a, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var a = Base_Import[109][2].call(null, low, t);
    return a ? Base_Import[109][2].call(null, t, high) : a;
   }
   function clamp_unchecked(t, min, max){
    return Base_Import[109][1].call(null, t, min)
            ? min
            : Base_Import[109][2].call(null, t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(Base_Import[109][2].call(null, min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, I], 1);
   }
   function clamp$0(t, min, max){
    if(! Base_Import[109][5].call(null, min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function create$0(opt, pattern){
    var case_sensitive = opt ? opt[1] : 1;
    return create(pattern, case_sensitive);
   }
   function Make_utf(Format){
    var
     codec_name = Format[1],
     is_valid = Format[3],
     raise_get_message =
       [246,
        function(c){
         var a = Format[1], b = Format[2];
         return caml_call2(Base_Printf[2].call(null, J), b, a);
        }];
    function raise_get(t, pos){
     var
      c =
        [0,
         [0, cst$13, [0, t]],
         [0, [0, cst_pos$1, Base_Import[139].call(null, pos)], 0]],
      a = runtime.caml_obj_tag(raise_get_message);
     a:
     if(250 === a)
      var b = raise_get_message[1];
     else{
      if(246 !== a && 244 !== a){var b = raise_get_message; break a;}
      var b = CamlinternalLazy[2].call(null, raise_get_message);
     }
     return raise_s(Base_Sexp[10].call(null, b, c));
    }
    function get(t, byte_pos){
     var decode = caml_call2(Format[5], t, byte_pos);
     return Base_Uchar0[18].call(null, decode)
             ? Base_Uchar0[19].call(null, decode)
             : raise_get(t, byte_pos);
    }
    function to_string(a){return a;}
    function of_string_unchecked(a){return a;}
    var
     raise_of_string_message =
       concat
        (0, [0, Format[2], [0, cst_of_string_invalid, [0, codec_name, 0]]]);
    function raise_of_string(string){
     return raise_s
             (Base_Sexp[10].call
               (null,
                raise_of_string_message,
                [0, [0, cst$14, [0, string]], 0]));
    }
    function of_string(string){
     return caml_call1(is_valid, string) ? string : raise_of_string(string);
    }
    var
     include = Base_Sexpable[5].call(null, [0, of_string, to_string]),
     t_sexp_grammar = include[1],
     t_of_sexp = include[2],
     sexp_of_t = include[3],
     compare = Base_Import[109][9];
    function hash(a){return runtime.Base_hash_string(a);}
    var
     module_name = Format[2],
     include$0 =
       Base_Identifiable[1].call
        (null,
         [0,
          compare,
          hash_fold_t,
          hash,
          t_of_sexp,
          sexp_of_t,
          of_string,
          to_string,
          module_name]),
     hash_fold_t$0 = include$0[1],
     hash$0 = include$0[2],
     t_of_sexp$0 = include$0[3],
     sexp_of_t$0 = include$0[4],
     of_string$0 = include$0[5],
     to_string$0 = include$0[6],
     symbol = include$0[7],
     symbol$0 = include$0[8],
     symbol$1 = include$0[9],
     symbol$2 = include$0[10],
     symbol$3 = include$0[11],
     symbol$4 = include$0[12],
     equal = include$0[13],
     compare$0 = include$0[14],
     min = include$0[15],
     max = include$0[16],
     ascending = include$0[17],
     descending = include$0[18],
     between = include$0[19],
     clamp_exn = include$0[20],
     clamp = include$0[21],
     comparator = include$0[22],
     pp = include$0[23],
     hashable = include$0[24];
    function to_sequence(t){
     var len = caml_ml_string_length(t);
     return Base_Sequence[45].call
             (null,
              0,
              function(byte_pos){
               if(len <= byte_pos) return 0;
               var
                decode = caml_call2(Format[5], t, byte_pos),
                a = Base_Uchar0[20].call(null, decode),
                b = Base_Import[91].call(null, byte_pos, a);
               return [0, [0, Base_Uchar0[19].call(null, decode), b]];
              });
    }
    function fold(t, acc, f){
     var len = caml_ml_string_length(t), byte_pos = 0, acc$0 = acc;
     for(;;){
      if(byte_pos === len) return acc$0;
      var
       decode = caml_call2(Format[5], t, byte_pos),
       acc$1 = caml_call2(f, acc$0, Base_Uchar0[19].call(null, decode)),
       a = Base_Uchar0[20].call(null, decode),
       byte_pos$0 = Base_Import[91].call(null, byte_pos, a);
      byte_pos = byte_pos$0;
      acc$0 = acc$1;
     }
    }
    function sanitize(t){
     var len$0 = caml_ml_string_length(t), acc$2 = 0, byte_pos$2 = 0;
     for(;;){
      if(byte_pos$2 === len$0) break;
      var
       decode$0 = caml_call2(Format[5], t, byte_pos$2),
       uchar$0 = Base_Uchar0[19].call(null, decode$0),
       a = caml_call1(Format[4], uchar$0),
       acc = Base_Import[91].call(null, acc$2, a),
       d = Base_Uchar0[20].call(null, decode$0),
       byte_pos$1 = Base_Import[91].call(null, byte_pos$2, d);
      acc$2 = acc;
      byte_pos$2 = byte_pos$1;
     }
     var
      bytes = Base_Bytes0[7].call(null, acc$2),
      len = caml_ml_string_length(t),
      acc$1 = 0,
      byte_pos$0 = 0;
     for(;;){
      if(byte_pos$0 === len){
       if(acc$1 === acc$2) return caml_string_of_bytes(bytes);
       throw caml_maybe_attach_backtrace([0, Assert_failure, K], 1);
      }
      var
       decode = caml_call2(Format[5], t, byte_pos$0),
       uchar = Base_Uchar0[19].call(null, decode),
       b = caml_call3(Format[6], bytes, acc$1, uchar),
       acc$0 = Base_Import[91].call(null, acc$1, b),
       c = Base_Uchar0[20].call(null, decode),
       byte_pos = Base_Import[91].call(null, byte_pos$0, c);
      acc$1 = acc$0;
      byte_pos$0 = byte_pos;
     }
    }
    function of_list(uchars){
     var
      len =
        Base_List[20].call
         (null,
          uchars,
          0,
          function(n, u){
           var a = caml_call1(Format[4], u);
           return Base_Import[91].call(null, n, a);
          }),
      bytes = Base_Bytes0[7].call(null, len),
      pos =
        Base_List[20].call
         (null,
          uchars,
          0,
          function(pos, uchar){
           var a = caml_call3(Format[6], bytes, pos, uchar);
           return Base_Import[91].call(null, pos, a);
          });
     if(pos === len) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, L], 1);
    }
    function of_array(uchars){
     var
      len = [0, 0],
      a = Base_Import[93].call(null, uchars.length - 1, 1),
      c = 0;
     if(a >= 0){
      var i$0 = c;
      for(;;){
       var
        h = caml_check_bound(uchars, i$0)[i$0 + 1],
        j = caml_call1(Format[4], h);
       len[1] = Base_Import[91].call(null, len[1], j);
       var k = i$0 + 1 | 0;
       if(a === i$0) break;
       i$0 = k;
      }
     }
     var
      bytes = Base_Bytes0[7].call(null, len[1]),
      pos = [0, 0],
      b = Base_Import[93].call(null, uchars.length - 1, 1),
      d = 0;
     if(b >= 0){
      var i = d;
      for(;;){
       var
        e = caml_check_bound(uchars, i)[i + 1],
        f = caml_call3(Format[6], bytes, pos[1], e);
       pos[1] = Base_Import[91].call(null, pos[1], f);
       var g = i + 1 | 0;
       if(b === i) break;
       i = g;
      }
     }
     if(pos[1] === len[1]) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, M], 1);
    }
    function concat$0(list){return concat(N, list);}
    function split(t, on){
     var len = caml_ml_string_length(t), start$1 = 0, until = 0;
     for(;;){
      if(until === len)
       return [0,
               sub(t, start$1, Base_Import[93].call(null, until, start$1)),
               0];
      var
       uchar = get(t, until),
       a = caml_call1(Format[4], uchar),
       until$0 = Base_Import[91].call(null, until, a);
      if(Base_Uchar0[11].call(null, uchar, on)) break;
      until = until$0;
     }
     var
      block =
        [0,
         sub(t, start$1, Base_Import[93].call(null, until, start$1)),
         24029],
      dst = block,
      offset = 1,
      start = until$0,
      until$1 = until$0;
     for(;;){
      if(until$1 === len){
       dst[offset + 1] =
        [0, sub(t, start, Base_Import[93].call(null, until$1, start)), 0];
       return block;
      }
      var
       uchar$0 = get(t, until$1),
       b = caml_call1(Format[4], uchar$0),
       start$0 = Base_Import[91].call(null, until$1, b);
      if(Base_Uchar0[11].call(null, uchar$0, on)){
       var
        dst$0 =
          [0,
           sub(t, start, Base_Import[93].call(null, until$1, start)),
           24029];
       dst[offset + 1] = dst$0;
       dst = dst$0;
       offset = 1;
       start = start$0;
       until$1 = start$0;
      }
      else
       until$1 = start$0;
     }
    }
    var
     C =
       Base_Indexed_container[12].call
        (null,
         [0,
          [0, Base_Uchar0[11]],
          of_list,
          of_array,
          concat$0,
          fold,
          -304398144,
          -304398144,
          -304398144,
          -304398144,
          348729712,
          -637740141]),
     append = C[3],
     concat_map = C[8],
     concat_mapi = C[39],
     count = C[20],
     counti = C[32],
     exists = C[18],
     existsi = C[30],
     filter = C[6],
     filter_map = C[7],
     filter_mapi = C[38],
     filteri = C[37],
     find = C[22],
     find_map = C[23],
     find_mapi = C[34],
     findi = C[33],
     fold_result = C[16],
     fold_until = C[17],
     foldi = C[28],
     for_all = C[19],
     for_alli = C[31],
     init = C[35],
     is_empty = C[13],
     iter = C[14],
     iteri = C[29],
     length = C[12],
     map = C[5],
     mapi = C[36],
     max_elt = C[27],
     mem = C[11],
     min_elt = C[26],
     partition_map = C[10],
     partition_tf = C[9],
     sum = C[21],
     to_array = C[25],
     to_list = C[24];
    return [0,
            codec_name,
            is_valid,
            ,
            ,
            get,
            of_string_unchecked,
            ,
            ,
            t_sexp_grammar,
            hash_fold_t$0,
            hash$0,
            t_of_sexp$0,
            sexp_of_t$0,
            of_string$0,
            to_string$0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable,
            to_sequence,
            fold,
            sanitize,
            of_list,
            of_array,
            concat$0,
            split,
            ,
            append,
            concat_map,
            concat_mapi,
            count,
            counti,
            exists,
            existsi,
            filter,
            filter_map,
            filter_mapi,
            filteri,
            find,
            find_map,
            find_mapi,
            findi,
            fold_result,
            fold_until,
            foldi,
            for_all,
            for_alli,
            init,
            is_empty,
            iter,
            iteri,
            length,
            map,
            mapi,
            max_elt,
            mem,
            min_elt,
            partition_map,
            partition_tf,
            sum,
            to_array,
            to_list,
            length];
   }
   var
    byte_length = Base_Uchar0[16],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name,
         is_valid_utf_8,
         byte_length,
         get_utf_8_uchar,
         set]),
    byte_length$0 = Base_Uchar0[17],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$0,
         is_valid_utf_16le,
         byte_length$0,
         get_utf_16le_uchar,
         set$0]),
    byte_length$1 = Base_Uchar0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$1,
         is_valid_utf_16be,
         byte_length$1,
         get_utf_16be_uchar,
         set$1]);
   function Make_utf32(Format){
    function byte_length(param){return 4;}
    var
     codec_name = Format[1],
     module_name = Format[2],
     set = Format[4],
     get_decode_result = Format[3];
    function is_valid(t){
     var len = caml_ml_string_length(t);
     if(0 !== Base_Import[122].call(null, len, 4)) return 0;
     var byte_pos = 0;
     for(;;){
      if(byte_pos >= len) return 1;
      var
       result = caml_call2(Format[3], t, byte_pos),
       a = Base_Uchar0[18].call(null, result);
      if(! a) return a;
      var byte_pos$0 = Base_Import[91].call(null, byte_pos, 4);
      byte_pos = byte_pos$0;
     }
    }
    return Make_utf
            ([0,
              codec_name,
              module_name,
              is_valid,
              byte_length,
              get_decode_result,
              set]);
   }
   var
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf32([0, codec_name$2, module_name$2, get_utf_32le_uchar, set$2]),
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf32([0, codec_name$3, module_name$3, get_utf_32be_uchar, set$3]),
    include$1 = Base_Import[109],
    symbol$5 = include$1[1],
    symbol$6 = include$1[2],
    symbol$7 = include$1[3],
    symbol$8 = include$1[4],
    symbol$9 = include$1[5],
    symbol$10 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$1 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_String =
      [0,
       globalize,
       t_sexp_grammar,
       sub,
       unsafe_sub,
       subo,
       of_char_list,
       of_array,
       symbol_concat,
       map,
       filter,
       filter_map,
       partition_tf,
       partition_map,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$10,
       symbol$6,
       symbol$8,
       symbol$9,
       symbol$5,
       symbol$7,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       compare_local$0,
       invariant,
       max_length,
       mem,
       make,
       symbol_concat,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        compare_local,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       to_sequence,
       of_sequence,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        [0, equal, equal_local, sexp_of_t$1, representation]],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       concat_map,
       concat_mapi,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       concat_lines,
       equal$1,
       equal_local$0,
       of_char,
       of_char_list,
       pad_left,
       pad_right,
       edit_distance,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal],
       [0,
        Utf8[9],
        Utf8[10],
        Utf8[11],
        Utf8[12],
        Utf8[13],
        Utf8[14],
        Utf8[15],
        Utf8[16],
        Utf8[17],
        Utf8[18],
        Utf8[19],
        Utf8[20],
        Utf8[21],
        Utf8[22],
        Utf8[23],
        Utf8[24],
        Utf8[25],
        Utf8[26],
        Utf8[27],
        Utf8[28],
        Utf8[29],
        Utf8[30],
        Utf8[31],
        Utf8[32],
        Utf8[33],
        Utf8[37],
        Utf8[38],
        Utf8[42],
        Utf8[39],
        Utf8[67],
        Utf8[49],
        Utf8[50],
        Utf8[43],
        Utf8[73],
        Utf8[72],
        Utf8[70],
        Utf8[63],
        Utf8[64],
        Utf8[35],
        Utf8[57],
        Utf8[58],
        Utf8[47],
        Utf8[60],
        Utf8[45],
        Utf8[74],
        Utf8[53],
        Utf8[54],
        Utf8[76],
        Utf8[75],
        Utf8[71],
        Utf8[69],
        Utf8[59],
        Utf8[65],
        Utf8[48],
        Utf8[61],
        Utf8[46],
        Utf8[56],
        Utf8[55],
        Utf8[62],
        Utf8[68],
        Utf8[52],
        Utf8[51],
        Utf8[44],
        Utf8[34],
        Utf8[2],
        Utf8[36],
        Utf8[5],
        Utf8[6],
        Utf8[40],
        Utf8[1],
        Utf8[77],
        Utf8[66]],
       [0,
        Utf16le[9],
        Utf16le[10],
        Utf16le[11],
        Utf16le[12],
        Utf16le[13],
        Utf16le[14],
        Utf16le[15],
        Utf16le[16],
        Utf16le[17],
        Utf16le[18],
        Utf16le[19],
        Utf16le[20],
        Utf16le[21],
        Utf16le[22],
        Utf16le[23],
        Utf16le[24],
        Utf16le[25],
        Utf16le[26],
        Utf16le[27],
        Utf16le[28],
        Utf16le[29],
        Utf16le[30],
        Utf16le[31],
        Utf16le[32],
        Utf16le[33],
        Utf16le[37],
        Utf16le[38],
        Utf16le[42],
        Utf16le[39],
        Utf16le[67],
        Utf16le[49],
        Utf16le[50],
        Utf16le[43],
        Utf16le[73],
        Utf16le[72],
        Utf16le[70],
        Utf16le[63],
        Utf16le[64],
        Utf16le[35],
        Utf16le[57],
        Utf16le[58],
        Utf16le[47],
        Utf16le[60],
        Utf16le[45],
        Utf16le[74],
        Utf16le[53],
        Utf16le[54],
        Utf16le[76],
        Utf16le[75],
        Utf16le[71],
        Utf16le[69],
        Utf16le[59],
        Utf16le[65],
        Utf16le[48],
        Utf16le[61],
        Utf16le[46],
        Utf16le[56],
        Utf16le[55],
        Utf16le[62],
        Utf16le[68],
        Utf16le[52],
        Utf16le[51],
        Utf16le[44],
        Utf16le[34],
        Utf16le[2],
        Utf16le[36],
        Utf16le[5],
        Utf16le[6],
        Utf16le[40],
        Utf16le[1],
        Utf16le[77],
        Utf16le[66]],
       [0,
        Utf16be[9],
        Utf16be[10],
        Utf16be[11],
        Utf16be[12],
        Utf16be[13],
        Utf16be[14],
        Utf16be[15],
        Utf16be[16],
        Utf16be[17],
        Utf16be[18],
        Utf16be[19],
        Utf16be[20],
        Utf16be[21],
        Utf16be[22],
        Utf16be[23],
        Utf16be[24],
        Utf16be[25],
        Utf16be[26],
        Utf16be[27],
        Utf16be[28],
        Utf16be[29],
        Utf16be[30],
        Utf16be[31],
        Utf16be[32],
        Utf16be[33],
        Utf16be[37],
        Utf16be[38],
        Utf16be[42],
        Utf16be[39],
        Utf16be[67],
        Utf16be[49],
        Utf16be[50],
        Utf16be[43],
        Utf16be[73],
        Utf16be[72],
        Utf16be[70],
        Utf16be[63],
        Utf16be[64],
        Utf16be[35],
        Utf16be[57],
        Utf16be[58],
        Utf16be[47],
        Utf16be[60],
        Utf16be[45],
        Utf16be[74],
        Utf16be[53],
        Utf16be[54],
        Utf16be[76],
        Utf16be[75],
        Utf16be[71],
        Utf16be[69],
        Utf16be[59],
        Utf16be[65],
        Utf16be[48],
        Utf16be[61],
        Utf16be[46],
        Utf16be[56],
        Utf16be[55],
        Utf16be[62],
        Utf16be[68],
        Utf16be[52],
        Utf16be[51],
        Utf16be[44],
        Utf16be[34],
        Utf16be[2],
        Utf16be[36],
        Utf16be[5],
        Utf16be[6],
        Utf16be[40],
        Utf16be[1],
        Utf16be[77],
        Utf16be[66]],
       [0,
        Utf32le[9],
        Utf32le[10],
        Utf32le[11],
        Utf32le[12],
        Utf32le[13],
        Utf32le[14],
        Utf32le[15],
        Utf32le[16],
        Utf32le[17],
        Utf32le[18],
        Utf32le[19],
        Utf32le[20],
        Utf32le[21],
        Utf32le[22],
        Utf32le[23],
        Utf32le[24],
        Utf32le[25],
        Utf32le[26],
        Utf32le[27],
        Utf32le[28],
        Utf32le[29],
        Utf32le[30],
        Utf32le[31],
        Utf32le[32],
        Utf32le[33],
        Utf32le[37],
        Utf32le[38],
        Utf32le[42],
        Utf32le[39],
        Utf32le[67],
        Utf32le[49],
        Utf32le[50],
        Utf32le[43],
        Utf32le[73],
        Utf32le[72],
        Utf32le[70],
        Utf32le[63],
        Utf32le[64],
        Utf32le[35],
        Utf32le[57],
        Utf32le[58],
        Utf32le[47],
        Utf32le[60],
        Utf32le[45],
        Utf32le[74],
        Utf32le[53],
        Utf32le[54],
        Utf32le[76],
        Utf32le[75],
        Utf32le[71],
        Utf32le[69],
        Utf32le[59],
        Utf32le[65],
        Utf32le[48],
        Utf32le[61],
        Utf32le[46],
        Utf32le[56],
        Utf32le[55],
        Utf32le[62],
        Utf32le[68],
        Utf32le[52],
        Utf32le[51],
        Utf32le[44],
        Utf32le[34],
        Utf32le[2],
        Utf32le[36],
        Utf32le[5],
        Utf32le[6],
        Utf32le[40],
        Utf32le[1],
        Utf32le[77],
        Utf32le[66]],
       [0,
        Utf32be[9],
        Utf32be[10],
        Utf32be[11],
        Utf32be[12],
        Utf32be[13],
        Utf32be[14],
        Utf32be[15],
        Utf32be[16],
        Utf32be[17],
        Utf32be[18],
        Utf32be[19],
        Utf32be[20],
        Utf32be[21],
        Utf32be[22],
        Utf32be[23],
        Utf32be[24],
        Utf32be[25],
        Utf32be[26],
        Utf32be[27],
        Utf32be[28],
        Utf32be[29],
        Utf32be[30],
        Utf32be[31],
        Utf32be[32],
        Utf32be[33],
        Utf32be[37],
        Utf32be[38],
        Utf32be[42],
        Utf32be[39],
        Utf32be[67],
        Utf32be[49],
        Utf32be[50],
        Utf32be[43],
        Utf32be[73],
        Utf32be[72],
        Utf32be[70],
        Utf32be[63],
        Utf32be[64],
        Utf32be[35],
        Utf32be[57],
        Utf32be[58],
        Utf32be[47],
        Utf32be[60],
        Utf32be[45],
        Utf32be[74],
        Utf32be[53],
        Utf32be[54],
        Utf32be[76],
        Utf32be[75],
        Utf32be[71],
        Utf32be[69],
        Utf32be[59],
        Utf32be[65],
        Utf32be[48],
        Utf32be[61],
        Utf32be[46],
        Utf32be[56],
        Utf32be[55],
        Utf32be[62],
        Utf32be[68],
        Utf32be[52],
        Utf32be[51],
        Utf32be[44],
        Utf32be[34],
        Utf32be[2],
        Utf32be[36],
        Utf32be[5],
        Utf32be[6],
        Utf32be[40],
        Utf32be[1],
        Utf32be[77],
        Utf32be[66]]];
   runtime.caml_register_global(114, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_intf, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
//# shape: Base__Bytes:[F(1)*,F(1),F(1),N,N,N,N,N,N,F(2),F(2)*,F(2)*,F(2),F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,F(2)*,F(2)*,F(1),F(1),N,F(1)*,N,N,F(1)*,F(1),F(2),F(2),F(2),F(1),F(2),F(1),F(2),F(4),F(3),F(2),F(1),F(1),F(3),F(3),F(4),N,[F(3)],[F(3)],[F(3)],[F(3)],[F(3)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    globalize = Base_Import[288],
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    set_uchar_utf_8 = Base_Bytes0[8],
    set_uchar_utf_16le = Base_Bytes0[9],
    set_uchar_utf_16be = Base_Bytes0[10],
    set_uchar_utf_32le = Base_Bytes0[12],
    set_uchar_utf_32be = Base_Bytes0[13],
    create_local = Base_Bytes0[14],
    fill = Base_Bytes0[15],
    make = Base_Bytes0[16],
    map = Base_Bytes0[17],
    mapi = Base_Bytes0[18],
    to_string = Base_Bytes0[20],
    of_string = Base_Bytes0[21],
    a = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var b = to_string(t);
    return caml_call1(Stdlib_Format[139].call(null, fmt)(a), b);
   }
   function create$0(len){return create(len);}
   var
    To_bytes =
      Base_Blit[1].call
       (null, [0, caml_ml_bytes_length, create$0, runtime.caml_blit_bytes]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = Base_Comparator[7].call(null, [0, compare, sexp_of_t])[1],
    include = Base_Pretty_printer[3].call(null, [0, pp, module_name]),
    pp$0 = include[1],
    To_string = Base_Blit[3].call(null, [0], To_bytes);
   function create$1(len){return create(len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$0 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      Base_Blit[2].call
       (null, [0, length$0], [0, length, create$1, unsafe_blit$0]),
    b = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    c = [0, "src/bytes.ml", 130, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call2(Base_Printf[7].call(null, b), n, 0);
    var t = create(n), a = Base_Import[93].call(null, n, 1), c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = create(Base_List[45].call(null, l));
    Base_List[34].call
     (null, l, function(i, c){return runtime.caml_bytes_set(t, i, c);});
    return t;
   }
   function to_list(t){
    var
     i$1 = Base_Import[93].call(null, caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = Base_Import[93].call(null, i, 1);
     i = i$0;
     acc = acc$0;
    }
   }
   function to_array(t){
    return Base_Array0[12].call
            (null,
             caml_ml_bytes_length(t),
             function(i){return caml_bytes_unsafe_get(t, i);});
   }
   function map$0(t, f){return map(t, f);}
   function mapi$0(t, f){return mapi(t, f);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = Base_Import[91].call(null, pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = Base_Import[91].call(null, pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var a = Base_Import[93].call(null, caml_ml_bytes_length(s), 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      if(Base_Char[16].call(null, caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return stage(function(a){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return Base_Import[126].call(null, cst_tr_multi_replacement_is_th);
    var match = Base_Bytes_tr[1].call(null, target, replacement);
    if(! match) return stage(function(a){return 0;});
    var tr_map = match[1];
    return stage
            (function(s){
              var
               a = Base_Import[93].call(null, caml_ml_bytes_length(s), 1),
               b = 0;
              if(a >= 0){
               var i = b;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    Base_Char[32].call(null, caml_bytes_unsafe_get(s, i))));
                var c = i + 1 | 0;
                if(a === i) break;
                i = c;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var a = Base_Import[110][2].call(null, low, t);
    return a ? Base_Import[110][2].call(null, t, high) : a;
   }
   function clamp_unchecked(t, min, max){
    return Base_Import[110][1].call(null, t, min)
            ? min
            : Base_Import[110][2].call(null, t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(Base_Import[110][2].call(null, min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
   }
   function clamp(t, min, max){
    if(! Base_Import[110][5].call(null, min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function contains(pos, len, t, char){
    var
     match =
       Base_Ordered_collection_common[1].call
        (null, pos, len, 0, caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = Base_Import[91].call(null, pos$0, len$0),
     i = pos$0;
    for(;;){
     var a = i < last ? 1 : 0;
     if(a){
      var d = caml_bytes_get(t, i), b = Base_Char[16].call(null, d, char);
      if(! b){var i$0 = Base_Import[91].call(null, i, 1); i = i$0; continue;}
      var c = b;
     }
     else
      var c = a;
     return c;
    }
   }
   var
    Utf8 = [0, set_uchar_utf_8],
    Utf16le = [0, set_uchar_utf_16le],
    Utf16be = [0, set_uchar_utf_16be],
    Utf32le = [0, set_uchar_utf_32le],
    Utf32be = [0, set_uchar_utf_32be],
    include$0 = Base_Import[110],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    compare_local = include$0[10],
    equal = include$0[11],
    equal_local = include$0[12],
    max = include$0[13],
    min = include$0[14],
    Base_Bytes =
      [0,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       create_local,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
//# shape: Base__Hex_lexer:[F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        Stdlib_Lexing[20].call
         (null, ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         Stdlib_Lexing[16].call(null, lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         Stdlib_Lexing[16].call(null, lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_string_conversions
//# unitInfo: Requires: Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Stdlib__Lexing
//# shape: Base__Int_string_conversions:[F(1)*,F(1)*,F(1)*,N,F(3),F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_0b$1 = "0b",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sexp = global_data.Base__Sexp;
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? Base_Import[93].call(null, input_length, 1) : input_length,
     a = Base_Import[93].call(null, num_digits, 1),
     num_delimiters = Base_Import[95].call(null, a, chars_per_delimiter),
     output_length = Base_Import[91].call(null, input_length, num_delimiters),
     output = Base_Bytes[34].call(null, output_length),
     input_pos = [0, Base_Import[93].call(null, input_length, 1)],
     output_pos = [0, Base_Import[93].call(null, output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign) caml_bytes_set(output, 0, caml_string_get(input, 0));
      return runtime.caml_string_of_bytes(output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_bytes_set(output, output_pos[1], delimiter);
      output_pos[1]--;
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var b = caml_string_get(input, input_pos[1]);
     caml_bytes_set(output, output_pos[1], b);
     input_pos[1]--;
     output_pos[1]--;
     num_chars_until_delimiter[1]--;
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var
    sexp_of_int_style = Base_Sexp[20],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    a =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0 = "0",
    cst_0b = cst_0b$1,
    cst_0b$0 = cst_0b$1,
    Base_Int_string_conversions =
      [0,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         var delimiter = opt ? opt[1] : 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       function(I){
        var compare_local = I[2];
        function compare(a, b){return caml_call2(compare_local, a, b);}
        var hash_fold_t = I[3], func = I[4];
        function hash(x){return caml_call1(func, x);}
        var chars_per_delimiter = 4;
        function to_string(delimiter, t){
         if(delimiter)
          var
           delimiter$0 = delimiter[1],
           make_suffix =
             function(t){
              return insert_delimiter_every
                      (caml_call1(I[5], t), delimiter$0, chars_per_delimiter);
             };
         else
          var make_suffix = I[5];
         if(caml_call2(I[8], t, I[7])){
          var a = caml_call1(make_suffix, caml_call1(I[9], t));
          return Base_Import[112].call(null, cst_0x, a);
         }
         var b = caml_call1(make_suffix, t);
         return Base_Import[112].call(null, cst_0x$0, b);
        }
        function to_string$0(t){return to_string(0, t);}
        function to_string_hum(opt, t){
         var delimiter = opt ? opt[1] : 95;
         return to_string([0, delimiter], t);
        }
        function invalid(str){
         var b = I[10];
         return caml_call3(Base_Printf[6].call(null, a), b, str, 0);
        }
        function of_string_with_delimiter(str){
         var
          a =
            Base_String[10].call
             (null, str, function(c){return Base_Char[15].call(null, c, 95);});
         return caml_call1(I[6], a);
        }
        function of_string(str){
         var
          lex = Stdlib_Lexing[3].call(null, 0, str),
          result =
            Base_Option[47].call
             (null,
              function(param){return Base_Hex_lexer[1].call(null, lex);});
         if(lex[6] !== lex[3]) return invalid(str);
         if(! result) return invalid(str);
         var match = result[1];
         if(0 === match[0]){
          var body = match[1], a = of_string_with_delimiter(body);
          return caml_call1(I[9], a);
         }
         var body$0 = match[1];
         return of_string_with_delimiter(body$0);
        }
        var
         include = Base_Sexpable[5].call(null, [0, of_string, to_string$0]),
         t_sexp_grammar = include[1],
         t_of_sexp = include[2],
         sexp_of_t = include[3];
        return [0,
                [0,
                 t_of_sexp,
                 sexp_of_t,
                 t_sexp_grammar,
                 compare,
                 compare_local,
                 hash_fold_t,
                 hash,
                 of_string,
                 to_string$0,
                 to_string_hum]];
       },
       function(a){
        var
         func = a[6],
         hash_fold_t = a[5],
         compare_local = a[2],
         b = a[12],
         c = a[13],
         d = a[11],
         e = a[10],
         f = a[9],
         g = a[8],
         h = a[7],
         i = a[4];
        function compare(a, b){return caml_call2(compare_local, a, b);}
        function hash(x){return caml_call1(func, x);}
        function to_string_suffix(t){
         if(caml_call2(i, t, c))
          var bits = 0;
         else
          var a = caml_call1(h, t), bits = Base_Import[93].call(null, d, a);
         return 0 === bits
                 ? cst_0
                 : Base_String
                    [36].call
                   (null,
                    bits,
                    function(char_index){
                     var
                      a = Base_Import[93].call(null, bits, char_index),
                      bit_index = Base_Import[93].call(null, a, 1),
                      bit = caml_call2(f, caml_call2(g, t, bit_index), b),
                      c = caml_call1(e, bit),
                      d = Base_Char[32].call(null, 48),
                      h = Base_Import[91].call(null, d, c);
                     return Base_Char[35].call(null, h);
                    });
        }
        function to_string(t){
         var a = to_string_suffix(t);
         return Base_Import[112].call(null, cst_0b, a);
        }
        function to_string_hum(opt, t){
         var
          delimiter = opt ? opt[1] : 95,
          a = insert_delimiter_every(to_string_suffix(t), delimiter, 4);
         return Base_Import[112].call(null, cst_0b$0, a);
        }
        function sexp_of_t(t){return [0, to_string_hum(0, t)];}
        return [0,
                [0,
                 sexp_of_t,
                 compare,
                 compare_local,
                 hash_fold_t,
                 hash,
                 to_string,
                 to_string_hum]];
       },
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (16, Base_Int_string_conversions, "Base__Int_string_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Stdlib__Nativeint
//# shape: Base__Popcount:[F(1),F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure;
   function int64_popcount(x$1){
    var
     x$0 =
       runtime.caml_int64_sub
        (x$1, caml_int64_and(caml_int64_shift_right_unsigne(x$1, 1), m1)),
     x =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x, caml_int64_shift_right_unsigne(x, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var match = Stdlib_Nativeint[9], a = [0, "src/popcount.ml", 45, 9];
   if(32 === match)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(a){return runtime.Base_int_math_int_popcount(a);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
//# shape: Base__Sign:[N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    compare_local = Base_Sign0[4],
    all = Base_Sign0[7],
    Replace_polymorphic_compare = Base_Sign0[8],
    to_int = Base_Sign0[11],
    of_int = Base_Sign0[14],
    a =
      Base_Identifiable[1].call
       (null,
        [0,
         Base_Sign0[5],
         Base_Sign0[6],
         Base_Sign0[12],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[9],
         Base_Sign0[10],
         Base_Sign0[13]]),
    hash_fold_t = a[1],
    hash = a[2],
    t_of_sexp = a[3],
    sexp_of_t = a[4],
    of_string = a[5],
    to_string = a[6],
    between = a[19],
    clamp_exn = a[20],
    clamp = a[21],
    comparator = a[22],
    pp = a[23],
    hashable = a[24],
    cst_negative = "negative",
    cst_zero = "zero",
    cst_positive = "positive";
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      default: return cst_positive;
    }
   }
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var a = to_int(t), b = to_int(t$0);
    return of_int(Base_Import[88].call(null, b, a));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    equal_local = Replace_polymorphic_compare[11],
    max = Replace_polymorphic_compare[12],
    min = Replace_polymorphic_compare[13],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(9, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
//# shape: Base__Int:[F(1)*,N,F(1),F(1)*,F(1)*,F(1)*,N,F(1),F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,F(1)*,F(2)*,F(2)*,F(1)*,N,N,F(1),N,N,N,F(2),N,N,N,N,N,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1),F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1)*,F(1),F(1)*,F(1)*,N,N,N,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(2),F(1)*,F(1)*,N,F(2),F(2),F(2)*,N,F(1)*,F(1)*,F(1),F(1),F(1),F(1),F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    of_string_opt = Base_Int0[3],
    globalize = Base_Import[284],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare,
    b = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function of_string$0(s){
    try{var a = of_string(s); return a;}
    catch(exn){return caml_call2(Base_Printf[6].call(null, b), s, 0);}
   }
   var
    num_bits = Base_Int_conversions[30],
    float_lower_bound = Base_Float0[26].call(null, num_bits),
    float_upper_bound = Base_Float0[24].call(null, num_bits),
    c =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"];
   function to_float(a){return a;}
   function of_float_unchecked(a){return a | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var a = Base_Float0[29].call(null, f);
    return caml_call2(Base_Printf[7].call(null, c), a, 0);
   }
   var
    zero = 0,
    one = 1,
    comparator = Base_Comparator[7].call(null, [0, compare, sexp_of_t])[1],
    a = Base_Comparable[14].call(null, [0, compare, sexp_of_t, zero]),
    is_positive = a[1],
    is_non_negative = a[2],
    is_negative = a[3],
    is_non_positive = a[4],
    include = Base_Int_string_conversions[1].call(null, [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare_local = Base_Import[256];
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[206], func$0 = Base_Import[220];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    neg = Base_Import[113],
    d = [0, [4, 6, 0, 0, 0], cst_x],
    e = [0, [4, 6, 0, 0, 0], cst_x];
   function symbol(b, a){return b < a ? 1 : 0;}
   function to_string$0(i){
    return caml_call1(Base_Printf[2].call(null, d), i);
   }
   function of_string$1(s){
    return caml_call1
            (Stdlib_Scanf[5].call(null, s, e), function(a){return a;});
   }
   var
    include$0 =
      Base_Int_string_conversions[2].call
       (null,
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      Base_Pretty_printer[2].call(null, [0, module_name$0, to_string]),
    pp = include$1[1],
    f = [0, "src/int.ml", 111, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var a = low <= t ? 1 : 0, b = a ? t <= high ? 1 : 0 : a;
    return b;
   }
   function clamp_unchecked(t, min, max){
    var a = Base_Import[97][4].call(null, t, max);
    return Base_Import[97][3].call(null, min, a);
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function pred(i){return Base_Import[93].call(null, i, 1);}
   function succ(i){return Base_Import[91].call(null, i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[85][19],
    min_value = Base_Import[85][20],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[12],
    of_int64_exn = Base_Int_conversions[13],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[23],
    of_nativeint_exn = Base_Int_conversions[24],
    to_nativeint = Base_Int_conversions[5];
   function abs(x){return Base_Import[123].call(null, x);}
   function rem(a, b){return Base_Import[122].call(null, a, b);}
   function incr(a){a[1]++; return 0;}
   function decr(a){a[1]--; return 0;}
   function shift_right(a, b){return Base_Import[115].call(null, a, b);}
   function shift_right_logical(a, b){
    return Base_Import[120].call(null, a, b);
   }
   function shift_left(a, b){return Base_Import[119].call(null, a, b);}
   function bit_not(a){return Base_Import[117].call(null, a);}
   function bit_or(a, b){return Base_Import[118].call(null, a, b);}
   function bit_and(a, b){return Base_Import[116].call(null, a, b);}
   function bit_xor(a, b){return Base_Import[121].call(null, a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return pow(b, e);}
   var
    raise_s = Base_Error[32],
    g =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call1(Base_Printf[7].call(null, g), 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = Base_Import[93].call(null, x, 1),
     a = Base_Import[120].call(null, x$0, 1),
     x$1 = Base_Import[118].call(null, x$0, a),
     b = Base_Import[120].call(null, x$1, 2),
     x$2 = Base_Import[118].call(null, x$1, b),
     c = Base_Import[120].call(null, x$2, 4),
     x$3 = Base_Import[118].call(null, x$2, c),
     d = Base_Import[120].call(null, x$3, 8),
     x$4 = Base_Import[118].call(null, x$3, d),
     e = Base_Import[120].call(null, x$4, 16),
     x$5 = Base_Import[118].call(null, x$4, e),
     f = Base_Import[120].call(null, x$5, 32),
     x$6 = Base_Import[118].call(null, x$5, f);
    return Base_Import[91].call(null, x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     a = Base_Import[120].call(null, x, 1),
     x$0 = Base_Import[118].call(null, x, a),
     b = Base_Import[120].call(null, x$0, 2),
     x$1 = Base_Import[118].call(null, x$0, b),
     c = Base_Import[120].call(null, x$1, 4),
     x$2 = Base_Import[118].call(null, x$1, c),
     d = Base_Import[120].call(null, x$2, 8),
     x$3 = Base_Import[118].call(null, x$2, d),
     e = Base_Import[120].call(null, x$3, 16),
     x$4 = Base_Import[118].call(null, x$3, e),
     f = Base_Import[120].call(null, x$4, 32),
     x$5 = Base_Import[118].call(null, x$4, f),
     g = Base_Import[120].call(null, x$5, 1);
    return Base_Import[93].call(null, x$5, g);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var a = Base_Import[93].call(null, x, 1);
    return 0 === Base_Import[116].call(null, x, a) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var a = [0, [0, cst, Base_Import[139].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int_floor_log2_got_invalid, a));
    }
    var
     b = runtime.Base_int_math_int_clz(i),
     c = Base_Import[93].call(null, num_bits, 1);
    return Base_Import[93].call(null, c, b);
   }
   function ceil_log2(i){
    if(i <= 0){
     var a = [0, [0, cst$0, Base_Import[139].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int_ceil_log2_got_invalid_, a));
    }
    if(1 === i) return 0;
    var b = runtime.Base_int_math_int_clz(Base_Import[93].call(null, i, 1));
    return Base_Import[93].call(null, num_bits, b);
   }
   var
    sign = Base_Sign[30],
    popcount = Base_Popcount[1],
    compare_local$0 = Base_Import[256];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[270];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[206], func$1 = Base_Import[220];
   function hash$1(x){return caml_call1(func$1, x);}
   var land = Base_Import[116], lsr = Base_Import[120];
   function clz(a){return runtime.Base_int_math_int_clz(a);}
   var
    Binary =
      Base_Int_string_conversions[3].call
        (null,
         [0,
          compare$1,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int,
          num_bits,
          one,
          zero])
       [1],
    F =
      Base_Int_math[1].call
       (null,
        [0,
         of_float,
         to_float,
         of_string$0,
         to_string,
         function(b, a){return b + a | 0;},
         function(b, a){return b - a | 0;},
         runtime.caml_mul,
         caml_div,
         function(a){return - a | 0;},
         function(b, a){return a <= b ? 1 : 0;},
         function(b, a){return b <= a ? 1 : 0;},
         function(b, a){return b === a ? 1 : 0;},
         function(b, a){return a < b ? 1 : 0;},
         function(b, a){return b < a ? 1 : 0;},
         function(b, a){return b !== a ? 1 : 0;},
         abs,
         function(a){return - a | 0;},
         zero,
         of_int_exn,
         rem]),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8],
    h =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    i =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"];
   function symbol$1(x, y){
    if(y <= 0){
     var a = to_string(y), b = to_string(x);
     caml_call3(Base_Printf[7].call(null, h), b, a, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var a = to_string(y), b = to_string(x);
     caml_call3(Base_Printf[7].call(null, i), b, a, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return Base_Import[96].call(null, x, y);}
   var
    lnot = Base_Import[117],
    include$2 = Base_Import[97],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    Base_Int =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(b, a){return b === a ? 1 : 0;},
       caml_int_compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       caml_int_compare,
       function(b, a){return b === a ? 1 : 0;},
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       -1,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(a){return runtime.Base_int_math_int_clz(a);},
       function(a){return runtime.Base_int_math_int_ctz(a);},
       [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       1073741823,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       [0, [0, F[1], F[2], F[3]]]];
   runtime.caml_register_global(34, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
//# shape: Base__Sys:[F(1),N,N,N,N,N,N,[N],N,N,N,N,N,F(1),F(1),N,F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[20],
    getenv = Base_Sys0[21],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_local
//# unitInfo: Requires: Base__Sys, Sexplib0__Sexp_conv_error
//# shape: Base__Obj_local:[F(1)*,F(1)*,F(1),F(2)*,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Heap = "Heap",
    cst_Immediate = "Immediate",
    cst_Stack = "Stack",
    cst_heap = "heap",
    cst_immediate = "immediate",
    cst_stack = "stack",
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "obj_local.ml.stack_or_heap",
    Base_Sys = global_data.Base__Sys,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    a = [0, cst_Immediate],
    b = [0, cst_Stack],
    c = [0, cst_Heap];
   function size(t){return t.length - 1;}
   function stack_or_heap_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var a = sexp_004[1];
      b:
      if(a !== cst_Heap){
       c:
       if(a !== cst_Immediate){
        if(a !== cst_Stack){
         if(a === cst_heap) break b;
         if(a === cst_immediate) break c;
         if(a !== cst_stack) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var match = sexp_004[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_003, sexp_004);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_003, sexp_004);
     var b = match$0[1];
     b:
     if(b !== cst_Heap){
      c:
      if(b !== cst_Immediate){
       if(b !== cst_Stack){
        if(b === cst_heap) break b;
        if(b === cst_immediate) break c;
        if(b !== cst_stack) break a;
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_003, sexp_004);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_003, sexp_004);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_003, sexp_004);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_003, sexp_004);
   }
   function sexp_of_stack_or_heap(param){
    switch(param){case 0: return a;case 1: return b;default: return c;
    }
   }
   var compare_stack_or_heap = runtime.caml_int_compare;
   function stack_or_heap(repr){
    if(typeof repr === "number") return 0;
    var match = Base_Sys[8];
    return typeof match === "number"
            ? match ? 2 : runtime.caml_dummy_obj_is_stack(repr) ? 1 : 2
            : 2;
   }
   var
    Base_Obj_local =
      [0,
       size,
       sexp_of_stack_or_heap,
       stack_or_heap_of_sexp,
       compare_stack_or_heap,
       stack_or_heap];
   runtime.caml_register_global(18, Base_Obj_local, "Base__Obj_local");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
//# shape: Base__Obj_array:[F(1),N,N,N,N,F(1),F(2),F(1)*,F(1),F(1),N,F(1)*,F(2),F(2)*,F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(3),F(2),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    a = [0, "src/obj_array.ml", 12, 2],
    b = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    c = [0, ""];
   function invariant(t){
    var b = Stdlib_Obj[17];
    if(caml_obj_tag(t) !== b) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
   }
   function length(a){return a.length - 1;}
   function sexp_of_t(t){
    var
     a =
       [0,
        cst_Obj_array_t_of_length,
        [0, Base_Int0[1].call(null, t.length - 1), b]];
    return [0, Base_String0[20].call(null, c, a)];
   }
   var zero_obj = 0;
   function create_zero(len){return Base_Array0[4].call(null, len, zero_obj);}
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[i + 1];}
   function unsafe_get(t, i){return t[i + 1];}
   function unsafe_set_with_caml_modify(t, i, obj){t[i + 1] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[i + 1] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int){t[i + 1] = int; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var a = 1 - (old_obj === obj ? 1 : 0);
    return a ? unsafe_set_with_caml_modify(t, i, obj) : a;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[i + 1];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var a = 1 - (old_obj === obj ? 1 : 0);
    return a ? unsafe_set_with_caml_modify(t, i, obj) : a;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[i + 1];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    if(typeof x !== "number"){
     var b = Stdlib_Obj[16];
     if(caml_obj_tag(x) === b){
      var t = create_zero(len), a = Base_Import[93].call(null, len, 1), c = 0;
      if(a >= 0){
       var i = c;
       for(;;){
        unsafe_set_with_caml_modify(t, i, x);
        var d = i + 1 | 0;
        if(a === i) break;
        i = d;
       }
      }
      return t;
     }
    }
    return Base_Array0[4].call(null, len, x);
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int){
    var old_obj = t[i + 1];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int)
            : unsafe_set_with_caml_modify(t, i, int);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[i + 1], a = 1 - (typeof old_obj === "number" ? 1 : 0);
    return a ? unsafe_set_with_caml_modify(t, i, 0) : a;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var a = Base_Import[93].call(null, len, 1), c = 0;
     if(a >= 0){
      var i = c;
      for(;;){
       var i$0 = Base_Import[91].call(null, src_pos, i), f = src[i$0 + 1];
       unsafe_set(dst, Base_Import[91].call(null, dst_pos, i), f);
       var d = i + 1 | 0;
       if(a === i) break;
       i = d;
      }
     }
     return 0;
    }
    var b = Base_Import[93].call(null, len, 1);
    if(b >= 0){
     var i$1 = b;
     for(;;){
      var i$2 = Base_Import[91].call(null, src_pos, i$1), g = src[i$2 + 1];
      unsafe_set(dst, Base_Import[91].call(null, dst_pos, i$1), g);
      var e = i$1 - 1 | 0;
      if(0 === i$1) break;
      i$1 = e;
     }
    }
    return 0;
   }
   var
    include = Base_Blit[1].call(null, [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    sub = Base_Array0[15],
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer,
       sub];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Base__Array, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__Int, Base__List, Base__Obj_array, Base__Option, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
//# shape: Base__Uniform_array:[N,N,F(1)*,F(3),F(3),F(1),N,F(2),F(1),F(2),F(1)*,F(2),F(2)*,F(2)*,F(3),F(3),F(3),F(3),F(3),F(3),F(2),F(2),F(2),F(2),F(3),F(3),F(1)*,F(1),F(1),F(1),F(1),F(1),N,N,N,N,N,F(1),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(4),F(2),F(2),N,N,N,F(1)*,F(1)*,F(3),F(3),F(3),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Int = global_data.Base__Int,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    empty = Base_Obj_array[11];
   function unsafe_create_uninitialized(len){
    return Base_Obj_array[8].call(null, len);
   }
   function create_obj_array(len){return Base_Obj_array[8].call(null, len);}
   function create(len, x){return Base_Obj_array[7].call(null, len, x);}
   function singleton(x){return Base_Obj_array[10].call(null, x);}
   function swap(t, i, j){return Base_Obj_array[17].call(null, t, i, j);}
   function get(arr, i){return Base_Obj_array[13].call(null, arr, i);}
   function set(arr, i, x){return Base_Obj_array[15].call(null, arr, i, x);}
   function unsafe_get_local(arr, i){
    return Base_Obj_array[14].call(null, arr, i);
   }
   function unsafe_get(arr, i){return unsafe_get_local(arr, i);}
   function unsafe_set(arr, i, x){
    return Base_Obj_array[16].call(null, arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return Base_Obj_array[21].call(null, arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return Base_Obj_array[20].call(null, arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return Base_Obj_array[19].call(null, arr, i, x);
   }
   function unsafe_to_array_inplace_promis(arr){return arr;}
   var
    length = Base_Obj_array[12],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[9];
   function unsafe_set_omit_phys_equal_che(t, i, x){return Base_Obj_array[22].call(null, t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return Base_Obj_array[23].call(null, t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return Base_Obj_array[18].call(null, t, i, x);
   }
   var
    unsafe_clear_if_pointer = Base_Obj_array[24],
    sub = Base_Obj_array[25],
    a = [0, cst_src_uniform_array_ml, 80, 2],
    cst_Uniform_array_init = "Uniform_array.init",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    dummy = 0;
   function invariant(t){
    var b = Stdlib_Obj[17];
    if(runtime.caml_obj_tag(t) !== b) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
   }
   function init(l, f){
    if(0 > l) return Base_Import[126].call(null, cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     a = Base_Import[93].call(null, l, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(a){return arr[a + 1];});
   }
   function map(arr, f){
    return init
            (length(arr),
             function(i){return caml_call1(f, unsafe_get_local(arr, i));});
   }
   function mapi(arr, f){
    return init
            (length(arr),
             function(i){return caml_call2(f, i, unsafe_get_local(arr, i));});
   }
   function iter(arr, f){
    var c = length(arr), a = Base_Import[93].call(null, c, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call1(f, unsafe_get_local(arr, i));
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return 0;
   }
   function iteri(arr, f){
    var c = length(arr), a = Base_Import[93].call(null, c, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i, unsafe_get_local(arr, i));
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return 0;
   }
   function foldi(arr, init, f){
    var
     acc = [0, init],
     c = length(arr),
     a = Base_Import[93].call(null, c, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var e = unsafe_get_local(arr, i);
      acc[1] = caml_call3(f, i, acc[1], e);
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return acc[1];
   }
   function fold(arr, init, f){
    var
     r = [0, init],
     c = length(arr),
     a = Base_Import[93].call(null, c, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var e = unsafe_get_local(arr, i);
      r[1] = caml_call2(f, r[1], e);
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return r[1];
   }
   function to_list(t){
    var a = length(t);
    return Base_List[40].call(null, a, function(a){return get(t, a);});
   }
   function of_list(l){
    var
     len = Base_List[45].call(null, l),
     res = unsafe_create_uninitialized(len);
    Base_List[34].call(null, l, function(i, x){return set(res, i, x);});
    return res;
   }
   function of_list_rev(l){
    var
     len = Base_List[45].call(null, l),
     res = unsafe_create_uninitialized(len);
    Base_List[34].call
     (null,
      l,
      function(i, x){
       var a = Base_Import[93].call(null, len, i);
       return set(res, Base_Import[93].call(null, a, 1), x);
      });
    return res;
   }
   function to_array(arr){
    var a = length(arr);
    return Base_Array[41].call
            (null, a, function(i){return unsafe_get_local(arr, i);});
   }
   function exists(arr, f){
    var
     a = length(arr),
     i = [0, Base_Import[93].call(null, a, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      var i$0 = i[1];
      if(caml_call1(f, unsafe_get_local(arr, i$0))){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function existsi(arr, f){
    var
     a = length(arr),
     i = [0, Base_Import[93].call(null, a, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      var i$0 = i[1], b = unsafe_get_local(arr, i$0);
      if(caml_call2(f, i[1], b)){result[1] = 1; continue;}
      i[1]--;
      continue;
     }
     return result[1];
    }
   }
   function for_all(arr, f){
    var
     a = length(arr),
     i = [0, Base_Import[93].call(null, a, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      var i$0 = i[1];
      if(caml_call1(f, unsafe_get_local(arr, i$0))){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(arr, f){
    var
     length$0 = length(arr),
     i = [0, Base_Import[93].call(null, length$0, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      var i$0 = i[1], a = unsafe_get_local(arr, i$0);
      if(caml_call2(f, i[1], a)){i[1]--; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function filter_mapi(arr, f){
    var
     r = [0, empty],
     k = [0, 0],
     d = length(arr),
     b = Base_Import[93].call(null, d, 1),
     c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      var match = caml_call2(f, i, unsafe_get_local(arr, i));
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = create(length(arr), a);
       unsafe_set(r[1], k[1], a);
       k[1]++;
      }
      var g = i + 1 | 0;
      if(b === i) break;
      i = g;
     }
    }
    var e = length(arr);
    return k[1] === e ? r[1] : 0 < k[1] ? sub(r[1], 0, k[1]) : empty;
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function fold2_exn(arr$0, arr, init, f){
    var len = length(arr$0);
    if(length(arr) !== len) Base_Import[126].call(null, cst_Array_fold2_exn);
    var acc = [0, init], a = Base_Import[93].call(null, len, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var e = unsafe_get_local(arr, i), d = unsafe_get_local(arr$0, i);
      acc[1] = caml_call3(f, acc[1], d, e);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return acc[1];
   }
   function map2_exn(arr$0, arr, f){
    var len = length(arr$0);
    if(length(arr) !== len) Base_Import[126].call(null, cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var a = unsafe_get_local(arr, i);
              return caml_call2(f, unsafe_get_local(arr$0, i), a);
             });
   }
   function concat(ts){
    var
     total_len =
       Base_List[26].call
        (null,
         [0, Base_Int[79], function(b, a){return b + a | 0;}],
         ts,
         function(t){return length(t);}),
     res = unsafe_create_uninitialized(total_len);
    Base_List[20].call
     (null,
      ts,
      0,
      function(so_far, t){
       var len = length(t), a = Base_Import[93].call(null, len, 1), b = 0;
       if(a >= 0){
        var i = b;
        for(;;){
         var c = get(t, i);
         set(res, Base_Import[91].call(null, so_far, i), c);
         var d = i + 1 | 0;
         if(a === i) break;
         i = d;
        }
       }
       return Base_Import[91].call(null, so_far, len);
      });
    return res;
   }
   function concat_mapi(t, f){
    var a = to_list(t);
    return concat(Base_List[41].call(null, a, f));
   }
   function concat_map(t, f){
    var a = to_list(t);
    return concat(Base_List[53].call(null, a, f));
   }
   function partition_map(arr, f){
    var
     right = [0, empty],
     left = [0, empty],
     right_idx = [0, 0],
     left_idx = [0, 0];
    function append(data, idx, value){
     if(0 === idx[1]) data[1] = create(length(arr), value);
     unsafe_set(data[1], idx[1], value);
     idx[1]++;
    }
    var d = length(arr), b = Base_Import[93].call(null, d, 1), c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      var match = caml_call1(f, unsafe_get_local(arr, i));
      if(0 === match[0]){
       var a = match[1];
       append(left, left_idx, a);
      }
      else{var a$0 = match[1]; append(right, right_idx, a$0);}
      var g = i + 1 | 0;
      if(b === i) break;
      i = g;
     }
    }
    function trim(data, idx){
     var a = length(arr);
     return idx[1] === a
             ? data[1]
             : 0 < idx[1] ? sub(data[1], 0, idx[1]) : empty;
    }
    var e = trim(right, right_idx);
    return [0, trim(left, left_idx), e];
   }
   function find_map(arr, f){
    var length$0 = length(arr);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(Base_Option[52].call(null, value_found[1]) && i[1] < length$0){
      var i$0 = i[1], value = unsafe_get_local(arr, i$0);
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find_mapi(arr, f){
    var length$0 = length(arr);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(Base_Option[52].call(null, value_found[1]) && i[1] < length$0){
      var i$0 = i[1], value = unsafe_get_local(arr, i$0);
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find(arr, f){
    var length$0 = length(arr);
    function b(param){var x = param[2]; return x;}
    if(0 === length$0)
     var a = 0;
    else{
     var
      i = [0, 0],
      found = [0, 0],
      value_found = [0, unsafe_get_local(arr, 0)];
     for(;;){
      if(! found[1] && i[1] < length$0){
       var i$0 = i[1], value = unsafe_get_local(arr, i$0);
       if(caml_call1(f, value)){
        value_found[1] = value;
        found[1] = 1;
        continue;
       }
       i[1]++;
       continue;
      }
      if(found[1]){var a = [0, [0, i[1], value_found[1]]]; break;}
      var a = 0;
      break;
     }
    }
    return caml_call2(Base_Option[24], a, b);
   }
   function findi(arr, f){
    var len = length(arr), i = 0;
    for(;;){
     if(len <= i) return 0;
     var x = unsafe_get_local(arr, i);
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
    }
   }
   function t_sexp_grammar(grammar){
    var a = Base_Array[6].call(null, grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   var
    include$1 =
      Base_Sexpable[2].call
       (null, [0, Base_Array[4], Base_Array[5]], [0, to_array, of_array]),
    t_of_sexp = include$1[1],
    sexp_of_t = include$1[2],
    b = [0, cst_src_uniform_array_ml, 347, 6];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < length(t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   var
    include = Base_Blit[4].call(null, [0, create_like, length, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub$0 = include[4],
    subo = include[5];
   function min_elt(t, compare){
    return Base_Container[3].call(null, fold, t, compare);
   }
   function max_elt(t, compare){
    return Base_Container[4].call(null, fold, t, compare);
   }
   function compare_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = length(a),
     len_b = length(b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get_local(a, i),
      r = unsafe_get_local(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = Base_Import[91].call(null, i, 1);
     i = i$0;
    }
   }
   function compare(compare_elt, a, b){
    return compare_local(compare_elt, a, b);
   }
   var
    Sort = caml_call1(Base_Array[109][2], [0, unsafe_get, unsafe_set, length]),
    sort = Sort[1],
    include$0 = Base_Binary_searchable[2].call(null, [0, unsafe_get, length]),
    binary_search = include$0[1],
    binary_search_segmented = include$0[2],
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       unsafe_get_local,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       fold,
       foldi,
       unsafe_to_array_inplace_promis,
       of_array,
       to_array,
       of_list,
       of_list_rev,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       copy,
       exists,
       existsi,
       for_all,
       for_alli,
       concat,
       concat_map,
       concat_mapi,
       partition_map,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       find,
       findi,
       find_map,
       find_mapi,
       map2_exn,
       fold2_exn,
       min_elt,
       max_elt,
       sort,
       binary_search,
       binary_search_segmented,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(18, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar_intf
//# shape: Base__Uchar_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Uchar_intf = [0];
   runtime.caml_register_global(0, Base_Uchar_intf, "Base__Uchar_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Bytes0, Base__Comparable, Base__Error, Base__Hash, Base__Hashable, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String0, Base__Uchar0, Base__Uchar_intf, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
//# shape: Base__Uchar:[F(2),F(1),F(1),F(1),N,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,N,N,N,N,F(2)*,F(2)*,N,F(1)*,F(1),F(1),F(1),F(1),F(1)*,F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),N,N,N,N,N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    codec_name = "UTF-8",
    module_name$0 = "Base.Uchar.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$1 = "Base.Uchar.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$2 = "Base.Uchar.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$3 = "Base.Uchar.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$4 = "Base.Uchar.Utf32be",
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    Base_String0 = global_data.Base__String0,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    byte_order_mark = Base_Uchar0[14],
    replacement_char = Base_Uchar0[15],
    utf_8_byte_length = Base_Uchar0[16],
    utf_16_byte_length = Base_Uchar0[17],
    a = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    b = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed";
   function hash_fold_t(state, t){
    var a = to_int(t);
    return Base_Hash[3].call(null, state, a);
   }
   function hash(t){return Base_Hash[14].call(null, 0, hash_fold_t, t);}
   function to_string_internal(t){
    var b = to_int(t);
    return caml_call1(Base_Printf[2].call(null, a), b);
   }
   function sexp_of_t(t){return [0, to_string_internal(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return Base_Import[156].call(null, cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      a =
        caml_call1
         (Stdlib_Scanf[5].call(null, s, b),
          function(i){return Base_Uchar0[7].call(null, i);});
     return a;
    }
    catch(exn){
     return Base_Import[156].call(null, cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = Sexplib0_Sexp_grammar[1].call(null, Base_Import[182]),
    include =
      Base_Pretty_printer[2].call(null, [0, module_name, to_string_internal]),
    pp = include[1],
    include$0 = Base_Comparable[11].call(null, [0, compare, sexp_of_t]),
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16],
    c = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    d = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    e =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    f =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"];
   function invariant(param){return 0;}
   function succ_exn(c$0){
    try{var a = Base_Uchar0[1].call(null, c$0); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call2(failwithf(c), msg, 0);
    }
   }
   function succ(c){
    try{var a = [0, Base_Uchar0[1].call(null, c)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function pred_exn(c){
    try{var a = Base_Uchar0[2].call(null, c); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call2(failwithf(d), msg, 0);
    }
   }
   function pred(c){
    try{var a = [0, Base_Uchar0[2].call(null, c)]; return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function of_scalar(i){return is_valid(i) ? [0, unsafe_of_int(i)] : 0;}
   function of_scalar_exn(i){
    return is_valid(i) ? unsafe_of_int(i) : caml_call2(failwithf(e), i, 0);
   }
   function to_scalar(t){return Base_Uchar0[8].call(null, t);}
   function to_char(c){return is_char(c) ? [0, unsafe_to_char(c)] : 0;}
   function to_char_exn(c){
    if(is_char(c)) return unsafe_to_char(c);
    var a = to_int(c);
    return caml_call2(failwithf(f), a, 0);
   }
   var compare$0 = runtime.caml_int_compare;
   function equal(b, a){return b === a ? 1 : 0;}
   function hash_fold_t$0(state, t){
    var a = Base_Hashable[6].call(null, t);
    return caml_call2(Base_Import[206], state, a);
   }
   var
    hash$0 = Base_Hashable[6],
    is_valid$0 = Base_Uchar0[18],
    bytes_consumed = Base_Uchar0[20],
    uchar_or_replacement_char = Base_Uchar0[19],
    g =
      [0,
       "Uchar.Decode_result.uchar_exn was called on an invalid decode result"],
    h = [0, "src/uchar.ml", 134, 4],
    cst_of_string_expected_a_singl =
      ".of_string: expected a single Unicode character",
    cst_string = "string";
   function sexp_of_t$0(t){return sexp_of_t(uchar_or_replacement_char(t));}
   function uchar(t){
    return is_valid$0(t) ? [0, uchar_or_replacement_char(t)] : 0;
   }
   function uchar_exn(t){
    return is_valid$0(t)
            ? uchar_or_replacement_char(t)
            : Base_Error[32].call(null, g);
   }
   function Make_utf(Format){
    var codec_name = Format[1], byte_length = Format[3];
    function to_string(t){
     var
      len = caml_call1(byte_length, t),
      bytes = Base_Bytes0[7].call(null, len),
      pos = caml_call3(Format[5], bytes, 0, t);
     if(pos === len) return runtime.caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
    }
    var
     of_string_message =
       Base_Import[112].call(null, Format[2], cst_of_string_expected_a_singl);
    function of_string(string){
     var
      decode = caml_call2(Format[4], string, 0),
      string_len = runtime.caml_ml_string_length(string),
      decode_len = bytes_consumed(decode);
     if(string_len === decode_len && is_valid$0(decode))
      return uchar_or_replacement_char(decode);
     var
      a =
        Base_Sexp[10].call
         (null, of_string_message, [0, [0, cst_string, [0, string]], 0]);
     return Base_Error[32].call(null, a);
    }
    return [0, of_string, to_string, byte_length, codec_name];
   }
   var
    get_decode_result = Base_String0[15],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name$0,
         utf_8_byte_length,
         get_decode_result,
         set]),
    get_decode_result$0 = Base_String0[16],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$1,
         utf_16_byte_length,
         get_decode_result$0,
         set$0]),
    get_decode_result$1 = Base_String0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$2,
         utf_16_byte_length,
         get_decode_result$1,
         set$1]);
   function byte_length(param){return 4;}
   var
    get_decode_result$2 = Base_String0[18],
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf
       ([0,
         codec_name$2,
         module_name$3,
         byte_length,
         get_decode_result$2,
         set$2]);
   function byte_length$0(param){return 4;}
   var
    get_decode_result$3 = Base_String0[19],
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf
       ([0,
         codec_name$3,
         module_name$4,
         byte_length$0,
         get_decode_result$3,
         set$3]),
    include$1 = Base_Import[107],
    symbol = include$1[1],
    symbol$0 = include$1[2],
    symbol$1 = include$1[3],
    symbol$2 = include$1[4],
    symbol$3 = include$1[5],
    symbol$4 = include$1[6],
    ascending = include$1[7],
    descending = include$1[8],
    compare$1 = include$1[9],
    equal$0 = include$1[10],
    compare_local = include$1[11],
    equal_local = include$1[12],
    max = include$1[13],
    min = include$1[14],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal$0,
       compare$1,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf_8_byte_length,
       utf_16_byte_length,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       [0,
        compare$0,
        equal,
        hash_fold_t$0,
        hash$0,
        sexp_of_t$0,
        is_valid$0,
        bytes_consumed,
        uchar,
        uchar_exn,
        uchar_or_replacement_char],
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(38, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal_intf
//# shape: Base__Type_equal_intf:[F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function Type_equal_defns(Type_equal){
    function Composition_preserves_injectiv(M1, M2){
     function strip(e){
      var a = caml_call1(M2[1], e);
      return caml_call1(M1[1], a);
     }
     return [0, strip];
    }
    return [0, Composition_preserves_injectiv];
   }
   function Type_equal_id_defns(Id){return [0];}
   var Base_Type_equal_intf = [0, Type_equal_defns, Type_equal_id_defns];
   runtime.caml_register_global
    (0, Base_Type_equal_intf, "Base__Type_equal_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Comparable, Base__Error, Base__Hash, Base__Import, Base__Sexp, Base__Type_equal_intf, Stdlib__Obj
//# shape: Base__Type_equal:[F(3)*,N,N,F(1)*,F(2)*,F(2)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_T = "T",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Hash = global_data.Base__Hash,
    Base_Type_equal_intf = global_data.Base__Type_equal_intf,
    Base_Comparable = global_data.Base__Comparable,
    a = [0, cst_T];
   function sexp_of_t(of_a_001, of_b_002, param){return a;}
   var
    include = Base_Type_equal_intf[1].call(null, [0]),
    Composition_preserves_injectiv = include[1],
    b = [0, 0, 0];
   function sym(param){return 0;}
   function trans(a, param){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(a, param){return 0;} return [0, lift];}
   function Lift3(X){function lift(b, a, param){return 0;} return [0, lift];}
   function detuple2(param){return b;}
   function tuple2(a, param){return 0;}
   function compare(a_005, b_006){
    if(a_005 === b_006) return 0;
    var
     b_010 = b_006[2],
     b_008 = b_006[1],
     a_009 = a_005[2],
     a_007 = a_005[1],
     n = caml_call2(Base_Import[228], a_007, b_008);
    return 0 === n ? caml_call3(Base_Import[236], compare, a_009, b_010) : n;
   }
   var letrec_function_context = [];
   function hash_fold_t(hsv, arg){
    var
     a1 = arg[2],
     a0 = arg[1],
     hsv$0 = caml_call2(Base_Import[206], hsv, a0);
    return caml_call3(Base_Import[212], hash_fold_t, hsv$0, a1);
   }
   function hash(x){return caml_call1(letrec_function_context[1], x);}
   function func(arg){
    var hsv = Base_Hash[11].call(null, 0, 0), a = hash_fold_t(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   runtime.caml_update_dummy(letrec_function_context, [0, func]);
   var c = [0, cst_T];
   function sexp_of_t$0(param){
    var
     arg1_014 = param[2],
     arg0_013 = param[1],
     res0_015 = Base_Import[139].call(null, arg0_013),
     res1_016 = Base_Import[149].call(null, sexp_of_t$0, arg1_014);
    return [1, [0, c, [0, res0_015, [0, res1_016, 0]]]];
   }
   var
    include$0 = Base_Comparable[11].call(null, [0, compare, sexp_of_t$0]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal = include$0[7],
    compare$0 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16],
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids",
    cst_Base_Type_equal_Id_Create0 = "Base__Type_equal.Id.Create0(T).T0",
    d = [0, 0],
    cst_Base_Type_equal_Id_Create1 = "Base__Type_equal.Id.Create1(T).T1",
    e = [0, 0],
    cst_Base_Type_equal_Id_Create2 = "Base__Type_equal.Id.Create2(T).T2",
    f = [0, 0],
    cst_Base_Type_equal_Id_Create3 = "Base__Type_equal.Id.Create3(T).T3",
    g = [0, 0],
    dummy = 0;
   function create(key, args){
    var
     a = Stdlib_Obj[22][1].call(null, key),
     tag = Stdlib_Obj[22][3].call(null, a);
    return [0, tag, args];
   }
   function uid(A){return A[2];}
   function name(A){return A[3];}
   function sexp_of_t$1(param, A){return A[4];}
   function to_sexp(A){return A[1];}
   function hash$0(t){return hash(t[2]);}
   function hash_fold_t$0(state, t){return hash_fold_t(state, t[2]);}
   function same_witness(A, B){return caml_call1(A[6], B[5]);}
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var equal = match[1]; return equal;}
    var
     a =
       [0,
        [0,
         cst,
         Base_Import[147].call
          (null,
           function(A){return A[4];},
           function(A){return A[4];},
           [0, t1, t2])],
        0],
     b = Base_Sexp[10].call(null, cst_Type_equal_Id_same_witness, a);
    return Base_Error[32].call(null, b);
   }
   function same(t1, t2){return same_witness(t1, t2) ? 1 : 0;}
   function Create0(T){
    var
     T0 = [248, cst_Base_Type_equal_Id_Create0, caml_fresh_oo_id(0)],
     id_name = T[2],
     id_sexp = [0, id_name],
     sexp_of_t = T[1],
     uid = create(T0, 0);
    function type_equal(otherkey){return otherkey === T0 ? d : 0;}
    var type_equal_id = [0, sexp_of_t, uid, id_name, id_sexp, T0, type_equal];
    return [0, , type_equal_id];
   }
   function create$0(name, sexp_of_t){
    return Create0([0, sexp_of_t, name])[2];
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       Composition_preserves_injectiv,
       0,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       [0,
        sexp_of_t$1,
        [0,
         hash_fold_t,
         hash,
         sexp_of_t$0,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         equal,
         compare$0,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator],
        uid,
        create$0,
        hash$0,
        name,
        to_sexp,
        hash_fold_t$0,
        same,
        same_witness,
        same_witness_exn,
        function(a){return [0, Create0(a)[2]];},
        function(T){
         var T1 = [248, cst_Base_Type_equal_Id_Create1, caml_fresh_oo_id(0)];
         function type_equal_id(A){
          var id_name = T[2], id_sexp = [1, [0, [0, id_name], [0, A[4], 0]]];
          function sexp_of_t(t){return caml_call2(T[1], A[1], t);}
          var type_key = [0, T1, A[5]], uid = create(type_key, [0, A[2], 0]);
          function type_equal(otherkey){
           var tag = otherkey[1];
           if(tag !== T1) return 0;
           var akey = otherkey[2];
           return caml_call1(A[6], akey) ? e : 0;
          }
          return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
         }
         return [0, type_equal_id];
        },
        function(T){
         var T2 = [248, cst_Base_Type_equal_Id_Create2, caml_fresh_oo_id(0)];
         function type_equal_id(A, B){
          var
           id_name = T[2],
           id_sexp = [1, [0, [0, id_name], [0, A[4], [0, B[4], 0]]]];
          function sexp_of_t(t){return caml_call3(T[1], A[1], B[1], t);}
          var
           type_key = [0, T2, A[5], B[5]],
           uid = create(type_key, [0, A[2], [0, B[2], 0]]);
          function type_equal(otherkey){
           var tag = otherkey[1];
           if(tag !== T2) return 0;
           var
            bkey = otherkey[3],
            akey = otherkey[2],
            match = caml_call1(A[6], akey),
            match$0 = caml_call1(B[6], bkey);
           if(match && match$0) return f;
           return 0;
          }
          return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
         }
         return [0, type_equal_id];
        },
        function(T){
         var T3 = [248, cst_Base_Type_equal_Id_Create3, caml_fresh_oo_id(0)];
         function type_equal_id(A, B, C){
          var
           id_name = T[2],
           id_sexp =
             [1, [0, [0, id_name], [0, A[4], [0, B[4], [0, C[4], 0]]]]];
          function sexp_of_t(t){return caml_call4(T[1], A[1], B[1], C[1], t);}
          var
           type_key = [0, T3, A[5], B[5], C[5]],
           uid = create(type_key, [0, A[2], [0, B[2], [0, C[2], 0]]]);
          function type_equal(otherkey){
           var tag = otherkey[1];
           if(tag !== T3) return 0;
           var
            ckey = otherkey[4],
            bkey = otherkey[3],
            akey = otherkey[2],
            match = caml_call1(A[6], akey),
            match$0 = caml_call1(B[6], bkey),
            match$1 = caml_call1(C[6], ckey);
           if(match && match$0 && match$1) return g;
           return 0;
          }
          return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
         }
         return [0, type_equal_id];
        }]];
   runtime.caml_register_global(20, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
//# shape: Base__Stack_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
//# shape: Base__Option_array:[F(2),F(2),F(1)*,N,F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(2),F(2),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2)*,F(2),F(2)*,F(2)*,F(3),F(3),F(2),F(3),F(1),F(2),F(2),F(3),F(3),F(2),N,N,N,N,N,F(1),N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[14], 1),
    none = 24791911,
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]";
   function is_none(x){return x === 24791911 ? 1 : 0;}
   function is_some(x){return 1 - (x === 24791911 ? 1 : 0);}
   function some(x){return x === 24791911 ? none_substitute : x;}
   function value_unsafe(x){return x === none_substitute ? none : x;}
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : Base_Import[124].call(null, cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include$1 =
      Base_Sexpable[2].call
       (null,
        [0, Base_Option[9], Base_Option[10]],
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include$1[1],
    sexp_of_t = include$1[2];
   function t_of_sexp$0(of_a_001, x_003){
    var a = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], a, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var a = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], a, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     a = Base_Option[5].call(null, a_sexp_grammar),
     b = Sexplib0_Sexp_grammar[1].call(null, a);
    return Base_Uniform_array[3].call(null, b);
   }
   var empty = Base_Uniform_array[7];
   function create(len){return Base_Uniform_array[8].call(null, len, none);}
   function init(n, f){
    return Base_Uniform_array[10].call
            (null, n, function(i){return of_sexpable(caml_call1(f, i));});
   }
   function init_some(n, f){
    return Base_Uniform_array[10].call
            (null, n, function(i){return some(caml_call1(f, i));});
   }
   var a = Base_Uniform_array[11];
   function get(t, i){
    return to_sexpable(Base_Uniform_array[12].call(null, t, i));
   }
   function get_local(t, i){
    var x = Base_Uniform_array[12].call(null, t, i);
    return is_some(x) ? [0, value_unsafe(x)] : 0;
   }
   function get_some_exn(t, i){
    return value_exn(Base_Uniform_array[12].call(null, t, i));
   }
   function is_none$0(t, i){
    var x = Base_Uniform_array[12].call(null, t, i);
    return x === 24791911 ? 1 : 0;
   }
   function is_some$0(t, i){
    return is_some(Base_Uniform_array[12].call(null, t, i));
   }
   function set(t, i, x){
    var a = of_sexpable(x);
    return Base_Uniform_array[15].call(null, t, i, a);
   }
   function set_some(t, i, x){
    var a = some(x);
    return Base_Uniform_array[15].call(null, t, i, a);
   }
   function set_none(t, i){
    return Base_Uniform_array[15].call(null, t, i, none);
   }
   function swap(t, i, j){return Base_Uniform_array[17].call(null, t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(Base_Uniform_array[13].call(null, t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(Base_Uniform_array[13].call(null, t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(Base_Uniform_array[13].call(null, t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(Base_Uniform_array[13].call(null, t, i));
   }
   function unsafe_set(t, i, x){
    var a = of_sexpable(x);
    return Base_Uniform_array[16].call(null, t, i, a);
   }
   function unsafe_set_some(t, i, x){
    var a = some(x);
    return Base_Uniform_array[16].call(null, t, i, a);
   }
   function unsafe_set_none(t, i){
    return Base_Uniform_array[16].call(null, t, i, none);
   }
   function clear(t){
    var d = a(t), b = Base_Import[93].call(null, d, 1), c = 0;
    if(b >= 0){
     var i = c;
     for(;;){
      unsafe_set_none(t, i);
      var e = i + 1 | 0;
      if(b === i) break;
      i = e;
     }
    }
    return 0;
   }
   function b(input, init, f){
    var
     acc = [0, init],
     e = a(input),
     b = Base_Import[93].call(null, e, 1),
     d = 0;
    if(b >= 0){
     var i = d;
     for(;;){
      var elem = unsafe_get(input, i);
      acc[1] = caml_call3(f, i, acc[1], elem);
      var c = i + 1 | 0;
      if(b === i) break;
      i = c;
     }
    }
    return acc[1];
   }
   function fold(input, init, f){
    return b
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, b],
    iter =
      [0,
       -198771759,
       function(input, f){
        var e = a(input), b = Base_Import[93].call(null, e, 1), d = 0;
        if(b >= 0){
         var i = d;
         for(;;){
          var x = unsafe_get(input, i);
          caml_call1(f, x);
          var c = i + 1 | 0;
          if(b === i) break;
          i = c;
         }
        }
        return 0;
       }],
    iteri =
      [0,
       -198771759,
       function(input, f){
        var d = a(input), b = Base_Import[93].call(null, d, 1), c = 0;
        if(b >= 0){
         var i = c;
         for(;;){
          caml_call2(f, i, unsafe_get(input, i));
          var e = i + 1 | 0;
          if(b === i) break;
          i = e;
         }
        }
        return 0;
       }],
    length = [0, -198771759, a],
    include =
      Base_Indexed_container[10].call
       (null, [0, fold, iter, length, iteri, foldi]),
    is_empty = include[2],
    mem = include[3],
    iter$0 = include[4],
    fold$0 = include[5],
    fold_result = include[6],
    fold_until = include[7],
    exists = include[8],
    for_all = include[9],
    count = include[10],
    sum = include[11],
    find = include[12],
    find_map = include[13],
    to_list = include[14],
    min_elt = include[16],
    max_elt = include[17],
    foldi$0 = include[18],
    iteri$0 = include[19],
    existsi = include[20],
    for_alli = include[21],
    counti = include[22],
    findi = include[23],
    find_mapi = include[24],
    length$0 = Base_Uniform_array[11];
   function map(input, f){
    var output = create(length$0(input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = length$0(input),
     output = create(len),
     a = Base_Import[93].call(null, len, 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var opt = Base_Uniform_array[13].call(null, input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[i + 1];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[i + 1];});
   }
   function to_array(t){
    var a = length$0(t);
    return Base_Array[41].call(null, a, function(i){return unsafe_get(t, i);});
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[35],
    include$0 =
      Base_Blit[5].call(null, [0, create_like, length$0, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5],
    copy = Base_Uniform_array[38],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       is_empty,
       mem,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       length$0,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_local,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
//# shape: Base__Stack:[F(2),F(2),F(1)*,F(2),N,F(1)*,F(1)*,F(2),F(3),N,N,N,N,N,N,N,N,N,N,N,N,F(1),F(1)*,F(1),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(1)*,F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Exn = global_data.Base__Exn,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[32],
    a = [0, "elts"],
    b = [0, "length"],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    c = [0, cst_src_stack_ml, 48, 6],
    d = [0, cst_src_stack_ml, 41, 4];
   function capacity(t){return Base_Option_array[28].call(null, t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= Base_Option_array[28].call(null, elts)){
      var e = Base_Import[93].call(null, length, 1), h = 0;
      if(e >= 0){
       var i$0 = h;
       for(;;){
        caml_call1(invariant_a, Base_Option_array[36].call(null, elts, i$0));
        var m = i$0 + 1 | 0;
        if(e === i$0) break;
        i$0 = m;
       }
      }
      var
       j = Base_Option_array[28].call(null, elts),
       f = Base_Import[93].call(null, j, 1);
      if(f >= length){
       var i = length;
       for(;;){
        if(Base_Option_array[38].call(null, elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
        var l = i + 1 | 0;
        if(f === i) break;
        i = l;
       }
      }
      var k = 0;
      return k;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[152],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = Base_Option_array[2].call(null, of_a_001, elts_005),
      bnds_002 = [0, [1, [0, a, [0, arg_006, 0]]], 0],
      arg_004 = Base_Import[139].call(null, length_003),
      bnds_002$0 = [0, [1, [0, b, [0, arg_004, 0]]], bnds_002],
      g =
        [0,
         [0, cst_exn, Base_Exn[1].call(null, exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return raise_s(Base_Sexp[10].call(null, cst_Stack_invariant_failed, g));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], a = Base_Import[93].call(null, t[1], 1);
    if(a >= 0){
     var i = a;
     for(;;){
      var b = Base_Option_array[36].call(null, t[2], i);
      r[1] = caml_call2(f, r[1], b);
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var a = Base_Import[93].call(null, t[1], 1);
    if(a >= 0){
     var i = a;
     for(;;){
      caml_call1(f, Base_Option_array[36].call(null, t[2], i));
      var b = i - 1 | 0;
      if(0 === i) break;
      i = b;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = Base_Container[17].call(null, [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    e = [0, cst_src_stack_ml, 109, 14];
   function of_list(l){
    if(Base_List[18].call(null, l)) return create(0);
    var
     length = Base_List[45].call(null, l),
     c = Base_Import[88].call(null, 2, length),
     elts = Base_Option_array[5].call(null, c),
     r = [0, l],
     b = Base_Import[93].call(null, length, 1);
    if(b >= 0){
     var i = b;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
      var l$0 = match[2], a = match[1];
      Base_Option_array[44].call(null, elts, i, a);
      r[1] = l$0;
      var d = i - 1 | 0;
      if(0 === i) break;
      i = d;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var a = caml_call1(to_list, t);
    return Base_List[6].call(null, sexp_of_a, a);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(Base_List[5].call(null, a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var a = Base_List[7].call(null, grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function resize(t, size){
    var arr = Base_Option_array[5].call(null, size);
    caml_call5(Base_Option_array[53], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = Base_Import[100].call(null, new_capacity, t[1]),
     a = new_capacity$0 !== capacity(t) ? 1 : 0;
    return a ? resize(t, new_capacity$0) : a;
   }
   function push(t, a){
    var b = Base_Option_array[28].call(null, t[2]);
    if(t[1] === b){
     var c = Base_Import[91].call(null, t[1], 1);
     resize(t, Base_Import[88].call(null, 2, c));
    }
    Base_Option_array[44].call(null, t[2], t[1], a);
    t[1] = Base_Import[91].call(null, t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = Base_Import[93].call(null, t[1], 1),
     result = Base_Option_array[36].call(null, t[2], i);
    Base_Option_array[45].call(null, t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = Base_Error[14].call(null, "Stack.pop of empty stack");
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? Base_Error[31].call(null, pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var a = Base_Import[93].call(null, t[1], 1);
    return Base_Option_array[36].call(null, t[2], a);
   }
   var top_error = Base_Error[14].call(null, "Stack.top of empty stack");
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? Base_Error[31].call(null, top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, Base_Option_array[58].call(null, elts)];
   }
   function clear(t){
    var a = 0 < t[1] ? 1 : 0;
    if(a){
     var b = Base_Import[93].call(null, t[1], 1), d = 0;
     if(b >= 0){
      var i = d;
      for(;;){
       Base_Option_array[45].call(null, t[2], i);
       var e = i + 1 | 0;
       if(b === i) break;
       i = e;
      }
     }
     t[1] = 0;
     var c = 0;
    }
    else
     var c = a;
    return c;
   }
   function until_empty(t, f){
    for(;;){
     var a = 0 < t[1] ? 1 : 0;
     if(! a) return a;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function filter_map(t, f){
    var t_result = create(0), a = Base_Import[93].call(null, t[1], 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var match = caml_call1(f, Base_Option_array[36].call(null, t[2], i));
      if(match){var x = match[1]; push(t_result, x);}
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0), a = Base_Import[93].call(null, t[1], 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var x = Base_Option_array[36].call(null, t[2], i);
      if(caml_call1(f, x)) push(t_result, x);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return t_result;
   }
   function filter_inplace(t, f){
    var write_index = [0, 0];
    return Base_Exn[13].call
            (null,
             function(param){
              var a = Base_Import[93].call(null, t[1], 1), b = 0;
              if(a >= 0){
               var read_index = b;
               for(;;){
                var x = Base_Option_array[41].call(null, t[2], read_index);
                if(caml_call1(f, x)){
                 if(write_index[1] < read_index)
                  Base_Option_array[51].call(null, t[2], write_index[1], x);
                 write_index[1]++;
                }
                var c = read_index + 1 | 0;
                if(a === read_index) break;
                read_index = c;
               }
              }
              return 0;
             },
             function(param){
              var a = write_index[1], b = Base_Import[93].call(null, t[1], 1);
              if(b >= a){
               var i = a;
               for(;;){
                Base_Option_array[52].call(null, t[2], i);
                var c = i + 1 | 0;
                if(b === i) break;
                i = c;
               }
              }
              t[1] = write_index[1];
              return 0;
             });
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       filter_map,
       filter,
       filter_inplace,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
//# shape: Base__Source_code_position:[F(2),F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(2),F(2),F(1),F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Int = global_data.Base__Int,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     a = Base_Int[8].call(null, pos_cnum),
     b = Base_Int[8].call(null, pos_bol),
     c = Base_Int[8].call(null, pos_lnum),
     d = runtime.Base_hash_string(pos_fname),
     e = Base_Import[121].call(null, d, c),
     f = Base_Import[121].call(null, e, b);
    return Base_Import[121].call(null, f, a);
   }
   var
    compare_local = Base_Source_code_position0[2],
    hash_fold_t = Base_Source_code_position0[4],
    comparator = Base_Source_code_position0[6],
    to_string = Base_Source_code_position0[8],
    sexp_of_t = Base_Source_code_position0[9],
    include = Base_Comparable[12].call(null, [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function equal_local(a, b){
    var c = compare_local(a, b);
    return caml_call2(Base_Import[242], c, 0);
   }
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       equal_local,
       compare_local,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
//# shape: Base__Sign_or_nan:[N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,F(1)*,F(1),F(1)*,F(1),F(1)*,F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero$0 = "zero",
    caml_int_compare = runtime.caml_int_compare,
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    b = [0, cst_Neg],
    c = [0, cst_Zero],
    d = [0, cst_Pos],
    e = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var a = sexp_004[1];
      b:
      if(a !== cst_Nan){
       c:
       if(a !== cst_Neg){
        d:
        if(a !== cst_Pos){
         if(a !== cst_Zero){
          if(a === cst_nan) break b;
          if(a === cst_neg) break c;
          if(a === cst_pos) break d;
          if(a !== cst_zero$0) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var match = sexp_004[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_003, sexp_004);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_003, sexp_004);
     var b = match$0[1];
     b:
     if(b !== cst_Nan){
      c:
      if(b !== cst_Neg){
       d:
       if(b !== cst_Pos){
        if(b !== cst_Zero){
         if(b === cst_nan) break b;
         if(b === cst_neg) break c;
         if(b === cst_pos) break d;
         if(b !== cst_zero$0) break a;
        }
        return Sexplib0_Sexp_conv_error[7].call
                (null, error_source_003, sexp_004);
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_003, sexp_004);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_003, sexp_004);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_003, sexp_004);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return b;
      case 1:
       return c;
      case 2:
       return d;
      default: return e;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var a = 0; break;
      case 1:
       var a = 1; break;
      case 2:
       var a = 2; break;
      default: var a = 3;
    }
    return Base_Hash[3].call(null, hsv, a);
   }
   function hash(arg){
    var hsv = Base_Hash[11].call(null, 0, 0), a = hash_fold_t(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   function of_string(s){return t_of_sexp(Base_Import[136].call(null, s));}
   function to_string(t){
    var a = sexp_of_t(t);
    return Base_Import[160].call(null, a);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return Base_Poly0[1].call(null, x, y);}
   function descending(x, y){return Base_Poly0[2].call(null, x, y);}
   var compare$0 = caml_int_compare, compare_local = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    a =
      Base_Identifiable[1].call
       (null,
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = a[1],
    hash$0 = a[2],
    t_of_sexp$0 = a[3],
    sexp_of_t$0 = a[4],
    of_string$0 = a[5],
    to_string$0 = a[6],
    between = a[19],
    clamp_exn = a[20],
    clamp = a[21],
    comparator = a[22],
    pp = a[23],
    hashable = a[24],
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    cst_negative = "negative",
    cst_zero = cst_zero$0,
    cst_positive = "positive",
    cst_not_a_number = "not-a-number";
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return Base_Import[126].call(null, cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(Base_Sign[30].call(null, n));}
   function to_int_exn(t){
    var a = to_sign_exn(t);
    return Base_Sign[31].call(null, a);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var a = to_sign_exn(t), b = to_sign_exn(t$0);
     return of_sign(Base_Sign[34].call(null, b, a));
    }
    return 3;
   }
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      case 2:
       return cst_positive;
      default: return cst_not_a_number;
    }
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(35, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
//# shape: Base__Sexp_with_comparable:[F(1),F(2),F(1),F(1)*,F(1)*,N,N,F(2),N,F(2),F(3),F(2),F(2),F(2),F(1),F(1),N,N,N,F(1)*,N,N,N,N,N,N,N,F(2),F(2),N,N,N,N,N,N,N,N,F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    a = Base_Comparable[11].call(null, [0, Base_Sexp[7], Base_Sexp[5]]),
    symbol = a[1],
    symbol$0 = a[2],
    symbol$1 = a[3],
    symbol$2 = a[4],
    symbol$3 = a[5],
    symbol$4 = a[6],
    min = a[9],
    max = a[10],
    ascending = a[11],
    descending = a[12],
    between = a[13],
    clamp_exn = a[14],
    clamp = a[15],
    comparator = a[16],
    globalize = Base_Sexp[1],
    hash_fold_t = Base_Sexp[2],
    hash = Base_Sexp[3],
    t_of_sexp = Base_Sexp[4],
    sexp_of_t = Base_Sexp[5],
    equal = Base_Sexp[6],
    compare = Base_Sexp[7],
    Not_found_s = Base_Sexp[8],
    Of_sexp_error = Base_Sexp[9],
    message = Base_Sexp[10],
    default_indent = Base_Sexp[11],
    pp_hum = Base_Sexp[12],
    pp_hum_indent = Base_Sexp[13],
    pp_mach = Base_Sexp[14],
    pp = Base_Sexp[15],
    to_string_hum = Base_Sexp[16],
    to_string_mach = Base_Sexp[17],
    to_string = Base_Sexp[18],
    of_float_style = Base_Sexp[19],
    of_int_style = Base_Sexp[20],
    equal_local = Base_Sexp[22],
    compare_local = Base_Sexp[23],
    t_sexp_grammar = Base_Sexp[24],
    invariant = Base_Sexp[25],
    of_string = Base_Sexp[26],
    Base_Sexp_with_comparable =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable_intf
//# shape: Base__Dictionary_immutable_intf:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Definitions = [0],
    Base_Dictionary_immutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable_intf, "Base__Dictionary_immutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable
//# unitInfo: Requires: Base__Dictionary_immutable_intf
//# shape: Base__Dictionary_immutable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_immutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable, "Base__Dictionary_immutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
//# shape: Base__Hasher:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
//# shape: Base__Maybe_bound:[F(1),F(2),F(2),F(1)*,F(2),F(2),F(3),F(3),F(4),F(3),F(1)*,F(1),N,F(2)*,F(2)*,F(2),F(1),F(4)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_033 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    a = [0, 0, 0],
    b = [0, cst_Unbounded],
    c = [0, cst_Incl$0],
    d = [0, cst_Excl$0],
    e = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    f = [0, cst_Below_lower_bound],
    g = [0, cst_In_range],
    h = [0, cst_Above_upper_bound];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc];
     l = l$0;
     acc = acc$0;
    }
    var
     b = Base_List[63].call(null, acc),
     l$1 = all_of_a,
     acc$1 = 0,
     c = Base_List[10].call(null, b, a);
    for(;;){
     if(! l$1){
      var d = Base_List[63].call(null, acc$1);
      return Base_List[10].call(null, d, c);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1];
     l$1 = l$2;
     acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var a = sexp_008[1];
      b:
      if(a !== cst_Excl$0){
       c:
       if(a !== cst_Incl$0){
        if(a !== cst_Unbounded){
         if(a === cst_excl) break b;
         if(a === cst_incl) break c;
         if(a !== cst_unbounded) break a;
        }
        return 0;
       }
       return Sexplib0_Sexp_conv_error[9].call
               (null, error_source_006, sexp_008);
      }
      return Sexplib0_Sexp_conv_error[9].call
              (null, error_source_006, sexp_008);
     }
     var match = sexp_008[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_006, sexp_008);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_006, sexp_008);
     var tag_009 = match$0[1];
     b:
     if(tag_009 !== cst_Excl$0){
      c:
      if(tag_009 !== cst_Incl$0){
       if(tag_009 !== cst_Unbounded){
        if(tag_009 === cst_excl) break b;
        if(tag_009 === cst_incl) break c;
        if(tag_009 !== cst_unbounded) break a;
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_006, sexp_008);
      }
      var sexp_args_010 = match[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return Sexplib0_Sexp_conv_error[8].call
              (null, error_source_006, tag_009, sexp_008);
     }
     var sexp_args_015 = match[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return Sexplib0_Sexp_conv_error[8].call
             (null, error_source_006, tag_009, sexp_008);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return b;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, c, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, d, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], e]]]];
   }
   function globalize(globalize_a_026, x_027){
    if(typeof x_027 === "number") return x_027;
    if(0 === x_027[0]){
     var arg_029 = x_027[1];
     return [0, caml_call1(globalize_a_026, arg_029)];
    }
    var arg_030 = x_027[1];
    return [1, caml_call1(globalize_a_026, arg_030)];
   }
   function interval_comparison_of_sexp(sexp_034){
    a:
    {
     if(0 === sexp_034[0]){
      var a = sexp_034[1];
      b:
      if(a !== cst_Above_upper_bound){
       c:
       if(a !== cst_Below_lower_bound){
        if(a !== cst_In_range){
         if(a === cst_above_upper_bound) break b;
         if(a === cst_below_lower_bound) break c;
         if(a !== cst_in_range) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var match = sexp_034[1];
     if(! match)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_033, sexp_034);
     var match$0 = match[1];
     if(0 !== match$0[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_033, sexp_034);
     var b = match$0[1];
     b:
     if(b !== cst_Above_upper_bound){
      c:
      if(b !== cst_Below_lower_bound){
       if(b !== cst_In_range){
        if(b === cst_above_upper_bound) break b;
        if(b === cst_below_lower_bound) break c;
        if(b !== cst_in_range) break a;
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_033, sexp_034);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_033, sexp_034);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_033, sexp_034);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_033, sexp_034);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return f;case 1: return g;default: return h;
    }
   }
   var
    compare_interval_comparison_lo = caml_int_compare,
    compare_interval_comparison = caml_int_compare,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound";
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       var a = 0; break;
      case 1:
       var a = 1; break;
      default: var a = 2;
    }
    return Base_Hash[3].call(null, hsv, a);
   }
   function hash_interval_comparison(arg){
    var
     hsv = Base_Hash[11].call(null, 0, 0),
     a = hash_fold_interval_comparison(hsv, arg);
    return Base_Hash[9].call(null, a);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     Base_Import[124].call(null, cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       globalize,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       compare_interval_comparison_lo,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Sexplib0__Sexp_conv_error
//# shape: Base__Map_intf:[[F(3),F(3),F(2)],[],[],[],[F(4),F(4),F(3),F(3),F(2)*],[F(4),F(4),F(3)],[F(2)*,N,F(2)*,F(1)*],[F(2)*,N,F(2)*,F(1)*]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    a = [0, "Duplicate"],
    b = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && -1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number"){
     var variant = b_002[1];
     if(17724 === variant){
      var right_004 = b_002[2], left_003 = a_001[2];
      return caml_call2(cmp_a, left_003, right_004);
     }
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(a_005 === b_006) return 1;
    if(typeof a_005 === "number"){
     if(typeof b_006 === "number" && -1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number"){
     var variant = b_006[1];
     if(17724 === variant){
      var right_008 = b_006[2], left_007 = a_005[2];
      return caml_call2(cmp_a, left_007, right_008);
     }
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return a;
    var v_010 = param[2];
    return [1, [0, b, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0],
    c = [0, cst_Left$0],
    d = [0, cst_Unequal$0],
    e = [0, cst_Right$0],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(t_014 === t_016) return 0;
    var a = t_014[1];
    if(847852583 === a){
     if(typeof t_016 !== "number"){
      var variant = t_016[1];
      if(847852583 === variant){
       var right_018 = t_016[2], left_017 = t_014[2];
       return caml_call2(cmp_v, left_017, right_018);
      }
     }
    }
    else
     if(1013247643 <= a){
      if(typeof t_016 !== "number"){
       var variant$0 = t_016[1];
       if(1013247643 === variant$0){
        var
         right_022 = t_016[2],
         left_021 = t_014[2],
         t_024 = left_021[2],
         t_023 = left_021[1],
         t_026 = right_022[2],
         t_025 = right_022[1],
         n$0 = caml_call2(cmp_v, t_023, t_025);
        return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
       }
      }
     }
     else if(typeof t_016 !== "number"){
      var variant$1 = t_016[1];
      if(-57574468 === variant$1){
       var right_020 = t_016[2], left_019 = t_014[2];
       return caml_call2(cmp_v, left_019, right_020);
      }
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     a = caml_call2(cmp_k, t_029, t_031);
    if(a){
     if(t_030 === t_032) return 1;
     var b = t_030[1];
     if(847852583 === b){
      if(typeof t_032 !== "number"){
       var variant = t_032[1];
       if(847852583 === variant){
        var right_034 = t_032[2], left_033 = t_030[2];
        return caml_call2(cmp_v, left_033, right_034);
       }
      }
     }
     else
      if(1013247643 <= b){
       if(typeof t_032 !== "number"){
        var variant$0 = t_032[1];
        if(1013247643 === variant$0){
         var
          right_038 = t_032[2],
          left_037 = t_030[2],
          t_040 = left_037[2],
          t_039 = left_037[1],
          t_042 = right_038[2],
          t_041 = right_038[1],
          d = caml_call2(cmp_v, t_039, t_041);
         return d ? caml_call2(cmp_v, t_040, t_042) : d;
        }
       }
      }
      else if(typeof t_032 !== "number"){
       var variant$1 = t_032[1];
       if(-57574468 === variant$1){
        var right_036 = t_032[2], left_035 = t_030[2];
        return caml_call2(cmp_v, left_035, right_036);
       }
      }
     var c = caml_equal(t_030, t_032);
    }
    else
     var c = a;
    return c;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(0 !== sexp_071[0]){
     var b = sexp_071[1];
     if(b){
      var c = b[2];
      if(c && ! c[2]){
       var
        arg1_068 = c[1],
        arg0_067 = b[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        a:
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          a =
            atom_047 !== cst_Left$0
             ? atom_047
               !== cst_Right$0
               ? atom_047
                 !== cst_Unequal$0
                 ? Sexplib0_Sexp_conv_error[23].call(null, 0)
                 : Sexplib0_Sexp_conv_error
                    [27].call
                   (null, error_source_057, arg1_068)
               : Sexplib0_Sexp_conv_error
                  [27].call
                 (null, error_source_057, arg1_068)
             : Sexplib0_Sexp_conv_error
                [27].call
               (null, error_source_057, arg1_068);
        else{
         var match = arg1_068[1];
         if(match){
          var match$0 = match[1];
          if(0 === match$0[0]){
           var sexp_args_050 = match[2], atom_047$0 = match$0[1];
           if(atom_047$0 !== cst_Left$0)
            if(atom_047$0 !== cst_Right$0)
             if(atom_047$0 !== cst_Unequal$0)
              var a = Sexplib0_Sexp_conv_error[23].call(null, 0);
             else{
              if(sexp_args_050 && ! sexp_args_050[2]){
               var arg0_058 = sexp_args_050[1];
               b:
               {
                if(0 !== arg0_058[0]){
                 var d = arg0_058[1];
                 if(d){
                  var e = d[2];
                  if(e && ! e[2]){
                   var
                    arg1_053 = e[1],
                    arg0_052 = d[1],
                    res0_054 = caml_call1(of_v_044, arg0_052),
                    res1_055 = caml_call1(of_v_044, arg1_053),
                    res0_059 = [0, res0_054, res1_055];
                   break b;
                  }
                 }
                }
                var
                 res0_059 =
                   Sexplib0_Sexp_conv_error[4].call
                    (null, error_source_057, 2, arg0_058);
               }
               var a = [0, 1013247643, res0_059];
               break a;
              }
              var
               a =
                 Sexplib0_Sexp_conv_error[26].call
                  (null, error_source_057, atom_047$0, arg1_068);
             }
            else{
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_061 = sexp_args_050[1],
               res0_062 = caml_call1(of_v_044, arg0_061),
               a = [0, -57574468, res0_062];
              break a;
             }
             var
              a =
                Sexplib0_Sexp_conv_error[26].call
                 (null, error_source_057, atom_047$0, arg1_068);
            }
           else{
            if(sexp_args_050 && ! sexp_args_050[2]){
             var
              arg0_064 = sexp_args_050[1],
              res0_065 = caml_call1(of_v_044, arg0_064),
              a = [0, 847852583, res0_065];
             break a;
            }
            var
             a =
               Sexplib0_Sexp_conv_error[26].call
                (null, error_source_057, atom_047$0, arg1_068);
           }
          }
          else
           var
            a =
              Sexplib0_Sexp_conv_error[28].call
               (null, error_source_057, arg1_068);
         }
         else
          var
           a =
             Sexplib0_Sexp_conv_error[29].call
              (null, error_source_057, arg1_068);
        }
        var res1_070 = a;
       }
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(exn !== Sexplib0_Sexp_conv_error[22])
         throw caml_maybe_attach_backtrace(exn, 0);
        var
         res1_070 =
           Sexplib0_Sexp_conv_error[24].call(null, error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return Sexplib0_Sexp_conv_error[4].call
            (null, error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     variant = arg1_082[1];
    if(847852583 === variant)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, c, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= variant)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, d, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, e, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar],
    f = [0, "Both"],
    g = [0, cst_Left$0],
    h = [0, cst_Right$0];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(a_085 === b_086) return 0;
    var a = a_085[1];
    if(737457313 === a){
     if(typeof b_086 !== "number"){
      var variant = b_086[1];
      if(737457313 === variant){
       var
        right_092 = b_086[2],
        left_091 = a_085[2],
        t_094 = left_091[2],
        t_093 = left_091[1],
        t_096 = right_092[2],
        t_095 = right_092[1],
        n = caml_call2(cmp_left, t_093, t_095);
       return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
      }
     }
    }
    else
     if(847852583 <= a){
      if(typeof b_086 !== "number"){
       var variant$0 = b_086[1];
       if(847852583 === variant$0){
        var right_088 = b_086[2], left_087 = a_085[2];
        return caml_call2(cmp_left, left_087, right_088);
       }
      }
     }
     else if(typeof b_086 !== "number"){
      var variant$1 = b_086[1];
      if(-57574468 === variant$1){
       var right_090 = b_086[2], left_089 = a_085[2];
       return caml_call2(cmp_right, left_089, right_090);
      }
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(a_097 === b_098) return 1;
    var a = a_097[1];
    if(737457313 === a){
     if(typeof b_098 !== "number"){
      var variant = b_098[1];
      if(737457313 === variant){
       var
        right_104 = b_098[2],
        left_103 = a_097[2],
        t_106 = left_103[2],
        t_105 = left_103[1],
        t_108 = right_104[2],
        t_107 = right_104[1],
        b = caml_call2(cmp_left, t_105, t_107);
       return b ? caml_call2(cmp_right, t_106, t_108) : b;
      }
     }
    }
    else
     if(847852583 <= a){
      if(typeof b_098 !== "number"){
       var variant$0 = b_098[1];
       if(847852583 === variant$0){
        var right_100 = b_098[2], left_099 = a_097[2];
        return caml_call2(cmp_left, left_099, right_100);
       }
      }
     }
     else if(typeof b_098 !== "number"){
      var variant$1 = b_098[1];
      if(-57574468 === variant$1){
       var right_102 = b_098[2], left_101 = a_097[2];
       return caml_call2(cmp_right, left_101, right_102);
      }
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var variant = param[1];
    if(737457313 === variant){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, f, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= variant){
     var v_111 = param[2];
     return [1, [0, g, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, h, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare,
    i = [0, "Stop"],
    j = [0, "Continue"];
   function equal$2(b, a){return b === a ? 1 : 0;}
   function sexp_of_t$2(param){return param ? i : j;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare,
    k = [0, "Unfinished"],
    l = [0, "Finished"];
   function equal$3(b, a){return b === a ? 1 : 0;}
   function sexp_of_t$3(param){return param ? k : l;}
   var
    Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3],
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished];
   runtime.caml_register_global(25, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
//# shape: Base__Set_intf:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Named = [0],
    Base_Set_intf = [0, Named];
   runtime.caml_register_global(0, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Base__Array, Base__Comparator, Base__Container, Base__Exn, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
//# shape: Base__Set:[F(4),F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(1)*,F(1)*,F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),N,F(2),F(2),F(2),F(1),F(1),F(2),F(2),F(3),F(2),F(3),F(3),F(2),F(3),F(3),F(4),F(3),F(2),F(3),F(2),F(1),F(1),F(1),F(1),F(1),F(1)*,F(1),F(2),F(2),F(2),F(2),F(4),F(4),F(3),N,F(5),F(1)*,F(2),F(2),F(1)*,F(3),F(3),F(2)*->F(1),F(2),N,F(1)*,F(2)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    with_return = Base_With_return[1],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    b = [0, cst_src_set_ml, 169, 17],
    c = [0, cst_src_set_ml, 170, 28],
    d = [0, cst_src_set_ml, 176, 21],
    e = [0, cst_src_set_ml, 178, 12],
    f = [0, cst_src_set_ml, 185, 17],
    g = [0, cst_src_set_ml, 186, 28],
    h = [0, cst_src_set_ml, 192, 21],
    i = [0, cst_src_set_ml, 194, 12];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      a = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var a = 1;
    if(a){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var b = 1;
    }
    else
     var b = a;
    return b;
   }
   function loop(lower$1, upper, compare_elt, t$0){
    var lower = lower$1, t = t$0;
    for(;;){
     if(typeof t === "number") return 1;
     if(0 === t[0]){
      var v = t[1];
      return in_range(lower, upper, compare_elt, v);
     }
     var
      n = t[5],
      h = t[4],
      r = t[3],
      v$0 = t[2],
      l = t[1],
      hl = height(l),
      hr = height(r),
      g = Base_Import[93].call(null, hl, hr),
      b = Base_Import[123].call(null, g) <= 2 ? 1 : 0;
     if(b){
      var
       i = Base_Import[100].call(null, hl, hr),
       c = h === Base_Import[91].call(null, i, 1) ? 1 : 0;
      if(c){
       var
        j = length(r),
        k = length(l),
        m = Base_Import[91].call(null, k, j),
        d = n === Base_Import[91].call(null, m, 1) ? 1 : 0;
       if(d){
        var e = in_range(lower, upper, compare_elt, v$0);
        if(e){
         var f = loop(lower, [0, v$0], compare_elt, l);
         if(f){var lower$0 = [0, v$0]; lower = lower$0; t = r; continue;}
         var a = f;
        }
        else
         var a = e;
       }
       else
        var a = d;
      }
      else
       var a = c;
     }
     else
      var a = b;
     return a;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    var
     hl = height(l),
     hr = height(r),
     h =
       hr <= hl
        ? Base_Import[91].call(null, hl, 1)
        : Base_Import[91].call(null, hr, 1);
    if(1 === h) return [0, v];
    var
     sl = length(l),
     sr = length(r),
     a = Base_Import[91].call(null, sl, sr);
    return [1, l, v, r, h, Base_Import[91].call(null, a, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, Base_Import[91].call(null, i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, Base_Import[91].call(null, i, 1)),
          kr = caml_call1(f, Base_Import[91].call(null, i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = Base_Import[120].call(null, n, 1),
      a = Base_Import[93].call(null, n, left_length),
      right_length = Base_Import[93].call(null, a, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, Base_Import[91].call(null, i, left_length)),
      b = Base_Import[91].call(null, i, left_length),
      right = loop(right_length, f, Base_Import[91].call(null, b, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var a = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], a)){
       var
        next =
          function(i){
           var
            b = Base_Import[93].call(null, array_length, 1),
            a = Base_Import[93].call(null, b, i);
           return caml_check_bound(array, a)[a + 1];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[i + 1];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return with_return
             (function(r){
               var
                c = caml_check_bound(array, 1)[2],
                i = caml_call2(compare_elt, caml_check_bound(array, 0)[1], c),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      Base_Or_error[40].call(null, cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                a = Base_Import[93].call(null, array.length - 1, 2),
                d = 1;
               if(a >= 1){
                var i$0 = d;
                for(;;){
                 var
                  b = Base_Import[91].call(null, i$0, 1),
                  e = caml_check_bound(array, b)[b + 1],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[i$0 + 1], e);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    Base_Or_error[40].call
                     (null, cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    Base_Or_error[40].call(null, cst_of_sorted_array_elements_a));
                 var f = i$0 + 1 | 0;
                 if(a === i$0) break;
                 i$0 = f;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    var hl = height(l), hr = height(r);
    if(Base_Import[91].call(null, hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
     var lr = l[3], lv = l[2], ll = l[1], a = height(lr);
     if(a <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], k = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, k);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
     var j = create(0, v, r);
     return create(create(ll, lv, 0), lrv, j);
    }
    if(Base_Import[91].call(null, hl, 2) >= hr) return create(l, v, r);
    if(typeof r === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
    var rr = r[3], rv = r[2], rl = r[1], m = height(rl);
    if(m <= height(rr)) return create(create(l, v, rl), rv, rr);
    if(typeof rl === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
    if(0 !== rl[0]){
     var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], o = create(rlr, rv, rr);
     return create(create(l, v, rll), rlv$0, o);
    }
    var rlv = rl[1];
    if(! is_empty(rr))
     throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
    var n = create(0, rv, rr);
    return create(create(l, v, 0), rlv, n);
   }
   var Same = [248, "Base__Set.Tree0.Same", caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? Base_Exn[6].call(null, Same)
              : 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     return 0 === c$0
             ? Base_Exn[6].call(null, Same)
             : 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var a = aux(t); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Same) return t;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function add_min(x, t){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, 0, x, t, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(add_min(x, l), v, r);
   }
   function add_max(t, x){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, t, x, 0, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(l, v, add_max(r, x));
   }
   function join(l, v, r){
    if(typeof l === "number") return add_min(v, r);
    if(0 !== l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){var rv = r[1]; return add_max(add_max(l, v), rv);}
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return Base_Import[91].call(null, rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r))
              : Base_Import
                  [91].call
                 (null, lh, 2)
                < rh
                ? bal(join(l, v, rl), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add_max(l, v);
    var lv = l[1];
    return add_min(lv, add_min(v, r));
   }
   function min_elt(param$0){
    var param = param$0;
    for(;;){
     if(typeof param === "number") return 0;
     if(0 === param[0])
      var v = param[1];
     else{
      var l = param[1];
      if(typeof l !== "number"){param = l; continue;}
      var v = param[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    j = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    k = [0, cst_src_set_ml, 276, 13];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Set_min_elt_exn_of_empty_set,
     function(param){
      if(param === Set_min_elt_exn_of_empty_set) return j;
      throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
     });
   var
    Set_max_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    l = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    m = [0, cst_src_set_ml, 289, 13];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Set_max_elt_exn_of_empty_set,
     function(param){
      if(param === Set_max_elt_exn_of_empty_set) return l;
      throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
     });
   var
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    n = [0, 0, 0, 0],
    o = [0, 0, 0],
    p = [0, 0, 0];
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t$0, acc$2){
     var t = t$0, acc = acc$2;
     for(;;){
      if(typeof t === "number") return [0, acc];
      if(0 === t[0]){var value = t[1]; return caml_call2(f, acc, value);}
      var
       right = t[3],
       value$0 = t[2],
       left = t[1],
       x = fold_until_helper(f, left, acc);
      if(0 !== x[0]) return x;
      var acc$0 = x[1], x$0 = caml_call2(f, acc$0, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$1 = x$0[1];
      t = right;
      acc = acc$1;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param$0){
    var param = param$0;
    for(;;){
     if(typeof param === "number") return 0;
     if(0 === param[0])
      var v = param[1];
     else{
      if(typeof param[3] !== "number"){var r = param[3]; param = r; continue;}
      var v = param[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return Base_Import[126].call(null, cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var a = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), a);
   }
   function concat(t1, t2){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var a = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), a);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return n;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r)];
    }
    return split(t);
   }
   function split_le_gt(t, x, compare_elt){
    if(typeof t === "number") return o;
    if(0 === t[0]){
     var v = t[1];
     return 0 <= caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, add_max(l, v$0), r];
    if(0 <= c){
     var match = split_le_gt(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_le_gt(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   function split_lt_ge(t, x, compare_elt){
    if(typeof t === "number") return p;
    if(0 === t[0]){
     var v = t[1];
     return 0 < caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, l, add_min(v$0, r)];
    if(0 <= c){
     var match = split_lt_ge(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_lt_ge(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   var empty_without_value_restrictio = 0, q = [0, 0, 0];
   function mem(t$0, x, compare_elt){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      a = 0 === c$0 ? 1 : 0;
     if(a) return a;
     t = 0 <= c$0 ? r : l;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") return Base_Exn[6].call(null, Same);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_elt, x, v)
              ? 0
              : Base_Exn[6].call(null, Same);
     }
     var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
     return 0 === c
             ? merge(l, r)
             : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var a = aux(t); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Same) return t;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") return Base_Exn[6].call(null, Same);
     if(0 === t[0]) return 0 === i ? 0 : Base_Exn[6].call(null, Same);
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var a = Base_Import[93].call(null, i, l_size);
     return bal(l, v, aux(r, Base_Import[93].call(null, a, 1)));
    }
    try{var a = aux(t, i); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Same) return t;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1$1, s2$1){
     var s1 = s1$1, s2 = s2$1;
     for(;;){
      if(s1 === s2) return s1;
      if(typeof s1 === "number")
       var t = s2;
      else{
       if(0 !== s1[0]){
        var h1 = s1[4], r1 = s1[3], v1$0 = s1[2], l1 = s1[1];
        if(typeof s2 !== "number"){
         if(0 !== s2[0]) break;
         var v2 = s2[1], s2$0 = [1, 0, v2, 0, 1, 1];
         s2 = s2$0;
         continue;
        }
       }
       if(typeof s2 !== "number"){
        var v1 = s1[1], s1$0 = [1, 0, v1, 0, 1, 1];
        s1 = s1$0;
        continue;
       }
       var t = s1;
      }
      return t;
     }
     var h2 = s2[4], r2 = s2[3], v2$0 = s2[2], l2 = s2[1];
     if(h2 <= h1){
      if(1 === h2) return add(s1, v2$0, compare_elt);
      var
       match = split(s2, v1$0, compare_elt),
       r2$0 = match[3],
       l2$0 = match[1],
       a = union(r1, r2$0);
      return join(union(l1, l2$0), v1$0, a);
     }
     if(1 === h1) return add(s2, v1$0, compare_elt);
     var
      match$0 = split(s1, v2$0, compare_elt),
      r1$0 = match$0[3],
      l1$0 = match$0[1],
      b = union(r1$0, r2);
     return join(union(l1$0, l2), v2$0, b);
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    return Base_List[20].call
            (null,
             xs,
             empty_without_value_restrictio,
             function(ac, x){
              return union(ac, caml_call1(to_tree, x), compare_elt);
             });
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(s1 === s2) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          a = split(s2, v1, compare_elt),
          match = a[2],
          l2 = a[1];
         if(match){
          var r2 = a[3], v1$0 = match[1], b = inter(r1, r2);
          return join(inter(l1, l2), v1$0, b);
         }
         var r2$0 = a[3], c = inter(r1, r2$0);
         return concat(inter(l1, l2), c);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1$1, s2){
     var s1 = s1$1;
     for(;;){
      if(s1 === s2) return 0;
      if(typeof s1 === "number") return 0;
      if(typeof s2 === "number") return s1;
      if(typeof s1 !== "number" && 0 !== s1[0]){
       var
        r1 = s1[3],
        v1$0 = s1[2],
        l1 = s1[1],
        a = split(s2, v1$0, compare_elt),
        l2 = a[1];
       if(a[2]){
        var r2 = a[3], b = diff(r1, r2);
        return concat(diff(l1, l2), b);
       }
       var r2$0 = a[3], c = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, c);
      }
      var v1 = s1[1], s1$0 = [1, 0, v1, 0, 1, 1];
      s1 = s1$0;
     }
    }
    return diff(s1, s2);
   }
   function cons(s$0, e$1){
    var s = s$0, e = e$1;
    for(;;){
     if(typeof s === "number") return e;
     if(0 === s[0]){var v = s[1]; return [0, v, 0, e];}
     var r = s[3], v$0 = s[2], l = s[1], e$0 = [0, v$0, r, e];
     s = l;
     e = e$0;
    }
   }
   function cons_right(s$0, e$1){
    var s = s$0, e = e$1;
    for(;;){
     if(typeof s === "number") return e;
     if(0 === s[0]){var v = s[1]; return [0, v, 0, e];}
     var r = s[3], v$0 = s[2], l = s[1], e$0 = [0, v$0, l, e];
     s = r;
     e = e$0;
    }
   }
   function of_set(s){return cons(s, 0);}
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree$0 = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree$0, enum$0)]];
     }
     var right = state[2], enum$ = left[3], tree = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree, enum$), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree, enum$), right]];
     if(tree === tree2)
      var next_state = [0, enum$, enum2];
     else
      var a = cons(tree2, enum2), next_state = [0, cons(tree, enum$), a];
     return [0, next_state];
    }
    var a = of_set(t2), b = [0, of_set(t1), a];
    return Base_Sequence[44].call(null, b, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    var order = opt ? opt[1] : 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      a = Base_Import[125],
      t$4 =
        Base_Option[34].call
         (null,
          less_or_equal_to,
          t$3,
          function(b, c){return inclusive_bound(a, b, c);}),
      next =
        function(enum$){
         if(! enum$) return 0;
         var e = enum$[3], t = enum$[2], k = enum$[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0]){
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1];
        t = t$0;
       }
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key)){
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e];
         t = l;
         e = e$0;
        }
        else
         t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return Base_Sequence[44].call(null, init, next);
    }
    var
     b = Base_Import[127],
     t$5 =
       Base_Option[34].call
        (null,
         greater_or_equal_to,
         t$3,
         function(a, c){return inclusive_bound(b, a, c);});
    function next$0(enum$){
     if(! enum$) return 0;
     var e = enum$[3], t = enum$[2], k = enum$[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0]){
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1];
       t$1 = t$2;
      }
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        t$1 = l$0;
       else{
        var r$1 = t$1[3], v$4 = t$1[2], e$2 = [0, v$4, l$0, e$1];
        t$1 = r$1;
        e$1 = e$2;
       }
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return Base_Sequence[44].call(null, init$0, next$0);
   }
   function find_first_satisfying(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t[3], v$0 = t[2], l = t[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     t = r;
    }
   }
   function find_last_satisfying(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t[3], v$0 = t[2], l = t[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     t = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    var order = opt ? opt[1] : 608542111;
    if(608542111 <= order)
     var a = comparator[1];
    else
     var
      d = comparator[1],
      e = Base_Fn[6],
      a = function(a, b){return e(d, a, b);};
    var
     b =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     c =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return Base_Sequence[58].call(null, c, b, a);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(r1 === r2){
      e1 = e1$0;
      e2 = e2$0;
     }
     else{
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0);
      e1 = e1$1;
      e2 = e2$1;
     }
    }
   }
   function iter2(s1, s2, compare_elt, f){
    var t2$2 = of_set(s2), t1$2 = of_set(s1);
    a:
    {
     var t1 = t1$2, t2 = t2$2;
     for(;;){
      if(! t1) break;
      if(! t2){var param$0 = t1; break a;}
      var
       enum2 = t2[3],
       tree2 = t2[2],
       a2 = t2[1],
       enum1 = t1[3],
       tree1 = t1[2],
       a1 = t1[1],
       compare_result = caml_call2(compare_elt, a1, a2);
      if(0 === compare_result){
       caml_call1(f, [0, 737457313, [0, a1, a2]]);
       var t2$0 = cons(tree2, enum2), t1$0 = cons(tree1, enum1);
       t1 = t1$0;
       t2 = t2$0;
      }
      else if(0 <= compare_result){
       caml_call1(f, [0, -57574468, a2]);
       var t2$1 = cons(tree2, enum2);
       t2 = t2$1;
      }
      else{
       caml_call1(f, [0, 847852583, a1]);
       var t1$1 = cons(tree1, enum1);
       t1 = t1$1;
      }
     }
     if(! t2) return 0;
     var param = t2;
     for(;;){
      if(! param) return 0;
      var enum$ = param[3], tree = param[2], a = param[1];
      caml_call1(f, [0, -57574468, a]);
      param = cons(tree, enum$);
     }
    }
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree$0 = param$0[2], a$0 = param$0[1];
     caml_call1(f, [0, 847852583, a$0]);
     param$0 = cons(tree$0, enum$0);
    }
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1$0, s2$0){
     var s1 = s1$0, s2 = s2$0;
     for(;;){
      if(typeof s1 === "number") return 1;
      if(0 !== s1[0]){
       var r1 = s1[3], v1$0 = s1[2], l1 = s1[1];
       if(typeof s2 !== "number"){
        if(0 === s2[0]){
         var v2 = s2[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2[3],
         v2$0 = s2[2],
         l2 = s2[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var e = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! e) return e;
          s1 = l1;
          continue;
         }
         var f = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! f) return f;
         s1 = r1;
         continue;
        }
        var a = s1 === s2 ? 1 : 0;
        if(a)
         var b = a;
        else{
         var d = is_subset(l1, l2);
         if(d){s1 = r1; s2 = r2; continue;}
         var b = d;
        }
        return b;
       }
      }
      if(typeof s2 === "number") return 0;
      var v1 = s1[1];
      return mem(s2, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1$0, s2$0, compare_elt){
    var s1 = s1$0, s2 = s2$0;
    for(;;){
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var r1 = s1[3], v1 = s1[2], l1 = s1[1];
         if(s1 === s2) return 0;
         var a = split(s2, v1, compare_elt), l2 = a[1];
         if(a[2]) return 0;
         var r2 = a[3], b = are_disjoint(l1, l2, compare_elt);
         if(! b) return b;
         s1 = r1;
         s2 = r2;
         continue;
        }
        var other_set = s1, elt = s2[1];
        break a;
       }
       var other_set = s2, elt = s1[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter(t, f){
    function iter(param$0){
     var param = param$0;
     for(;;){
      if(typeof param === "number") return 0;
      if(0 === param[0]){var v = param[1]; return caml_call1(f, v);}
      var r = param[3], v$0 = param[2], l = param[1];
      iter(l);
      caml_call1(f, v$0);
      param = r;
     }
    }
    return iter(t);
   }
   function fold(s$0, accu$1, f){
    var s = s$0, accu = accu$1;
    for(;;){
     if(typeof s === "number") return accu;
     if(0 === s[0]){var v = s[1]; return caml_call2(f, accu, v);}
     var
      r = s[3],
      v$0 = s[2],
      l = s[1],
      accu$0 = caml_call2(f, fold(l, accu, f), v$0);
     s = r;
     accu = accu$0;
    }
   }
   function count(t, f){return Base_Container[2].call(null, fold, t, f);}
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function fold_right(s$0, accu$1, f){
    var s = s$0, accu = accu$1;
    for(;;){
     if(typeof s === "number") return accu;
     if(0 === s[0]){var v = s[1]; return caml_call2(f, v, accu);}
     var
      r = s[3],
      v$0 = s[2],
      l = s[1],
      accu$0 = caml_call2(f, v$0, fold_right(r, accu, f));
     s = l;
     accu = accu$0;
    }
   }
   function for_all(t$0, p){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 1;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v);}
     var r = t[3], v$0 = t[2], l = t[1], a = caml_call1(p, v$0);
     if(a){
      var b = for_all(l, p);
      if(b){t = r; continue;}
      var c = b;
     }
     else
      var c = a;
     return c;
    }
   }
   function exists(t$0, p){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v);}
     var r = t[3], v$0 = t[2], l = t[1], a = caml_call1(p, v$0);
     if(a)
      var b = a;
     else{var c = exists(l, p); if(! c){t = r; continue;} var b = c;}
     return b;
    }
   }
   function filter(s, p){
    function filt(t){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v) ? t : 0;}
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = filt(l),
      keep_v = caml_call1(p, v$0),
      r$0 = filt(r);
     if(keep_v && l === l$0 && r === r$0) return t;
     return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
    }
    return filt(s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu$1, param$0){
     var accu = accu$1, param = param$0;
     for(;;){
      if(typeof param === "number") return accu;
      if(0 === param[0]){
       var v = param[1], match = caml_call1(p, v);
       if(! match) return accu;
       var v$0 = match[1];
       return add(accu, v$0, compare_elt);
      }
      var
       r = param[3],
       v$1 = param[2],
       l = param[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], a = add(accu, v$2, compare_elt);
      else
       var a = accu;
      var accu$0 = filt(a, l);
      accu = accu$0;
      param = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p){
    function loop(t){
     if(typeof t === "number") return q;
     if(0 === t[0]){
      var v = t[1];
      return caml_call1(p, v) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l),
      l_f = match[2],
      l_t = match[1],
      keep_v_t = caml_call1(p, v$0),
      match$0 = loop(r),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(keep_v, l$0, r$0){
      if(keep_v && l === l$0 && r === r$0) return t;
      return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
     }
     var a = mk(1 - keep_v_t, l_f, r_f);
     return [0, mk(keep_v_t, l_t, r_t), a];
    }
    return loop(s);
   }
   function elements_aux(accu$1, param$0){
    var accu = accu$1, param = param$0;
    for(;;){
     if(typeof param === "number") return accu;
     if(0 === param[0]){var v = param[1]; return [0, v, accu];}
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      accu$0 = [0, v$0, elements_aux(accu, r)];
     accu = accu$0;
     param = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var
    not_found = [0, Base_Import[297], [0, "Set.choose_exn: empty set"]],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    r = [0, cst_src_set_ml, 1120, 8],
    s = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ";
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    return Base_List[20].call
            (null,
             lst,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_sequence(sequence, compare_elt){
    return Base_Sequence[11].call
            (null,
             sequence,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_array(a, compare_elt){
    return Base_Array[21].call
            (null,
             a,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = Base_Array[48].call(null, s, v$0),
     pos_ref = [0, 0];
    function loop(param$0){
     var param = param$0;
     for(;;){
      if(typeof param === "number") return;
      if(0 === param[0]){
       var v = param[1], a = pos_ref[1];
       caml_check_bound(res, a)[a + 1] = v;
       pos_ref[1]++;
       return;
      }
      var r = param[3], v$0 = param[2], l = param[1];
      loop(l);
      var b = pos_ref[1];
      caml_check_bound(res, b)[b + 1] = v$0;
      pos_ref[1]++;
      param = r;
     }
    }
    loop(l);
    pos_ref[1]++;
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var x = choose_exn(set$0);
     let x$0 = x;
     var
      match =
        partition_tf
         (set$0,
          function(elt){
           var a = x$0 === elt ? 1 : 0;
           return a ? a : caml_call2(equiv, x$0, elt);
          }),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes];
     set$0 = not_equiv_x;
     equiv_classes = equiv_classes$0;
    }
   }
   function find(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t[3], v$0 = t[2], l = t[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     t = r;
    }
   }
   function find_map(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(f, v);}
     var r = t[3], v$0 = t[2], l = t[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     t = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return Base_Import[124].call(null, cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t$0, i$1){
    var t = t$0, i = i$1;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return 0 === i ? [0, v] : 0;}
     var s = t[5], r = t[3], v$0 = t[2], l = t[1];
     if(s <= i) return 0;
     var l_size = length(l), c = caml_int_compare(i, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       a = Base_Import[93].call(null, i, l_size),
       i$0 = Base_Import[93].call(null, a, 1);
      t = r;
      i = i$0;
     }
     else
      t = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return Base_List[63].call(null, leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      xs$0 = tl;
     else{
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers];
      xs$0 = tl;
      leftovers = leftovers$0;
      already_seen = already_seen$0;
     }
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return Base_Import[156].call(null, cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = Base_List[53].call(null, lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     a = Base_List[45].call(null, lst);
    if(length(set) === a) return set;
    var set$0 = [0, empty_without_value_restrictio];
    Base_List[67].call
     (null,
      lst,
      elt_lst,
      function(el_sexp, el){
       return mem(set$0[1], el, compare_elt)
               ? Base_Import
                  [156].call
                 (null, cst_Set_t_of_sexp_duplicate_el, el_sexp)
               : (set$0[1] = add(set$0[1], el, compare_elt), 0);
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, r], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return s;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     a = Base_Import[112].call(null, cst_is_not_a_subset_of, superset[2]),
     b = Base_Import[112].call(null, subset[2], a),
     c =
       Base_Sexp[10].call
        (null, b, [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return Base_Or_error[39].call(null, c);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function like_maybe_no_op(old_t, tree){
    var old_tree = old_t[2], comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function comparator_s(t){return Base_Comparator[5].call(null, t[1]);}
   function invariants$0(t){
    var a = compare_elt(t);
    return invariants(t[2], a);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list(t){var s = t[2]; return elements(s);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return Base_Container[8].call(null, fold$0, init, f, t);
   }
   function iter$0(t, f){return iter(t[2], f);}
   function iter2$0(a, b, f){
    var c = compare_elt(a);
    return iter2(a[2], b[2], c, f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var b = compare_elt(t); return mem(t[2], a, b);}
   function filter$0(t, f){return like_maybe_no_op(t, filter(t[2], f));}
   function add$0(t, a){
    var b = compare_elt(t);
    return like(t, add(t[2], a, b));
   }
   function remove$0(t, a){
    var b = compare_elt(t);
    return like(t, remove(t[2], a, b));
   }
   function union$0(t1, t2){
    var a = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], a));
   }
   function inter$0(t1, t2){
    var a = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], a));
   }
   function diff$0(t1, t2){
    var a = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], a));
   }
   function symmetric_diff$0(t1, t2){
    var a = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], a);
   }
   function compare_direct(t1, t2){
    var a = t2[2], b = t1[2];
    return compare(compare_elt(t1), b, a);
   }
   function equal$0(t1, t2){
    var a = compare_elt(t1);
    return equal(t1[2], t2[2], a);
   }
   function is_subset$1(t, of){
    var a = compare_elt(t);
    return is_subset(t[2], of[2], a);
   }
   function are_disjoint$0(t1, t2){
    var a = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], a);
   }
   function to_named_tree(named){return [0, named[1][2], named[2]];}
   function is_subset$2(subset, superset){
    var
     a = compare_elt(subset[1]),
     b = subset[1][1][2],
     c = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), c, b, a);
   }
   function equal$1(t1, t2){
    var a = [0, is_subset$2(t2, t1), 0], b = [0, is_subset$2(t1, t2), a];
    return Base_Or_error[51].call(null, b);
   }
   function partition_tf$0(t, f){
    var
     match = partition_tf(t[2], f),
     tree_f = match[2],
     tree_t = match[1],
     a = like_maybe_no_op(t, tree_f);
    return [0, like_maybe_no_op(t, tree_t), a];
   }
   function split$0(t, a){
    var
     c = compare_elt(t),
     match = split(t[2], a, c),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     d = like(t, tree2);
    return [0, like(t, tree1), b, d];
   }
   function split_le_gt$0(t, a){
    var
     b = compare_elt(t),
     match = split_le_gt(t[2], a, b),
     tree2 = match[2],
     tree1 = match[1],
     c = like(t, tree2);
    return [0, like(t, tree1), c];
   }
   function split_lt_ge$0(t, a){
    var
     b = compare_elt(t),
     match = split_lt_ge(t[2], a, b),
     tree2 = match[2],
     tree1 = match[1],
     c = like(t, tree2);
    return [0, like(t, tree1), c];
   }
   function group_by$0(t, equiv){
    var a = group_by(t[2], equiv);
    return Base_List[53].call(null, a, function(a){return like(t, a);});
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var a = compare_elt(t);
    return like(t, remove_index(t[2], i, a));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], a = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, a), hash_fold_elem);
   }
   function compare$0(a, param, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$0(t){return elements(t);}
   function to_array$1(t){return to_array(t);}
   function iter$1(t, f){return iter(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(t, f){return filter(t, f);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1], f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(a){return a;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(t, equiv){return group_by(t, equiv);}
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function split_le_gt$1(comparator, t, a){
    return split_le_gt(t, a, comparator[1]);
   }
   function split_lt_ge$1(comparator, t, a){
    return split_lt_ge(t, a, comparator[1]);
   }
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return Base_Container[8].call(null, fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     a = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     b = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), a];
    return Base_Or_error[51].call(null, b);
   }
   var Named = [0, is_subset$4, equal$3];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    var tree = t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
    return [0, comparator, tree];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    var tree = union_list(comparator, to_tree$0, l);
    return [0, comparator, tree];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    var tree = of_increasing_iterator_uncheck(len, f);
    return [0, comparator, tree];
   }
   function of_sorted_array$1(comparator, array){
    var a = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[21][2],
             a,
             function(tree){return [0, comparator, tree];});
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   var to_comparator = Base_Comparator[4], t = [0, "_"];
   function empty$1(m){
    var comparator = to_comparator(m);
    return [0, comparator, empty_without_value_restrictio];
   }
   function singleton$1(m, a){return singleton$0(to_comparator(m), a);}
   function union_list$2(m, a){return union_list$1(to_comparator(m), a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(to_comparator(m), a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(to_comparator(m), len, f);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(to_comparator(m), a);
   }
   function of_list$2(m, a){return of_list$1(to_comparator(m), a);}
   function of_sequence$2(m, a){return of_sequence$1(to_comparator(m), a);}
   function of_array$2(m, a){return of_array$1(to_comparator(m), a);}
   function stable_dedup_list$2(m, a){
    return stable_dedup_list$1(to_comparator(m), a);
   }
   function map$2(m, a, f){return map$1(to_comparator(m), a, f);}
   function filter_map$2(m, a, f){
    return filter_map$1(to_comparator(m), a, f);
   }
   function of_tree$1(m, tree){
    var comparator = to_comparator(m);
    return [0, comparator, tree];
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t$0){
    return sexp_of_t$0(Elt[1], function(param){return t;}, t$0);
   }
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var a = Base_Import[194].call(null, Elt[1]);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt, state){
    var a = Elt[1];
    return function(b){return hash_fold_direct(a, state, b);};
   }
   function hash_m_t(folder, t){
    var state = hash_fold_m_t(folder, Base_Hash[11].call(null, 0, 0))(t);
    return Base_Hash[9].call(null, state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$2(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    a = Base_Sequence[57],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$0,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       split_le_gt$0,
       split_lt_ge$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, a[1], a[6], a[7]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         length$1,
         is_empty$1,
         iter$1,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$0,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         Named,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         split_le_gt$1,
         split_lt_ge$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$0,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator_s,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       to_tree$0,
       of_tree$1,
       [0,
        length$0,
        is_empty$0,
        iter$0,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$2]];
   runtime.caml_register_global(48, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
//# shape: Base__Ref:[N,N,N,N,F(2)*,F(2),F(2),F(1)*,F(2),F(2),F(3),N,F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare_local = Base_Import[266],
    compare = Base_Import[238],
    equal_local = Base_Import[280],
    equal = Base_Import[252],
    globalize = Base_Import[296],
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144];
   function t_sexp_grammar(a_sexp_grammar){
    return Base_Import[191].call(null, a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    return Base_Exn[13].call
            (null, f, function(param){t[1] = restore_to; return 0;});
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return Base_List[19].call(null, ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = Base_List[53].call(null, and_values, snapshot);
    sets(and_values);
    return Base_Exn[13].call
            (null, f, function(param){return sets(restore_to);});
   }
   var
    Base_Ref =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
//# shape: Base__Queue_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
//# shape: Base__Queue:[F(3),F(3),F(2),F(2),F(2),F(1)*,N,F(1)*,F(1)*,F(2),F(3),N,N,N,N,N,N,N,N,F(1),F(1),N,N,F(3),F(2),N,N,N,N,N,F(1),F(1),F(1),F(2),F(2),F(2),F(1),F(1),F(1),F(3),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(4),F(2),F(3),F(1)*,F(2),[F(1)*,F(2)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    a = [0, "elts"],
    b = [0, cst_length$2],
    c = [0, "mask"],
    d = [0, "front"],
    e = [0, "num_mutations"],
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    f = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    g = [0, cst_src_queue_ml, 184, 9],
    h = [0, cst_src_queue_ml, 178, 2],
    i = [0, cst_src_queue_ml, 177, 2],
    j = [0, cst_src_queue_ml, 176, 2],
    k = [0, cst_src_queue_ml, 175, 2],
    l = [0, cst_src_queue_ml, 174, 2],
    m = [0, cst_src_queue_ml, 172, 2],
    n = [0, cst_src_queue_ml, 171, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    o = [0, cst_src_queue_ml, 212, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    dummy = 0;
   function globalize(param, t){
    var a = Base_Option_array[58].call(null, t[5]);
    return [0, t[1], t[2], t[3], t[4], a];
   }
   function inc_num_mutations(t){t[1] = Base_Import[91].call(null, t[1], 1);}
   function capacity(t){return Base_Import[91].call(null, t[3], 1);}
   function elts_index(t, i){
    var a = t[3], b = Base_Import[91].call(null, t[2], i);
    return Base_Import[116].call(null, b, a);
   }
   function unsafe_get(t, i){
    var a = elts_index(t, i);
    return Base_Option_array[40].call(null, t[5], a);
   }
   function unsafe_set(t, i, a){
    var b = elts_index(t, i);
    return Base_Option_array[51].call(null, t[5], b, a);
   }
   function check_index_exn(t, i){
    var b = i < 0 ? 1 : 0, a = b || (t[4] <= i ? 1 : 0);
    if(! a) return a;
    var
     c = [0, [0, cst_length, caml_call1(Base_Int[10], t[4])], 0],
     d = [0, [0, cst_index, caml_call1(Base_Int[10], i)], c],
     e = Base_Sexp[10].call(null, cst_Queue_index_out_of_bounds, d);
    return Base_Error[32].call(null, e);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var g = t[1] !== num_mutations ? 1 : 0;
    if(! g) return g;
    var param = globalize(0, t);
    function of_a_001(param){return f;}
    var
     num_mutations_003 = param[1],
     front_005 = param[2],
     mask_007 = param[3],
     length_009 = param[4],
     elts_011 = param[5],
     arg_012 = Base_Option_array[2].call(null, of_a_001, elts_011),
     bnds_002 = [0, [1, [0, a, [0, arg_012, 0]]], 0],
     arg_010 = Base_Import[139].call(null, length_009),
     bnds_002$0 = [0, [1, [0, b, [0, arg_010, 0]]], bnds_002],
     arg_008 = Base_Import[139].call(null, mask_007),
     bnds_002$1 = [0, [1, [0, c, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = Base_Import[139].call(null, front_005),
     bnds_002$2 = [0, [1, [0, d, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = Base_Import[139].call(null, num_mutations_003),
     bnds_002$3 = [0, [1, [0, e, [0, arg_004, 0]]], bnds_002$2],
     h =
       Base_Sexp[10].call
        (null,
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], 0]);
    return Base_Error[32].call(null, h);
   }
   function compare_local(compare_elt, t1, t2){
    if(t1 === t2) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      a = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), a);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = Base_Import[91].call(null, pos, 1);
     pos = pos$0;
    }
   }
   function compare(compare_elt, t1, t2){
    return compare_local(compare_elt, t1, t2);
   }
   function equal_local(equal_elt, t1, t2){
    var d = t1 === t2 ? 1 : 0;
    if(d)
     var e = d;
    else{
     var len1 = t1[4], len2 = t2[4], f = len1 === len2 ? 1 : 0;
     if(f){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var a = pos === len1 ? 1 : 0;
       if(a)
        var c = a;
       else{
        var
         g = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), g);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = Base_Import[91].call(null, pos, 1);
         pos = pos$0;
         continue;
        }
        var c = b;
       }
       return c;
      }
     }
     var e = f;
    }
    return e;
   }
   function equal(equal_elt, t1, t2){return equal_local(equal_elt, t1, t2);}
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, n], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== Base_Option_array[28].call(null, elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, l], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
    if(! Base_Int[72].call(null, capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
    var a = Base_Import[93].call(null, capacity$0, 1), c = 0;
    if(a >= 0){
     var i$0 = c;
     for(;;){
      if(i$0 < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i$0));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var b = elts_index(t, i$0);
       if(Base_Option_array[42].call(null, t[5], b))
        throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
      }
      var d = i$0 + 1 | 0;
      if(a === i$0) break;
      i$0 = d;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var
       capacity$1 = 0 === capacity$0 ? 1 : Base_Int[68].call(null, capacity$0);
     else
      var
       b = [0, [0, cst_capacity, caml_call1(Base_Int[10], capacity$0)], 0],
       c = Base_Sexp[10].call(null, cst_cannot_have_queue_with_neg, b),
       capacity$1 = Base_Error[32].call(null, c);
    }
    else
     var capacity$1 = 2;
    var a = Base_Option_array[5].call(null, capacity$1);
    return [0, 0, 0, Base_Import[93].call(null, capacity$1, 1), 0, a];
   }
   function blit_to_array(src, dst){
    var a = Base_Option_array[28].call(null, dst);
    if(src[4] > a)
     throw caml_maybe_attach_backtrace([0, Assert_failure, o], 1);
    var
     b = src[2],
     c = capacity(src),
     d = Base_Import[93].call(null, c, b),
     front_len = Base_Int[15].call(null, src[4], d),
     rest_len = Base_Import[93].call(null, src[4], front_len);
    caml_call5(Base_Option_array[53], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[53], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity_internal(t, new_capacity){
    var dst = Base_Option_array[5].call(null, new_capacity);
    blit_to_array(t, dst);
    t[2] = 0;
    t[3] = Base_Import[93].call(null, new_capacity, 1);
    t[5] = dst;
    return 0;
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     b = Base_Import[100].call(null, desired_capacity, t[4]),
     c = Base_Import[100].call(null, 1, b),
     new_capacity = Base_Int[68].call(null, c),
     a = new_capacity !== capacity(t) ? 1 : 0;
    return a ? set_capacity_internal(t, new_capacity) : a;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var b = capacity(t);
    if(t[4] === b)
     set_capacity_internal(t, Base_Import[88].call(null, 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = Base_Import[91].call(null, t[4], 1);
    return 0;
   }
   function enqueue_front(t, a){
    inc_num_mutations(t);
    var b = capacity(t);
    if(t[4] === b)
     set_capacity_internal(t, Base_Import[88].call(null, 2, t[4]));
    var
     c = t[3],
     d = Base_Import[93].call(null, t[2], 1),
     front = Base_Import[116].call(null, d, c);
    t[2] = front;
    t[4] = Base_Import[91].call(null, t[4], 1);
    return unsafe_set(t, 0, a);
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = Base_Option_array[36].call(null, elts, front);
    Base_Option_array[45].call(null, elts, front);
    t[2] = elts_index(t, 1);
    t[4] = Base_Import[93].call(null, t[4], 1);
    return res;
   }
   function back_index(t){
    return elts_index(t, Base_Import[93].call(null, t[4], 1));
   }
   function dequeue_back_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     back = back_index(t),
     res = Base_Option_array[36].call(null, elts, back);
    Base_Option_array[45].call(null, elts, back);
    t[4] = Base_Import[93].call(null, t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function dequeue_and_ignore_exn(t){dequeue_exn(t); return 0;}
   function dequeue_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_back_nonempty(t);
   }
   function dequeue_back(t){
    return is_empty(t) ? 0 : [0, dequeue_back_nonempty(t)];
   }
   function front_nonempty(t){
    return Base_Option_array[40].call(null, t[5], t[2]);
   }
   function back_nonempty(t){
    var a = back_index(t);
    return Base_Option_array[40].call(null, t[5], a);
   }
   function last_nonempty(t){
    return unsafe_get(t, Base_Import[93].call(null, t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function peek_back(t){return is_empty(t) ? 0 : [0, back_nonempty(t)];}
   function peek_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return back_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function drain(t, f, while$){
    for(;;){
     if(! is_empty(t) && caml_call1(while$, front_nonempty(t))){caml_call1(f, dequeue_nonempty(t)); continue;}
     return 0;
    }
   }
   function clear(t){
    inc_num_mutations(t);
    var a = 0 < t[4] ? 1 : 0;
    if(a){
     var b = Base_Import[93].call(null, t[4], 1), e = 0;
     if(b >= 0){
      var i = e;
      for(;;){
       var d = elts_index(t, i);
       Base_Option_array[52].call(null, t[5], d);
       var f = i + 1 | 0;
       if(b === i) break;
       i = f;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var c = 0;
    }
    else
     var c = a;
    return c;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       d = [0, [0, cst_length$0, caml_call1(Base_Int[10], len$0)], 0],
       e = Base_Sexp[10].call(null, cst_Queue_blit_transfer_negati, d);
      Base_Error[32].call(null, e);
     }
     var len$1 = Base_Import[101].call(null, len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var a = 0 < len$1 ? 1 : 0;
    if(a){
     var f = Base_Import[91].call(null, dst[4], len$1), g = capacity(dst);
     set_capacity(dst, Base_Import[100].call(null, g, f));
     var
      dst_start = Base_Import[91].call(null, dst[2], dst[4]),
      b = Base_Import[93].call(null, len$1, 1),
      h = 0;
     if(b >= 0){
      var i = h;
      for(;;){
       var
        l = src[3],
        m = Base_Import[91].call(null, src[2], i),
        src_i = Base_Import[116].call(null, m, l),
        n = dst[3],
        o = Base_Import[91].call(null, dst_start, i),
        dst_i = Base_Import[116].call(null, o, n),
        p = Base_Option_array[40].call(null, src[5], src_i);
       Base_Option_array[51].call(null, dst[5], dst_i, p);
       Base_Option_array[52].call(null, src[5], src_i);
       var q = i + 1 | 0;
       if(b === i) break;
       i = q;
      }
     }
     dst[4] = Base_Import[91].call(null, dst[4], len$1);
     var j = src[3], k = Base_Import[91].call(null, src[2], len$1);
     src[2] = Base_Import[116].call(null, k, j);
     src[4] = Base_Import[93].call(null, src[4], len$1);
     var c = 0;
    }
    else
     var c = a;
    return c;
   }
   function enqueue_all(t, l){
    var
     a = Base_List[45].call(null, l),
     b = Base_Import[91].call(null, t[4], a),
     c = capacity(t);
    set_capacity(t, Base_Int[16].call(null, c, b));
    return Base_List[19].call(null, l, function(x){return enqueue(t, x);});
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     a = Base_Import[93].call(null, t[4], 1),
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], c);
      ensure_no_mutation(t, num_mutations);
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = Base_Import[91].call(null, i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var num_mutations = t[1], a = Base_Import[93].call(null, t[4], 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var num_mutations = t[1], a = Base_Import[93].call(null, t[4], 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], a = Base_Import[93].call(null, t[4], 1);
    if(a >= 0){
     var i = a;
     for(;;){
      var b = result[1];
      result[1] = [0, unsafe_get(t, i), b];
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      Base_Indexed_container[8].call
       (null, [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    p = [0, cst_src_queue_ml, 507, 2],
    q = [0, 1];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var b = caml_call1(f, a);
       return Base_List[19].call
               (null, b, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var b = caml_call2(f, i, a);
       return Base_List[19].call
               (null, b, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var b = caml_call1(f, a);
       return b ? enqueue(t_result, a) : b;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var b = caml_call2(f, i, a);
       return b ? enqueue(t_result, a) : b;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, Base_List[45].call(null, l)], 0);
    Base_List[19].call(null, l, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      b = [0, [0, cst_length$1, caml_call1(Base_Int[10], len)], 0],
      c = Base_Sexp[10].call(null, cst_Queue_init_negative_length, b);
     Base_Error[32].call(null, c);
    }
    var t = create([0, len], 0);
    if(len > Base_Option_array[28].call(null, t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, p], 1);
    var a = Base_Import[93].call(null, len, 1), d = 0;
    if(a >= 0){
     var i = d;
     for(;;){
      var e = caml_call1(f, i);
      Base_Option_array[51].call(null, t[5], i, e);
      var g = i + 1 | 0;
      if(a === i) break;
      i = g;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(b){return a[b + 1];});
   }
   function to_array(t){
    return Base_Array[41].call
            (null, t[4], function(i){return unsafe_get(t, i);});
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var a = Base_Import[93].call(null, ta[4], 1), c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      Base_Option_array[51].call(null, tb[5], i, b);
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = Base_Import[91].call(null, i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(q, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var a = to_list(t);
    return Base_List[6].call(null, sexp_of_a, a);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(Base_List[5].call(null, a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var a = Base_List[7].call(null, grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function start(q){return q[1];}
   function assert_no_mutation_since_start(t, q){return ensure_no_mutation(q, t);
   }
   var
    Iteration = [0, start, assert_no_mutation_since_start],
    Base_Queue =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       equal_local,
       invariant,
       create,
       last,
       last_exn,
       enqueue_front,
       dequeue_back,
       dequeue_back_exn,
       peek_back,
       peek_back_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity,
       Iteration];
   runtime.caml_register_global(39, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Sexplib0__Sexp_conv_error
//# shape: Base__Nothing:[N,F(1),N,F(1),F(1),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(2),F(2),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    a = [0, "src/nothing.ml", 6, 31];
   function unreachable_code_local(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, a], 1);
   }
   function unreachable_code(x){return unreachable_code_local(x);}
   var
    cst_Base_Nothing_t = "Base.Nothing.t",
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported";
   function hash_fold_t(param, t){return unreachable_code_local(t);}
   function compare(a, param){return unreachable_code_local(a);}
   function compare_local(a, param){return unreachable_code_local(a);}
   function equal_local(a, param){return unreachable_code_local(a);}
   function t_of_sexp(sexp){
    return Sexplib0_Sexp_conv_error[30].call(null, cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return Base_Import[124].call(null, cst_Base_Nothing_of_string_not);
   }
   var
    include =
      Base_Identifiable[1].call
       (null,
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function must_be_none(param){return 0;}
   function must_be_empty(param){return 0;}
   function must_be_ok(param){var ok = param[1]; return ok;}
   function must_be_error(param){var error = param[1]; return error;}
   function must_be_first(param){var first = param[1]; return first;}
   function must_be_second(param){var second = param[1]; return second;}
   var
    Base_Nothing =
      [0,
       0,
       unreachable_code,
       t_sexp_grammar,
       unreachable_code,
       unreachable_code_local,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       must_be_none,
       must_be_empty,
       must_be_ok,
       must_be_error,
       must_be_first,
       must_be_second];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
//# shape: Base__Nativeint:[F(1)*,N,F(1),F(1)*,F(1)*,F(1),N,F(1),F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1),N,N,N,N,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1)*,N,N,F(2),F(2),N,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,N,N,N,F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(1)*,F(1),F(1)*,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    include = Base_Import[104],
    compare = include[9],
    globalize = Base_Import[287],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[104][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Nativeint[14],
    comparator = Base_Comparator[7].call(null, [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    b = Base_Comparable[14].call(null, [0, compare$0, sexp_of_t, zero]),
    is_positive = b[1],
    is_non_negative = b[2],
    is_negative = b[3],
    is_non_positive = b[4],
    sign = b[5],
    include$0 = Base_Int_string_conversions[1].call(null, [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare_local = Base_Import[259];
   function compare$1(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[202], func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(a){return - a | 0;}
   var
    symbol = Base_Import[104][1],
    c = [0, [6, 6, 0, 0, 0], cst_nx],
    d = [0, [6, 6, 0, 0, 0], cst_nx];
   function to_string$0(i){
    return caml_call1(Base_Printf[2].call(null, c), i);
   }
   function of_string$0(s){
    return caml_call1
            (Stdlib_Scanf[5].call(null, s, d), function(a){return a;});
   }
   var
    include$1 =
      Base_Int_string_conversions[2].call
       (null,
        [0,
         compare$1,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      Base_Pretty_printer[2].call(null, [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = Base_Word_size[2].call(null, Base_Word_size[3]),
    float_lower_bound = Base_Float0[26].call(null, num_bits),
    float_upper_bound = Base_Float0[24].call(null, num_bits);
   function shift_right_logical(b, a){return b >>> a | 0;}
   function shift_right(b, a){return b >> a;}
   function shift_left(b, a){return b << a;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(b, a){return b ^ a;}
   function bit_or(b, a){return b | a;}
   function bit_and(b, a){return b & a;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(a){return - a | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1],
    e =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"];
   function to_float(a){return a;}
   function of_float_unchecked(a){return a | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var a = Base_Float0[29].call(null, f);
    return caml_call2(Base_Printf[7].call(null, e), a, 0);
   }
   var
    raise_s = Base_Error[32],
    f =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    g = [0, "src/nativeint.ml", 206, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function non_positive_argument(param){
    return caml_call1(Base_Printf[7].call(null, f), 0);
   }
   function lsr(b, a){return b >>> a | 0;}
   function land(b, a){return b & a;}
   function ceil_pow2(x){
    if(Base_Import[104][2].call(null, x, 0)) non_positive_argument(0);
    var
     x$0 = Stdlib_Nativeint[7].call(null, x),
     x$6 = x$0 | x$0 >>> 1 | 0,
     x$5 = x$6 | x$6 >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return Stdlib_Nativeint[6].call(null, x$1);
   }
   function floor_pow2(x$0){
    if(Base_Import[104][2].call(null, x$0, 0)) non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$5 = x | x >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(Base_Import[104][2].call(null, x, 0)) non_positive_argument(0);
    var a = x & Stdlib_Nativeint[7].call(null, x);
    return Base_Import[104][4].call(null, a, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var a = [0, [0, cst, Base_Import[143].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Nativeint_floor_log2_got_i, a));
    }
    var
     b = runtime.Base_int_math_nativeint_clz(i),
     c = Base_Import[93].call(null, num_bits, 1);
    return Base_Import[93].call(null, c, b);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var a = [0, [0, cst$0, Base_Import[143].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Nativeint_ceil_log2_got_in, a));
    }
    if(Stdlib_Nativeint[18].call(null, i, Stdlib_Nativeint[2])) return 0;
    var
     b =
       runtime.Base_int_math_nativeint_clz(Stdlib_Nativeint[7].call(null, i));
    return Base_Import[93].call(null, num_bits, b);
   }
   function between(t, low, high){
    var a = Base_Import[104][2].call(null, low, t);
    return a ? Base_Import[104][2].call(null, t, high) : a;
   }
   function clamp_unchecked(t, min, max){
    var a = Base_Import[104][14].call(null, t, max);
    return Base_Import[104][13].call(null, min, a);
   }
   function clamp_exn(t, min, max){
    if(Base_Import[104][2].call(null, min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
   }
   function clamp(t, min, max){
    if(! Base_Import[104][5].call(null, min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(b, a){return b - a | 0;}
   function symbol$4(b, a){return b + a | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[23],
    to_int_exn = Base_Int_conversions[24],
    to_int_trunc = Base_Int_conversions[25],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[26],
    to_int32_exn = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[18],
    of_int64_exn = Base_Int_conversions[19],
    of_int64_trunc = Base_Int_conversions[20],
    to_int64 = Base_Int_conversions[29];
   function pow(b, e){
    var a = to_int_exn(e), c = to_int_exn(b);
    return of_int_exn(Base_Int_math[2][1].call(null, c, a));
   }
   function symbol$5(b, e){return pow(b, e);}
   var compare_local$0 = Base_Import[259];
   function compare$2(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[273];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[202], func$1 = Base_Import[216];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(a){return runtime.Base_int_math_nativeint_clz(a);}
   var
    Binary =
      Base_Int_string_conversions[3].call
        (null,
         [0,
          compare$2,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int_exn,
          num_bits,
          one,
          zero$1])
       [1],
    a = Base_Import[104],
    symbol$6 = a[3],
    symbol$7 = a[1],
    symbol$8 = a[5],
    symbol$9 = a[4],
    symbol$10 = a[2],
    symbol$11 = a[6],
    include$3 =
      Base_Int_math[1].call
       (null,
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[104],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$3 = include$4[9],
    compare_local$1 = include$4[10],
    equal$0 = include$4[11],
    equal_local$0 = include$4[12],
    max = include$4[13],
    min = include$4[14],
    Base_Nativeint =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal$0,
       compare$3,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local$1,
       equal_local$0,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(a){return runtime.Base_int_math_nativeint_clz(a);},
       function(a){return runtime.Base_int_math_nativeint_ctz(a);},
       [0,
        symbol$4,
        symbol$3,
        symbol$2,
        symbol$1,
        symbol$0,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$0,
        zero$1,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       of_int64_trunc,
       runtime.caml_int32_bswap];
   runtime.caml_register_global(35, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
//# shape: Base__Map:[[F(2)*,N,F(2)*,F(1)*,F(1)*,F(1)*],[F(4),F(4),F(3),F(1)*,F(1)*,F(2)*,F(2)*,F(3)*],F(1),F(1)*,F(1)*,F(1)*,F(2)*->F(1)*,F(2),F(2),F(2),F(2),F(4),F(3),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(4),F(3),F(3),F(3),F(3),F(3),F(5),F(4),F(1)*,F(1)*,F(3),F(3),F(3),F(3),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(2),F(2),F(3),F(3),F(3),F(4),F(3),F(4),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(1),F(3),F(4),F(3),F(1),F(1),F(2),F(3),F(2),F(3),[F(4),F(4),F(3),F(3),F(2)*],F(3),F(5),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(2),F(2),F(3),F(5),F(3),F(3),F(2),F(2),F(2),F(4),F(4),F(3),F(4),F(1)*,F(1)*,F(3),F(3),F(2)*,F(4),F(4),F(3)*->F(1),N,N,F(2),F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "alist",
    name$0 = "sequence",
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Comparator = global_data.Base__Comparator,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4];
   function of_continue_or_stop(a){return a;}
   function to_continue_or_stop(a){return a;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var variant = param[1];
    if(737457313 === variant)
     var left = param[2][1];
    else{if(847852583 > variant) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var variant = param[1];
    if(737457313 === variant)
     var right = param[2][2];
    else{if(847852583 <= variant) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$){
    var variant = t[1];
    if(737457313 === variant)
     var left = t[2][1];
    else{if(847852583 > variant) return default$; var left = t[2];}
    return left;
   }
   function right_value(t, default$){
    var variant = t[1];
    if(737457313 === variant)
     var right = t[2][2];
    else{if(847852583 <= variant) return default$; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var variant = t[1];
    if(737457313 === variant){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= variant){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, "Base__Map.Duplicate", caml_fresh_oo_id(0)],
    a = [0, "map.ml.Duplicate"],
    b = [0, cst_src_map_ml, 67, 11];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Duplicate,
     function(param){
      if(param === Duplicate) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
     });
   var
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_Map_bal = cst_Map_bal$3,
    c = [0, cst_src_map_ml, 248, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    d = [0, cst_src_map_ml, 263, 18],
    cst_Map_bal$2 = cst_Map_bal$3;
   function globalize(param){
    var length = param[2], tree = param[1];
    return [0, tree, length];
   }
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      a = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var a = 1;
    if(a){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var b = 1;
    }
    else
     var b = a;
    return b;
   }
   function loop(lower$1, upper, compare_key, t$0){
    var lower = lower$1, t = t$0;
    for(;;){
     if(typeof t === "number") return 1;
     if(0 === t[0]){
      var k = t[1];
      return in_range(lower, upper, compare_key, k);
     }
     var
      h = t[5],
      r = t[4],
      k$0 = t[2],
      l = t[1],
      hl = height(l),
      hr = height(r),
      f = Base_Import[93].call(null, hl, hr),
      b = Base_Import[123].call(null, f) <= 2 ? 1 : 0;
     if(b){
      var
       g = Base_Import[100].call(null, hl, hr),
       c = h === Base_Import[91].call(null, g, 1) ? 1 : 0;
      if(c){
       var d = in_range(lower, upper, compare_key, k$0);
       if(d){
        var e = loop(lower, [0, k$0], compare_key, l);
        if(e){var lower$0 = [0, k$0]; lower = lower$0; t = r; continue;}
        var a = e;
       }
       else
        var a = d;
      }
      else
       var a = c;
     }
     else
      var a = b;
     return a;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create_with_heights(hl, hr, l, x, d, r){
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     a =
       hr <= hl
        ? Base_Import[91].call(null, hl, 1)
        : Base_Import[91].call(null, hr, 1);
    return [1, l, x, d, r, a];
   }
   function create(l, x, d, r){
    var a = height(r);
    return create_with_heights(height(l), a, l, x, d, r);
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, Base_Import[91].call(null, i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, Base_Import[91].call(null, i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, Base_Import[91].call(null, i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = Base_Import[120].call(null, n, 1),
      a = Base_Import[93].call(null, n, left_length),
      right_length = Base_Import[93].call(null, a, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, Base_Import[91].call(null, i, left_length)),
      v = match[2],
      k = match[1],
      b = Base_Import[91].call(null, i, left_length),
      right = loop(right_length, f, Base_Import[91].call(null, b, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            b = Base_Import[93].call(null, array_length, 1),
            a = Base_Import[93].call(null, b, i);
           return caml_check_bound(array, a)[a + 1];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[i + 1];};
    }
    var tree = of_increasing_iterator_uncheck(array_length, next);
    return [0, tree, array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return with_return
             (function(r){
               var
                c = caml_check_bound(array, 1)[2],
                d = Base_Import[125].call(null, c),
                e = caml_check_bound(array, 0)[1],
                i = caml_call2(compare_key, Base_Import[125].call(null, e), d),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      Base_Or_error[40].call(null, cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                a = Base_Import[93].call(null, array.length - 1, 2),
                f = 1;
               if(a >= 1){
                var i$0 = f;
                for(;;){
                 var
                  b = Base_Import[91].call(null, i$0, 1),
                  g = caml_check_bound(array, b)[b + 1],
                  h = Base_Import[125].call(null, g),
                  j = caml_check_bound(array, i$0)[i$0 + 1],
                  i$1 =
                    caml_call2(compare_key, Base_Import[125].call(null, j), h);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    Base_Or_error[40].call
                     (null, cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    Base_Or_error[40].call(null, cst_of_sorted_array_elements_a));
                 var k = i$0 + 1 | 0;
                 if(a === i$0) break;
                 i$0 = k;
                }
               }
               return [0,
                       globalize(of_sorted_array_unchecked(array, compare_key))];
              });
    return [0, globalize(of_sorted_array_unchecked(array, compare_key))];
   }
   function bal(l, x, d$0, r){
    var hl = height(l), hr = height(r);
    if(Base_Import[91].call(null, hr, 2) < hl){
     if(typeof l === "number")
      return Base_Import[126].call(null, cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], a = height(lr);
     if(a <= height(ll)) return create(ll, lv, ld, create(lr, x, d$0, r));
     if(typeof lr === "number")
      return Base_Import[126].call(null, cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], b = create(0, x, d$0, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, b);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      e = create(lrr, x, d$0, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, e);
    }
    if(Base_Import[91].call(null, hl, 2) >= hr)
     return create_with_heights(hl, hr, l, x, d$0, r);
    if(typeof r === "number")
     return Base_Import[126].call(null, cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], f = height(rl);
    if(f <= height(rr)) return create(create(l, x, d$0, rl), rv, rd, rr);
    if(typeof rl === "number")
     return Base_Import[126].call(null, cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], g = create(0, rv, rd, rr);
     return create(create(l, x, d$0, 0), rlv, rld, g);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     h = create(rlr, rv, rd, rr);
    return create(create(l, x, d$0, rll), rlv$0, rld$0, h);
   }
   var
    empty_without_value_restrictio = 0,
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    e = [1, 0];
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     a = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     b = Base_Sexp[10].call(null, cst_Map_add_exn_got_key_alread, a);
    return Base_Error[32].call(null, b);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number"){
     var
      length$0 = Base_Import[91].call(null, length, 1),
      tree = [0, x, data];
     return [0, tree, length$0];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return Base_Exn[6].call(null, Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: var tree$0 = [0, x, data]; return [0, tree$0, length];
      }
     if(0 <= c){
      var
       length$1 = Base_Import[91].call(null, length, 1),
       tree$1 = [1, 0, v, d, [0, x, data], 2];
      return [0, tree$1, length$1];
     }
     var
      length$2 = Base_Import[91].call(null, length, 1),
      tree$2 = [1, [0, x, data], v, d, 0, 2];
     return [0, tree$2, length$2];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return Base_Exn[6].call(null, Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default:
        var tree$3 = [1, l, x, data, r, h]; return [0, tree$3, length];
     }
    if(0 <= c$0)
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$3 = match[2],
      r$0 = match[1],
      length$4 = length$3,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 =
        find_and_add_or_set
         (l, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$5 = match$0[2],
      l$1 = match$0[1],
      length$4 = length$5,
      r$1 = r,
      l$0 = l$1;
    var tree$4 = bal(l$0, v$0, d$0, r$1);
    return [0, tree$4, length$4];
   }
   function set_min(key, data, t){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, [0, key, data], v, d, 0, 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = set_min(key, data, l);
    return bal(l$0, v$0, d$0, r);
   }
   function set_max(t, key, data){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, 0, v, d, [0, key, data], 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     r$0 = set_max(r, key, data);
    return bal(l, v$0, d$0, r$0);
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, function(param){return e;}, 2);
   }
   var
    empty = 0,
    f = [0, cst_src_map_ml, 480, 21],
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    g = [0, 0, 0, 0],
    h = [0, cst_src_map_ml, 578, 4],
    i = [0, "Map.find_exn: not found"];
   function max_key(param){
    if(! param) return 0;
    var key = param[1][1];
    return [0, key];
   }
   function add_unchecked(t, key, data){return [0, [0, key, data], t];}
   function to_tree_unchecked(list){
    if(! list) return 0;
    if(list[2]){
     var
      len = Base_List0[5].call(null, list),
      list$0 = [0, list],
      loop =
        function(len){
         var match = list$0[1], switcher = len - 1 | 0;
         if(2 >= switcher >>> 0)
          switch(switcher){
            case 0:
             if(match){
              var
               tail$0 = match[2],
               match$2 = match[1],
               data = match$2[2],
               key = match$2[1];
              list$0[1] = tail$0;
              return [0, key, data];
             }
             break;
            case 1:
             if(match){
              var a = match[2];
              if(a){
               var
                tail$1 = a[2],
                e = a[1],
                d1 = e[2],
                k1 = e[1],
                match$3 = match[1],
                d2 = match$3[2],
                k2 = match$3[1];
               list$0[1] = tail$1;
               return [1, 0, k1, d1, [0, k2, d2], 2];
              }
             }
             break;
            default:
             if(match){
              var b = match[2];
              if(b){
               var c = b[2];
               if(c){
                var
                 tail$2 = c[2],
                 g = c[1],
                 d1$0 = g[2],
                 k1$0 = g[1],
                 h = b[1],
                 d2$0 = h[2],
                 k2$0 = h[1],
                 match$4 = match[1],
                 d3 = match$4[2],
                 k3 = match$4[1];
                list$0[1] = tail$2;
                return [1, [0, k1$0, d1$0], k2$0, d2$0, [0, k3, d3], 2];
               }
              }
             }
          }
         var
          nr = Base_Import[95].call(null, len, 2),
          i = Base_Import[93].call(null, len, nr),
          nl = Base_Import[93].call(null, i, 1),
          r = loop(nr),
          match$0 = list$0[1];
         if(! match$0)
          throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
         var
          tail = match$0[2],
          match$1 = match$0[1],
          d = match$1[2],
          k = match$1[1];
         list$0[1] = tail;
         var l = loop(nl);
         return create(l, k, d, r);
        };
     return loop(len);
    }
    var match = list[1], data = match[2], key = match[1];
    return [0, key, data];
   }
   function of_increasing_sequence(seq, compare_key){
    return with_return
            (function(param){
              var
               match =
                 Base_Sequence[11].call
                  (null,
                   seq,
                   [0, empty, 0],
                   function(a, param$0){
                    var
                     data = param$0[2],
                     key = param$0[1],
                     length = a[2],
                     builder = a[1],
                     match = max_key(builder);
                    if(match){
                     var prev_key = match[1];
                     if(0 <= caml_call2(compare_key, prev_key, key))
                      return caml_call1
                              (param,
                               Base_Or_error[40].call(null, cst_of_increasing_sequence_non));
                    }
                    var
                     length$0 = Base_Import[91].call(null, length, 1),
                     tree = add_unchecked(builder, key, data);
                    return [0, tree, length$0];
                   }),
               length = match[2],
               builder = match[1],
               tree = to_tree_unchecked(builder);
              return [0, [0, tree, length]];
             });
   }
   function join(l, k, d, r){
    if(typeof l === "number") return set_min(k, d, r);
    if(0 !== l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set_max(set_max(l, k, d), rk, rd);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      if(Base_Import[91].call(null, rh, 3) < lh)
       var r$0 = join(lr, k, d, r), d$0 = ld$0, k$0 = lk$0, l$0 = ll;
      else if(Base_Import[91].call(null, lh, 3) < rh)
       var r$0 = rr, d$0 = rd$0, k$0 = rk$0, l$0 = join(l, k, d, rl);
      else
       var r$0 = r, d$0 = d, k$0 = k, l$0 = l;
      return bal(l$0, k$0, d$0, r$0);
     }
    }
    if(typeof r === "number") return set_max(l, k, d);
    var ld = l[2], lk = l[1];
    return set_min(lk, ld, set_min(k, d, r));
   }
   function split_gen(t, x, compare_key){
    if(typeof t === "number") return g;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call1(compare_key, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call1(compare_key, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split_gen(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join(l, k$0, d$0, rl), maybe, rr];
    }
    var
     match$0 = split_gen(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join(lr, k$0, d$0, r)];
   }
   function split(t, x, compare_key){
    return split_gen(t, x, function(y){return caml_call2(compare_key, x, y);});
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     a =
       847852583 <= into
        ? function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? 1 : res;
         }
        : function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? -1 : res;
         },
     match = split_gen(t, x, a),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(Base_Option[52].call(null, boundary_opt)) return [0, left, right];
    throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(Base_Maybe_bound[10].call(null, lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      c = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = c[2],
      left = c[1];
    else
     var
      lb$2 = lower_bound[1],
      d = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = d[2],
      left$0 = d[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      a =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = a[2],
      mid = a[1];
    else
     var
      lb$0 = upper_bound[1],
      b =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = b[2],
      mid$0 = b[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t$0, x, compare_key){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     t = 0 <= c ? r : l;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     a = find(t, key, compare_key),
     data$0 = [0, data, Base_Option[30].call(null, a, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var a = [1, [0, i, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], a], 1);
   }
   function find_exn(t$0, x, compare_key, sexp_of_key){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return if_not_found(x, sexp_of_key);
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     t = 0 <= c ? r : l;
    }
   }
   function mem(t, x, compare_key){
    var a = find(t, x, compare_key);
    return Base_Option[53].call(null, a);
   }
   function min_elt(param$0){
    var param = param$0;
    for(;;){
     if(typeof param === "number") return 0;
     if(0 === param[0]){
      var d = param[2], k = param[1];
      return [0, [0, k, d]];
     }
     var l = param[1];
     if(typeof l === "number"){
      var d$0 = param[3], k$0 = param[2];
      return [0, [0, k$0, d$0]];
     }
     param = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    j = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    k = [0, cst_src_map_ml, 664, 13];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Map_min_elt_exn_of_empty_map,
     function(param){
      if(param === Map_min_elt_exn_of_empty_map) return j;
      throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
     });
   var
    Map_max_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    l = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    m = [0, cst_src_map_ml, 677, 13];
   caml_call4
    (Sexplib0_Sexp_conv[72][1],
     0,
     0,
     Map_max_elt_exn_of_empty_map,
     function(param){
      if(param === Map_max_elt_exn_of_empty_map) return l;
      throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
     });
   var
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    n = [0, 0, 0],
    o = [0, cst_src_map_ml, 1145, 17],
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1;
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param$0){
    var param = param$0;
    for(;;){
     if(typeof param === "number") return 0;
     if(0 === param[0]){
      var d = param[2], k = param[1];
      return [0, [0, k, d]];
     }
     if(typeof param[4] === "number"){
      var d$0 = param[3], k$0 = param[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param[4];
     param = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return Base_Import[126].call(null, cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var a = match$0[1], v = a[2], min_upper = a[1], max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0, 17724, join(lower_part, min_upper, v, upper_part_without_min)];
   }
   function go(t$0, min, max, init$2, f, compare_key){
    var t = t$0, init = init$2;
    for(;;){
     if(typeof t === "number") return init;
     if(0 === t[0]){
      var d = t[2], k = t[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init);
      return init;
     }
     var
      r = t[4],
      d$0 = t[3],
      k$0 = t[2],
      l = t[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min){
       var init$0 = caml_call3(f, k$0, d$0, init);
       t = r;
       init = init$0;
      }
      else{
       var
        z = go(l, min, max, init, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$1 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$1;
       t = r;
       init = init$1;
      }
     else
      t = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     a =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return Base_List0[19].call(null, a);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   function concat_and_balance_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return join(t1, x, d, remove_min_elt(t2));
   }
   function remove(tree, x, length, compare_key){
    if(typeof tree === "number") return [0, tree, length];
    if(0 === tree[0]){
     var v = tree[1];
     if(0 !== caml_call2(compare_key, x, v)) return [0, tree, length];
     var length$0 = Base_Import[93].call(null, length, 1);
     return [0, 0, length$0];
    }
    var
     r = tree[4],
     d = tree[3],
     v$0 = tree[2],
     l = tree[1],
     c = caml_call2(compare_key, x, v$0);
    if(0 === c){
     var
      length$1 = Base_Import[93].call(null, length, 1),
      tree$0 = concat_unchecked(l, r);
     return [0, tree$0, length$1];
    }
    if(0 <= c)
     var
      match = remove(r, x, length, compare_key),
      length$2 = match[2],
      r$0 = match[1],
      length$3 = length$2,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 = remove(l, x, length, compare_key),
      length$4 = match$0[2],
      l$1 = match$0[1],
      length$3 = length$4,
      r$1 = r,
      l$0 = l$1;
    if(length === length$3) return [0, tree, length];
    var tree$1 = bal(l$0, v$0, d, r$1);
    return [0, tree$1, length$3];
   }
   function change(tree, key, f, length, compare_key){
    if(typeof tree === "number"){
     var match = caml_call1(f, 0);
     if(! match) return [0, 0, length];
     var
      data = match[1],
      length$0 = Base_Import[91].call(null, length, 1),
      tree$0 = [0, key, data];
     return [0, tree$0, length$0];
    }
    if(0 === tree[0]){
     var d = tree[2], v = tree[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var match$0 = caml_call1(f, [0, d]);
      if(match$0){
       var d$0 = match$0[1], tree$1 = [0, v, d$0];
       return [0, tree$1, length];
      }
      var length$1 = Base_Import[93].call(null, length, 1);
      return [0, 0, length$1];
     }
     if(0 <= c){
      var
       match$1 = change(0, key, f, length, compare_key),
       length$2 = match$1[2],
       r = match$1[1];
      if(r === tree) return [0, tree, length$2];
      var tree$2 = bal(0, v, d, r);
      return [0, tree$2, length$2];
     }
     var
      match$2 = change(0, key, f, length, compare_key),
      length$3 = match$2[2],
      l = match$2[1];
     if(l === tree) return [0, tree, length$3];
     var tree$3 = bal(l, v, d, 0);
     return [0, tree$3, length$3];
    }
    var
     h = tree[5],
     r$0 = tree[4],
     d$1 = tree[3],
     v$0 = tree[2],
     l$0 = tree[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var match$3 = caml_call1(f, [0, d$1]);
     if(match$3){
      var data$0 = match$3[1], tree$4 = [1, l$0, key, data$0, r$0, h];
      return [0, tree$4, length];
     }
     var
      length$4 = Base_Import[93].call(null, length, 1),
      tree$5 = concat_unchecked(l$0, r$0);
     return [0, tree$5, length$4];
    }
    if(0 <= c$0){
     var
      match$4 = change(r$0, key, f, length, compare_key),
      length$5 = match$4[2],
      r$1 = match$4[1];
     if(r$1 === r$0) return [0, tree, length$5];
     var tree$6 = bal(l$0, v$0, d$1, r$1);
     return [0, tree$6, length$5];
    }
    var
     match$5 = change(l$0, key, f, length, compare_key),
     length$6 = match$5[2],
     l$1 = match$5[1];
    if(l$1 === l$0) return [0, tree, length$6];
    var tree$7 = bal(l$1, v$0, d$1, r$0);
    return [0, tree$7, length$6];
   }
   function update(t, key, f, length, compare_key){
    if(typeof t === "number"){
     var
      data = caml_call1(f, 0),
      length$0 = Base_Import[91].call(null, length, 1),
      tree = [0, key, data];
     return [0, tree, length$0];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var d$0 = caml_call1(f, [0, d]), tree$0 = [0, v, d$0];
      return [0, tree$0, length];
     }
     if(0 <= c){
      var
       match = update(0, key, f, length, compare_key),
       length$1 = match[2],
       r = match[1],
       tree$1 = bal(0, v, d, r);
      return [0, tree$1, length$1];
     }
     var
      match$0 = update(0, key, f, length, compare_key),
      length$2 = match$0[2],
      l = match$0[1],
      tree$2 = bal(l, v, d, 0);
     return [0, tree$2, length$2];
    }
    var
     h = t[5],
     r$0 = t[4],
     d$1 = t[3],
     v$0 = t[2],
     l$0 = t[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var
      data$0 = caml_call1(f, [0, d$1]),
      tree$3 = [1, l$0, key, data$0, r$0, h];
     return [0, tree$3, length];
    }
    if(0 <= c$0){
     var
      match$1 = update(r$0, key, f, length, compare_key),
      length$3 = match$1[2],
      r$1 = match$1[1],
      tree$4 = bal(l$0, v$0, d$1, r$1);
     return [0, tree$4, length$3];
    }
    var
     match$2 = update(l$0, key, f, length, compare_key),
     length$4 = match$2[2],
     l$1 = match$2[1],
     tree$5 = bal(l$1, v$0, d$1, r$0);
    return [0, tree$5, length$4];
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var match = param[1];
               if(match){
                var non_empty_tail = match[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(f, v);}
     var r = t[4], v$0 = t[2], l = t[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     t = r;
    }
   }
   function iter(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var d = t[2]; return caml_call1(f, d);}
     var r = t[4], d$0 = t[3], l = t[1];
     iter(l, f);
     caml_call1(f, d$0);
     t = r;
    }
   }
   function iteri(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var d = t[2], v = t[1]; return caml_call2(f, v, d);}
     var r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     t = r;
    }
   }
   function iteri_until_loop(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var d = t[2], v = t[1]; return caml_call2(f, v, d);}
     var r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     t = r;
    }
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t$0, accu$1, f){
    var t = t$0, accu = accu$1;
    for(;;){
     if(typeof t === "number") return accu;
     if(0 === t[0]){var d = t[2], v = t[1]; return caml_call3(f, v, d, accu);}
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      accu$0 = caml_call3(f, v$0, d$0, fold(l, accu, f));
     t = r;
     accu = accu$0;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t$0, acc$2, f){
     var t = t$0, acc = acc$2;
     for(;;){
      if(typeof t === "number") return [0, acc];
      if(0 === t[0]){var d = t[2], v = t[1]; return caml_call3(f, v, d, acc);}
      var
       r = t[4],
       d$0 = t[3],
       v$0 = t[2],
       l = t[1],
       match = fold_until_loop(l, acc, f);
      if(0 !== match[0]){var final$0 = match[1]; return [1, final$0];}
      var acc$0 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$0);
      if(0 !== match$0[0]){var final = match$0[1]; return [1, final];}
      var acc$1 = match$0[1];
      t = r;
      acc = acc$1;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t$0, accu$1, f){
    var t = t$0, accu = accu$1;
    for(;;){
     if(typeof t === "number") return accu;
     if(0 === t[0]){var d = t[2], v = t[1]; return caml_call3(f, v, d, accu);}
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      accu$0 = caml_call3(f, v$0, d$0, fold_right(r, accu, f));
     t = l;
     accu = accu$0;
    }
   }
   function filter_mapi(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1], match = caml_call2(f, v, d);
     if(match){var new_data = match[1]; return [0, v, new_data];}
     len[1]--;
     return 0;
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filter_mapi(l, f, len),
     new_data$0 = caml_call2(f, v$0, d$0),
     r$0 = filter_mapi(r, f, len);
    if(new_data$0){
     var new_data$1 = new_data$0[1];
     return join(l$0, v$0, new_data$1, r$0);
    }
    len[1]--;
    return concat_and_balance_unchecked(l$0, r$0);
   }
   function filteri(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return caml_call2(f, v, d) ? t : (len[1]--, 0);
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filteri(l, f, len),
     keep_data = caml_call2(f, v$0, d$0),
     r$0 = filteri(r, f, len);
    if(l === l$0 && keep_data && r === r$0) return t;
    return keep_data
            ? join(l$0, v$0, d$0, r$0)
            : (len[1]--, concat_and_balance_unchecked(l$0, r$0));
   }
   function filter(t, f, len){
    return filteri(t, function(param, data){return caml_call1(f, data);}, len);
   }
   function filter_keys(t, f, len){
    return filteri(t, function(key, param){return caml_call1(f, key);}, len);
   }
   function filter_map(t, f, len){
    return filter_mapi
            (t, function(param, data){return caml_call1(f, data);}, len);
   }
   function partition_mapi(t, f){
    var
     match =
       fold
        (t,
         [0, empty, empty],
         function(key, data, param){
          var t2 = param[2], t1 = param[1], match = caml_call2(f, key, data);
          if(0 === match[0]){
           var x = match[1];
           return [0, add_unchecked(t1, key, x), t2];
          }
          var y = match[1];
          return [0, t1, add_unchecked(t2, key, y)];
         }),
     t2 = match[2],
     t1 = match[1],
     a = to_tree_unchecked(t2);
    return [0, to_tree_unchecked(t1), a];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    function loop(t, f){
     if(typeof t === "number") return n;
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return caml_call2(f, v, d) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l, f),
      l_f = match[2],
      l_t = match[1],
      keep_data_t = caml_call2(f, v$0, d$0),
      match$0 = loop(r, f),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(l$0, keep_data, r$0){
      if(l === l$0 && keep_data && r === r$0) return t;
      return keep_data
              ? join(l$0, v$0, d$0, r$0)
              : concat_and_balance_unchecked(l$0, r$0);
     }
     var a = mk(l_f, 1 - keep_data_t, r_f);
     return [0, mk(l_t, keep_data_t, r_t), a];
    }
    return loop(t, f);
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function cons(t$0, e$1){
    var t = t$0, e = e$1;
    for(;;){
     if(typeof t === "number") return e;
     if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, d, 0, e];}
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      e$0 = [0, v$0, d$0, r, e];
     t = l;
     e = e$0;
    }
   }
   function cons_right(t$0, e$1){
    var t = t$0, e = e$1;
    for(;;){
     if(typeof t === "number") return e;
     if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, d, 0, e];}
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      e$0 = [0, v$0, d$0, l, e];
     t = r;
     e = e$0;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function step_deeper_exn(tree, e){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, o], 1);
    if(0 === tree[0]){
     var d = tree[2], v = tree[1];
     return [0, 0, [0, v, d, 0, e]];
    }
    var r = tree[4], d$0 = tree[3], v$0 = tree[2], l = tree[1];
    return [0, l, [0, v$0, d$0, r, e]];
   }
   function drop_phys_equal_prefix(tree1$2, acc1$2, tree2$2, acc2$2){
    var tree1 = tree1$2, acc1 = acc1$2, tree2 = tree2$2, acc2 = acc2$2;
    for(;;){
     if(tree1 === tree2) return [0, acc1, acc2];
     var h2 = height(tree2), h1 = height(tree1);
     if(h2 === h1){
      var
       match = step_deeper_exn(tree1, acc1),
       acc1$0 = match[2],
       tree1$0 = match[1],
       match$0 = step_deeper_exn(tree2, acc2),
       acc2$0 = match$0[2],
       tree2$0 = match$0[1];
      tree1 = tree1$0;
      acc1 = acc1$0;
      tree2 = tree2$0;
      acc2 = acc2$0;
     }
     else if(h1 < h2){
      var
       match$1 = step_deeper_exn(tree2, acc2),
       acc2$1 = match$1[2],
       tree2$1 = match$1[1];
      tree2 = tree2$1;
      acc2 = acc2$1;
     }
     else{
      var
       match$2 = step_deeper_exn(tree1, acc1),
       acc1$1 = match$2[2],
       tree1$1 = match$2[1];
      tree1 = tree1$1;
      acc1 = acc1$1;
     }
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    a:
    {
     var t1$0 = t1, t2$0 = t2, curr = init;
     for(;;){
      if(! t1$0) break;
      if(! t2$0){var param = t1$0, init$0 = curr; break a;}
      var
       enum2 = t2$0[4],
       tree2 = t2$0[3],
       v2 = t2$0[2],
       k2 = t2$0[1],
       enum1 = t1$0[4],
       tree1 = t1$0[3],
       v1 = t1$0[2],
       k1 = t1$0[1],
       compare_result = caml_call2(compare_key, k1, k2);
      if(0 === compare_result){
       var
        next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1);
       t1$0 = t1$1;
       t2$0 = t2$1;
       curr = next;
      }
      else if(0 <= compare_result){
       var
        next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
        t2$2 = cons(tree2, enum2);
       t2$0 = t2$2;
       curr = next$0;
      }
      else{
       var
        next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
        t1$2 = cons(tree1, enum1);
       t1$0 = t1$2;
       curr = next$1;
      }
     }
     if(! t2$0) return curr;
     var param$0 = t2$0, init$1 = curr;
     for(;;){
      if(! param$0) return init$1;
      var
       enum$0 = param$0[4],
       tree$0 = param$0[3],
       data$0 = param$0[2],
       key$0 = param$0[1],
       next$3 = caml_call3(f, key$0, [0, -57574468, data$0], init$1);
      param$0 = cons(tree$0, enum$0);
      init$1 = next$3;
     }
    }
    for(;;){
     if(! param) return init$0;
     var
      enum$ = param[4],
      tree = param[3],
      data = param[2],
      key = param[1],
      next$2 = caml_call3(f, key, [0, 847852583, data], init$0);
     param = cons(tree, enum$);
     init$0 = next$2;
    }
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(left){
      var
       right = state[2],
       enum$ = left[4],
       tree = left[3],
       data = left[2],
       key = left[1];
      if(! right)
       return [1, [0, key, [0, 847852583, data]], [0, cons(tree, enum$), 0]];
      var
       enum2 = right[4],
       tree2 = right[3],
       v2 = right[2],
       k2 = right[1],
       compare_result = caml_call2(compare_key, key, k2);
      if(0 !== compare_result)
       return 0 <= compare_result
               ? [1,
                 [0, k2, [0, -57574468, v2]],
                 [0, left, cons(tree2, enum2)]]
               : [1,
                 [0, key, [0, 847852583, data]],
                 [0, cons(tree, enum$), right]];
      var next_state = drop_phys_equal_prefix(tree, enum$, tree2, enum2);
      return caml_call2(data_equal, data, v2)
              ? [0, next_state]
              : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
     }
     var match = state[2];
     if(! match) return 0;
     var
      enum$0 = match[4],
      tree$0 = match[3],
      data$0 = match[2],
      key$0 = match[1];
     return [1,
             [0, key$0, [0, -57574468, data$0]],
             [0, 0, cons(tree$0, enum$0)]];
    }
    var a = drop_phys_equal_prefix(t1, 0, t2, 0);
    return Base_Sequence[44].call(null, a, step);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init$0, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    var
     match$0 = drop_phys_equal_prefix(t1, 0, t2, 0),
     right$1 = match$0[2],
     left$1 = match$0[1];
    a:
    {
     var left = left$1, right = right$1, init$1 = init$0;
     for(;;){
      if(! left){var init = init$1, param = right; break;}
      if(! right){var param$0 = left, init$2 = init$1; break a;}
      var
       enum2 = right[4],
       tree2 = right[3],
       v2 = right[2],
       k2 = right[1],
       enum1 = left[4],
       tree1 = left[3],
       v1 = left[2],
       k1 = left[1],
       compare_result = caml_call2(compare_key, k1, k2);
      if(0 === compare_result){
       var
        acc =
          caml_call2(data_equal, v1, v2)
           ? init$1
           : caml_call2(f, init$1, [0, k1, [0, 1013247643, [0, v1, v2]]]),
        match = drop_phys_equal_prefix(tree1, enum1, tree2, enum2),
        enum2$0 = match[2],
        enum1$0 = match[1];
       left = enum1$0;
       right = enum2$0;
       init$1 = acc;
      }
      else if(0 <= compare_result){
       var acc$0 = add(init$1, k2, v2), right$0 = cons(tree2, enum2);
       right = right$0;
       init$1 = acc$0;
      }
      else{
       var acc$1 = remove(init$1, k1, v1), left$0 = cons(tree1, enum1);
       left = left$0;
       init$1 = acc$1;
      }
     }
     for(;;){
      if(! param) return init;
      var
       enum$ = param[4],
       tree = param[3],
       data = param[2],
       key = param[1],
       next$0 = add(init, key, data);
      init = next$0;
      param = cons(tree, enum$);
     }
    }
    for(;;){
     if(! param$0) return init$2;
     var
      enum$0 = param$0[4],
      tree$0 = param$0[3],
      data$0 = param$0[2],
      key$0 = param$0[1],
      next = remove(init$2, key$0, data$0);
     param$0 = cons(tree$0, enum$0);
     init$2 = next;
    }
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    var order = opt ? opt[1] : -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set(t$0, 0, key, data, compare_key)[1];
    }
    if(511974747 <= order){
     var
      a = Base_Import[127],
      tree =
        Base_Option[34].call
         (null,
          keys_greater_or_equal_to,
          t$3,
          function(b, c){return inclusive_bound(a, b, c);}),
      next$0 =
        function(enum$){
         if(! enum$) return 0;
         var e = enum$[4], t = enum$[3], v = enum$[2], k = enum$[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0]){
        var d$1 = t$1[2], v$2 = t$1[1], t$2 = [1, 0, v$2, d$1, 0, 1];
        t$1 = t$2;
       }
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         t$1 = l$0;
        else{
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1];
         t$1 = r$1;
         e$1 = e$2;
        }
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return Base_Sequence[44].call(null, init$0, next$0);
    }
    var
     b = Base_Import[125],
     t$4 =
       Base_Option[34].call
        (null,
         keys_less_or_equal_to,
         t$3,
         function(a, c){return inclusive_bound(b, a, c);});
    function next(enum$){
     if(! enum$) return 0;
     var e = enum$[4], t = enum$[3], v = enum$[2], k = enum$[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0]){
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1];
       t = t$0;
      }
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key)){
        var r$0 = t[4], d$0 = t[3], v$1 = t[2], e$0 = [0, v$1, d$0, r$0, e];
        t = l;
        e = e$0;
       }
       else
        t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return Base_Sequence[44].call(null, init, next);
   }
   function compare$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     var
      match = drop_phys_equal_prefix(r1, e1, r2, e2),
      e2$0 = match[2],
      e1$0 = match[1];
     t1 = e1$0;
     t2 = e2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        a = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(a){
        var b = caml_call2(compare_data, d1, d2);
        if(b){
         var
          match = drop_phys_equal_prefix(r1, e1, r2, e2),
          e2$0 = match[2],
          e1$0 = match[1];
         t1 = e1$0;
         t2 = e2$0;
         continue;
        }
        var c = b;
       }
       else
        var c = a;
       return c;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    var a = of_tree(t2);
    return fold2
            (compare_key,
             of_tree(t1),
             a,
             0,
             function(key, data, param){return caml_call2(f, key, data);});
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var a = of_tree(t2);
    return fold2(compare_key, of_tree(t1), a, init, f);
   }
   function fold_symmetric_diff$0(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$1, t$2, acc$3){
     a:
     {
      b:
      {
       c:
       {
        var t$0 = t$1, t = t$2, init = acc$3;
        for(;;){
         if(t$0 === t) return init;
         if(typeof t$0 === "number") break;
         if(0 === t$0[0]) break c;
         var r = t$0[4], v$1 = t$0[3], k$1 = t$0[2], l = t$0[1];
         if(typeof t === "number") break b;
         if(0 === t[0]) break a;
         var r$0 = t[4], v$2 = t[3], k$2 = t[2], l$0 = t[1];
         if(0 !== caml_call2(compare_key, k$1, k$2)) break a;
         var acc$1 = loop(l, l$0, init), acc$2 = delta(acc$1, k$1, v$1, v$2);
         t$0 = r;
         t = r$0;
         init = acc$2;
        }
        return fold
                (t,
                 init,
                 function(key, data, acc){return add(acc, key, data);});
       }
       var v = t$0[2], k = t$0[1];
       if(typeof t !== "number"){
        if(0 !== t[0]) break a;
        var v$0 = t[2], k$0 = t[1], x = caml_call2(compare_key, k, k$0);
        if(0 === x) return delta(init, k, v, v$0);
        if(0 <= x){var acc = add(init, k$0, v$0); return remove(acc, k, v);}
        var acc$0 = remove(init, k, v);
        return add(acc$0, k$0, v$0);
       }
      }
      return fold
              (t$0,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
     return fold_symmetric_diff(t$0, t, compare_key, data_equal, init, f);
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     a = length(r),
     b = length(l),
     c = Base_Import[91].call(null, b, a);
    return Base_Import[91].call(null, c, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function of_foldable(fold, foldable, init, f, compare_key){
    return caml_call3
            (fold,
             foldable,
             [0, empty_without_value_restrictio, 0],
             function(a, param){
              var
               data = param[2],
               key = param[1],
               length = a[2],
               accum = a[1],
               match = find(accum, key, compare_key);
              if(match)
               var prev = match[1], prev_data = prev;
              else
               var prev_data = init;
              var data$0 = caml_call2(f, prev_data, data);
              return globalize(set(accum, length, key, data$0, compare_key));
             });
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return of_foldable(M[2], foldable, init, f, compare_key);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(a, param){
               var
                data = param[2],
                key = param[1],
                length = a[2],
                accum = a[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], new_data = caml_call2(f, prev, data);
               else
                var new_data = data;
               return globalize
                       (set(accum, length, key, new_data, compare_key));
              });
    }
    function of_foldable$0(foldable, compare_key){
     return with_return
             (function(r){
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    function(a, param){
                     var
                      data = param[2],
                      key = param[1],
                      length = a[2],
                      t = a[1],
                      acc = set(t, length, key, data, compare_key),
                      length$0 = acc[2];
                     return length === length$0
                             ? caml_call1(r, [0, -1048878709, key])
                             : globalize(acc);
                    });
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]), variant = match[1];
     if(17724 <= variant){var x = match[2]; return [0, x];}
     var
      key = match[2],
      a = comparator[2],
      b = Base_Import[112].call(null, M[1], cst_or_error_duplicate_key),
      c = Base_Import[112].call(null, cst_Map_of, b);
     return Base_Or_error[38].call(null, 0, 0, c, key, a);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]), variant = match[1];
     if(17724 <= variant){var x = match[2]; return x;}
     var
      key = match[2],
      a = comparator[2],
      b = Base_Import[112].call(null, M[1], cst_exn_duplicate_key),
      c = Base_Import[112].call(null, cst_Map_of$0, b),
      d = Base_Error[19].call(null, 0, 0, c, key, a);
     return Base_Error[31].call(null, d);
    }
    function of_foldable_multi(foldable, compare_key){
     var
      alist = caml_call3(M[2], foldable, 0, function(l, x){return [0, x, l];});
     return of_foldable
             (Base_List0[8],
              alist,
              0,
              function(l, x){return [0, x, l];},
              compare_key);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable$0,
            of_foldable_or_error,
            of_foldable_exn,
            of_foldable_multi];
   }
   var
    fold$0 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$0]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5],
    of_alist_multi = Of_alist[6],
    fold$1 = Base_Sequence[11],
    Of_sequence = Of_foldable([0, name$0, fold$1]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    of_sequence_multi = Of_sequence[6],
    cst_Map_of_list_with_key_or_er =
      "Map.of_list_with_key_or_error: duplicate key",
    cst_Map_of_list_with_key_exn_d = "Map.of_list_with_key_exn: duplicate key",
    cst_Map_merge_disjoint_exn_dup = "Map.merge_disjoint_exn: duplicate key",
    p = [0, 0],
    q = [0, 0],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    r = [0, cst_src_map_ml, 1967, 6],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    s = [0, "Map.Build_increasing.add: non-increasing key"],
    dummy = 0;
   function of_list_with_key(list, get_key, compare_key){
    return with_return
            (function(r){
              var
               map =
                 Base_List0[8].call
                  (null,
                   list,
                   [0, empty_without_value_restrictio, 0],
                   function(param, data){
                    var
                     length = param[2],
                     t = param[1],
                     key = caml_call1(get_key, data),
                     acc = set(t, length, key, data, compare_key),
                     new_length = acc[2];
                    return length === new_length
                            ? caml_call1(r, [0, -1048878709, key])
                            : globalize(acc);
                   });
              return [0, 17724, map];
             });
   }
   function of_list_with_key_or_error(list, get_key, comparator){
    var
     match = of_list_with_key(list, get_key, comparator[1]),
     variant = match[1];
    if(17724 <= variant){var x = match[2]; return [0, x];}
    var key = match[2];
    return Base_Or_error[38].call
            (null, 0, 0, cst_Map_of_list_with_key_or_er, key, comparator[2]);
   }
   function of_list_with_key_exn(list, get_key, comparator){
    var
     match = of_list_with_key(list, get_key, comparator[1]),
     variant = match[1];
    if(17724 <= variant){var x = match[2]; return x;}
    var
     key = match[2],
     a =
       Base_Error[19].call
        (null, 0, 0, cst_Map_of_list_with_key_exn_d, key, comparator[2]);
    return Base_Error[31].call(null, a);
   }
   function of_list_with_key_multi(list, get_key, compare_key){
    var list$0 = Base_List0[19].call(null, list);
    return Base_List0[8].call
            (null,
             list$0,
             [0, empty_without_value_restrictio, 0],
             function(param, data){
              var
               length = param[2],
               t = param[1],
               key = caml_call1(get_key, data);
              return globalize
                      (update
                        (t,
                         key,
                         function(option){
                          var list = Base_Option[30].call(null, option, 0);
                          return [0, data, list];
                         },
                         length,
                         compare_key));
             });
   }
   function of_list_with_key_fold(list, get_key, init, f, compare_key){
    return Base_List0[8].call
            (null,
             list,
             [0, empty_without_value_restrictio, 0],
             function(param, data){
              var
               length = param[2],
               t = param[1],
               key = caml_call1(get_key, data);
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return caml_call2(f, init, data);
                          var prev = param[1];
                          return caml_call2(f, prev, data);
                         },
                         length,
                         compare_key));
             });
   }
   function of_list_with_key_reduce(list, get_key, f, compare_key){
    return Base_List0[8].call
            (null,
             list,
             [0, empty_without_value_restrictio, 0],
             function(param, data){
              var
               length = param[2],
               t = param[1],
               key = caml_call1(get_key, data);
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return data;
                          var prev = param[1];
                          return caml_call2(f, prev, data);
                         },
                         length,
                         compare_key));
             });
   }
   function for_all(t, f){
    return with_return
            (function(r){
              iter
               (t,
                function(data){
                 var a = 1 - caml_call1(f, data);
                 return a ? caml_call1(r, 0) : a;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return with_return
            (function(r){
              iteri
               (t,
                function(key, data){
                 var a = 1 - caml_call2(f, key, data);
                 return a ? caml_call1(r, 0) : a;
                });
              return 1;
             });
   }
   function exists(t, f){
    return with_return
            (function(r){
              iter
               (t,
                function(data){
                 var a = caml_call1(f, data);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return with_return
            (function(r){
              iteri
               (t,
                function(key, data){
                 var a = caml_call2(f, key, data);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? Base_Import[91].call(null, acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? Base_Import[91].call(null, acc, 1)
                      : acc;
             });
   }
   function sum(M, t, f){
    return fold
            (t,
             M[1],
             function(param, data, acc){
              var a = caml_call1(f, data);
              return caml_call2(M[2], a, acc);
             });
   }
   function sumi(M, t, f){
    return fold
            (t,
             M[1],
             function(key, data, acc){
              var a = caml_call2(f, key, data);
              return caml_call2(M[2], a, acc);
             });
   }
   function to_alist(opt, t){
    var key_order = opt ? opt[1] : 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     a = length(t2),
     b = length(t1),
     c = Base_Import[91].call(null, b, a),
     elts = Base_Uniform_array[62].call(null, c),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       Base_Uniform_array[15].call(null, elts, i[1], [0, key, value]);
       i[1]++;
       return 0;
      },
      compare_key);
    var length$0 = i[1];
    function get(i){return Base_Uniform_array[12].call(null, elts, i);}
    var tree = of_increasing_iterator_uncheck(length$0, get);
    return [0, tree, length$0];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return data;
                          var data$0 = param[1];
                          return caml_call4(call, combine, key, data$0, data);
                         },
                         length,
                         compare_key));
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function merge_disjoint_exn(t1, t2, length1, length2, comparator){
    return merge_skewed
            (t1,
             t2,
             length1,
             length2,
             function(key, b, param){
              var
               a =
                 Base_Error[19].call
                  (null,
                   0,
                   0,
                   cst_Map_merge_disjoint_exn_dup,
                   key,
                   comparator[2]);
              return Base_Error[31].call(null, a);
             },
             comparator[1]);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       t = l;
       found_marker = 1;
       found_key = found_key$0;
       found_value = found_value$0;
       continue;
      }
      t = r;
      continue;
     }
     if(0 <= c$0)
      t = l;
     else{
      t = r;
      found_marker = 1;
      found_key = found_key$0;
      found_value = found_value$0;
     }
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     a =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return a
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t$0, k$1, compare_key){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var k = t[1];
      return 0 === caml_call2(compare_key, k, k$1) ? p : 0;
     }
     var
      r = t[4],
      k$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, k$0, k$1);
     if(0 === c) return [0, length(l)];
     if(0 >= c) break;
     t = l;
    }
    var a = rank(r, k$1, compare_key);
    return caml_call2
            (Base_Option[24],
             a,
             function(rank){
              var a = length(l), b = Base_Import[91].call(null, rank, 1);
              return Base_Import[91].call(null, b, a);
             });
   }
   function nth(num_to_search, param$0){
    var param = param$0;
    for(;;){
     if(typeof param === "number") return 0;
     if(0 === param[0]){
      var v = param[2], k = param[1];
      return 0 === num_to_search[1] ? [0, [0, k, v]] : (num_to_search[1]--, 0);
     }
     var
      r = param[4],
      v$0 = param[3],
      k$0 = param[2],
      l = param[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     num_to_search[1]--;
     param = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var v = t[2], k = t[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t[4], v$0 = t[3], k$0 = t[2], l = t[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t = r;
    }
   }
   function find_last_satisfying(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var v = t[2], k = t[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t[4], v$0 = t[3], k$0 = t[2], l = t[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return q;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && Base_Option[52].call(null, acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = globalize(pair);
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]), variant = match[1];
    if(17724 <= variant){var v = match[2]; return v;}
    var
     key = match[2],
     a =
       Base_Error[19].call
        (null, 0, 0, cst_Map_of_iteri_exn_duplicate, key, comparator[2]);
    return Base_Error[31].call(null, a);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     a = Base_Import[171],
     alist =
       Base_Import[173].call
        (null, function(b){return a(key_of_sexp, value_of_sexp, b);}, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key),
     variant = match[1];
    if(17724 <= variant){var v = match[2]; return v;}
    var k = match[2];
    function b(a){return a;}
    function c(a){return a;}
    var
     d = Base_Import[171],
     alist_sexps =
       Base_Import[173].call(null, function(a){return d(c, b, a);}, sexp),
     found_first_k = [0, 0];
    Base_List0[13].call
     (null,
      alist,
      alist_sexps,
      function(c, param){
       var
        k2_sexp = param[1],
        k2 = c[1],
        a = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
       if(a){
        if(found_first_k[1])
         return Base_Import[156].call
                 (null, cst_Map_t_of_sexp_direct_dupli, k2_sexp);
        found_first_k[1] = 1;
        var b = 0;
       }
       else
        var b = a;
       return b;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, r], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var a = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), a]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, sexp_of_key){
    var
     match = partition_map(t, Base_Result[38]),
     errors = match[2],
     oks = match[1];
    if(is_empty(errors)) return [0, oks];
    var a = sexp_of_t$1(sexp_of_key, Base_Error[9], errors);
    return Base_Or_error[39].call(null, a);
   }
   function unzip(t){
    var a = map(t, Base_Import[127]);
    return [0, map(t, Base_Import[125]), a];
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return with_return
            (function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           a =
                             globalize
                              (add_exn_internal
                                (t2, length, key$0, data, compare_key, sexp_of_key));
                          return a;
                         }
                         catch(exn$0){
                          var exn = caml_wrap_exception(exn$0);
                          if(exn === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(exn, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator), variant = match[1];
    if(17724 <= variant){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     a = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     b = Base_Sexp[10].call(null, cst_Map_map_keys_exn_duplicate, a);
    return Base_Error[32].call(null, b);
   }
   function transpose_keys(outer_comparator, inner_comparator, outer_t){
    return fold
            (outer_t,
             [0, empty_without_value_restrictio, 0],
             function(outer_key, inner_t, acc){
              return fold
                      (inner_t,
                       acc,
                       function(inner_key, data, param){
                        var acc_len = param[2], acc = param[1];
                        return globalize
                                (update
                                  (acc,
                                   inner_key,
                                   function(param){
                                    if(param){
                                     var match = param[1], elt_len = match[2], elt = match[1];
                                     return globalize
                                             (set(elt, elt_len, outer_key, data, outer_comparator[1]));
                                    }
                                    var tree = [0, outer_key, data];
                                    return [0, tree, 1];
                                   },
                                   acc_len,
                                   inner_comparator[1]));
                       });
             });
   }
   function Make_applicative_traversals(A){
    function mapi(t, f){
     if(typeof t === "number") return caml_call1(A[1], 0);
     if(0 === t[0]){
      var d = t[2], v = t[1], a = caml_call2(f, v, d);
      return caml_call2(A[2], a, function(new_data){return [0, v, new_data];});
     }
     var
      h = t[5],
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = caml_call1(A[14], function(param){return mapi(l, f);}),
      d$1 = caml_call2(f, v$0, d$0),
      r$0 = caml_call1(A[14], function(param){return mapi(r, f);});
     return caml_call4
             (A[10],
              l$0,
              d$1,
              r$0,
              function(l, d, r){return [1, l, v$0, d, r, h];});
    }
    function filter_mapi(t, f){
     function tree_filter_mapi(t, f){
      if(typeof t === "number") return caml_call1(A[1], [0, 0, 0]);
      if(0 === t[0]){
       var d = t[2], v = t[1], a = caml_call2(f, v, d);
       return caml_call2
               (A[2],
                a,
                function(param){
                 if(! param) return [0, 0, 0];
                 var new_data = param[1], tree = [0, v, new_data];
                 return [0, tree, 1];
                });
      }
      var
       r = t[4],
       d$0 = t[3],
       v$0 = t[2],
       l = t[1],
       b = caml_call1(A[14], function(param){return tree_filter_mapi(r, f);}),
       c = caml_call2(f, v$0, d$0),
       e = caml_call1(A[14], function(param){return tree_filter_mapi(l, f);});
      return caml_call4
              (A[10],
               e,
               c,
               b,
               function(a, new_data, param){
                var r_len = param[2], r = param[1], l_len = a[2], l = a[1];
                if(new_data){
                 var
                  new_data$0 = new_data[1],
                  b = Base_Import[91].call(null, l_len, r_len),
                  length = Base_Import[91].call(null, b, 1),
                  tree = join(l, v$0, new_data$0, r);
                 return [0, tree, length];
                }
                var
                 length$0 = Base_Import[91].call(null, l_len, r_len),
                 tree$0 = concat_and_balance_unchecked(l, r);
                return [0, tree$0, length$0];
               });
     }
     return tree_filter_mapi(t, f);
    }
    return [0, mapi, filter_mapi];
   }
   function compare_key(t){return t[1][1];}
   function like(a, param){
    var length = param[2], tree = param[1], comparator = a[1];
    return [0, comparator, tree, length];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_like_tree(t, tree){
    var a = length(tree);
    return [0, t[1], tree, a];
   }
   function of_like_tree_maybe_no_op(t, tree){
    if(t[2] === tree) return t;
    var a = length(tree);
    return [0, t[1], tree, a];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var c = compare_key(t), a = invariants(t[2], c);
    if(a) var d = t[3], b = length(t[2]) === d ? 1 : 0; else var b = a;
    return b;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$0(t, key, data){
    var a = compare_key(t);
    return like(t, set(t[2], t[3], key, data, a));
   }
   function add_exn$0(t, key, data){
    var a = t[1][2], b = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, b, a));
   }
   function add(t, key, data){
    try{
     var
      a = t[1][2],
      b = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, b, a));
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var a = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, a));
   }
   function remove_multi$0(t, key){
    var a = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], a));
   }
   function find_multi$0(t, key){
    var a = compare_key(t);
    return find_multi(t[2], key, a);
   }
   function change$0(t, key, f){
    var a = compare_key(t);
    return like(t, change(t[2], key, f, t[3], a));
   }
   function update$0(t, key, f){
    var a = compare_key(t);
    return like(t, update(t[2], key, f, t[3], a));
   }
   function find_exn$0(t, key){
    var a = t[1][2], b = compare_key(t);
    return find_exn(t[2], key, b, a);
   }
   function find$0(t, key){var a = compare_key(t); return find(t[2], key, a);}
   function remove$0(t, key){
    var a = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], a));
   }
   function mem$0(t, key){var a = compare_key(t); return mem(t[2], key, a);}
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until(t, f){
    var t$0 = t[2];
    return iteri_until_loop(t$0, f);
   }
   function iter2$0(t1, t2, f){
    var a = compare_key(t1);
    return iter2(t1[2], t2[2], f, a);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$2(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var a = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, a);
   }
   function filter_keys$0(t, f){
    var len = [0, t[3]], tree = filter_keys(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filter$0(t, f){
    var len = [0, t[3]], tree = filter(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filteri$0(t, f){
    var len = [0, t[3]], tree = filteri(t[2], f, len), length = len[1];
    return like_maybe_no_op(t, [0, tree, length]);
   }
   function filter_map$0(t, f){
    var len = [0, t[3]], tree = filter_map(t[2], f, len), length = len[1];
    return like(t, [0, tree, length]);
   }
   function filter_mapi$0(t, f){
    var len = [0, t[3]], tree = filter_mapi(t[2], f, len), length = len[1];
    return like(t, [0, tree, length]);
   }
   function of_like_tree2(t, param){
    var t2 = param[2], t1 = param[1], a = of_like_tree(t, t2);
    return [0, of_like_tree(t, t1), a];
   }
   function of_like_tree2_maybe_no_op(t, param){
    var t2 = param[2], t1 = param[1], a = of_like_tree_maybe_no_op(t, t2);
    return [0, of_like_tree_maybe_no_op(t, t1), a];
   }
   function partition_mapi$0(t, f){
    return of_like_tree2(t, partition_mapi(t[2], f));
   }
   function partition_map$0(t, f){
    return of_like_tree2(t, partition_map(t[2], f));
   }
   function partitioni_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partitioni_tf(t[2], f));
   }
   function partition_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partition_tf(t[2], f));
   }
   function combine_errors$0(t){
    var a = combine_errors(t[2], t[1][2]);
    return caml_call2
            (Base_Or_error[47], a, function(a){return of_like_tree(t, a);});
   }
   function unzip$0(t){return of_like_tree2(t, unzip(t[2]));}
   function compare_direct(compare_data, t1, t2){
    var a = t2[2], b = t1[2];
    return compare$1(compare_key(t1), compare_data, b, a);
   }
   function equal$2(compare_data, t1, t2){
    var a = t2[2], b = t1[2];
    return equal$1(compare_key(t1), compare_data, b, a);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var a = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], a, data_equal);
   }
   function fold_symmetric_diff$1(t1, t2, data_equal, init, f){
    var a = compare_key(t1);
    return fold_symmetric_diff$0(t1[2], t2[2], a, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var a = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, a));
   }
   function merge_disjoint_exn$0(t1, t2){
    return like(t1, merge_disjoint_exn(t1[2], t2[2], t1[3], t2[3], t1[1]));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     a = compare_key(t1),
     b = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, a),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, b);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function sumi$0(m, t, f){return sumi(m, t[2], f);}
   function split$0(t, k){
    var
     a = compare_key(t),
     match = split(t[2], k, a),
     tree = match[3],
     maybe = match[2],
     tree$0 = match[1],
     comparator = t[1],
     both_len =
       Base_Option[53].call(null, maybe)
        ? Base_Import[93].call(null, t[3], 1)
        : t[3],
     b = height(tree);
    if(height(tree$0) < b){
     var
      l = of_tree$0(comparator, tree$0),
      length = Base_Import[93].call(null, both_len, l[3]);
     return [0, l, maybe, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = Base_Import[93].call(null, both_len, r[3]);
    return [0, [0, comparator, tree$0, length$0], maybe, r];
   }
   function split_and_reinsert_boundary$0(t, into, k){
    var
     a = compare_key(t),
     match = split_and_reinsert_boundary(t[2], into, k, a),
     tree = match[2],
     tree$0 = match[1],
     comparator = t[1],
     b = height(tree);
    if(height(tree$0) < b){
     var
      l = of_tree$0(comparator, tree$0),
      length = Base_Import[93].call(null, t[3], l[3]);
     return [0, l, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = Base_Import[93].call(null, t[3], r[3]);
    return [0, [0, comparator, tree$0, length$0], r];
   }
   function split_le_gt(t, k){
    return split_and_reinsert_boundary$0(t, 847852583, k);
   }
   function split_lt_ge(t, k){
    return split_and_reinsert_boundary$0(t, -57574468, k);
   }
   function subrange(t, lower_bound, upper_bound){
    var
     a = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, a),
     right = match[3],
     tree = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? Base_Import[91].call(null, h_l, 1)
        : Base_Import[100].call(null, h_l, h_r);
    if(outer_joined_height >= height(tree)) return of_tree$0(t[1], tree);
    var
     b = length(right),
     c = length(left),
     d = Base_Import[91].call(null, c, b),
     mid_length = Base_Import[93].call(null, t[3], d),
     comparator = t[1];
    return [0, comparator, tree, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     a = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], a);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     length = Base_Import[91].call(null, lower_part[3], upper_part[3]),
     comparator = lower_part[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var a = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, a);
   }
   function range_to_alist$0(t, min, max){
    var a = compare_key(t);
    return range_to_alist(t[2], min, max, a);
   }
   function closest_key$0(t, dir, key){
    var a = compare_key(t);
    return closest_key(t[2], dir, key, a);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var a = nth$1(t, n);
    return Base_Option[31].call(null, 0, 0, 0, a);
   }
   function rank$0(t, key){var a = compare_key(t); return rank(t[2], key, a);}
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2], a = length(t$0);
    return fold
            (t$0,
             caml_call2(Base_Import[206], state, a),
             function(key, data, state){
              return caml_call2
                      (hash_fold_data,
                       caml_call2(hash_fold_key, state, key),
                       data);
             });
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, [0, 0, 0]);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function Make_applicative_traversals$0(A){
    var Tree_traversals = Make_applicative_traversals(A);
    function mapi(t, f){
     var a = Tree_traversals[1].call(null, t[2], f);
     return caml_call2
             (A[2],
              a,
              function(new_tree){return with_same_length(t, new_tree);});
    }
    function filter_mapi(t, f){
     var a = Tree_traversals[2].call(null, t[2], f);
     return caml_call2
             (A[2],
              a,
              function(new_tree_with_length){
               return like(t, new_tree_with_length);
              });
    }
    return [0, , mapi, filter_mapi];
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, key, data){return [0, key, data];}
   function of_sorted_array_unchecked$0(comparator, array){
    return of_sorted_array_unchecked(array, comparator[1])[1];
   }
   function of_sorted_array$0(comparator, array){
    var a = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[47], a, function(x){return x[1];});
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]), variant = d[1];
    if(17724 > variant) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var a = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Or_error[47], a, function(x){return x[1];});
   }
   function of_alist_exn$0(comparator, alist){
    return of_alist_exn(alist, comparator)[1];
   }
   function of_alist_multi$0(comparator, alist){
    return of_alist_multi(alist, comparator[1])[1];
   }
   function of_alist_fold$0(comparator, alist, init, f){
    return of_alist_fold(alist, init, f, comparator[1])[1];
   }
   function of_alist_reduce$0(comparator, alist, f){
    return of_alist_reduce(alist, f, comparator[1])[1];
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]), variant = d[1];
    if(17724 > variant) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    return of_iteri_exn(iteri, comparator)[1];
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var a = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[47], a, function(x){return x[1];});
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]), variant = d[1];
    if(17724 > variant) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var a = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Or_error[47], a, function(x){return x[1];});
   }
   function of_sequence_exn$0(comparator, seq){
    return of_sequence_exn(seq, comparator)[1];
   }
   function of_sequence_multi$0(comparator, seq){
    return of_sequence_multi(seq, comparator[1])[1];
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    return of_sequence_fold(seq, init, f, comparator[1])[1];
   }
   function of_sequence_reduce$0(comparator, seq, f){
    return of_sequence_reduce(seq, f, comparator[1])[1];
   }
   function of_list_with_key$0(comparator, list, get_key){
    var d = of_list_with_key(list, get_key, comparator[1]), variant = d[1];
    if(17724 > variant) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_list_with_key_or_error$0(comparator, list, get_key){
    var a = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2(Base_Or_error[47], a, function(x){return x[1];});
   }
   function of_list_with_key_exn$0(comparator, list, get_key){
    return of_list_with_key_exn(list, get_key, comparator)[1];
   }
   function of_list_with_key_multi$0(comparator, list, get_key){
    return of_list_with_key_multi(list, get_key, comparator[1])[1];
   }
   function of_list_with_key_fold$0(comparator, list, get_key, init, f){
    return of_list_with_key_fold(list, get_key, init, f, comparator[1])[1];
   }
   function of_list_with_key_reduce$0(comparator, list, get_key, f){
    return of_list_with_key_reduce(list, get_key, f, comparator[1])[1];
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$1(comparator, t, key, data){
    return set(t, 0, key, data, comparator[1])[1];
   }
   function add_exn$1(comparator, t, key, data){
    return add_exn(t, 0, key, data, comparator[1], comparator[2])[1];
   }
   function add$0(comparator, t, key, data){
    try{
     var
      a =
        [0,
         17724,
         add_exn_internal(t, 0, key, data, comparator[1], comparator[2])[1]];
     return a;
    }
    catch(exn){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    return add_multi(t, 0, key, data, comparator[1])[1];
   }
   function remove_multi$1(comparator, t, key){
    return remove_multi(t, key, 0, comparator[1])[1];
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    return change(t, key, f, 0, comparator[1])[1];
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    return remove(t, key, 0, comparator[1])[1];
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$0(t, f){return iteri_until_loop(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$3(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(t, f){return filter_keys(t, f, [0, 0]);}
   function filter$1(t, f){return filter(t, f, [0, 0]);}
   function filteri$1(t, f){return filteri(t, f, [0, 0]);}
   function filter_map$1(t, f){return filter_map(t, f, [0, 0]);}
   function filter_mapi$1(t, f){return filter_mapi(t, f, [0, 0]);}
   function partition_mapi$1(t, f){return partition_mapi(t, f);}
   function partition_map$1(t, f){return partition_map(t, f);}
   function partitioni_tf$1(t, f){return partitioni_tf(t, f);}
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function combine_errors$1(comparator, t){
    return combine_errors(t, comparator[2]);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$2(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff$0(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    return merge(t1, t2, f, comparator[1])[1];
   }
   function merge_disjoint_exn$1(comparator, t1, t2){
    var a = length(t2);
    return merge_disjoint_exn(t1, t2, length(t1), a, comparator)[1];
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var a = comparator[1], b = length(t2);
    return merge_skewed(t1, t2, length(t1), b, combine, a)[1];
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function sumi$1(m, t, f){return sumi(m, t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function split_le_gt$0(comparator, t, k){
    return split_and_reinsert_boundary(t, 847852583, k, comparator[1]);
   }
   function split_lt_ge$0(comparator, t, k){
    return split_and_reinsert_boundary(t, -57574468, k, comparator[1]);
   }
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var a = nth$0(t, n);
    return Base_Option[31].call(null, 0, 0, 0, a);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    return t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator)[1];
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator), variant = dup[1];
    if(17724 > variant) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    return map_keys_exn(t, f, comparator)[1];
   }
   function transpose_keys$0(outer_comparator, inner_comparator, t){
    var t$0 = transpose_keys(outer_comparator, inner_comparator, t)[1];
    function f(x){return x[1];}
    return map(t$0, f);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return Base_Error[32].call(null, s);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, key, data){return [0, comparator, [0, key, data], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    var length$0 = length(tree);
    return of_tree0(comparator, [0, tree, length$0]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    var a = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[47],
             a,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]), variant = z[1];
    if(17724 > variant) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    var a = of_alist_or_error(alist, comparator);
    return caml_call2
            (Base_Result[33],
             a,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]), variant = z[1];
    if(17724 > variant) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, length, f){
    var tree = of_increasing_iterator_uncheck(length, f);
    return of_tree0(comparator, [0, tree, length]);
   }
   function of_increasing_sequence$1(comparator, seq){
    var a = of_increasing_sequence(seq, comparator[1]);
    return caml_call2
            (Base_Or_error[47],
             a,
             function(x){return of_tree0(comparator, x);});
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]), variant = z[1];
    if(17724 > variant) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    var a = of_sequence_or_error(seq, comparator);
    return caml_call2
            (Base_Result[33],
             a,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function of_list_with_key$1(comparator, list, get_key){
    var z = of_list_with_key(list, get_key, comparator[1]), variant = z[1];
    if(17724 > variant) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_list_with_key_or_error$1(comparator, list, get_key){
    var a = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2
            (Base_Result[33],
             a,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_list_with_key_exn$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_exn(list, get_key, comparator));
   }
   function of_list_with_key_multi$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_multi(list, get_key, comparator[1]));
   }
   function of_list_with_key_fold$1(comparator, list, get_key, init, f){
    return of_tree0
            (comparator,
             of_list_with_key_fold(list, get_key, init, f, comparator[1]));
   }
   function of_list_with_key_reduce$1(comparator, list, get_key, f){
    return of_tree0
            (comparator,
             of_list_with_key_reduce(list, get_key, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator), variant = dup[1];
    if(17724 > variant) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function transpose_keys$1(inner_comparator, t){
    var outer_comparator = t[1];
    return map$0
            (of_tree0
              (inner_comparator,
               transpose_keys
                (outer_comparator, inner_comparator, map(t[2], to_tree))),
             function(x){return of_tree0(outer_comparator, x);});
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){return Base_Comparator[5].call(null, t[1]);}
   var
    to_comparator = Base_Comparator[4],
    t = [0, "_"],
    u = [1, 0],
    v = [1, 0],
    w = [1, 0];
   function of_tree$3(m, tree){return of_tree$0(to_comparator(m), tree);}
   function empty$2(m){return empty$1(to_comparator(m));}
   function singleton$1(m, a){
    var b = to_comparator(m);
    return function(c){return singleton$0(b, a, c);};
   }
   function of_alist$2(m, a){return of_alist$1(to_comparator(m), a);}
   function of_alist_or_error$2(m, a){
    return of_alist_or_error$1(to_comparator(m), a);
   }
   function of_alist_exn$2(m, a){return of_alist_exn$1(to_comparator(m), a);}
   function of_alist_multi$2(m, a){
    return of_alist_multi$1(to_comparator(m), a);
   }
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(to_comparator(m), a, init, f);
   }
   function of_alist_reduce$2(m, a, f){
    return of_alist_reduce$1(to_comparator(m), a, f);
   }
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(to_comparator(m), a);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(to_comparator(m), a);
   }
   function of_iteri$2(m, iteri){return of_iteri$1(to_comparator(m), iteri);}
   function of_iteri_exn$2(m, iteri){
    return of_iteri_exn$1(to_comparator(m), iteri);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(to_comparator(m), len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(to_comparator(m), seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(to_comparator(m), s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(to_comparator(m), s);
   }
   function of_sequence_exn$2(m, s){
    return of_sequence_exn$1(to_comparator(m), s);
   }
   function of_sequence_multi$2(m, s){
    return of_sequence_multi$1(to_comparator(m), s);
   }
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(to_comparator(m), s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(to_comparator(m), s, f);
   }
   function of_list_with_key$2(m, l, get_key){
    return of_list_with_key$1(to_comparator(m), l, get_key);
   }
   function of_list_with_key_or_error$2(m, l, get_key){
    return of_list_with_key_or_error$1(to_comparator(m), l, get_key);
   }
   function of_list_with_key_exn$2(m, l, get_key){
    return of_list_with_key_exn$1(to_comparator(m), l, get_key);
   }
   function of_list_with_key_multi$2(m, l, get_key){
    return of_list_with_key_multi$1(to_comparator(m), l, get_key);
   }
   function of_list_with_key_fold$2(m, l, get_key, init, f){
    return of_list_with_key_fold$1(to_comparator(m), l, get_key, init, f);
   }
   function of_list_with_key_reduce$2(m, l, get_key, f){
    return of_list_with_key_reduce$1(to_comparator(m), l, get_key, f);
   }
   function map_keys$2(m, t, f){return map_keys$1(to_comparator(m), t, f);}
   function map_keys_exn$2(m, t, f){
    return map_keys_exn$1(to_comparator(m), t, f);
   }
   function transpose_keys$2(m, t){
    return transpose_keys$1(to_comparator(m), t);
   }
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t$0){
    return sexp_of_t$2(K[1], sexp_of_v, function(param){return t;}, t$0);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return [5,
            [0,
             Sexplib0_Sexp_grammar[5],
             w,
             [2,
              [1,
               [2,
                [0,
                 [5, [0, Sexplib0_Sexp_grammar[6], v, K[1]]],
                 [0, [5, [0, Sexplib0_Sexp_grammar[7], u, v_grammar]], 0]]]]]]];
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K, hash_fold_v, state){
    var a = K[1];
    return function(b){return hash_fold_direct(a, hash_fold_v, state, b);};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(b){return singleton$0(comparator$0, a, b);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function of_list_with_key$3(l, get_key){
    return of_list_with_key$1(comparator$0, l, get_key);
   }
   function of_list_with_key_or_error$3(l, get_key){
    return of_list_with_key_or_error$1(comparator$0, l, get_key);
   }
   function of_list_with_key_exn$3(l, get_key){
    return of_list_with_key_exn$1(comparator$0, l, get_key);
   }
   function of_list_with_key_multi$3(l, get_key){
    return of_list_with_key_multi$1(comparator$0, l, get_key);
   }
   function of_list_with_key_fold$3(l, get_key, init, f){
    return of_list_with_key_fold$1(comparator$0, l, get_key, init, f);
   }
   function of_list_with_key_reduce$3(l, get_key, f){
    return of_list_with_key_reduce$1(comparator$0, l, get_key, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   function transpose_keys$3(t){return transpose_keys$1(comparator$0, t);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       of_list_with_key$2,
       of_list_with_key_or_error$2,
       of_list_with_key_exn$2,
       of_list_with_key_multi$2,
       of_list_with_key_fold$2,
       of_list_with_key_reduce$2,
       is_empty$0,
       length$0,
       set$0,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$2,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$1,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       transpose_keys$2,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(b){
        var a = Make_applicative_traversals$0(b);
        return [0, a[2], a[3]];
       },
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         transpose_keys$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_list_with_key$0,
         of_list_with_key_or_error$0,
         of_list_with_key_exn$0,
         of_list_with_key_multi$0,
         of_list_with_key_fold$0,
         of_list_with_key_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$1,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$0,
         iter2$1,
         map$1,
         mapi$1,
         fold$3,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         unzip,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_disjoint_exn$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$2,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         sum$1,
         sumi$1,
         split$1,
         split_le_gt$0,
         split_lt_ge$0,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         function(A){
          var Tree0_traversals = Make_applicative_traversals(A);
          function mapi(t, f){return Tree0_traversals[1].call(null, t, f);}
          function filter_mapi(t, f){
           var a = Tree0_traversals[2].call(null, t, f);
           return caml_call2(A[2], a, function(x){return x[1];});
          }
          return [0, mapi, filter_mapi];
         },
         empty_without_value_restrictio,
         Build_increasing],
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        transpose_keys$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_list_with_key$1,
        of_list_with_key_or_error$1,
        of_list_with_key_exn$1,
        of_list_with_key_multi$1,
        of_list_with_key_fold$1,
        of_list_with_key_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$0,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until,
        iter2$0,
        map$0,
        mapi$0,
        fold$2,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        unzip$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_disjoint_exn$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$1,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        sum$0,
        sumi$0,
        split$0,
        split_le_gt,
        split_lt_ge,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        function(b){
         var a = Make_applicative_traversals$0(b);
         return [0, a[2], a[3]];
        },
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        transpose_keys$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_list_with_key$3,
        of_list_with_key_or_error$3,
        of_list_with_key_exn$3,
        of_list_with_key_multi$3,
        of_list_with_key_fold$3,
        of_list_with_key_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$0,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until,
        iter2$0,
        map$0,
        mapi$0,
        fold$2,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        unzip$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_disjoint_exn$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$1,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        sum$0,
        sumi$0,
        split$0,
        split_le_gt,
        split_lt_ge,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        function(b){
         var a = Make_applicative_traversals$0(b);
         return [0, a[2], a[3]];
        }],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
//# shape: Base__Linked_queue0:[F(1)*,F(1),F(1),F(1)*,F(1)*,F(1),F(1),F(2),F(2),F(2),F(3)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){
    var caml_iter = Stdlib_Queue[15];
    return caml_iter(f, t);
   }
   function fold(t, init, f){
    var caml_fold = Stdlib_Queue[16];
    return caml_fold(f, init, t);
   }
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
//# shape: Base__Linked_queue:[F(2),F(2),F(1)*,N,F(1)*,F(1)*,F(2),F(3),N,N,N,N,N,N,N,N,N,F(1),N,N,N,N,N,N,N,N,N,F(1),F(1),F(1),F(2),F(2),F(2),F(1),F(1),F(1),F(3),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1)*,F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return Base_Linked_queue0[8].call(null, x, t);}
   function dequeue(t){
    return is_empty(t) ? 0 : [0, Base_Linked_queue0[7].call(null, t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function dequeue_and_ignore_exn(t){dequeue_exn(t); return 0;}
   function peek(t){
    return is_empty(t) ? 0 : [0, Base_Linked_queue0[6].call(null, t)];
   }
   var peek_exn = Base_Linked_queue0[6];
   function drain(t, f, while$){
    for(;;){
     if(! is_empty(t) && caml_call1(while$, peek_exn(t))){caml_call1(f, dequeue_exn(t)); continue;}
     return 0;
    }
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      Base_Indexed_container[8].call
       (null, [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return Base_Linked_queue0[9].call(null, src, dst);
   }
   function concat_map(t, f){
    var res = create(0);
    iter
     (t,
      function(a){
       var b = caml_call1(f, a);
       return Base_List[19].call
               (null, b, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = create(0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var b = caml_call2(f, i, a);
       return Base_List[19].call
               (null, b, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function filter_map(t, f){
    var res = create(0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = create(0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = create(0);
    iter
     (t,
      function(a){var b = caml_call1(f, a); return b ? enqueue(res, a) : b;});
    return res;
   }
   function filteri(t, f){
    var res = create(0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var b = caml_call2(f, i, a);
       return b ? enqueue(res, a) : b;
      });
    return res;
   }
   function map(t, f){
    var res = create(0);
    iter(t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = create(0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    clear(q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    clear(q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    return Base_List[19].call(null, list, function(x){return enqueue(t, x);});
   }
   function of_list(list){
    var t = create(0);
    Base_List[19].call(null, list, function(x){return enqueue(t, x);});
    return t;
   }
   function of_array(array){
    var t = create(0);
    Base_Array[20].call(null, array, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    var t = create(0), a = Base_Import[93].call(null, len, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return t;
   }
   function to_array(t){
    var len = length(t);
    if(0 === len) return [0];
    var a = peek_exn(t), arr = Base_Array[48].call(null, len, a), i = [0, 0];
    iter
     (t,
      function(v){
       var a = i[1];
       runtime.caml_check_bound(arr, a)[a + 1] = v;
       i[1]++;
       return 0;
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(Base_Import[173].call(null, a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var a = caml_call1(to_list, t);
    return Base_Import[149].call(null, sexp_of_a, a);
   }
   function t_sexp_grammar(grammar){
    var a = Base_List[7].call(null, grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function singleton(a){var t = create(0); enqueue(t, a); return t;}
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
//# shape: Base__Int64:[F(1)*,N,F(1),F(1)*,F(1)*,F(1),N,F(1),F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1),N,N,N,F(2),N,N,N,N,N,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1),F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1),F(1)*,N,N,N,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(2),F(1)*,F(1)*,N,N,N,N,F(1),F(1),F(1),F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    func = Base_Import[217];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(b, a){return caml_int64_compare(b, a);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    of_string_opt = Stdlib_Int64[13],
    include = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include[1],
    num_bits = 64,
    float_lower_bound = Base_Float0[26].call(null, num_bits),
    float_upper_bound = Base_Float0[24].call(null, num_bits),
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    symbol = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    a =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound)
     return caml_int64_of_float(f);
    var b = Base_Float0[29].call(null, f);
    return caml_call2(Base_Printf[7].call(null, a), b, 0);
   }
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = Base_Comparable[14].call(null, [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    b = [0, "src/int64.ml", 115, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var a = caml_lessequal(low, t), b = a ? caml_lessequal(t, high) : a;
    return b;
   }
   function clamp_unchecked(t, min, max){
    var a = Base_Import[103][4].call(null, t, max);
    return Base_Import[103][3].call(null, min, a);
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(a){return a;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[12],
    to_int_exn = Base_Int_conversions[13],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[15],
    to_int32_exn = Base_Int_conversions[16],
    of_nativeint_exn = caml_int64_of_int32,
    to_nativeint = Base_Int_conversions[18],
    to_nativeint_exn = Base_Int_conversions[19],
    raise_s = Base_Error[32],
    c =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_];
   function non_positive_argument(param){
    return caml_call1(Base_Printf[7].call(null, c), 0);
   }
   var
    lsr = caml_int64_shift_right_unsigne,
    land = caml_int64_and,
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input";
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = Stdlib_Int64[7].call(null, x),
     x$6 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x$6, caml_int64_shift_right_unsigne(x$6, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return Stdlib_Int64[6].call(null, x$1);
   }
   function floor_pow2(x$0){
    if(caml_lessequal(x$0, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_int64_sub(x$1, caml_int64_shift_right_unsigne(x$1, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var a = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, Stdlib_Int64[7].call(null, x)), a);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var a = [0, [0, cst, Base_Import[142].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int64_floor_log2_got_inval, a));
    }
    var
     b = runtime.Base_int_math_int64_clz(i),
     c = Base_Import[93].call(null, num_bits, 1);
    return Base_Import[93].call(null, c, b);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var a = [0, [0, cst$0, Base_Import[142].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int64_ceil_log2_got_invali, a));
    }
    if(Stdlib_Int64[17].call(null, i, Stdlib_Int64[2])) return 0;
    var b = runtime.Base_int_math_int64_clz(Stdlib_Int64[7].call(null, i));
    return Base_Import[93].call(null, num_bits, b);
   }
   var
    include$1 = Base_Int_string_conversions[1].call(null, [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local = Base_Import[258];
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[203], func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    symbol$0 = caml_lessthan,
    d = [0, [7, 6, 0, 0, 0], cst_Lx],
    e = [0, [7, 6, 0, 0, 0], cst_Lx];
   function to_string$0(i){
    return caml_call1(Base_Printf[2].call(null, d), i);
   }
   function of_string$0(s){
    return caml_call1
            (Stdlib_Scanf[5].call(null, s, e), function(a){return a;});
   }
   var
    include$2 =
      Base_Int_string_conversions[2].call
       (null,
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    compare_local$0 = Base_Import[258];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[272];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[203], func$1 = Base_Import[217];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(a){return runtime.Base_int_math_int64_clz(a);}
   var
    include$3 =
      Base_Int_string_conversions[3].call
       (null,
        [0,
         compare$1,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = Base_Pretty_printer[2].call(null, [0, module_name$0, to_string])[1],
    include$4 =
      Base_Int_math[1].call
       (null,
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$4[1],
    symbol$2 = include$4[2],
    symbol$3 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max = include$5[3],
    min = include$5[4],
    Base_Int64 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(b, a){return caml_int64_compare(b, a);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       function(b, a){return caml_int64_compare(b, a);},
       caml_equal,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       symbol,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(a){return runtime.Base_int_math_int64_clz(a);},
       function(a){return runtime.Base_int_math_int64_ctz(a);},
       [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       to_nativeint,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(30, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64
//# shape: Base__Int63_emul:[F(1)*,N,F(1),F(1)*,F(1),F(1),N,F(1)*,F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1),N,N,F(1),N,N,N,N,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1)*,N,N,F(2),F(2),N,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,N,N,N,F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1),F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,[],N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_create_lo_mi_hi = runtime.caml_int64_create_lo_mi_hi,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    a = caml_int64_create_lo_mi_hi(2, 0, 0),
    mask = caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    include = Base_Import[103],
    max = include[3],
    min = include[4],
    compare_local = Base_Import[258];
   function compare(a, b){return caml_call2(compare_local, a, b);}
   var
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    include$0 = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include$0[1],
    c = caml_int64_create_lo_mi_hi(2, 0, 0),
    g = [0, cst_src_int63_emul_ml, 117, 20];
   function wrap_exn(x){
    Base_Int_conversions[21].call(null, x);
    return caml_int64_mul(x, c);
   }
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function invariant(t){
    if(caml_equal(caml_int64_and(t, mask), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return Stdlib_Int64[8].call(null, x);}
   var one = wrap_exn(caml_int64_create_lo_mi_hi(1, 0, 0));
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var
    x = Stdlib_Int64[10],
    min_value = caml_int64_and(x, mask),
    x$0 = Stdlib_Int64[9],
    max_value = caml_int64_and(x$0, mask);
   function bit_not(x){
    var x$0 = Stdlib_Int64[11].call(null, x);
    return caml_int64_and(x$0, mask);
   }
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){
    var x$0 = caml_int64_shift_right(x, i);
    return caml_int64_and(x$0, mask);
   }
   function shift_right_logical(x, i){
    var x$0 = caml_int64_shift_right_unsigne(x, i);
    return caml_int64_and(x$0, mask);
   }
   var f = Base_Int_math[2][3], e = caml_int64_create_lo_mi_hi(2, 0, 0);
   function pow(a, b){
    return caml_int64_mul
            (f(caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)), e);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a$0, b){
    var x = runtime.caml_int64_div(a$0, b);
    return caml_int64_mul(x, a);
   }
   var rem = runtime.caml_int64_mod, d = caml_int64_create_lo_mi_hi(2, 0, 0);
   function popcount(x){return Base_Popcount[3].call(null, x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return Base_Int_conversions[22].call(null, t)
            ? [0, caml_int64_mul(t, d)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return caml_int64_mul(t, a);}
   function t_of_sexp(x){return wrap_exn(Base_Import[166].call(null, x));}
   function sexp_of_t$0(x){
    return Base_Import[142].call(null, caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare_local, x, y);}
   function compare_local$0(x, y){return caml_call2(compare_local, x, y);}
   var equal_local = caml_equal;
   function is_pow2(x){
    return Base_Int64[72].call(null, caml_int64_shift_right(x, 1));
   }
   function clz(x){return Base_Int64[73].call(null, x);}
   function ctz(x){
    return Base_Int64[74].call(null, caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(Base_Int64[69].call(null, caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(Base_Int64[69].call(null, caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return Base_Int64[71].call(null, caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return Base_Int64[70].call(null, caml_int64_shift_right(x, 1));
   }
   function hash(x){return Base_Import[85][105][28].call(null, x);}
   var
    hashable = [0, hash, compare$0, sexp_of_t$0],
    h =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    i = caml_int64_create_lo_mi_hi(0, 0, 0);
   function invalid_str(x){
    return caml_call2(Base_Printf[6].call(null, h), x, 0);
   }
   function to_string(x){
    return Stdlib_Int64[14].call(null, caml_int64_shift_right(x, 1));
   }
   function of_string_raw(str){
    var len = caml_ml_string_length(str);
    a:
    if(0 < len){
     var switcher = caml_string_get(str, 0) - 43 | 0;
     if(2 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var sign = 4003188, pos = 1; break a;
        case 2:
         var sign = 3901488, pos = 1; break a;
      }
     var sign = 4003188, pos = 0;
    }
    else
     var sign = 4003188, pos = 0;
    if(Base_Import[91].call(null, pos, 2) < len)
     var
      c1 = caml_string_get(str, pos),
      c2 = caml_string_get(str, Base_Import[91].call(null, pos, 1)),
      match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
    else
     var match = [0, , 1];
    var signedness = match[2];
    if(signedness){var t = caml_int64_of_string(str); return wrap_exn(t);}
    if(4003188 <= sign)
     var pos_str = str;
    else
     var
      b = Base_Import[93].call(null, caml_ml_string_length(str), 1),
      pos_str = Base_String[3].call(null, str, 1, b);
    var int64 = caml_int64_of_string(pos_str);
    if(caml_lessthan(int64, i)) invalid_str(str);
    var int63 = caml_int64_mul(int64, a);
    return 4003188 <= sign ? int63 : caml_int64_neg(int63);
   }
   function of_string(str){
    try{var a = of_string_raw(str); return a;}
    catch(exn){return invalid_str(str);}
   }
   function of_string_opt(str){
    try{var t = of_string_raw(str);}catch(exn){return 0;}
    return [0, t];
   }
   function bswap16(t){
    var x = Base_Int64[86].call(null, caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, a);
   }
   function bswap32(t){
    var x = Base_Int64[87].call(null, caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, a);
   }
   function bswap48(t){
    var x = Base_Int64[88].call(null, caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, a);
   }
   var
    num_bits = 63,
    float_lower_bound = Base_Float0[26].call(null, num_bits),
    float_upper_bound = Base_Float0[24].call(null, num_bits),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    j =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"];
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){
    var x$0 = caml_int64_of_float(x);
    return caml_int64_mul(x$0, a);
   }
   function of_float(t){
    if(float_lower_bound <= t && t <= float_upper_bound){
     var x = caml_int64_of_float(t);
     return caml_int64_mul(x, a);
    }
    var b = Base_Float0[29].call(null, t);
    return caml_call2(Base_Printf[7].call(null, j), b, 0);
   }
   var
    b = Base_Comparable[14].call(null, [0, compare$0, sexp_of_t$0, zero]),
    is_positive = b[1],
    is_non_negative = b[2],
    is_negative = b[3],
    is_non_positive = b[4],
    sign = b[5],
    k = [0, cst_src_int63_emul_ml, 334, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function between(t, low, high){
    var a = caml_lessequal(low, t), b = a ? caml_lessequal(t, high) : a;
    return b;
   }
   function clamp_unchecked(t, min$0, max$0){return max(min$0, min(t, max$0));
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     b = [0, [0, cst_min, sexp_of_t$0(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){var x = r[1]; r[1] = caml_int64_add(x, one$0); return 0;}
   function decr(r){var x = r[1]; r[1] = caml_int64_sub(x, one$0); return 0;}
   function of_int(x){return wrap_exn(Base_Int_conversions[4].call(null, x));}
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return Base_Int_conversions[12].call(null, caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return Base_Int_conversions[13].call(null, caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return Base_Int_conversions[14].call(null, caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(Base_Int_conversions[9].call(null, x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return Base_Int_conversions[15].call(null, caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return Base_Int_conversions[16].call(null, caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return Base_Int_conversions[17].call(null, caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(Base_Int_conversions[29].call(null, x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(Base_Int_conversions[29].call(null, x));
   }
   function of_nativeint_trunc(x){
    var t = Base_Int_conversions[29].call(null, x);
    return caml_int64_mul(t, a);
   }
   function to_nativeint(x){
    return Base_Int_conversions[18].call(null, caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return Base_Int_conversions[19].call(null, caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return Base_Int_conversions[20].call(null, caml_int64_shift_right(x, 1));
   }
   var
    include$1 = Base_Int_string_conversions[1].call(null, [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$1 = include$1[2];
   function compare$1(a, b){return caml_call2(compare_local, a, b);}
   function hash$0(x){return hash(x);}
   var
    symbol$5 = caml_lessthan,
    l = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_0x = "0x";
   function to_string$0(i){
    return caml_call1
            (Base_Printf[2].call(null, l),
             caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(Base_Import[112].call(null, cst_0x, s));
   }
   var
    include$2 =
      Base_Int_string_conversions[2].call
       (null,
        [0,
         compare$1,
         compare_local$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$2[1];
   function to_string$1(x){return to_string(x);}
   var
    pp = Base_Pretty_printer[2].call(null, [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$3 =
      Base_Int_math[1].call
       (null,
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8];
   function compare$2(a, b){return caml_call2(compare_local, a, b);}
   var equal = caml_equal;
   function hash$1(x){return hash(x);}
   var
    include$4 =
      Base_Int_string_conversions[3].call
       (null,
        [0,
         compare$2,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t,
         hash$1,
         clz,
         shift_right_logical,
         bit_and,
         to_int_exn,
         num_bits,
         one$0,
         zero]),
    Binary = include$4[1],
    Repr = [0],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max$0 = include$5[3],
    min$0 = include$5[4],
    Base_Int63_emul =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(b, a){return caml_int64_compare(b, a);},
       min$0,
       max$0,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       function(b, a){return caml_int64_compare(b, a);},
       caml_equal,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       [0,
        symbol,
        symbol$0,
        symbol$2,
        symbol$3,
        symbol$1,
        symbol$4,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$1,
        zero,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       [0, wrap_exn, unwrap],
       Repr,
       1];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Base__Bool0, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
//# shape: Base__Int32:[F(1)*,N,F(1),F(1)*,F(1),F(1),N,F(1),F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1)*,N,N,F(1),N,N,N,N,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1)*,N,N,F(2),F(2),N,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1),F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1)*,F(1)*,N,N,N,F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,F(1),F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[285],
    hash_fold_t = Base_Import[204],
    func = Base_Import[218];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return Stdlib_Int32[15].call(null, x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Int32[13],
    include = Base_Comparator[7].call(null, [0, ascending, sexp_of_t]),
    comparator = include[1],
    num_bits = 32,
    float_lower_bound = Base_Float0[26].call(null, num_bits),
    float_upper_bound = Base_Float0[24].call(null, num_bits),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float;
   function shift_right_logical(b, a){return b >>> a | 0;}
   function shift_right(b, a){return b >> a;}
   function shift_left(b, a){return b << a;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(b, a){return b ^ a;}
   function bit_or(b, a){return b | a;}
   function bit_and(b, a){return b & a;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(a){return - a | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    compare_local = runtime.caml_compare,
    a =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function to_float(a){return a;}
   function of_float_unchecked(a){return a | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var b = Base_Float0[29].call(null, f);
    return caml_call2(Base_Printf[7].call(null, a), b, 0);
   }
   var
    include$0 =
      Base_Comparable[14].call(null, [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = runtime.caml_lessthan,
    symbol$5 = runtime.caml_notequal;
   function descending(x, y){return ascending(y, x);}
   function min(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   function max(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   var
    equal = caml_equal,
    equal_local = caml_equal,
    b = [0, "src/int32.ml", 103, 4],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function between(t, low, high){
    var a = caml_lessequal(low, t);
    return a ? caml_lessequal(t, high) : a;
   }
   function clamp_unchecked(t, min$0, max$0){return max(min$0, min(t, max$0));
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(b, a){return b - a | 0;}
   function symbol$9(b, a){return b + a | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[15],
    of_int64_exn = Base_Int_conversions[16],
    of_int64_trunc = Base_Int_conversions[17],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[26],
    of_nativeint_exn = Base_Int_conversions[27],
    of_nativeint_trunc = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var a = to_int_exn(e), c = to_int_exn(b);
    return of_int_exn(Base_Int_math[2][1].call(null, c, a));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var
    raise_s = Base_Error[32],
    c =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call1(Base_Printf[7].call(null, c), 0);
   }
   function lsr(b, a){return b >>> a | 0;}
   function land(b, a){return b & a;}
   function ceil_pow2(x){
    if(Base_Import[102][2].call(null, x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = Stdlib_Int32[7].call(null, x),
     x$5 = x$0 | x$0 >>> 1 | 0,
     x$4 = x$5 | x$5 >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return Stdlib_Int32[6].call(null, x$1);
   }
   function floor_pow2(x$0){
    if(Base_Import[102][2].call(null, x$0, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$4 = x | x >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(Base_Import[102][2].call(null, x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var a = Stdlib_Int32[1], b = x & Stdlib_Int32[7].call(null, x);
    return Base_Import[102][4].call(null, b, a);
   }
   function floor_log2(i){
    if(Base_Import[102][2].call(null, i, Stdlib_Int32[1])){
     var a = [0, [0, cst, Base_Import[141].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int32_floor_log2_got_inval, a));
    }
    var
     b = runtime.Base_int_math_int32_clz(i),
     c = Base_Import[93].call(null, num_bits, 1);
    return Base_Import[93].call(null, c, b);
   }
   function ceil_log2(i){
    if(Base_Import[102][2].call(null, i, Stdlib_Int32[1])){
     var a = [0, [0, cst$0, Base_Import[141].call(null, i)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int32_ceil_log2_got_invali, a));
    }
    if(Stdlib_Int32[17].call(null, i, Stdlib_Int32[2])) return 0;
    var b = runtime.Base_int_math_int32_clz(Stdlib_Int32[7].call(null, i));
    return Base_Import[93].call(null, num_bits, b);
   }
   var
    include$1 = Base_Int_string_conversions[1].call(null, [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local$0 = Base_Import[257];
   function compare(a, b){return caml_call2(compare_local$0, a, b);}
   var
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218],
    d = [0, [5, 6, 0, 0, 0], cst_lx],
    e = [0, [5, 6, 0, 0, 0], cst_lx];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){
    return caml_call1(Base_Printf[2].call(null, d), i);
   }
   function of_string$0(s){
    return caml_call1
            (Stdlib_Scanf[5].call(null, s, e), function(a){return a;});
   }
   var
    include$2 =
      Base_Int_string_conversions[2].call
       (null,
        [0,
         compare,
         compare_local$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    compare_local$1 = Base_Import[257];
   function compare$0(a, b){return caml_call2(compare_local$1, a, b);}
   var equal_local$0 = Base_Import[271];
   function equal$0(a, b){return caml_call2(equal_local$0, a, b);}
   var hash_fold_t$1 = Base_Import[204], func$1 = Base_Import[218];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(a){return runtime.Base_int_math_int32_clz(a);}
   var
    include$3 =
      Base_Int_string_conversions[3].call
       (null,
        [0,
         compare$0,
         compare_local$1,
         equal$0,
         equal_local$0,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = Base_Pretty_printer[2].call(null, [0, module_name$0, to_string])[1],
    include$4 =
      Base_Int_math[1].call
       (null,
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$4[1],
    symbol$12 = include$4[2],
    symbol$13 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    Base_Int32 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local,
       equal_local,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(a){return runtime.Base_int_math_int32_clz(a);},
       function(a){return runtime.Base_int_math_int32_ctz(a);},
       [0,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        symbol,
        symbol$10,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        abs,
        symbol,
        zero,
        symbol$11,
        symbol$12,
        symbol$13,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       caml_int32_bswap];
   runtime.caml_register_global(30, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Sys0, Base__Word_size
//# shape: Base__Int63:[N,F(1),F(1)*,F(1),F(1),N,F(1),F(1),N,F(1),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,N,N,N,N,N,F(2)*,F(2)*,F(1),N,N,F(1),N,N,N,N,F(2)*,F(2)*,F(2)*,F(2),F(1)*,F(1)*,N,N,F(2),F(2),N,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(2),F(2)*,F(2)*,F(2)*,F(1)*,F(1),F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,N,N,N,F(2)*,F(2)*,F(1),F(1),F(1),F(1),F(1),F(1),N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2),F(3),F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Base_Sys0 = global_data.Base__Sys0,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[32],
    include$0 = Base_Sys0[19].call(null, [0], [0]),
    repr = include$0[1],
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$0 = Base_Int[80],
    symbol$1 = Base_Int[81],
    symbol$2 = Base_Int[82],
    of_int = Base_Int[84],
    to_int32 = Base_Int[87],
    of_int64 = Base_Int[88],
    of_nativeint = Base_Int[89],
    a = Base_Int[90];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return a(x);}
   function to_nativeint(x){return [0, a(x)];}
   function bswap32(t){
    return caml_int64_to_int32
            (Base_Int64[87].call(null, caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (Base_Int64[88].call(null, caml_int64_of_int32(t)));
   }
   var
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    b = [0, "src/int63.ml", 110, 9],
    repr$0 = 0,
    include =
      repr
       ? [0,
         Base_Int63_emul[2],
         Base_Int63_emul[3],
         Base_Int63_emul[4],
         Base_Int63_emul[5],
         Base_Int63_emul[6],
         Base_Int63_emul[7],
         Base_Int63_emul[8],
         Base_Int63_emul[9],
         Base_Int63_emul[10],
         Base_Int63_emul[11],
         Base_Int63_emul[12],
         Base_Int63_emul[13],
         Base_Int63_emul[14],
         Base_Int63_emul[15],
         Base_Int63_emul[16],
         Base_Int63_emul[17],
         Base_Int63_emul[18],
         Base_Int63_emul[19],
         Base_Int63_emul[20],
         Base_Int63_emul[21],
         Base_Int63_emul[22],
         Base_Int63_emul[23],
         Base_Int63_emul[24],
         Base_Int63_emul[25],
         Base_Int63_emul[26],
         Base_Int63_emul[27],
         Base_Int63_emul[28],
         Base_Int63_emul[29],
         Base_Int63_emul[30],
         Base_Int63_emul[31],
         Base_Int63_emul[32],
         Base_Int63_emul[33],
         Base_Int63_emul[34],
         Base_Int63_emul[35],
         Base_Int63_emul[36],
         Base_Int63_emul[37],
         Base_Int63_emul[38],
         Base_Int63_emul[39],
         Base_Int63_emul[40],
         Base_Int63_emul[41],
         Base_Int63_emul[42],
         Base_Int63_emul[43],
         Base_Int63_emul[44],
         Base_Int63_emul[45],
         Base_Int63_emul[46],
         Base_Int63_emul[47],
         Base_Int63_emul[48],
         Base_Int63_emul[49],
         Base_Int63_emul[50],
         Base_Int63_emul[51],
         Base_Int63_emul[52],
         Base_Int63_emul[53],
         Base_Int63_emul[54],
         Base_Int63_emul[55],
         Base_Int63_emul[56],
         Base_Int63_emul[57],
         Base_Int63_emul[58],
         Base_Int63_emul[59],
         Base_Int63_emul[60],
         Base_Int63_emul[61],
         Base_Int63_emul[62],
         Base_Int63_emul[63],
         Base_Int63_emul[64],
         Base_Int63_emul[65],
         Base_Int63_emul[66],
         Base_Int63_emul[67],
         Base_Int63_emul[68],
         Base_Int63_emul[69],
         Base_Int63_emul[70],
         Base_Int63_emul[71],
         Base_Int63_emul[72],
         Base_Int63_emul[73],
         Base_Int63_emul[74],
         Base_Int63_emul[75],
         Base_Int63_emul[76],
         Base_Int63_emul[77],
         Base_Int63_emul[78],
         Base_Int63_emul[79],
         Base_Int63_emul[80],
         Base_Int63_emul[81],
         Base_Int63_emul[82],
         Base_Int63_emul[83],
         Base_Int63_emul[84],
         Base_Int63_emul[85],
         Base_Int63_emul[86],
         Base_Int63_emul[88],
         Base_Int63_emul[89],
         Base_Int63_emul[90],
         Base_Int63_emul[91],
         Base_Int63_emul[92],
         Base_Int63_emul[93],
         Base_Int63_emul[94],
         Base_Int63_emul[95],
         ,
         Base_Int63_emul[97],
         Base_Int63_emul[98],
         Base_Int63_emul[99],
         Base_Int63_emul[100],
         Base_Int63_emul[101],
         Base_Int63_emul[102],
         Base_Int63_emul[103],
         Base_Int63_emul[104],
         Base_Int63_emul[105],
         Base_Int63_emul[106],
         Base_Int63_emul[107],
         Base_Int63_emul[108],
         Base_Int63_emul[109],
         Base_Int63_emul[110],
         Base_Int63_emul[111],
         Base_Int63_emul[112],
         Base_Int63_emul[87],
         Base_Int63_emul[118],
         Base_Int63_emul[113],
         Base_Int63_emul[114],
         Base_Int63_emul[115]]
       : [0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(b, a){return a <= b ? 1 : 0;},
         function(b, a){return b <= a ? 1 : 0;},
         function(b, a){return b === a ? 1 : 0;},
         function(b, a){return a < b ? 1 : 0;},
         function(b, a){return b < a ? 1 : 0;},
         function(b, a){return b !== a ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         compare_local,
         equal_local,
         invariant,
         Hex,
         Binary,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(b, a){return b + a | 0;},
         function(b, a){return b - a | 0;},
         caml_mul,
         symbol,
         function(a){return - a | 0;},
         function(a){return - a | 0;},
         symbol$1,
         symbol$0,
         caml_div,
         rem,
         symbol$2,
         function(b, a){return b & a;},
         function(b, a){return b | a;},
         function(b, a){return b ^ a;},
         lnot,
         function(b, a){return b << a;},
         function(b, a){return b >> a;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         num_bits,
         max_value,
         min_value,
         function(b, a){return b >>> a | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         ,
         is_pow2,
         clz,
         ctz,
         [0,
          function(b, a){return b + a | 0;},
          function(b, a){return b - a | 0;},
          caml_mul,
          caml_div,
          function(a){return - a | 0;},
          O[1],
          function(b, a){return a <= b ? 1 : 0;},
          function(b, a){return b <= a ? 1 : 0;},
          function(b, a){return b === a ? 1 : 0;},
          function(b, a){return a < b ? 1 : 0;},
          function(b, a){return b < a ? 1 : 0;},
          function(b, a){return b !== a ? 1 : 0;},
          O[3],
          function(a){return - a | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(b, a){return b & a;},
          function(b, a){return b | a;},
          function(b, a){return b ^ a;},
          O[2],
          function(b, a){return b << a;},
          function(b, a){return b >> a;},
          function(b, a){return b >>> a | 0;}],
         of_int,
         to_int,
         to_int_trunc,
         of_int32_exn,
         to_int32,
         function(a){return a;},
         of_int64,
         caml_int64_to_int32,
         of_nativeint,
         to_nativeint,
         function(a){return a;},
         to_nativeint_trunc,
         of_float_unchecked,
         repr$0,
         runtime.caml_bswap16,
         bswap32,
         bswap48],
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    compare_local$0 = include[35],
    equal_local$0 = include[36],
    invariant$0 = include[37],
    Hex$0 = include[38],
    Binary$0 = include[39],
    of_string_opt$0 = include[40],
    to_string_hum$0 = include[41],
    zero$0 = include[42],
    one$0 = include[43],
    minus_one$0 = include[44],
    symbol$9 = include[45],
    symbol$10 = include[46],
    symbol$11 = include[47],
    symbol$12 = include[48],
    neg = include[49],
    symbol$13 = include[50],
    symbol$14 = include[51],
    symbol$15 = include[52],
    symbol$16 = include[53],
    rem$0 = include[54],
    symbol$17 = include[55],
    land = include[56],
    lor = include[57],
    lxor = include[58],
    lnot$0 = include[59],
    lsl = include[60],
    asr = include[61],
    round$0 = include[62],
    round_towards_zero$0 = include[63],
    round_down$0 = include[64],
    round_up$0 = include[65],
    round_nearest$0 = include[66],
    abs$0 = include[67],
    succ$0 = include[68],
    pred$0 = include[69],
    pow$0 = include[70],
    bit_and$0 = include[71],
    bit_or$0 = include[72],
    bit_xor$0 = include[73],
    bit_not$0 = include[74],
    popcount$0 = include[75],
    shift_left$0 = include[76],
    shift_right$0 = include[77],
    decr$0 = include[78],
    incr$0 = include[79],
    of_int32_exn$0 = include[80],
    to_int32_exn$0 = include[81],
    of_int64_exn$0 = include[82],
    to_int64$0 = include[83],
    of_nativeint_exn$0 = include[84],
    to_nativeint_exn$0 = include[85],
    num_bits$0 = include[86],
    max_value$0 = include[87],
    min_value$0 = include[88],
    lsr = include[89],
    shift_right_logical$0 = include[90],
    ceil_pow2$0 = include[91],
    floor_pow2$0 = include[92],
    ceil_log2$0 = include[93],
    is_pow2$0 = include[95],
    clz$0 = include[96],
    ctz$0 = include[97],
    O$0 = include[98],
    of_int$0 = include[99],
    to_int$0 = include[100],
    to_int_trunc$0 = include[101],
    of_int32 = include[102],
    to_int32$0 = include[103],
    to_int32_trunc = include[104],
    of_int64$0 = include[105],
    of_int64_trunc = include[106],
    of_nativeint$0 = include[107],
    to_nativeint$0 = include[108],
    of_nativeint_trunc = include[109],
    to_nativeint_trunc$0 = include[110],
    of_float_unchecked$0 = include[111],
    repr$1 = include[112],
    bswap16 = include[113],
    bswap32$0 = include[114],
    bswap48$0 = include[115];
   function symbol$18(t, u){
    var sum = symbol$9(t, u), a = bit_xor$0(t, bit_not$0(sum));
    if(symbol$7(bit_or$0(bit_xor$0(t, u), a), zero$0)) return sum;
    var
     b = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     c = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], b],
     d = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], c];
    return raise_s(Base_Sexp[10].call(null, cst_overflow, d));
   }
   function symbol$19(t, u){
    var diff = symbol$10(t, u), pos_diff = symbol$6(t, u);
    if(symbol$8(t, u)){
     var a = caml_call1(is_positive$0, diff);
     if(Base_Bool[15].call(null, pos_diff, a)){
      var
       b = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       c = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], b],
       d = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], c];
      return raise_s(Base_Sexp[10].call(null, cst_overflow$0, d));
     }
    }
    return diff;
   }
   var negative_one = of_int$0(-1);
   function div_would_overflow(t, u){
    var a = symbol$5(t, min_value$0);
    return a ? symbol$5(u, negative_one) : a;
   }
   function symbol$20(t, u){
    var product = symbol$11(t, u);
    a:
    if(symbol$8(u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! symbol$8(symbol$16(product, u), t))
      break a;
     var
      a = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      b = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], a],
      c = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], b];
     return raise_s(Base_Sexp[10].call(null, cst_overflow$1, c));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return symbol$16(t, u);
    var
     a = [0, [0, cst_product$0, caml_call1(sexp_of_t$0, symbol$16(t, u))], 0],
     b = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], a],
     c = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], b];
    return raise_s(Base_Sexp[10].call(null, cst_overflow$2, c));
   }
   function abs$1(t){
    return symbol$5(t, min_value$0)
            ? Base_Import[124].call(null, cst_abs_overflow)
            : abs$0(t);
   }
   function neg$0(t){
    return symbol$5(t, min_value$0)
            ? Base_Import[124].call(null, cst_neg_overflow)
            : neg(t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   function random_of_int(opt, bound){
    var state = opt ? opt[1] : Base_Random[19][1], a = to_int_exn$0(bound);
    return of_int$0(caml_call2(Base_Random[19][7], state, a));
   }
   function random_of_int64(opt, bound){
    var state = opt ? opt[1] : Base_Random[19][1], a = to_int64$0(bound);
    return of_int64_exn$0(caml_call2(Base_Random[19][10], state, a));
   }
   var random = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    var
     state = opt ? opt[1] : Base_Random[19][1],
     a = to_int_exn$0(hi),
     b = to_int_exn$0(lo);
    return of_int$0(caml_call3(Base_Random[19][12], state, b, a));
   }
   function random_incl_of_int64(opt, lo, hi){
    var
     state = opt ? opt[1] : Base_Random[19][1],
     a = to_int64$0(hi),
     b = to_int64$0(lo);
    return of_int64_exn$0(caml_call3(Base_Random[19][15], state, b, a));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var a = to_int_exn$0(t);
     return Base_Int[71].call(null, a);
    }
    if(symbol$4(t, zero$0)){
     var b = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     raise_s(Base_Sexp[10].call(null, cst_Int_floor_log2_got_invalid, b));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if(! equal$0(zero$0, bit_and$0(t, shift_left$0(one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       compare_local$0,
       equal_local$0,
       invariant$0,
       Hex$0,
       Binary$0,
       of_string_opt$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[117], repr$1]];
   runtime.caml_register_global(32, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable_intf
//# shape: Base__Dictionary_mutable_intf:[[[]]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Merge_into_action = [0],
    Definitions = [0, Merge_into_action],
    Base_Dictionary_mutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable_intf, "Base__Dictionary_mutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable
//# unitInfo: Requires: Base__Dictionary_mutable_intf
//# shape: Base__Dictionary_mutable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_mutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable, "Base__Dictionary_mutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
//# shape: Base__Hashtbl_intf:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Base_Hashtbl_intf = [0, Key];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Base__Error, Base__Import, Base__Sexp
//# shape: Base__Avltree:[N,F(1)*,F(2),F(6),F(1),F(1),F(3),F(5),F(6),F(7),F(5),F(6),F(7),F(3),F(4),F(3),F(2),F(2),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32];
   function max(x, y){return y < x ? x : y;}
   var
    a = [0, cst_src_avltree_ml, 50, 6],
    b = [0, cst_src_avltree_ml, 56, 6],
    c = [0, cst_src_avltree_ml, 67, 6],
    d = [0, cst_src_avltree_ml, 66, 6],
    e = [0, cst_src_avltree_ml, 87, 22],
    f = [0, cst_src_avltree_ml, 110, 26],
    g = [0, cst_src_avltree_ml, 129, 30],
    h = [0, cst_src_avltree_ml, 145, 26],
    i = [0, cst_src_avltree_ml, 163, 30],
    dummy = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
      }
      var e = max(hl, hr);
      if(h !== Base_Import[91].call(null, e, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
      var f = Base_Import[93].call(null, hl, hr);
      if(2 < Base_Import[123].call(null, f))
       throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(param){
    if(typeof param !== "number" && 0 === param[0]){
     var
      left = param[1],
      old_height = param[4],
      right = param[5],
      a = height(right),
      b = max(height(left), a),
      new_height = Base_Import[91].call(null, b, 1);
     if(new_height !== old_height) param[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left = root_node[1],
      right = root_node[5],
      hl = height(left),
      hr = height(right);
     if(Base_Import[91].call(null, hr, 2) < hl){
      if(typeof left !== "number" && 0 === left[0]){
       var
        left_node_left = left[1],
        left_node_right = left[5],
        a = height(left_node_right);
       if(a <= height(left_node_left)){
        root_node[1] = left_node_right;
        left[5] = root_node;
        update_height(root_node);
        update_height(left);
        return left;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left;
        update_height(left);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
     }
     if(Base_Import[91].call(null, hl, 2) >= hr){
      update_height(root_node);
      return root_node;
     }
     if(typeof right !== "number" && 0 === right[0]){
      var
       right_node_left = right[1],
       right_node_right = right[5],
       b = height(right_node_left);
      if(b <= height(right_node_right)){
       root_node[5] = right_node_left;
       right[1] = root_node;
       update_height(root_node);
       update_height(right);
       return right;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right;
       update_height(right);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
    }
    return root_node;
   }
   function add(t, replace, compare, added, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){added[1] = 0; if(replace) t[3] = v; return t;}
    if(0 <= c){
     var right$0 = add(right, replace, compare, added, k, v);
     if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
    }
    else{
     var left$0 = add(left, replace, compare, added, k, v);
     if(1 - (left$0 === left ? 1 : 0)) t[1] = left$0;
    }
    return added[1] ? balance(t) : t;
   }
   function first(t$0){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var l = t[1];
      if(typeof l !== "number"){t = l; continue;}
      var v = t[3], k = t[2];
     }
     else
      var k$0 = t[1], v$0 = t[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t$0){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 === t[0]){
      var k = t[2], v = t[3];
      if(typeof t[5] !== "number"){var r = t[5]; t = r; continue;}
      var v$0 = v, k$0 = k;
     }
     else
      var k$1 = t[1], v$1 = t[2], v$0 = v$1, k$0 = k$1;
     return [0, [0, k$0, v$0]];
    }
   }
   function findi_and_call_impl
   (t$0,
    compare,
    k$1,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t = t$0;
    for(;;){
     if(typeof t === "number")
      return caml_call4(call_if_not_found, if_not_found, k$1, arg1, arg2);
     if(0 !== t[0]){
      var k$0 = t[1], v$0 = t[2];
      return 0 === caml_call2(compare, k$1, k$0)
              ? caml_call5(call_if_found, if_found, k$0, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k$1, arg1, arg2);
     }
     var
      left = t[1],
      k = t[2],
      v = t[3],
      right = t[5],
      c = caml_call2(compare, k$1, k);
     if(0 === c) return caml_call5(call_if_found, if_found, k, v, arg1, arg2);
     t = 0 <= c ? right : left;
    }
   }
   function call_if_found(if_found, b, data, a, param){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, a, param){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, a, param){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, a, param){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, a, data, arg, param){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   var
    letrec_function_context = [],
    j = [0, cst_src_avltree_ml, 389, 15],
    k = [0, cst_src_avltree_ml, 406, 20];
   function remove(t, removed, compare, k){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$1 = t[1];
     return 0 === caml_call2(compare, k, k$1)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     removed[1] = 1;
     return caml_call2(letrec_function_context[1], left, right);
    }
    if(0 <= c){
     var right$0 = remove(right, removed, compare, k);
     if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
    }
    else{
     var left$0 = remove(left, removed, compare, k);
     if(1 - (left$0 === left ? 1 : 0)) t[1] = left$0;
    }
    return removed[1] ? balance(t) : t;
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 !== left[0]){
     var k = tree[2], v = tree[3];
     if(typeof tree[5] === "number") return [1, k, v];
    }
    tree[1] = remove_min_elt(left);
    return balance(tree);
   }
   function merge(t1, tree$0){
    if(typeof t1 === "number") return tree$0;
    if(typeof tree$0 === "number") return t1;
    var tree = tree$0;
    for(;;){
     if(typeof tree === "number")
      var tree$1 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){tree = left; continue;}
      var tree$1 = tree;
     }
     else
      var tree$1 = tree;
     if(typeof tree$1 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
     if(0 === tree$1[0]){
      tree$1[5] = remove_min_elt(tree$0);
      tree$1[1] = t1;
      var tree$2 = tree$1;
     }
     else
      var
       k$0 = tree$1[1],
       v = tree$1[2],
       t2 = remove_min_elt(tree$0),
       a = height(t2),
       b = max(height(t1), a),
       tree$2 = [0, t1, k$0, v, Base_Import[91].call(null, b, 1), t2];
     return balance(tree$2);
    }
   }
   runtime.caml_update_dummy(letrec_function_context, [0, merge]);
   var
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl";
   function fold(t$0, init$2, f){
    var t = t$0, init = init$2;
    for(;;){
     if(typeof t === "number") return init;
     if(0 !== t[0]){
      var key$4 = t[1], data$4 = t[2];
      return caml_call3(f, key$4, data$4, init);
     }
     var left = t[1];
     if(typeof left === "number"){
      var key = t[2], data = t[3], match = t[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t[2], data$1 = t[3], match$0 = t[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t[2],
        data$3 = t[3],
        match$1 = t[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init)));
       }
      }
      if(typeof left !== "number" && 0 !== left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t[2],
        data$2 = t[3],
        right$0 = t[5],
        init$1 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init));
       t = right$0;
       init = init$1;
       continue;
      }
     }
     var
      key$0 = t[2],
      data$0 = t[3],
      right = t[5],
      init$0 = caml_call3(f, key$0, data$0, fold(left, init, f));
     t = right;
     init = init$0;
    }
   }
   function iter(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 !== t[0]){
      var key$0 = t[1], data$0 = t[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t[1], key = t[2], data = t[3], right = t[5];
     iter(left, f);
     caml_call2(f, key, data);
     t = right;
    }
   }
   function mapi_inplace(t$0, f){
    var t = t$0;
    for(;;){
     if(typeof t === "number") return 0;
     if(0 !== t[0]){
      var key$0 = t[1], value$0 = t[2];
      t[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t[1], key = t[2], value = t[3], right = t[5];
     mapi_inplace(left, f);
     t[3] = caml_call2(f, key, value);
     t = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return raise_s
             (Base_Sexp[10].call(null, cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       0,
       is_empty,
       invariant,
       add,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(16, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Random, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
//# shape: Base__Hashtbl:[F(1)*,F(3)*,F(3),F(3),F(4),F(4),F(4),F(4),F(4),F(6),F(5),F(5),F(5),F(7),F(1)*,F(1),F(1),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(1)*,F(1)*,F(1)*,F(2),F(2),F(1),F(1),F(2),F(2),F(3),F(3),F(3),F(3),F(3),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(2),F(2),F(4),F(5),F(6),F(4),F(5),F(6),F(2),F(3),F(3),F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(1),F(4),F(4),F(3),F(2),F(2),F(1)*,F(3),F(1)*,N,F(1)*,F(3),F(3),F(2),F(4),[F(1)*]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Random = global_data.Base__Random,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[32],
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[4][3];}
   function compare_key(t){return t[4][2];}
   function ensure_mutation_allowed(t){
    var a = 1 - t[5];
    return a ? Base_Import[124].call(null, cst_Hashtbl_mutation_not_allow) : a;
   }
   function without_mutating(t, f){
    if(! t[5]) return caml_call1(f, 0);
    t[5] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = 1;
    return x;
   }
   var
    max_table_length = Base_Int[69].call(null, Base_Array[47]),
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_choose_randomly_ex =
      "[Hashtbl.choose_randomly_exn] of empty hashtbl",
    b = [0, cst_src_hashtbl_ml, 333, 2],
    c = [0, "Hashtbl.find_exn: not found"],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    d = [0, cst_src_hashtbl_ml, 582, 4],
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values";
   function create(a, opt, hashable, param){
    var
     growth_allowed = a ? a[1] : 1,
     size = opt ? opt[1] : 0,
     b = Base_Int[16].call(null, 1, size),
     size$0 = Base_Int[15].call(null, b, max_table_length),
     size$1 = Base_Int[68].call(null, size$0);
    return [0,
            Base_Array[48].call(null, size$1, Base_Avltree[1]),
            0,
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[4][1], key),
     a = Base_Import[93].call(null, t[1].length - 1, 1);
    return Base_Import[116].call(null, hash, a);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[i + 1],
     added = [0, 0],
     a = compare_key(t),
     new_root = Base_Avltree[4].call(null, root, replace, a, added, key, data);
    if(added[1]) t[2] = Base_Import[91].call(null, t[2], 1);
    if(1 - (new_root === root ? 1 : 0))
     caml_check_bound(t[1], i)[i + 1] = new_root;
    return added[1];
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     b = should_grow ? t[3] : should_grow;
    if(b){
     var
      e = Base_Import[88].call(null, len, 2),
      new_array_length = Base_Int[15].call(null, e, max_table_length),
      c = len < new_array_length ? 1 : 0;
     if(c){
      var
       new_table =
         Base_Array[48].call(null, new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){add_worker(t, 1, key, data); return 0;},
       d = Base_Import[93].call(null, old_table.length - 1, 1),
       g = 0;
      if(d >= 0){
       var i = g;
       for(;;){
        var h = caml_check_bound(old_table, i)[i + 1];
        Base_Avltree[17].call(null, h, f);
        var j = i + 1 | 0;
        if(d === i) break;
        i = j;
       }
      }
      var a = 0;
     }
     else
      var a = c;
    }
    else
     var a = b;
    return a;
   }
   function capacity(t){return t[1].length - 1;}
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    var added = add_worker(t, 0, key, data);
    return added ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       Base_Error[19].call
        (null, 0, 0, cst_Hashtbl_add_exn_got_key_al, key, sexp_of_key$0);
    return Base_Error[31].call(null, error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var a = Base_Import[93].call(null, t[1].length - 1, 1), b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = Base_Avltree[1];
      caml_check_bound(t[1], i)[i + 1] = c;
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var a = slot(t, key), tree = caml_check_bound(t[1], a)[a + 1];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var b = compare_key(t);
     return Base_Avltree[8].call(null, tree, b, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var b = slot(t, key), tree = caml_check_bound(t[1], b)[b + 1];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var c = compare_key(t);
     return Base_Avltree[9].call
             (null, tree, c, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var c = slot(t, key), tree = caml_check_bound(t[1], c)[c + 1];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var d = compare_key(t);
     return Base_Avltree[10].call
             (null, tree, d, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var a = slot(t, key), tree = caml_check_bound(t[1], a)[a + 1];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var b = compare_key(t);
     return Base_Avltree[11].call(null, tree, b, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var b = slot(t, key), tree = caml_check_bound(t[1], b)[b + 1];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var c = compare_key(t);
     return Base_Avltree[12].call
             (null, tree, c, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var c = slot(t, key), tree = caml_check_bound(t[1], c)[c + 1];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var d = compare_key(t);
     return Base_Avltree[13].call
             (null, tree, d, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var a = slot(t, key), tree = caml_check_bound(t[1], a)[a + 1];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var b = compare_key(t);
     return Base_Avltree[14].call(null, tree, b, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[i + 1],
     removed = [0, 0],
     b = compare_key(t),
     new_root = Base_Avltree[15].call(null, root, removed, b, key);
    if(1 - (root === new_root ? 1 : 0))
     caml_check_bound(t[1], i)[i + 1] = new_root;
    var
     a = removed[1],
     c = a ? (t[2] = Base_Import[93].call(null, t[2], 1), 0) : a;
    return c;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[5];
    try{
     t[5] = 0;
     var a = Base_Import[93].call(null, n, 1), b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       var bucket = t[1][i + 1];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = Base_Avltree[16].call(null, bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[5];
    try{
     t[5] = 0;
     var a = Base_Import[93].call(null, n, 1), b = 0;
     if(a >= 0){
      var i = b;
      for(;;){
       var bucket = t[1][i + 1];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         Base_Avltree[17].call(null, bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var c = i + 1 | 0;
       if(a === i) break;
       i = c;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i$1){
    var i = i$1;
    for(;;){
     var avltree = table[i + 1];
     if(! Base_Avltree[2].call(null, avltree))
      return Base_Avltree[19].call(null, avltree);
     var
      a = Base_Import[93].call(null, table.length - 1, 1),
      b = Base_Import[91].call(null, i, 1),
      i$0 = Base_Import[116].call(null, b, a);
     i = i$0;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     raise_s(Base_Sexp[10].call(null, cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function choose_randomly_nonempty(random_state, t){
    var
     start_idx = caml_call2(Base_Random[19][7], random_state, t[1].length - 1);
    return choose_nonempty(t[1], start_idx);
   }
   function choose_randomly(opt, t){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    return is_empty(t) ? 0 : [0, choose_randomly_nonempty(random_state, t)];
   }
   function choose_randomly_exn(opt, t){
    var random_state = opt ? opt[1] : Base_Random[19][1];
    if(0 === t[2])
     raise_s(Base_Sexp[10].call(null, cst_Hashtbl_choose_randomly_ex, 0));
    return choose_randomly_nonempty(random_state, t);
   }
   function invariant(invariant_key, invariant_data, t){
    var a = Base_Import[93].call(null, t[1].length - 1, 1), c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var d = compare_key(t), e = caml_check_bound(t[1], i)[i + 1];
      Base_Avltree[3].call(null, e, d);
      var f = i + 1 | 0;
      if(a === i) break;
      i = f;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return Base_Import[91].call(null, i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var a = [1, [0, c, [0, caml_call1(t[4][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], a], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return with_return
            (function(r){
              iteri
               (t,
                function(key, data){
                 var a = caml_call2(f, key, data);
                 return a ? caml_call1(r, 1) : a;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? Base_Import[91].call(null, acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? Base_Import[91].call(null, acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(a){return a;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[3]], [0, t[2]], t[4], 0),
     t1 = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$){
    return find_and_call
            (t,
             id,
             function(data){return data;},
             function(key){
              var default$0 = caml_call1(default$, 0);
              set(t, key, default$0);
              return default$0;
             });
   }
   function findi_or_add(t, id, default$){
    return find_and_call
            (t,
             id,
             function(data){return data;},
             function(key){
              var default$0 = caml_call1(default$, key);
              set(t, key, default$0);
              return default$0;
             });
   }
   function find_and_remove(t, key){
    var result = find_and_call(t, key, if_found, if_not_found);
    if(Base_Option[53].call(null, result)) remove(t, key);
    return result;
   }
   function change(t, key, f){
    var match = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    if(! match) return remove(t, key);
    var data = match[1];
    return set(t, key, data);
   }
   function update_and_return(t, key, f){
    var data = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    set(t, key, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    if(! remove_if_zero)
     return update
             (t,
              key,
              function(param){
               if(! param) return by;
               var i = param[1];
               return Base_Import[91].call(null, by, i);
              });
    var
     opt = find_and_call(t, key, if_found, if_not_found),
     a = Base_Option[30].call(null, opt, 0),
     n = Base_Import[91].call(null, by, a),
     match = 0 === n ? 0 : [0, n];
    if(! match) return remove(t, key);
    var data = match[1];
    return set(t, key, data);
   }
   function incr(a, opt, t, key){
    var by = a ? a[1] : 1, remove_if_zero = opt ? opt[1] : 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(a, opt, t, key){
    var by = a ? a[1] : 1, remove_if_zero = opt ? opt[1] : 0;
    return incr_by(remove_if_zero, t, key, Base_Import[113].call(null, by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var a = match[1];
    if(a && a[2]){var tl = a[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = Base_List[45].call(null, rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    Base_List[19].call
     (null,
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return mem(res, key)
               ? (dupes[1] = [0, key, dupes[1]], 0)
               : set(res, key, data);
      });
    var keys = dupes[1];
    return keys
            ? [0, 175765640, Base_List[126].call(null, keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[125],
         Base_Import[127],
         lst),
     variant = match[1];
    if(175765640 <= variant){
     var k = match[2];
     return [0, -1048878709, Base_List[88].call(null, k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[125],
             Base_Import[127],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var
     match = of_alist(growth_allowed, size, hashable, lst),
     variant = match[1];
    if(17724 <= variant){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return Base_Or_error[38].call
            (null, 0, 0, cst_Hashtbl_of_alist_exn_dupli, key, sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return Base_Error[31].call(null, e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[127], get_key = Base_Import[125];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = Base_List[45].call(null, rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    Base_List[19].call
     (null,
      rows,
      function(r){
       var key = get_key(r), data = get_data(r);
       return add_multi(res, key, data);
      });
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     a = to_alist(t),
     b =
       Base_List[83].call
        (null,
         a,
         function(a, param){
          var k2 = param[1], k1 = a[1];
          return caml_call2(t[4][2], k1, k2);
         }),
     c = Base_Import[147];
    return Base_Import[149].call
            (null, function(a){return c(sexp_of_key, sexp_of_data, a);}, b);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     a = Base_Import[171],
     alist =
       Base_Import[173].call
        (null, function(b){return a(k_of_sexp, d_of_sexp, b);}, sexp),
     match =
       of_alist(0, [0, Base_List[45].call(null, alist)], hashable, alist),
     variant = match[1];
    if(17724 <= variant){var v = match[2]; return v;}
    var k = match[2];
    function b(a){return a;}
    function c(a){return a;}
    var
     e = Base_Import[171],
     alist_sexps =
       Base_Import[173].call(null, function(a){return e(c, b, a);}, sexp),
     found_first_k = [0, 0];
    Base_List[67].call
     (null,
      alist,
      alist_sexps,
      function(c, param){
       var
        k2_sexp = param[1],
        k2 = c[1],
        a = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
       if(a){
        if(found_first_k[1])
         return Base_Import[156].call
                 (null, cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
        found_first_k[1] = 1;
        var b = 0;
       }
       else
        var b = a;
       return b;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var a = caml_call2(Base_List[137][3], k_grammar, v_grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    Base_List[19].call
     (null,
      rows,
      function(row){
       var
        key = caml_call1(get_key, row),
        data = caml_call1(get_data, row),
        match = find_and_call(groups, key, if_found, if_not_found);
       if(match)
        var old = match[1], data$0 = caml_call2(combine, old, data);
       else
        var data$0 = data;
       return set(groups, key, data$0);
      });
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(a){return a;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows),
     variant = match[1];
    if(175765640 <= variant){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      a =
        [0, [0, cst_keys, Base_Import[149].call(null, sexp_of_key, keys)], 0],
      b = Base_Sexp[10].call(null, cst_Hashtbl_create_with_key_du, a);
     return Base_Or_error[39].call(null, b);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     a =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return Base_Or_error[34].call(null, a);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - Base_Hashable[1].call(null, t_left[4], t_right[4]))
     Base_Import[126].call(null, cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[3]], [0, t_left[2]], t_left[4], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var
                     match = find_and_call(t_right, key, if_found, if_not_found);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find_and_call(t_left, key, if_found, if_not_found)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data$0 = find_and_call(dst, key, if_found, if_not_found),
               action =
                 without_mutating
                  (dst,
                   function(param){
                    return caml_call3(f, key, data, dst_data$0);
                   });
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data$0) return set(dst, key, data$0);
              var
               dst_data = dst_data$0[1],
               a = 1 - (dst_data === data$0 ? 1 : 0);
              return a ? set(dst, key, data$0) : a;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    return Base_List[19].call
            (null, to_remove, function(key){return remove(t, key);});
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    return Base_List[19].call
            (null,
             map_results,
             function(param){
              var result = param[2], key = param[1];
              if(! result) return remove(t, key);
              var data = result[1];
              return set(t, key, data);
             });
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var a = Base_Avltree[18];
              return Base_Array[20].call
                      (null, t[1], function(b){return a(b, f);});
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var a = t$0[2] === t[2] ? 1 : 0;
    return a
            ? with_return
              (function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find_and_call(t, key, if_found, if_not_found);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              a = 1 - caml_call2(equal, data, data$0);
                             return a ? caml_call1(r, 0) : a;
                            });
                  });
                return 1;
               })
            : a;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    a = Creators([0, hashable]),
    t_of_sexp$0 = a[1],
    create$0 = a[2],
    of_alist$0 = a[3],
    of_alist_report_all_dups$0 = a[4],
    of_alist_or_error$0 = a[5],
    of_alist_exn$0 = a[6],
    of_alist_multi$0 = a[7],
    create_mapped$0 = a[8],
    create_with_key$0 = a[9],
    create_with_key_or_error$0 = a[10],
    create_with_key_exn$0 = a[11],
    group$0 = a[12];
   function hashable$0(t){return t[4];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, Base_Hashable[3].call(null, m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, Base_Hashable[3].call(null, m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, Base_Hashable[3].call(null, m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, Base_Hashable[3].call(null, m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, Base_Hashable[3].call(null, m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, Base_Hashable[3].call(null, m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             Base_Hashable[3].call(null, m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed, size, Base_Hashable[3].call(null, m), get_key, l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed, size, Base_Hashable[3].call(null, m), get_key, l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed, size, Base_Hashable[3].call(null, m), get_key, l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             Base_Hashable[3].call(null, m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return Base_Hashable[4].call(null, t[4]);}
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    return sexp_of_t(K[1], sexp_of_v, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    var a = K[1];
    return t_of_sexp
            (Base_Hashable[3].call(null, [0, K[2], K[3], K[4]]),
             a,
             v_of_sexp,
             sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return t_sexp_grammar(K[1], v_grammar);
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       capacity,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       choose_randomly,
       choose_randomly_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        capacity,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        choose_randomly,
        choose_randomly_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(26, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
//# shape: Base__Hash_set_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
//# shape: Base__Hash_set:[F(2),F(3),F(4),F(1)*,F(1)*,F(2),F(3),F(3),F(4),F(2),F(2),F(2),F(3),F(2),F(2),F(1),F(1),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(2),F(2),F(2),F(2),F(2),F(2),F(1),F(2),F(1)*,N,F(1)*,F(1)*,F(2),F(2),F(1)*,F(3),[F(1)*]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[84],
    hashable = Base_Hashtbl[93][1],
    poly_hashable = Base_Hashtbl[87][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[31],
    cst_element_already_exists = "element already exists",
    b = [0, 0];
   function is_empty(t){return Base_Hashtbl[30].call(null, t);}
   function find_map(t, f){
    return with_return
            (function(r){
              Base_Hashtbl[19].call
               (null,
                t,
                function(elt){
                 var o = caml_call1(f, elt);
                 return o ? caml_call1(r, o) : 0;
                });
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return Base_Hashtbl[37].call(null, t, k, 0);}
   function strict_add(t, k){
    return mem(t, k)
            ? Base_Or_error[40].call(null, cst_element_already_exists)
            : (Base_Hashtbl[37].call(null, t, k, 0), b);
   }
   function strict_add_exn(t, k){
    var a = strict_add(t, k);
    return Base_Or_error[34].call(null, a);
   }
   var
    remove = Base_Hashtbl[32],
    c = [0, 0],
    cst_element_not_in_set = "element not in set";
   function strict_remove(t, k){
    if(mem(t, k)){remove(t, k); return c;}
    var a = Base_Hashtbl[15].call(null, t);
    return Base_Or_error[38].call(null, 0, 0, cst_element_not_in_set, k, a);
   }
   function strict_remove_exn(t, k){
    var a = strict_remove(t, k);
    return Base_Or_error[34].call(null, a);
   }
   function fold(t, init, f){
    return Base_Hashtbl[18].call
            (null,
             t,
             init,
             function(key, param, acc){return caml_call2(f, acc, key);});
   }
   function iter(t, f){return Base_Hashtbl[19].call(null, t, f);}
   function count(t, f){return Base_Container[2].call(null, fold, t, f);}
   function sum(m, t, f){return Base_Container[7].call(null, fold, m, t, f);}
   function min_elt(t, compare){
    return Base_Container[3].call(null, fold, t, compare);
   }
   function max_elt(t, compare){
    return Base_Container[4].call(null, fold, t, compare);
   }
   function fold_result(t, init, f){
    return Base_Container[8].call(null, fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return Base_Container[9].call(null, fold, init, f, finish, t);
   }
   var
    to_list = Base_Hashtbl[67],
    d = [0, 0],
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element";
   function sexp_of_t(sexp_of_e, t){
    var
     a = to_list(t),
     b = hashable(t)[2],
     c = Base_List[83].call(null, a, b);
    return Base_Import[149].call(null, sexp_of_e, c);
   }
   function to_array(t){
    var len = length(t), index = [0, Base_Import[93].call(null, len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return Base_Array[48].call(null, len, key);
              index[1] = Base_Import[93].call(null, index[1], 1);
              var a = index[1];
              runtime.caml_check_bound(acc, a)[a + 1] = key;
              return acc;
             });
   }
   function exists(t, f){
    return Base_Hashtbl[22].call
            (null, t, function(key, param){return caml_call1(f, key);});
   }
   function for_all(t, f){
    return 1
           -
            Base_Hashtbl[22].call
             (null, t, function(key, param){return 1 - caml_call1(f, key);});
   }
   function equal(t1, t2){
    return Base_Hashtbl[76].call(null, function(a, param){return 1;}, t1, t2);
   }
   function copy(t){return Base_Hashtbl[17].call(null, t);}
   function filter(t, f){
    return Base_Hashtbl[49].call
            (null, t, function(key, param){return caml_call1(f, key);});
   }
   function union(t1, t2){
    return Base_Hashtbl[65].call(null, t1, t2, function(a, param){return d;});
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - Base_Hashtbl[31].call(null, t2, key);});
   }
   function inter(t1, t2){
    var a = length(t2);
    if(a < length(t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    return Base_Hashtbl[49].call
            (null,
             smaller,
             function(key, param){
              return Base_Hashtbl[31].call(null, larger, key);
             });
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    return Base_List[19].call
            (null, to_remove, function(x){return remove(t, x);});
   }
   function of_hashtbl_keys(hashtbl){
    return Base_Hashtbl[43].call(null, hashtbl, function(a){return 0;});
   }
   function to_hashtbl(t, f){
    return Base_Hashtbl[44].call
            (null, t, function(key, param){return caml_call1(f, key);});
   }
   function create(growth_allowed, size, m){
    return Base_Hashtbl[4].call(null, growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = Base_List[45].call(null, l);
    var t = Base_Hashtbl[4].call(null, growth_allowed, [0, size$0], m);
    Base_List[19].call(null, l, function(k){return add(t, k);});
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return Base_Import[156].call(null, cst_Hash_set_t_of_sexp_require, sexp);
    var list = sexp[1], t = create(0, [0, Base_List[45].call(null, list)], m);
    Base_List[19].call
     (null,
      list,
      function(sexp){
       var e = caml_call1(e_of_sexp, sexp);
       return 0 === strict_add(t, e)[0]
               ? 0
               : Base_Import
                  [156].call
                 (null, cst_Hash_set_t_of_sexp_got_a_d, sexp);
      });
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, Base_Hashable[4].call(null, Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, Base_Hashable[4].call(null, Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(Base_Hashable[4].call(null, Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    a = Creators([0, poly_hashable]),
    t_of_sexp$0 = a[1],
    create$0 = a[2],
    of_list$0 = a[3];
   function t_sexp_grammar(grammar){
    var a = Base_List[7].call(null, grammar);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){return sexp_of_t(Elt[1], t);}
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var a = Base_Import[194].call(null, Elt[1]);
    return Sexplib0_Sexp_grammar[1].call(null, a);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[93][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_string_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
//# shape: Base__Float:[F(1)*,N,F(1)*,F(1)*,N,F(1),F(1),F(1),F(1),F(2)*,F(2)*,F(3)*,F(3),F(3),N,N,N,F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(1)*,F(2)*,F(2)*,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1),F(1)*,F(2)*,F(1)*,F(1),F(1)*,F(1)*,F(1)*,F(2)*,F(2),F(2),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),N,N,N,N,F(2),F(2),F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2)*,F(2),F(2)*,F(2)*,F(1)*,N,F(1)*,F(2)*,F(2)*,F(2)*,F(1)*,F(2)*,F(1)*,N,N,F(1),F(5),F(1),F(8),F(2),F(1)*,F(2)*,F(1)*,N,F(1)*,N,F(1),F(1)*,F(3),F(3),F(1)*,F(1)*,F(1)*,N,[F(1)*,F(3),F(1),F(1)*,N,N,F(1),F(1),F(1)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_float_compare = runtime.caml_float_compare,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_int_compare = runtime.caml_int_compare,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_007 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    float_of_string_opt = Base_Float0[6],
    nan = Base_Float0[7],
    max_value = Base_Float0[8],
    neg_infinity = Base_Float0[9],
    max_finite_value = Base_Float0[10],
    epsilon_float = Base_Float0[11],
    classify_float = Base_Float0[12],
    abs_float = Base_Float0[13],
    is_integer = Base_Float0[14],
    symbol = Base_Float0[15],
    symbol$0 = Base_Float0[16],
    frexp = Base_Float0[17],
    ldexp = Base_Float0[18],
    is_nan = Base_Float0[19],
    to_int64_preserve_order = Base_Float0[20],
    to_int64_preserve_order_exn = Base_Float0[21],
    of_int64_preserve_order = Base_Float0[22],
    one_ulp = Base_Float0[23],
    upper_bound_for_int = Base_Float0[24],
    lower_bound_for_int = Base_Float0[26],
    clamp_unchecked = Base_Float0[28],
    box = Base_Float0[29],
    raise_s = Base_Error[32],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[283],
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, caml_float_compare, sexp_of_t],
    compare = caml_float_compare,
    include = Base_Comparator[7].call(null, [0, compare, sexp_of_t]),
    comparator = include[1],
    a = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var b = float_of_string(s); return b;}
    catch(exn){return caml_call2(Base_Printf[7].call(null, a), s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     y$0 = float_of_string(y) === x ? y : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return Base_Import[112].call(null, y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 <= match) break a;} else if(45 !== match) break a;
      var i$0 = Base_Import[91].call(null, i, 1);
      i = i$0;
      continue;
     }
     return y$0;
    }
   }
   var
    min_positive_subnormal_value = symbol(2., -1074.),
    min_positive_normal_value = symbol(2., -1022.),
    zero = 0.,
    of_int = Base_Int[4],
    to_int = Base_Int[3];
   function of_int63(i){return Base_Int63[3].call(null, i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = lower_bound_for_int(Base_Int[64]),
    iround_ubound = upper_bound_for_int(Base_Int[64]),
    b =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    c =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    d =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    e =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    f =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"];
   function iround_up(t){
    if(! (0. < t))
     return iround_lbound <= t ? [0, Base_Int[63].call(null, t)] : 0;
    var t$0 = round_up(t);
    return t$0 <= iround_ubound ? [0, Base_Int[63].call(null, t$0)] : 0;
   }
   function iround_up_exn(t){
    if(0. < t){
     var t$0 = round_up(t);
     if(t$0 <= iround_ubound) return Base_Int[63].call(null, t$0);
     var a = box(t);
     return caml_call2(Base_Printf[7].call(null, b), a, 0);
    }
    if(iround_lbound <= t) return Base_Int[63].call(null, t);
    var d = box(t);
    return caml_call2(Base_Printf[7].call(null, c), d, 0);
   }
   function iround_down(t){
    if(0. <= t)
     return t <= iround_ubound ? [0, Base_Int[63].call(null, t)] : 0;
    var t$0 = round_down(t);
    return iround_lbound <= t$0 ? [0, Base_Int[63].call(null, t$0)] : 0;
   }
   function iround_down_exn(t){
    if(0. <= t){
     if(t <= iround_ubound) return Base_Int[63].call(null, t);
     var a = box(t);
     return caml_call2(Base_Printf[7].call(null, d), a, 0);
    }
    var t$0 = round_down(t);
    if(iround_lbound <= t$0) return Base_Int[63].call(null, t$0);
    var b = box(t);
    return caml_call2(Base_Printf[7].call(null, e), b, 0);
   }
   function iround_towards_zero(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return [0, Base_Int[63].call(null, t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return Base_Int[63].call(null, t);
    var a = box(t);
    return caml_call2(Base_Printf[7].call(null, f), a, 0);
   }
   var
    g = symbol(2., 52.),
    round_nearest_lb = Base_Import[114].call(null, g),
    round_nearest_ub = symbol(2., 52.),
    one_ulp_less_than_half = one_ulp(759637122, 0.5);
   function add_half_for_round_nearest(t){
    var a = t === one_ulp_less_than_half ? one_ulp_less_than_half : 0.5;
    return Base_Import[92].call(null, t, a);
   }
   function iround_nearest_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     return t$0 <= iround_ubound ? [0, Base_Int[63].call(null, t$0)] : 0;
    }
    var t$1 = round_down(Base_Import[92].call(null, t, 0.5));
    return iround_lbound <= t$1 ? [0, Base_Int[63].call(null, t$1)] : 0;
   }
   function iround_nearest_64(t){
    if(0. <= t){
     if(! (t < round_nearest_ub))
      return t <= iround_ubound ? [0, Base_Int[63].call(null, t)] : 0;
     var a = add_half_for_round_nearest(t);
     return [0, Base_Int[63].call(null, a)];
    }
    if(! (round_nearest_lb < t))
     return iround_lbound <= t ? [0, Base_Int[63].call(null, t)] : 0;
    var b = round_down(Base_Import[92].call(null, t, 0.5));
    return [0, Base_Int[63].call(null, b)];
   }
   var
    R = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    P =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    Q =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    L = [0, cst_src_float_ml, 865, 2],
    K =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    J = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    I = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    F = [0, cst_src_float_ml, 703, 8],
    E = [0, cst_src_float_ml, 706, 8],
    A = [0, cst_src_float_ml, 713, 8],
    B = [0, cst_src_float_ml, 714, 8],
    C = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    D = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    z = [0, cst_src_float_ml, 690, 8],
    cst_0 = ".0",
    G = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    H = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    w =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    x = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    y = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    r = [0, cst_Infinite],
    s = [0, cst_Nan],
    t = [0, cst_Normal],
    u = [0, cst_Subnormal],
    v = [0, cst_Zero],
    p =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    q =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    n =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    o =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    l =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    m =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    j =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    k =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    h =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    i =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329,
    iround_nearest = Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     if(t$0 <= iround_ubound) return Base_Int[63].call(null, t$0);
     var a = box(t);
     return caml_call2(Base_Printf[7].call(null, h), a, 0);
    }
    var t$1 = round_down(Base_Import[92].call(null, t, 0.5));
    if(iround_lbound <= t$1) return Base_Int[63].call(null, t$1);
    var b = box(t);
    return caml_call2(Base_Printf[7].call(null, i), b, 0);
   }
   function iround_nearest_exn_64(t){
    if(0. <= t){
     if(t < round_nearest_ub){
      var a = add_half_for_round_nearest(t);
      return Base_Int[63].call(null, a);
     }
     if(t <= iround_ubound) return Base_Int[63].call(null, t);
     var b = box(t);
     return caml_call2(Base_Printf[7].call(null, j), b, 0);
    }
    if(round_nearest_lb < t){
     var c = round_down(Base_Import[92].call(null, t, 0.5));
     return Base_Int[63].call(null, c);
    }
    if(iround_lbound <= t) return Base_Int[63].call(null, t);
    var d = box(t);
    return caml_call2(Base_Printf[7].call(null, k), d, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    var dir = opt ? opt[1] : 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    var dir = opt ? opt[1] : 857423934;
    try{var a = [0, iround_exn([0, dir], t)]; return a;}catch(exn){return 0;}
   }
   function is_inf(t){
    return Base_Import[96].call(null, 1., t) === 0. ? 1 : 0;
   }
   function is_finite(t){
    return Base_Import[94].call(null, t, t) === 0. ? 1 : 0;
   }
   function min_inan(x, y){
    return is_nan(y) ? x : is_nan(x) ? y : x < y ? x : y;
   }
   function max_inan(x, y){
    return is_nan(y) ? x : is_nan(x) ? y : y < x ? x : y;
   }
   var
    add = Base_Import[92],
    sub = Base_Import[94],
    neg = Base_Import[114],
    scale = Base_Import[90];
   function square(x){return Base_Import[90].call(null, x, x);}
   function fractional(t){return Base_Import[125].call(null, t);}
   function integral(t){return Base_Import[127].call(null, t);}
   function round_towards_zero(t){
    return 0. <= t ? round_down(t) : round_up(t);
   }
   function round_nearest_inline(t){
    if(round_nearest_lb < t && t < round_nearest_ub)
     return round_down(add_half_for_round_nearest(t));
    return Base_Import[92].call(null, t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if(! (t <= round_nearest_lb) && ! (round_nearest_ub <= t)){
     var
      floor = round_down(t),
      ceil_or_succ = Base_Import[92].call(null, floor, 1.),
      diff_floor = Base_Import[94].call(null, t, floor),
      diff_ceil = Base_Import[94].call(null, ceil_or_succ, t);
     return diff_floor < diff_ceil
             ? floor
             : diff_ceil
               < diff_floor
               ? ceil_or_succ
               : mod_float(floor, 2.) === 0. ? floor : ceil_or_succ;
    }
    return Base_Import[92].call(null, t, 0.);
   }
   var
    int63_round_lbound = lower_bound_for_int(Base_Int63[87]),
    int63_round_ubound = upper_bound_for_int(Base_Int63[87]);
   function int63_round_up_exn(t){
    if(0. < t){
     var t$0 = round_up(t);
     if(t$0 <= int63_round_ubound) return Base_Int63[86].call(null, t$0);
     var a = Base_Float0[29].call(null, t);
     return caml_call2(Base_Printf[7].call(null, l), a, 0);
    }
    if(int63_round_lbound <= t) return Base_Int63[86].call(null, t);
    var b = Base_Float0[29].call(null, t);
    return caml_call2(Base_Printf[7].call(null, m), b, 0);
   }
   function int63_round_down_exn(t){
    if(0. <= t){
     if(t <= int63_round_ubound) return Base_Int63[86].call(null, t);
     var a = Base_Float0[29].call(null, t);
     return caml_call2(Base_Printf[7].call(null, n), a, 0);
    }
    var t$0 = round_down(t);
    if(int63_round_lbound <= t$0) return Base_Int63[86].call(null, t$0);
    var b = Base_Float0[29].call(null, t);
    return caml_call2(Base_Printf[7].call(null, o), b, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(0. < t){
     if(t <= int63_round_ubound) return Base_Int63[86].call(null, t);
     var a = box(t0);
     return caml_call2(Base_Printf[7].call(null, p), a, 0);
    }
    if(int63_round_lbound <= t) return Base_Int63[86].call(null, t);
    var b = box(t0);
    return caml_call2(Base_Printf[7].call(null, q), b, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var a = iround_nearest_exn(f);
    return Base_Int63[100].call(null, a);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    var dir = opt ? opt[1] : 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? round_towards_zero(t)
              : round_nearest_inline(t)
            : 759637122 <= dir ? round_down(t) : round_up(t);
   }
   var compare_local = caml_int_compare, compare$0 = caml_int_compare;
   function t_of_sexp$0(sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var match = sexp_008[1], a = caml_string_compare(match, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= a){
           if(0 < a){
            if(match === cst_nan$1) break e;
            if(match === cst_normal) break d;
            if(match === cst_subnormal) break c;
            if(match !== cst_zero) break a;
            break b;
           }
          }
          else if(match !== cst_Infinite){
           if(match === cst_Nan) break e;
           if(match === cst_Normal) break d;
           if(match === cst_Subnormal) break c;
           if(match !== cst_Zero) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var match$0 = sexp_008[1];
     if(! match$0)
      return Sexplib0_Sexp_conv_error[11].call
              (null, error_source_007, sexp_008);
     var match$1 = match$0[1];
     if(0 !== match$1[0])
      return Sexplib0_Sexp_conv_error[10].call
              (null, error_source_007, sexp_008);
     var match$2 = match$1[1], b = caml_string_compare(match$2, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= b){
          if(0 < b){
           if(match$2 === cst_nan$1) break e;
           if(match$2 === cst_normal) break d;
           if(match$2 === cst_subnormal) break c;
           if(match$2 !== cst_zero) break a;
           break b;
          }
         }
         else if(match$2 !== cst_Infinite){
          if(match$2 === cst_Nan) break e;
          if(match$2 === cst_Normal) break d;
          if(match$2 === cst_Subnormal) break c;
          if(match$2 !== cst_Zero) break a;
          break b;
         }
         return Sexplib0_Sexp_conv_error[7].call
                 (null, error_source_007, sexp_008);
        }
        return Sexplib0_Sexp_conv_error[7].call
                (null, error_source_007, sexp_008);
       }
       return Sexplib0_Sexp_conv_error[7].call
               (null, error_source_007, sexp_008);
      }
      return Sexplib0_Sexp_conv_error[7].call
              (null, error_source_007, sexp_008);
     }
     return Sexplib0_Sexp_conv_error[7].call(null, error_source_007, sexp_008);
    }
    return Sexplib0_Sexp_conv_error[12].call(null, error_source_007, sexp_008);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return r;
      case 1:
       return s;
      case 2:
       return t;
      case 3:
       return u;
      default: return v;
    }
   }
   function to_string$0(t){
    var a = sexp_of_t$0(t);
    return Base_Import[160].call(null, a);
   }
   function of_string$0(s){
    return t_of_sexp$0(Base_Import[136].call(null, s));
   }
   function classify(t){
    switch(classify_float(t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(a, opt, string){
    var
     delimiter = a ? a[1] : 95,
     strip_zero = opt ? opt[1] : 0,
     match = Base_String[100].call(null, string, 46);
    if(! match)
     return Base_Int_string_conversions[6].call(null, string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = Base_Int_string_conversions[6].call(null, left, delimiter),
     right$0 =
       strip_zero
        ? Base_String
           [108].call
          (null,
           [0, function(c){return Base_Char[12].call(null, c, 48);}],
           right)
        : right;
    if(right$0 === cst$4) return left$0;
    var b = Base_Import[112].call(null, cst$0, right$0);
    return Base_Import[112].call(null, left$0, b);
   }
   function to_string_hum(delimiter, a, strip_zero, opt, f){
    var decimals = a ? a[1] : 3, explicit_plus = opt ? opt[1] : 0;
    if(decimals < 0) caml_call2(Base_Printf[7].call(null, w), decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match) return 0. < f ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call2(Base_Printf[2].call(null, x), decimals, f)
        : caml_call2(Base_Printf[2].call(null, y), decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = sexp_of_t(t);
    if(1009018843 <= Base_Sexp[19][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return Base_String[70].call(null, 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var a = [0, [0, cst_sexp, Base_Sexp[5].call(null, sexp)], 0];
    return raise_s
            (Base_Sexp[10].call(null, cst_sexp_of_float_produced_str, a));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    var prefix = opt ? opt[1] : cst$2, match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match) return t < 0. ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if(denominator === 100. && 999.95 <= numerator) break a;
       if(100000. <= denominator){
        var t$0 = Base_Import[90].call(null, denominator, 9.9995);
        if(round_nearest_inline(t$0) <= numerator) break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, F], 1);
      }
      var t = Base_Import[90].call(null, denominator, 9999.5);
      if(! (numerator < round_nearest_inline(t)))
       throw caml_maybe_attach_backtrace([0, Assert_failure, E], 1);
      var
       k = round_down(Base_Import[96].call(null, numerator, denominator)),
       lower = Base_Import[90].call(null, denominator, k),
       a = Base_Import[92].call(null, k, 1.),
       higher = Base_Import[90].call(null, denominator, a),
       diff_right = Base_Import[94].call(null, higher, numerator),
       diff_left = Base_Import[94].call(null, numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         diff_right < diff_left
          ? Base_Import[91].call(null, k$0, 1)
          : diff_left
            < diff_right
            ? k$0
            : 0
              === Base_Import[122].call(null, k$0, 2)
              ? k$0
              : Base_Import[91].call(null, k$0, 1),
       d = Base_Import[122].call(null, k$1, 10),
       i = Base_Import[95].call(null, k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call3(Base_Printf[2].call(null, C), prefix, i, mag)
                : caml_call4(Base_Printf[2].call(null, D), prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, B], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, A], 1);
     }
     if(! (t < 999.95)){
      if(t < 999950.) return conv(kilo, t, 100.);
      if(t < 999950000.) return conv(mega, t, 100000.);
      if(t < 999950000000.) return conv(giga, t, 100000000.);
      if(t < 999950000000000.) return conv(tera, t, 100000000000.);
      if(! peta) return caml_call2(Base_Printf[2].call(null, H), prefix, t);
      var peta$0 = peta[1];
      return t < 999950000000000000.
              ? conv(peta$0, t, 100000000000000.)
              : caml_call2(Base_Printf[2].call(null, G), prefix, t);
     }
     if(0. <= t && t < 999.95){
      var
       x = Base_Import[112].call(null, prefix, caml_format_float("%.1f", t));
      if(! Base_String[96].call(null, x, cst_0)) return x;
      var
       x$0 = Base_Bytes0[21].call(null, x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, Base_Import[93].call(null, n, 1), 32);
      caml_bytes_set(x$0, Base_Import[93].call(null, n, 2), 32);
      return runtime.caml_string_of_bytes(x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, z], 1);
    }
    if(0. <= t) return go(t);
    var a = go(Base_Import[114].call(null, t));
    return Base_Import[112].call(null, cst$1, a);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, I, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, Base_Import[92].call(null, x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = Base_Import[96].call(null, 1., x$0[1]);
     n$0[1] = Base_Import[113].call(null, n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; n$0[1]--;}
    }
    for(;;){
     if(1 >= n$0[1]) return Base_Import[90].call(null, x$0[1], accum[1]);
     if(0 !== Base_Import[116].call(null, n$0[1], 1))
      accum[1] = Base_Import[90].call(null, x$0[1], accum[1]);
     x$0[1] = Base_Import[90].call(null, x$0[1], x$0[1]);
     n$0[1] = Base_Import[120].call(null, n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(x === 0.) return 0.;
    if(! is_finite(x)) return x;
    var variant = how[1];
    if(555917426 <= variant)
     var
      sd = how[2],
      a = to_int(round_up(caml_log10_float(abs_float(x)))),
      dd = Base_Import[93].call(null, sd, a),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      d = to_int(round_up(caml_log10_float(abs_float(x)))),
      sd$1 = Base_Import[91].call(null, dd$1, d),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = Base_Int[78].call(null, dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       b = round_nearest_half_to_even(Base_Import[90].call(null, x, order));
      return Base_Import[96].call(null, b, order);
     }
     var c = round_nearest_half_to_even(Base_Import[96].call(null, x, order));
     return Base_Import[90].call(null, c, order);
    }
    return of_string(caml_call2(Base_Printf[2].call(null, J), sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call2(Base_Printf[7].call(null, K), significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var a = low <= t ? 1 : 0, b = a ? t <= high ? 1 : 0 : a;
    return b;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, L], 1);
   }
   function clamp(t, min, max){
    if(min <= max) return [0, clamp_unchecked(t, min, max)];
    var
     a = [0, [0, cst_max, sexp_of_t(max)], 0],
     b = [0, [0, cst_min, sexp_of_t(min)], a],
     c = Base_Sexp[10].call(null, cst_clamp_requires_min_max, b);
    return Base_Or_error[39].call(null, c);
   }
   var
    symbol$1 = Base_Import[92],
    symbol$2 = Base_Import[94],
    symbol$3 = Base_Import[90],
    symbol$4 = Base_Import[96],
    symbol$5 = Base_Import[114];
   function sign_exn(t){
    if(0. < t) return 2;
    if(t < 0.) return 0;
    if(t === 0.) return 1;
    var
     a = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     b = Base_Sexp[10].call(null, cst_Float_sign_exn_of_NAN, a);
    return Base_Error[32].call(null, b);
   }
   function sign_or_nan(t){return 0. < t ? 2 : t < 0. ? 0 : t === 0. ? 1 : 3;}
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    mantissa_bits = 52,
    M = Base_Int64[37],
    exponent_mask64 =
      runtime.caml_int64_sub(Base_Int64[53].call(null, Base_Int64[37], 11), M),
    exponent_mask = Base_Int64[6].call(null, exponent_mask64),
    N = Base_Int63[43],
    O = Base_Int63[76].call(null, Base_Int63[43], mantissa_bits),
    mantissa_mask = Base_Int63[46].call(null, O, N),
    mantissa_mask64 = Base_Int63[83].call(null, mantissa_mask);
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     a = Base_Int64[67].call(null, bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (Base_Int64[48].call(null, a, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return Base_Int63[109].call
            (null, runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(Base_Int[48].call(null, exponent, exponent_mask) !== exponent)
     return caml_call3
             (Base_Printf[6].call(null, P), exponent, exponent_mask, 0);
    var a = Base_Int63[71].call(null, mantissa, mantissa_mask);
    if(Base_Int63[17].call(null, a, mantissa)){
     var
      b = Base_Int63[11].call(null, mantissa_mask),
      c = Base_Int63[11].call(null, mantissa);
     return caml_call3(Base_Printf[6].call(null, Q), c, b, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = Base_Int63[83].call(null, mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    return Base_Or_error[31].call
            (null,
             0,
             function(param){
              return create_ieee_exn(negative, exponent, mantissa);
             });
   }
   function to_string$1(x){
    return caml_call1(Base_Printf[2].call(null, R), x);
   }
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 = Base_Comparable[14].call(null, [0, compare, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return 0. < t ? 1 : 0;}
   function is_non_negative(t){return 0. <= t ? 1 : 0;}
   function is_negative(t){return t < 0. ? 1 : 0;}
   function is_non_positive(t){return t <= 0. ? 1 : 0;}
   var
    include$1 = Base_Pretty_printer[2].call(null, [0, module_name, to_string]),
    pp = include$1[1];
   function symbol$6(b, a){return b !== a ? 1 : 0;}
   function symbol$7(b, a){return b < a ? 1 : 0;}
   function symbol$8(b, a){return a < b ? 1 : 0;}
   function symbol$9(b, a){return b === a ? 1 : 0;}
   function symbol$10(b, a){return b <= a ? 1 : 0;}
   function symbol$11(b, a){return a <= b ? 1 : 0;}
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[108],
    ascending = include$2[1],
    descending = include$2[2],
    compare_local$0 = include$2[3],
    equal_local = include$2[4];
   function min(x, y){if(! (x < y) && ! is_nan(x)) return y; return x;}
   function max(x, y){if(! (y < x) && ! is_nan(x)) return y; return x;}
   var
    Base_Float =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       float_of_string_opt,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       equal_local,
       compare_local$0,
       invariant,
       min,
       max,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$0,
        compare_local,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
//# shape: Base__Fieldslib:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
//# shape: Base__Buffer_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
//# shape: Base__Buffer:[F(1),F(1)*,F(1),F(1),N,N,N,N,N,N,F(2),F(1)*,F(1),F(1),F(2),F(2),F(4),F(2),F(4),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    a = Stdlib_Buffer[18],
    b = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){return a(t, s, pos, len);}
   function add_subbytes(t, s, pos, len){return b(t, s, pos, len);}
   function sexp_of_t(t){
    var a = contents(t);
    return Base_Import[136].call(null, a);
   }
   var
    caml_buffer_length = Stdlib_Buffer[7],
    caml_buffer_blit = Stdlib_Buffer[5];
   function create$0(len){return Base_Bytes[34].call(null, len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_buffer_blit(src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      Base_Blit[2].call
       (null, [0, caml_buffer_length], [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = Base_Blit[3].call(null, [0], To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
//# shape: Base__Backtrace:[F(1),F(2)*,F(1),F(1),N,N,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0];
   function get(opt, param){
    var at_most_num_frames = opt ? opt[1] : Base_Int[65];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : Stdlib_Printexc[14].call(null, t);
   }
   function to_string_list(t){
    var a = to_string(t);
    return Base_String[104].call(null, a);
   }
   function sexp_of_t(t){
    var a = to_string_list(t);
    return [1, Base_List[53].call(null, a, function(x){return [0, x];})];
   }
   var
    set_recording = Stdlib_Printexc[7],
    am_recording = Stdlib_Printexc[8],
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM",
    cst_b = "b";
   function most_recent(param){return Stdlib_Printexc[12].call(null, 0);}
   function most_recent_for_exn(exn){
    return Base_Exn[18].call(null, exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = am_recording(0);
    set_recording(b);
    return Base_Exn[13].call
            (null, f, function(param){return set_recording(saved);});
   }
   function initialize_module(param){
    var match = Base_Sys0[21].call(null, cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      b = Base_String[97],
      c = Base_String[102].call(null, x, 44),
      ocamlrunparam_mentions_backtra =
        Base_List[23].call(null, c, function(a){return b(a, cst_b);});
    else
     var ocamlrunparam_mentions_backtra = 0;
    var a = 1 - ocamlrunparam_mentions_backtra;
    return a ? set_recording(1) : a;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__Int_conversions, Base__Int_string_conversions, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
//# shape: Base:[N,N,N,N,N,N,N,N,N,N,F(1),F(1)*,F(1)*,F(1),F(1)*,F(1),F(1),F(1),N,N,N,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(3),F(1),F(1),F(2),F(2),F(2),F(4),F(4),F(2),F(2),F(2),F(2),F(1),F(1),F(1),F(1),F(2),F(1),F(1),F(3),F(1),F(1),F(4),F(4),F(2),F(1),F(1),F(1),F(2),F(1),F(1),F(1),F(1),F(2),F(1)*,F(2),F(1),F(1),F(1),F(4),F(1),N,[F(1),F(2),F(1),F(1)*,F(1)*,N,N,F(2),N,F(2),F(3),F(2),F(2),F(2),F(1),F(1),N,N,N,F(1)*,N,N,N,N,N,N,N,F(2),F(2),N,N,N,N,N,N,N,N,F(2),F(2)],[F(1),F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1)*,F(1)*,F(1)*,F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1),F(1),F(1),F(1),F(1)*,F(1),F(1),F(1)*,F(1)*,N,N,N,N,F(1)*,F(1)*,F(1)*,N,F(3),F(2),F(1)],[N],[N,N,F(3),F(3),F(2)*,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1)*,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),N,N,N,F(1),F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1),N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(3),F(3),F(3),F(3),F(2),N,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,N,N,F(3),F(3),F(2),N,F(2),F(2),F(1)*,N,N,N,N,F(2)*,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1)*,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,F(1),F(1),N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),N,N,N,F(2),N,N,N,N,N,N,N,F(2)*,F(2)*,F(2),F(2),N,N,N,N,N,N,N,F(2)*,F(1)*,F(1)*,F(1),F(1),F(1)],N,N,F(3),F(3),F(2)*,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1)*,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),N,N,N,F(1),F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1),N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,F(3),F(3),F(3),F(3),F(2),N,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),N,N,N,N,F(3),F(3),F(2),N,F(2),F(2),F(1)*,N,N,N,N,F(2)*,F(2),F(2),F(1)*,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),F(1),F(1)*,N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,F(1),F(1),N,F(2)*,F(2)*,F(2)*,F(2)*,F(1)*,N,F(1),N,N,N,F(2),N,N,N,N,N,N,N,F(2)*,F(2)*,F(2),F(2),N,N,N,N,N,N,N,F(2)*,F(1)*,F(1)*,F(1),F(1),F(1),[],N,[]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    globalize = Base_Sexp_with_comparable[1],
    hash_fold_t = Base_Sexp_with_comparable[2],
    hash = Base_Sexp_with_comparable[3],
    t_of_sexp = Base_Sexp_with_comparable[4],
    sexp_of_t = Base_Sexp_with_comparable[5],
    Not_found_s = Base_Sexp_with_comparable[6],
    Of_sexp_error = Base_Sexp_with_comparable[7],
    message = Base_Sexp_with_comparable[8],
    default_indent = Base_Sexp_with_comparable[9],
    pp_hum = Base_Sexp_with_comparable[10],
    pp_hum_indent = Base_Sexp_with_comparable[11],
    pp_mach = Base_Sexp_with_comparable[12],
    pp = Base_Sexp_with_comparable[13],
    to_string_hum = Base_Sexp_with_comparable[14],
    to_string_mach = Base_Sexp_with_comparable[15],
    to_string = Base_Sexp_with_comparable[16],
    of_float_style = Base_Sexp_with_comparable[17],
    of_int_style = Base_Sexp_with_comparable[18],
    t_sexp_grammar = Base_Sexp_with_comparable[19],
    invariant = Base_Sexp_with_comparable[20],
    of_string = Base_Sexp_with_comparable[21],
    symbol$0 = Base_Sexp_with_comparable[22],
    symbol$1 = Base_Sexp_with_comparable[23],
    symbol$2 = Base_Sexp_with_comparable[24],
    symbol$3 = Base_Sexp_with_comparable[25],
    symbol$4 = Base_Sexp_with_comparable[26],
    symbol$5 = Base_Sexp_with_comparable[27],
    equal = Base_Sexp_with_comparable[28],
    compare = Base_Sexp_with_comparable[29],
    min = Base_Sexp_with_comparable[30],
    max = Base_Sexp_with_comparable[31],
    ascending = Base_Sexp_with_comparable[32],
    descending = Base_Sexp_with_comparable[33],
    between = Base_Sexp_with_comparable[34],
    clamp_exn = Base_Sexp_with_comparable[35],
    clamp = Base_Sexp_with_comparable[36],
    comparator = Base_Sexp_with_comparable[37],
    compare_local = Base_Sexp_with_comparable[38],
    equal_local = Base_Sexp_with_comparable[39],
    Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local],
    int_to_int32 = Base_Int_conversions[1],
    int_to_int32_exn = Base_Int_conversions[2],
    int_to_int32_trunc = Base_Int_conversions[3],
    int_to_int64 = Base_Int_conversions[4],
    int_to_nativeint = Base_Int_conversions[5],
    int32_to_int = Base_Int_conversions[6],
    int32_to_int_exn = Base_Int_conversions[7],
    int32_to_int_trunc = Base_Int_conversions[8],
    int32_to_int64 = Base_Int_conversions[9],
    int32_to_nativeint = Base_Int_conversions[10],
    int32_is_representable_as_int = Base_Int_conversions[11],
    int64_to_int = Base_Int_conversions[12],
    int64_to_int_exn = Base_Int_conversions[13],
    int64_to_int_trunc = Base_Int_conversions[14],
    int64_to_int32 = Base_Int_conversions[15],
    int64_to_int32_exn = Base_Int_conversions[16],
    int64_to_int32_trunc = Base_Int_conversions[17],
    int64_to_nativeint = Base_Int_conversions[18],
    int64_to_nativeint_exn = Base_Int_conversions[19],
    int64_to_nativeint_trunc = Base_Int_conversions[20],
    int64_fit_on_int63_exn = Base_Int_conversions[21],
    int64_is_representable_as_int6 = Base_Int_conversions[22],
    nativeint_to_int = Base_Int_conversions[23],
    nativeint_to_int_exn = Base_Int_conversions[24],
    nativeint_to_int_trunc = Base_Int_conversions[25],
    nativeint_to_int32 = Base_Int_conversions[26],
    nativeint_to_int32_exn = Base_Int_conversions[27],
    nativeint_to_int32_trunc = Base_Int_conversions[28],
    nativeint_to_int64 = Base_Int_conversions[29],
    num_bits_int = Base_Int_conversions[30],
    num_bits_int32 = Base_Int_conversions[31],
    num_bits_int64 = Base_Int_conversions[32],
    num_bits_nativeint = Base_Int_conversions[33],
    Make = Base_Int_string_conversions[1],
    Make_hex = Base_Int_string_conversions[2],
    Make_binary = Base_Int_string_conversions[3],
    sexp_of_int_style = Base_Int_string_conversions[4],
    insert_delimiter_every = Base_Int_string_conversions[5],
    insert_delimiter = Base_Int_string_conversions[6],
    insert_underscores = Base_Int_string_conversions[7],
    Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       Make,
       Make_hex,
       Make_binary,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores],
    am_testing = Base_Import[129],
    Exported_for_specific_uses = [0, am_testing],
    compare_array_local = Base_Array[2],
    compare_array = Base_Array[1],
    equal_array_local = Base_Array[106],
    equal_array = Base_Array[105],
    globalize_array = Base_Array[3],
    array_of_sexp = Base_Array[4],
    sexp_of_array = Base_Array[5];
   function array_sexp_grammar(a_sexp_grammar){
    return Base_Array[6].call(null, a_sexp_grammar);
   }
   var compare_bool_local = Base_Bool[28];
   function compare_bool(a, b){return compare_bool_local(a, b);}
   var equal_bool_local = Base_Bool[29];
   function equal_bool(a, b){return equal_bool_local(a, b);}
   var
    globalize_bool = Base_Bool[2],
    hash_fold_bool = Base_Bool[4],
    func = Base_Bool[5];
   function hash_bool(x){return func(x);}
   var
    bool_of_sexp = Base_Bool[6],
    sexp_of_bool = Base_Bool[7],
    bool_sexp_grammar = Base_Bool[3],
    compare_char_local = Base_Char[29];
   function compare_char(a, b){return compare_char_local(a, b);}
   var equal_char_local = Base_Char[28];
   function equal_char(a, b){return equal_char_local(a, b);}
   var
    globalize_char = Base_Char[2],
    hash_fold_char = Base_Char[4],
    func$0 = Base_Char[5];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[6],
    sexp_of_char = Base_Char[7],
    char_sexp_grammar = Base_Char[3],
    sexp_of_exn = Base_Exn[1],
    compare_float_local = Base_Float[24];
   function compare_float(a, b){return compare_float_local(a, b);}
   var equal_float_local = Base_Float[23];
   function equal_float(a, b){return equal_float_local(a, b);}
   var
    globalize_float = Base_Float[1],
    hash_fold_float = Base_Float[5],
    func$1 = Base_Float[6];
   function hash_float(x){return func$1(x);}
   var
    float_of_sexp = Base_Float[7],
    sexp_of_float = Base_Float[8],
    float_sexp_grammar = Base_Float[2],
    compare_int_local = Base_Int[30];
   function compare_int(a, b){return compare_int_local(a, b);}
   var equal_int_local = Base_Int[31];
   function equal_int(a, b){return equal_int_local(a, b);}
   var
    globalize_int = Base_Int[1],
    hash_fold_int = Base_Int[7],
    func$2 = Base_Int[8];
   function hash_int(x){return func$2(x);}
   var
    int_of_sexp = Base_Int[9],
    sexp_of_int = Base_Int[10],
    int_sexp_grammar = Base_Int[2],
    compare_int32_local = Base_Int32[36];
   function compare_int32(a, b){return compare_int32_local(a, b);}
   var equal_int32_local = Base_Int32[37];
   function equal_int32(a, b){return equal_int32_local(a, b);}
   var
    globalize_int32 = Base_Int32[1],
    hash_fold_int32 = Base_Int32[7],
    func$3 = Base_Int32[8];
   function hash_int32(x){return func$3(x);}
   var
    int32_of_sexp = Base_Int32[9],
    sexp_of_int32 = Base_Int32[10],
    int32_sexp_grammar = Base_Int32[2],
    compare_int64_local = Base_Int64[30];
   function compare_int64(a, b){return compare_int64_local(a, b);}
   var equal_int64_local = Base_Int64[31];
   function equal_int64(a, b){return equal_int64_local(a, b);}
   var
    globalize_int64 = Base_Int64[1],
    hash_fold_int64 = Base_Int64[7],
    func$4 = Base_Int64[8];
   function hash_int64(x){return func$4(x);}
   var
    int64_of_sexp = Base_Int64[9],
    sexp_of_int64 = Base_Int64[10],
    int64_sexp_grammar = Base_Int64[2],
    compare_list_local = Base_List[2],
    compare_list = Base_List[1],
    equal_list_local = Base_List[155],
    equal_list = Base_List[154],
    globalize_list = Base_List[3],
    hash_fold_list = Base_List[4],
    list_of_sexp = Base_List[5],
    sexp_of_list = Base_List[6];
   function list_sexp_grammar(a_sexp_grammar){
    return Base_List[7].call(null, a_sexp_grammar);
   }
   var compare_nativeint_local = Base_Nativeint[36];
   function compare_nativeint(a, b){return compare_nativeint_local(a, b);}
   var equal_nativeint_local = Base_Nativeint[37];
   function equal_nativeint(a, b){return equal_nativeint_local(a, b);}
   var
    globalize_nativeint = Base_Nativeint[1],
    hash_fold_nativeint = Base_Nativeint[7],
    func$5 = Base_Nativeint[8];
   function hash_nativeint(x){return func$5(x);}
   var
    nativeint_of_sexp = Base_Nativeint[9],
    sexp_of_nativeint = Base_Nativeint[10],
    nativeint_sexp_grammar = Base_Nativeint[2],
    compare_option_local = Base_Option[2],
    compare_option = Base_Option[1],
    equal_option_local = Base_Option[7],
    equal_option = Base_Option[6],
    globalize_option = Base_Option[3],
    hash_fold_option = Base_Option[4],
    option_of_sexp = Base_Option[9],
    sexp_of_option = Base_Option[10];
   function option_sexp_grammar(a_sexp_grammar){
    return Base_Option[5].call(null, a_sexp_grammar);
   }
   var
    compare_ref_local = Base_Ref[2],
    compare_ref = Base_Ref[1],
    equal_ref_local = Base_Ref[4],
    equal_ref = Base_Ref[3],
    globalize_ref = Base_Ref[5],
    ref_of_sexp = Base_Ref[6],
    sexp_of_ref = Base_Ref[7];
   function ref_sexp_grammar(a_sexp_grammar){
    return Base_Ref[8].call(null, a_sexp_grammar);
   }
   var compare_string_local = Base_String[62];
   function compare_string(a, b){return compare_string_local(a, b);}
   var equal_string_local = Base_String[135];
   function equal_string(a, b){return equal_string_local(a, b);}
   var globalize_string = Base_String[1], hash_fold_string = Base_String[40];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[41],
    sexp_of_string = Base_String[42],
    string_sexp_grammar = Base_String[2],
    compare_bytes_local = Base_Bytes[26];
   function compare_bytes(a, b){return compare_bytes_local(a, b);}
   var equal_bytes_local = Base_Bytes[27];
   function equal_bytes(a, b){return equal_bytes_local(a, b);}
   var
    globalize_bytes = Base_Bytes[1],
    bytes_of_sexp = Base_Bytes[2],
    sexp_of_bytes = Base_Bytes[3],
    bytes_sexp_grammar = Base_Bytes[4],
    compare_unit_local = Base_Unit[29];
   function compare_unit(a, b){return compare_unit_local(a, b);}
   var equal_unit_local = Base_Unit[28];
   function equal_unit(a, b){return equal_unit_local(a, b);}
   var
    globalize_unit = Base_Unit[2],
    hash_fold_unit = Base_Unit[4],
    func$6 = Base_Unit[5];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[6],
    sexp_of_unit = Base_Unit[7],
    unit_sexp_grammar = Base_Unit[3],
    symbol$6 = Base_List[156][1],
    a = Base_Int[75],
    symbol$7 = a[1],
    lnot = a[2],
    abs = a[3],
    zero = a[4],
    symbol$8 = a[5],
    symbol$9 = a[6],
    symbol$10 = a[7],
    b = Base_Import[97],
    ascending$0 = b[1],
    descending$0 = b[2],
    max$0 = b[3],
    min$0 = b[4],
    include = Base_Float[100],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol_concat = Base_String[67],
    fst = Base_Import[125],
    snd = Base_Import[127],
    failwith = Base_Import[124],
    invalid_arg = Base_Import[126],
    raise_s = Base_Error[32],
    Export =
      [0,
       compare_array_local,
       compare_array,
       equal_array_local,
       equal_array,
       globalize_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool_local,
       compare_bool,
       equal_bool_local,
       equal_bool,
       globalize_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char_local,
       compare_char,
       equal_char_local,
       equal_char,
       globalize_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float_local,
       compare_float,
       equal_float_local,
       equal_float,
       globalize_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int_local,
       compare_int,
       equal_int_local,
       equal_int,
       globalize_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32_local,
       compare_int32,
       equal_int32_local,
       equal_int32,
       globalize_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64_local,
       compare_int64,
       equal_int64_local,
       equal_int64,
       globalize_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list_local,
       compare_list,
       equal_list_local,
       equal_list,
       globalize_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint_local,
       compare_nativeint,
       equal_nativeint_local,
       equal_nativeint,
       globalize_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option_local,
       compare_option,
       equal_option_local,
       equal_option,
       globalize_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref_local,
       compare_ref,
       equal_ref_local,
       equal_ref,
       globalize_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string_local,
       compare_string,
       equal_string_local,
       equal_string,
       globalize_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes_local,
       compare_bytes,
       equal_bytes_local,
       equal_bytes,
       globalize_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit_local,
       compare_unit,
       equal_unit_local,
       equal_unit,
       globalize_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol_concat,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[297];
   Base_Backtrace[7].call(null, 0);
   var
    Caml = [0],
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Sexp,
       Int_conversions,
       Exported_for_specific_uses,
       Export,
       compare_array_local,
       compare_array,
       equal_array_local,
       equal_array,
       globalize_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool_local,
       compare_bool,
       equal_bool_local,
       equal_bool,
       globalize_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char_local,
       compare_char,
       equal_char_local,
       equal_char,
       globalize_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float_local,
       compare_float,
       equal_float_local,
       equal_float,
       globalize_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int_local,
       compare_int,
       equal_int_local,
       equal_int,
       globalize_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32_local,
       compare_int32,
       equal_int32_local,
       equal_int32,
       globalize_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64_local,
       compare_int64,
       equal_int64_local,
       equal_int64,
       globalize_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list_local,
       compare_list,
       equal_list_local,
       equal_list,
       globalize_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint_local,
       compare_nativeint,
       equal_nativeint_local,
       equal_nativeint,
       globalize_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option_local,
       compare_option,
       equal_option_local,
       equal_option,
       globalize_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref_local,
       compare_ref,
       equal_ref_local,
       equal_ref,
       globalize_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string_local,
       compare_string,
       equal_string_local,
       equal_string,
       globalize_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes_local,
       compare_bytes,
       equal_bytes_local,
       equal_bytes,
       globalize_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit_local,
       compare_unit,
       equal_unit_local,
       equal_unit,
       globalize_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol_concat,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s,
       Continue_or_stop,
       Not_found_s$0,
       Caml];
   runtime.caml_register_global(23, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsT0FBQSxLQUFBQSxTQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0Jvb2wwIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsYUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2dsb2JhbGl6ZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoZSBbZ2xvYmFsaXplX3tib29sLGNoYXIsdW5pdH1dIGZ1bmN0aW9ucyBhcmUgd3JpdHRlbiBhcyBtYXRjaGVzIHBsdXMgdGhlIGlkZW50aXR5XG4gICBmdW5jdGlvbiBzbyB0aGF0IHRoZSB0eXBlIGNoZWNrZXIgY2FuIGdpdmUgdGhlbSB0aGUgZGVzaXJlZCB0eXBlLCB3aXRob3V0IGhhdmluZyB0byBkb1xuICAgYW55dGhpbmcgc3BlY2lhbC4gIEhvd2V2ZXIsIFtnbG9iYWxpemVfaW50XSBjYW5ub3QgYmUgd3JpdHRlbiB0aGlzIHdheSwgc28gd2UgcmVzb3J0IHRvXG4gICB1c2luZyBhbiBbZXh0ZXJuYWxdLiAqKVxuXG5sZXQgZ2xvYmFsaXplX2Jvb2wgPSBmdW5jdGlvblxuICB8ICh0cnVlIHwgZmFsc2UpIGFzIGIgLT4gYlxuOztcblxubGV0IGdsb2JhbGl6ZV9jaGFyID0gZnVuY3Rpb25cbiAgfCAnXFx4MDAnIC4uICdcXHhGRicgYXMgYyAtPiBjXG47O1xuXG5leHRlcm5hbCBnbG9iYWxpemVfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9pbnQgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludDMyIDogaW50MzIgLT4gaW50MzIgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBnbG9iYWxpemVfaW50NjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2J5dGVzIDogYnl0ZXMgLT4gYnl0ZXMgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBnbG9iYWxpemVfc3RyaW5nIDogc3RyaW5nIC0+IHN0cmluZyA9IFwiY2FtbF9vYmpfZHVwXCJcblxubGV0IGdsb2JhbGl6ZV91bml0ICgoKSBhcyB1KSA9IHVcblxuZXh0ZXJuYWwgZ2xvYmFsaXplX2FycmF5JyA6ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX29ial9kdXBcIlxuXG5sZXQgZ2xvYmFsaXplX2FycmF5IF8gYSA9IGdsb2JhbGl6ZV9hcnJheScgYVxuXG5sZXQgcmVjIGdsb2JhbGl6ZV9saXN0IGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB4cyAtPiBmIHggOjogZ2xvYmFsaXplX2xpc3QgZiB4c1xuOztcblxubGV0IGdsb2JhbGl6ZV9vcHRpb24gZiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB4IC0+IFNvbWUgKGYgeClcbjs7XG5cbmxldCBnbG9iYWxpemVfcmVzdWx0IGdsb2JhbGl6ZV9hIGdsb2JhbGl6ZV9iIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBhIC0+IE9rIChnbG9iYWxpemVfYSBhKVxuICB8IEVycm9yIGIgLT4gRXJyb3IgKGdsb2JhbGl6ZV9iIGIpXG47O1xuXG5sZXQgZ2xvYmFsaXplX3JlZicgciA9IHJlZiAhclxubGV0IGdsb2JhbGl6ZV9yZWYgXyByID0gZ2xvYmFsaXplX3JlZicgclxuXG5leHRlcm5hbCBnbG9iYWxpemVfbGF6eV90X21vbm8gOiAnYSBsYXp5X3QgLT4gJ2EgbGF6eV90ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgZ2xvYmFsaXplX2xhenlfdCBfIHQgPSBnbG9iYWxpemVfbGF6eV90X21vbm8gdFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial9kdXAiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsaXplX2Jvb2wiLCJiIiwiZ2xvYmFsaXplX2NoYXIiLCJjIiwiZ2xvYmFsaXplX3VuaXQiLCJ1IiwiZ2xvYmFsaXplX2FycmF5IiwicGFyYW0iLCJhIiwiZ2xvYmFsaXplX2xpc3QiLCJ4cyIsIngiLCJnbG9iYWxpemVfb3B0aW9uIiwiZ2xvYmFsaXplX3Jlc3VsdCIsImdsb2JhbGl6ZV9hIiwiZ2xvYmFsaXplX2IiLCJ0IiwiZ2xvYmFsaXplX3JlZiIsInIiLCJnbG9iYWxpemVfbGF6eV90IiwiQmFzZV9HbG9iYWxpemUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGVBQUFDLEdDTTJCLFNBQUM7QUFBQSxZQUFBQyxlQUFBQyxHQUlDLFNBQUM7QUFBQSxZQUFBQyxlQUFBQyxHQVdDLFNBQUM7QUFBQSxZQUFBQyxnQkFBQUMsT0FBQUMsR0FJTixzQkFBa0I7QUFBQSxZQUFBQyxlQUFBWCxHQUFBUztBQUFBQSxJQUVyQixZQUNiO0FBQUEsUUFBQUcsS0FEYSxVQUFBQyxJQUFBLGNBRUQ7QUFBQSxJQUFQLCtCQUFHO0FBQUEsR0FBdUI7QUFBQSxZQUFBQyxpQkFBQWQsR0FBQVM7QUFBQUEsSUFHcEIsWUFDVDtBQUFBLFFBQUFJLElBRFM7QUFBQSxJQUVGLDRCQUFLO0FBQUE7QUFBQSxZQUFBRSxpQkFBQUMsYUFBQUMsYUFBQUM7QUFBQUEsSUFJdEIsbUJBQUFSLElBQUEsTUFDYSxzQ0FBZTtBQUFBLFFBQUFQLElBRDVCO0FBQUEsSUFFbUIsc0NBQWU7QUFBQTtBQUFBLFlBQUFnQixjQUFBVixPQUFBVyxHQUdiLGlCQUNpQjtBQUFBLFlBQUFDLGlCQUFBWixPQUFBUyxHQUliLFNBQXVCO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNRGhEbEQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo4NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9wb2x5MC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBQcmltaXRpdmVzIGZvciBwb2x5bW9ycGhpYyBjb21wYXJlLiAqKVxuXG4oKl8gUG9seW1vcnBoaWMgY29tcGlsZXIgcHJpbWl0aXZlcyBjYW4ndCBiZSBhbGlhc2VzIGFzIHRoaXMgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICBpbmxpbmluZy4gKElmIGFsaWFzZWQgd2l0aG91dCBhIHR5cGUgYW5ub3RhdGlvbiwgdGhlIGNvbXBpbGVyIHdvdWxkIGltcGxlbWVudCB0aGVtXG4gIHVzaW5nIHRoZSBnZW5lcmljIGNvZGUgZG9pbmcgYSBDIGNhbGwsIGFuZCBpdCdzIHRoaXMgY29kZSB0aGF0IHdvdWxkIGJlIGlubGluZWQuKSBBcyBhXG4gIHJlc3VsdCB3ZSBoYXZlIHRvIGNvcHkgdGhlIFtleHRlcm5hbCAuLi5dIGRlY2xhcmF0aW9uIGhlcmUuICopXG5leHRlcm5hbCAoIDwgKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoID0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPj0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGFzY2VuZGluZyA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBlcXVhbCA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuXG5sZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxubGV0IG1heCB4IHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG5sZXQgbWluIHggeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jb21wYXJlIiwiZGVzY2VuZGluZyIsIngiLCJ5IiwibWF4IiwibWluIiwiQmFzZV9Qb2x5MCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxHQ2dCcUIseUJBQVc7QUFBQSxZQUFBQyxJQUFBRixHQUFBQztBQUFBQSxJQUNMLE9BQWIsd0JBQWEsc0NBQVk7QUFBQTtBQUFBLFlBQUFFLElBQUFILEdBQUFDO0FBQUFBLElBQ1osT0FBYix3QkFBYSxtQ0FBWTtBQUFBO0FBQUEsT0FBQUcsYURsQnZDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ltcG9ydDAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgICBpbmNsdWRlIFNoYWRvd19zdGRsaWJcbiAgICBlbmRcbiAgICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0IDo9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgICgqIFRoZXNlIG1vZHVsZXMgYXJlIHJlZGVmaW5lZCBpbiBCYXNlICopXG4gICAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICAgIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICAgIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gICAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gICAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICAgIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gICAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gICAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICAgIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gICAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gICAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICAgIHdpdGggbW9kdWxlIEludDY0IDo9IFNoYWRvd19zdGRsaWIuSW50NjRcbiAgICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICAgIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gICAgd2l0aCBtb2R1bGUgTWFwIDo9IFNoYWRvd19zdGRsaWIuTWFwXG4gICAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gICAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gICAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gICAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICAgIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICAgIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICAgIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICAgIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gICAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXQpXG5bQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIFN0ZGxpYi5yZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5cbigqIFJlc2h1ZmZsZSBbU3RkbGliXSBzbyB0aGF0IHdlIGNob29zZSB0aGUgbW9kdWxlcyB1c2luZyBsYWJlbHMgd2hlbiBhdmFpbGFibGUuICopXG5tb2R1bGUgU3RkbGliID0gc3RydWN0XG4gIGluY2x1ZGUgU3RkbGliXG4gIGluY2x1ZGUgU3RkbGliLlN0ZExhYmVsc1xuICBpbmNsdWRlIFN0ZGxpYi5Nb3JlTGFiZWxzXG5lbmRcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCgnYSAtPiAnYilbQGxvY2FsX29wdF0pIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgbm90IDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuKCogV2UgdXNlIFtPYmoubWFnaWNdIGhlcmUgYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIGdlbmVyYXRlIGEgY29uZGl0aW9uYWwganVtcCBhbmQgdGhlXG4gICBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlIGlzIG5vdGljZWFibGUuICopXG5sZXQgYm9vbF90b19pbnQgKHggOiBib29sKSA6IGludCA9IFN0ZGxpYi5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseSAqKVxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0ICggIT0gKSA9IFN0ZGxpYi4oICE9IClcbmxldCAoICogKSA9IFN0ZGxpYi4oICogKVxubGV0ICggKiogKSA9IFN0ZGxpYi4oICoqIClcbmxldCAoICouICkgPSBTdGRsaWIuKCAqLiApXG5sZXQgKCArICkgPSBTdGRsaWIuKCArIClcbmxldCAoICsuICkgPSBTdGRsaWIuKCArLiApXG5sZXQgKCAtICkgPSBTdGRsaWIuKCAtIClcbmxldCAoIC0uICkgPSBTdGRsaWIuKCAtLiApXG5sZXQgKCAvICkgPSBTdGRsaWIuKCAvIClcbmxldCAoIC8uICkgPSBTdGRsaWIuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG4gIGV4dGVybmFsICggPCApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgY29tcGFyZV9fbG9jYWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuICBleHRlcm5hbCBlcXVhbF9fbG9jYWwgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtYXggKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBpbnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgKCogRGVjbGFyZWQgYXMgZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX2FwcGx5X1ggd3JhcHBpbmcgZXZlbiB3aGVuXG4gICAgIGNvbXBpbGluZyB3aXRob3V0IGNyb3NzIGxpYnJhcnkgaW5saW5pbmcuICopXG4gIGV4dGVybmFsICggPSApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA8PiApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVub3RlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA8IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWxlc3N0aGFuXCJcblxuICBleHRlcm5hbCAoID4gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZ3JlYXRlcnRoYW5cIlxuXG4gIGV4dGVybmFsICggPD0gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlbGVzc2VxdWFsXCJcblxuICBleHRlcm5hbCAoID49IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgY29tcGFyZVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50XG4gICAgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBjb21wYXJlX19sb2NhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50XG4gICAgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBlcXVhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZXF1YWxcIlxuXG4gIGV4dGVybmFsIGVxdWFsX19sb2NhbFxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZXF1YWxcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogU3RkbGliLkludDY0LnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogYm9vbCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBib29sKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogYm9vbCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogY2hhcikgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBjaGFyKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogY2hhcikgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIG9wZW4gc3RydWN0XG4gICAgZXh0ZXJuYWwgaSA6IChTdGRsaWIuVWNoYXIudFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuICBlbmRcblxuICBsZXQgKCA8ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSAoaSB4KSAoaSB5KVxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmRlc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgY29tcGFyZSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIChpIHgpIChpIHkpXG4gIGxldCBlcXVhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVfX2xvY2FsIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsX19sb2NhbCAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBtYXggKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCA8ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA8PSApIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoIDw+ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA9ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+PSApIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBlcXVhbCA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZV9fbG9jYWwgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGZsb2F0KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHN0cmluZykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IHN0cmluZykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogc3RyaW5nKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IHN0cmluZykgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBzdHJpbmcpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJ5dGVzKSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxuKCogVGhpcyBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIHNvIHRoYXQgdGhlIGNvbXBpbGVyIGNhbiBzcGVjaWFsaXplIGl0IGFzIGFcbiAgIGRpcmVjdCBzZXQgb3IgY2FtbF9tb2RpZnkuICopXG5leHRlcm5hbCAoIDo9ICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuKCogVGhlc2UgbmVlZCB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIG90aGVyd2lzZSB0aGUgY29tcGlsZXIgd29uJ3QgdW5ib3hcbiAgIHJlZmVyZW5jZXMuICopXG5leHRlcm5hbCAoICEgKSA6ICgnYSByZWZbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHJlZiA6ICdhIC0+ICgnYSByZWZbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuXG5sZXQgKCBAICkgPSBTdGRsaWIuKCBAIClcbmxldCAoIF4gKSA9IFN0ZGxpYi4oIF4gKVxubGV0ICggfi0gKSA9IFN0ZGxpYi4oIH4tIClcbmxldCAoIH4tLiApID0gU3RkbGliLiggfi0uIClcbmxldCAoIGFzciApID0gU3RkbGliLiggYXNyIClcbmxldCAoIGxhbmQgKSA9IFN0ZGxpYi4oIGxhbmQgKVxubGV0IGxub3QgPSBTdGRsaWIubG5vdFxubGV0ICggbG9yICkgPSBTdGRsaWIuKCBsb3IgKVxubGV0ICggbHNsICkgPSBTdGRsaWIuKCBsc2wgKVxubGV0ICggbHNyICkgPSBTdGRsaWIuKCBsc3IgKVxubGV0ICggbHhvciApID0gU3RkbGliLiggbHhvciApXG5sZXQgKCBtb2QgKSA9IFN0ZGxpYi4oIG1vZCApXG5sZXQgYWJzID0gU3RkbGliLmFic1xubGV0IGZhaWx3aXRoID0gU3RkbGliLmZhaWx3aXRoXG5sZXQgZnN0ID0gU3RkbGliLmZzdFxubGV0IGludmFsaWRfYXJnID0gU3RkbGliLmludmFsaWRfYXJnXG5sZXQgc25kID0gU3RkbGliLnNuZFxuXG4oKiBbcmFpc2VdIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgYXMgdGhlIGNvbXBpbGVyIGF1dG9tYXRpY2FsbHkgcmVwbGFjZXNcbiAgICclcmFpc2UnIGJ5ICclcmVyYWlzZScgd2hlbiBhcHByb3ByaWF0ZS4gKilcbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+IF8gPSBcIiVyYWlzZVwiXG5leHRlcm5hbCBwaHlzX2VxdWFsIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCBkZWNyIDogKGludCByZWZbQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVkZWNyXCJcbmV4dGVybmFsIGluY3IgOiAoaW50IHJlZltAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWluY3JcIlxuXG4oKiBVc2VkIGJ5IHNleHBfY29udiwgd2hpY2ggZmxvYXQwIGRlcGVuZHMgb24gdGhyb3VnaCBvcHRpb24uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ1xuXG4oKiBbYW1fdGVzdGluZ10gaXMgdXNlZCBpbiBhIGZldyBwbGFjZXMgdG8gYmVoYXZlIGRpZmZlcmVudGx5IHdoZW4gaW4gdGVzdGluZyBtb2RlLCBzdWNoXG4gICBhcyBpbiBbcmFuZG9tLm1sXS4gIFthbV90ZXN0aW5nXSBpcyBpbXBsZW1lbnRlZCB1c2luZyBbQmFzZV9hbV90ZXN0aW5nXSwgYSB3ZWFrIEMvanNcbiAgIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW2ZhbHNlXSwgYnV0IHdoZW4gbGlua2luZyBhbiBpbmxpbmUtdGVzdC1ydW5uZXIgZXhlY3V0YWJsZSwgaXNcbiAgIG92ZXJyaWRkZW4gYnkgYW5vdGhlciBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFt0cnVlXS4gKilcbmV4dGVybmFsIGFtX3Rlc3RpbmcgOiB1bml0IC0+IGJvb2wgPSBcIkJhc2VfYW1fdGVzdGluZ1wiXG5cbmxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZyAoKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfZXF1YWwiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImdsb2JhbF9kYXRhIiwiQmFzZV9Qb2x5MCIsIlNoYWRvd19zdGRsaWIiLCJTdGRsaWIiLCJTdGRsaWJfTW9yZUxhYmVscyIsIkV4aXQiLCJOb3RfZm91bmQiLCJtYXhfaW50IiwibWluX2ludCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJib29sX29mX3N0cmluZ19vcHQiLCJib29sX29mX3N0cmluZyIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnRfb3B0IiwicmVhZF9pbnQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfZmxvYXQiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsIm9wZW5fb3V0X2dlbiIsImZsdXNoIiwiZmx1c2hfYWxsIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0X2J5dGVzIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfdmFsdWUiLCJzZWVrX291dCIsInBvc19vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJzZXRfYmluYXJ5X21vZGVfb3V0Iiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwib3Blbl9pbl9nZW4iLCJpbnB1dF9jaGFyIiwiaW5wdXRfbGluZSIsImlucHV0IiwicmVhbGx5X2lucHV0IiwicmVhbGx5X2lucHV0X3N0cmluZyIsImlucHV0X2J5dGUiLCJpbnB1dF9iaW5hcnlfaW50IiwiaW5wdXRfdmFsdWUiLCJzZWVrX2luIiwicG9zX2luIiwiaW5fY2hhbm5lbF9sZW5ndGgiLCJjbG9zZV9pbiIsImNsb3NlX2luX25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX2luIiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCIsImV4aXQiLCJhdF9leGl0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJ1bnNhZmVfcmVhbGx5X2lucHV0IiwiZG9fYXRfZXhpdCIsImRvX2RvbWFpbl9sb2NhbF9hdF9leGl0IiwiaW52YWxpZF9hcmciLCJmYWlsd2l0aCIsIk1hdGNoX2ZhaWx1cmUiLCJBc3NlcnRfZmFpbHVyZSIsIkludmFsaWRfYXJndW1lbnQiLCJGYWlsdXJlIiwiT3V0X29mX21lbW9yeSIsIlN0YWNrX292ZXJmbG93IiwiU3lzX2Vycm9yIiwiRW5kX29mX2ZpbGUiLCJEaXZpc2lvbl9ieV96ZXJvIiwiU3lzX2Jsb2NrZWRfaW8iLCJVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSIsIm1pbiIsIm1heCIsImFicyIsImxub3QiLCJzeW1ib2xfY29uY2F0IiwiTGFyZ2VGaWxlIiwiSGFzaHRibCIsIk1hcCIsIlNldCIsImJvb2xfdG9faW50IiwieCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJ5IiwiSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyIiwiY29tcGFyZSIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbCIsImVxdWFsX2xvY2FsIiwiSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wIiwiSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wIiwiTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfIiwiQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhIiwiQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhIiwiVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wIiwiRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wIiwiU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tIiwiQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wIiwiYXNyIiwibGFuZCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJmc3QiLCJzbmQiLCJmbG9hdF9vZl9zdHJpbmciLCJhbV90ZXN0aW5nIiwiQmFzZV9JbXBvcnQwIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMs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V0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFvQixVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBM0c7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBNEcsWUFBQUMsR0M2RG1DLFNBQWtCO0FBQUEsWUFBQTlCLFNBQUEsTUQ3RHJEO0FBQUEsT0FBQUEsV0FBQTtBQUFBLFlBQUFBLFNBQUE7QUFBQSxZQUFBQSxTQUFBO0FBQUEsWUFBQUEsU0FBQTtBQUFBLFlBQUFBLFNBQUE7QUFBQSxZQUFBQSxTQUFBO0FBQUEsWUFBQUEsU0FBQTtBQUFBLE9BQUFBLFlBQUE7QUFBQSxZ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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEaFg5QiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjg2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzdWNjIiwicHJlZCIsIkJhc2VfSW50MCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxZQUFBQyxTQUFBO0FBQUEsWUFBQUMsU0FBQTtBQUFBLE9BQUFDLFlBQUEsWUFBQUMsWUFBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxLQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6ODk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3ByaW50Zi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgU3RkbGliLlByaW50ZlxuXG4oKiogZmFpbHdpdGgsIGludmFsaWRfYXJnLCBhbmQgZXhpdCBhY2NlcHRpbmcgcHJpbnRmJ3MgZm9ybWF0LiAqKVxuXG5sZXRbQGlubGluZSBuZXZlcl0gW0B6ZXJvX2FsbG9jIGFzc3VtZSBuZXZlcl9yZXR1cm5zX25vcm1hbGx5XSBmYWlsd2l0aGYgZm10ID1cbiAga3NwcmludGYgKGZ1biBzICgpIC0+IGZhaWx3aXRoIHMpIGZtdFxuOztcblxubGV0W0BpbmxpbmUgbmV2ZXJdIFtAemVyb19hbGxvYyBhc3N1bWUgbmV2ZXJfcmV0dXJuc19ub3JtYWxseV0gaW52YWxpZF9hcmdmIGZtdCA9XG4gIGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQwIiwiU3RkbGliX1ByaW50ZiIsInNwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJrc3ByaW50ZiIsImticHJpbnRmIiwiZmFpbHdpdGhmIiwiZm10IiwicyIsInBhcmFtIiwiaW52YWxpZF9hcmdmIiwiQmFzZV9QcmludGYiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUNNRTtBQUFBLHNCQUFBQyxHQUFBQyxPQUFzQixzQ0FBVSxRQUFLO0FBQUE7QUFBQSxZQUFBQyxhQUFBSDtBQUFBQSxJQUlyQztBQUFBLHNCQUFBQyxHQUFBQyxPQUFzQixzQ0FBYSxRQUFLO0FBQUE7QUFBQTtBQUFBLElBQUFFO0FBQUFBLE1EVjFDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6OTM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3N5czAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBbU3lzMF0gZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtTdGRsaWIuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtTdGRsaWIuU3lzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIHN5cy5tbFxuICAgc2hvdWxkIHVzZSBbU3RkbGliLlN5c10uIFtTeXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZVxuICAgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSB0aGVzZVxuICAgZnVuY3Rpb25zIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TeXNdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBTeXMgPSBTeXMwXS4gIERlZmluaW5nIFttb2R1bGUgU3lzID0gU3lzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TeXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbnR5cGUgYmFja2VuZF90eXBlID0gU3RkbGliLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBTdGRsaWIuU3lzLmJhY2tlbmRfdHlwZVxubGV0IGludGVyYWN0aXZlID0gU3RkbGliLlN5cy5pbnRlcmFjdGl2ZVxubGV0IG9zX3R5cGUgPSBTdGRsaWIuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gU3RkbGliLlN5cy51bml4XG5sZXQgd2luMzIgPSBTdGRsaWIuU3lzLndpbjMyXG5sZXQgY3lnd2luID0gU3RkbGliLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMud29yZF9zaXplXG5sZXQgaW50X3NpemVfaW5fYml0cyA9IFN0ZGxpYi5TeXMuaW50X3NpemVcbmxldCBiaWdfZW5kaWFuID0gU3RkbGliLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBTdGRsaWIuU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgbWF4X2FycmF5X2xlbmd0aCA9IFN0ZGxpYi5TeXMubWF4X2FycmF5X2xlbmd0aFxubGV0IHJ1bnRpbWVfdmFyaWFudCA9IFN0ZGxpYi5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gU3RkbGliLlN5cy5ydW50aW1lX3BhcmFtZXRlcnNcbmxldCBhcmd2ID0gU3RkbGliLlN5cy5hcmd2XG5sZXQgZ2V0X2FyZ3YgKCkgPSBTdGRsaWIuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gU3RkbGliLlN5cy5vY2FtbF92ZXJzaW9uXG5sZXQgZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgPSBTdGRsaWIuU3lzLmVuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG5sZXQgcnVudGltZV93YXJuaW5nc19lbmFibGVkID0gU3RkbGliLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubW9kdWxlIE1ha2VfaW1tZWRpYXRlNjRcbiAgKEltbSA6IFN0ZGxpYi5TeXMuSW1tZWRpYXRlNjQuSW1tZWRpYXRlKVxuICAoTm9uX2ltbSA6IFN0ZGxpYi5TeXMuSW1tZWRpYXRlNjQuTm9uX2ltbWVkaWF0ZSkgPVxuICBTdGRsaWIuU3lzLkltbWVkaWF0ZTY0Lk1ha2UgKEltbSkgKE5vbl9pbW0pXG5cbmxldCBnZXRlbnZfZXhuIHZhciA9XG4gIHRyeSBTdGRsaWIuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IFN0ZGxpYi5Ob3RfZm91bmQgLT5cbiAgICBQcmludGYuZmFpbHdpdGhmIFwiU3lzLmdldGVudl9leG46IGVudmlyb25tZW50IHZhcmlhYmxlICVzIGlzIG5vdCBzZXRcIiB2YXIgKClcbjs7XG5cbmxldCBnZXRlbnYgdmFyID1cbiAgbWF0Y2ggU3RkbGliLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBTdGRsaWIuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJW9wYXF1ZVwiXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHlfZ2xvYmFsIDogJ2EgLT4gJ2EgPSBcIiVvcGFxdWVcIlxuXG5leGNlcHRpb24gQnJlYWsgPSBTdGRsaWIuU3lzLkJyZWFrXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydDAiLCJCYXNlX1ByaW50ZiIsIlN0ZGxpYl9TeXMiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImludF9zaXplX2luX2JpdHMiLCJiaWdfZW5kaWFuIiwibWF4X3N0cmluZ19sZW5ndGgiLCJtYXhfYXJyYXlfbGVuZ3RoIiwicnVudGltZV92YXJpYW50IiwicnVudGltZV9wYXJhbWV0ZXJzIiwiYXJndiIsImdldF9hcmd2IiwicGFyYW0iLCJvY2FtbF92ZXJzaW9uIiwiZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJNYWtlX2ltbWVkaWF0ZTY0IiwiZ2V0ZW52X2V4biIsInZhciQiLCJleG4iLCJnZXRlbnYiLCJ4IiwiQnJlYWsiLCJCYXNlX1N5czAiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxZQUFBQyxTQUFBQyxPQzhCa0IsdUJBQWU7QUFBQTtBQUFBLElBQUFDLGdCRDlCakM7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxXQUFBQztBQUFBQSxJQ3lDRSxZQUFJO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTUR6Q047QUFBQTtBQUFBLE1DMkNJLHdEQUE0RTtBQUFBLEtEM0NoRjtBQUFBO0FBQUEsR0MyQ2dGO0FBQUEsWUFBQUMsT0FBQUY7QUFBQUEsSUFJOUUsUUFBQUcsSUFBTTtBQUFBLFVBQUFGO0FBQUFBLFNBQUFBLE1EL0NSO0FBQUEscUNDaURrQztBQUFBLEtEakRsQztBQUFBO0FBQUEsSUNnRFM7QUFBQSxHQUM2QjtBQUFBO0FBQUEsSUFBQUcsUURqRHRDO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEwMzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYXJyYXkwLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogW0FycmF5MF0gZGVmaW5lcyBhcnJheSBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXNcbiAgIG9mIFtTdGRsaWIuQXJyYXldLiAgW0FycmF5MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtTdGRsaWIuQXJyYXldXG4gICB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGFycmF5MC5tbCBzaG91bGQgdXNlIFtTdGRsaWIuQXJyYXldLlxuICAgW0FycmF5MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgYXJyYXlzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5BcnJheV0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkXG4gICBkbyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXS4gIFRoaXMgaW5jbHVkZXMgdXNlcyBvZiBzdWJzY3JpcHQgc3ludGF4IChbeC4oaSldLCBbeC4oaSkgPC1cbiAgIGVdKSwgd2hpY2ggdGhlIE9DYW1sIHBhcnNlciBkZXN1Z2FycyBpbnRvIGNhbGxzIHRvIFtBcnJheS5nZXRdIGFuZCBbQXJyYXkuc2V0XS5cbiAgIERlZmluaW5nIFttb2R1bGUgQXJyYXkgPSBBcnJheTBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbVxuICAgbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQXJyYXldLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG4gIGV4dGVybmFsIGNyZWF0ZV9sb2NhbCA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCA6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuICBleHRlcm5hbCBnZXQgOiAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5cbiAgZXh0ZXJuYWwgc2V0XG4gICAgOiAgKCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gJ2FcbiAgICAtPiB1bml0XG4gICAgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldFxuICAgIDogICgnYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICdhXG4gICAgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0XG4gICAgOiAgKCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gJ2FcbiAgICAtPiB1bml0XG4gICAgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfYmxpdFxuICAgIDogIHNyYzooJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6KCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGRzdF9wb3M6aW50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmVuZFxuXG5pbmNsdWRlIEFycmF5XG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9hcnJheV9sZW5ndGhcblxubGV0IGNyZWF0ZSB+bGVuIHggPVxuICB0cnkgY3JlYXRlIGxlbiB4IHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlIH5sZW46JWQ6IGludmFsaWQgbGVuZ3RoXCIgbGVuICgpXG47O1xuXG5sZXQgY3JlYXRlX2xvY2FsIH5sZW4geCA9XG4gIHRyeSBjcmVhdGVfbG9jYWwgbGVuIHggd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfbG9jYWwgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuID1cbiAgdHJ5IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIGxlbiB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBhcHBlbmQgPSBTdGRsaWIuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IFN0ZGxpYi5BcnJheS5ibGl0XG5sZXQgY29uY2F0ID0gU3RkbGliLkFycmF5LmNvbmNhdFxubGV0IGNvcHkgPSBTdGRsaWIuQXJyYXkuY29weVxubGV0IGZpbGwgPSBTdGRsaWIuQXJyYXkuZmlsbFxuXG5sZXQgaW5pdCBsZW4gfihmIDogXyAtPiBfKSA9XG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBbfHxdXG4gIGVsc2UgaWYgbGVuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSBjcmVhdGUgfmxlbiAoZiAwKSBpblxuICAgIGZvciBpID0gMSB0byBJbnQwLnByZWQgbGVuIGRvXG4gICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgZG9uZTtcbiAgICByZXMpXG47O1xuXG5sZXQgbWFrZV9tYXRyaXggPSBTdGRsaWIuQXJyYXkubWFrZV9tYXRyaXhcbmxldCBvZl9saXN0ID0gU3RkbGliLkFycmF5Lm9mX2xpc3RcbmxldCBzdWIgPSBTdGRsaWIuQXJyYXkuc3ViXG5sZXQgdG9fbGlzdCA9IFN0ZGxpYi5BcnJheS50b19saXN0XG5cbmxldCBmb2xkIHQgfmluaXQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBmb2xkX3JpZ2h0IHQgfihmIDogXyAtPiBfIC0+IF8pIH5pbml0ID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IGxlbmd0aCB0IC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCB0IGkpICFyXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgaXRlciB0IH4oZiA6IF8gLT4gXykgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSB0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgbWFwIHQgfihmIDogXyAtPiBfKSA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSB+bGVuIChmICh1bnNhZmVfZ2V0IHQgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IG1hcGkgdCB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHIgPSBjcmVhdGUgfmxlbiAoZiAwICh1bnNhZmVfZ2V0IHQgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgdCBpKSlcbiAgICBkb25lO1xuICAgIHIpXG47O1xuXG5sZXQgc3RhYmxlX3NvcnQgdCB+Y29tcGFyZSA9IFN0ZGxpYi5BcnJheS5zdGFibGVfc29ydCB0IH5jbXA6Y29tcGFyZVxuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBlbHRfaSA9IHQuKGkpIGluXG4gIGxldCBlbHRfaiA9IHQuKGopIGluXG4gIHVuc2FmZV9zZXQgdCBpIGVsdF9qO1xuICB1bnNhZmVfc2V0IHQgaiBlbHRfaVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0FycmF5TGFiZWxzIiwiQmFzZV9JbXBvcnQwIiwiQmFzZV9JbnQwIiwiQmFzZV9QcmludGYiLCJCYXNlX1N5czAiLCJpbnZhbGlkX2FyZ2YiLCJBcnJheSIsIm1heF9sZW5ndGgiLCJjcmVhdGUiLCJjcmVhdGVfbG9jYWwiLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImNzdF9BcnJheV9pbml0IiwiaW5pdCIsImxlbiIsIngiLCJyZXMiLCJpIiwibWFrZV9tYXRyaXgiLCJvZl9saXN0Iiwic3ViIiwidG9fbGlzdCIsImZvbGQiLCJ0IiwiciIsImZvbGRfcmlnaHQiLCJpdGVyIiwiaXRlcmkiLCJtYXAiLCJtYXBpIiwic3RhYmxlX3NvcnQiLCJjb21wYXJlIiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiQmFzZV9BcnJheTAiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsS0FBQUMsS0FBQXZCO0FBQUFBLElDK0VFLGNBQ0s7QUFBQSxJQUNBLFlBQ0EsbURBTUM7QUFBQTtBQUFBLEtBQUF3QixJQUprQjtBQUFBLEtBQUFDLE1BM0JwQjtBQUFBLFNBNEJXO0FBQUEsU0FBYTtBQUFBO0FBQUEsU0FBQUMsSUFBQTtBQUFBO0FBQUEsTUFDUDtBQUFBLGNBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXhCO0FBQUEsR0FBSTtBQUFBO0FBQUEsSUFBQUMsY0R4RlI7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQUFBVixNQUFBdEI7QUFBQUE7QUFBQUEsS0FBQWlDLElDaUdFO0FBQUEsU0FDYTtBQUFBLFNBQVk7QUFBQTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ2xCO0FBQUEsY0FBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRTVCO0FBQUEsR0FBRTtBQUFBLFlBQUFRLFdBQUFGLEdBQUFoQyxHQUFBc0I7QUFBQUEsUUFBQVcsSUFJRixlQUNRO0FBQUEsSUFBWTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ2I7QUFBQSxjQUFxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFNUI7QUFBQSxHQUFFO0FBQUEsWUFBQVMsS0FBQUgsR0FBQWhDO0FBQUFBLFFBQUEsSUFJVyxrREFBWTtBQUFBO0FBQUEsU0FBQTBCLElBQUE7QUFBQTtBQUFBLE1BQ3ZCO0FBQUEsY0FBa0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBREs7QUFBQSxHQUVyQjtBQUFBLFlBQUFVLE1BQUFKLEdBQUFoQztBQUFBQSxRQUFBLElBSVMsa0RBQVk7QUFBQTtBQUFBLFNBQUEwQixJQUFBO0FBQUE7QUFBQSxNQUN2QjtBQUFBLGNBQW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURHO0FBQUEsR0FFckI7QUFBQSxZQUFBVyxJQUFBTCxHQUFBaEM7QUFBQUEsUUFBQXVCLE1BSUo7QUFBQSxJQUNBLGNBQ0s7QUFBQTtBQUFBLEtBQUFDLElBRWlCO0FBQUEsS0FBQVMsSUF4RWxCO0FBQUEsU0F5RVc7QUFBQSxTQUFPO0FBQUE7QUFBQSxTQUFBUCxJQUFBO0FBQUE7QUFBQSxNQUNIO0FBQUEsY0FBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXJDO0FBQUEsR0FBRTtBQUFBLFlBQUFZLEtBQUFOLEdBQUFoQztBQUFBQSxRQUFBdUIsTUFJSjtBQUFBLElBQ0EsY0FDSztBQUFBO0FBQUEsS0FBQUMsSUFFaUI7QUFBQSxLQUFBUyxJQXBGbEI7QUFBQSxTQXFGVztBQUFBLFNBQU87QUFBQTtBQUFBLFNBQUFQLElBQUE7QUFBQTtBQUFBLE1BQ0g7QUFBQSxjQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFdkM7QUFBQSxHQUFFO0FBQUEsWUFBQWEsWUFBQVAsR0FBQVE7QUFBQUEsSUFHdUIsb0RBQXVDO0FBQUE7QUFBQSxZQUFBQyxLQUFBVCxHQUFBTixHQUFBZ0I7QUFBQUE7QUFBQUEsS0FBQUMsUUFHdEQ7QUFBQSxLQUFBQyxRQUNBO0FBQUEsSUFDWjtBQUFBLElBQ0E7QUFBQSxJQUFvQjtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRDFKdEIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjM1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2NoYXIwLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbU3RkbGliLkNoYXJdLiAgW0NoYXIwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW1N0ZGxpYi5DaGFyXSB0aGF0XG4gICBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBjaGFyMC5tbCBzaG91bGQgdXNlIFtTdGRsaWIuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IFN0ZGxpYi5DaGFyLmVzY2FwZWRcbmxldCBsb3dlcmNhc2UgPSBTdGRsaWIuQ2hhci5sb3dlcmNhc2VfYXNjaWlcbmxldCB0b19pbnQgPSBTdGRsaWIuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IFN0ZGxpYi5DaGFyLnVuc2FmZV9jaHJcbmxldCB1cHBlcmNhc2UgPSBTdGRsaWIuQ2hhci51cHBlcmNhc2VfYXNjaWlcblxuKCogV2UgdXNlIG91ciBvd24gcmFuZ2UgdGVzdCB3aGVuIGNvbnZlcnRpbmcgaW50ZWdlcnMgdG8gY2hhcnMgcmF0aGVyIHRoYW5cbiAgIGNhbGxpbmcgW1N0ZGxpYi5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1ByaW50ZiIsIlN0ZGxpYl9DaGFyIiwiZmFpbHdpdGhmIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJpIiwib2ZfaW50Iiwib2ZfaW50X2V4biIsImVxdWFsIiwidDEiLCJ0MiIsIkJhc2VfQ2hhcjAiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsT0FBQTtBQUFBLFlBQUFDLGNBQUE7QUFBQSxPQUFBQyxZQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsUUFBQSxJQ29Ca0I7QUFBQTtBQUFBLEdBQWtCO0FBQUE7QUFBQTtBQUFBLE1BRUg7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUQsR0FDZixnQ0FBaUQ7QUFBQSxZQUFBRSxXQUFBRjtBQUFBQSxJQUc5RCwwQkFFRSw4QkFBNkQ7QUFBQTtBQUFBLFlBQUFHLE1BQUFDLElBQUFDLElBR3pDLHlCQUFnQjtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFUVjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRCakMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9IYXNoX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvbGlzdDAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBbTGlzdDBdIGRlZmluZXMgbGlzdCBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtTdGRsaWIuTGlzdF0uICBbTGlzdDBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZiBbU3RkbGliLkxpc3RdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGxpc3QwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5MaXN0XS5cbiAgIFtMaXN0MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgbGlzdHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkxpc3RdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBMaXN0ID0gTGlzdDBdLiAgRGVmaW5pbmcgW21vZHVsZSBMaXN0ID0gTGlzdDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuTGlzdF0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGhkX2V4biA9IFN0ZGxpYi5MaXN0LmhkXG5sZXQgcmV2X2FwcGVuZCA9IFN0ZGxpYi5MaXN0LnJldl9hcHBlbmRcbmxldCB0bF9leG4gPSBTdGRsaWIuTGlzdC50bFxubGV0IHVuemlwID0gU3RkbGliLkxpc3Quc3BsaXRcblxuKCogU29tZSBvZiB0aGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcblxubGV0IGxlbmd0aCA9XG4gIGxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIHwgW10gLT4gbGVuXG4gICAgfCBfIDo6IGwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuICBpblxuICBmdW4gbCAtPiBsZW5ndGhfYXV4IDAgbFxuOztcblxubGV0IHJlYyBleGlzdHMgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IGZhbHNlXG4gIHwgeCA6OiB4cyAtPiBpZiBmIHggdGhlbiB0cnVlIGVsc2UgZXhpc3RzIHhzIH5mXG47O1xuXG5sZXQgcmVjIGV4aXN0czJfb2sgbDEgbDIgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gZmFsc2VcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gZiBhMSBhMiB8fCBleGlzdHMyX29rIGwxIGwyIH5mXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBpbml0XG4gIHwgYSA6OiBsIC0+IGZvbGQgbCB+aW5pdDooZiBpbml0IGEpIH5mXG47O1xuXG5sZXQgcmVjIGZvbGQyX29rIGwxIGwyIH5pbml0IH4oZiA6IF8gLT4gXyAtPiBfIC0+IF8pID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gaW5pdFxuICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPiBmb2xkMl9vayBsMSBsMiB+ZiB+aW5pdDooZiBpbml0IGExIGEyKVxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoZXhpc3RzIHQgfmY6KGZ1biB4IC0+IG5vdCAoZiB4KSkpXG5cbmxldCByZWMgZm9yX2FsbDJfb2sgbDEgbDIgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPiBmIGExIGEyICYmIGZvcl9hbGwyX29rIGwxIGwyIH5mXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuOztcblxubGV0IHJlYyBpdGVyIHQgfihmIDogXyAtPiBfKSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+ICgpXG4gIHwgYSA6OiBsIC0+XG4gICAgZiBhO1xuICAgIGl0ZXIgbCB+ZlxuOztcblxubGV0IHJlYyBpdGVyMl9vayBsMSBsMiB+KGYgOiBfIC0+IF8gLT4gdW5pdCkgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAoKVxuICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPlxuICAgIGYgYTEgYTI7XG4gICAgaXRlcjJfb2sgbDEgbDIgfmZcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG47O1xuXG5sZXQgcmVjIG5vbnRhaWxfbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT5cbiAgICBsZXQgeSA9IGYgeCBpblxuICAgIHkgOjogbm9udGFpbF9tYXAgeHMgfmZcbjs7XG5cbmxldCBub250YWlsX21hcGkgdCB+ZiA9IFN0ZGxpYi5MaXN0Lm1hcGkgdCB+ZlxubGV0IHBhcnRpdGlvbiB0IH5mID0gU3RkbGliLkxpc3QucGFydGl0aW9uIHQgfmZcblxubGV0IHJldl9tYXAgPVxuICBsZXQgcmVjIHJtYXBfZiBmIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYSA6OiBsIC0+IHJtYXBfZiBmIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBmdW4gbCB+ZiAtPiBybWFwX2YgZiBbXSBsXG47O1xuXG5sZXQgcmV2X21hcDJfb2sgPVxuICBsZXQgcmVjIHJtYXAyX2YgZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IGFjY3VcbiAgICB8IGExIDo6IGwxLCBhMiA6OiBsMiAtPiBybWFwMl9mIGYgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgZnVuIGwxIGwyIH4oZiA6IF8gLT4gXyAtPiBfKSAtPiBybWFwMl9mIGYgW10gbDEgbDJcbjs7XG5cbmxldCByZXYgPSBmdW5jdGlvblxuICB8IChbXSB8IFsgXyBdKSBhcyByZXMgLT4gcmVzXG4gIHwgeCA6OiB5IDo6IHJlc3QgLT4gcmV2X2FwcGVuZCByZXN0IFsgeTsgeCBdXG47O1xuXG5sZXQgZm9sZF9yaWdodCBsIH4oZiA6IF8gLT4gXyAtPiBfKSB+aW5pdCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IGluaXQgKCogYXZvaWQgdGhlIGFsbG9jYXRpb24gb2YgW35mXSBiZWxvdyAqKVxuICB8IF8gLT4gZm9sZCB+ZjooZnVuIGEgYiAtPiBmIGIgYSkgfmluaXQgKHJldiBsKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9yaWdodDJfb2sgbDEgbDIgfihmIDogXyAtPiBfIC0+IF8gLT4gXykgfmluaXQgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfLCBfIC0+IGZvbGQyX29rIH5mOihmdW4gYSBiIGMgLT4gZiBiIGMgYSkgfmluaXQgKHJldiBsMSkgKHJldiBsMikgW0Bub250YWlsXVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiY3N0X0xpc3RfZm9sZF9sZWZ0MiIsIkJhc2VfSW1wb3J0MCIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiaGRfZXhuIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiY3N0X0xpc3RfZXhpc3RzMiIsImNzdF9MaXN0X2Zvcl9hbGwyIiwiY3N0X0xpc3RfaXRlcjIiLCJjc3RfTGlzdF9yZXZfbWFwMiIsImxlbmd0aCIsImwiLCJsZW4iLCJwYXJhbSIsImV4aXN0cyIsInQiLCJ4cyIsIngiLCJleGlzdHMyX29rIiwibDEiLCJsMiIsImZvbGQiLCJpbml0IiwiYSIsImZvbGQyX29rIiwiZm9yX2FsbCIsImZvcl9hbGwyX29rIiwiaXRlciIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJ5Iiwibm9udGFpbF9tYXBpIiwicGFydGl0aW9uIiwicmV2X21hcCIsImFjY3UiLCJyZXZfbWFwMl9vayIsInJldiIsInJlcyIsIm1hdGNoIiwicmVzdCIsImZvbGRfcmlnaHQiLCJmb2xkX3JpZ2h0Ml9vayIsIkJhc2VfTGlzdDAiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FB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LFFBQUFQLElBQ2dDLFFBQUFPLFNBQU8sTUFBQVAsTUFBQTtBQUFBO0FBQUEsS0EzRS9DLFVBQ1E7QUFBQSxTQUFBSixNQURSLFFBQUFZLElBQUEsUUFBQUQsU0EyRTJCO0FBQUEsS0F6RVE7QUFBQTtBQUFBO0FBQUEsR0F5RXVCO0FBQUEsWUFBQW1CLGVBQUF0QixJQUFBQyxJQUFBNUIsR0FBQThCO0FBQUFBLElBSTFELGlCQUNZO0FBQUE7QUFBQSxLQUFBRixPQUNnRDtBQUFBLEtBQUFELE9BQVQ7QUFBQSxLQUFBRyxTQUFRO0FBQUEsS0FBQUYsT0FBQTtBQUFBLEtBQUFELE9BQUE7QUFBQTtBQUFBLEtBM0UzRDtBQUFBO0FBQUE7QUFBQSxRQUFBQyxPQUFBO0FBQUEsUUFBQXZCLEtBQUE7QUFBQSxRQUFBc0IsT0FBQTtBQUFBLFFBQUF4QixLQUFBO0FBQUEsUUFBQTJCLFNBMkVvQztBQUFBLE9BekUwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFEbEQ7QUFBQSxLQUVGLHdEQXdFcUU7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBb0I7QUFBQUEsTUFqQi9FO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEeEdGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTU3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9oYXNoLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAgIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB0aGUgcnVudGltZSBzdXBwb3J0IGZvciBbcHB4X2hhc2hdLlxuXG4gICBUaGUgW3BweF9oYXNoXSBzeW50YXggZXh0ZW5zaW9uIHN1cHBvcnRzOiBbQEBkZXJpdmluZyBoYXNoXSBhbmQgWyVoYXNoX2ZvbGQ6IFRZUEVdIGFuZFxuICAgWyVoYXNoOiBUWVBFXVxuXG4gICBGb3IgdHlwZSBbdF0gYSBmdW5jdGlvbiBbaGFzaF9mb2xkX3RdIG9mIHR5cGUgW0hhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlXSBpc1xuICAgZ2VuZXJhdGVkLlxuXG4gICBUaGUgZ2VuZXJhdGVkIFtoYXNoX2ZvbGRfPFQ+XSBmdW5jdGlvbiBpcyBjb21wb3NpdGlvbmFsLCBmb2xsb3dpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgIHR5cGU7IGFsbG93aW5nIHVzZXIgb3ZlcnJpZGVzIGF0IGV2ZXJ5IGxldmVsLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIG9jYW1sJ3MgYnVpbHRpblxuICAgcG9seW1vcnBoaWMgaGFzaGluZyBbSGFzaHRibC5oYXNoXSB3aGljaCBpZ25vcmVzIHVzZXIgb3ZlcnJpZGVzLlxuXG4gICBUaGUgZ2VuZXJhdG9yIGFsc28gcHJvdmlkZXMgYSBkaXJlY3QgaGFzaC1mdW5jdGlvbiBbaGFzaF0gKG5hbWVkIFtoYXNoXzxUPl0gd2hlbiA8VD4gIT1cbiAgIFwidFwiKSBvZiB0eXBlOiBbdCAtPiBIYXNoLmhhc2hfdmFsdWVdLlxuXG4gICBUaGUgZm9sZGluZyBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2hfZm9sZDogVFlQRV1cbiAgIFRoZSBkaXJlY3QgaGFzaCBmdW5jdGlvbiBjYW4gYmUgYWNjZXNzZWQgYXMgWyVoYXNoOiBUWVBFXVxuKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBIYXNoX2ludGZcblxuKCoqIEJ1aWx0aW4gZm9sZGluZy1zdHlsZSBoYXNoIGZ1bmN0aW9ucywgYWJzdHJhY3RlZCBvdmVyIFtIYXNoX2ludGYuU10gKilcbm1vZHVsZSBGb2xkaW5nIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkJ1aWx0aW5faW50ZlxuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZSA9IHN0cnVjdFxuICB0eXBlIHN0YXRlID0gSGFzaC5zdGF0ZVxuICB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWVcbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBoYXNoX2ZvbGRfdW5pdCBzICgpID0gc1xuICBsZXQgaGFzaF9mb2xkX2ludCA9IEhhc2guZm9sZF9pbnRcbiAgbGV0IGhhc2hfZm9sZF9pbnQ2NCA9IEhhc2guZm9sZF9pbnQ2NFxuICBsZXQgaGFzaF9mb2xkX2Zsb2F0ID0gSGFzaC5mb2xkX2Zsb2F0XG4gIGxldCBoYXNoX2ZvbGRfc3RyaW5nID0gSGFzaC5mb2xkX3N0cmluZ1xuICBsZXQgYXNfaW50IGYgcyB4ID0gaGFzaF9mb2xkX2ludCBzIChmIHgpXG5cbiAgKCogVGhpcyBpZ25vcmVzIHRoZSBzaWduIGJpdCBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgdW5saWtlbHkgdG8gbGVhZCB0b1xuICAgICBmcmVxdWVudCBjb2xsaXNpb25zIChtaW5fdmFsdWUgY29sbGlkaW5nIHdpdGggMCBpcyB0aGUgbW9zdCBsaWtlbHkgb25lKS4gICopXG4gIGxldCBoYXNoX2ZvbGRfaW50MzIgPSBhc19pbnQgU3RkbGliLkludDMyLnRvX2ludFxuICBsZXQgaGFzaF9mb2xkX2NoYXIgPSBhc19pbnQgQ2hhci50b19pbnRcblxuICBsZXQgaGFzaF9mb2xkX2Jvb2wgPVxuICAgIGFzX2ludCAoZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiAxXG4gICAgICB8IGZhbHNlIC0+IDApXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9uYXRpdmVpbnQgcyB4ID0gaGFzaF9mb2xkX2ludDY0IHMgKFN0ZGxpYi5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoU3RkbGliLkxhenkuZm9yY2UgeClcbiAgbGV0IGhhc2hfZm9sZF9yZWZfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgeCA9IGhhc2hfZm9sZF9lbGVtIHMgIXhcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSBzIGFycmF5IGkgPVxuICAgIGlmIGkgPSBBcnJheS5sZW5ndGggYXJyYXlcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBlID0gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpIGluXG4gICAgICBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9lbGVtIHMgZSkgYXJyYXkgKGkgKyAxKSlcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2FycmF5X2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIGFycmF5ID1cbiAgICBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2lcbiAgICAgICgqIFtsZW5ndGhdIG11c3QgYmUgaW5jb3Jwb3JhdGVkIGZvciBhcnJheXMsIGFzIGl0IGlzIGZvciBsaXN0cy4gU2VlIGNvbW1lbnQgYWJvdmUgKilcbiAgICAgIGhhc2hfZm9sZF9lbGVtXG4gICAgICAoaGFzaF9mb2xkX2ludCBzIChBcnJheS5sZW5ndGggYXJyYXkpKVxuICAgICAgYXJyYXlcbiAgICAgIDBcbiAgOztcblxuICAoKiB0aGUgZHVwbGljYXRpb24gaGVyZSBpcyBiZWNhdXNlIHdlIHRoaW5rXG4gICAgIG9jYW1sIGNhbid0IGVsaW1pbmF0ZSBpbmRpcmVjdCBmdW5jdGlvbiBjYWxscyBvdGhlcndpc2UuICopXG4gIGxldCBoYXNoX25hdGl2ZWludCB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfbmF0aXZlaW50IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcblxuICBsZXQgaGFzaF9pbnQ2NCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDY0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfaW50MzIgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQzMiAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2NoYXIgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9jaGFyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfaW50IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfYm9vbCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2Jvb2wgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuXG4gIGxldCBoYXNoX3N0cmluZyB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfc3RyaW5nIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcblxuICBsZXQgaGFzaF9mbG9hdCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2Zsb2F0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfdW5pdCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3VuaXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuZW5kXG5cbm1vZHVsZSBGIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkZ1bGxcbiAgICB3aXRoIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICAgICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEhhc2guc2VlZCA9IHN0cnVjdFxuICBpbmNsdWRlIEhhc2hcblxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGNyZWF0ZSA/c2VlZCAoKSA9IHJlc2V0ID9zZWVkIChhbGxvYyAoKSlcbiAgbGV0IG9mX2ZvbGQgaGFzaF9mb2xkX3QgdCA9IGdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdCAoY3JlYXRlICgpKSB0KVxuXG4gIG1vZHVsZSBCdWlsdGluID0gRm9sZGluZyAoSGFzaClcblxuICBsZXQgcnVuID9zZWVkIGZvbGRlciB4ID1cbiAgICBIYXNoLmdldF9oYXNoX3ZhbHVlIChmb2xkZXIgKEhhc2gucmVzZXQgP3NlZWQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBJbnRlcm5hbGhhc2ggOiBzaWdcbiAgaW5jbHVkZVxuICAgIEhhc2hfaW50Zi5TXG4gICAgICB3aXRoIHR5cGUgc3RhdGUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zdGF0ZVxuICAgICAgKCogV2UgZ2l2ZSBhIGNvbmNyZXRlIHR5cGUgZm9yIFtzdGF0ZV0sIGFsYmVpdCBvbmx5IHBhcnRpYWxseSBleHBvc2VkIChzZWVcbiAgICAgICAgQmFzZV9pbnRlcm5hbGhhc2hfdHlwZXMpLCBzbyB0aGF0IGl0IHVuaWZpZXMgd2l0aCB0aGUgc2FtZSB0eXBlIGluIFtCYXNlX2Jvb3RdLFxuICAgICAgICBhbmQgdG8gYWxsb3cgb3B0aW1pemF0aW9ucyBmb3IgdGhlIGltbWVkaWF0ZSB0eXBlLiAqKVxuICAgICAgIGFuZCB0eXBlIHNlZWQgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zZWVkXG4gICAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0XG4gICAgOiAgc3RhdGVcbiAgICAtPiAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IHN0YXRlXG4gICAgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIiBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX2ludCA6IHN0YXRlIC0+IGludCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfZmxvYXRcbiAgICA6ICBzdGF0ZVxuICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgLT4gc3RhdGVcbiAgICA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFwiIFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfc3RyaW5nIDogc3RhdGUgLT4gc3RyaW5nIC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX3N0cmluZ1wiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBnZXRfaGFzaF92YWx1ZSA6IHN0YXRlIC0+IGhhc2hfdmFsdWUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXCJcbiAgICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0XG4gICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgLT4gaW50XG4gICAgICA9IFwiQmFzZV9oYXNoX2RvdWJsZVwiIFwiQmFzZV9oYXNoX2RvdWJsZV91bmJveGVkXCJcbiAgICAgIFtAQG5vYWxsb2NdXG5cbiAgICBsZXQgaGFzaF91bml0ICgpID0gMFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIFRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiZGVzY3JpcHRpb24iLCJCYXNlX0ltcG9ydDAiLCJCYXNlX0ludDAiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9MaXN0MCIsIkJhc2VfQ2hhcjAiLCJGb2xkaW5nIiwiSGFzaCIsImhhc2hfZm9sZF91bml0IiwicyIsInBhcmFtIiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJoYXNoX2ZvbGRfaW50MzIiLCJ4IiwiaGFzaF9mb2xkX2NoYXIiLCJoYXNoX2ZvbGRfYm9vbCIsImhhc2hfZm9sZF9uYXRpdmVpbnQiLCJoYXNoX2ZvbGRfb3B0aW9uIiwiaGFzaF9mb2xkX2VsZW0iLCJoYXNoX2ZvbGRfbGlzdCIsImxpc3QiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiYXJyYXkiLCJpIiwiZSIsImhhc2hfbmF0aXZlaW50IiwiaGFzaF9pbnQ2NCIsImhhc2hfaW50MzIiLCJoYXNoX2NoYXIiLCJoYXNoX2ludCIsImhhc2hfYm9vbCIsImhhc2hfc3RyaW5nIiwiaGFzaF9mbG9hdCIsImhhc2hfdW5pdCIsIkYiLCJmb2xkX2ludCIsImZvbGRfaW50NjQiLCJmb2xkX2Zsb2F0IiwiZm9sZF9zdHJpbmciLCJhbGxvYyIsInJlc2V0IiwiZ2V0X2hhc2hfdmFsdWUiLCJGb3JfdGVzdHMiLCJjcmVhdGUiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwidCIsIkJ1aWx0aW4iLCJydW4iLCJmb2xkZXIiLCJvcHQiLCJjb21wYXJlX3N0YXRlIiwic3RhdGVfdG9fc3RyaW5nIiwic3RhdGUiLCJCYXNlX0hhc2giXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMsUUFBQUM7QUFBQUEsYUFBQUMsZUFBQUMsR0FBQUMsT0NvQzRCLFNBQUM7QUFBQTtBQUFBLEtBQUFDLGdCRHBDN0I7QUFBQSxLQUFBQyxrQkFBQTtBQUFBLEtBQUFDLGtCQUFBO0FBQUEsS0FBQUMsbUJBQUE7QUFBQSxhQUFBQyxnQkFBQU4sR0FBQU8sR0N5QzBDO0FBQUEsUUFBQXJCLElBSVE7QUFBQSxhQUFBc0IsZUFBQVIsR0FBQU8sR0FKYixPQUFLLDZCQUFMLEtBQUs7QUFBQSxhQUFBRSxlQUFBVCxHQUFBTztBQUFBQSxTQUFBLElBUS9CO0FBQUEsS0FSK0I7QUFBQTtBQUFBLGFBQUFHLG9CQUFBVixHQUFBTztBQUFBQSxLQWFRLE9BQTZCLCtCQUE3QiwrQkFBNkI7QUFBQTtBQUFBLGFBQUFJLGlCQUFBQyxnQkFBQVosR0FBQUM7QUFBQUEsS0FFeEQsWUFDVCxzQ0FDc0M7QUFBQSxTQUFBTSxJQUY3QjtBQUFBLEtBRVEsT0FBbUIsMkJBQW5CLG1DQUFxQjtBQUFBO0FBQUEsYUFBQU0sZUFBQUQsZ0JBQUFaLEtBQUFjO0FBQUFBO0FBQUFBLE1BQUFkLE1BY3hDLCtCQUFnQjtBQUFBLE1BQUFBLElBQ2hCO0FBQUEsTUFBQWMsT0FBQTtBQUFBO0FBQUEsTUFYUixXQVlBO0FBQUE7QUFBQSxPQUFBQSxTQVpBO0FBQUEsT0FBQVAsSUFB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QkFBa0I7QUFBQSxZQUFBc0IsVUFBQTVCLE9BUWpCLFNBQUM7QUFBQTtBQUFBLElBQUFrRDtBQUFBQSxNRHRPeEIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxOTAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3BweF9jb21wYXJlX2xpYi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4gSW1wb3J0MFxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgY29tcGFyZV9fbG9jYWwgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG50eXBlICdhIGVxdWFsX19sb2NhbCA9ICdhIC0+ICdhIC0+IGJvb2xcblxubW9kdWxlIENvbXBhcmFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICgnYSwgJ2IpIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgY29tcGFyZSAtPiAnYiBjb21wYXJlIC0+ICdjIGNvbXBhcmUgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWwgOiB0IGNvbXBhcmVfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWwgOiAnYSBjb21wYXJlX19sb2NhbCAtPiAnYSB0IGNvbXBhcmVfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZV9fbG9jYWxcbiAgICAgIDogICdhIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAnYiBjb21wYXJlX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYikgdCBjb21wYXJlX19sb2NhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wYXJlX19sb2NhbFxuICAgICAgOiAgJ2EgY29tcGFyZV9fbG9jYWxcbiAgICAgIC0+ICdiIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAnYyBjb21wYXJlX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHQgY29tcGFyZV9fbG9jYWxcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWxfX2xvY2FsIDogdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbF9fbG9jYWwgOiAnYSBlcXVhbF9fbG9jYWwgLT4gJ2EgdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbF9fbG9jYWwgOiAnYSBlcXVhbF9fbG9jYWwgLT4gJ2IgZXF1YWxfX2xvY2FsIC0+ICgnYSwgJ2IpIHQgZXF1YWxfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGVxdWFsX19sb2NhbFxuICAgICAgOiAgJ2EgZXF1YWxfX2xvY2FsXG4gICAgICAtPiAnYiBlcXVhbF9fbG9jYWxcbiAgICAgIC0+ICdjIGVxdWFsX19sb2NhbFxuICAgICAgLT4gKCdhLCAnYiwgJ2MpIHQgZXF1YWxfX2xvY2FsXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gIGxldCBjb21wYXJlX2Jvb2wgOiBib29sIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfYm9vbF9fbG9jYWwgOiBib29sIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfY2hhcl9fbG9jYWwgOiBjaGFyIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2Zsb2F0IDogZmxvYXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9mbG9hdF9fbG9jYWwgOiBmbG9hdCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQgOiBpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnRfX2xvY2FsIDogaW50IGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQzMl9fbG9jYWwgOiBpbnQzMiBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50NjRfX2xvY2FsIDogaW50NjQgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50X19sb2NhbCA6IG5hdGl2ZWludCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9zdHJpbmcgOiBzdHJpbmcgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9zdHJpbmdfX2xvY2FsIDogc3RyaW5nIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2J5dGVzIDogYnl0ZXMgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9ieXRlc19fbG9jYWwgOiBieXRlcyBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV91bml0IDogdW5pdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3VuaXRfX2xvY2FsIDogdW5pdCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5X19sb2NhbCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIGlmIHBoeXNfZXF1YWwgYSBiXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICAgIGlmIHJldCA8PiAwXG4gICAgICB0aGVuIHJldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgICB0aGVuIDBcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgMCBbQG5vbnRhaWxdKSlcbiAgOztcblxuICBsZXQgY29tcGFyZV9hcnJheSBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX2FycmF5X19sb2NhbCBjb21wYXJlX2VsdCBhIGJcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCByZWMgY29tcGFyZV9saXN0X19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiAwXG4gICAgfCBbXSwgXyAtPiAtMVxuICAgIHwgXywgW10gLT4gMVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0X19sb2NhbCB4IHkgaW5cbiAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0X19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgeHMgeXNcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfb3B0aW9uX19sb2NhbCBjb21wYXJlX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHRfX2xvY2FsIGEgYlxuICA7O1xuXG4gIGxldCBjb21wYXJlX3JlZiBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX2VsdCAhYSAhYlxuICBsZXQgY29tcGFyZV9yZWZfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfZWx0ICFhICFiXG4gIGxldCBlcXVhbF9ib29sIDogYm9vbCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2Jvb2xfX2xvY2FsIDogYm9vbCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9jaGFyIDogY2hhciBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2NoYXJfX2xvY2FsIDogY2hhciBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnRfX2xvY2FsIDogaW50IGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDMyIDogaW50MzIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMl9fbG9jYWwgOiBpbnQzMiBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQ2NCA6IGludDY0IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjRfX2xvY2FsIDogaW50NjQgZXF1YWxfX2xvY2FsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfbmF0aXZlaW50IDogbmF0aXZlaW50IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfbmF0aXZlaW50X19sb2NhbCA6IG5hdGl2ZWludCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmcgOiBzdHJpbmcgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmdfX2xvY2FsIDogc3RyaW5nIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2J5dGVzIDogYnl0ZXMgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9ieXRlc19fbG9jYWwgOiBieXRlcyBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF91bml0IDogdW5pdCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXRfX2xvY2FsIDogdW5pdCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG5cbiAgKCogW1BvbHkuZXF1YWxdIGlzIElFRUUgY29tcGxpYW50LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50IGhlcmUuICopXG4gIGxldCBlcXVhbF9mbG9hdCB4IHkgPSBlcXVhbF9pbnQgKGNvbXBhcmVfZmxvYXQgeCB5KSAwXG4gIGxldCBlcXVhbF9mbG9hdF9fbG9jYWwgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0X19sb2NhbCB4IHkpIDBcblxuICBsZXQgZXF1YWxfYXJyYXlfX2xvY2FsIGVxdWFsX2VsdCBhIGIgPVxuICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgfHxcbiAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICBsZXQgbGVuX2IgPSBBcnJheTAubGVuZ3RoIGIgaW5cbiAgICBlcXVhbCBsZW5fYSBsZW5fYlxuICAgICYmXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaSA9IGxlbl9hXG4gICAgICB8fFxuICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICBlcXVhbF9lbHQgbCByICYmIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZXF1YWxfYXJyYXkgZXF1YWxfZWx0IGEgYiA9IGVxdWFsX2FycmF5X19sb2NhbCBlcXVhbF9lbHQgYSBiXG5cbiAgbGV0IHJlYyBlcXVhbF9saXN0IGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFtdLCBfIHwgXywgW10gLT4gZmFsc2VcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT4gZXF1YWxfZWx0IHggeSAmJiBlcXVhbF9saXN0IGVxdWFsX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdF9fbG9jYWwgZXF1YWxfZWx0X19sb2NhbCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFtdLCBfIHwgXywgW10gLT4gZmFsc2VcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT4gZXF1YWxfZWx0X19sb2NhbCB4IHkgJiYgZXF1YWxfbGlzdF9fbG9jYWwgZXF1YWxfZWx0X19sb2NhbCB4cyB5c1xuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgICB8IE5vbmUsIFNvbWUgXyB8IFNvbWUgXywgTm9uZSAtPiBmYWxzZVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gZXF1YWxfZWx0IGEgYlxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb25fX2xvY2FsIGVxdWFsX2VsdF9fbG9jYWwgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgIHwgTm9uZSwgU29tZSBfIHwgU29tZSBfLCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBlcXVhbF9lbHRfX2xvY2FsIGEgYlxuICA7O1xuXG4gIGxldCBlcXVhbF9yZWYgZXF1YWxfZWx0IGEgYiA9IGVxdWFsX2VsdCAhYSAhYlxuICBsZXQgZXF1YWxfcmVmX19sb2NhbCBlcXVhbF9lbHQgYSBiID0gZXF1YWxfZWx0ICFhICFiXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3doaWNoX2lzX2Fic3RyYWN0X2luX2FuX2ltIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfZXF1YWwiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQwIiwiQmFzZV9QcmludGYiLCJjb21wYXJlX2Fic3RyYWN0IiwidHlwZV9uYW1lIiwicGFyYW0iLCJlcXVhbF9hYnN0cmFjdCIsIkNvbXBhcmFibGUiLCJFcXVhbCIsImNvbXBhcmVfYm9vbCIsImNvbXBhcmVfYm9vbF9sb2NhbCIsImNvbXBhcmVfY2hhciIsImNvbXBhcmVfY2hhcl9sb2NhbCIsImNvbXBhcmVfZmxvYXQiLCJjb21wYXJlX2Zsb2F0X2xvY2FsIiwiY29tcGFyZV9pbnQiLCJjb21wYXJlX2ludF9sb2NhbCIsImNvbXBhcmVfaW50MzIiLCJjb21wYXJlX2ludDMyX2xvY2FsIiwiY29tcGFyZV9pbnQ2NCIsImNvbXBhcmVfaW50NjRfbG9jYWwiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfbmF0aXZlaW50X2xvY2FsIiwiY29tcGFyZV9zdHJpbmciLCJjb21wYXJlX3N0cmluZ19sb2NhbCIsImNvbXBhcmVfYnl0ZXMiLCJjb21wYXJlX2J5dGVzX2xvY2FsIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV91bml0X2xvY2FsIiwiY29tcGFyZV9hcnJheV9sb2NhbCIsImNvbXBhcmVfZWx0IiwiYSIsImIiLCJsZW5fYSIsImxlbl9iIiwicmV0IiwiaSIsImwiLCJyIiwicmVzIiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfbGlzdCIsInlzIiwieSIsInhzIiwieCIsImNvbXBhcmVfbGlzdF9sb2NhbCIsImNvbXBhcmVfZWx0X2xvY2FsIiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX29wdGlvbl9sb2NhbCIsImNvbXBhcmVfcmVmIiwiY29tcGFyZV9yZWZfbG9jYWwiLCJlcXVhbF9ib29sIiwiZXF1YWxfYm9vbF9sb2NhbCIsImVxdWFsX2NoYXIiLCJlcXVhbF9jaGFyX2xvY2FsIiwiZXF1YWxfaW50IiwiZXF1YWxfaW50X2xvY2FsIiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQzMl9sb2NhbCIsImVxdWFsX2ludDY0IiwiZXF1YWxfaW50NjRfbG9jYWwiLCJlcXVhbF9uYXRpdmVpbnQiLCJlcXVhbF9uYXRpdmVpbnRfbG9jYWwiLCJlcXVhbF9zdHJpbmciLCJlcXVhbF9zdHJpbmdfbG9jYWwiLCJlcXVhbF9ieXRlcyIsImVxdWFsX2J5dGVzX2xvY2FsIiwiZXF1YWxfdW5pdCIsImVxdWFsX3VuaXRfbG9jYWwiLCJlcXVhbF9mbG9hdCIsImVxdWFsX2Zsb2F0X2xvY2FsIiwiZXF1YWxfYXJyYXlfbG9jYWwiLCJlcXVhbF9lbHQiLCJlcXVhbF9hcnJheSIsImVxdWFsX2xpc3QiLCJlcXVhbF9saXN0X2xvY2FsIiwiZXF1YWxfZWx0X2xvY2FsIiwiZXF1YWxfb3B0aW9uIiwiZXF1YWxfb3B0aW9uX2xvY2FsIiwiZXF1YWxfcmVmIiwiZXF1YWxfcmVmX2xvY2FsIiwiQmFzZV9QcHhfY29tcGFyZV9saWIiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxpQkFBQUMsV0FBQSxHQUFBQztBQUFBQSxJQ0dFO0FBQUEsd0VBR1c7QUFBQTtBQUFBLFlBQUFDLGVBQUFGLFdBQUEsR0FBQUM7QUFBQUEsSUFJWDtBQUFBLHdFQUdXO0FBQUE7QUFBQTtBQUFBLElBQUFFLGFEYmI7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxjQUFBO0FBQUEsWUFBQUMsb0JBQUE7QUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLFlBQUFDLG9CQUFBQyxhQUFBQyxHQUFBQztBQUFBQSxJQzJKSSxZQUNLO0FBQUE7QUFBQSxLQUFBQyxRQUNBO0FBQUEsS0FBQUMsUUFFSDtBQUFBLEtBQUFDLE1BQ0E7QUFBQSxJQUNBLGNBQ0s7QUFBQSxRQUFBQyxJQVdIO0FBQUE7QUFBQSxLQVJFLGdCQUNLO0FBQUEsU0FBQUMsSUFFSyxVQUFBQyxJQUNBLFVBQUFDLE1BQ0U7QUFBQSxLQUNWLGNBQWlCO0FBQUEsU0FBQUgsTUFBYztBQUFBLEtBQU87QUFBQTtBQUFBLEdBRXZCO0FBQUEsWUFBQUksY0FBQVYsYUFBQUMsR0FBQUM7QUFBQUEsSUFHVyw2Q0FBb0M7QUFBQTtBQUFBLFlBQUFTLGFBQUFYLGFBQUFDLEtBQUFDO0FBQUFBLFFBQUFELElBR3RFLEtBQUFDLElBQUE7QUFBQTtBQUFBLDhCQU0wRDtBQUFBLEtBTjFELFFBR1c7QUFBQTtBQUFBLE1BQUFVLEtBSFg7QUFBQSxNQUFBQyxJQUFBO0FBQUEsTUFBQUMsS0FBQTtBQUFBLE1BQUFDLElBQUE7QUFBQSxNQUFBTixNQUtZO0FBQUEsS0FDVixjQUFpQjtBQUFBLEtBQWpCO0FBQUE7QUFBQTtBQUFBLEdBQXdEO0FBQUEsWUFBQU8sbUJBQUFDLG1CQUFBaEIsS0FBQUM7QUFBQUEsUUFBQUQsSUFJMUQsS0FBQUMsSUFBQTtBQUFBO0FBQUEsOEJBTXdFO0FBQUEsS0FOeEUsUUFHVztBQUFBO0FBQUEsTUFBQVUsS0FIWDtBQUFBLE1BQUFDLElBQUE7QUFBQSxNQUFBQyxLQUFBO0FBQUEsTUFBQUMsSUFBQTtBQUFBLE1BQUFOLE1BS1k7QUFBQSxLQUNWLGNBQWlCO0FBQUEsS0FBakI7QUFBQTtBQUFBO0FBQUEsR0FBc0U7QUFBQSxZQUFBUyxlQUFBbEIsYUFBQUMsR0FBQUM7QUFBQUEsSUFJeEUseUJBSW1DO0FBQUEsUUFBQUQsTUFKbkM7QUFBQSxZQUdrQjtBQUFBLFFBQUFDLE1BSGxCO0FBQUEsSUFJb0Isd0NBQWU7QUFBQTtBQUFBLFlBQUFpQixxQkFBQUYsbUJBQUFoQixHQUFBQztBQUFBQSxJQUluQyx5QkFJMEM7QUFBQSxRQUFBRCxNQUoxQztBQUFBLFlBR2tCO0FBQUEsUUFBQUMsTUFIbEI7QUFBQSxJQUlvQiw4Q0FBc0I7QUFBQTtBQUFBLFlBQUFrQixZQUFBcEIsYUFBQUMsR0FBQUM7QUFBQUEsSUFHViwwQ0FBaUI7QUFBQTtBQUFBLFlBQUFtQixrQkFBQXJCLGFBQUFDLEdBQUFDLEdBQ1YsMENBQWlCO0FBQUE7QUFBQSxZQUFBb0IsV0FBQSxNRHZONUQ7QUFBQSxZQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFdBQUE7QUFBQSxZQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFVBQUE7QUFBQSxZQUFBQyxnQkFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLFdBQUE7QUFBQSxZQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFlBQUF6QixHQUFBRixHQzRPa0MsNkNBQW1CLENBQUU7QUFBQSxZQUFBNEIsa0JBQUExQixHQUFBRjtBQUFBQSxJQUNkLDZDQUEwQjtBQUFBLEdBQUU7QUFBQSxZQUFBNkIsa0JBQUFDLFdBQUExQyxHQUFBQztBQUFBQSxRQUFBLElBR2pFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUFBQyxRQUFBO0FBQUEsTUFBQUMsUUFHQTtBQUFBLFVBQ0E7QUFBQTtBQUFBLFVBQUFFLElBU0E7QUFBQTtBQUFBLGVBTkU7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxJQUVRLFVBQUFDLElBQ0EsY0FDUjtBQUFBLFFBQWEsVUFBQUYsTUFBUyxtQ0FBTztBQUFBLGdCQUFoQjtBQUFBO0FBQUEsT0FKYjtBQUFBO0FBQUE7QUFBQSxhQUhGO0FBQUE7QUFBQSxJQUpBO0FBQUEsR0FhaUI7QUFBQSxZQUFBc0MsWUFBQUQsV0FBQTFDLEdBQUFDO0FBQUFBLElBR2EseUNBQWdDO0FBQUE7QUFBQSxZQUFBMkMsV0FBQUYsV0FBQTFDLEtBQUFDO0FBQUFBLFFBQUFELElBRzlELEtBQUFDLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUFVLEtBQUE7QUFBQSxRQUFBQyxJQUFBO0FBQUEsUUFBQUMsS0FBQTtBQUFBLFFBQUFDLElBQUE7QUFBQSxZQUdzQjtBQUFBLE9BQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBRnZCO0FBQUEsS0FDTztBQUFBO0FBQUEsR0FDOEM7QUFBQSxZQUFBK0IsaUJBQUFDLGlCQUFBOUMsS0FBQUM7QUFBQUEsUUFBQUQsSUFJakUsS0FBQUMsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFBQVUsS0FBQTtBQUFBLFFBQUFDLElBQUE7QUFBQSxRQUFBQyxLQUFBO0FBQUEsUUFBQUMsSUFBQTtBQUFBLFlBR3NCO0FBQUEsT0FBb0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBRjlCO0FBQUEsS0FDTztBQUFBO0FBQUEsR0FDbUU7QUFBQSxZQUFBaUMsYUFBQUwsV0FBQTFDLEdBQUFDO0FBQUFBLElBSXRGO0FBQUE7QUFBQSxVQUFBQSxNQUFBLE1BQUFELE1BQUE7QUFBQSxNQUdvQixzQ0FBYTtBQUFBO0FBQUE7QUFBQSxpQkFGakI7QUFBQSxJQUNpQjtBQUFBLEdBQ0E7QUFBQSxZQUFBZ0QsbUJBQUFGLGlCQUFBOUMsR0FBQUM7QUFBQUEsSUFJakM7QUFBQTtBQUFBLFVBQUFBLE1BQUEsTUFBQUQsTUFBQTtBQUFBLE1BR29CLDRDQUFvQjtBQUFBO0FBQUE7QUFBQSxpQkFGeEI7QUFBQSxJQUNpQjtBQUFBLEdBQ087QUFBQSxZQUFBaUQsVUFBQVAsV0FBQTFDLEdBQUFDO0FBQUFBLElBR1osd0NBQWU7QUFBQTtBQUFBLFlBQUFpRCxnQkFBQVIsV0FBQTFDLEdBQUFDO0FBQUFBLElBQ1Isd0NBQWU7QUFBQTtBQUFBO0FBQUEsSUFBQWtEO0FBQUFBLE1EL1J0RCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJTdGQiLCJIYXNoYWJsZSIsIkJhc2VfUHB4X2hhc2hfbGliIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsb0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMjUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3NleHAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIEdsb2JhbGl6ZVxub3BlbiBIYXNoLkJ1aWx0aW5cbm9wZW4gUHB4X2NvbXBhcmVfbGliLkJ1aWx0aW5cbmluY2x1ZGUgU2V4cGxpYjAuU2V4cFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPSBTZXhwbGliMC5TZXhwLnQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoXVxuXG5sZXQgcmVjIGNvbXBhcmVfX2xvY2FsID1cbiAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZ19fbG9jYWwgX2FfXzAwM18gX2JfXzAwNF9cbiAgICAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICAgICB8IExpc3QgX2FfXzAwNV8sIExpc3QgX2JfXzAwNl8gLT5cbiAgICAgICAgIGNvbXBhcmVfbGlzdF9fbG9jYWwgY29tcGFyZV9fbG9jYWwgX2FfXzAwNV8gX2JfXzAwNl8pXG4gICAgOiB0IC0+IHQgLT4gaW50KVxuOztcblxubGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgcmVjIChnbG9iYWxpemUgOiB0IC0+IHQpID1cbiAgKGZ1biB4X18wMDlfIC0+XG4gICAgIG1hdGNoIHhfXzAwOV8gd2l0aFxuICAgICB8IEF0b20gYXJnX18wMTBfIC0+IEF0b20gKGdsb2JhbGl6ZV9zdHJpbmcgYXJnX18wMTBfKVxuICAgICB8IExpc3QgYXJnX18wMTFfIC0+IExpc3QgKGdsb2JhbGl6ZV9saXN0IGdsb2JhbGl6ZSBhcmdfXzAxMV8pXG4gICAgOiB0IC0+IHQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGVxdWFsX19sb2NhbCBhIGIgPSBjb21wYXJlX19sb2NhbCBhIGIgPSAwXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfUHB4X2NvbXBhcmVfbGliIiwiQmFzZV9HbG9iYWxpemUiLCJCYXNlX0hhc2giLCJTZXhwbGliMF9TZXhwIiwiU2V4cGxpYjBfU2V4cF9jb252IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiZXF1YWwiLCJOb3RfZm91bmRfcyIsIk9mX3NleHBfZXJyb3IiLCJtZXNzYWdlIiwiZGVmYXVsdF9pbmRlbnQiLCJwcF9odW0iLCJwcF9odW1faW5kZW50IiwicHBfbWFjaCIsInBwIiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZ19tYWNoIiwidG9fc3RyaW5nIiwib2ZfZmxvYXRfc3R5bGUiLCJvZl9pbnRfc3R5bGUiLCJQcml2YXRlIiwiY29tcGFyZV9sb2NhbCIsImFfMDAxIiwiYl8wMDIiLCJhXzAwMyIsImJfMDA0IiwiYV8wMDUiLCJiXzAwNiIsImNvbXBhcmUiLCJhIiwiYiIsImdsb2JhbGl6ZSIsInhfMDA5IiwiYXJnXzAxMCIsImFyZ18wMTEiLCJsZXRyZWNfZnVuY3Rpb25fY29udGV4dCIsImhhc2hfZm9sZF90IiwiaHN2IiwiYXJnIiwiaGFzaCIsIngiLCJmdW5jIiwidF9zZXhwX2dyYW1tYXIiLCJpbnZhcmlhbnQiLCJwYXJhbSIsImVxdWFsX2xvY2FsIiwiQmFzZV9TZXhwIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsWUFBQUMsY0FBQUMsT0FBQUM7QUFBQUEsSUNhSyxvQkFDSztBQUFBLElBQ0E7QUFBQSxTQUFBQyxRQUFBO0FBQUEsd0JBR1k7QUFBQSxTQUFBQyxRQUhaO0FBQUEsS0FFK0IsNERBSXFCO0FBQUE7QUFBQSxRQUFBQyxRQU5wRDtBQUFBLHVCQUlZO0FBQUEsUUFBQUMsUUFKWjtBQUFBLElBTUQ7QUFBQSxzRUFBcUQ7QUFBQTtBQUFBLFlBQUFDLFFBQUFDLEdBQUFDLEdBSXBDLDBCQUFrQjtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBLElBSXZDO0FBQUEsU0FBQUMsVUFBQTtBQUFBLEtBQ3lCLGlEQUE0QjtBQUFBO0FBQUEsUUFBQUMsVUFEckQ7QUFBQSxJQUV5Qiw2REFBb0M7QUFBQTtBQUFBLE9BQUFDLDBCRC9CbEU7QUFBQSxZQUFBQyxZQUFBQyxLQUFBQztBQUFBQSxJQ3FDSztBQUFBLFNBQUE3QyxLQUFBLFFBQUE0QyxRQUVZO0FBQUEsS0FFViw4Q0FJa0M7QUFBQTtBQUFBLFFBQUE1QyxPQVJwQyxRQUFBNEMsUUFNWTtBQUFBLElBRVYsOERBQWtDO0FBQUE7QUFBQSxZQUFBRSxLQUFBQyxHQVM5QixnREFBTTtBQUFBLFlBQUFDLEtBQUFIO0FBQUFBLFFBQUFELE1BSEEsb0NBQ1Y7QUFBQSxJQUFtQixpQ0FBQztBQUFBO0FBQUEsR0FFekI7QUFBQSxPQUFBSyxpQkFBQTtBQUFBLFlBQUFDLFVBQUFDLE9BT3NCLFNBQUU7QUFBQSxZQUFBQyxZQUFBaEIsR0FBQUMsR0FDSCx3Q0FBa0IsQ0FBSTtBQUFBO0FBQUEsSUFBQWdCO0FBQUFBLE1BUjNDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRERiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0MCIsIlNleHBsaWIwX1NleHBfY29udiIsIkJhc2VfSGFzaCIsIkJhc2VfUHB4X2NvbXBhcmVfbGliIiwiQmFzZV9HbG9iYWxpemUiLCJCYXNlX1NleHAiLCJFeGl0IiwiTm90X2ZvdW5kIiwibWF4X2ludCIsIm1pbl9pbnQiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYm9vbF9vZl9zdHJpbmdfb3B0IiwiYm9vbF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50X29wdCIsInJlYWRfaW50IiwicmVhZF9mbG9hdF9vcHQiLCJyZWFkX2Zsb2F0Iiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJvcGVuX291dF9nZW4iLCJmbHVzaCIsImZsdXNoX2FsbCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X3ZhbHVlIiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dCIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJjbG9zZV9pbl9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9pbiIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJleGl0IiwiYXRfZXhpdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsImRvX2F0X2V4aXQiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsIlN0ZGxpYiIsImJvb2xfdG9faW50IiwiSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsIm1heCIsIm1pbiIsIkludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIkludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIk5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljXyIsIkJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYSIsIkNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYSIsIlVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIkZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsIlN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbSIsIkJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcCIsInN5bWJvbF9jb25jYXQiLCJhc3IiLCJsYW5kIiwibG5vdCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMiLCJmYWlsd2l0aCIsImZzdCIsImludmFsaWRfYXJnIiwic25kIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsImRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0Iiwid3JpdGVfb2xkX29wdGlvbl9mb3JtYXQiLCJyZWFkX29sZF9vcHRpb25fZm9ybWF0IiwibGlzdF9tYXAiLCJzZXhwX29mX3VuaXQiLCJzZXhwX29mX2Jvb2wiLCJzZXhwX29mX3N0cmluZyIsInNleHBfb2ZfYnl0ZXMiLCJzZXhwX29mX2NoYXIiLCJzZXhwX29mX2ludCIsInNleHBfb2ZfZmxvYXQiLCJzZXhwX29mX2ludDMyIiwic2V4cF9vZl9pbnQ2NCIsInNleHBfb2ZfbmF0aXZlaW50Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX2xhenlfdCIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl9wYWlyIiwic2V4cF9vZl90cmlwbGUiLCJzZXhwX29mX2xpc3QiLCJzZXhwX29mX2FycmF5Iiwic2V4cF9vZl9oYXNodGJsIiwic2V4cF9vZl9vcGFxdWUiLCJzZXhwX29mX2Z1biIsIk9mX3NleHBfZXJyb3IiLCJyZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzIiwib2Zfc2V4cF9lcnJvciIsIm9mX3NleHBfZXJyb3JfZXhuIiwidW5pdF9vZl9zZXhwIiwiYm9vbF9vZl9zZXhwIiwic3RyaW5nX29mX3NleHAiLCJieXRlc19vZl9zZXhwIiwiY2hhcl9vZl9zZXhwIiwiaW50X29mX3NleHAiLCJmbG9hdF9vZl9zZXhwIiwiaW50MzJfb2Zfc2V4cCIsImludDY0X29mX3NleHAiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInJlZl9vZl9zZXhwIiwibGF6eV90X29mX3NleHAiLCJvcHRpb25fb2Zfc2V4cCIsInBhaXJfb2Zfc2V4cCIsInRyaXBsZV9vZl9zZXhwIiwibGlzdF9vZl9zZXhwIiwiYXJyYXlfb2Zfc2V4cCIsImhhc2h0Ymxfb2Zfc2V4cCIsIm9wYXF1ZV9vZl9zZXhwIiwiZnVuX29mX3NleHAiLCJzZXhwX2dyYW1tYXJfd2l0aF90YWdzIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QiLCJ1bml0X3NleHBfZ3JhbW1hciIsImJvb2xfc2V4cF9ncmFtbWFyIiwic3RyaW5nX3NleHBfZ3JhbW1hciIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImNoYXJfc2V4cF9ncmFtbWFyIiwiaW50X3NleHBfZ3JhbW1hciIsImZsb2F0X3NleHBfZ3JhbW1hciIsImludDMyX3NleHBfZ3JhbW1hciIsImludDY0X3NleHBfZ3JhbW1hciIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJzZXhwX3Rfc2V4cF9ncmFtbWFyIiwicmVmX3NleHBfZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwibGlzdF9zZXhwX2dyYW1tYXIiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJvcGFxdWVfc2V4cF9ncmFtbWFyIiwiZnVuX3NleHBfZ3JhbW1hciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGNfcHJlZmVyX3NleHAiLCJzZXhwX29mX2V4bl9vcHQiLCJFeG5fY29udmVydGVyIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9pbnQzMiIsImhhc2hfZm9sZF9jaGFyIiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX3N0cmluZyIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX29wdGlvbiIsImhhc2hfZm9sZF9saXN0IiwiaGFzaF9mb2xkX2xhenlfdCIsImhhc2hfZm9sZF9yZWZfZnJvemVuIiwiaGFzaF9mb2xkX2FycmF5X2Zyb3plbiIsImhhc2hfbmF0aXZlaW50IiwiaGFzaF9pbnQ2NCIsImhhc2hfaW50MzIiLCJoYXNoX2NoYXIiLCJoYXNoX2ludCIsImhhc2hfYm9vbCIsImhhc2hfc3RyaW5nIiwiaGFzaF9mbG9hdCIsImhhc2hfdW5pdCIsImNvbXBhcmVfYm9vbCIsImNvbXBhcmVfY2hhciIsImNvbXBhcmVfZmxvYXQiLCJjb21wYXJlX2ludCIsImNvbXBhcmVfaW50MzIiLCJjb21wYXJlX2ludDY0IiwiY29tcGFyZV9uYXRpdmVpbnQiLCJjb21wYXJlX3N0cmluZyIsImNvbXBhcmVfYnl0ZXMiLCJjb21wYXJlX3VuaXQiLCJjb21wYXJlX2FycmF5IiwiY29tcGFyZV9saXN0IiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX3JlZiIsImVxdWFsX2Jvb2wiLCJlcXVhbF9jaGFyIiwiZXF1YWxfZmxvYXQiLCJlcXVhbF9pbnQiLCJlcXVhbF9pbnQzMiIsImVxdWFsX2ludDY0IiwiZXF1YWxfbmF0aXZlaW50IiwiZXF1YWxfc3RyaW5nIiwiZXF1YWxfYnl0ZXMiLCJlcXVhbF91bml0IiwiZXF1YWxfYXJyYXkiLCJlcXVhbF9saXN0IiwiZXF1YWxfb3B0aW9uIiwiZXF1YWxfcmVmIiwiY29tcGFyZV9ib29sX2xvY2FsIiwiY29tcGFyZV9jaGFyX2xvY2FsIiwiY29tcGFyZV9mbG9hdF9sb2NhbCIsImNvbXBhcmVfaW50X2xvY2FsIiwiY29tcGFyZV9pbnQzMl9sb2NhbCIsImNvbXBhcmVfaW50NjRfbG9jYWwiLCJjb21wYXJlX25hdGl2ZWludF9sb2NhbCIsImNvbXBhcmVfc3RyaW5nX2xvY2FsIiwiY29tcGFyZV9ieXRlc19sb2NhbCIsImNvbXBhcmVfdW5pdF9sb2NhbCIsImNvbXBhcmVfYXJyYXlfbG9jYWwiLCJjb21wYXJlX2xpc3RfbG9jYWwiLCJjb21wYXJlX29wdGlvbl9sb2NhbCIsImNvbXBhcmVfcmVmX2xvY2FsIiwiZXF1YWxfYm9vbF9sb2NhbCIsImVxdWFsX2NoYXJfbG9jYWwiLCJlcXVhbF9mbG9hdF9sb2NhbCIsImVxdWFsX2ludF9sb2NhbCIsImVxdWFsX2ludDMyX2xvY2FsIiwiZXF1YWxfaW50NjRfbG9jYWwiLCJlcXVhbF9uYXRpdmVpbnRfbG9jYWwiLCJlcXVhbF9zdHJpbmdfbG9jYWwiLCJlcXVhbF9ieXRlc19sb2NhbCIsImVxdWFsX3VuaXRfbG9jYWwiLCJlcXVhbF9hcnJheV9sb2NhbCIsImVxdWFsX2xpc3RfbG9jYWwiLCJlcXVhbF9vcHRpb25fbG9jYWwiLCJlcXVhbF9yZWZfbG9jYWwiLCJnbG9iYWxpemVfYm9vbCIsImdsb2JhbGl6ZV9jaGFyIiwiZ2xvYmFsaXplX2Zsb2F0IiwiZ2xvYmFsaXplX2ludCIsImdsb2JhbGl6ZV9pbnQzMiIsImdsb2JhbGl6ZV9pbnQ2NCIsImdsb2JhbGl6ZV9uYXRpdmVpbnQiLCJnbG9iYWxpemVfYnl0ZXMiLCJnbG9iYWxpemVfc3RyaW5nIiwiZ2xvYmFsaXplX3VuaXQiLCJnbG9iYWxpemVfYXJyYXkiLCJnbG9iYWxpemVfbGF6eV90IiwiZ2xvYmFsaXplX2xpc3QiLCJnbG9iYWxpemVfb3B0aW9uIiwiZ2xvYmFsaXplX3Jlc3VsdCIsImdsb2JhbGl6ZV9yZWYiLCJOb3RfZm91bmRfcyIsIkJhc2VfSW1wb3J0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBUixXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQVMsaUNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQXRCLFlBQUE7QUFBQSxJQUFBdUIsZ0JBQUE7QUFBQSxJQUFBdkIsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBd0IsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOTkyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID1cbiAgfCBXMzJcbiAgfCBXNjRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgfCBXNjQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVzY0XCJcbiAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxuW0BAQGVuZF1cblxubGV0IG51bV9iaXRzID0gZnVuY3Rpb25cbiAgfCBXMzIgLT4gMzJcbiAgfCBXNjQgLT4gNjRcbjs7XG5cbmxldCB3b3JkX3NpemUgPVxuICBtYXRjaCBTeXMud29yZF9zaXplX2luX2JpdHMgd2l0aFxuICB8IDMyIC0+IFczMlxuICB8IDY0IC0+IFc2NFxuICB8IF8gLT4gZmFpbHdpdGggXCJ1bmtub3duIHdvcmQgc2l6ZVwiXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU3lzMCIsIkJhc2VfSW1wb3J0Iiwic2V4cF9vZl90IiwicGFyYW0iLCJudW1fYml0cyIsIm1hdGNoIiwiY3N0X3Vua25vd25fd29yZF9zaXplIiwid29yZF9zaXplIiwiQmFzZV9Xb3JkX3NpemUiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFVBQUFDLE9DU0csb0JBRWlDO0FBQUEsWUFBQUMsU0FBQUQsT0FNckIsc0JBRUY7QUFBQTtBQUFBLElBQUFFLFFEbkJiO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQSw0QkMwQlM7QUFBQSxJQUFBQyxpQkQxQlQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDE4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9Gb3JtYXR0ZXIiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvcHJldHR5X3ByaW50ZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxubGV0IHIgPSByZWYgWyBcIkJhc2UuU2V4cC5wcF9odW1cIiBdXG5sZXQgYWxsICgpID0gIXJcbmxldCByZWdpc3RlciBwID0gciA6PSBwIDo6ICFyXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHBwIDogRm9ybWF0dGVyLnQgLT4gdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyX3BwIChNIDogc2lnXG4gIGluY2x1ZGUgU1xuXG4gIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0ICgpID0gcmVnaXN0ZXIgKE0ubW9kdWxlX25hbWUgXiBcIi5wcFwiKVxuZW5kXG5cbm1vZHVsZSBSZWdpc3RlciAoTSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5lbmQpID1cblJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0IHBwIGZvcm1hdHRlciB0ID0gU3RkbGliLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm9ybWF0dGVyIChNLnRvX3N0cmluZyB0KVxuZW5kKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiQmFzZV9JbXBvcnQiLCJyIiwiY3N0X3BwIiwiYWxsIiwicGFyYW0iLCJyZWdpc3RlciIsInAiLCJSZWdpc3Rlcl9wcCIsIk0iLCJwcCIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJtb2R1bGVfbmFtZSIsImZvcm1hdHRlciIsInQiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLElBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsWUFBQUMsSUFBQUMsT0NHYSxZQUFFO0FBQUEsWUFBQUMsU0FBQUMsR0FDRSw4QkFBWTtBQUFBLFlBQUFDLFlBQUFDO0FBQUFBLFFBQUFDLEtESjdCO0FBQUEsSUNvQlcsU0FBUztBQUFBLElBQXVCO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EcEIzQztBQUFBO0FBQUEsZ0JBQUFGO0FBQUFBLFlBQUFHLGNBQUE7QUFBQSxpQkFBQUYsR0FBQUcsV0FBQUM7QUFBQUEsYUFBQSxJQ2dDK0Q7QUFBQSxTQUFlO0FBQUE7QUFBQSxRRGhDOUUiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2V4bi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBTdGRsaWIuZXhpdFxuXG5leGNlcHRpb24gRmluYWxseSBvZiB0ICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZpbmFsbHldIChmdW5jdGlvblxuICAgIHwgRmluYWxseSAoYXJnMF9fMDAxXywgYXJnMV9fMDAyXykgLT5cbiAgICAgIGxldCByZXMwX18wMDNfID0gc2V4cF9vZl90IGFyZzBfXzAwMV9cbiAgICAgIGFuZCByZXMxX18wMDRfID0gc2V4cF9vZl90IGFyZzFfXzAwMl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5GaW5hbGx5XCI7IHJlczBfXzAwM187IHJlczFfXzAwNF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gUmVyYWlzZWQgb2Ygc3RyaW5nICogdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFJlcmFpc2VkXSAoZnVuY3Rpb25cbiAgICB8IFJlcmFpc2VkIChhcmcwX18wMDVfLCBhcmcxX18wMDZfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDVfXG4gICAgICBhbmQgcmVzMV9fMDA4XyA9IHNleHBfb2ZfdCBhcmcxX18wMDZfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuUmVyYWlzZWRcIjsgcmVzMF9fMDA3XzsgcmVzMV9fMDA4XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudFxuXG4oKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlOlxuXG4gICB7W1xuICAgICBleGNlcHRpb24gU2V4cCBvZiBTZXhwLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG4gICAgICgqIC4uLiAqKVxuICAgICBbQEBAZW5kXVxuICAgXX1cblxuICAgdG8gZWxpbWluYXRlIHRoZSBleHRyYSB3cmFwcGluZyBvZiBbKFNleHAgLi4uKV0uICopXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2V4cF0gKGZ1bmN0aW9uXG4gICAgfCBTZXhwIHQgLT4gdFxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgY3JlYXRlX3Mgc2V4cCA9IFNleHAgc2V4cFxuXG5sZXQgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgdCBiYWNrdHJhY2UgPVxuICBTdGRsaWIuUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgdCBiYWNrdHJhY2Vcbjs7XG5cbmV4dGVybmFsIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgOiB0IC0+IGJvb2wgPSBcIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuXCJcblxubGV0IHJlcmFpc2UgZXhuIHN0ciA9XG4gIGxldCBleG4nID0gUmVyYWlzZWQgKHN0ciwgZXhuKSBpblxuICBpZiBpc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4blxuICB0aGVuIChcbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAobWF0Y2ggZmluYWxseSB4IHdpdGhcbiAgICAgfCAoKSAtPiByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4gYnRcbiAgICAgfCBleGNlcHRpb24gZmluYWxfZXhuIC0+XG4gICAgICAgKCogVW5mb3J0dW5hdGVseSwgdGhlIGJhY2t0cmFjZSBvZiB0aGUgW2ZpbmFsX2V4bl0gaXMgZGlzY2FyZGVkIGhlcmUuICopXG4gICAgICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKEZpbmFsbHkgKGV4biwgZmluYWxfZXhuKSkgYnQpXG47O1xuXG5sZXQgcHJvdGVjdCB+ZiB+ZmluYWxseSA9IHByb3RlY3R4IH5mICgpIH5maW5hbGx5XG5cbmxldCBkb2VzX3JhaXNlICh0eXBlIGEpIChmIDogdW5pdCAtPiBhKSA9XG4gIHRyeVxuICAgIGlnbm9yZSAoZiAoKSA6IGEpO1xuICAgIGZhbHNlXG4gIHdpdGhcbiAgfCBfIC0+IHRydWVcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICB0eXBlIHQgPSBleG5cblxuICBsZXQgcHAgcHBmIHQgPVxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdCB0IHdpdGhcbiAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgIHwgTm9uZSAtPiBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKFN0ZGxpYi5QcmludGV4Yy50b19zdHJpbmcgdClcbiAgOztcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXhuXCJcbmVuZClcblxubGV0IHByaW50X3dpdGhfYmFja3RyYWNlIGV4YyByYXdfYmFja3RyYWNlID1cbiAgU3RkbGliLkZvcm1hdC5lcHJpbnRmIFwiQFs8Mj5VbmNhdWdodCBleGNlcHRpb246QFxcbkBcXG5AWyVhQF1AXUBcXG5ALlwiIHBwIGV4YztcbiAgaWYgU3RkbGliLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBTdGRsaWIuUHJpbnRleGMucHJpbnRfcmF3X2JhY2t0cmFjZSBTdGRsaWIuc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIFN0ZGxpYi5mbHVzaCBTdGRsaWIuc3RkZXJyXG47O1xuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyICgpID1cbiAgU3RkbGliLlByaW50ZXhjLnNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBwcmludF93aXRoX2JhY2t0cmFjZVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hdXggfmRvX2F0X2V4aXQgfmV4aXQgZiA9XG4gIHRyeSBmICgpIHdpdGhcbiAgfCBleGMgLT5cbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aFxuICAgICAgfCBfIC0+ICgpKTtcbiAgICAodHJ5IHByaW50X3dpdGhfYmFja3RyYWNlIGV4YyByYXdfYmFja3RyYWNlIHdpdGhcbiAgICAgfCBfIC0+XG4gICAgICAgKHRyeVxuICAgICAgICAgIFN0ZGxpYi5QcmludGYuZXByaW50ZiBcIkV4bi5oYW5kbGVfdW5jYXVnaHQgY291bGQgbm90IHByaW50OyBleGl0aW5nIGFueXdheVxcbiUhXCJcbiAgICAgICAgd2l0aFxuICAgICAgICB8IF8gLT4gKCkpKTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZiA9IGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdCB+ZG9fYXRfZXhpdDp0cnVlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHQgfmV4aXQ6bXVzdF9leGl0IGYgPVxuICBoYW5kbGVfdW5jYXVnaHRfYXV4IGYgfmV4aXQ6KGlmIG11c3RfZXhpdCB0aGVuIGV4aXQgZWxzZSBpZ25vcmUpIH5kb19hdF9leGl0Om11c3RfZXhpdFxuOztcblxubGV0IHJlcmFpc2VfdW5jYXVnaHQgc3RyIGZ1bmMgPVxuICB0cnkgZnVuYyAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgbGV0IGJ0ID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIFN0ZGxpYi5yYWlzZV9ub3RyYWNlIGVcbjs7XG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgY2xlYXJfYmFja3RyYWNlID0gY2xlYXJfYmFja3RyYWNlXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0XzIiLCJjc3Rfc3JjX2V4bl9tbCIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDQiLCJhMiIsImEzIiwiZ2xvYmFsX2RhdGEiLCJtb2R1bGVfbmFtZSIsIlN0ZGxpYl9QcmludGV4YyIsIkJhc2VfSW1wb3J0IiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9Gb3JtYXQiLCJCYXNlX1NleHAiLCJCYXNlX1ByaW50ZiIsIkFzc2VydF9mYWlsdXJlIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsInNleHBfb2ZfdCIsImV4aXQiLCJGaW5hbGx5IiwicGFyYW0iLCJ0YWciLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsIlJlcmFpc2VkIiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA3IiwicmVzMV8wMDgiLCJTZXhwIiwidCIsImNyZWF0ZV9zIiwic2V4cCIsInJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicmVyYWlzZSIsImV4biIsInN0ciIsImJ0IiwicmVyYWlzZWYiLCJleGMiLCJmb3JtYXQiLCJ0b19zdHJpbmciLCJ0b19zdHJpbmdfbWFjaCIsInByb3RlY3R4IiwieCIsImZpbmFsbHkkIiwicmVzIiwiZmluYWxfZXhuIiwicHJvdGVjdCIsImRvZXNfcmFpc2UiLCJwcCIsInBwZiIsIm1hdGNoIiwiaW5jbHVkZSIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJkb19hdF9leGl0IiwiaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IiwiaGFuZGxlX3VuY2F1Z2h0IiwibXVzdF9leGl0IiwicmVyYWlzZV91bmNhdWdodCIsImZ1bmMiLCJyYWlzZV93aXRob3V0X2JhY2t0cmFjZSIsImUiLCJpbml0aWFsaXplX21vZHVsZSIsImNsZWFyX2JhY2t0cmFjZSIsIlByaXZhdGUiLCJCYXNlX0V4biJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUE7QUFBQTtBQUFBLEdDYUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUFBLFVBQUFDLE1BQXNFO0FBQUE7QUFBQSxPQUs3RDtBQUFBO0FBQUEsT0FBQUMsV0FMNkQ7QUFBQSxPQUFBQyxXQUFBO0FBQUEsT0FBQUMsV0FFakQ7QUFBQSxPQUFBQyxXQUNBO0FBQUEsTUFDakI7QUFBQSxLQUNrQjtBQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQSxHQVF0QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQU47QUFBQUEsVUFBQUMsTUFBdUU7QUFBQTtBQUFBLE9BSzlEO0FBQUE7QUFBQSxPQUFBTSxXQUw4RDtBQUFBLE9BQUFDLFdBQUE7QUFBQSxPQUFBQyxXQUVsRDtBQUFBLE9BQUFDLFdBQ0E7QUFBQSxNQUNqQjtBQUFBLEtBQ2tCO0FBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUE7QUFBQSxHQWlCdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFYO0FBQUFBLFVBQUFDLE1BQW1FO0FBQUE7QUFBQSxPQUkvRDtBQUFBLFVBQUFXLElBSitEO0FBQUEsTUFDckQ7QUFBQSxLQUdHO0FBQUE7QUFBQSxZQUFBQyxTQUFBQyxNQUdDLHVCQUFTO0FBQUEsWUFBQUMsOEJBQUFILEdBQUFJO0FBQUFBLElBRzNCO0FBQUE7QUFBQSxHQUFnRDtBQUFBLFlBQUFDLFFBQUFDLEtBQUFDO0FBQUFBLFFBQUFELFFBTWhEO0FBQUEsSUFDRztBQUFBLEtBSUU7QUFBQSxRQUFBRSxLQUZNO0FBQUEsSUFDVCwrQ0FDYTtBQUFBO0FBQUEsWUFBQUMsU0FBQUMsS0FBQUM7QUFBQUEsSUFHUztBQUFBLDRCQUFBSixLQUFBbkIsT0FBK0Isd0JBQWUsV0FBUTtBQUFBO0FBQUEsWUFBQXdCLFVBQUFGO0FBQUFBLFFBQUEsSUFDL0I7QUFBQSxJQUFpQjtBQUFBO0FBQUEsWUFBQUcsZUFBQUg7QUFBQUEsUUFBQSxJQUNyQjtBQUFBLElBQWlCO0FBQUE7QUFBQSxPQUFBekIsY0F0QjNDO0FBQUEsWUFBQTZCLFNBQUEvQyxHQUFBZ0QsR0FBQUM7QUFBQUEsSUEwQmpCLFFBQUFDLE1BQU07QUFBQSxVQUFBWDtBQUFBQTtBQUFBQSxNQUFBQSxNRDlFUjtBQUFBLE1BQUFFLEtDbUZhO0FBQUEsS0FDVCxJQUFPO0FBQUEsV0FBQVU7QUFBQUEsVUFBQUEsWURwRlg7QUFBQSxNQ3dGTyxzRUFBNEQ7QUFBQTtBQUFBLEtBSHRELDZDQUdzRDtBQUFBO0FBQUEsSUFSL0Q7QUFBQSxJQUFTO0FBQUEsR0FRc0Q7QUFBQSxZQUFBQyxRQUFBcEQsR0FBQWlELFVBR3pDLCtCQUF1QjtBQUFBLFlBQUFJLFdBQUFyRDtBQUFBQSxJQUcvQyxJQUNVLDBCQUNSLG1CQUFBdUMsS0FFSztBQUFBLEdBQUk7QUFBQSxZQUFBZSxHQUFBQyxLQUFBdEI7QUFBQUEsUUFBQXVCLFFBT0g7QUFBQSxJQUFpQjtBQUFBLFNBQUFyQixPQUFBO0FBQUEsS0FDUiwwQ0FDMEQ7QUFBQTtBQUFBLFlBQTdCO0FBQUEsSUFBNkI7QUFBQTtBQUFBO0FBQUEsSUFBQXNCLFVBdkQxRDtBQUFBLElBQUFILE9BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFJLHFCQUFBZixLQUFBZ0I7QUFBQUEsSUE4RGpCO0FBQUEsSUFDRztBQUFBLEtBQ0U7QUFBQSxJQUNMLDBEQUEwQjtBQUFBO0FBQUEsWUFBQUMsb0JBQUFDLFlBQUExQyxNQUFBbkI7QUFBQUEsSUFRMUIsWUFBSTtBQUFBLFVBQUEyQztBQUFBQTtBQUFBQSxNQUFBQSxNRDdITjtBQUFBLE1BQUFnQixnQkMrSHdCO0FBQUEsS0FLcEIsbUJBRU0sMENBQUFwQjtBQUFBQSxLQUZOLElBSUs7QUFBQSxXQUFBQSxLRHhJVCxJQzJJVSxzQ0FBQUE7QUFBQUEsS0FHTiwwQkFBTTtBQUFBO0FBQUE7QUFBQSxZQUFBdUIseUJBQUE5RDtBQUFBQSxJQUd1QixzQ0FBNEM7QUFBQTtBQUFBLFlBQUErRCxnQkFBQUMsV0FBQWhFO0FBQUFBLFFBQUFtQixTQUczRSwrQkRwSkY7QUFBQSxJQ29KRSxnREFBc0Y7QUFBQTtBQUFBLFlBQUE4QyxpQkFBQXpCLEtBQUEwQjtBQUFBQSxJQUl0RixZQUFJO0FBQUEsVUFBQTNCO0FBQUFBO0FBQUFBLE1BQUFBLE1EeEpOO0FBQUEsTUFBQUUsS0MwSmE7QUFBQSxLQUNULGlFQUFzRDtBQUFBO0FBQUE7QUFBQSxZQUFBMEIsd0JBQUFDO0FBQUFBLElBUXhEO0FBQUEsSUFBa0I7QUFBQSxHQUNJO0FBQUEsWUFBQUMsa0JBQUFoRDtBQUFBQSxJQTNDdEIsMkRBOEMwRDtBQUFBO0FBQUEsWUFBQWlELGdCQUFBO0FBQUEsSUR2SzVEO0FBQUE7QUFBQTtBQUFBLElBQUFDLFVDb0RtQjtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJEcERuQjtBQUFBO0FBQUE7QUFBQSxHQ29EbUI7QUFBQTtBQUFBLEVEcERuQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBiZWxvbmdzIGluIENvbW1vbiwgYnV0IG1vdmVkIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHJldHVybiA9IHsgcmV0dXJuIDogJ2IuICdhIC0+ICdiIH0gW0BAdW5ib3hlZF1cblxubGV0IHdpdGhfcmV0dXJuICh0eXBlIGEpIGYgPVxuICAoKiBSYWlzZWQgdG8gaW5kaWNhdGUgfnJldHVybiB3YXMgY2FsbGVkLiAgTG9jYWwgc28gdGhhdCB0aGUgZXhjZXB0aW9uIGlzIHRpZWQgdG8gYVxuICAgICBwYXJ0aWN1bGFyIGNhbGwgb2YgW3dpdGhfcmV0dXJuXS4gKilcbiAgbGV0IGV4Y2VwdGlvbiBSZXR1cm4gb2YgYSBpblxuICBsZXQgaXNfYWxpdmUgPSByZWYgdHJ1ZSBpblxuICBsZXQgcmV0dXJuIGEgPVxuICAgIGlmIG5vdCAhaXNfYWxpdmVcbiAgICB0aGVuIGZhaWx3aXRoIFwidXNlIG9mIFtyZXR1cm5dIGZyb20gYSBbd2l0aF9yZXR1cm5dIHRoYXQgYWxyZWFkeSByZXR1cm5lZFwiO1xuICAgIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSAoUmV0dXJuIGEpXG4gIGluXG4gIHRyeVxuICAgIGxldCBhID0gZiB7IHJldHVybiB9IGluXG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgYVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgKG1hdGNoIGV4biB3aXRoXG4gICAgIHwgUmV0dXJuIGEgLT4gYVxuICAgICB8IF8gLT4gcmFpc2UgZXhuKVxuOztcblxubGV0IHdpdGhfcmV0dXJuX29wdGlvbiBmID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByZXR1cm4gLT5cbiAgICBmIHsgcmV0dXJuID0gKGZ1biBhIC0+IHJldHVybi5yZXR1cm4gKFNvbWUgYSkpIH07XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IHByZXBlbmQgeyByZXR1cm4gfSB+ZiA9IHsgcmV0dXJuID0gKGZ1biB4IC0+IHJldHVybiAoZiB4KSkgfVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0V4biIsImNzdF9SZXR1cm4iLCJjc3RfdXNlX29mX3JldHVybl9mcm9tX2Ffd2l0aF8iLCJ3aXRoX3JldHVybiIsIlJldHVybiIsImlzX2FsaXZlIiwicmV0dXJuJCIsImEiLCJleG4iLCJ0YWciLCJ3aXRoX3JldHVybl9vcHRpb24iLCJwcmVwZW5kIiwicGFyYW0iLCJ4IiwiQmFzZV9XaXRoX3JldHVybiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxZQUFBUDtBQUFBQTtBQUFBQSxLQUFBUSxTQ1NFO0FBQUEsS0FBQUMsV0FBQTtBQUFBLGFBQUFDLFFBQUFDO0FBQUFBLEtBR0U7QUFBQSxNQUNLO0FBQUEsS0FDTCw2Q0FBc0M7QUFBQTtBQUFBLElBRXhDLFFBQUFBLE1BQ1Usd0JBQ1I7QUFBQSxVQUFBQztBQUFBQSxTQUFBQSxNRGxCSjtBQUFBLEtDc0JJO0FBQUEsU0FBQUMsTUFDQTtBQUFBLHdCQUVRO0FBQUEsU0FBQUYsSUFGUjtBQUFBLEtBQ2U7QUFBQTtBQUFBLEdBQ0c7QUFBQSxZQUFBRyxtQkFBQWQ7QUFBQUEsSUFJcEI7QUFBQSxzQkFBQVU7QUFBQUEsY0FDRSx1QkFBQUMsR0FBdUIsa0NBQXNCO0FBQUEsY0FBRztBQUFBLGFBQzVDLEVBQUM7QUFBQTtBQUFBLFlBQUFJLFFBQUFDLE9BQUFoQjtBQUFBQSxJQUdtQixnQkFBQWlCLEdBQTRCLE9BQUssa0JBQUwsaUJBQUssRUFBakM7QUFBQSxHQUFvQztBQUFBLE9BQUFDLG1CRGxDaEUiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMzc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9WYXJpYW50Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX1ZhcmlhbnRzbGliIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsbUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMzk4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ZuLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbmxldCBjb25zdCBjIF8gPSBjXG5cbmV4dGVybmFsIGlnbm9yZSA6IChfW0Bsb2NhbF9vcHRdKSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogdGhpcyBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgW1N0ZGxpYi5pZ25vcmVdICopXG5cbmxldCBub24gZiB4ID0gbm90IChmIHgpXG5cbmxldCBmb3JldmVyIGYgPVxuICBsZXQgcmVjIGZvcmV2ZXIgKCkgPVxuICAgIGYgKCk7XG4gICAgZm9yZXZlciAoKVxuICBpblxuICB0cnkgZm9yZXZlciAoKSB3aXRoXG4gIHwgZSAtPiBlXG47O1xuXG5leHRlcm5hbCBpZCA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoZXNlIGZ1bmN0aW9ucyBpcyB0byBwYXNzIGluIGZ1bmN0aW9uYWwgYXJndW1lbnRzIGFuZCBnZXRcbiAgIGZ1bmN0aW9ucyBhcyBhIHJlc3VsdC4gKilcbmxldCBjb21wb3NlIGYgZyB4ID0gZiAoZyB4KVxubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IHJlYyBhcHBseV9uX3RpbWVzIH5uIGYgeCA9IGlmIG4gPD0gMCB0aGVuIHggZWxzZSBhcHBseV9uX3RpbWVzIH5uOihuIC0gMSkgZiAoZiB4KVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJjb25zdCQiLCJjIiwicGFyYW0iLCJub24iLCJ4IiwiZm9yZXZlciIsImUiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJ5IiwiYXBwbHlfbl90aW1lcyIsIm4iLCJCYXNlX0ZuIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUMsT0NFZ0IsU0FBQztBQUFBLFlBQUFDLElBQUFULEdBQUFVLEdBTUMsMkJBQUs7QUFBQSxZQUFBQyxRQUFBWDtBQUFBQSxJQU9yQixZQUhFO0FBQUEsVUFBQVksU0FBQUEsSURaSiwwQkNnQlM7QUFBQSxHQUFDO0FBQUEsWUFBQUMsUUFBQWIsR0FBQWMsR0FBQUosR0FRWSxPQUFLLGNBQUwsaUJBQUs7QUFBQSxZQUFBSyxLQUFBZixHQUFBVSxHQUFBTSxHQUNWLDBCQUFLO0FBQUEsWUFBQUMsY0FBQUMsS0FBQWxCLEdBQUFVO0FBQUFBLFFBQUFRLElBQ1MsS0FBQVIsSUFBQTtBQUFBO0FBQUEsZ0JBQWU7QUFBQSxTQUFBQSxNQUFrQyxrQkFBQVEsTUFBVjtBQUFBLEtBQU87QUFBQTtBQUFBO0FBQUEsR0FBUTtBQUFBLE9BQUFDLFVEMUJyRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0NDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJTX3RvX1MyIiwiWCIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsIk1vbmFkX2luZml4IiwiYmluZCIsInJldHVybiQiLCJtYXAiLCJqb2luIiwiaWdub3JlX20iLCJhbGwiLCJhbGxfdW5pdCIsIkxldF9zeW50YXgiLCJTMl90b19TMyIsIlNfdG9fU19pbmRleGVkIiwiUzJfdG9fUyIsIlMzX3RvX1MyIiwiU19pbmRleGVkX3RvX1MyIiwiQmFzZV9Nb25hZF9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFFBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsY0FBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxVQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxTQUFBWjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUcsZUFBQWI7QUFBQUE7QUFBQUEsS0FBQUMsY0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFHLFFBQUFkO0FBQUFBO0FBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQVMsYUFBQTtBQUFBLEtBQUFSLGNBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBSyxTQUFBZjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQU0sZ0JBQUFoQjtBQUFBQTtBQUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFTLGFBQUE7QUFBQSxLQUFBUixjQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBTztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzYxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9tb25hZC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNb25hZF9pbnRmXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2dlbmVyYWwgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmRcbiAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmRcbiAgICAgIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5lcmFsIChNIDogQmFzaWNfZ2VuZXJhbCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmQgPSBNLmJpbmRcbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gIGxldCBtYXBfdmlhX2JpbmQgbWEgfmYgPSBNLmJpbmQgbWEgfmY6KGZ1biBhIC0+IE0ucmV0dXJuIChmIGEpKVxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIE0ubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYmluZCAtPiBtYXBfdmlhX2JpbmRcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG4gICAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggYSBiID0gYSA+Pj0gZnVuIGEgLT4gYiA+PnwgZnVuIGIgLT4gYSwgYlxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBqb2luIHQgPSB0ID4+PSBmdW4gdCcgLT4gdCdcbiAgbGV0IGlnbm9yZV9tIHQgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpXG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9pbmRleGVkIChNIDogQmFzaWNfaW5kZXhlZCkgOlxuICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG5lbmQpXG5cbm1vZHVsZSBNYWtlMyAoTSA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIE0udCA9XG5NYWtlX2dlbmVyYWwgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG5lbmQpXG5cbm1vZHVsZSBNYWtlMiAoTSA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZCkgdCA6PSAoJ2EsICdkKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbmVuZClcblxubW9kdWxlIE1ha2UgKE0gOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuZW5kKVxuXG5tb2R1bGUgTWFrZTJfbG9jYWwgKE0gOiBCYXNpYzJfbG9jYWwpID0gc3RydWN0XG4gIGxldCBiaW5kID0gTS5iaW5kXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuXG4gIGxldCBtYXBfdmlhX2JpbmQgbWEgfmYgPVxuICAgIGxldCByZXMgPSBNLmJpbmQgbWEgfmY6KGZ1biBhIC0+IE0ucmV0dXJuIChmIGEpKSBpblxuICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIE0ubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYmluZCAtPiBtYXBfdmlhX2JpbmRcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG4gICAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuXG4gICAgICBsZXQgYm90aCBhIGIgPVxuICAgICAgICBsZXQgcmVzID1cbiAgICAgICAgICBiaW5kIGEgfmY6KGZ1biBhIC0+XG4gICAgICAgICAgICBsZXQgcmVzID0gbWFwIGIgfmY6KGZ1biBiIC0+IGEsIGIpIGluXG4gICAgICAgICAgICByZXMpXG4gICAgICAgIGluXG4gICAgICAgIHJlc1xuICAgICAgOztcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBsZXQgam9pbiB0ID0gdCA+Pj0gRm4uaWRcblxuICBsZXQgaWdub3JlX20gdCA9XG4gICAgbGV0IHJlcyA9IG1hcCB0IH5mOihmdW4gXyAtPiAoKSkgaW5cbiAgICByZXNcbiAgOztcblxuICBsZXQgYWxsID1cbiAgICBsZXQgcmVjIGxvb3AgdnMgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IHZzKVxuICAgICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biB2IC0+IGxvb3AgKHYgOjogdnMpIHRzXG4gICAgaW5cbiAgICBmdW4gdHMgLT4gbG9vcCBbXSB0c1xuICA7O1xuXG4gIGxldCByZWMgYWxsX3VuaXQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biAoKSAtPiBhbGxfdW5pdCB0c1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2xvY2FsIChNIDogQmFzaWNfbG9jYWwpIDogU19sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPVxuTWFrZTJfbG9jYWwgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBNLnRcbmVuZClcblxubW9kdWxlIE9mX21vbmFkX2dlbmVyYWwgKE1vbmFkIDogc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kXG4gICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gIHZhbCBtYXAgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG5lbmQpIChNIDogc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudFxuICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbmVuZCkgPVxuTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2osICdkLCAnZSkgTS50XG5cbiAgbGV0IHJldHVybiBhID0gTS5vZl9tb25hZCAoTW9uYWQucmV0dXJuIGEpXG4gIGxldCBiaW5kIHQgfmYgPSBNLm9mX21vbmFkIChNb25hZC5iaW5kIChNLnRvX21vbmFkIHQpIH5mOihmdW4gYSAtPiBNLnRvX21vbmFkIChmIGEpKSlcbiAgbGV0IG1hcCA9IGBDdXN0b20gKGZ1biB0IH5mIC0+IE0ub2ZfbW9uYWQgKE1vbmFkLm1hcCAoTS50b19tb25hZCB0KSB+ZikpXG5lbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9pbmRleGVkXG4gIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkM1xuICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkMlxuICAoTW9uYWQgOiBTMikgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IpIE1vbmFkLnQgLT4gKCdhLCAnYikgdFxuICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRcbiAgKE1vbmFkIDogUykgKE0gOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgIHZhbCBvZl9tb25hZCA6ICdhIE1vbmFkLnQgLT4gJ2EgdFxuICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBsZXRbQGlubGluZV0gYmluZCBhIH5mID0gKGYgW0BpbmxpbmVkIGhpbnRdKSBhXG4gIGxldFtAaW5saW5lXSBtYXAgYSB+ZiA9IChmIFtAaW5saW5lZCBoaW50XSkgYVxuXG4gIGV4dGVybmFsIHJldHVybiA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXRbQGlubGluZV0gKCA+PnwgKSBhIGYgPSBtYXAgYSB+ZlxuICAgIGxldFtAaW5saW5lXSAoID4+PSApIGEgZiA9IGJpbmQgYSB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXRbQGlubGluZV0gYm90aCBhIGIgPSBhLCBiXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgZW5kXG5cbiAgZXh0ZXJuYWwgam9pbiA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbiAgZXh0ZXJuYWwgaWdub3JlX20gOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG4gIGV4dGVybmFsIGFsbF91bml0IDogKHVuaXQgbGlzdFtAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG4gIGV4dGVybmFsIGFsbCA6ICgnYSBsaXN0W0Bsb2NhbF9vcHRdKSAtPiAoJ2EgbGlzdFtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0xpc3QwIiwiTWFrZV9nZW5lcmFsIiwiTSIsImJpbmQiLCJyZXR1cm4kIiwibWFwX3ZpYV9iaW5kIiwibWEiLCJhIiwibWF0Y2giLCJtYXAiLCJ4Iiwic3ltYm9sX2JpbmQiLCJ0Iiwic3ltYm9sX21hcCIsIk1vbmFkX2luZml4IiwiYm90aCIsImIiLCJPcGVuX29uX3JocyIsIkxldF9zeW50YXgiLCJqb2luIiwiaWdub3JlX20iLCJwYXJhbSIsImxvb3AiLCJ2cyIsInRzIiwidiIsImFsbCIsImFsbF91bml0IiwiTWFrZV9pbmRleGVkIiwiTWFrZTMiLCJNYWtlMiIsIk1ha2UiLCJNYWtlMl9sb2NhbCIsInJlcyIsIk1ha2VfbG9jYWwiLCJPZl9tb25hZF9nZW5lcmFsIiwiTW9uYWQiLCJCYXNlX01vbmFkIiwidG9fbW9uYWQiLCJvZl9tb25hZCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJ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QUEsU0FBQW9DLFdBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQXBDLE9BQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUssTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBMkIsT0FBQWxDO0FBQUFBO0FBQUFBLFNBQUFvQyxXQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFwQyxPQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFLLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQTJCLE9BQUFsQztBQUFBQTtBQUFBQSxTQUFBb0MsV0FBQTtBQUFBLFNBQUFDLFdBQUE7QUFBQSxTQUFBcEMsT0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBSyxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDAyMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfVCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLFNBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0MDMyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9BcHBsaWNhdGl2ZV9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsd0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0MDQ1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2FwcGxpY2F0aXZlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcblxuKCoqIFRoaXMgbW9kdWxlIHNlcnZlcyBtb3N0bHkgYXMgYSBwYXJ0aWFsIGNoZWNrIHRoYXQgW1MyXSBhbmQgW1NdIGFyZSBpbiBzeW5jLCBidXRcbiAgICBhY3R1YWxseSBjYWxsaW5nIGl0IGlzIG9jY2FzaW9uYWxseSB1c2VmdWwuICopXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFQgOiBULlQpIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgVC50KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCBULnQpIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChUIDogVC5UKSAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgVC50KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgVC50KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUyAoVDEgOiBULlQpIChUMiA6IFQuVCkgKFggOiBTMykgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCBUMS50LCBUMi50KSBYLnQgPVxuc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgVDEudCwgVDIudCkgWC50XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYXBwbHkgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IG1hcDIgdGEgdGIgfmYgPSBtYXAgfmYgdGEgPCo+IHRiXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwIH5mIHRhIDwqPiB0YiA8Kj4gdGNcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgKCAqPiApIHUgdiA9IHJldHVybiAoZnVuICgpIHkgLT4geSkgPCo+IHUgPCo+IHZcbiAgbGV0ICggPCogKSB1IHYgPSByZXR1cm4gKGZ1biB4ICgpIC0+IHgpIDwqPiB1IDwqPiB2XG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTMgKHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMiAoc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4M1xuICAoWCA6IEZvcl9sZXRfc3ludGF4MykgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gSW1wbFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4MlxuICAoWCA6IEZvcl9sZXRfc3ludGF4MikgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4M1xuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgJ2QsIF8pIHQgPSAoJ2EsICdkKSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXhcbiAgKFggOiBGb3JfbGV0X3N5bnRheCkgKEludGYgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBTXG4gIGVuZClcbiAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4MlxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgXykgdCA9ICdhIFgudFxuICAgIGVuZClcbiAgICAoSW50ZilcbiAgICAoSW1wbClcblxuKCoqIFRoaXMgZnVuY3RvciBjbG9zZWx5IHJlc2VtYmxlcyBbTWFrZTNdLCBhbmQgaW5kZWVkIGl0IGNvdWxkIGJlIGltcGxlbWVudGVkXG4gICAgbXVjaCBzaG9ydGVyIGluIHRlcm1zIG9mIFtNYWtlM10uIEhvd2V2ZXIsIHdlIGltcGxlbWVudCBpdCBieSBoYW5kIHNvIHRoYXRcbiAgICB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9ucyBhcmUgbW9yZSBlZmZpY2llbnQsIGUuZy4gdXNpbmcgW21hcDJdIGRpcmVjdGx5IGluc3RlYWQgb2ZcbiAgICBkZWZpbmluZyBbYXBwbHldIGluIHRlcm1zIG9mIGl0IGFuZCB0aGVuIFttYXAyXSBpbiB0ZXJtcyBvZiB0aGF0LiBGb3IgbW9zdFxuICAgIGFwcGxpY2F0aXZlcyB0aGlzIGRvZXMgbm90IG1hdHRlciwgYnV0IGZvciBzb21lIChzdWNoIGFzIEJvbnNhaS5WYWx1ZS50KSwgaXQgaGFzIGFcbiAgICBsYXJnZXIgaW1wYWN0LiAqKVxubW9kdWxlIE1ha2UzX3VzaW5nX21hcDIgKFggOiBCYXNpYzNfdXNpbmdfbWFwMikgOlxuICBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgYXBwbHkgdGYgdGEgPSBtYXAyIHRmIHRhIH5mOihmdW4gZiBhIC0+IGYgYSlcbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IHJldHVybiBmIDwqPiB0XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19tYXAyIC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcDIgKG1hcDIgdGEgdGIgfmYpIHRjIH5mOihmdW4gZmFiIGMgLT4gZmFiIGMpXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgKCAqPiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4gKCkgeSAtPiB5KVxuICBsZXQgKCA8KiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4geCAoKSAtPiB4KVxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyX3VzaW5nX21hcDIgKFggOiBCYXNpYzJfdXNpbmdfbWFwMikgOlxuICBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlM191c2luZ19tYXAyIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kKVxuXG5tb2R1bGUgTWFrZV91c2luZ19tYXAyIChYIDogQmFzaWNfdXNpbmdfbWFwMikgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9XG5NYWtlMl91c2luZ19tYXAyIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlM191c2luZ19tYXAyX2xvY2FsIChYIDogQmFzaWMzX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgUzNfbG9jYWwgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0IGFwcGx5IHRmIHRhID0gbWFwMiB0ZiB0YSB+ZjooZnVuIGYgYSAtPiBmIGEpXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSBtYXAyIH5mOihmdW4gKCkgLT4gZikgKHJldHVybiAoKSkgdCBbQG5vbnRhaWxdXG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19tYXAyIC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIG1hcCAtPiBtYXBcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcblxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9XG4gICAgbGV0IHJlcyA9IG1hcDIgKGJvdGggdGEgdGIpIHRjIH5mOihmdW4gKGEsIGIpIGMgLT4gZiBhIGIgYykgaW5cbiAgICByZXNcbiAgOztcblxuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0ICggKj4gKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuICgpIHkgLT4geSlcbiAgbGV0ICggPCogKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuIHggKCkgLT4geClcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMl91c2luZ19tYXAyX2xvY2FsIChYIDogQmFzaWMyX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgUzJfbG9jYWwgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTNfdXNpbmdfbWFwMl9sb2NhbCAoc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZClcblxubW9kdWxlIE1ha2VfdXNpbmdfbWFwMl9sb2NhbCAoWCA6IEJhc2ljX3VzaW5nX21hcDJfbG9jYWwpIDpcbiAgU19sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMl91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmQpXG5cbm1vZHVsZSBPZl9tb25hZDIgKE0gOiBNb25hZC5TMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBNLnQgPSBNYWtlMiAoc3RydWN0XG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIE0udFxuXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuICBsZXQgYXBwbHkgbWYgbXggPSBNLmJpbmQgbWYgfmY6KGZ1biBmIC0+IE0ubWFwIG14IH5mKVxuICBsZXQgbWFwID0gYEN1c3RvbSBNLm1hcFxuZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQgKE0gOiBNb25hZC5TKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gT2ZfbW9uYWQyIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBNLnRcbmVuZClcblxubW9kdWxlIENvbXBvc2UgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50IEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gYSA9IEcucmV0dXJuIChGLnJldHVybiBhKVxuICAgIGxldCBhcHBseSB0ZiB0eCA9IEcuYXBwbHkgKEcubWFwIH5mOkYuYXBwbHkgdGYpIHR4XG4gICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEcubWFwIH5mOihGLm1hcCB+ZikgdFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBQYWlyIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiBhID0gRi5yZXR1cm4gYSwgRy5yZXR1cm4gYVxuICAgIGxldCBhcHBseSB0ZiB0eCA9IEYuYXBwbHkgKGZzdCB0ZikgKGZzdCB0eCksIEcuYXBwbHkgKHNuZCB0ZikgKHNuZCB0eClcbiAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRi5tYXAgfmYgKGZzdCB0KSwgRy5tYXAgfmYgKHNuZCB0KVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBJZGVudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZV91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IEZuLmlkXG4gICAgbGV0IG1hcDIgYSBiIH5mID0gZiBhIGJcbiAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIGEgfmYgLT4gZiBhKVxuICBlbmQpXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfTGlzdDAiLCJTX3RvX1MyIiwiWCIsInJldHVybiQiLCJtYXAiLCJib3RoIiwic3ltYm9sIiwic3ltYm9sX21hcCIsImFwcGx5IiwibWFwMiIsIm1hcDMiLCJhbGwiLCJhbGxfdW5pdCIsIkFwcGxpY2F0aXZlX2luZml4IiwiUzJfdG9fUyIsIlQiLCJTMl90b19TMyIsIlMzX3RvX1MyIiwiUzNfdG9fUyIsIlQxIiwiVDIiLCJNYWtlMyIsImluY2x1ZGUiLCJkZXJpdmVkX21hcCIsInQiLCJtYXRjaCIsIngiLCJ0YSIsInRiIiwidGMiLCJ0cyIsInhzIiwiYSIsImIiLCJ1IiwidiIsInBhcmFtIiwieSIsIk1ha2UyIiwiTWFrZSIsIk1ha2VfbGV0X3N5bnRheDMiLCJJbnRmIiwiSW1wbCIsIkxldF9zeW50YXgiLCJNYWtlX2xldF9zeW50YXgyIiwiTWFrZTNfdXNpbmdfbWFwMiIsInRmIiwiZmFiIiwiYyIsIk1ha2UyX3VzaW5nX21hcDIiLCJNYWtlX3VzaW5nX21hcDIiLCJNYWtlM191c2luZ19tYXAyX2xvY2FsIiwicmVzIiwiTWFrZTJfdXNpbmdfbWFwMl9sb2NhbCIsIk1ha2VfdXNpbmdfbWFwMl9sb2NhbCIsIk9mX21vbmFkMiIsIk0iLCJtZiIsIm14IiwiT2ZfbW9uYWQiLCJzeW1ib2xfYmluZCIsIk1vbmFkX2luZml4IiwiYmluZCIsImpvaW4iLCJpZ25vcmVfbSIsIkNvbXBvc2UiLCJGIiwiRyIsInR4IiwiY3VzdG9tX21hcCIsIlBhaXIiLCJJZGVudCIsIkJhc2VfQXBwbGljYXRpdmUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMsUUFBQUM7QUFBQUE7QUFBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsb0JBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxRQUFBQyxHQUFBYjtBQUFBQTtBQUFBQSxLQUFBQyxVQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxTQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQyxhQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxvQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFHLFNBQUFkO0FBQUFBO0FBQUFBLEtBQUFDLFVBQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLFNBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQSxLQUFBQyxRQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE9BQUE7QUFBQSxLQUFBQyxNQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLG9CQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUksU0FBQUYsR0FBQWI7QUFBQUE7QUFBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsT0FBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxXQUFBO0FBQUEsS0FBQUMsb0JBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBSyxRQUFBQyxJQUFBQyxJQUFBbEI7QUFBQUE7QUFBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsU0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUMsYUFBQTtBQUFBLEtB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O0FBQUEsSUFBQStCLFVEN1F0QztBQUFBLElBQUFuQixXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUEwRDtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUF0RSxHQUFBdUMsTUFBQUM7QUFBQUE7QUFBQUEsU0FBQXZDLFVBQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsT0FBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFDLGFBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NjgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2NvbXBhcmF0b3IubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICd3aXRuZXNzKSB0ID1cbiAgeyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gIH1cblxudHlwZSAoJ2EsICdiKSBjb21wYXJhdG9yID0gKCdhLCAnYikgdFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhIHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfZmMgPSBzaWdcbiAgdHlwZSBjb21wYXJhYmxlX3RcblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gY29tcGFyYWJsZV90XG5lbmRcblxubW9kdWxlIE1vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnYilcbmVuZFxuXG5sZXQgb2ZfbW9kdWxlICh0eXBlIGEgYikgKChtb2R1bGUgTSkgOiAoYSwgYikgTW9kdWxlLnQpID0gTS5jb21wYXJhdG9yXG5cbmxldCB0b19tb2R1bGUgKHR5cGUgYSBiKSB0IDogKGEsIGIpIE1vZHVsZS50ID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBhXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBiXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHRcbiAgZW5kKVxuOztcblxubGV0IG1ha2UgKHR5cGUgdCkgfmNvbXBhcmUgfnNleHBfb2ZfdCA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSBjb21wYXJhYmxlX3QgPSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICAgIGxldCBjb21wYXJhdG9yID0geyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBlbmQgOiBTX2ZjXG4gICAgd2l0aCB0eXBlIGNvbXBhcmFibGVfdCA9IHQpXG47O1xuXG5tb2R1bGUgU190b19TMSAoUyA6IFMpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IFMudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFMuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgb3BlbiBTXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIE1ha2UgKE0gOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZTEgKE0gOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGNvbXBhcmUgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gIHZhbCBzZXhwX29mX3QgOiAnYSB0IC0+IFNleHAudFxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgIGxldCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gICAgbGV0IHNleHBfb2ZfdCBfID0gU2V4cC5BdG9tIFwiX1wiXG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICEnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSBjb21wYXJhdG9yIC0+ICgnYSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkIChNIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAhJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZDIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCEnY21wX2EsICEnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wX2EpIGNvbXBhcmF0b3JcbiAgICAtPiAoJ2IsICdjbXBfYikgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsICdiKSB0LCAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkMiAoTSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgdmFsIHNleHBfb2ZfdFxuICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCEnY21wX2EsICEnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgYiA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICA7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IGIuc2V4cF9vZl90XG4gICAgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWRfcGhhbnRvbSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgXykgdCwgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZF9waGFudG9tIChNIDogc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gIHZhbCBjb21wYXJlIDogKCdhIC0+ICdhIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdhLCBfKSB0IC0+IFNleHAudFxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wX2EgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQyX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuICB0eXBlICghJ2NtcF9hLCAhJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcF9hKSBjb21wYXJhdG9yXG4gICAgLT4gKCdiLCAnY21wX2IpIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCAnYiwgXykgdCwgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZDJfcGhhbnRvbSAoTSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgdmFsIGNvbXBhcmVcbiAgICA6ICAoJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICgnYiAtPiAnYiAtPiBpbnQpXG4gICAgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAtPiAoJ2EsICdiLCAnYykgdFxuICAgIC0+IGludFxuXG4gIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2IgLT4gU2V4cC50KSAtPiAoJ2EsICdiLCBfKSB0IC0+IFNleHAudFxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSBiID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgIDsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgYi5zZXhwX29mX3RcbiAgICB9XG4gIDs7XG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsIk1vZHVsZSIsIm9mX21vZHVsZSIsIk0iLCJ0b19tb2R1bGUiLCJ0IiwibWFrZSIsImNvbXBhcmUiLCJzZXhwX29mX3QiLCJjb21wYXJhdG9yIiwiU190b19TMSIsIlMiLCJNYWtlMSIsInBhcmFtIiwiaW5jbHVkZSIsIlBvbHkiLCJEZXJpdmVkIiwiYSIsIkRlcml2ZWQyIiwiYiIsIkRlcml2ZWRfcGhhbnRvbSIsIkRlcml2ZWQyX3BoYW50b20iLCJCYXNlX0NvbXBhcmF0b3IiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxTQUFBO0FBQUEsWUFBQUMsVUFBQUMsR0NpQzBELFlBQVk7QUFBQSxZQUFBQyxVQUFBQyxHQUdwRSxjQUtJO0FBQUEsWUFBQUMsS0FBQUMsU0FBQUM7QUFBQUEsUUFBQUMsYUFJSjtBQUFBO0FBQUEsR0FNNkI7QUFBQSxZQUFBQyxRQUFBQyxPQUFBRixhRG5EL0I7QUFBQSxZQUFBRyxNQUFBVDtBQUFBQSxRQUFBTSxhQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFGLFVBQUE7QUFBQSxZQUFBQyxVQUFBSyxPQ21Hc0IsU0FBYTtBQUFBO0FBQUEsSUFBQUMsVURuR25DO0FBQUEsSUFBQUwsYUFBQTtBQUFBLElBQUFNLE9BQUE7QUFBQSxZQUFBQyxRQUFBYjtBQUFBQSxhQUFBTSxXQUFBUTtBQUFBQSxTQUFBLElDMkhpRDtBQUFBLEtBQWpDLHFDQUFtQjtBQUFBLElBQXVDO0FBQUEsSUQzSDFFO0FBQUE7QUFBQSxZQUFBQyxTQUFBZjtBQUFBQSxhQUFBTSxXQUFBUSxHQUFBRTtBQUFBQSxTQUFBLElDMkprQjtBQUFBLEtBREYsMkNBQTZCO0FBQUEsSUFFeEM7QUFBQSxJRDVKTDtBQUFBO0FBQUEsWUFBQUMsZ0JBQUFqQjtBQUFBQSxhQUFBTSxXQUFBUTtBQUFBQSxTQUFBLElDbUxpRDtBQUFBLEtBQWpDLHFDQUFtQjtBQUFBLElBQXVDO0FBQUEsSURuTDFFO0FBQUE7QUFBQSxZQUFBSSxpQkFBQWxCO0FBQUFBLGFBQUFNLFdBQUFRLEdBQUFFO0FBQUFBLFNBQUEsSUNrTmtCO0FBQUEsS0FERiwyQ0FBNkI7QUFBQSxJQUV4QztBQUFBLElEbk5MO0FBQUE7QUFBQTtBQUFBLElBQUFHO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQW5CLE9BQUFNLGFBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NzY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9Db21wYXJpc29ucyJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLG1CQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDc3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9laXRoZXIwLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdmLCAncykgdCA9XG4gIHwgRmlyc3Qgb2YgJ2ZcbiAgfCBTZWNvbmQgb2YgJ3NcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgOlxuICAgICAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwN18gYl9fMDA4XyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwN18gYl9fMDA4X1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDA3XywgYl9fMDA4XyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDA5XywgRmlyc3QgX2JfXzAxMF8gLT4gX2NtcF9fZiBfYV9fMDA5XyBfYl9fMDEwX1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAxMV8sIFNlY29uZCBfYl9fMDEyXyAtPiBfY21wX19zIF9hX18wMTFfIF9iX18wMTJfKVxuOztcblxubGV0IGNvbXBhcmUgOlxuICAgICAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwMV8gYl9fMDAyXyAtPlxuICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICAgICAnZiAncy5cbiAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2YpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3MpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2YsICdzKSB0XG4gID1cbiAgZnVuICh0eXBlIGZfXzAyOV8gc19fMDMwXylcbiAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjlfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAzMF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+IChmX18wMjlfLCBzX18wMzBfKSB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMTdfID0gXCJlaXRoZXIwLm1sLnRcIiBpblxuICBmdW4gX29mX2ZfXzAxM18gX29mX3NfXzAxNF8gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJmaXJzdFwiIHwgXCJGaXJzdFwiKSBhcyBfdGFnX18wMjBfKSA6OiBzZXhwX2FyZ3NfXzAyMV8pIGFzXG4gICAgICBfc2V4cF9fMDE5XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDIxXyB3aXRoXG4gICAgICAgfCBhcmcwX18wMjJfIDo6IFtdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDIzXyA9IF9vZl9mX18wMTNfIGFyZzBfXzAyMl8gaW5cbiAgICAgICAgIEZpcnN0IHJlczBfXzAyM19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTdfXG4gICAgICAgICAgIF90YWdfXzAyMF9cbiAgICAgICAgICAgX3NleHBfXzAxOV8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMjVfKSA6OiBzZXhwX2FyZ3NfXzAyNl8pIGFzXG4gICAgICBfc2V4cF9fMDI0XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDI2XyB3aXRoXG4gICAgICAgfCBhcmcwX18wMjdfIDo6IFtdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDI4XyA9IF9vZl9zX18wMTRfIGFyZzBfXzAyN18gaW5cbiAgICAgICAgIFNlY29uZCByZXMwX18wMjhfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDE3X1xuICAgICAgICAgICBfdGFnX18wMjVfXG4gICAgICAgICAgIF9zZXhwX18wMjRfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIHNleHBfXzAxOF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxOF9cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxOF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxOF9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDE2XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDE3XyBzZXhwX18wMTZfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDE2XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxNl9cbiAgICB8IHNleHBfXzAxNl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxN18gc2V4cF9fMDE2X1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICAgICAnZiAncy5cbiAgICAgICgnZiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnZiwgJ3MpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGZfXzAzN18gc19fMDM4XylcbiAgICA6ICAoKGZfXzAzN18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDM4XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKGZfXzAzN18sIHNfXzAzOF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2ZfXzAzMV8gX29mX3NfXzAzMl8gLT4gZnVuY3Rpb25cbiAgfCBGaXJzdCBhcmcwX18wMzNfIC0+XG4gICAgbGV0IHJlczBfXzAzNF8gPSBfb2ZfZl9fMDMxXyBhcmcwX18wMzNfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmlyc3RcIjsgcmVzMF9fMDM0XyBdXG4gIHwgU2Vjb25kIGFyZzBfXzAzNV8gLT5cbiAgICBsZXQgcmVzMF9fMDM2XyA9IF9vZl9zX18wMzJfIGFyZzBfXzAzNV8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZWNvbmRcIjsgcmVzMF9fMDM2XyBdXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICAgJ2YgJ3MuXG4gICAgICAnZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ3MgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBmdW4gXydmX3NleHBfZ3JhbW1hciBfJ3Nfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJGaXJzdFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nZl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiU2Vjb25kXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydzX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5bQEBAZW5kXVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRmlyc3QiLCJjc3RfU2Vjb25kIiwiY3N0X2ZpcnN0IiwiY3N0X3NlY29uZCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImVycm9yX3NvdXJjZV8wMTciLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX0hhc2giLCJjb21wYXJlX2xvY2FsIiwiY21wX2YiLCJjbXBfcyIsImFfMDA3IiwiYl8wMDgiLCJhXzAwOSIsImJfMDEwIiwiYV8wMTEiLCJiXzAxMiIsImNvbXBhcmUiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsImFfMDA1IiwiYl8wMDYiLCJoYXNoX2ZvbGRfdCIsImhhc2hfZm9sZF9mIiwiaGFzaF9mb2xkX3MiLCJoc3YiLCJhcmciLCJ0X29mX3NleHAiLCJvZl9mXzAxMyIsIm9mX3NfMDE0Iiwic2V4cF8wMTkiLCJtYXRjaCIsInRhZ18wMjAiLCJzZXhwX2FyZ3NfMDI2IiwiYXJnMF8wMjciLCJyZXMwXzAyOCIsInNleHBfYXJnc18wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwic2V4cF9vZl90Iiwib2ZfZl8wMzEiLCJvZl9zXzAzMiIsInBhcmFtIiwiYXJnMF8wMzMiLCJyZXMwXzAzNCIsImFyZzBfMDM1IiwicmVzMF8wMzYiLCJ0X3NleHBfZ3JhbW1hciIsImZfc2V4cF9ncmFtbWFyIiwic19zZXhwX2dyYW1tYXIiLCJCYXNlX0VpdGhlcjAiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxRQytERTtBQUFBO0FBQUEsSUFBQVgsYUFBQTtBQUFBLElBQUFELFlBQUE7QUFBQSxZQUFBYSxjQUFBQyxPQUFBQyxPQUFBQyxPQUFBQztBQUFBQSxJQXBEQSxvQkFDSztBQUFBLElBQ0E7QUFBQSxTQUFBQyxRQUFBO0FBQUEsd0JBR2E7QUFBQSxTQUFBQyxRQUhiO0FBQUEsS0FFaUMsc0NBRzRCO0FBQUE7QUFBQSxRQUFBQyxRQUw3RDtBQUFBLHVCQUlhO0FBQUEsUUFBQUMsUUFKYjtBQUFBLElBS21DLHNDQUEwQjtBQUFBO0FBQUEsWUFBQUMsUUFBQVIsT0FBQUMsT0FBQVEsT0FBQUM7QUFBQUEsSUFPbEUsb0JBQ0s7QUFBQSxJQUNBO0FBQUEsU0FBQUMsUUFBQTtBQUFBLHdCQUdhO0FBQUEsU0FBQUMsUUFIYjtBQUFBLEtBRWlDLHNDQUc0QjtBQUFBO0FBQUEsUUFBQUMsUUFMN0Q7QUFBQSx1QkFJYTtBQUFBLFFBQUFDLFFBSmI7QUFBQSxJQUttQyxzQ0FBMEI7QUFBQTtBQUFBLFlBQUFDLFlBQUFDLGFBQUFDLGFBQUFDLEtBQUFDO0FBQUFBLElBWWxFO0FBQUEsU0FBQTNCLEtBQUEsUUFBQTBCLFFBRVk7QUFBQSxLQUVWLHlDQUlvQjtBQUFBO0FBQUEsUUFBQTFCLE9BUnRCLFFBQUEwQixRQU1ZO0FBQUEsSUFFViwyQ0FBb0I7QUFBQTtBQUFBLFlBQUFFLFVBQUFDLFVBQUFDLFVBQUFDO0FBQUFBO0FBQUFBO0FBQUFBLEtBV3RCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQTRCSTtBQUFBLGlEQUtvRjtBQUFBO0FBQUEsTUFQcEY7QUFBQSxnREFPb0Y7QUFBQTtBQUFBLFNBQUFDLFFBakN4RjtBQUFBO0FBQUEsTUFnQ0k7QUFBQSxnREFDb0Y7QUFBQSxTQUFBQSxVQWpDeEY7QUFBQTtBQUFBLE1BOEJJO0FBQUEsZ0RBR29GO0FBQUEsU0FBQUMsVUFqQ3hGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQUMsZ0JBQUE7QUFBQSxNQWdCSTtBQUFBO0FBQUEsUUFBQUMsV0FBQTtBQUFBLFFBQUFDLFdBRW9CO0FBQUEsT0FDakI7QUFBQTtBQUFBLE1BRUE7QUFBQSx5REFZaUY7QUFBQTtBQUFBLFNBQUFDLGdCQWpDeEY7QUFBQSxLQUlJO0FBQUE7QUFBQSxPQUFBQyxXQUFBO0FBQUEsT0FBQUMsV0FFb0I7QUFBQSxNQUNqQjtBQUFBO0FBQUEsS0FFQTtBQUFBLHdEQXdCaUY7QUFBQTtBQUFBLElBQXRFLDBFQUFzRTtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsVUFBQUMsVUFBQUM7QUFBQUEsSUFPeEY7QUFBQSxTQUFBQyxXQUFBLFVBQUFDLFdBS21CO0FBQUEsS0FDakI7QUFBQTtBQUFBLFFBQUFDLFdBTkYsVUFBQUMsV0FRbUI7QUFBQSxJQUNqQjtBQUFBLEdBQThEO0FBQUEsWUFBQUMsZUFBQUMsZ0JBQUFDO0FBQUFBLElBVWhFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBZ0JDO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQTNFRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRC9ERiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvZmllbGQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGUgdHlwZSBbdF0gc2hvdWxkIGJlIGFic3RyYWN0IHRvIG1ha2UgdGhlIGZzZXQgYW5kIHNldCBmdW5jdGlvbnMgdW5hdmFpbGFibGVcbiAgIGZvciBwcml2YXRlIHR5cGVzIGF0IHRoZSBsZXZlbCBvZiB0eXBlcyAoYW5kIG5vdCBieSBwdXR0aW5nIE5vbmUgaW4gdGhlIGZpZWxkKS5cbiAgIFVuZm9ydHVuYXRlbHksIG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCBtZWFucyB0aGF0IHdoZW4gY3JlYXRpbmcgZmllbGRzICh0aHJvdWdoXG4gICBhIFtjcmVhdGVdIGZ1bmN0aW9uKSB2YWx1ZSByZXN0cmljdGlvbiBraWNrcyBpbi4gVGhpcyBpcyB3b3JrZWQgYXJvdW5kIGJ5IGluc3RlYWRcbiAgIG5vdCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QsIGJ1dCBmb3JjaW5nIGFueW9uZSBicmVha2luZyB0aGUgYWJzdHJhY3Rpb24gdG8gdXNlXG4gICB0aGUgW0Zvcl9nZW5lcmF0ZWRfY29kZV0gbW9kdWxlLCBtYWtpbmcgaXQgb2J2aW91cyB0byBhbnkgcmVhZGVyIHRoYXQgc29tZXRoaW5nIHVnbHlcbiAgIGlzIGdvaW5nIG9uLlxuICAgdF93aXRoX3Blcm0gKGFuZCBkZXJpdmF0aXZlcykgaXMgdGhlIHR5cGUgdGhhdCB1c2VycyByZWFsbHkgdXNlLiBJdCBpcyBhIGNvbnN0cnVjdG9yXG4gICBiZWNhdXNlOlxuICAgMS4gaXQgbWFrZXMgdHlwZSBlcnJvcnMgbW9yZSByZWFkYWJsZSAobGVzcyBhbGlhc2luZylcbiAgIDIuIHRoZSB0eXBlciBpbiBvY2FtbCA0LjAxIGFsbG93cyB0aGlzOlxuXG4gICB7W1xuICAgICBtb2R1bGUgQSA9IHN0cnVjdFxuICAgICAgIHR5cGUgdCA9IHthIDogaW50fVxuICAgICBlbmRcbiAgICAgdHlwZSB0ID0gQS50XG4gICAgIGxldCBmICh4IDogdCkgPSB4LmFcbiAgIF19XG5cbiAgIChhbHRob3VnaCB3aXRoIFdhcm5pbmcgNDA6IGEgaXMgdXNlZCBvdXQgb2Ygc2NvcGUpXG4gICB3aGljaCBtZWFucyB0aGF0IGlmIFt0X3dpdGhfcGVybV0gd2FzIHJlYWxseSBhbiBhbGlhcyBvbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdLFxuICAgcGVvcGxlIGNvdWxkIHNheSBbdC5zZXR0ZXJdIGFuZCBicmVhayB0aGUgYWJzdHJhY3Rpb24gd2l0aCBubyBpbmRpY2F0aW9uIHRoYXRcbiAgIHNvbWV0aGluZyB1Z2x5IGlzIGdvaW5nIG9uIGluIHRoZSBzb3VyY2UgY29kZS5cbiAgIFRoZSB3YXJuaW5nIGlzIChJIHRoaW5rKSBmb3IgcGVvcGxlIHdobyB3YW50IHRvIG1ha2UgdGhlaXIgY29kZSBjb21wYXRpYmxlIHdpdGhcbiAgIHByZXZpb3VzIHZlcnNpb25zIG9mIG9jYW1sLCBzbyB3ZSBtYXkgdmVyeSB3ZWxsIHR1cm4gaXQgb2ZmLlxuXG4gICBUaGUgdHlwZSB0X3dpdGhfcGVybSBjb3VsZCBhbHNvIGhhdmUgYmVlbiBhIFt1bml0IC0+IEZvcl9nZW5lcmF0ZWRfY29kZS50XSB0byB3b3JrXG4gICBhcm91bmQgdmFsdWUgcmVzdHJpY3Rpb24gYW5kIHRoZW4gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSB3b3VsZCBoYXZlIGJlZW4gYSBwcm9wZXJcbiAgIGFic3RyYWN0IHR5cGUsIGJ1dCBpdCBsb29rcyBsaWtlIGl0IGNvdWxkIGltcGFjdCBwZXJmb3JtYW5jZSAoZm9yIGV4YW1wbGUsIGEgZm9sZCBvbiBhXG4gICByZWNvcmQgdHlwZSB3aXRoIDQwIGZpZWxkcyB3b3VsZCBhY3R1YWxseSBhbGxvY2F0ZSB0aGUgNDAgW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSdzIGF0XG4gICBldmVyeSBzaW5nbGUgZm9sZC4pICopXG5cbm1vZHVsZSBGb3JfZ2VuZXJhdGVkX2NvZGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgeyBmb3JjZV92YXJpYW5jZSA6ICdwZXJtIC0+IHVuaXRcbiAgICA7ICgqIGZvcmNlIFt0XSB0byBiZSBjb250cmF2YXJpYW50IGluIFsncGVybV0sIGJlY2F1c2UgcGhhbnRvbSB0eXBlIHZhcmlhYmxlcyBvblxuICAgICAgICAgY29uY3JldGUgdHlwZXMgZG9uJ3Qgd29yayB0aGF0IHdlbGwgb3RoZXJ3aXNlICh1c2luZyA6PiBjYW4gcmVtb3ZlIHRoZW0gZWFzaWx5KSAqKVxuICAgICAgbmFtZSA6IHN0cmluZ1xuICAgIDsgc2V0dGVyIDogKCdyZWNvcmQgLT4gJ2ZpZWxkIC0+IHVuaXQpIG9wdGlvblxuICAgIDsgZ2V0dGVyIDogJ3JlY29yZCAtPiAnZmllbGRcbiAgICA7IGZzZXQgOiAncmVjb3JkIC0+ICdmaWVsZCAtPiAncmVjb3JkXG4gICAgfVxuXG4gIGxldCBvcGFxdWVfaWRlbnRpdHkgPSBTeXMwLm9wYXF1ZV9pZGVudGl0eVxuZW5kXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtID1cbiAgfCBGaWVsZCBvZiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgRm9yX2dlbmVyYXRlZF9jb2RlLnRcbltAQHVuYm94ZWRdXG5cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9IChbIGBSZWFkIHwgYFNldF9hbmRfY3JlYXRlIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgcmVhZG9ubHlfdCA9IChbIGBSZWFkIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cblxubGV0IG5hbWUgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLm5hbWVcbmxldCBnZXQgKEZpZWxkIGZpZWxkKSByID0gZmllbGQuZ2V0dGVyIHJcbmxldCBmc2V0IChGaWVsZCBmaWVsZCkgciB2ID0gZmllbGQuZnNldCByIHZcbmxldCBzZXR0ZXIgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLnNldHRlclxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ3Jlc3VsdCkgdXNlciA9XG4gIHsgZiA6ICdmaWVsZC4gKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtIC0+ICdyZXN1bHQgfVxuXG5sZXQgbWFwIChGaWVsZCBmaWVsZCkgciB+ZiA9IGZpZWxkLmZzZXQgciAoZiAoZmllbGQuZ2V0dGVyIHIpKVxuXG5sZXQgdXBkYXRlciAoRmllbGQgZmllbGQpID1cbiAgbWF0Y2ggZmllbGQuc2V0dGVyIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHNldHRlciAtPiBTb21lIChmdW4gciB+ZiAtPiBzZXR0ZXIgciAoZiAoZmllbGQuZ2V0dGVyIHIpKSlcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJvcGFxdWVfaWRlbnRpdHkiLCJGb3JfZ2VuZXJhdGVkX2NvZGUiLCJuYW1lIiwicGFyYW0iLCJnZXQiLCJyIiwiZnNldCIsInYiLCJzZXR0ZXIiLCJtYXAiLCJ1cGRhdGVyIiwibWF0Y2giLCJCYXNlX0ZpZWxkIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsZ0JBQUE7QUFBQSxPQUFBQyxxQkFBQTtBQUFBLFlBQUFDLEtBQUFDLE9Dc0R5QixnQkFBVTtBQUFBLFlBQUFDLElBQUFELE9BQUFFLEdBQ1QsOEJBQWM7QUFBQSxZQUFBQyxLQUFBSCxPQUFBRSxHQUFBRSxHQUNYLGlDQUFjO0FBQUEsWUFBQUMsT0FBQUwsT0FDaEIsZ0JBQVk7QUFBQSxZQUFBTSxJQUFBTixPQUFBRSxHQUFBVDtBQUFBQSxRQUFBLElBS0csY0FBRztBQUFBLElBQWlCO0FBQUE7QUFBQSxZQUFBYyxRQUFBUDtBQUFBQSxRQUFBUSxRQUc1RDtBQUFBLGdCQUNVO0FBQUEsUUFBQUgsU0FEVjtBQUFBLElBRWlCO0FBQUEscUJBQUFILEdBQUFUO0FBQUFBLGFBQThCLE9BQWlCO0FBQUEsaUNBQXBCLGNBQUcseUJBQWlCO0FBQUEsY0FBL0M7QUFBQSxHQUFnRDtBQUFBO0FBQUEsSUFBQWdCO0FBQUFBLE1EbkVuRSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5NzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaW50X2NvbnZlcnNpb25zLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGNvbnZlcnRfZmFpbHVyZSB4IGEgYiB0b19zdHJpbmcgPVxuICBQcmludGYuZmFpbHdpdGhmXG4gICAgXCJjb252ZXJzaW9uIGZyb20gJXMgdG8gJXMgZmFpbGVkOiAlcyBpcyBvdXQgb2YgcmFuZ2VcIlxuICAgIGFcbiAgICBiXG4gICAgKHRvX3N0cmluZyB4KVxuICAgICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgbnVtX2JpdHNfaW50ID0gU3lzLmludF9zaXplX2luX2JpdHNcbmxldCBudW1fYml0c19pbnQzMiA9IDMyXG5sZXQgbnVtX2JpdHNfaW50NjQgPSA2NFxubGV0IG51bV9iaXRzX25hdGl2ZWludCA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA9IDYzIHx8IG51bV9iaXRzX2ludCA9IDMxIHx8IG51bV9iaXRzX2ludCA9IDMyKVxubGV0IG1pbl9pbnQzMiA9IFN0ZGxpYi5JbnQzMi5taW5faW50XG5sZXQgbWF4X2ludDMyID0gU3RkbGliLkludDMyLm1heF9pbnRcbmxldCBtaW5faW50NjQgPSBTdGRsaWIuSW50NjQubWluX2ludFxubGV0IG1heF9pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5tYXhfaW50XG5sZXQgbWluX25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQubWluX2ludFxubGV0IG1heF9uYXRpdmVpbnQgPSBTdGRsaWIuTmF0aXZlaW50Lm1heF9pbnRcbmxldCBpbnRfdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9pbnRcbmxldCBpbnQzMl90b19zdHJpbmcgPSBTdGRsaWIuSW50MzIudG9fc3RyaW5nXG5sZXQgaW50NjRfdG9fc3RyaW5nID0gU3RkbGliLkludDY0LnRvX3N0cmluZ1xubGV0IG5hdGl2ZWludF90b19zdHJpbmcgPSBTdGRsaWIuTmF0aXZlaW50LnRvX3N0cmluZ1xuXG4oKiBpbnQgPC0+IGludDMyICopXG5cbmxldCBpbnRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnRcIiBcImludDMyXCIgaW50X3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDMyXCIgXCJpbnRcIiBpbnQzMl90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfdHJ1bmMgPSBTdGRsaWIuSW50MzIudG9faW50XG5sZXQgaW50X3RvX2ludDMyX3RydW5jID0gU3RkbGliLkludDMyLm9mX2ludFxuXG5sZXQgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19pbnRfdHJ1bmMgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX2ludF90cnVuYyBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1pbl92YWx1ZSBpblxuICAgIGxldCBtYXggPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50MzIgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDMyIHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50X3RvX2ludDMyIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDMyX3RvX2ludCB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDMyX3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gaW50X3RvX2ludDMyX3RydW5jIHggZWxzZSBpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG5sZXQgaW50MzJfdG9faW50X2V4biB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDMyX3RvX2ludF90cnVuYyB4IGVsc2UgaW50MzJfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBpbnQ2NCAqKVxuXG5sZXRbQGNvbGRdIGludDY0X3RvX2ludF9mYWlsdXJlIHggPVxuICBjb252ZXJ0X2ZhaWx1cmVcbiAgICAoU3RkbGliLkludDY0LmFkZCB4IDBMICgqIGZvcmNlIGludDY0IGJveGluZyB0byBiZSBoZXJlIHVuZGVyIGZsYW1iZGEyICopKVxuICAgIFwiaW50NjRcIlxuICAgIFwiaW50XCJcbiAgICBpbnQ2NF90b19zdHJpbmdcbjs7XG5cbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDwgbnVtX2JpdHNfaW50NjQpXG5sZXQgaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX2ludFxubGV0IGludDY0X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQub2ZfaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludF90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50XG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX25hdGl2ZWludCBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19uYXRpdmVpbnQgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50IHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludF90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50MzJcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnQzMl90b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gU3RkbGliLkludDY0LnRvX2ludDMyXG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgbGV0IG1pbiA9IGludDMyX3RvX2ludDY0IG1pbl9pbnQzMiBpblxuICBsZXQgbWF4ID0gaW50MzJfdG9faW50NjQgbWF4X2ludDMyIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMiB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBpbnQ2NF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQzMiA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4ID1cbiAgY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludDMyXCIgbmF0aXZlaW50X3RvX3N0cmluZ1xuOztcblxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50MzJfdG9fbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMlxubGV0IG5hdGl2ZWludF90b19pbnQzMl90cnVuYyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBTdGRsaWIuSW50NjQudG9fbmF0aXZlaW50XG5sZXQgbmF0aXZlaW50X3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX25hdGl2ZWludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgPVxuICBpZiBudW1fYml0c19pbnQ2NCA8PSBudW1fYml0c19uYXRpdmVpbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBuYXRpdmVpbnRfdG9faW50NjQgbWluX25hdGl2ZWludCBpblxuICAgIGxldCBtYXggPSBuYXRpdmVpbnRfdG9faW50NjQgbWF4X25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gU29tZSAoaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBpbnQ2MyAqKVxuXG5sZXQgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50NjNcIiBpbnQ2NF90b19zdHJpbmdcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgPVxuICBsZXQgbWluID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgbWF4X2ludDY0IDEgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X2ZpdF9vbl9pbnQ2M19leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuICgpIGVsc2UgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4XG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfaW50IiwiY3N0X2ludDMyIiwiY3N0X2ludDY0IiwiY3N0X25hdGl2ZWludCIsImNzdF9zcmNfaW50X2NvbnZlcnNpb25zX21sIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9QcmludGYiLCJCYXNlX1N5czAiLCJCYXNlX1dvcmRfc2l6ZSIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0ludDMyIiwiU3RkbGliX0ludDY0IiwiU3RkbGliX05hdGl2ZWludCIsIkJhc2VfSW50MCIsImNvbnZlcnRfZmFpbHVyZSIsIngiLCJhIiwiYiIsInRvX3N0cmluZyIsIm51bV9iaXRzX2ludCIsIm51bV9iaXRzX25hdGl2ZWludCIsImNzdF9pbnQ2MyIsIm51bV9iaXRzX2ludDMyIiwibnVtX2JpdHNfaW50NjQiLCJtaW5faW50MzIiLCJtYXhfaW50MzIiLCJtaW5faW50NjQiLCJtYXhfaW50NjQiLCJtaW5fbmF0aXZlaW50IiwibWF4X25hdGl2ZWludCIsImludF90b19zdHJpbmciLCJpbnQzMl90b19zdHJpbmciLCJpbnQ2NF90b19zdHJpbmciLCJuYXRpdmVpbnRfdG9fc3RyaW5nIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50X3RvX2ludDMyX3RydW5jIiwiaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIiLCJwYXJhbSIsIm1pbiIsIm1heCIsImludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50X3RvX2ludDMyIiwiaW50MzJfdG9faW50IiwiaW50X3RvX2ludDMyX2V4biIsImludDMyX3RvX2ludF9leG4iLCJpbnRfdG9faW50NjQiLCJpbnQ2NF90b19pbnRfdHJ1bmMiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCIsImludDY0X3RvX2ludCIsImludDY0X3RvX2ludF9leG4iLCJpbnRfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludF90cnVuYyIsIm5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzXyIsIm5hdGl2ZWludF90b19pbnQiLCJuYXRpdmVpbnRfdG9faW50X2V4biIsImludDMyX3RvX2ludDY0IiwiaW50NjRfdG9faW50MzJfdHJ1bmMiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMiLCJpbnQ2NF90b19pbnQzMiIsImludDY0X3RvX2ludDMyX2V4biIsImludDMyX3RvX25hdGl2ZWludCIsIm5hdGl2ZWludF90b19pbnQzMl90cnVuYyIsIm5hdGl2ZWludF90b19pbnQzMiIsIm5hdGl2ZWludF90b19pbnQzMl9leG4iLCJpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50NjQiLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGkiLCJpbnQ2NF90b19uYXRpdmVpbnQiLCJpbnQ2NF90b19uYXRpdmVpbnRfZXhuIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2IiwiaW50NjRfZml0X29uX2ludDYzX2V4biIsIkJhc2VfSW50X2NvbnZlcnNpb25zIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxnQkFBQUMsR0FBQUMsS0FBQUMsR0FBQUM7QUFBQUEsUUFBQSxJQ1NJO0FBQUEsSUFBYSw2REFDWDtBQUFBO0FBQUE7QUFBQSxJQUFBQyxlRFZOO0FBQUEsSUFBQUMscUJDaUJ5QjtBQUFBLElBQUFDLFlBQXNDO0FBQUEsSUFBQWpDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFELGNBQUE7QUFBQSxJQUFBRCxjQUFBO0FBQUEsSUFBQUUsa0JBQUE7QUFBQSxJQUFBRixjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFGLFlBQUE7QUFBQSxJQUFBRyxnQkFBQTtBQUFBLElBQUFILFlBQUE7QUFBQSxJQUFBRSxZQUFBO0FBQUE7QUFBQSxJQUFBRixZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBRCxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFvQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLG1CQUFBLEdEakIvRDtBQUFBLFlBQUFDLG1CQUFBO0FBQUEsR0NpQitEO0FBQUEsUUFBQUMsZ0NBc0J4RCxTQUFBQyxPQUFTLFNBQUk7QUFBQTtBQUFBO0FBQUEsS0FBQUMsUUFFTjtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxLQUFBSDtBQUFBQSxPQUNWLFNBQUFyQjtBQUFBQTtBQUFBQSxTQUFBLElBQVM7QUFBQSxhQUFpQixJQUFTO0FBQUEsUUFBVDtBQUFBLE9BQStCO0FBQUEsR0ExQkU7QUFBQSxRQUFBeUIsZ0NBK0J4RCxTQUFBSCxPQUFTLFNBQUk7QUFBQTtBQUFBO0FBQUEsS0FBQUMsUUFFTjtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxLQUFBQztBQUFBQSxPQUNWLFNBQUF6QjtBQUFBQTtBQUFBQSxTQUFBLElBQVM7QUFBQSxhQUFtQixJQUFTO0FBQUEsUUFBVDtBQUFBLE9BQWlDO0FBQUEsWUFBQTBCLGFBQUExQjtBQUFBQSxJQUk1RCxvREFBMEU7QUFBQTtBQUFBLFlBQUEyQixhQUFBM0I7QUFBQUEsSUFJMUUsb0RBQTBFO0FBQUE7QUFBQSxZQUFBNEIsaUJBQUE1QjtBQUFBQSxJQUkxRTtBQUFBO0FBQUEsY0FoQ3dCLHFEQWdDNkQ7QUFBQTtBQUFBLFlBQUE2QixpQkFBQTdCO0FBQUFBLElBSXJGO0FBQUE7QUFBQSxjQW5Dd0IsMkRBbUM2RDtBQUFBO0FBQUEsR0FuRDNCO0FBQUE7QUFBQTtBQUFBLElBQUE4QixlQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBUixRQXFFbkQ7QUFBQSxJQUFBQyxRQUNBO0FBQUEsWUFBQVEsOEJBQUFoQztBQUFBQTtBQUFBQSxLQUFBLElBQ0Q7QUFBQSxTQUFtQixJQUFTO0FBQUEsSUFBVDtBQUFBLEdBQWlDO0FBQUEsWUFBQWlDLGFBQUFqQztBQUFBQSxJQUkxRCw4Q0FBMEMsMkJBQWdDO0FBQUE7QUFBQSxZQUFBa0MsaUJBQUFsQztBQUFBQSxJQUkxRTtBQUFBLGNBQXFDO0FBQUEsY0FyQm9DO0FBQUEsZUFBMUU7QUFBQTtBQUFBO0FBQUEsK0JBcUJzRjtBQUFBO0FBQUEsR0FSeEY7QUFBQTtBQUFBLFlBQUFtQyxpQkFBQSxHRHhGRjtBQUFBLFlBQUFDLHVCQUFBO0FBQUEsR0N3RkU7QUFBQSxRQUFBQyxpQ0FvQkssU0FBQWYsT0FBUyxTQUFJO0FBQUE7QUFBQTtBQUFBLEtBQUFDLFFBRU47QUFBQSxLQUFBQyxRQUNBO0FBQUEsS0FBQWE7QUFBQUEsT0FDVixTQUFBckM7QUFBQUE7QUFBQUEsU0FBQSxJQUFTO0FBQUEsYUFBdUIsSUFBUztBQUFBLFFBQVQ7QUFBQSxPQUFxQztBQUFBLFlBQUFzQyxpQkFBQXRDO0FBQUFBLElBSXBFLHFEQUFrRjtBQUFBO0FBQUEsWUFBQXVDLHFCQUFBdkM7QUFBQUEsSUFJbEY7QUFBQTtBQUFBLGNBbkI0QjtBQUFBLGdFQXFCQTtBQUFBO0FBQUE7QUFBQSxJQUFBd0MsaUJBbEMvQjtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQWxCLFFBNkNVO0FBQUEsSUFBQUMsUUFDQTtBQUFBLFlBQUFrQiwrQkFBQTFDO0FBQUFBO0FBQUFBLEtBQUEsSUFDRDtBQUFBLFNBQW1CLElBQVM7QUFBQSxJQUFUO0FBQUEsR0FBaUM7QUFBQSxZQUFBMkMsZUFBQTNDO0FBQUFBLElBSTFELCtDQUE0QywyQkFBa0M7QUFBQTtBQUFBLFlBQUE0QyxtQkFBQTVDO0FBQUFBLElBSTlFO0FBQUEsY0FDRTtBQUFBLGNBakJ3Qiw2REFrQkE7QUFBQTtBQUFBLEdBVjdCO0FBQUE7QUFBQSxZQUFBNkMsbUJBQUEsR0R2SUY7QUFBQSxZQUFBQyx5QkFBQTtBQUFBLEdDdUlFO0FBQUEsUUFBQVQsbUNBeUJLLFNBQUFmLE9BQVMsU0FBSTtBQUFBO0FBQUE7QUFBQSxLQUFBQyxRQUVOO0FBQUEsS0FBQUMsUUFDQTtBQUFBLEtBQUFhO0FBQUFBLE9BQ1YsU0FBQXJDO0FBQUFBO0FBQUFBLFNBQUEsSUFBUztBQUFBLGFBQXVCLElBQVM7QUFBQSxRQUFUO0FBQUEsT0FBcUM7QUFBQSxZQUFBK0MsbUJBQUEvQztBQUFBQSxJQUlwRSx1REFFTTtBQUFBO0FBQUEsWUFBQWdELHVCQUFBaEQ7QUFBQUEsSUFJTjtBQUFBO0FBQUEsY0F2Qkg7QUFBQSxvRUF5QmlDO0FBQUE7QUFBQSxHQXpDakM7QUFBQTtBQUFBO0FBQUEsSUFBQWlELDJCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQTtBQUFBLFFBQUFDLGlDQXFESyxTQUFBN0IsT0FBUyxTQUFJO0FBQUE7QUFBQTtBQUFBLEtBQUFDLFFBRU47QUFBQSxLQUFBQyxRQUNBO0FBQUEsS0FBQTJCO0FBQUFBLE9BQ1YsU0FBQW5EO0FBQUFBO0FBQUFBLFNBQUEsSUFBUztBQUFBLGFBQW1CLElBQVM7QUFBQSxRQUFUO0FBQUEsT0FBaUM7QUFBQSxZQUFBb0QsbUJBQUFwRDtBQUFBQSxJQUk1RCwrQ0FDTywyQkFDRDtBQUFBO0FBQUEsWUFBQXFELHVCQUFBckQ7QUFBQUEsSUFJTjtBQUFBLGNBQ0U7QUFBQSxjQXRCNEI7QUFBQSxnRUF1QkE7QUFBQTtBQUFBO0FBQUEsSUFBQXVCLE1BUXZCO0FBQUEsSUFBQUMsTUFDQTtBQUFBLFlBQUE4QiwrQkFBQXREO0FBQUFBO0FBQUFBLEtBQUEsSUFDRDtBQUFBLFNBQW1CLElBQVM7QUFBQSxJQUFUO0FBQUEsR0FBaUM7QUFBQSxZQUFBdUQsdUJBQUF2RDtBQUFBQSxJQUkxRDtBQUFBO0FBQUEsY0FUMEIsMkRBUzZDO0FBQUE7QUFBQTtBQUFBLElBQUF3RDtBQUFBQSxNQUoxRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEdE5GIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTI5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1VjaGFyIiwic3VjYyIsInByZWQiLCJpc192YWxpZCIsImlzX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsInVuc2FmZV9vZl9pbnQiLCJvZl9pbnQiLCJ0b19pbnQiLCJvZl9jaGFyIiwiY29tcGFyZSIsImVxdWFsIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwiYnl0ZV9vcmRlcl9tYXJrIiwicmVwbGFjZW1lbnRfY2hhciIsInV0Zl84X2J5dGVfbGVuZ3RoIiwidXRmXzE2X2J5dGVfbGVuZ3RoIiwidXRmX2RlY29kZV9pc192YWxpZCIsInV0Zl9kZWNvZGVfdWNoYXIiLCJ1dGZfZGVjb2RlX2xlbmd0aCIsInV0Zl9kZWNvZGUiLCJ1dGZfZGVjb2RlX2ludmFsaWQiLCJCYXNlX1VjaGFyMCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjUzNTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvc3RyaW5nMC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFtTdHJpbmcwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtTdGRsaWIuU3RyaW5nXS4gW1N0cmluZzBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZlxuICAgW1N0ZGxpYi5TdHJpbmddIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3RyaW5nMC5tbCBzaG91bGRcbiAgIHVzZSBbU3RkbGliLlN0cmluZ10uICBbU3RyaW5nMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzXG4gICBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzLCBpbmNsdWRpbmcgdGhlIHN1YnNjcmlwdCBzeW50YXggW3guW2ldXSB3aGljaFxuICAgdGhlIE9DYW1sIHBhcnNlciBkZXN1Z2FycyBpbnRvIGNhbGxzIHRvIFtTdHJpbmddLCBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuU3RyaW5nXSBpblxuICAgYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG5cbiAgIHtbXG4gICAgIG1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIFN0cmluZyA9IFN0cmluZzBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHNcbiAgIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuU3RyaW5nXS4gKilcblxub3BlbiEgSW1wb3J0MFxuXG5vcGVuIHN0cnVjdFxuICBtb2R1bGUgU3lzID0gU3lzMFxuICBtb2R1bGUgVWNoYXIgPSBVY2hhcjBcbmVuZFxuXG5tb2R1bGUgU3RyaW5nID0gc3RydWN0XG4gIGV4dGVybmFsIGdldCA6IChzdHJpbmdbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiAoc3RyaW5nW0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0XG4gICAgOiAgKHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGNoYXJcbiAgICA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmVuZFxuXG5pbmNsdWRlIFN0cmluZ1xuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0ICggXiApID0gKCBeIClcbmxldCBjYXBpdGFsaXplID0gU3RkbGliLlN0cmluZy5jYXBpdGFsaXplX2FzY2lpXG5sZXQgY29tcGFyZSA9IFN0ZGxpYi5TdHJpbmcuY29tcGFyZVxubGV0IGVzY2FwZWQgPSBTdGRsaWIuU3RyaW5nLmVzY2FwZWRcbmxldCBsb3dlcmNhc2UgPSBTdGRsaWIuU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxubGV0IG1ha2UgPSBTdGRsaWIuU3RyaW5nLm1ha2VcbmxldCBzdWIgPSBTdGRsaWIuU3RyaW5nLnN1YlxubGV0IHVuY2FwaXRhbGl6ZSA9IFN0ZGxpYi5TdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpXG5sZXQgdXBwZXJjYXNlID0gU3RkbGliLlN0cmluZy51cHBlcmNhc2VfYXNjaWlcbmxldCBpc192YWxpZF91dGZfOCA9IFN0ZGxpYi5TdHJpbmcuaXNfdmFsaWRfdXRmXzhcbmxldCBpc192YWxpZF91dGZfMTZsZSA9IFN0ZGxpYi5TdHJpbmcuaXNfdmFsaWRfdXRmXzE2bGVcbmxldCBpc192YWxpZF91dGZfMTZiZSA9IFN0ZGxpYi5TdHJpbmcuaXNfdmFsaWRfdXRmXzE2YmVcbmxldCBnZXRfdXRmXzhfdWNoYXIgdCB+Ynl0ZV9wb3MgPSBTdGRsaWIuU3RyaW5nLmdldF91dGZfOF91Y2hhciB0IGJ5dGVfcG9zXG5sZXQgZ2V0X3V0Zl8xNmxlX3VjaGFyIHQgfmJ5dGVfcG9zID0gU3RkbGliLlN0cmluZy5nZXRfdXRmXzE2bGVfdWNoYXIgdCBieXRlX3Bvc1xubGV0IGdldF91dGZfMTZiZV91Y2hhciB0IH5ieXRlX3BvcyA9IFN0ZGxpYi5TdHJpbmcuZ2V0X3V0Zl8xNmJlX3VjaGFyIHQgYnl0ZV9wb3Ncblxub3BlbiBzdHJ1Y3RcbiAgbGV0IGdldF91dGZfMzJfdWNoYXIgfmdldF9pbnQzMiB0IH5ieXRlX3BvcyA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggdCBpblxuICAgIG1hdGNoIGJ5dGVfcG9zID49IDAgJiYgYnl0ZV9wb3MgPCBsZW4gd2l0aFxuICAgIHwgZmFsc2UgLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG4gICAgfCB0cnVlIC0+XG4gICAgICAobWF0Y2ggbGVuIC0gYnl0ZV9wb3Mgd2l0aFxuICAgICAgIHwgKDEgfCAyIHwgMykgYXMgYnl0ZXNfcmVhZCAtPlxuICAgICAgICAgKCogRmV3ZXIgdGhhbiA0IGJ5dGVzIHJlbWFpbiBpbiBbdF0sIHNvIHdlIGtub3cgdGhlIGRlY29kaW5nIGlzIGludmFsaWQuICopXG4gICAgICAgICBVY2hhci51dGZfZGVjb2RlX2ludmFsaWQgYnl0ZXNfcmVhZFxuICAgICAgIHwgXyAtPlxuICAgICAgICAgbGV0IGludDMyID0gZ2V0X2ludDMyIHQgYnl0ZV9wb3MgaW5cbiAgICAgICAgIChtYXRjaCBJbnRfY29udmVyc2lvbnMuaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgaW50MzIgd2l0aFxuICAgICAgICAgIHwgZmFsc2UgLT4gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkIDRcbiAgICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICAgIGxldCBpbnQgPSBJbnRfY29udmVyc2lvbnMuaW50MzJfdG9faW50X3RydW5jIGludDMyIGluXG4gICAgICAgICAgICAobWF0Y2ggVWNoYXIuaXNfdmFsaWQgaW50IHdpdGhcbiAgICAgICAgICAgICB8IHRydWUgLT4gVWNoYXIudXRmX2RlY29kZSA0IChVY2hhci51bnNhZmVfb2ZfaW50IGludClcbiAgICAgICAgICAgICB8IGZhbHNlIC0+IFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZCA0KSkpXG4gIDs7XG5lbmRcblxubGV0IGdldF91dGZfMzJsZV91Y2hhciB0IH5ieXRlX3BvcyA9XG4gIGdldF91dGZfMzJfdWNoYXIgdCB+Ynl0ZV9wb3MgfmdldF9pbnQzMjpTdGRsaWIuU3RyaW5nLmdldF9pbnQzMl9sZVxuOztcblxubGV0IGdldF91dGZfMzJiZV91Y2hhciB0IH5ieXRlX3BvcyA9XG4gIGdldF91dGZfMzJfdWNoYXIgdCB+Ynl0ZV9wb3MgfmdldF9pbnQzMjpTdGRsaWIuU3RyaW5nLmdldF9pbnQzMl9iZVxuOztcblxubGV0IGNvbmNhdCA/KHNlcCA9IFwiXCIpIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIlwiXG4gICgqIFRoZSBzdGRsaWIgZG9lcyBub3Qgc3BlY2lhbGl6ZSB0aGlzIGNhc2UgYmVjYXVzZSBpdCBjb3VsZCBicmVhayBleGlzdGluZyBwcm9qZWN0cy4gKilcbiAgfCBbIHggXSAtPiB4XG4gIHwgbCAtPiBTdGRsaWIuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBzcGxpdF9saW5lcyA9XG4gIGxldCBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sID1cbiAgICBwb3MgOj0gIXBvcyAtIGlmICFwb3MgPiAwICYmIENoYXIwLmVxdWFsIHQuWyFwb3MgLSAxXSAnXFxyJyB0aGVuIDIgZWxzZSAxO1xuICAgIGVvbCA6PSAhcG9zICsgMVxuICBpblxuICBmdW4gdCAtPlxuICAgIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgICgqIEludmFyaWFudDogWy0xIDw9IHBvcyA8IGVvbF0uICopXG4gICAgICBsZXQgcG9zID0gcmVmIChuIC0gMSkgaW5cbiAgICAgIGxldCBlb2wgPSByZWYgbiBpblxuICAgICAgbGV0IGFjID0gcmVmIFtdIGluXG4gICAgICAoKiBXZSB0cmVhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgc3BlY2lhbGx5LCBiZWNhdXNlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGFcbiAgICAgICAgIG5ld2xpbmUsIHdlIGRvbid0IHdhbnQgYW4gZXh0cmEgZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG91dHB1dC4gKilcbiAgICAgIGlmIENoYXIwLmVxdWFsIHQuWyFwb3NdICdcXG4nIHRoZW4gYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbDtcbiAgICAgIHdoaWxlICFwb3MgPj0gMCBkb1xuICAgICAgICBpZiBub3QgKENoYXIwLmVxdWFsIHQuWyFwb3NdICdcXG4nKVxuICAgICAgICB0aGVuIGRlY3IgcG9zXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIEJlY2F1c2UgW3BvcyA8IGVvbF0sIHdlIGtub3cgdGhhdCBbc3RhcnQgPD0gZW9sXS4gKilcbiAgICAgICAgICBsZXQgc3RhcnQgPSAhcG9zICsgMSBpblxuICAgICAgICAgIGFjIDo9IHN1YiB0IH5wb3M6c3RhcnQgfmxlbjooIWVvbCAtIHN0YXJ0KSA6OiAhYWM7XG4gICAgICAgICAgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbClcbiAgICAgIGRvbmU7XG4gICAgICBzdWIgdCB+cG9zOjAgfmxlbjohZW9sIDo6ICFhYylcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0MCIsIkJhc2VfQ2hhcjAiLCJTdGRsaWJfU3RyaW5nTGFiZWxzIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX1VjaGFyMCIsIlN0ZGxpYiIsIkJhc2VfU3lzMCIsIlN0cmluZyIsIm1heF9sZW5ndGgiLCJzeW1ib2xfY29uY2F0IiwiY2FwaXRhbGl6ZSIsImNvbXBhcmUiLCJlc2NhcGVkIiwibG93ZXJjYXNlIiwibWFrZSIsInN1YiIsInVuY2FwaXRhbGl6ZSIsInVwcGVyY2FzZSIsImlzX3ZhbGlkX3V0Zl84IiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJpc192YWxpZF91dGZfMTZiZSIsImNzdF9pbmRleF9vdXRfb2ZfYm91bmRzIiwiZHVtbXkiLCJnZXRfdXRmXzhfdWNoYXIiLCJ0IiwiYnl0ZV9wb3MiLCJnZXRfdXRmXzE2bGVfdWNoYXIiLCJnZXRfdXRmXzE2YmVfdWNoYXIiLCJnZXRfdXRmXzMyX3VjaGFyIiwiZ2V0X2ludDMyIiwibGVuIiwibWF0Y2giLCJieXRlc19yZWFkIiwiaW50MzIiLCJpbnQiLCJnZXRfdXRmXzMybGVfdWNoYXIiLCJnZXRfdXRmXzMyYmVfdWNoYXIiLCJjb25jYXQiLCJvcHQiLCJsIiwic2VwIiwieCIsIml0ZXIiLCJpIiwiYmFja191cF9hdF9uZXdsaW5lIiwicG9zIiwiZW9sIiwic3BsaXRfbGluZXMiLCJuIiwiYWMiLCJzdGFydCIsIkJhc2VfU3RyaW5nMCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsWUFBQUMs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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHZHRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU1MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24wLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RkbGliLkxleGluZy5wb3NpdGlvbiA9XG4gICAgeyBwb3NfZm5hbWUgOiBzdHJpbmdcbiAgICA7IHBvc19sbnVtIDogaW50XG4gICAgOyBwb3NfYm9sIDogaW50XG4gICAgOyBwb3NfY251bSA6IGludFxuICAgIH1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9XG4gICAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmdfX2xvY2FsIGFfXzAwMV8ucG9zX2ZuYW1lIGJfXzAwMl8ucG9zX2ZuYW1lIHdpdGhcbiAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnRfX2xvY2FsIGFfXzAwMV8ucG9zX2xudW0gYl9fMDAyXy5wb3NfbG51bSB3aXRoXG4gICAgICAgICAgICB8IDAgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50X19sb2NhbCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludF9fbG9jYWwgYV9fMDAxXy5wb3NfY251bSBiX18wMDJfLnBvc19jbnVtXG4gICAgICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICA6IHQgLT4gdCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBmdW4gaHN2IGFyZyAtPlxuICAgIGxldCBoc3YgPVxuICAgICAgbGV0IGhzdiA9XG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICBoYXNoX2ZvbGRfc3RyaW5nIGhzdiBhcmcucG9zX2ZuYW1lXG4gICAgICAgIGluXG4gICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfYm9sXG4gICAgaW5cbiAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2NudW1cbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuIHsgcG9zX2ZuYW1lID0gcG9zX2ZuYW1lX18wMDRfXG4gICAgICAgICA7IHBvc19sbnVtID0gcG9zX2xudW1fXzAwNl9cbiAgICAgICAgIDsgcG9zX2JvbCA9IHBvc19ib2xfXzAwOF9cbiAgICAgICAgIDsgcG9zX2NudW0gPSBwb3NfY251bV9fMDEwX1xuICAgICAgICAgfSAtPlxuICAgICAgIGxldCBibmRzX18wMDNfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19jbnVtXCI7IGFyZ19fMDExXyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19ib2xcIjsgYXJnX18wMDlfIF0gOjogYm5kc19fMDAzX1xuICAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgICBpblxuICAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19sbnVtXCI7IGFyZ19fMDA3XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2ZuYW1lXCI7IGFyZ19fMDA1XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAzX1xuICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgZnVuY3Rpb24gYXMgUHB4X2hlcmUubGlmdF9wb3NpdGlvbl9hc19zdHJpbmcuICopXG5sZXQgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sID1cbiAgU3RyaW5nLmNvbmNhdFxuICAgIFsgcG9zX2ZuYW1lOyBcIjpcIjsgSW50LnRvX3N0cmluZyBwb3NfbG51bTsgXCI6XCI7IEludC50b19zdHJpbmcgKHBvc19jbnVtIC0gcG9zX2JvbCkgXVxuOztcblxubGV0IHRvX3N0cmluZyB7IFN0ZGxpYi5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgfSA9XG4gIG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbFxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfSW50MCIsIkJhc2VfU3RyaW5nMCIsIkJhc2VfSGFzaCIsIkJhc2VfQ29tcGFyYXRvciIsImNvbXBhcmVfbG9jYWwiLCJhXzAwMSIsImJfMDAyIiwibiIsImNvbXBhcmUiLCJhIiwiYiIsImhhc2hfZm9sZF90IiwiaHN2IiwiYXJnIiwiaGFzaCIsInNleHBfb2ZfdCIsInBhcmFtIiwicG9zX2NudW1fMDEwIiwicG9zX2JvbF8wMDgiLCJwb3NfbG51bV8wMDYiLCJwb3NfZm5hbWVfMDA0IiwiYXJnXzAxMSIsImJuZHNfMDAzIiwiYXJnXzAwOSIsImFyZ18wMDciLCJhcmdfMDA1IiwiVCIsImluY2x1ZGUiLCJjb21wYXJhdG9yIiwibWFrZV9sb2NhdGlvbl9zdHJpbmciLCJwb3NfZm5hbWUiLCJwb3NfbG51bSIsInBvc19jbnVtIiwicG9zX2JvbCIsInRvX3N0cmluZyIsInQiLCJCYXNlX1NvdXJjZV9jb2RlX3Bvc2l0aW9uMCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLFFBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUwsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBTSxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxRQ3FESTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGNBQUFDLE9BQUFDO0FBQUFBLElBdENHLG9CQUNLO0FBQUEsUUFBQUMsSUFFRztBQUFBLElBQXlELFlBUXhEO0FBQUEsUUFBQUEsTUFORTtBQUFBLElBQW9ELGNBS25EO0FBQUEsUUFBQUEsTUFIRTtBQUFBLElBQWtELG1CQUNqRCxzREFHSjtBQUFBO0FBQUEsWUFBQUMsUUFBQUMsR0FBQUMsR0FJVSwwQkFBa0I7QUFBQSxZQUFBQyxZQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBRCxRQVFwQztBQUFBLEtBQUFBLFFBRUY7QUFBQSxLQUFBQSxRQUVGO0FBQUEsSUFFRixrREFBOEI7QUFBQTtBQUFBLFlBQUFFLEtBQUFEO0FBQUFBLFFBQUFELE1BTWYsb0NBQ1Y7QUFBQSxJQUFtQixpQ0FFVDtBQUFBO0FBQUEsWUFBQUcsVUFBQUM7QUFBQUE7QUFBQUEsS0FBQUMsZUFJZDtBQUFBLEtBQUFDLGNBQUE7QUFBQSxLQUFBQyxlQUFBO0FBQUEsS0FBQUMsZ0JBQUE7QUFBQSxLQUFBQyxVQU9vQjtBQUFBLEtBQUFDLFdBQ2Y7QUFBQSxLQUFBQyxVQUllO0FBQUEsS0FBQUQsYUFDZjtBQUFBLEtBQUFFLFVBSWU7QUFBQSxLQUFBRixhQUNmO0FBQUEsS0FBQUcsVUFJZTtBQUFBLEtBQUFILGFBQ2Y7QUFBQSxJQUdIO0FBQUEsR0FBNkI7QUFBQTtBQUFBLElBQUFJLElBOUJoQztBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsWUFBQUMscUJBQUFDLFdBQUFDLFVBQUFDLFVBQUFDO0FBQUFBO0FBQUFBLEtBQUEsSUEyQzZEO0FBQUEsU0FBZDtBQUFBLFNBQTdCO0FBQUEsSUFBc0Isd0NBQTJDO0FBQUE7QUFBQSxZQUFBQyxVQUFBbEI7QUFBQUE7QUFBQUEsS0FBQWdCLFdBR3pFO0FBQUEsS0FBQUMsVUFBQTtBQUFBLEtBQUFGLFdBQUE7QUFBQSxLQUFBRCxZQUFBO0FBQUEsSUFDWixtRUFBNEQ7QUFBQTtBQUFBLFlBQUFmLFlBQUFvQixHQUdsQyx3QkFBYTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFsRHJDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURyREoiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1NjE4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9JbnZhcmlhbnRfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLHNCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTYzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9saXN0MS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaXN0MFxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCAoZiB4IDogXyBFaXRoZXIwLnQpIHdpdGhcbiAgICAgICB8IEZpcnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kXG4gICAgICAgfCBTZWNvbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXSBbQG5vbnRhaWxdXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0xpc3QwIiwiaGRfZXhuIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwibGVuZ3RoIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImZvbGQiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIiLCJpdGVyMl9vayIsIm5vbnRhaWxfbWFwIiwibm9udGFpbF9tYXBpIiwicGFydGl0aW9uIiwicmV2X21hcCIsInJldl9tYXAyX29rIiwicmV2IiwiZm9sZF9yaWdodCIsImZvbGRfcmlnaHQyX29rIiwiaXNfZW1wdHkiLCJwYXJhbSIsInBhcnRpdGlvbl9tYXAiLCJ0IiwiZnN0Iiwic25kIiwieCIsIm1hdGNoIiwieSIsIkJhc2VfTGlzdDEiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsU0FBQUMsT0NHZSxvQkFFRDtBQUFBLFlBQUFDLGNBQUFDLEdBQUE1QjtBQUFBQSxRQUFBNEIsTUFZWixHQUFBQyxNQUFBLEdBQUFDLE1BQUE7QUFBQTtBQUFBLEtBUEUsa0JBQ2lCLFVBQVQsdUJBQU87QUFBQSxTQUFBRixNQURmLFFBQUFHLElBQUEsUUFBQUMsUUFHVTtBQUFBLEtBQUc7QUFBQSxVQUFBQyxJQUFBLFVBQUFKLFFBQ0c7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBSSxNQURILFVBQUFILFFBRUk7QUFBQTtBQUFBLEdBRUk7QUFBQTtBQUFBLElBQUFJO0FBQUFBLE1EakJ6QiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU3MTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvcmVzdWx0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBTdGRsaWIucmVzdWx0ID1cbiAgfCBPayBvZiAnYVxuICB8IEVycm9yIG9mICdiXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG5sZXQgdF9vZl9zZXhwIDpcbiAgICAgICdhICdiLlxuICAgICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxN18pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKGFfXzAxN18sIGJfXzAxOF8pIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcInJlc3VsdC5tbC50XCIgaW5cbiAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwib2tcIiB8IFwiT2tcIikgYXMgX3RhZ19fMDA4XykgOjogc2V4cF9hcmdzX18wMDlfKSBhc1xuICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAwOV8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTBfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgT2sgcmVzMF9fMDExX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgX3RhZ19fMDA4X1xuICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBfdGFnX18wMTNfKSA6OiBzZXhwX2FyZ3NfXzAxNF8pIGFzXG4gICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE0XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNV8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICBFcnJvciByZXMwX18wMTZfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICBfdGFnX18wMTNfXG4gICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm9rXCIgfCBcIk9rXCIpIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgfCBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAgICAgJ2EgJ2IuXG4gICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBhX18wMjVfIGJfXzAyNl8pXG4gICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgZnVuIF9vZl9hX18wMTlfIF9vZl9iX18wMjBfIC0+IGZ1bmN0aW9uXG4gIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgIGxldCByZXMwX18wMjJfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIxXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAyMl8gXVxuICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICBsZXQgcmVzMF9fMDI0XyA9IF9vZl9iX18wMjBfIGFyZzBfXzAyM18gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFcnJvclwiOyByZXMwX18wMjRfIF1cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAnYSAnYi5cbiAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIk9rXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFcnJvclwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsIDpcbiAgICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMzNfIGJfXzAzNF8gLT5cbiAgaWYgU3RkbGliLiggPT0gKSBhX18wMzNfIGJfXzAzNF9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgIHwgT2sgX2FfXzAzNV8sIE9rIF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICB8IF8sIE9rIF8gLT4gMVxuICAgIHwgRXJyb3IgX2FfXzAzN18sIEVycm9yIF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF8pXG47O1xuXG5sZXQgY29tcGFyZSA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDI3XyBiX18wMjhfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDI3XyBiX18wMjhfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMjdfLCBiX18wMjhfIHdpdGhcbiAgICB8IE9rIF9hX18wMjlfLCBPayBfYl9fMDMwXyAtPiBfY21wX19hIF9hX18wMjlfIF9iX18wMzBfXG4gICAgfCBPayBfLCBfIC0+IC0xXG4gICAgfCBfLCBPayBfIC0+IDFcbiAgICB8IEVycm9yIF9hX18wMzFfLCBFcnJvciBfYl9fMDMyXyAtPiBfY21wX19iIF9hX18wMzFfIF9iX18wMzJfKVxuOztcblxubGV0IGVxdWFsX19sb2NhbCA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDQ1XyBiX18wNDZfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDQ1XyBiX18wNDZfXG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wNDVfLCBiX18wNDZfIHdpdGhcbiAgICB8IE9rIF9hX18wNDdfLCBPayBfYl9fMDQ4XyAtPiBfY21wX19hIF9hX18wNDdfIF9iX18wNDhfXG4gICAgfCBPayBfLCBfIC0+IGZhbHNlXG4gICAgfCBfLCBPayBfIC0+IGZhbHNlXG4gICAgfCBFcnJvciBfYV9fMDQ5XywgRXJyb3IgX2JfXzA1MF8gLT4gX2NtcF9fYiBfYV9fMDQ5XyBfYl9fMDUwXylcbjs7XG5cbmxldCBlcXVhbCA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDM5XyBiX18wNDBfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDM5XyBiX18wNDBfXG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMzlfLCBiX18wNDBfIHdpdGhcbiAgICB8IE9rIF9hX18wNDFfLCBPayBfYl9fMDQyXyAtPiBfY21wX19hIF9hX18wNDFfIF9iX18wNDJfXG4gICAgfCBPayBfLCBfIC0+IGZhbHNlXG4gICAgfCBfLCBPayBfIC0+IGZhbHNlXG4gICAgfCBFcnJvciBfYV9fMDQzXywgRXJyb3IgX2JfXzA0NF8gLT4gX2NtcF9fYiBfYV9fMDQzXyBfYl9fMDQ0Xylcbjs7XG5cbmxldCBoYXNoX2ZvbGRfdFxuICA6IHR5cGUgYSBiLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAoYSwgYikgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBPayBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gIHwgRXJyb3IgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuOztcblxuW0BAQGVuZF1cblxubGV0IGdsb2JhbGl6ZSA9IGdsb2JhbGl6ZV9yZXN1bHRcblxuaW5jbHVkZSBNb25hZC5NYWtlMl9sb2NhbCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgeCAtPiBmIHhcbiAgOztcblxuICBsZXQgbWFwIHggfmYgPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIHggLT4gT2sgKGYgeClcbiAgOztcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgbGV0IHJldHVybiB4ID0gT2sgeFxuZW5kKVxuXG5sZXQgaW52YXJpYW50IGNoZWNrX29rIGNoZWNrX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBvayAtPiBjaGVja19vayBva1xuICB8IEVycm9yIGVycm9yIC0+IGNoZWNrX2Vycm9yIGVycm9yXG47O1xuXG5sZXQgZmFpbCB4ID0gRXJyb3IgeFxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxuXG5sZXQgbWFwX2Vycm9yIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBfIGFzIHggLT4geFxuICB8IEVycm9yIHggLT4gRXJyb3IgKGYgeClcbjs7XG5cbm1vZHVsZSBFcnJvciA9IE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICBsZXQgYmluZCB4IH5mID1cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IE9rIF8gYXMgb2sgLT4gb2tcbiAgICB8IEVycm9yIGUgLT4gZiBlXG4gIDs7XG5cbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwX2Vycm9yXG4gIGxldCByZXR1cm4gZSA9IEVycm9yIGVcbmVuZClcblxubGV0IGlzX29rID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gZmFsc2VcbiAgfCBFcnJvciBfIC0+IHRydWVcbjs7XG5cbmxldCBvayA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBTb21lIHhcbiAgfCBFcnJvciBfIC0+IE5vbmVcbjs7XG5cbmxldCBlcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBOb25lXG4gIHwgRXJyb3IgeCAtPiBTb21lIHhcbjs7XG5cbmxldCBvZl9vcHRpb24gb3B0IH5lcnJvciA9XG4gIG1hdGNoIG9wdCB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+IEVycm9yIGVycm9yXG47O1xuXG5sZXQgaXRlciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgeCAtPiBmIHhcbiAgfCBFcnJvciBfIC0+ICgpXG47O1xuXG5sZXQgaXRlcl9lcnJvciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgXyAtPiAoKVxuICB8IEVycm9yIHggLT4gZiB4XG47O1xuXG5sZXQgdG9fZWl0aGVyIDogXyB0IC0+IF8gRWl0aGVyLnQgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gRmlyc3QgeFxuICB8IEVycm9yIHggLT4gU2Vjb25kIHhcbjs7XG5cbmxldCBvZl9laXRoZXIgOiBfIEVpdGhlci50IC0+IF8gdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBPayB4XG4gIHwgU2Vjb25kIHggLT4gRXJyb3IgeFxuOztcblxubGV0IG9rX2lmX3RydWUgYm9vbCB+ZXJyb3IgPSBpZiBib29sIHRoZW4gT2sgKCkgZWxzZSBFcnJvciBlcnJvclxuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBva19vcl9mYWlsd2l0aCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3Igc3RyIC0+IGZhaWx3aXRoIHN0clxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnb2ssICdlcnIpIF9yZXN1bHQgPSAoJ29rLCAnZXJyKSB0ID1cbiAgICB8IE9rIG9mICdva1xuICAgIHwgRXJyb3Igb2YgJ2VyclxuXG4gIGxldCBpc19lcnJvciA9IGlzX2Vycm9yXG4gIGxldCBpc19vayA9IGlzX29rXG5lbmRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IE9rIF8sIEVycm9yIGUgfCBFcnJvciBlLCBPayBfIC0+IEVycm9yIGVcbiAgfCBPayBvazEsIE9rIG9rMiAtPiBPayAob2sgb2sxIG9rMilcbiAgfCBFcnJvciBlcnIxLCBFcnJvciBlcnIyIC0+IEVycm9yIChlcnIgZXJyMSBlcnIyKVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0MS5wYXJ0aXRpb25fbWFwIGwgfmY6dG9fZWl0aGVyIGluXG4gIG1hdGNoIGVycnMgd2l0aFxuICB8IFtdIC0+IE9rIG9rXG4gIHwgXyA6OiBfIC0+IEVycm9yIGVycnNcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBtYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfRXJyb3IiLCJjc3RfT2siLCJjc3RfZXJyb3IiLCJjc3Rfb2siLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiZXJyb3Jfc291cmNlXzAwNSIsIkJhc2VfTGlzdDEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUHJpbnRmIiwiQmFzZV9IYXNoIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9Nb25hZCIsInRfb2Zfc2V4cCIsIm9mX2FfMDAxIiwib2ZfYl8wMDIiLCJzZXhwXzAwNyIsIm1hdGNoIiwidGFnXzAwOCIsInNleHBfYXJnc18wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwic2V4cF9hcmdzXzAxNCIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJzZXhwX29mX3QiLCJvZl9hXzAxOSIsIm9mX2JfMDIwIiwicGFyYW0iLCJhcmcwXzAyMSIsInJlczBfMDIyIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsInRfc2V4cF9ncmFtbWFyIiwiYV9zZXhwX2dyYW1tYXIiLCJiX3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbG9jYWwiLCJjbXBfYSIsImNtcF9iIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiY29tcGFyZSIsImFfMDI3IiwiYl8wMjgiLCJhXzAyOSIsImJfMDMwIiwiYV8wMzEiLCJiXzAzMiIsImVxdWFsX2xvY2FsIiwiYV8wNDUiLCJiXzA0NiIsImFfMDQ3IiwiYl8wNDgiLCJhXzA0OSIsImJfMDUwIiwiZXF1YWwiLCJhXzAzOSIsImJfMDQwIiwiYV8wNDEiLCJiXzA0MiIsImFfMDQzIiwiYl8wNDQiLCJoYXNoX2ZvbGRfdCIsImhhc2hfZm9sZF9hIiwiaGFzaF9mb2xkX2IiLCJoc3YiLCJhcmciLCJnbG9iYWxpemUiLCJiaW5kIiwieCIsIm1hcCIsInJldHVybiQiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTGV0X3N5bnRheCIsIk1vbmFkX2luZml4Iiwiam9pbiIsImlnbm9yZV9tIiwiYWxsIiwiYWxsX3VuaXQiLCJpbnZhcmlhbnQiLCJjaGVja19vayIsImNoZWNrX2Vycm9yIiwidCIsIm9rIiwiZXJyb3IiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJtYXBfZXJyb3IiLCJlIiwiRXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwib2Zfb3B0aW9uIiwib3B0IiwiaXRlciIsInYiLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsImV4biIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwic3RyIiwiY29tYmluZSIsInQxIiwidDIiLCJlcnIiLCJvazEiLCJvazIiLCJlcnIxIiwiZXJyMiIsImNvbWJpbmVfZXJyb3JzIiwibCIsImVycnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiQmFzZV9SZXN1bHQiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7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LE9BQUFsRjtBQUFBQSxJQUdQLHVCQUFBNkMsSUFBQSxVQUNEO0FBQUEsUUFBQW9DLE1BREM7QUFBQTtBQUFBLEdBRWE7QUFBQSxZQUFBRSxlQUFBbkY7QUFBQUEsSUFHTCx1QkFBQTZDLElBQUEsVUFDVDtBQUFBLFFBQUF1QyxNQURTO0FBQUEsSUFFSix1Q0FBWTtBQUFBO0FBQUEsWUFBQUMsUUFBQUMsSUFBQUMsSUFBQTFCLElBQUEyQjtBQUFBQSxJQWEzQjtBQUFBLFNBQUFDLE1BQUE7QUFBQSx5QkFBQUMsTUFBQSxPQUV1QixvQ0FBWTtBQUFBLFNBQUF2QixJQUZuQztBQUFBO0FBQUE7QUFBQSxTQUFBd0IsT0FBQTtBQUFBO0FBQUEsVUFBQUMsT0FBQTtBQUFBLE1BR2tDLHVDQUFlO0FBQUE7QUFBQSxTQUFBekIsSUFIakQ7QUFBQTtBQUFBLElBQ21DO0FBQUEsR0FFYztBQUFBLFlBQUEwQixlQUFBQztBQUFBQTtBQUFBQSxLQUFBekcsUUFJbEM7QUFBQSxLQUFBMEcsT0FBa0M7QUFBQSxLQUFBbEMsS0FBQTtBQUFBLElBQ2pELGlDQUVzQjtBQUFBO0FBQUEsWUFBQW1DLG9CQUFBRjtBQUFBQSxJQUdRLE9BQWtCLGtCQUFsQiw0QkFBQTlGLE9BQThDLFNBQUUsRUFBQztBQUFBO0FBQUE7QUFBQSxJQUFBaUc7QUFBQUEsTUFyUy9FO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEaEJGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjA1OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkNvbnRpbnVlX29yX3N0b3AiLCJFeHBvcnQiLCJCYXNlX0NvbnRhaW5lcl9pbnRmIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLHNCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjA3NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9jb250YWluZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgQ29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPSAndCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cbnR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbnR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbmxldCBpdGVyIH4oZm9sZCA6IChfLCBfLCBfKSBmb2xkKSB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpIFtAbm9udGFpbF1cbmxldCBjb3VudCB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBuIGEgLT4gaWYgZiBhIHRoZW4gbiArIDEgZWxzZSBuKSBbQG5vbnRhaWxdXG5cbmxldCBzdW0gKHR5cGUgYSkgfmZvbGQgKG1vZHVsZSBNIDogU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgZm9sZCB0IH5pbml0Ok0uemVybyB+ZjooZnVuIG4gYSAtPiBNLiggKyApIG4gKGYgYSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0ID1cbiAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgUmVzdWx0Lk9rXG4gICAgICAoZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGl0ZW0gLT5cbiAgICAgICAgIG1hdGNoIGYgYWNjIGl0ZW0gd2l0aFxuICAgICAgICAgfCBSZXN1bHQuT2sgeCAtPiB4XG4gICAgICAgICB8IEVycm9yIF8gYXMgZSAtPiByZXR1cm4gZSkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBmaW5pc2hcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IENvbnRpbnVlX29yX3N0b3AuQ29udGludWUgeCAtPiB4XG4gICAgICAgICB8IFN0b3AgeCAtPiByZXR1cm4geCkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWluIC0+IGlmIGNvbXBhcmUgbWluIGVsdCA+IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYykgW0Bub250YWlsXVxuOztcblxubGV0IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1heCAtPiBpZiBjb21wYXJlIG1heCBlbHQgPCAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBsZW5ndGggfmZvbGQgYyA9IGZvbGQgYyB+aW5pdDowIH5mOihmdW4gYWNjIF8gLT4gYWNjICsgMSlcblxubGV0IGlzX2VtcHR5IH5pdGVyIGMgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biBfIC0+IHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IG1lbSB+aXRlciBjIHggfmVxdWFsID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geSAtPiBpZiBlcXVhbCB4IHkgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSkgW0Bub250YWlsXVxuOztcblxubGV0IGV4aXN0cyB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvcl9hbGwgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgbm90IChmIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kX21hcCB+aXRlciB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciB0IH5mOihmdW4geCAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHIucmV0dXJuIHJlcyk7XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmQgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gKFNvbWUgeCkpO1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCB0b19saXN0IH5mb2xkIGMgPSBMaXN0LnJldiAoZm9sZCBjIH5pbml0OltdIH5mOihmdW4gYWNjIHggLT4geCA6OiBhY2MpKVxuXG5sZXQgdG9fYXJyYXkgfmxlbmd0aCB+aXRlciBjID1cbiAgbGV0IGFycmF5ID0gcmVmIFt8fF0gaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICBpdGVyIGMgfmY6KGZ1biB4IC0+XG4gICAgaWYgIWkgPSAwIHRoZW4gYXJyYXkgOj0gQXJyYXkuY3JlYXRlIH5sZW46KGxlbmd0aCBjKSB4O1xuICAgICFhcnJheS4oIWkpIDwtIHg7XG4gICAgaW5jciBpKTtcbiAgIWFycmF5XG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDpcbiAgR2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQgPSBzdHJ1Y3RcbiAgbGV0IGZvbGQgPSBULmZvbGRcblxuICBsZXQgaXRlciA9XG4gICAgbWF0Y2ggVC5pdGVyIHdpdGhcbiAgICB8IGBDdXN0b20gaXRlciAtPiBpdGVyXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlciB+Zm9sZCB0IH5mXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9XG4gICAgbWF0Y2ggVC5sZW5ndGggd2l0aFxuICAgIHwgYEN1c3RvbSBsZW5ndGggLT4gbGVuZ3RoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgLT4gbGVuZ3RoIH5mb2xkIHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IGlzX2VtcHR5IH5pdGVyIHRcbiAgbGV0IG1lbSB0IHggfmVxdWFsID0gbWVtIH5pdGVyIHQgeCB+ZXF1YWxcbiAgbGV0IHN1bSBtIHQgPSBzdW0gfmZvbGQgbSB0XG4gIGxldCBjb3VudCB0IH5mID0gY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBleGlzdHMgfml0ZXIgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbCB+aXRlciB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXAgfml0ZXIgdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gZmluZCB+aXRlciB0IH5mXG4gIGxldCB0b19saXN0IHQgPSB0b19saXN0IH5mb2xkIHRcbiAgbGV0IHRvX2FycmF5IHQgPSB0b19hcnJheSB+bGVuZ3RoIH5pdGVyIHRcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gZm9sZF9yZXN1bHQgdCB+Zm9sZCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBmb2xkX3VudGlsIHQgfmZvbGQgfmluaXQgfmYgfmZpbmlzaFxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSAnYSBULnRcbiAgICB0eXBlICdhIGVsdCA9ICdhXG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSBULnRcbiAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgZW5kKVxuXG4gIGxldCBtZW0gdCB4ID0gbWVtIHQgeCB+ZXF1YWw6VC5FbHQuZXF1YWxcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNfYXJnKSA6XG4gIEdlbmVyaWNfd2l0aF9jcmVhdG9yc1xuICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbiAgICAgYW5kIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgY29uY2F0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQuY29uY2F0ID1cbnN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChUKVxuXG4gIGxldCBvZl9saXN0ID0gVC5vZl9saXN0XG4gIGxldCBvZl9hcnJheSA9IFQub2ZfYXJyYXlcbiAgbGV0IGNvbmNhdCA9IFQuY29uY2F0XG4gIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBULmNvbmNhdF9vZl9hcnJheVxuICBsZXQgYXBwZW5kIGEgYiA9IGNvbmNhdCAoY29uY2F0X29mX2FycmF5IFt8IGE7IGIgfF0pXG4gIGxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKGNvbmNhdF9vZl9hcnJheSAoQXJyYXkubWFwICh0b19hcnJheSB0KSB+ZikpXG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gICAgY29uY2F0X21hcCB0IH5mOihmdW4geCAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBvZl9hcnJheSBbfHxdXG4gICAgICB8IFNvbWUgeSAtPiBvZl9hcnJheSBbfCB5IHxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBTb21lIChmIHgpKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICAgIGxldCBhcnJheSA9IEFycmF5Lm1hcCAodG9fYXJyYXkgdCkgfmYgaW5cbiAgICBsZXQgeHMgPVxuICAgICAgQXJyYXkuZm9sZF9yaWdodCBhcnJheSB+aW5pdDpbXSB+ZjooZnVuIGVpdGhlciBhY2MgLT5cbiAgICAgICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCB4IC0+IHggOjogYWNjXG4gICAgICAgIHwgU2Vjb25kIF8gLT4gYWNjKVxuICAgIGluXG4gICAgbGV0IHlzID1cbiAgICAgIEFycmF5LmZvbGRfcmlnaHQgYXJyYXkgfmluaXQ6W10gfmY6KGZ1biBlaXRoZXIgYWNjIC0+XG4gICAgICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgXyAtPiBhY2NcbiAgICAgICAgfCBTZWNvbmQgeCAtPiB4IDo6IGFjYylcbiAgICBpblxuICAgIG9mX2xpc3QgeHMsIG9mX2xpc3QgeXNcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIHBhcnRpdGlvbl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4KSBbQG5vbnRhaWxdXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2Vfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2Vfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9ICdhIFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICgnYSwgXywgXykgY29uY2F0ID0gJ2EgVC50XG5cbiAgICBsZXQgY29uY2F0X29mX2FycmF5ID0gb2ZfYXJyYXlcbiAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMF93aXRoX2NyZWF0b3JzIChUIDogTWFrZTBfd2l0aF9jcmVhdG9yc19hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlICgnYSwgXywgXykgdCA9IFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgPSAnYSBsaXN0XG5cbiAgICBsZXQgY29uY2F0X29mX2FycmF5ID0gQXJyYXkudG9fbGlzdFxuICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQXJyYXkwIiwiQmFzZV9MaXN0MCIsIkJhc2VfSW1wb3J0IiwiQmFzZV9XaXRoX3JldHVybiIsIndpdGhfcmV0dXJuIiwiaXRlciIsImZvbGQiLCJ0IiwicGFyYW0iLCJhIiwiY291bnQiLCJuIiwic3VtIiwiTSIsImZvbGRfcmVzdWx0IiwiaW5pdCIsImFjYyIsIml0ZW0iLCJlIiwieCIsImZvbGRfdW50aWwiLCJmaW5pc2giLCJtYXRjaCIsIm1pbl9lbHQiLCJjb21wYXJlIiwiZWx0IiwibWluIiwibWF4X2VsdCIsIm1heCIsImxlbmd0aCIsImMiLCJpc19lbXB0eSIsInIiLCJtZW0iLCJlcXVhbCIsInkiLCJleGlzdHMiLCJmb3JfYWxsIiwiZmluZF9tYXAiLCJyZXMiLCJmaW5kIiwidG9fbGlzdCIsInRvX2FycmF5IiwiYXJyYXkiLCJpIiwiTWFrZV9nZW4iLCJUIiwibSIsIk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMiLCJpbmNsdWRlIiwib2ZfbGlzdCIsIm9mX2FycmF5IiwiY29uY2F0IiwiY29uY2F0X29mX2FycmF5IiwiYXBwZW5kIiwiYiIsImNvbmNhdF9tYXAiLCJmaWx0ZXJfbWFwIiwibWFwIiwiZmlsdGVyIiwicGFydGl0aW9uX21hcCIsInhzIiwiZWl0aGVyIiwieXMiLCJwYXJ0aXRpb25fdGYiLCJCYXNlX0NvbnRhaW5lciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxZQUFBQyxLQUFBQyxNQUFBQyxHQUFBZDtBQUFBQSxJQ1l5QztBQUFBLGtDQUFBZSxPQUFBQyxHQUFnQyx1QkFBRyxHQUFDO0FBQUE7QUFBQSxZQUFBQyxNQUFBSixNQUFBQyxHQUFBZDtBQUFBQSxJQUN0RDtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBa0IsR0FBQUY7QUFBQUEsY0FBaUMsMEJBQVMsb0NBQVk7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBRyxJQUFBTixNQUFBTyxHQUFBTixHQUFBZDtBQUFBQSxJQUc1RTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBa0IsR0FBQUY7QUFBQUEsa0JBQUEsSUFBNkM7QUFBQSxjQUFLO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQUssWUFBQVIsTUFBQVMsTUFBQXRCLEdBQUFjO0FBQUFBLElBSW5EO0FBQUEs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Y0FBQTtBQUFBLFNBQUFNLGFBQUE7QUFBQSxTQUFBZ0IsU0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBM0IsUUFBQTtBQUFBLFNBQUFFLE1BQUE7QUFBQSxTQUFBNEIsT0FBQTtBQUFBLFNBQUFGLFdBQUE7QUFBQSxTQUFBRyxVQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFuQixVQUFBO0FBQUEsU0FBQUksVUFBQTtBQUFBLFNBQUF1QixZQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFHLFNBQUE7QUFBQSxTQUFBRixXQUFBO0FBQUEsU0FBQU0sTUFBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBRixhQUFBO0FBQUEsU0FBQUQsYUFBQTtBQUFBLFNBQUFRLGVBQUE7QUFBQSxTQUFBSixnQkFBQTtBQUFBO0FBQUEsaUJBQUEzQixJQUFBMUIsR0FBQVksR0NvT2dCLG1DQUEwQjtBQUFBLFFEcE8xQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY2ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyw4QkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY3MDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuaW5jbHVkZSBJbmRleGVkX2NvbnRhaW5lcl9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmxldFtAaW5saW5lIGFsd2F5c10gaXRlcmkgfmZvbGQgdCB+ZiA9XG4gIGlnbm9yZVxuICAgIChmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIGkgeCAtPlxuICAgICAgIGYgaSB4O1xuICAgICAgIGkgKyAxKVxuICAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIHYgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgdiBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYykgW0Bub250YWlsXVxuOztcblxubGV0IGNvdW50aSB+Zm9sZGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGkgbiBhIC0+IGlmIGYgaSBhIHRoZW4gbiArIDEgZWxzZSBuKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZXhpc3RzaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvcl9hbGxpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBub3QgKGYgaSB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXBpIH5pdGVyaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gKFNvbWUgKGksIHgpKSk7XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxuKCogQWxsb3dzIFtNYWtlX2dlbl0gdG8gc2hhcmUgYSBbQ29udGFpbmVyLkdlbmVyaWNdIGltcGxlbWVudGF0aW9uIHdpdGgsIGUuZy4sXG4gICBbQ29udGFpbmVyLk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNdLiAqKVxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY29udGFpbmVyXG4gIChUIDogTWFrZV9nZW5fYXJnKVxuICAoQyA6IENvbnRhaW5lci5HZW5lcmljXG4gICAgICAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQpIDpcbiAgR2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDXG5cbiAgbGV0IGl0ZXJpID1cbiAgICBtYXRjaCBULml0ZXJpIHdpdGhcbiAgICB8IGBDdXN0b20gaXRlcmkgLT4gaXRlcmlcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+ZiAtPiBpdGVyaSB+Zm9sZCB0IH5mXG4gIDs7XG5cbiAgbGV0IGZvbGRpID1cbiAgICBtYXRjaCBULmZvbGRpIHdpdGhcbiAgICB8IGBDdXN0b20gZm9sZGkgLT4gZm9sZGlcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+aW5pdCB+ZiAtPiBmb2xkaSB+Zm9sZCB0IH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID0gY291bnRpIH5mb2xkaSB0IH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBleGlzdHNpIH5pdGVyaSB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gZm9yX2FsbGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRfbWFwaSB0IH5mID0gZmluZF9tYXBpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kaSB0IH5mID0gZmluZGkgfml0ZXJpIHQgfmZcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6XG4gIEdlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0ID0gc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2VfZ2VuIChUKVxuICBpbmNsdWRlIENcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NvbnRhaW5lciAoVCkgKEMpXG5lbmRcbltAQGlubGluZSBhbHdheXNdXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSAnYSBULnRcbiAgICB0eXBlICdhIGVsdCA9ICdhXG4gIGVuZClcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKF8sIF8sIF8pIHQgPSBULnRcbiAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgZW5kKVxuXG4gIGxldCBtZW0gdCB4ID0gbWVtIHQgeCB+ZXF1YWw6VC5FbHQuZXF1YWxcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNfYXJnKSA6XG4gIEdlbmVyaWNfd2l0aF9jcmVhdG9yc1xuICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbiAgICAgYW5kIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgY29uY2F0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQuY29uY2F0ID1cbnN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlX2dlbl93aXRoX2NyZWF0b3JzIChUKVxuICBpbmNsdWRlIENcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NvbnRhaW5lciAoVCkgKEMpXG5cbiAgbGV0IGRlcml2ZWRfaW5pdCBuIH5mID0gb2ZfYXJyYXkgKEFycmF5LmluaXQgbiB+ZilcblxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggVC5pbml0IHdpdGhcbiAgICB8IGBDdXN0b20gaW5pdCAtPiBpbml0XG4gICAgfCBgRGVmaW5lX3VzaW5nX29mX2FycmF5IC0+IGRlcml2ZWRfaW5pdFxuICA7O1xuXG4gIGxldCBkZXJpdmVkX2NvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKFQuY29uY2F0X29mX2FycmF5IChBcnJheS5tYXBpICh0b19hcnJheSB0KSB+ZikpXG5cbiAgbGV0IGNvbmNhdF9tYXBpID1cbiAgICBtYXRjaCBULmNvbmNhdF9tYXBpIHdpdGhcbiAgICB8IGBDdXN0b20gY29uY2F0X21hcGkgLT4gY29uY2F0X21hcGlcbiAgICB8IGBEZWZpbmVfdXNpbmdfY29uY2F0IC0+IGRlcml2ZWRfY29uY2F0X21hcGlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgY29uY2F0X21hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+IG9mX2FycmF5IFt8fF1cbiAgICAgIHwgU29tZSB5IC0+IG9mX2FycmF5IFt8IHkgfF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWFwaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBTb21lIChmIGkgeCkpIFtAbm9udGFpbF1cblxuICBsZXQgZmlsdGVyaSB0IH5mID1cbiAgICBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSAnYSBULnRcbiAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgdHlwZSAoJ2EsIF8sIF8pIGNvbmNhdCA9ICdhIFQudFxuXG4gICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IG9mX2FycmF5XG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTBfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2UwX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoXywgXywgXykgdCA9IFQudFxuICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgPSAnYSBsaXN0XG5cbiAgICBsZXQgY29uY2F0X29mX2FycmF5ID0gQXJyYXkudG9fbGlzdFxuICBlbmQpXG5cbiAgbGV0IG1lbSB0IHggPSBtZW0gdCB4IH5lcXVhbDpULkVsdC5lcXVhbFxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQXJyYXkwIiwiQmFzZV9Db250YWluZXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfV2l0aF9yZXR1cm4iLCJ3aXRoX3JldHVybiIsIml0ZXJpIiwiZm9sZCIsInQiLCJpIiwieCIsImZvbGRpIiwiaW5pdCIsImFjYyIsInYiLCJjb3VudGkiLCJuIiwiYSIsImV4aXN0c2kiLCJjIiwiciIsImZvcl9hbGxpIiwiZmluZF9tYXBpIiwicmVzIiwiZmluZGkiLCJNYWtlX2dlbl93aXRoX2NvbnRhaW5lciIsIlQiLCJpbmNsdWRlIiwibGVuZ3RoIiwiaXNfZW1wdHkiLCJtZW0iLCJpdGVyIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJtYXRjaCIsIk1ha2VfZ2VuIiwiQyIsIk1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMiLCJvZl9saXN0Iiwib2ZfYXJyYXkiLCJhcHBlbmQiLCJjb25jYXQiLCJtYXAiLCJmaWx0ZXIiLCJmaWx0ZXJfbWFwIiwiY29uY2F0X21hcCIsInBhcnRpdGlvbl90ZiIsInBhcnRpdGlvbl9tYXAiLCJkZXJpdmVkX2luaXQiLCJkZXJpdmVkX2NvbmNhdF9tYXBpIiwiY29uY2F0X21hcGkiLCJmaWx0ZXJfbWFwaSIsInkiLCJtYXBpIiwiZmlsdGVyaSIsIkJhc2VfSW5kZXhlZF9jb250YWluZXIiLCJjb25jYXRfb2ZfYXJyYXkiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEs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QyxnQkFBQTtBQUFBLFNBQUE3QixXQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFFLFNBQUE7QUFBQSxTQUFBeEIsU0FBQTtBQUFBLFNBQUF5QixjQUFBO0FBQUEsU0FBQUMsYUFBQTtBQUFBLFNBQUFDLFNBQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUMsUUFBQTtBQUFBLFNBQUFDLE1BQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQUMsV0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBaEMsVUFBQTtBQUFBLFNBQUFMLFVBQUE7QUFBQSxTQUFBWSxVQUFBO0FBQUEsU0FBQUcsV0FBQTtBQUFBLFNBQUFOLFNBQUE7QUFBQSxTQUFBUyxRQUFBO0FBQUEsU0FBQUYsWUFBQTtBQUFBLFNBQUFWLFNBQUE7QUFBQSxTQUFBbUQsT0FBQTtBQUFBLFNBQUFDLFVBQUE7QUFBQSxTQUFBSCxjQUFBO0FBQUEsU0FBQUQsZ0JBQUE7QUFBQTtBQUFBLGlCQUFBOUIsSUFBQXRCLEdBQUFFLEdDbUxnQixtQ0FBMEI7QUFBQSxRRG5MMUMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3NDE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2xhenkubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU3RkbGliLkxhenlcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsYXp5X3Rfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGF6eV90XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gbGF6eV90X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG5leHRlcm5hbCBmb3JjZSA6ICgnYSB0W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG5sZXQgZ2xvYmFsaXplID0gR2xvYmFsaXplLmdsb2JhbGl6ZV9sYXp5X3RcbmxldCBtYXAgdCB+ZiA9IGxhenkgKGYgKGZvcmNlIHQpKVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgY29tcGFyZV9hIHQxIHQyID1cbiAgaWYgcGh5c19lcXVhbCB0MSB0MiB0aGVuIDAgZWxzZSBjb21wYXJlX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG47O1xuXG5sZXQgY29tcGFyZSBjb21wYXJlX2EgdDEgdDIgPSBjb21wYXJlX19sb2NhbCBjb21wYXJlX2EgdDEgdDJcblxubGV0IGVxdWFsX19sb2NhbCBlcXVhbF9hIHQxIHQyID1cbiAgaWYgcGh5c19lcXVhbCB0MSB0MiB0aGVuIHRydWUgZWxzZSBlcXVhbF9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBlcXVhbF9fbG9jYWwgZXF1YWxfYSB0MSB0MlxubGV0IGhhc2hfZm9sZF90ID0gSGFzaC5CdWlsdGluLmhhc2hfZm9sZF9sYXp5X3RcbmxldCBwZWVrIHQgPSBpZiBpc192YWwgdCB0aGVuIFNvbWUgKGZvcmNlIHQpIGVsc2UgTm9uZVxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCByZXR1cm4geCA9IGZyb21fdmFsIHhcbiAgbGV0IGJpbmQgdCB+ZiA9IGxhenkgKGZvcmNlIChmIChmb3JjZSB0KSkpXG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5lbmQpXG5cbm1vZHVsZSBUX3VuZm9yY2luZyA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGlmIGlzX3ZhbCB0IHRoZW4gc2V4cF9vZl9hIChmb3JjZSB0KSBlbHNlIHNleHBfb2Zfc3RyaW5nIFwiPHVuZm9yY2VkIGxhenk+XCJcbiAgOztcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9JbXBvcnQiLCJTdGRsaWJfTGF6eSIsIkJhc2VfR2xvYmFsaXplIiwiQmFzZV9IYXNoIiwiQmFzZV9Nb25hZCIsIlVuZGVmaW5lZCIsImlzX3ZhbCIsImZyb21fdmFsIiwiZnJvbV9mdW4iLCJmb3JjZV92YWwiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiZ2xvYmFsaXplIiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmVfYSIsInQxIiwidDIiLCJjb21wYXJlIiwiZXF1YWxfbG9jYWwiLCJlcXVhbF9hIiwiZXF1YWwiLCJoYXNoX2ZvbGRfdCIsInBlZWsiLCJ0IiwicmV0dXJuJCIsIngiLCJiaW5kIiwicGFyYW0iLCJtYXAiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTW9uYWRfaW5maXgiLCJqb2luIiwiaWdub3JlX20iLCJhbGwiLCJhbGxfdW5pdCIsIkxldF9zeW50YXgiLCJjc3RfdW5mb3JjZWRfbGF6eSIsInNleHBfb2ZfYSIsIlRfdW5mb3JjaW5nIiwiQmFzZV9MYXp5Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsWUFBQUMsZUFBQUM7QUFBQUEsSUNTMEIsa0RBQW9DO0FBQUE7QUFBQSxPQUFBQyxZRFQ5RDtBQUFBLFlBQUFDLGNBQUFDLFdBQUFDLElBQUFDO0FBQUFBLElDb0JFLGNBQXlCO0FBQUEsWUFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNDQUErQjtBQUFBO0FBQUEsWUFBQUMsUUFBQUgsV0FBQUMsSUFBQUM7QUFBQUEsSUFHbkMsdUNBQThCO0FBQUE7QUFBQSxZQUFBRSxZQUFBQyxTQUFBSixJQUFBQztBQUFBQSxJQUcxRCxjQUF5QjtBQUFBLFlBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQ0FBNkI7QUFBQTtBQUFBLFlBQUFJLE1BQUFELFNBQUFKLElBQUFDLElBR3hDLG1DQUEwQjtBQUFBLE9BQUFLLGNEN0JwRDtBQUFBLFlBQUFDLEtBQUFDO0FBQUFBLElDK0JnQixnQkFBa0M7QUFBQSxZQUFwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUF3QjtBQUFBLFlBQUFDLFFBQUFDLEdBS3JDLGtCQUFVO0FBQUEsWUFBQUMsS0FBQUgsR0FBQS9CO0FBQUFBLElBQ1Q7QUFBQSxxQkFBQW1DO0FBQUFBLGlCQUFBLElEckNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJDcUM4QixzQkFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQXpCO0FBQUEsR0FBMEI7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EckM1QztBQUFBO0FBQUEsZ0JBQUFMLEdBQUEvQjtBQUFBQSxRQ2lCZTtBQUFBLHlCQUFBbUM7QUFBQUEscUJBQUEsSURqQmY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JDaUJlO0FBQUEsT0FBa0I7QUFBQSxJQUFBRSxVRGpCakM7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBTixTQUFBO0FBQUEsSUFBQUYsV0FBQTtBQUFBLElBQUFJLFFBQUE7QUFBQSxJQUFBSyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsWUFBQTdCLFlBQUE4QixXQUFBaEI7QUFBQUEsSUM4Q08sZ0JBQXVDLHFEQUFnQztBQUFBLFlBQXpEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQ0FBeUQ7QUFBQTtBQUFBO0FBQUEsSUFBQWlCLGNEOUM5RTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3NjA1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9JbmZvX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjc2MTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBTcGxpdCBvZmYgdG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIFtPcl9lcnJvcl0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5sZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gIGlmIHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBwb3NpdGlvbjogJWRcIiBwb3MgKCk7XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJOZWdhdGl2ZSBsZW5ndGg6ICVkXCIgbGVuICgpO1xuICAoKiBXZSB1c2UgW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gcmF0aGVyIHRoYW4gW3BvcyArIGxlbiA+IHRvdGFsX2xlbmd0aF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJwb3MgKyBsZW4gcGFzdCBlbmQ6ICVkICsgJWQgPiAlZFwiIHBvcyBsZW4gdG90YWxfbGVuZ3RoICgpXG4gIFtAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICAoKiBUaGlzIGlzIGJldHRlciB0aGFuIFtzbG93X2NoZWNrX3Bvc19sZW5fZXhuXSBmb3IgdHdvIHJlYXNvbnM6XG5cbiAgICAgLSBtdWNoIGxlc3MgaW5saW5lZCBjb2RlXG4gICAgIC0gb25seSBvbmUgY29uZGl0aW9uYWwganVtcFxuXG4gICAgIFRoZSByZWFzb24gaXQgd29ya3MgaXMgdGhhdCBjaGVja2luZyBbPCAwXSBpcyB0ZXN0aW5nIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCwgc29cbiAgICAgW2EgPCAwIHx8IGIgPCAwXSBpcyB0aGUgc2FtZSBhcyBbYSBsb3IgYiA8IDBdLlxuXG4gICAgIFtwb3MgKyBsZW5dIGNhbiBvdmVyZmxvdywgc28gW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gaXMgbm90IGVxdWl2YWxlbnQgdG9cbiAgICAgW3RvdGFsX2xlbmd0aCAtIGxlbiAtIHBvcyA8IDBdLCB3ZSBuZWVkIHRvIHRlc3QgZm9yIFtwb3MgKyBsZW5dIG92ZXJmbG93IGFzXG4gICAgIHdlbGwuICopXG4gIGxldCBzdG9wID0gcG9zICsgbGVuIGluXG4gIGlmIHBvcyBsb3IgbGVuIGxvciBzdG9wIGxvciAodG90YWxfbGVuZ3RoIC0gc3RvcCkgPCAwXG4gIHRoZW4gc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aFxuICBbQEBpbmxpbmUgYWx3YXlzXVxuOztcblxubGV0IGdldF9wb3NfbGVuX2V4biA/KHBvcyA9IDApID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGkgLT4gaVxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIHBvcywgbGVuXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biA9IHNsb3dfY2hlY2tfcG9zX2xlbl9leG5cbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJjYW1sX2NhbGw0IiwiYTIiLCJhMyIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1ByaW50ZiIsImludmFsaWRfYXJnZiIsInNsb3dfY2hlY2tfcG9zX2xlbl9leG4iLCJwb3MiLCJsZW4iLCJ0b3RhbF9sZW5ndGgiLCJjaGVja19wb3NfbGVuX2V4biIsInN0b3AiLCJnZXRfcG9zX2xlbl9leG4iLCJvcHQiLCJwYXJhbSIsImkiLCJQcml2YXRlIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSCxHQUFBQyxJQUFBQyxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLHVCQUFBQyxLQUFBQyxLQUFBQztBQUFBQSxJQ09FLFlBQWdCO0FBQUEsSUFDaEIsWUFBZ0I7QUFBQSxZQUdQO0FBQUEsSUFBa0IsV0FDdEIsMERBQXVFO0FBQUE7QUFBQSxZQUFBQyxrQkFBQUgsS0FBQUMsS0FBQUM7QUFBQUE7QUFBQUEsS0FBQUUsT0FnQmpFO0FBQUEsU0FDaUI7QUFBQSxTQUF6QjtBQUFBO0FBQUE7QUFBQSxJQUE4QyxXQUM1QyxrREFBOEM7QUFBQTtBQUFBLFlBQUFDLGdCQUFBQyxLQUFBTCxLQUFBTSxPQUFBTDtBQUFBQSxRQUFBRixNQUlqQztBQUFBLElBQ2xCO0FBQUEsU0FBQVEsSUFBQSxRQUFBUCxRQUVjO0FBQUE7QUFBQSxTQUFBQSxRQUNGO0FBQUEsSUFFWjtBQUFBLElBQXlDO0FBQUEsR0FDakM7QUFBQTtBQUFBLElBQUFRLFVEekNWO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjc2ODQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvcmFuZG9tX3JlcHIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJcbnR5cGUgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUudCBTdGRsaWIuRG9tYWluLkRMUy5rZXlcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgb3BlbiBTdGRsaWIuQmlnYXJyYXlcblxuICB0eXBlIHQgPSAoaW50NjQsIGludDY0X2VsdCwgY19sYXlvdXQpIEFycmF5MS50XG5cbiAgbGV0IG9mX3N0YXRlIDogU3RkbGliLlJhbmRvbS5TdGF0ZS50IC0+IHQgPSBTdGRsaWIuT2JqLm1hZ2ljXG5lbmRcblxubGV0IGFzc2lnbiB0IHN0YXRlID1cbiAgbGV0IGRzdCA9IFJlcHIub2Zfc3RhdGUgKFN0ZGxpYi5Eb21haW4uRExTLmdldCB0KSBpblxuICBsZXQgc3JjID0gUmVwci5vZl9zdGF0ZSBzdGF0ZSBpblxuICBTdGRsaWIuQmlnYXJyYXkuQXJyYXkxLmJsaXQgc3JjIGRzdFxuOztcblxubGV0IG1ha2Ugc3RhdGUgPVxuICBsZXQgc3BsaXRfZnJvbV9wYXJlbnQgdiA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuc3BsaXQgdiBpblxuICBsZXQgdCA9IFN0ZGxpYi5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IChmdW4gKCkgLT4gc3RhdGUpIGluXG4gIFN0ZGxpYi5Eb21haW4uRExTLmdldCB0IHw+IGlnbm9yZTtcbiAgdFxuOztcblxubGV0IG1ha2VfbGF6eSB+ZiA9XG4gIGxldCBzcGxpdF9mcm9tX3BhcmVudCB2ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5zcGxpdCB2IGluXG4gIFN0ZGxpYi5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IGZcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZ2V0X3N0YXRlIHQgPSBTdGRsaWIuRG9tYWluLkRMUy5nZXQgdFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRG9tYWluIiwiU3RkbGliX1JhbmRvbSIsIm9mX3N0YXRlIiwiUmVwciIsImFzc2lnbiIsInQiLCJzdGF0ZSIsImRzdCIsIm1ha2UiLCJzcGxpdF9mcm9tX3BhcmVudCIsInYiLCJwYXJhbSIsIm1ha2VfbGF6eSIsImdldF9zdGF0ZSIsIkJhc2VfUmFuZG9tX3JlcHIiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsWUFBQUMsU0FBQTtBQUFBLE9BQUFDLE9BQUE7QUFBQSxZQUFBQyxPQUFBQyxHQUFBQztBQUFBQSxRQUFBQyxNQ1kwQjtBQUFBLElBRXhCLHVDQUFtQztBQUFBO0FBQUEsWUFBQUMsS0FBQUY7QUFBQUEsYUFBQUcsa0JBQUFDO0FBQUFBLEtBSVQsMkNBQTJCO0FBQUE7QUFBQTtBQUFBLEtBQUFMO0FBQUFBLE9BQzdDO0FBQUE7QUFBQTtBQUFBLGtCQUFBTSxPQUF3RCxhQUFLO0FBQUEsSUFDckU7QUFBQSxJQUNBO0FBQUEsR0FBQztBQUFBLFlBQUFDLFVBQUFqQjtBQUFBQSxhQUFBYyxrQkFBQUM7QUFBQUEsS0FJeUIsMkNBQTJCO0FBQUE7QUFBQSxJQUNyRCxrRUFBOEM7QUFBQTtBQUFBLFlBQUFHLFVBQUFSLEdBR2QsMENBQXVCO0FBQUEsT0FBQVMsbUJEN0J6RCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjc3MzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvcmFuZG9tLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIENoYXIgPSBDaGFyMFxuXG4oKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGRvZXMgbm90IGV4cG9zZVxuICAgW1N0ZGxpYi5SYW5kb20uU3RhdGUuZGVmYXVsdF0sIHdlIGhhdmUgdG8gY29uc3RydWN0IG91ciBvd24uICBXZSB0aGVuIGJ1aWxkIHRoZVxuICAgW1N0ZGxpYi5SYW5kb20uaW50XSwgW1N0ZGxpYi5SYW5kb20uYm9vbF0gZnVuY3Rpb25zIGFuZCBmcmllbmRzIHVzaW5nIHRoYXQgZGVmYXVsdCBzdGF0ZSBpblxuICAgZXhhY3RseSB0aGUgc2FtZSB3YXkgYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkuICopXG5cbigqIFJlZ3Jlc3Npb24gdGVzdHMgb3VnaHQgdG8gYmUgZGV0ZXJtaW5pc3RpYyBiZWNhdXNlIHRoYXQgd2F5IGFueW9uZSB3aG8gYnJlYWtzIHRoZSB0ZXN0XG4gICBrbm93cyB0aGF0IGl0J3MgdGhlaXIgY29kZSB0aGF0IGJyb2tlIHRoZSB0ZXN0LiAgSWYgdGVzdHMgYXJlIG5vbmRldGVybWluaXN0aWMsIGEgdGVzdFxuICAgZmFpbHVyZSBtYXkgaW5zdGVhZCBoYXBwZW4gYmVjYXVzZSB0aGUgdGVzdCBydW5uZXIgZ290IHVubHVja3kgYW5kIHVuY292ZXJlZCBhblxuICAgZXhpc3RpbmcgYnVnIGluIHRoZSBjb2RlIHN1cHBvc2VkbHkgYmVpbmcgXCJwcm90ZWN0ZWRcIiBieSB0aGUgdGVzdCBpbiBxdWVzdGlvbi4gKilcbmxldCBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzID1cbiAgaWYgYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICBtYXRjaCBhbGxvd19pbl90ZXN0cyB3aXRoXG4gICAgfCBTb21lIHRydWUgLT4gKClcbiAgICB8IE5vbmUgfCBTb21lIGZhbHNlIC0+XG4gICAgICBmYWlsd2l0aFxuICAgICAgICBcImluaXRpYWxpemluZyBSYW5kb20gd2l0aCBhIG5vbmRldGVybWluaXN0aWMgc2VlZCBpcyBmb3JiaWRkZW4gaW4gaW5saW5lIHRlc3RzXCIpXG47O1xuXG5leHRlcm5hbCByYW5kb21fc2VlZCA6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbmxldCByYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzO1xuICByYW5kb21fc2VlZCAoKVxuOztcblxubW9kdWxlIFJlcHIgPSBSYW5kb21fcmVwclxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUmVwci50XG5cbiAgbGV0IGJpdHMgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuYml0cyAoUmVwci5nZXRfc3RhdGUgdClcbiAgbGV0IGJpdHM2NCB0ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5iaXRzNjQgKFJlcHIuZ2V0X3N0YXRlIHQpXG4gIGxldCBib29sIHQgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmJvb2wgKFJlcHIuZ2V0X3N0YXRlIHQpXG4gIGxldCBpbnQgdCB4ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5pbnQgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IGludDMyIHQgeCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuaW50MzIgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IGludDY0IHQgeCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuaW50NjQgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLm5hdGl2ZWludCAoUmVwci5nZXRfc3RhdGUgdCkgeFxuICBsZXQgbWFrZSBzZWVkID0gUmVwci5tYWtlIChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcbiAgbGV0IGNvcHkgdCA9IFJlcHIubWFrZSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5jb3B5IChSZXByLmdldF9zdGF0ZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBSZXByLm1ha2VfbGF6eSB+ZjpTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG4gIDs7XG5cbiAgbGV0IGFzc2lnbiA9IFJlcHIuYXNzaWduXG4gIGxldCBmdWxsX2luaXQgdCBzZWVkID0gYXNzaWduIHQgKFN0ZGxpYi5SYW5kb20uU3RhdGUubWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIFN0ZGxpYi5SYW5kb20uIEhvd2V2ZXIsIGJlY2F1c2UgW2dldF9zdGF0ZV0gcmV0dXJuc1xuICAgICAgICAgYSBjb3B5LCBCYXNlLlJhbmRvbSBhbmQgT0NhbWwuUmFuZG9tIGFyZSBub3QgdXNpbmcgdGhlIHNhbWUgc3RhdGUuIElmIGEgcHJvZ3JhbVxuICAgICAgICAgdXNlZCBib3RoLCBlYWNoIG9mIHRoZW0gd291bGQgZ28gdGhyb3VnaCB0aGUgc2FtZSBzZXF1ZW5jZSBvZiByYW5kb20gYml0cy4gVG9cbiAgICAgICAgIGF2b2lkIHRoYXQsIHdlIHJlc2V0IE9DYW1sJ3MgcmFuZG9tIHN0YXRlIHRvIGEgZGlmZmVyZW50IHNlZWQsIGdpdmluZyBpdCBhXG4gICAgICAgICBkaWZmZXJlbnQgc2VxdWVuY2UuICopXG4gICAgICBsZXQgdCA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gICAgICBTdGRsaWIuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgUmVwci5tYWtlIHQpXG4gICAgZWxzZVxuICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgIFdlIGZvcmNlIHRoZSByYW5kb20gaW5pdGlhbGl6YXRpb24gdG8gYmUgbGF6eSBzbyB0aGF0IHdlIGRvIG5vdCBwYXkgYW55IGNvc3RcbiAgICAgICAgIGZvciBpdCBpbiBwcm9ncmFtcyB0aGF0IGRvIG5vdCB1c2UgcmFuZG9tbmVzcy4gKilcbiAgICAgIG1ha2Vfc2VsZl9pbml0ICgpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQ2NC50b19pbnQgKGludDY0IHQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fMzJiaXRzIHQgYm91bmQgPVxuICAgICgqIE5vdCBhbHdheXMgdHJ1ZSB3aXRoIHRoZSBKYXZhU2NyaXB0IGJhY2tlbmQuICopXG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQzMi50b19pbnQgKGludDMyIHQgKFN0ZGxpYi5JbnQzMi5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50NjQgPVxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPlxuICAgICAgbG9neG9yXG4gICAgICAgIChiaXRzIHN0YXRlKVxuICAgICAgICAobG9neG9yIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMCkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDYwKSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQzMiA9XG4gICAgbGV0IG9wZW4gU3RkbGliLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBTdGRsaWIuSW50NjQudG9faW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzIHN0YXRlID0gU3RkbGliLkludDMyLnRvX2ludCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHMgc3RhdGUgPVxuICAgIFN0ZGxpYi5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMiAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCByYWlzZV9jcm9zc2VkX2JvdW5kcyBuYW1lIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kIHN0cmluZ19vZl9ib3VuZCA9XG4gICAgUHJpbnRmLmZhaWx3aXRoZlxuICAgICAgXCJSYW5kb20uJXM6IGNyb3NzZWQgYm91bmRzIFslcyA+ICVzXVwiXG4gICAgICBuYW1lXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIGxvd2VyX2JvdW5kKVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCB1cHBlcl9ib3VuZClcbiAgICAgICgpXG4gICAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbiAgOztcblxuICBsZXQgaW50X2luY2wgPVxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50XCIgbG8gaGkgSW50LnRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgICAgaWYgZGlmZiA9IEludC5tYXhfdmFsdWVcbiAgICAgIHRoZW4gbG8gKyAoZnVsbF9yYW5nZV9pbnQgc3RhdGUgbGFuZCBJbnQubWF4X3ZhbHVlKVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBcbiAgICAgIHRoZW4gbG8gKyBpbnQgc3RhdGUgKEludC5zdWNjIGRpZmYpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDMyX2luY2wgPVxuICAgIGxldCBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gU3RkbGliLkludDMyIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQzMlwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwbFxuICAgICAgdGhlbiBhZGQgbG8gKGludDMyIHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfaW5jbCA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5OYXRpdmVpbnQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcIm5hdGl2ZWludFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9uYXRpdmVpbnQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMG5cbiAgICAgIHRoZW4gYWRkIGxvIChuYXRpdmVpbnQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDY0X2luY2wgPVxuICAgIGxldCBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gU3RkbGliLkludDY0IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQ2NFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwTFxuICAgICAgdGhlbiBhZGQgbG8gKGludDY0IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gICgqIFJldHVybiBhIHVuaWZvcm1seSByYW5kb20gZmxvYXQgaW4gWzAsIDEpLiAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHN0YXRlID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgc2NhbGUgPSAweDFwLTMwIGluXG4gICAgKCogMl4tMzAgKilcbiAgICBsZXQgcjEgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByMiA9IFN0ZGxpYi5mbG9hdF9vZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgbGV0IHJlc3VsdCA9ICgocjEgKi4gc2NhbGUpICsuIHIyKSAqLiBzY2FsZSBpblxuICAgICgqIFdpdGggdmVyeSBzbWFsbCBwcm9iYWJpbGl0eSwgcmVzdWx0IGNhbiByb3VuZCB1cCB0byAxLjAsIHNvIGluIHRoYXQgY2FzZSwgd2UganVzdFxuICAgICAgIHRyeSBhZ2Fpbi4gKilcbiAgICBpZiByZXN1bHQgPCAxLjAgdGhlbiByZXN1bHQgZWxzZSByYXdmbG9hdCBzdGF0ZVxuICA7O1xuXG4gIGxldCBmbG9hdCBzdGF0ZSBoaSA9IHJhd2Zsb2F0IHN0YXRlICouIGhpXG5cbiAgbGV0IGZsb2F0X3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJmbG9hdFwiIGxvIGhpIFN0ZGxpYi5zdHJpbmdfb2ZfZmxvYXQ7XG4gICAgbG8gKy4gZmxvYXQgc3RhdGUgKGhpIC0uIGxvKVxuICA7O1xuZW5kXG5cbmxldCBkZWZhdWx0ID0gU3RhdGUuZGVmYXVsdFxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgZGVmYXVsdFxubGV0IGludCB4ID0gU3RhdGUuaW50IGRlZmF1bHQgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgZGVmYXVsdCB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgZGVmYXVsdCB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgZGVmYXVsdCB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSBkZWZhdWx0IHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciBkZWZhdWx0XG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSBkZWZhdWx0XG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCAoUmVwci5nZXRfc3RhdGUgcylcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGw0IiwiYTIiLCJhMyIsImdsb2JhbF9kYXRhIiwiQmFzZV9SYW5kb21fcmVwciIsIkJhc2VfSW1wb3J0IiwiU3RkbGliX0ludDY0IiwiU3RkbGliX05hdGl2ZWludCIsIlN0ZGxpYl9JbnQzMiIsIkJhc2VfSW50MCIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX1JhbmRvbSIsIkJhc2VfQ2hhcjAiLCJCYXNlX1dvcmRfc2l6ZSIsImNzdF9pbml0aWFsaXppbmdfUmFuZG9tX3dpdGhfYSIsImR1bW15IiwiZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIiwiYWxsb3dfaW5fdGVzdHMiLCJiaXRzIiwidCIsImJpdHM2NCIsImJvb2wiLCJpbnQiLCJ4IiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsIm1ha2UiLCJzZWVkIiwiY29weSIsImNoYXIiLCJhc2NpaSIsIm1ha2Vfc2VsZl9pbml0IiwicGFyYW0iLCJhc3NpZ24iLCJjc3RfZmxvYXQiLCJjc3RfaW50NjQiLCJjc3RfbmF0aXZlaW50IiwiY3N0X2ludDMyIiwiY3N0X2ludCIsImRlZmF1bHQkIiwiaW50X29uXzY0Yml0cyIsImJvdW5kIiwiaW50X29uXzMyYml0cyIsInN0YXRlIiwiZnVsbF9yYW5nZV9pbnQ2NCIsImZ1bGxfcmFuZ2VfaW50MzIiLCJmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMiLCJmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHMiLCJmdWxsX3JhbmdlX2ludCIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfbmF0aXZlaW50IiwicmFpc2VfY3Jvc3NlZF9ib3VuZHMiLCJuYW1lIiwibG93ZXJfYm91bmQiLCJ1cHBlcl9ib3VuZCIsInN0cmluZ19vZl9ib3VuZCIsImludF9pbmNsIiwibG8iLCJoaSIsImRpZmYiLCJpbnQzMl9pbmNsIiwibmF0aXZlaW50X2luY2wiLCJpbnQ2NF9pbmNsIiwiZmxvYXQiLCJzY2FsZSIsInIxIiwicjIiLCJyZXN1bHQiLCJmbG9hdF9yYW5nZSIsInkiLCJmdWxsX2luaXQiLCJpbml0Iiwic2VsZl9pbml0Iiwic2V0X3N0YXRlIiwicyIsIkJhc2VfUmFuZG9tIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFB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QXZDLEdBQUFnRCxHQUN4QixpQ0FBNEI7QUFBQSxZQUFBUixpQkFBQXhDLEdBQUFnRCxHQUN4QixxQ0FBZ0M7QUFBQSxZQUFBUCxhQUFBekMsR0FBQWdELEdBQ3BDLGlDQUE0QjtBQUFBLFlBQUFELGNBQUEvQyxHQUFBZ0QsR0FDM0Isa0NBQTZCO0FBQUEsWUFBQWxELE9BQUFZLE9BQ3JDLHFCQUFrQjtBQUFBLFlBQUFILE9BQUFHLE9BQ2xCLHFCQUFrQjtBQUFBLFlBQUFGLFFBQUFFLE9BQ2pCLHNCQUFtQjtBQUFBLFlBQUF1QyxVQUFBNUM7QUFBQUEsSUFoTUEsT0FBK0IsaUJBQS9CLHVDQWlNZTtBQUFBO0FBQUEsWUFBQTZDLEtBQUE3QyxNQUNqQywyQkFBb0I7QUFBQSxZQUFBOEMsVUFBQXpELGdCQUFBZ0I7QUFBQUEsSUE3TmxDO0FBQUEsSUFDQSxPQTZOMkUsVUE3TjNFLGdDQTZOMkU7QUFBQTtBQUFBLFlBQUEwQyxVQUFBQztBQUFBQSxJQUN0QyxPQUFrQixpQkFBbEIsa0NBQWtCO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BcERyRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHJNSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjgwNjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYXJyYXlfcGVybXV0ZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBBbiBpbnRlcm5hbC1vbmx5IG1vZHVsZSBmYWN0b3JlZCBvdXQgZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIGNvcmVfYXJyYXlcbiAgICBhbmQgY29yZV9saXN0LiAgQ29udGFpbnMgY29kZSBmb3IgcGVybXV0aW5nIGFuIGFycmF5LiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbmxldCBwZXJtdXRlID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpID8ocG9zID0gMCkgP2xlbiB0ID1cbiAgKCogQ29waWVkIGZyb20gW09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgd2hlbiBjb21waWxpbmdcbiAgICAgd2l0aG91dCBmbGFtYmRhLiAqKVxuICBsZXQgdG90YWxfbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgbCAtPiBsXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgbGV0IG51bV9zd2FwcyA9IGxlbiAtIDEgaW5cbiAgZm9yIGkgPSBudW1fc3dhcHMgZG93bnRvIDEgZG9cbiAgICBsZXQgdGhpc19pID0gcG9zICsgaSBpblxuICAgICgqIFtyYW5kb21faV0gaXMgZHJhd24gZnJvbSBbcG9zLHRoaXNfaV0gKilcbiAgICBsZXQgcmFuZG9tX2kgPSBwb3MgKyBSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAoaSArIDEpIGluXG4gICAgc3dhcCB0IHRoaXNfaSByYW5kb21faVxuICBkb25lXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfUmFuZG9tIiwiQmFzZV9JbXBvcnQiLCJCYXNlX09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24iLCJCYXNlX0FycmF5MCIsImludmFsaWRfYXJnZiIsIkFycmF5IiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImNyZWF0ZV9sb2NhbCIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwiZm9sZF9yaWdodCIsIml0ZXIiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJzdGFibGVfc29ydCIsInN3YXAiLCJwZXJtdXRlIiwib3B0IiwibGVuIiwidCIsInJhbmRvbV9zdGF0ZSIsInBvcyIsInRvdGFsX2xlbmd0aCIsImwiLCJudW1fc3dhcHMiLCJpIiwidGhpc19pIiwicmFuZG9tX2kiLCJCYXNlX0FycmF5X3Blcm11dGUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsWUFBQUMsUUFBQSxHQUFBQyxLQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxlQ01ZO0FBQUEsS0FBQUMsTUFBQTtBQUFBLEtBQUFDLGVBR1Y7QUFBQSxJQUNBO0FBQUEsU0FBQUMsSUFBQSxRQUFBTCxRQUVjO0FBQUE7QUFBQSxTQUFBQSxRQUNGO0FBQUEsSUFFWjtBQUFBLFFBQUFNLFlBQ2dCO0FBQUEsSUFDaEI7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFDLFNBQ2U7QUFBQSxXQUVzQztBQUFBLFdBQTlCO0FBQUEsT0FBQUMsV0FBTjtBQUFBLE1BQ2Y7QUFBQSxjQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFKeEI7QUFBQSxHQUtJO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNRHRCTiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjgxNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0VxdWFsIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsYUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjgxNzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvb3JkZXJpbmcubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBMZXNzXG4gIHwgRXF1YWxcbiAgfCBHcmVhdGVyXG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2gsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgPSAoU3RkbGliLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxubGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnRcbiAgICAgICBoc3ZcbiAgICAgICAobWF0Y2ggYXJnIHdpdGhcbiAgICAgICAgfCBMZXNzIC0+IDBcbiAgICAgICAgfCBFcXVhbCAtPiAxXG4gICAgICAgIHwgR3JlYXRlciAtPiAyKVxuICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTGVzczsgRXF1YWw7IEdyZWF0ZXIgXSA6IHQgbGlzdClcblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJvcmRlcmluZy5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZXNzXCIgfCBcIkxlc3NcIikgLT4gTGVzc1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXF1YWxcIiB8IFwiRXF1YWxcIikgLT4gRXF1YWxcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImdyZWF0ZXJcIiB8IFwiR3JlYXRlclwiKSAtPiBHcmVhdGVyXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZXF1YWxcIiB8IFwiRXF1YWxcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImdyZWF0ZXJcIiB8IFwiR3JlYXRlclwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgfCBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgfCBMZXNzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkxlc3NcIlxuICAgfCBFcXVhbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJFcXVhbFwiXG4gICB8IEdyZWF0ZXIgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiR3JlYXRlclwiXG4gICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTGVzc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiRXF1YWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkdyZWF0ZXJcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxubGV0IGVxdWFsX19sb2NhbCBhIGIgPSBjb21wYXJlX19sb2NhbCBhIGIgPSAwXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSBfb3JkZXJpbmcgPSB0ID1cbiAgICB8IExlc3NcbiAgICB8IEVxdWFsXG4gICAgfCBHcmVhdGVyXG5lbmRcblxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBMZXNzIGVsc2UgaWYgbiA9IDAgdGhlbiBFcXVhbCBlbHNlIEdyZWF0ZXJcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTGVzcyAtPiAtMVxuICB8IEVxdWFsIC0+IDBcbiAgfCBHcmVhdGVyIC0+IDFcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9FcXVhbCIsImNzdF9HcmVhdGVyIiwiY3N0X0xlc3MiLCJjc3RfZXF1YWwiLCJjc3RfZ3JlYXRlciIsImNzdF9sZXNzIiwiY2FtbF9pbnRfY29tcGFyZSIsImdsb2JhbF9kYXRhIiwiYWxsIiwiZXJyb3Jfc291cmNlXzAwNSIsInRfc2V4cF9ncmFtbWFyIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9IYXNoIiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmUiLCJoYXNoX2ZvbGRfdCIsImhzdiIsImFyZyIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwXzAwNiIsIm1hdGNoIiwic2V4cF9vZl90IiwicGFyYW0iLCJlcXVhbCIsImEiLCJiIiwiZXF1YWxfbG9jYWwiLCJFeHBvcnQiLCJvZl9pbnQiLCJuIiwidG9faW50IiwiQmFzZV9PcmRlcmluZyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLFFDbUNHO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFlBQUFDLEtBQUFDO0FBQUFBLElBdEJFO0FBQUE7QUFBQSxlQUdhO0FBQUE7QUFBQSxlQUNDO0FBQUEsdUJBQ0U7QUFBQTtBQUFBLElBTGhCLHNDQUtrQjtBQUFBO0FBQUEsWUFBQUMsS0FBQUQ7QUFBQUEsUUFBQUQsTUFPTixvQ0FDVjtBQUFBLElBQW1CLGlDQUVUO0FBQUE7QUFBQSxZQUFBRyxVQUFBQztBQUFBQTtBQUFBQTtBQUFBQSxLQU9kO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUMwQztBQUFBO0FBQUEsT0FFTTtBQUFBO0FBQUEsTUFESjtBQUFBO0FBQUEsU0FBQUMsUUFGNUM7QUFBQTtBQUFBLE1BYUU7QUFBQSxnREFDb0Y7QUFBQSxTQUFBQSxVQWR0RjtBQUFBO0FBQUEsTUFXRTtBQUFBLGdEQUdvRjtBQUFBLGFBZHRGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FLRTtBQUFBLGlEQVNvRjtBQUFBO0FBQUEsTUFMcEY7QUFBQSxnREFLb0Y7QUFBQTtBQUFBLEtBUHBGLHlFQU9vRjtBQUFBO0FBQUEsSUFBdEUsMEVBQXNFO0FBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQSxJQUt0RixzQkFDVSxpQkFDQyxrQkFDRTtBQUFBO0FBQUEsR0FBNEI7QUFBQSxZQUFBQyxNQUFBQyxHQUFBQyxHQWhEbEIsMkNBbUVDLENBQUk7QUFBQSxZQUFBQyxZQUFBRixHQUFBQyxHQUNSLDJDQUFrQixDQUFJO0FBQUEsT0FBQUUsU0ExQzFDO0FBQUEsWUFBQUMsT0FBQUMsR0FtRFksbUNBQXdEO0FBQUEsWUFBQUMsT0FBQVI7QUFBQUEsSUFFMUQsc0JBQ0Qsa0JBQ0Msa0JBQ0U7QUFBQTtBQUFBLEdBQUM7QUFBQTtBQUFBLElBQUFTO0FBQUFBLE1BeERiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURuQ0giLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo4MzA0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2xpc3QubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcbmluY2x1ZGUgTGlzdDFcblxuKCogVGhpcyBpdHNlbGYgaW5jbHVkZXMgW0xpc3QwXS4gKilcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gICAgZnVuICh0eXBlIGFfXzAwMV8pIDogKChhX18wMDFfIC0+IGFfXzAwMV8pIC0+IGFfXzAwMV8gdCAtPiBhX18wMDFfIHQpIC0+XG4gICAgZ2xvYmFsaXplX2xpc3RcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGlzdF9vZl9zZXhwXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xpc3RcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gbGlzdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE9yX3VuZXF1YWxfbGVuZ3RocyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgT2sgb2YgJ2FcbiAgICB8IFVuZXF1YWxfbGVuZ3Roc1xuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAxNF8gYl9fMDE1XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDE0XyBiX18wMTVfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMTRfLCBiX18wMTVfIHdpdGhcbiAgICAgIHwgT2sgX2FfXzAxNl8sIE9rIF9iX18wMTdfIC0+IF9jbXBfX2EgX2FfXzAxNl8gX2JfXzAxN19cbiAgICAgIHwgT2sgXywgXyAtPiAtMVxuICAgICAgfCBfLCBPayBfIC0+IDFcbiAgICAgIHwgVW5lcXVhbF9sZW5ndGhzLCBVbmVxdWFsX2xlbmd0aHMgLT4gMClcbiAgOztcblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMTBfIGJfXzAxMV8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAxMF8gYl9fMDExX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDEwXywgYl9fMDExXyB3aXRoXG4gICAgICB8IE9rIF9hX18wMTJfLCBPayBfYl9fMDEzXyAtPiBfY21wX19hIF9hX18wMTJfIF9iX18wMTNfXG4gICAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICAgIHwgXywgT2sgXyAtPiAxXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocywgVW5lcXVhbF9sZW5ndGhzIC0+IDApXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuICh0eXBlIGFfXzAyMV8pIDogKChhX18wMjFfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gYV9fMDIxXyB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxOF8gLT4gZnVuY3Rpb25cbiAgICB8IE9rIGFyZzBfXzAxOV8gLT5cbiAgICAgIGxldCByZXMwX18wMjBfID0gX29mX2FfXzAxOF8gYXJnMF9fMDE5XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDIwXyBdXG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbF9sZW5ndGhzXCJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxubGV0IG9mX2xpc3QgdCA9IHRcbmxldCBzaW5nbGV0b24geCA9IFsgeCBdXG5cbmxldCByYW5nZScgfmNvbXBhcmUgfnN0cmlkZSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBsZXQgbmV4dF9pID0gc3RyaWRlIHN0YXJ0X2kgaW5cbiAgbGV0IG9yZGVyIHggeSA9IE9yZGVyaW5nLm9mX2ludCAoY29tcGFyZSB4IHkpIGluXG4gIGxldCByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpID1cbiAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IHJldHVybiB0aGUgc2FtZSB2YWx1ZVwiXG4gIGluXG4gIGxldCBpbml0aWFsX3N0cmlkZV9vcmRlciA9XG4gICAgbWF0Y2ggb3JkZXIgc3RhcnRfaSBuZXh0X2kgd2l0aFxuICAgIHwgRXF1YWwgLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgIHwgTGVzcyAtPiBgTGVzc1xuICAgIHwgR3JlYXRlciAtPiBgR3JlYXRlclxuICBpblxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIGkgPVxuICAgIGxldCBpX3RvX3N0b3Bfb3JkZXIgPSBvcmRlciBpIHN0b3BfaSBpblxuICAgIG1hdGNoIGlfdG9fc3RvcF9vcmRlciwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPlxuICAgICAgKCogaGF2ZW4ndCB5ZXQgcmVhY2hlZCBbc3RvcF9pXS4gQ29udGludWUuICopXG4gICAgICBsZXQgbmV4dF9pID0gc3RyaWRlIGkgaW5cbiAgICAgIChtYXRjaCBvcmRlciBpIG5leHRfaSwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgICAgIHwgRXF1YWwsIF8gLT4gKHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgW0B0YWlsY2FsbCBmYWxzZV0pICgpXG4gICAgICAgfCBMZXNzLCBgR3JlYXRlciB8IEdyZWF0ZXIsIGBMZXNzIC0+XG4gICAgICAgICBpbnZhbGlkX2FyZyBcIkxpc3QucmFuZ2UnOiBzdHJpZGUgZnVuY3Rpb24gY2Fubm90IGNoYW5nZSBkaXJlY3Rpb25cIlxuICAgICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPiBpIDo6IGxvb3AgbmV4dF9pKVxuICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgKCogc3RlcHBlZCBwYXN0IFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICBbXVxuICAgIHwgRXF1YWwsIF8gLT5cbiAgICAgICgqIHJlYWNoZWQgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIChtYXRjaCBzdG9wIHdpdGhcbiAgICAgICB8IGBpbmNsdXNpdmUgLT4gWyBpIF1cbiAgICAgICB8IGBleGNsdXNpdmUgLT4gW10pXG4gIGluXG4gIGxldCBzdGFydF9pID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X2lcbiAgICB8IGBleGNsdXNpdmUgLT4gbmV4dF9pXG4gIGluXG4gIGxvb3Agc3RhcnRfaSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBpZiBzdHJpZGUgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlOiBzdHJpZGUgbXVzdCBiZSBub24temVyb1wiO1xuICByYW5nZScgfmNvbXBhcmUgfnN0cmlkZTooZnVuIHggLT4geCArIHN0cmlkZSkgfnN0YXJ0IH5zdG9wIHN0YXJ0X2kgc3RvcF9pXG47O1xuXG5sZXQgaGQgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IF8gLT4gU29tZSB4XG47O1xuXG5sZXQgdGwgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IHQnIC0+IFNvbWUgdCdcbjs7XG5cbmxldCBudGggdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbnRoX2F1eCB0IG4gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYSA6OiB0IC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCB0IChuIC0gMSlcbiAgICBpblxuICAgIG50aF9hdXggdCBuKVxuOztcblxubGV0IG50aF9leG4gdCBuID1cbiAgbWF0Y2ggbnRoIHQgbiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJMaXN0Lm50aF9leG4gJWQgY2FsbGVkIG9uIGxpc3Qgb2YgbGVuZ3RoICVkXCIgbiAobGVuZ3RoIHQpICgpXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB1bm9yZGVyZWRfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbCB8IGwsIFtdIC0+IGxcbiAgfCBfIC0+IHJldl9hcHBlbmQgbDEgbDJcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiAtPiBsb29wIGEgYiAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfIHwgXywgW10gLT4gVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYiB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSBsMSBsMiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYiB9IC0+XG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIlxuICAgICAgbmFtZVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hKVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iKVxuICAgICAgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgyIGwxIGwyIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9jIDogJ2MgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiBsMyA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBjIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiwgYyB3aXRoXG4gICAgICB8IFtdLCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiwgXyA6OiBjIC0+IGxvb3AgYSBiIGMgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXywgXyB8IF8sIFtdLCBfIHwgXywgXywgW10gLT5cbiAgICAgICAgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYjsgdGFpbF9vZl9jID0gYyB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIGwzIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoM19leG4gbmFtZSBsMSBsMiBsMyA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYjsgdGFpbF9vZl9jIH0gLT5cbiAgICBsZXQgbjEgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSBpblxuICAgIGxldCBuMiA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iIGluXG4gICAgbGV0IG4zID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2MgaW5cbiAgICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkIHx8ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiBuMiBuMyAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMiBsMylcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbmxldCBpdGVyMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGl0ZXIyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCBpdGVyMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIml0ZXIyX2V4blwiIGwxIGwyO1xuICBpdGVyMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjoocmV2X21hcDJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IHJldl9tYXAyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwicmV2X21hcDJfZXhuXCIgbDEgbDI7XG4gIHJldl9tYXAyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgZm9sZDIgbDEgbDIgfmluaXQgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb2xkMl9vayB+aW5pdCB+ZikgW0Bub250YWlsXVxuXG5sZXQgZm9sZDJfZXhuIGwxIGwyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb2xkMl9leG5cIiBsMSBsMjtcbiAgZm9sZDJfb2sgbDEgbDIgfmluaXQgfmZcbjs7XG5cbmxldCBmb2xkX3JpZ2h0MiBsMSBsMiB+ZiB+aW5pdCA9XG4gIGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvbGRfcmlnaHQyX29rIH5mIH5pbml0KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9yaWdodDJfZXhuIGwxIGwyIH5mIH5pbml0ID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb2xkX3JpZ2h0Ml9leG5cIiBsMSBsMjtcbiAgZm9sZF9yaWdodDJfb2sgbDEgbDIgfmYgfmluaXRcbjs7XG5cbmxldCBmb3JfYWxsMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvcl9hbGwyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCBmb3JfYWxsMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImZvcl9hbGwyX2V4blwiIGwxIGwyO1xuICBmb3JfYWxsMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGV4aXN0czIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihleGlzdHMyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCBleGlzdHMyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZXhpc3RzMl9leG5cIiBsMSBsMjtcbiAgZXhpc3RzMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIGVxdWFsIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IGIgOjogYnMgLT4gZXF1YWwgYSBiIHx8IGxvb3AgZXF1YWwgYSBic1xuICBpblxuICBsb29wIGVxdWFsIGEgdFxuOztcblxuKCogVGhpcyBpcyBhIGNvcHkgb2YgdGhlIGNvZGUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCBhbiBleHRyYSBldGEtZXhwYW5zaW9uIHRvXG4gICBhdm9pZCBjcmVhdGluZyBwYXJ0aWFsIGNsb3N1cmVzIChzaG93ZWQgdXAgZm9yIFtmaWx0ZXJdKSBpbiBwcm9maWxpbmcpLiAqKVxubGV0IHJldl9maWx0ZXIgdCB+ZiA9XG4gIGxldCByZWMgZmluZCB+ZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBmaW5kIH5mICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIH5mIGFjY3UgbFxuICBpblxuICBmaW5kIH5mIFtdIHRcbjs7XG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbHRlciBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiBpZiBmIGhkIHRoZW4gaGQgOjogZmlsdGVyIHRsIH5mIGVsc2UgZmlsdGVyIHRsIH5mXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIGxcbiAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIGluXG4gIGxvb3AgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBsb29wIGxcbiAgaW5cbiAgbG9vcCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmVjIGZpbmRfZXhuIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCB4IDo6IHQgLT4gaWYgZiB4IHRoZW4geCBlbHNlIGZpbmRfZXhuIHQgfmZcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX2V4blxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgKGksIHgpIGVsc2UgbG9vcCAoaSArIDEpIGxcbiAgaW5cbiAgbG9vcCAwIHQgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICBmaW5kaV9leG5cbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiBpIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGwpXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHRydWVcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCAmJiBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHQgW0Bub250YWlsXVxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCB8fCBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHQgW0Bub250YWlsXVxuOztcblxuKCoqIEZvciB0aGUgY29udGFpbmVyIGludGVyZmFjZS4gKilcbmxldCBmb2xkX2xlZnQgPSBmb2xkXG5cbmxldCBvZl9hcnJheSA9IEFycmF5LnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEFycmF5Lm9mX2xpc3RcbmxldCB0b19saXN0IHQgPSB0XG5cbigqKiBUYWlsIHJlY3Vyc2l2ZSB2ZXJzaW9ucyBvZiBzdGFuZGFyZCBbTGlzdF0gbW9kdWxlICopXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGFwcGVuZF9sb29wIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICB8IFtdIC0+IGwyXG4gIHwgWyB4MSBdIC0+IHgxIDo6IGwyXG4gIHwgWyB4MTsgeDIgXSAtPiB4MSA6OiB4MiA6OiBsMlxuICB8IFsgeDE7IHgyOyB4MyBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IGwyXG4gIHwgWyB4MTsgeDI7IHgzOyB4NCBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IGwyXG4gIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiAoYXBwZW5kX2xvb3AgW0B0YWlsY2FsbF0pIHRsIGwyXG47O1xuXG5sZXQgYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDIgd2l0aFxuICB8IFtdIC0+IGwxXG4gIHwgXyA6OiBfIC0+IGFwcGVuZF9sb29wIGwxIGwyXG47O1xuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXAgbCB+ZiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiB0bCAtPiBmIHggOjogKG1hcCBbQHRhaWxjYWxsXSkgdGwgfmZcbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcCB0IH5mOihmdW4geCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgKCA+PnwgKSBsIGYgPSBtYXAgbCB+ZlxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXAyX29rIGwxIGwyIH5mID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gW11cbiAgfCB4MSA6OiBsMSwgeDIgOjogbDIgLT4gZiB4MSB4MiA6OiBtYXAyX29rIGwxIGwyIH5mXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG47O1xuXG5sZXQgbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KG1hcDJfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IG1hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJtYXAyX2V4blwiIGwxIGwyO1xuICBtYXAyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmYgPVxuICBsZXQgcmVjIGxvb3AgbDEgbDIgbDMgYWMgPVxuICAgIG1hdGNoIGwxLCBsMiwgbDMgd2l0aFxuICAgIHwgW10sIFtdLCBbXSAtPiBhY1xuICAgIHwgeDEgOjogbDEsIHgyIDo6IGwyLCB4MyA6OiBsMyAtPiBsb29wIGwxIGwyIGwzIChmIHgxIHgyIHgzIDo6IGFjKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgbG9vcCBsMSBsMiBsMyBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmV2X21hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihyZXZfbWFwM19vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgcmV2X21hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJyZXZfbWFwM19leG5cIiBsMSBsMiBsMztcbiAgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcDNfb2sgbDEgbDIgbDMgfmYgPVxuICBtYXRjaCBsMSwgbDIsIGwzIHdpdGhcbiAgfCBbXSwgW10sIFtdIC0+IFtdXG4gIHwgeDEgOjogbDEsIHgyIDo6IGwyLCB4MyA6OiBsMyAtPiBmIHgxIHgyIHgzIDo6IG1hcDNfb2sgbDEgbDIgbDMgfmZcbiAgfCBfLCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAzXCJcbjs7XG5cbmxldCBtYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoobWFwM19vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgbWFwM19leG4gbDEgbDIgbDMgfmYgPVxuICBjaGVja19sZW5ndGgzX2V4biBcIm1hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIG1hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCByZWMgcmV2X21hcF9hcHBlbmQgbDEgbDIgfmYgPVxuICBtYXRjaCBsMSB3aXRoXG4gIHwgW10gLT4gbDJcbiAgfCBoIDo6IHQgLT4gcmV2X21hcF9hcHBlbmQgfmYgdCAoZiBoIDo6IGwyKVxuOztcblxubGV0IHVuemlwIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDJcbiAgICB8ICh4LCB5KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMilcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdXG47O1xuXG5sZXQgdW56aXAzIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiBsMyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDIsIGwzXG4gICAgfCAoeCwgeSwgeikgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpICh6IDo6IGwzKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW10gW11cbjs7XG5cbmxldCB6aXBfZXhuIGwxIGwyID1cbiAgdHJ5IG1hcDJfb2sgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDIgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluIHppcF9leG46ICVkIDw+ICVkXCIgKGxlbmd0aCBsMSkgKGxlbmd0aCBsMikgKClcbjs7XG5cbmxldCB6aXAgbDEgbDIgPSBtYXAyIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyXG5cbigqKiBBZGRpdGlvbmFsIGxpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmV2X21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGggOjogdCAtPiBsb29wIChpICsgMSkgKGYgaSBoIDo6IGFjYykgdFxuICBpblxuICBsb29wIDAgW10gbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwaSBsIH5mID1cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCBoIDo6IHQgLT4gZiBpIGggOjogbG9vcCAoaSArIDEpIHRcbiAgaW5cbiAgbG9vcCAwIGwgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBpdGVyaSBsIH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgbCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgICA6IGludClcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgc25kIChmb2xkIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgdiAtPiBpICsgMSwgZiBpIGFjYyB2KSlcbjs7XG5cbmxldCBmaWx0ZXJpIGwgfmYgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIHBvcyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFtdXG4gICAgfCBoZCA6OiB0bCAtPiBpZiBmIHBvcyBoZCB0aGVuIGhkIDo6IGxvb3AgKHBvcyArIDEpIHRsIGVsc2UgbG9vcCAocG9zICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIGwgW0Bub250YWlsXVxuOztcblxubGV0IHJlZHVjZSBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGhkIDo6IHRsIC0+IFNvbWUgKGZvbGQgfmluaXQ6aGQgfmYgdGwpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkIGwgfmYgPVxuICAoKiBDYWxsIHRoZSBcInNpemVcIiBvZiBhIHZhbHVlIHRoZSBudW1iZXIgb2YgbGlzdCBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjb21iaW5lZCBpbnRvXG4gICAgIGl0IHZpYSBjYWxscyB0byBbZl0uICBXZSBwcm9jZWVkIGJ5IHVzaW5nIFtmXSB0byBjb21iaW5lIGVsZW1lbnRzIGluIHRoZSBhY2N1bXVsYXRvclxuICAgICBvZiB0aGUgc2FtZSBzaXplIHVudGlsIHdlIGNhbid0IGNvbWJpbmUgYW55IG1vcmUsIHRoZW4gZ2V0dGluZyBhIG5ldyBlbGVtZW50IGZyb20gdGhlXG4gICAgIGlucHV0IGxpc3QgYW5kIHJlcGVhdGluZy5cblxuICAgICBXaXRoIHRoaXMgc3RyYXRlZ3ksIGluIHRoZSBhY2N1bXVsYXRvcjpcbiAgICAgLSB3ZSBvbmx5IGV2ZXIgaGF2ZSBlbGVtZW50cyBvZiBzaXplcyBhIHBvd2VyIG9mIHR3b1xuICAgICAtIHdlIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBlbGVtZW50IG9mIGVhY2ggc2l6ZVxuICAgICAtIHRoZSBzdW0gb2YgYWxsIHRoZSBlbGVtZW50IHNpemVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWRcblxuICAgICBUaGVzZSBjb25kaXRpb25zIGVuZm9yY2UgdGhhdCBsaXN0IG9mIGVsZW1lbnRzIG9mIGVhY2ggc2l6ZSBpcyBwcmVjaXNlbHkgdGhlIGJpbmFyeVxuICAgICBleHBhbnNpb24gb2YgdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZDogaWYgeW91J3ZlIGNvbnN1bWVkIDEzID0gMGIxMTAxXG4gICAgIGVsZW1lbnRzLCB5b3UgaGF2ZSBvbmUgZWxlbWVudCBvZiBzaXplIDgsIG9uZSBvZiBzaXplIDQsIGFuZCBvbmUgb2Ygc2l6ZSAxLiAgSGVuY2VcbiAgICAgd2hlbiBhIG5ldyBlbGVtZW50IGNvbWVzIGFsb25nLCB0aGUgbnVtYmVyIG9mIGNvbWJpbmluZ3MgeW91IG5lZWQgdG8gZG8gaXMgdGhlIG51bWJlclxuICAgICBvZiB0cmFpbGluZyAxcyBpbiB0aGUgYmluYXJ5IGV4cGFuc2lvbiBvZiBbbnVtXSwgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgYWxyZWFkeSBnb25lIGludG8gdGhlIGFjY3VtdWxhdG9yLiAgVGhlIGFjY3VtdWxhdG9yIGlzIGluIGFzY2VuZGluZyBvcmRlciBvZiBzaXplLCBzb1xuICAgICB0aGUgbmV4dCBlbGVtZW50IHRvIGNvbWJpbmUgd2l0aCBpcyBhbHdheXMgdGhlIGhlYWQgb2YgdGhlIGxpc3QuICopXG4gIGxldCByZWMgc3RlcF9hY2N1bSBudW0gYWNjIHggPVxuICAgIGlmIG51bSBsYW5kIDEgPSAwXG4gICAgdGhlbiB4IDo6IGFjY1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAoKiBOZXcgZWxlbWVudHMgZnJvbSBsYXRlciBpbiB0aGUgaW5wdXQgbGlzdCBnbyBvbiB0aGUgZnJvbnQgb2YgdGhlIGFjY3VtdWxhdG9yLCBzb1xuICAgICAgICAgdGhlIGFjY3VtdWxhdG9yIGlzIGluIHJldmVyc2Ugb3JkZXIgd3J0IHRoZSBvcmlnaW5hbCBsaXN0IG9yZGVyLCBoZW5jZSBbZiB5IHhdXG4gICAgICAgICBpbnN0ZWFkIG9mIFtmIHggeV0uICopXG4gICAgICB8IHkgOjogeXMgLT4gc3RlcF9hY2N1bSAobnVtIGFzciAxKSB5cyAoZiB5IHgpKVxuICBpblxuICAoKiBFeHBlcmltZW50YWxseSwgaW5saW5pbmcgW2ZvbGRpXSBhbmQgdW5yb2xsaW5nIHRoaXMgbG9vcCBhIGZldyB0aW1lcyBjYW4gcmVkdWNlXG4gICAgIHJ1bnRpbWUgZG93biB0byBhIHRoaXJkIGFuZCBhbGxvY2F0aW9uIHRvIDEvMTZ0aCBvciBzbyBpbiB0aGUgbWljcm9iZW5jaG1hcmtzIGJlbG93LlxuICAgICBIb3dldmVyLCBpbiBtb3N0IHVzZSBjYXNlcyBbZl0gaXMgbGlrZWx5IHRvIGJlIGV4cGVuc2l2ZSAob3RoZXJ3aXNlIHdoeSBkbyB5b3UgY2FyZVxuICAgICBhYm91dCB0aGUgb3JkZXIgb2YgcmVkdWN0aW9uPykgc28gdGhlIG92ZXJoZWFkIG9mIHRoaXMgZnVuY3Rpb24gaXRzZWxmIGRvZXNuJ3QgcmVhbGx5XG4gICAgIG1hdHRlci4gSWYgeW91IGNvbWUgdXAgd2l0aCBhIHVzZS1jYXNlIHdoZXJlIGl0IGRvZXMsIHRoZW4gdGhhdCdzIHNvbWV0aGluZyB5b3UgbWlnaHRcbiAgICAgd2FudCB0byB0cnk6IHNlZSBoZyBsb2cgLXByIDQ5ZWYwNjVmNDI5ZC4gKilcbiAgbWF0Y2ggZm9sZGkgbCB+aW5pdDpbXSB+ZjpzdGVwX2FjY3VtIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBTb21lIChmb2xkIHhzIH5pbml0OnggfmY6KGZ1biB4IHkgLT4gZiB5IHgpKVxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZF9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZV9iYWxhbmNlZCBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfYmFsYW5jZWRfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IGdyb3VwaSBsIH5icmVhayA9XG4gICgqIFdlIGFsbG9jYXRlIHNoYXJlZCBwb3NpdGlvbiBhbmQgbGlzdCByZWZlcmVuY2VzIHNvIHdlIGNhbiBtYWtlIHRoZSBpbm5lciBsb29wIHVzZVxuICAgICBbW0B0YWlsX21vZF9jb25zXV0sIGFuZCBzdGlsbCByZXR1cm4gYmFjayBpbmZvcm1hdGlvbiBhYm91dCBwb3NpdGlvbiBhbmQgd2hlcmUgaW4gdGhlXG4gICAgIGxpc3Qgd2UgbGVmdCBvZmYuICopXG4gIGxldCBwb3MgPSByZWYgMCBpblxuICBsZXQgbCA9IHJlZiBsIGluXG4gICgqIEFzIGEgcmVzdWx0IG9mIHVzaW5nIGxvY2FsIHJlZmVyZW5jZXMsIG91ciBpbm5lciBsb29wIGRvZXMgbm90IG5lZWQgYXJndW1lbnRzLiAqKVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyB0YWtlX2dyb3VwICgpID1cbiAgICBtYXRjaCAhbCB3aXRoXG4gICAgfCAoW10gfCBbIF8gXSkgYXMgZ3JvdXAgLT5cbiAgICAgIGwgOj0gW107XG4gICAgICBncm91cFxuICAgIHwgeCA6OiAoeSA6OiBfIGFzIHRsKSAtPlxuICAgICAgcG9zIDo9ICFwb3MgKyAxO1xuICAgICAgbCA6PSB0bDtcbiAgICAgIGlmIGJyZWFrICFwb3MgeCB5IHRoZW4gWyB4IF0gZWxzZSB4IDo6IHRha2VfZ3JvdXAgKClcbiAgaW5cbiAgKCogT3VyIG91dGVyIGxvb3AgZG9lcyBub3QgbmVlZCBhcmd1bWVudHMsIGVpdGhlci4gKilcbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgZ3JvdXBzICgpID1cbiAgICBpZiBpc19lbXB0eSAhbFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgIGxldCBncm91cCA9IHRha2VfZ3JvdXAgKCkgaW5cbiAgICAgIGdyb3VwIDo6IGdyb3VwcyAoKSlcbiAgaW5cbiAgZ3JvdXBzICgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBncm91cCBsIH5icmVhayA9IGdyb3VwaSBsIH5icmVhazooZnVuIF8geCB5IC0+IGJyZWFrIHggeSkgW0Bub250YWlsXVxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtZXJnZSBsMSBsMiB+Y29tcGFyZSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgaWYgY29tcGFyZSBoMSBoMiA8PSAwIHRoZW4gaDEgOjogbWVyZ2UgdDEgbDIgfmNvbXBhcmUgZWxzZSBoMiA6OiBtZXJnZSBsMSB0MiB+Y29tcGFyZVxuOztcblxubGV0IHN0YWJsZV9zb3J0IGwgfmNvbXBhcmU6Y21wID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgY21wIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIHJldl9tZXJnZSBjbXAgdDEgbDIgKGgxIDo6IGFjY3UpXG4gICAgICBlbHNlIHJldl9tZXJnZSBjbXAgbDEgdDIgKGgyIDo6IGFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBjbXAgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IGNtcCB0MSBsMiAoaDEgOjogYWNjdSlcbiAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBjbXAgbDEgdDIgKGgyIDo6IGFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbIHgxOyB4MiBdIGVsc2UgWyB4MjsgeDEgXSBpblxuICAgICAgcywgdGxcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMFxuICAgICAgICAgIHRoZW4gWyB4MTsgeDI7IHgzIF1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwXG4gICAgICAgICAgdGhlbiBbIHgxOyB4MzsgeDIgXVxuICAgICAgICAgIGVsc2UgWyB4MzsgeDE7IHgyIF1cbiAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMFxuICAgICAgICB0aGVuIFsgeDI7IHgxOyB4MyBdXG4gICAgICAgIGVsc2UgaWYgY21wIHgyIHgzIDw9IDBcbiAgICAgICAgdGhlbiBbIHgyOyB4MzsgeDEgXVxuICAgICAgICBlbHNlIFsgeDM7IHgyOyB4MSBdXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IG4sIGwgLT5cbiAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgcmV2X21lcmdlX3JldiBjbXAgczEgczIgW10sIHRsXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFsgeDE7IHgyIF0gZWxzZSBbIHgyOyB4MSBdIGluXG4gICAgICBzLCB0bFxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgaWYgY21wIHgxIHgyID4gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgY21wIHgyIHgzID4gMFxuICAgICAgICAgIHRoZW4gWyB4MTsgeDI7IHgzIF1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDBcbiAgICAgICAgICB0aGVuIFsgeDE7IHgzOyB4MiBdXG4gICAgICAgICAgZWxzZSBbIHgzOyB4MTsgeDIgXVxuICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDBcbiAgICAgICAgdGhlbiBbIHgyOyB4MTsgeDMgXVxuICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDBcbiAgICAgICAgdGhlbiBbIHgyOyB4MzsgeDEgXVxuICAgICAgICBlbHNlIFsgeDM7IHgyOyB4MSBdXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IG4sIGwgLT5cbiAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgIHJldl9tZXJnZSBjbXAgczEgczIgW10sIHRsXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcbjs7XG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcblxubGV0IHNvcnRfYW5kX2dyb3VwIGwgfmNvbXBhcmUgPVxuICAobCB8PiBzdGFibGVfc29ydCB+Y29tcGFyZSB8PiBncm91cCB+YnJlYWs6KGZ1biB4IHkgLT4gY29tcGFyZSB4IHkgPD4gMCkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBkZWR1cF9hbmRfc29ydCBsIH5jb21wYXJlOmNtcCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGNtcCBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICAobWF0Y2ggY21wIGgxIGgyIHdpdGhcbiAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiByZXZfbWVyZ2UgY21wIHQxIGwyIChoMSA6OiBhY2N1KVxuICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IHJldl9tZXJnZSBjbXAgbDEgdDIgKGgyIDo6IGFjY3UpXG4gICAgICAgfCBfIC0+IHJldl9tZXJnZSBjbXAgdDEgbDIgYWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGNtcCBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICAobWF0Y2ggY21wIGgxIGgyIHdpdGhcbiAgICAgICB8IGMgd2hlbiBjID4gMCAtPiByZXZfbWVyZ2VfcmV2IGNtcCB0MSBsMiAoaDEgOjogYWNjdSlcbiAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiByZXZfbWVyZ2VfcmV2IGNtcCBsMSB0MiAoaDIgOjogYWNjdSlcbiAgICAgICB8IF8gLT4gcmV2X21lcmdlX3JldiBjbXAgdDEgbDIgYWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBtYXRjaCBjbXAgeDEgeDIgd2l0aFxuICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgxOyB4MiBdXG4gICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDI7IHgxIF1cbiAgICAgICAgfCBfIC0+IFsgeDIgXVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBtYXRjaCBjbXAgeDEgeDIgd2l0aFxuICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgxOyB4MjsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPlxuICAgICAgICAgICAgIChtYXRjaCBjbXAgeDEgeDMgd2l0aFxuICAgICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgxOyB4MzsgeDIgXVxuICAgICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgzOyB4MTsgeDIgXVxuICAgICAgICAgICAgICB8IF8gLT4gWyB4MzsgeDIgXSlcbiAgICAgICAgICAgfCBfIC0+IFsgeDE7IHgzIF0pXG4gICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MSB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDI7IHgxOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+XG4gICAgICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDI7IHgzOyB4MSBdXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDM7IHgyOyB4MSBdXG4gICAgICAgICAgICAgIHwgXyAtPiBbIHgzOyB4MSBdKVxuICAgICAgICAgICB8IF8gLT4gWyB4MjsgeDMgXSlcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDI7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MzsgeDIgXVxuICAgICAgICAgICB8IF8gLT4gWyB4MyBdKVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCBuLCBsIC0+XG4gICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgIHJldl9tZXJnZV9yZXYgY21wIHMxIHMyIFtdLCB0bFxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIG1hdGNoIGNtcCB4MSB4MiB3aXRoXG4gICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDE7IHgyIF1cbiAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MjsgeDEgXVxuICAgICAgICB8IF8gLT4gWyB4MiBdXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIG1hdGNoIGNtcCB4MSB4MiB3aXRoXG4gICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDE7IHgyOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+XG4gICAgICAgICAgICAgKG1hdGNoIGNtcCB4MSB4MyB3aXRoXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDE7IHgzOyB4MiBdXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDM7IHgxOyB4MiBdXG4gICAgICAgICAgICAgIHwgXyAtPiBbIHgzOyB4MiBdKVxuICAgICAgICAgICB8IF8gLT4gWyB4MTsgeDMgXSlcbiAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgxIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MjsgeDE7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT5cbiAgICAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MjsgeDM7IHgxIF1cbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MzsgeDI7IHgxIF1cbiAgICAgICAgICAgICAgfCBfIC0+IFsgeDM7IHgxIF0pXG4gICAgICAgICAgIHwgXyAtPiBbIHgyOyB4MyBdKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MjsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgzOyB4MiBdXG4gICAgICAgICAgIHwgXyAtPiBbIHgzIF0pXG4gICAgICBpblxuICAgICAgcywgdGxcbiAgICB8IG4sIGwgLT5cbiAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgIHJldl9tZXJnZSBjbXAgczEgczIgW10sIHRsXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcbjs7XG5cbmxldCBzdGFibGVfZGVkdXAgbGlzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIHwgWyBfIF0gLT4gbGlzdCAoKiBzcGVjaWFsIGNhc2UgZm9yIHBlcmZvcm1hbmNlICopXG4gIHwgXyA6OiBfIDo6IF8gLT5cbiAgICBsZXQgb3BlbiBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgZGVkdXAgPVxuICAgICAgICB7IGVsdCA6ICdhXG4gICAgICAgIDsgbXV0YWJsZSBkdXAgOiBib29sXG4gICAgICAgIH1cbiAgICBlbmQgaW5cbiAgICAoKiBbc3RhYmxlX2RlZHVwXSBrZWVwcyB0aGUgZmlyc3Qgb2YgZWFjaCBzZXQgb2YgZHVwbGljYXRlcy4gW2RlZHVwX2FuZF9zb3J0XSBrZWVwc1xuICAgICAgIHRoZSBsYXN0LiBXZSBkZWZpbmUgb25lIGluIHRlcm1zIG9mIHRoZSBvdGhlciBieSBwYXNzaW5nIHRoZSB2YWx1ZXMgaW4gcmV2ZXJzZVxuICAgICAgIG9yZGVyLCBoZW5jZSB0aGUgW3Jldl9tYXBdIGluIHRoZSBkZWZpbml0aW9uIG9mIFtkZWR1cHNdLiBXZSByZXN0b3JlIHRoZSBvcmRlciBpblxuICAgICAgIHRoZSBmaW5hbCBbZm9sZF0uICopXG4gICAgbGV0IGRlZHVwcyA9IHJldl9tYXAgbGlzdCB+ZjooZnVuIGVsdCAtPiB7IGVsdDsgZHVwID0gdHJ1ZSB9KSBpblxuICAgIGxldCB1bmlxdWUgPSBkZWR1cF9hbmRfc29ydCBkZWR1cHMgfmNvbXBhcmU6KGZ1biB4IHkgLT4gY29tcGFyZSB4LmVsdCB5LmVsdCkgaW5cbiAgICBpdGVyIHVuaXF1ZSB+ZjooZnVuIGRlZHVwIC0+IGRlZHVwLmR1cCA8LSBmYWxzZSk7XG4gICAgZm9sZCBkZWR1cHMgfmluaXQ6W10gfmY6KGZ1biBhY2MgZGVkdXAgLT4gaWYgZGVkdXAuZHVwIHRoZW4gYWNjIGVsc2UgZGVkdXAuZWx0IDo6IGFjYylcbjs7XG5cbmxldCBjb25jYXRfbWFwaSBsIH5mID1cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgb3V0ZXJfbG9vcCBwb3MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IFsgaGQgXSAtPiAoZiBbQHRhaWxjYWxsIGZhbHNlXSkgcG9zIGhkXG4gICAgfCBoZCA6OiAoXyA6OiBfIGFzIHRsKSAtPiBpbm5lcl9sb29wIChwb3MgKyAxKSAoZiBwb3MgaGQpIHRsXG4gIGFuZFtAdGFpbF9tb2RfY29uc10gaW5uZXJfbG9vcCBwb3MgbDEgbDIgPVxuICAgIG1hdGNoIGwxIHdpdGhcbiAgICB8IFtdIC0+IG91dGVyX2xvb3AgcG9zIGwyXG4gICAgfCBbIHgxIF0gLT4geDEgOjogb3V0ZXJfbG9vcCBwb3MgbDJcbiAgICB8IFsgeDE7IHgyIF0gLT4geDEgOjogeDIgOjogb3V0ZXJfbG9vcCBwb3MgbDJcbiAgICB8IFsgeDE7IHgyOyB4MyBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IG91dGVyX2xvb3AgcG9zIGwyXG4gICAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT4geDEgOjogeDIgOjogeDMgOjogeDQgOjogb3V0ZXJfbG9vcCBwb3MgbDJcbiAgICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgICB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiBpbm5lcl9sb29wIHBvcyB0bCBsMlxuICBpblxuICBvdXRlcl9sb29wIDAgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgY29uY2F0X21hcCBsIH5mID0gY29uY2F0X21hcGkgbCB+ZjooZnVuIF8geCAtPiBmIHgpIFtAbm9udGFpbF1cblxubW9kdWxlIENhcnRlc2lhbl9wcm9kdWN0ID0gc3RydWN0XG4gICgqIFdlIGFyZSBleHBsaWNpdCBhYm91dCB3aGF0IHdlIGV4cG9ydCBmcm9tIGZ1bmN0b3JzIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5XG4gICAgIHJlYmluZCBtb3JlIGVmZmljaWVudCBsaXN0LXNwZWNpZmljIGZ1bmN0aW9ucy4gKilcblxuICBsZXQgYmluZCA9IGNvbmNhdF9tYXBcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwMiBhIGIgfmYgPSBjb25jYXRfbWFwIGEgfmY6KGZ1biB4IC0+IG1hcCBiIH5mOihmdW4geSAtPiBmIHggeSkpXG4gIGxldCByZXR1cm4gPSBzaW5nbGV0b25cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuXG4gIG9wZW4gc3RydWN0XG4gICAgbW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICBsZXQgbWFwMiA9IG1hcDJcbiAgICBlbmQpXG5cbiAgICBtb2R1bGUgTW9uYWQgPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBlbmQpXG4gIGVuZFxuXG4gIGxldCBhbGwgPSBNb25hZC5hbGxcbiAgbGV0IGFsbF91bml0ID0gTW9uYWQuYWxsX3VuaXRcbiAgbGV0IGlnbm9yZV9tID0gTW9uYWQuaWdub3JlX21cbiAgbGV0IGpvaW4gPSBNb25hZC5qb2luXG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG4gIGVuZFxuXG4gIGxldCBhcHBseSA9IEFwcGxpY2F0aXZlLmFwcGx5XG4gIGxldCBib3RoID0gQXBwbGljYXRpdmUuYm90aFxuICBsZXQgbWFwMyA9IEFwcGxpY2F0aXZlLm1hcDNcbiAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG4gIGVuZFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSAoQ2FydGVzaWFuX3Byb2R1Y3QgOiBNb25hZC5TX2xvY2FsIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQpXG5cbigqKiByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0X2V4biBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4geFxuICB8IF8gOjogdGwgLT4gbGFzdF9leG4gdGxcbiAgfCBbXSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubGFzdFwiXG47O1xuXG4oKiogb3B0aW9uYWxseSByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0IGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiBTb21lIHhcbiAgfCBfIDo6IHRsIC0+IGxhc3QgdGxcbiAgfCBbXSAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGlzX3ByZWZpeCBsaXN0IH5wcmVmaXggfmVxdWFsID1cbiAgbWF0Y2ggcHJlZml4IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgaGQgOjogdGwgLT5cbiAgICAobWF0Y2ggbGlzdCB3aXRoXG4gICAgIHwgW10gLT4gZmFsc2VcbiAgICAgfCBoZCcgOjogdGwnIC0+IGVxdWFsIGhkIGhkJyAmJiBpc19wcmVmaXggdGwnIH5wcmVmaXg6dGwgfmVxdWFsKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGExIDo6IHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgYTEgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhMiA6OiB0IC0+IGlmIGVxdWFsIGExIGEyIHRoZW4gU29tZSAoYTEsIGEyKSBlbHNlIGxvb3AgYTIgdFxuICAgIGluXG4gICAgbG9vcCBhMSB0IFtAbm9udGFpbF1cbjs7XG5cbigqIHJldHVybnMgbGlzdCB3aXRob3V0IGFkamFjZW50IGR1cGxpY2F0ZXMgKilcbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyA/KHdoaWNoX3RvX2tlZXAgPSBgTGFzdCkgbGlzdCB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgdG9fa2VlcCBhY2N1bSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0b19rZWVwIDo6IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgZXF1YWwgaGQgdG9fa2VlcFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0b19rZWVwID1cbiAgICAgICAgICBtYXRjaCB3aGljaF90b19rZWVwIHdpdGhcbiAgICAgICAgICB8IGBGaXJzdCAtPiB0b19rZWVwXG4gICAgICAgICAgfCBgTGFzdCAtPiBoZFxuICAgICAgICBpblxuICAgICAgICBsb29wIHRvX2tlZXAgYWNjdW0gdGwpXG4gICAgICBlbHNlIGxvb3AgaGQgKHRvX2tlZXAgOjogYWNjdW0pIHRsXG4gIGluXG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gcmV2IChsb29wIGhkIFtdIHRsKVxuOztcblxubGV0IGZpbmRfYV9kdXAgbCB+Y29tcGFyZSA9XG4gIGxldCBzb3J0ZWQgPSBzb3J0IGwgfmNvbXBhcmUgaW5cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiBOb25lXG4gICAgfCBoZDEgOjogKGhkMiA6OiBfIGFzIHRsKSAtPiBpZiBjb21wYXJlIGhkMSBoZDIgPSAwIHRoZW4gU29tZSBoZDEgZWxzZSBsb29wIHRsXG4gIGluXG4gIGxvb3Agc29ydGVkIFtAbm9udGFpbF1cbjs7XG5cbmxldCBjb250YWluc19kdXAgbHN0IH5jb21wYXJlID1cbiAgbWF0Y2ggZmluZF9hX2R1cCBsc3QgfmNvbXBhcmUgd2l0aFxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZpbmRfYWxsX2R1cHMgbCB+Y29tcGFyZSA9XG4gIGxldCBzb3J0ZWQgPSBzb3J0IH5jb21wYXJlIGwgaW5cbiAgKCogV2FsayB0aGUgbGlzdCBhbmQgcmVjb3JkIHRoZSBmaXJzdCBvZiBlYWNoIGNvbnNlY3V0aXZlIHJ1biBvZiBpZGVudGljYWwgZWxlbWVudHMgKilcbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBzb3J0ZWQgcHJldiB+YWxyZWFkeV9yZWNvcmRlZCA9XG4gICAgbWF0Y2ggc29ydGVkIHdpdGhcbiAgICB8IFtdIC0+IFtdXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgY29tcGFyZSBwcmV2IGhkIDw+IDBcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZVxuICAgICAgZWxzZSBpZiBhbHJlYWR5X3JlY29yZGVkXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZVxuICAgICAgZWxzZSBoZCA6OiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWVcbiAgaW5cbiAgbWF0Y2ggc29ydGVkIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+IGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6ZmFsc2UgW0Bub250YWlsXVxuOztcblxubGV0IHJlYyBhbGxfZXF1YWxfdG8gdCB2IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCB4IDo6IHhzIC0+IGVxdWFsIHggdiAmJiBhbGxfZXF1YWxfdG8geHMgdiB+ZXF1YWxcbjs7XG5cbmxldCBhbGxfZXF1YWwgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBpZiBhbGxfZXF1YWxfdG8geHMgeCB+ZXF1YWwgdGhlbiBTb21lIHggZWxzZSBOb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJMaXN0LmluaXQgJWRcIiBuICgpO1xuICBsZXQgcmVjIGxvb3AgaSBhY2N1bSA9XG4gICAgYXNzZXJ0IChpID49IDApO1xuICAgIGlmIGkgPSAwIHRoZW4gYWNjdW0gZWxzZSBsb29wIChpIC0gMSkgKGYgKGkgLSAxKSA6OiBhY2N1bSlcbiAgaW5cbiAgbG9vcCBuIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZXZfZmlsdGVyX21hcCBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBoZCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gbG9vcCB0bCAoeCA6OiBhY2N1bSlcbiAgICAgICB8IE5vbmUgLT4gbG9vcCB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCBsIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbHRlcl9tYXAgbCB+ZiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT5cbiAgICAobWF0Y2ggZiBoZCB3aXRoXG4gICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIHRsIH5mXG4gICAgIHwgU29tZSB4IC0+IHggOjogZmlsdGVyX21hcCB0bCB+Zilcbjs7XG5cbmxldCByZXZfZmlsdGVyX21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBpIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIChpICsgMSkgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCAwIGwgW10gW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlcl9tYXBpIGwgfmYgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIHBvcyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFtdXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgcG9zIGhkIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAocG9zICsgMSkgdGxcbiAgICAgICB8IFNvbWUgeCAtPiB4IDo6IGxvb3AgKHBvcyArIDEpIHRsKVxuICBpblxuICBsb29wIDAgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmlsdGVyX29wdCBsID0gZmlsdGVyX21hcCBsIH5mOkZuLmlkXG5cbmxldCBwYXJ0aXRpb24zX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCB0cmQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV2IGZzdCwgcmV2IHNuZCwgcmV2IHRyZFxuICAgIHwgeCA6OiB0IC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IGBGc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmQgdHJkXG4gICAgICAgfCBgU25kIHkgLT4gbG9vcCB0IGZzdCAoeSA6OiBzbmQpIHRyZFxuICAgICAgIHwgYFRyZCB5IC0+IGxvb3AgdCBmc3Qgc25kICh5IDo6IHRyZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXSBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICBsZXQgZiB4IDogXyBFaXRoZXIudCA9IGlmIGYgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCBpblxuICBwYXJ0aXRpb25fbWFwIHQgfmYgW0Bub250YWlsXVxuOztcblxubGV0IHBhcnRpdGlvbl9yZXN1bHQgdCA9IHBhcnRpdGlvbl9tYXAgdCB+ZjpSZXN1bHQudG9fZWl0aGVyXG5cbm1vZHVsZSBBc3NvYyA9IHN0cnVjdFxuICB0eXBlICdhIGtleSA9ICgnYVtAdGFnIFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY19rZXlfdGFnID0gTGlzdCBbXV0pXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGtleV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBrZXkgPVxuICAgIGZ1biBfb2ZfYV9fMDIyXyAtPiBfb2ZfYV9fMDIyX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX2tleSA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBrZXkgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gX29mX2FfXzAyNF8gLT4gX29mX2FfXzAyNF9cbiAgOztcblxuICBsZXQga2V5X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBrZXkgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVGFnZ2VkXG4gICAgICAgICAgeyBrZXkgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2Nfa2V5X3RhZ1xuICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgOyBncmFtbWFyID0gXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgdmFsdWUgPSAoJ2FbQHRhZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdmFsdWVfdGFnID0gTGlzdCBbXV0pXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHZhbHVlX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHZhbHVlID1cbiAgICBmdW4gX29mX2FfXzAyNV8gLT4gX29mX2FfXzAyNV9cbiAgOztcblxuICBsZXQgc2V4cF9vZl92YWx1ZSA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB2YWx1ZSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDI3XyAtPiBfb2ZfYV9fMDI3X1xuICA7O1xuXG4gIGxldCB2YWx1ZV9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdmFsdWUgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBUYWdnZWRcbiAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY192YWx1ZV90YWdcbiAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgIDsgZ3JhbW1hciA9IF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgICgoJ2Ega2V5ICogJ2IgdmFsdWUpIGxpc3RbQHRhZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdGFnID0gTGlzdCBbXV0pXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgICAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdiKVxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMzZfID0gXCJsaXN0Lm1sLkFzc29jLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDI4XyBfb2ZfYl9fMDI5XyB4X18wMzdfIC0+XG4gICAgICBsaXN0X29mX3NleHBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzAzMV87IGFyZzFfXzAzMl8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDMzXyA9IGtleV9vZl9zZXhwIF9vZl9hX18wMjhfIGFyZzBfXzAzMV9cbiAgICAgICAgICAgYW5kIHJlczFfXzAzNF8gPSB2YWx1ZV9vZl9zZXhwIF9vZl9iX18wMjlfIGFyZzFfXzAzMl8gaW5cbiAgICAgICAgICAgcmVzMF9fMDMzXywgcmVzMV9fMDM0X1xuICAgICAgICAgfCBzZXhwX18wMzVfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAzNl9cbiAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgc2V4cF9fMDM1XylcbiAgICAgICAgeF9fMDM3X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9hX18wMzhfIF9vZl9iX18wMzlfIHhfXzA0NF8gLT5cbiAgICBzZXhwX29mX2xpc3RcbiAgICAgIChmdW4gKGFyZzBfXzA0MF8sIGFyZzFfXzA0MV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wNDJfID0gc2V4cF9vZl9rZXkgX29mX2FfXzAzOF8gYXJnMF9fMDQwX1xuICAgICAgICBhbmQgcmVzMV9fMDQzXyA9IHNleHBfb2ZfdmFsdWUgX29mX2JfXzAzOV8gYXJnMV9fMDQxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wNDJfOyByZXMxX18wNDNfIF0pXG4gICAgICB4X18wNDRfXG4gIDs7XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFRhZ2dlZFxuICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3RhZ1xuICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgKGxpc3Rfc2V4cF9ncmFtbWFyXG4gICAgICAgICAgICAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgICAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggKGtleV9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hcikudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKCh2YWx1ZV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hcikudW50eXBlZCwgRW1wdHkpICkpXG4gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnVudHlwZWRcbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHBhaXJfb2ZfZ3JvdXAgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCAoaywgXykgOjogXyBhcyBsaXN0IC0+IGssIG1hcCBsaXN0IH5mOnNuZFxuICA7O1xuXG4gIGxldCBncm91cCBhbGlzdCB+ZXF1YWwgPVxuICAgIGdyb3VwIGFsaXN0IH5icmVhazooZnVuICh4LCBfKSAoeSwgXykgLT4gbm90IChlcXVhbCB4IHkpKSB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZSA9XG4gICAgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmU6KGZ1biAoeCwgXykgKHksIF8pIC0+IGNvbXBhcmUgeCB5KVxuICAgIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZXF1YWwga2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgfmY6KGZ1biAoa2V5JywgXykgLT4gZXF1YWwga2V5IGtleScpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgKHNuZCB4KVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5Bc3NvYy5maW5kX2V4bjogbm90IGZvdW5kXCIpIGluXG4gICAgbGV0IHJlYyBmaW5kX2V4biB0IH5lcXVhbCBrZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCAoa2V5JywgdmFsdWUpIDo6IHQgLT4gaWYgZXF1YWwga2V5IGtleScgdGhlbiB2YWx1ZSBlbHNlIGZpbmRfZXhuIHQgfmVxdWFsIGtleVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZXF1YWwga2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgXyAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IH5lcXVhbCBrZXkgPSBmaWx0ZXIgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBub3QgKGVxdWFsIGtleSBrZXknKSkgW0Bub250YWlsXVxuXG4gIGxldCBhZGQgdCB+ZXF1YWwga2V5IHZhbHVlID1cbiAgICAoKiB0aGUgcmVtb3ZlIGRvZXNuJ3QgY2hhbmdlIHRoZSBtYXAgc2VtYW50aWNzLCBidXQga2VlcHMgdGhlIGxpc3Qgc21hbGwgKilcbiAgICAoa2V5LCB2YWx1ZSkgOjogcmVtb3ZlIHQgfmVxdWFsIGtleVxuICA7O1xuXG4gIGxldCBpbnZlcnNlIHQgPSBtYXAgdCB+ZjooZnVuICh4LCB5KSAtPiB5LCB4KVxuICBsZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZjooZnVuIChrZXksIHZhbHVlKSAtPiBrZXksIGYgdmFsdWUpIFtAbm9udGFpbF1cbmVuZFxuXG5sZXQgc3ViIGwgfnBvcyB+bGVuID1cbiAgKCogV2UgdXNlIFtwb3MgPiBsZW5ndGggbCAtIGxlbl0gcmF0aGVyIHRoYW4gW3BvcyArIGxlbiA+IGxlbmd0aCBsXSB0byBhdm9pZCB0aGVcbiAgICAgcG9zc2liaWxpdHkgb2Ygb3ZlcmZsb3cuICopXG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBsZW5ndGggbCAtIGxlbiB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5zdWJcIjtcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBpIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gW11cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICBpZiBpIDwgcG9zIHRoZW4gbG9vcCAoaSArIDEpIHRsIGVsc2UgaWYgaSA8IHN0b3AgdGhlbiBoZCA6OiBsb29wIChpICsgMSkgdGwgZWxzZSBbXVxuICBpblxuICBsb29wIDAgbCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgc3BsaXRfbiB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdLCB0X29yaWdcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gdF9vcmlnLCBbXSAoKiBpbiB0aGlzIGNhc2UsIHRfb3JpZyA9IHJldiBhY2N1bSAqKVxuICAgICAgfCBoZCA6OiB0bCAtPiBpZiBuID0gMCB0aGVuIHJldiBhY2N1bSwgdCBlbHNlIGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X25dIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2UgdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiB0X29yaWdcbiAgICAgIHwgaGQgOjogdGwgLT4gaWYgbiA9IDAgdGhlbiByZXYgYWNjdW0gZWxzZSBsb29wIChuIC0gMSkgdGwgKGhkIDo6IGFjY3VtKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbmxldCByZWMgZHJvcCB0IG4gPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBfIDo6IHRsIHdoZW4gbiA+IDAgLT4gZHJvcCB0bCAobiAtIDEpXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgY2h1bmtzX29mIGwgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8PSAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5jaHVua3Nfb2Y6IEV4cGVjdGVkIGxlbmd0aCA+IDAsIGdvdCAlZFwiIGxlbmd0aCAoKTtcbiAgbGV0IHJlYyBhdXggbGVuZ3RoIGFjYyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IHN1Ymxpc3QsIGwgPSBzcGxpdF9uIGwgbGVuZ3RoIGluXG4gICAgICBhdXggbGVuZ3RoIChzdWJsaXN0IDo6IGFjYykgbFxuICBpblxuICBhdXggbGVuZ3RoIFtdIGxcbjs7XG5cbmxldCBzcGxpdF93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IHQgLT4gcmV2IGFjYywgdFxuICBpblxuICBsb29wIFtdIHhzIFtAbm9udGFpbF1cbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF93aGlsZV0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlICopXG5sZXQgdGFrZV93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IF8gLT4gcmV2IGFjY1xuICBpblxuICBsb29wIFtdIHhzIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWMgZHJvcF93aGlsZSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGRyb3Bfd2hpbGUgdGwgfmZcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBkcm9wX2xhc3QgdCA9XG4gIG1hdGNoIHJldiB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiBsc3QgLT4gU29tZSAocmV2IGxzdClcbjs7XG5cbmxldCBkcm9wX2xhc3RfZXhuIHQgPVxuICBtYXRjaCBkcm9wX2xhc3QgdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIkxpc3QuZHJvcF9sYXN0X2V4bjogZW1wdHkgbGlzdFwiXG4gIHwgU29tZSBsc3QgLT4gbHN0XG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgbGlzdDEgbGlzdDIgPVxuICBpZiBpc19lbXB0eSBsaXN0MlxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIG91dGVyX2xvb3AgbDEgPVxuICAgICAgbWF0Y2ggbDEgd2l0aFxuICAgICAgfCBbXSAtPiBbXVxuICAgICAgfCB4MSA6OiBsMSAtPiBpbm5lcl9sb29wIHgxIGwxIGxpc3QyXG4gICAgYW5kW0B0YWlsX21vZF9jb25zXSBpbm5lcl9sb29wIHgxIGwxIGwyID1cbiAgICAgIG1hdGNoIGwyIHdpdGhcbiAgICAgIHwgW10gLT4gb3V0ZXJfbG9vcCBsMVxuICAgICAgfCB4MiA6OiBsMiAtPiAoeDEsIHgyKSA6OiBpbm5lcl9sb29wIHgxIGwxIGwyXG4gICAgaW5cbiAgICBvdXRlcl9sb29wIGxpc3QxIFtAbm9udGFpbF0pXG47O1xuXG5sZXQgY29uY2F0IGwgPSBmb2xkX3JpZ2h0IGwgfmluaXQ6W10gfmY6YXBwZW5kXG5sZXQgY29uY2F0X25vX29yZGVyIGwgPSBmb2xkIGwgfmluaXQ6W10gfmY6KGZ1biBhY2MgbCAtPiByZXZfYXBwZW5kIGwgYWNjKVxubGV0IGNvbnMgeCBsID0geCA6OiBsXG5cbmxldCBpc19zb3J0ZWQgbCB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gdHJ1ZVxuICAgIHwgeDEgOjogKHgyIDo6IF8gYXMgcmVzdCkgLT4gY29tcGFyZSB4MSB4MiA8PSAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGwgW0Bub250YWlsXVxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDwgMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsIFtAbm9udGFpbF1cbjs7XG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gICgqIHNwZWNpYWwgY2FzZXMgdG8gc3BlZWQgdGhpbmdzIHVwIGluIHRyaXZpYWwgY2FzZXMgKilcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3RcbiAgfCBbIHg7IHkgXSAtPiBpZiBSYW5kb20uU3RhdGUuYm9vbCByYW5kb21fc3RhdGUgdGhlbiBbIHk7IHggXSBlbHNlIGxpc3RcbiAgfCBfIC0+XG4gICAgbGV0IGFyciA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIEFycmF5X3Blcm11dGUucGVybXV0ZSBhcnIgfnJhbmRvbV9zdGF0ZTtcbiAgICBBcnJheS50b19saXN0IGFyclxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgaWYgaXNfZW1wdHkgbGlzdFxuICB0aGVuIGZhaWx3aXRoIFwiTGlzdC5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGxpc3RcIlxuICBlbHNlIG50aF9leG4gbGlzdCAoUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCBsaXN0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsaXN0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIGxpc3QpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgY29tcGFyZSBjbXAgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgaWYgbiA9IDAgdGhlbiBjb21wYXJlIGNtcCB4cyB5cyBlbHNlIG5cbjs7XG5cbmxldCByZWMgY29tcGFyZV9fbG9jYWwgY21wIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCBuID0gY21wIHggeSBpblxuICAgIGlmIG4gPSAwIHRoZW4gY29tcGFyZV9fbG9jYWwgY21wIHhzIHlzIGVsc2UgblxuOztcblxubGV0IGhhc2hfZm9sZF90ID0gaGFzaF9mb2xkX2xpc3RcblxubGV0IGVxdWFsX3dpdGhfbG9jYWxfY2xvc3VyZSAoZXF1YWwgOiBfIC0+IF8gLT4gXykgdDEgdDIgPVxuICBsZXQgcmVjIGxvb3AgfmVxdWFsIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IHgxIDo6IHQxLCB4MiA6OiB0MiAtPiBlcXVhbCB4MSB4MiAmJiBsb29wIH5lcXVhbCB0MSB0MlxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIH5lcXVhbCB0MSB0MlxuOztcblxubGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gIGZ1biBmIHggeSAtPiBlcXVhbF93aXRoX2xvY2FsX2Nsb3N1cmUgZiB4IHlcbjs7XG5cbmxldCBlcXVhbF9fbG9jYWwgZXF1YWxfYV9fbG9jYWwgdDEgdDIgPVxuICBsZXQgcmVjIGxvb3AgfmVxdWFsX2FfX2xvY2FsIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IHgxIDo6IHQxLCB4MiA6OiB0MiAtPiBlcXVhbF9hX19sb2NhbCB4MSB4MiAmJiBsb29wIH5lcXVhbF9hX19sb2NhbCB0MSB0MlxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIH5lcXVhbF9hX19sb2NhbCB0MSB0MiBbQG5vbnRhaWxdXG47O1xuXG5sZXQgdHJhbnNwb3NlID1cbiAgbGV0IHJlYyBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHQgY29sdW1uX2FjYyB0cmltbWVkIGZvdW5kX2VtcHR5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGNvbHVtbl9hY2MsIHRyaW1tZWQsIGZvdW5kX2VtcHR5XG4gICAgfCBbXSA6OiB0bCAtPiBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsIGNvbHVtbl9hY2MgdHJpbW1lZCB0cnVlXG4gICAgfCAoeCA6OiB4cykgOjogdGwgLT5cbiAgICAgIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgKHggOjogY29sdW1uX2FjYykgKHhzIDo6IHRyaW1tZWQpIGZvdW5kX2VtcHR5XG4gIGluXG4gIGxldCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgPSBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3MgW10gW10gZmFsc2UgaW5cbiAgbGV0IHJlYyBsb29wIHJvd3MgY29sdW1ucyBkb19yZXYgPVxuICAgIG1hdGNoIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyB3aXRoXG4gICAgfCBbXSwgW10sIF8gLT4gU29tZSAocmV2IGNvbHVtbnMpXG4gICAgfCBjb2x1bW4sIHRyaW1tZWRfcm93cywgZm91bmRfZW1wdHkgLT5cbiAgICAgIGlmIGZvdW5kX2VtcHR5XG4gICAgICB0aGVuIE5vbmVcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgY29sdW1uID0gaWYgZG9fcmV2IHRoZW4gcmV2IGNvbHVtbiBlbHNlIGNvbHVtbiBpblxuICAgICAgICBsb29wIHRyaW1tZWRfcm93cyAoY29sdW1uIDo6IGNvbHVtbnMpIChub3QgZG9fcmV2KSlcbiAgaW5cbiAgZnVuIHQgLT4gbG9vcCB0IFtdIHRydWVcbjs7XG5cbmV4Y2VwdGlvbiBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzIG9mIGludCBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXVxuICAgIChmdW5jdGlvblxuICAgIHwgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBhcmcwX18wNDVfIC0+XG4gICAgICBsZXQgcmVzMF9fMDQ2XyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2ludCBhcmcwX18wNDVfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsaXN0Lm1sLlRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNcIlxuICAgICAgICA7IHJlczBfXzA0Nl9cbiAgICAgICAgXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdHJhbnNwb3NlX2V4biBsID1cbiAgbWF0Y2ggdHJhbnNwb3NlIGwgd2l0aFxuICB8IFNvbWUgbCAtPiBsXG4gIHwgTm9uZSAtPiByYWlzZSAoVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyAobWFwIGwgfmY6KGxlbmd0aCA6PiBfIC0+IF8pKSlcbjs7XG5cbmxldCBpbnRlcnNwZXJzZSB0IH5zZXAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT4geCA6OiBmb2xkX3JpZ2h0IHhzIH5pbml0OltdIH5mOihmdW4geSBhY2MgLT4gc2VwIDo6IHkgOjogYWNjKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdCB+ZmluaXNoXG5cbmxldCBpc19zdWZmaXggbGlzdCB+c3VmZml4IH5lcXVhbDooZXF1YWxfZWx0IDogXyAtPiBfIC0+IF8pID1cbiAgbGV0IGxpc3RfbGVuID0gbGVuZ3RoIGxpc3QgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIGxpc3RfbGVuID49IHN1ZmZpeF9sZW5cbiAgJiYgZXF1YWxfd2l0aF9sb2NhbF9jbG9zdXJlIGVxdWFsX2VsdCAoZHJvcCBsaXN0IChsaXN0X2xlbiAtIHN1ZmZpeF9sZW4pKSBzdWZmaXhcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9MaXN0X21hcDIiLCJjc3RfTGlzdF9tYXAzIiwiY3N0X0xpc3RfcmFuZ2Vfc3RyaWRlX2Z1bmN0aW9uIiwiY3N0X2xlbmd0aF9taXNtYXRjaF9pbiIsImNzdF9zcmNfbGlzdF9tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNiIsImE0IiwiYTUiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiZXJyb3Jfc291cmNlXzAzNiIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Db250YWluZXIiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfUmFuZG9tIiwiQmFzZV9BcnJheTAiLCJCYXNlX0FycmF5X3Blcm11dGUiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX1Jlc3VsdCIsIkJhc2VfT3JkZXJpbmciLCJCYXNlX0xpc3QxIiwiQmFzZV9QcmludGYiLCJCYXNlX0FwcGxpY2F0aXZlIiwiQmFzZV9Nb25hZCIsIlNleHBsaWIwX1NleHBfY29udiIsImhkX2V4biIsInJldl9hcHBlbmQiLCJ0bF9leG4iLCJsZW5ndGgiLCJleGlzdHMiLCJleGlzdHMyX29rIiwiZm9sZCIsImZvbGQyX29rIiwiZm9yX2FsbCIsImZvcl9hbGwyX29rIiwiaXRlciIsIml0ZXIyX29rIiwicmV2X21hcCIsInJldl9tYXAyX29rIiwicmV2IiwiZm9sZF9yaWdodCIsImZvbGRfcmlnaHQyX29rIiwiaXNfZW1wdHkiLCJwYXJ0aXRpb25fbWFwIiwiaW52YWxpZF9hcmdmIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiY3N0X0xpc3RfcmFuZ2Vfc3RyaWRlX211c3RfYmVfIiwiY3N0X2l0ZXIyX2V4biIsImNzdF9yZXZfbWFwMl9leG4iLCJjc3RfZm9sZDJfZXhuIiwiY3N0X2ZvbGRfcmlnaHQyX2V4biIsImNzdF9mb3JfYWxsMl9leG4iLCJjc3RfZXhpc3RzMl9leG4iLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9sb2NhbCIsImNtcF9hIiwiYV8wMTQiLCJiXzAxNSIsImFfMDE2IiwiYl8wMTciLCJjb21wYXJlIiwiYV8wMTAiLCJiXzAxMSIsImFfMDEyIiwiYl8wMTMiLCJvZl9hXzAxOCIsInBhcmFtIiwiYXJnMF8wMTkiLCJyZXMwXzAyMCIsImludmFyaWFudCIsInQiLCJvZl9saXN0Iiwic2luZ2xldG9uIiwieCIsInJhbmdlIiwic3RyaWRlIiwib3B0Iiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0Iiwic3RvcCIsIm5leHRfaSIsIm9yZGVyIiwieSIsInJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbSIsImluaXRpYWxfc3RyaWRlX29yZGVyIiwiaV90b19zdG9wX29yZGVyIiwiYmxvY2siLCJkc3QiLCJvZmZzZXQiLCJpIiwiaGQiLCJ0bCIsIm50aCIsIm4iLCJhIiwibnRoX2V4biIsIm1hdGNoIiwidW5vcmRlcmVkX2FwcGVuZCIsImwxIiwibDIiLCJsIiwib2ZfbGlzdHMiLCJiIiwic2hhcmVkX2xlbmd0aCIsImNoZWNrX2xlbmd0aDJfZXhuIiwibmFtZSIsInRhaWxfb2ZfYiIsInRhaWxfb2ZfYSIsImNoZWNrX2xlbmd0aDIiLCJsMyIsImMiLCJjaGVja19sZW5ndGgzX2V4biIsInRhaWxfb2ZfYyIsIm4xIiwibjIiLCJuMyIsImNoZWNrX2xlbmd0aDMiLCJpdGVyMiIsIml0ZXIyX2V4biIsInJldl9tYXAyIiwicmV2X21hcDJfZXhuIiwiZm9sZDIiLCJpbml0IiwiZm9sZDJfZXhuIiwiZm9sZF9yaWdodDIiLCJmb2xkX3JpZ2h0Ml9leG4iLCJmb3JfYWxsMiIsImZvcl9hbGwyX2V4biIsImV4aXN0czIiLCJleGlzdHMyX2V4biIsIm1lbSIsImVxdWFsIiwiYnMiLCJyZXZfZmlsdGVyIiwiYWNjdSIsImZpbHRlciIsImZpbmRfbWFwIiwiciIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsImZpbmQiLCJmaW5kX2V4biIsImZpbmRpIiwiZmluZGlfZXhuIiwiZmluZF9tYXBpIiwicmVzdWx0IiwiZmluZF9tYXBpX2V4biIsImZvcl9hbGxpIiwiZXhpc3RzaSIsIm9mX2FycmF5IiwidG9fYXJyYXkiLCJjc3RfbWFwMl9leG4iLCJjc3RfcmV2X21hcDNfZXhuIiwiY3N0X21hcDNfZXhuIiwiY3N0X0xpc3RfcmVkdWNlX2V4biIsImNzdF9MaXN0X3JlZHVjZV9iYWxhbmNlZF9leG4iLCJ0b19saXN0IiwiYXBwZW5kIiwieDEiLCJ4MiIsIngzIiwieDQiLCJ4NSIsIm1hcCIsImZvbGRpbmdfbWFwIiwiYWNjIiwibmV3X2FjYyIsImZvbGRfbWFwIiwic3ltYm9sX21hcCIsIm1hcDJfb2siLCJtYXAyIiwibWFwMl9leG4iLCJyZXZfbWFwM19vayIsImFjIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwMyIsIm1hcDNfZXhuIiwicmV2X21hcF9hcHBlbmQiLCJoIiwidW56aXAiLCJsaXN0IiwidW56aXAzIiwieiIsInppcF9leG4iLCJleG4iLCJ6aXAiLCJyZXZfbWFwaSIsIm1hcGkiLCJibG9jazBfYXJnMCIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsIml0ZXJpIiwiZm9sZGkiLCJ2IiwiZmlsdGVyaSIsInBvcyIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZWR1Y2VfYmFsYW5jZWQiLCJzdGVwX2FjY3VtIiwibnVtIiwieHMiLCJyZWR1Y2VfYmFsYW5jZWRfZXhuIiwiZ3JvdXBpIiwiYnJlYWskIiwidGFrZV9ncm91cCIsImdyb3VwIiwibWVyZ2UiLCJ0MiIsImgyIiwidDEiLCJoMSIsIm1lcmdlX2RwcyIsInN0YWJsZV9zb3J0IiwiY21wIiwic29ydCIsInMiLCJzMSIsInMyIiwicmV2X3NvcnQiLCJsZW4iLCJzb3J0X2FuZF9ncm91cCIsImRlZHVwX2FuZF9zb3J0Iiwic3RhYmxlX2RlZHVwIiwiZGVkdXBzIiwiZWx0IiwidW5pcXVlIiwiZGVkdXAiLCJjb25jYXRfbWFwaSIsIm91dGVyX2xvb3BfZHBzIiwiY291bnRlciIsImlubmVyX2xvb3BfZHBzIiwiY29uY2F0X21hcCIsInN5bWJvbF9iaW5kIiwiQXBwbGljYXRpdmUiLCJNb25hZCIsImFsbCIsImFsbF91bml0IiwiaWdub3JlX20iLCJqb2luIiwiYXBwbHkiLCJib3RoIiwic3ltYm9sIiwiT3Blbl9vbl9yaHMiLCJMZXRfc3ludGF4IiwiTW9uYWRfaW5maXgiLCJjc3RfTGlzdF9sYXN0IiwibGFzdF9leG4iLCJsYXN0IiwiaXNfcHJlZml4IiwicHJlZml4IiwiZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUiLCJyZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyIsIndoaWNoX3RvX2tlZXAiLCJ0b19rZWVwIiwiYWNjdW0iLCJmaW5kX2FfZHVwIiwic29ydGVkIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInByZXYiLCJhbHJlYWR5X3JlY29yZGVkIiwiYWxsX2VxdWFsIiwiY291bnQiLCJzdW0iLCJtIiwibWluX2VsdCIsIm1heF9lbHQiLCJjb3VudGkiLCJpZHgiLCJyZXZfZmlsdGVyX21hcCIsImZpbHRlcl9tYXAiLCJyZXZfZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsImZzdCIsInNuZCIsInRyZCIsInZhcmlhbnQiLCJwYXJ0aXRpb25fdGYiLCJwYXJ0aXRpb25fcmVzdWx0Iiwib2ZfYV8wMjgiLCJvZl9iXzAyOSIsInhfMDM3Iiwic2V4cF8wMzUiLCJhcmcxXzAzMiIsImFyZzBfMDMxIiwicmVzMF8wMzMiLCJyZXMxXzAzNCIsIm9mX2FfMDM4Iiwib2ZfYl8wMzkiLCJ4XzA0NCIsImFyZzFfMDQxIiwiYXJnMF8wNDAiLCJyZXMwXzA0MiIsInJlczFfMDQzIiwiYl9zZXhwX2dyYW1tYXIiLCJwYWlyX29mX2dyb3VwIiwiayIsImFsaXN0Iiwia2V5IiwiY3N0X0xpc3Rfc3ViIiwiY3N0X0xpc3RfZHJvcF9sYXN0X2V4bl9lbXB0eV9sIiwidmFsdWUiLCJyZW1vdmUiLCJhZGQiLCJpbnZlcnNlIiwic3ViIiwic3BsaXRfbiIsInRfb3JpZyIsInRha2UiLCJkcm9wIiwiY2h1bmtzX29mIiwic3VibGlzdCIsInNwbGl0X3doaWxlIiwidGFrZV93aGlsZSIsImRyb3Bfd2hpbGUiLCJkcm9wX2xhc3QiLCJkcm9wX2xhc3RfZXhuIiwiY2FydGVzaWFuX3Byb2R1Y3QiLCJsaXN0MSIsImxpc3QyIiwiY29uY2F0IiwiY29uY2F0X25vX29yZGVyIiwiY29ucyIsImlzX3NvcnRlZCIsInJlc3QiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJJbmZpeCIsImNzdF9MaXN0X3JhbmRvbV9lbGVtZW50X2V4bl9lbSIsInBlcm11dGUiLCJyYW5kb21fc3RhdGUiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsInlzIiwiaGFzaF9mb2xkX3QiLCJlcXVhbF93aXRoX2xvY2FsX2Nsb3N1cmUiLCJlcXVhbF9sb2NhbCIsImVxdWFsX2FfbG9jYWwiLCJ0cmFuc3Bvc2UiLCJyb3dzIiwiY29sdW1ucyIsImRvX3JldiIsImNvbHVtbl9hY2MiLCJ0cmltbWVkX3Jvd3MiLCJmb3VuZF9lbXB0eSIsImNvbHVtbiIsInRyaW1tZWQiLCJUcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmUiLCJ0YWciLCJhcmcwXzA0NSIsInJlczBfMDQ2IiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwic2VwIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZmluaXNoIiwiaXNfc3VmZml4Iiwic3VmZml4IiwiZXF1YWxfZWx0IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwiQmFzZV9MaXN0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxr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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRG5qRHhCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTExMDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaW5mby5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0luZm9dLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIGFzIG1hbnkgcGxhY2VzIGFzIHBvc3NpYmxlLiBQbGVhc2UgYXZvaWRcbiAgIGFkZGluZyBuZXcgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb19pbnRmXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG5tb2R1bGUgTWVzc2FnZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBvZiBTZXhwLnRcbiAgICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgICB8IEV4biBvZiBleG5cbiAgICB8IFNleHAgb2YgU2V4cC50XG4gICAgfCBUYWdfc2V4cCBvZiBzdHJpbmcgKiBTZXhwLnQgKiBTb3VyY2VfY29kZV9wb3NpdGlvbjAudCBvcHRpb25cbiAgICB8IFRhZ190IG9mIHN0cmluZyAqIHRcbiAgICB8IFRhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50ICogdFxuICAgIHwgT2ZfbGlzdCBvZiBpbnQgb3B0aW9uICogdCBsaXN0XG4gICAgfCBXaXRoX2JhY2t0cmFjZSBvZiB0ICogc3RyaW5nICgqIGJhY2t0cmFjZSAqKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBhcmcwX18wMDFfIC0+XG4gICAgICAgbGV0IHJlczBfXzAwMl8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDFfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ291bGRfbm90X2NvbnN0cnVjdFwiOyByZXMwX18wMDJfIF1cbiAgICAgfCBTdHJpbmcgYXJnMF9fMDAzXyAtPlxuICAgICAgIGxldCByZXMwX18wMDRfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDAzXyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlN0cmluZ1wiOyByZXMwX18wMDRfIF1cbiAgICAgfCBFeG4gYXJnMF9fMDA1XyAtPlxuICAgICAgIGxldCByZXMwX18wMDZfID0gc2V4cF9vZl9leG4gYXJnMF9fMDA1XyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4blwiOyByZXMwX18wMDZfIF1cbiAgICAgfCBTZXhwIGFyZzBfXzAwN18gLT5cbiAgICAgICBsZXQgcmVzMF9fMDA4XyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwN18gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZXhwXCI7IHJlczBfXzAwOF8gXVxuICAgICB8IFRhZ19zZXhwIChhcmcwX18wMDlfLCBhcmcxX18wMTBfLCBhcmcyX18wMTFfKSAtPlxuICAgICAgIGxldCByZXMwX18wMTJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA5X1xuICAgICAgIGFuZCByZXMxX18wMTNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDEwX1xuICAgICAgIGFuZCByZXMyX18wMTRfID0gc2V4cF9vZl9vcHRpb24gU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBhcmcyX18wMTFfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ19zZXhwXCI7IHJlczBfXzAxMl87IHJlczFfXzAxM187IHJlczJfXzAxNF8gXVxuICAgICB8IFRhZ190IChhcmcwX18wMTVfLCBhcmcxX18wMTZfKSAtPlxuICAgICAgIGxldCByZXMwX18wMTdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE1X1xuICAgICAgIGFuZCByZXMxX18wMThfID0gc2V4cF9vZl90IGFyZzFfXzAxNl8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfdFwiOyByZXMwX18wMTdfOyByZXMxX18wMThfIF1cbiAgICAgfCBUYWdfYXJnIChhcmcwX18wMTlfLCBhcmcxX18wMjBfLCBhcmcyX18wMjFfKSAtPlxuICAgICAgIGxldCByZXMwX18wMjJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE5X1xuICAgICAgIGFuZCByZXMxX18wMjNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDIwX1xuICAgICAgIGFuZCByZXMyX18wMjRfID0gc2V4cF9vZl90IGFyZzJfXzAyMV8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX2FyZ1wiOyByZXMwX18wMjJfOyByZXMxX18wMjNfOyByZXMyX18wMjRfIF1cbiAgICAgfCBPZl9saXN0IChhcmcwX18wMjVfLCBhcmcxX18wMjZfKSAtPlxuICAgICAgIGxldCByZXMwX18wMjdfID0gc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9pbnQgYXJnMF9fMDI1X1xuICAgICAgIGFuZCByZXMxX18wMjhfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfdCBhcmcxX18wMjZfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2ZfbGlzdFwiOyByZXMwX18wMjdfOyByZXMxX18wMjhfIF1cbiAgICAgfCBXaXRoX2JhY2t0cmFjZSAoYXJnMF9fMDI5XywgYXJnMV9fMDMwXykgLT5cbiAgICAgICBsZXQgcmVzMF9fMDMxXyA9IHNleHBfb2ZfdCBhcmcwX18wMjlfXG4gICAgICAgYW5kIHJlczFfXzAzMl8gPSBzZXhwX29mX3N0cmluZyBhcmcxX18wMzBfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiV2l0aF9iYWNrdHJhY2VcIjsgcmVzMF9fMDMxXzsgcmVzMV9fMDMyXyBdXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHJlYyB0b19zZXhwc19odW0gdCBhYyA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IF8gYXMgdCAtPiBzZXhwX29mX3QgdCA6OiBhY1xuICAgIHwgU3RyaW5nIHN0cmluZyAtPiBBdG9tIHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBFeG4uc2V4cF9vZl90IGV4biA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIGhlcmUpIC0+XG4gICAgICBMaXN0XG4gICAgICAgIChBdG9tIHRhZ1xuICAgICAgICAgOjogc2V4cFxuICAgICAgICAgOjpcbiAgICAgICAgIChtYXRjaCBoZXJlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgaGVyZSAtPiBbIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZSBdKSlcbiAgICAgIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiBMaXN0IChBdG9tIHRhZyA6OiB0b19zZXhwc19odW0gdCBbXSkgOjogYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gc2V4cCA6OiB0b19zZXhwc19odW0gdCBbXSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCB0YWcgPSAwIHRoZW4gTGlzdCBib2R5IDo6IGFjIGVsc2UgTGlzdCAoQXRvbSB0YWcgOjogYm9keSkgOjogYWNcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICBTZXhwLkxpc3RcbiAgICAgICAgWyB0b19zZXhwX2h1bSB0OyBzZXhwX29mX2xpc3Qgc2V4cF9vZl9zdHJpbmcgKFN0cmluZy5zcGxpdF9saW5lcyBiYWNrdHJhY2UpIF1cbiAgICAgIDo6IGFjXG4gICAgfCBPZl9saXN0IChfLCB0cykgLT5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPiB0b19zZXhwc19odW0gdCBhYylcblxuICBhbmQgdG9fc2V4cF9odW0gdCA9XG4gICAgbWF0Y2ggdG9fc2V4cHNfaHVtIHQgW10gd2l0aFxuICAgIHwgWyBzZXhwIF0gLT4gc2V4cFxuICAgIHwgc2V4cHMgLT4gU2V4cC5MaXN0IHNleHBzXG4gIDs7XG5lbmRcblxub3BlbiBNZXNzYWdlXG5cbm1vZHVsZSBDb21wdXRlZCA9IHN0cnVjdFxuICAoKiBNZW1vaXplZCwgbGF6aWx5LWNvbXB1dGVkIHJlcHJlc2VudGF0aW9uIG9mIG1lc3NhZ2VzLiBNYWludGFpbnMgaXRzIG93biBzdGF0ZSB0b1xuICAgICBhdm9pZCBzdGFjayBvdmVyZmxvdyBmcm9tIG5lc3RlZCBbTGF6eS50XS4gKilcblxuICAoKiBXZSB1c2UgYSBnbG9iYWwgW3N0YXRlIHJlZl0gc28gd2UgY2FuIG11dGF0ZSBbc3RhdGVdLCBidXQgc3RpbGwgW2dsb2JhbGl6ZV0gd2l0aCBub1xuICAgICBjb3N0IGFuZCB3aXRob3V0IGR1cGxpY2F0aW5nIHN0YXRlLiAqKVxuICB0eXBlIGluZm8gPSB7IHN0YXRlIDogc3RhdGUgcmVmIH0gW0BAdW5ib3hlZF1cblxuICAoKiBBbiBbaW5mb10gc3RhcnRzIGFzIGEgW2NvbnN0cnVjdG9yXS4gV2hlbiBmb3JjZWQsIGl0IGlzIG1hcmtlZCBbQ29tcHV0aW5nXSB0byBhdm9pZFxuICAgICBjeWNsZXMuIFdoZW4gZmluaXNoZWQsIHRoZSBmaW5hbCBbbWVzc2FnZV0gaXMgcmVjb3JkZWQuICopXG4gIGFuZCBzdGF0ZSA9XG4gICAgfCBJbml0aWFsIG9mIGNvbnN0cnVjdG9yXG4gICAgfCBDb21wdXRpbmdcbiAgICB8IEZpbmFsIG9mIE1lc3NhZ2UudFxuXG4gICgqIFJlY3Vyc2l2ZSBjb25zdHJ1Y3RvcnMgZm9yIFtJbmZvLnRdLiBPdGhlcnMgY2FuIGJlIGJ1aWx0IGRpcmVjdGx5IGFzIFtNZXNzYWdlLnRdLiAqKVxuICBhbmQgY29uc3RydWN0b3IgPVxuICAgIHwgQ29uc19sYXp5X2luZm8gb2YgaW5mbyBMYXp5LnRcbiAgICB8IENvbnNfbGlzdCBvZiBpbmZvIGxpc3RcbiAgICB8IENvbnNfdGFnX2FyZyBvZiBzdHJpbmcgKiBTZXhwLnQgKiBpbmZvXG4gICAgfCBDb25zX3RhZ190IG9mIHN0cmluZyAqIGluZm9cblxuICAoKiBUaGlzIGlzIGEgbm8tb3AsIHNpbmNlIFtpbmZvXSBpcyB1bmJveGVkLiAqKVxuICBsZXQgZ2xvYmFsaXplX2luZm8geyBzdGF0ZSB9ID0geyBzdGF0ZSB9XG5cbiAgKCogV2Uga2VlcCBhIGxpc3Qgb2Ygc3RhY2tfZnJhbWVzIHdoaWxlIGNvbXB1dGluZywgcmF0aGVyIHRoYW4gdXNpbmcgdGhlIGNhbGwgc3RhY2suICopXG4gIHR5cGUgc3RhY2tfZnJhbWUgPVxuICAgIHwgSW5faW5mbyBvZiBpbmZvXG4gICAgfCBJbl90YWdfYXJnIG9mIHN0cmluZyAqIFNleHAudFxuICAgIHwgSW5fdGFnX3Qgb2Ygc3RyaW5nXG4gICAgfCBJbl9saXN0IG9mXG4gICAgICAgIHsgZndkX3ByZWZpeCA6IGluZm8gbGlzdFxuICAgICAgICA7IHJldl9zdWZmaXggOiBNZXNzYWdlLnQgbGlzdFxuICAgICAgICB9XG5cbiAgKCogVGhlIGZvbGxvd2luZyBtdXR1YWxseS1yZWN1cnNpdmUgZnVuY3Rpb25zIGNvbXB1dGUgYSBbTWVzc2FnZS50XSBmcm9tIGFuIFtpbmZvXS5cbiAgICAgQWxsIGNhbGxzIGJlbG93IGFyZSB0YWlsIGNhbGxzOiB3ZSB3YW50IHRvIGF2b2lkIHVzaW5nIHRoZSBjYWxsIHN0YWNrIGluIGZhdm9yXG4gICAgIG9mIG91ciBvd24gbWFudWFsIHN0YWNrLiAqKVxuICBsZXQgcmVjIGNvbXB1dGVfaW5mbyBpbmZvIHN0YWNrID1cbiAgICBtYXRjaCAhKGluZm8uc3RhdGUpIHdpdGhcbiAgICB8IEluaXRpYWwgY29ucyAtPlxuICAgICAgaW5mby5zdGF0ZSA6PSBDb21wdXRpbmc7XG4gICAgICBjb21wdXRlX2NvbnN0cnVjdG9yIGNvbnMgKEluX2luZm8gaW5mbyA6OiBzdGFjaylcbiAgICB8IENvbXB1dGluZyAtPlxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChDb3VsZF9ub3RfY29uc3RydWN0IChBdG9tIFwiY3ljbGUgd2hpbGUgY29tcHV0aW5nIG1lc3NhZ2VcIikpIHN0YWNrXG4gICAgfCBGaW5hbCBtZXNzYWdlIC0+IGNvbXB1dGVfbWVzc2FnZSBtZXNzYWdlIHN0YWNrXG5cbiAgYW5kIGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4IH5yZXZfc3VmZml4IHN0YWNrID1cbiAgICBtYXRjaCBmd2RfcHJlZml4IHdpdGhcbiAgICB8IGluZm8gOjogZndkX3ByZWZpeCAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fbGlzdCB7IGZ3ZF9wcmVmaXg7IHJldl9zdWZmaXggfSA6OiBzdGFjaylcbiAgICB8IFtdIC0+XG4gICAgICBsZXQgaW5mb3MgPVxuICAgICAgICBMaXN0LmZvbGQgcmV2X3N1ZmZpeCB+aW5pdDpbXSB+ZjooZnVuIHRhaWwgbWVzc2FnZSAtPlxuICAgICAgICAgIG1hdGNoIG1lc3NhZ2Ugd2l0aFxuICAgICAgICAgIHwgT2ZfbGlzdCAoXywgbWVzc2FnZXMpIC0+IG1lc3NhZ2VzIEAgdGFpbFxuICAgICAgICAgIHwgXyAtPiBtZXNzYWdlIDo6IHRhaWwpXG4gICAgICBpblxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChPZl9saXN0IChOb25lLCBpbmZvcykpIHN0YWNrXG5cbiAgYW5kIGNvbXB1dGVfY29uc3RydWN0b3IgY29ucyBzdGFjayA9XG4gICAgbWF0Y2ggY29ucyB3aXRoXG4gICAgfCBDb25zX3RhZ19hcmcgKHRhZywgYXJnLCBpbmZvKSAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fdGFnX2FyZyAodGFnLCBhcmcpIDo6IHN0YWNrKVxuICAgIHwgQ29uc190YWdfdCAodGFnLCBpbmZvKSAtPiBjb21wdXRlX2luZm8gaW5mbyAoSW5fdGFnX3QgdGFnIDo6IHN0YWNrKVxuICAgIHwgQ29uc19saXN0IGluZm9zIC0+IGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4OmluZm9zIH5yZXZfc3VmZml4OltdIHN0YWNrXG4gICAgfCBDb25zX2xhenlfaW5mbyBsYXp5X2luZm8gLT5cbiAgICAgIChtYXRjaCBMYXp5LmZvcmNlIGxhenlfaW5mbyB3aXRoXG4gICAgICAgfCBpbmZvIC0+IGNvbXB1dGVfaW5mbyBpbmZvIHN0YWNrXG4gICAgICAgfCBleGNlcHRpb24gZXhuIC0+IGNvbXB1dGVfbWVzc2FnZSAoQ291bGRfbm90X2NvbnN0cnVjdCAoRXhuLnNleHBfb2ZfdCBleG4pKSBzdGFjaylcblxuICBhbmQgY29tcHV0ZV9tZXNzYWdlIG1lc3NhZ2Ugc3RhY2sgPVxuICAgIG1hdGNoIHN0YWNrIHdpdGhcbiAgICB8IFtdIC0+IG1lc3NhZ2VcbiAgICB8IEluX2luZm8gaW5mbyA6OiBzdGFjayAtPlxuICAgICAgaW5mby5zdGF0ZSA6PSBGaW5hbCBtZXNzYWdlO1xuICAgICAgY29tcHV0ZV9tZXNzYWdlIG1lc3NhZ2Ugc3RhY2tcbiAgICB8IEluX3RhZ19hcmcgKHRhZywgYXJnKSA6OiBzdGFjayAtPlxuICAgICAgY29tcHV0ZV9tZXNzYWdlIChUYWdfYXJnICh0YWcsIGFyZywgbWVzc2FnZSkpIHN0YWNrXG4gICAgfCBJbl90YWdfdCB0YWcgOjogc3RhY2sgLT4gY29tcHV0ZV9tZXNzYWdlIChUYWdfdCAodGFnLCBtZXNzYWdlKSkgc3RhY2tcbiAgICB8IEluX2xpc3QgeyBmd2RfcHJlZml4OyByZXZfc3VmZml4IH0gOjogc3RhY2sgLT5cbiAgICAgIGNvbXB1dGVfaW5mb19saXN0IH5md2RfcHJlZml4IH5yZXZfc3VmZml4OihtZXNzYWdlIDo6IHJldl9zdWZmaXgpIHN0YWNrXG4gIDs7XG5cbiAgKCogSGVscGVyIGZ1bmN0aW9ucyBmb3IgY29udmVydGluZyBhbmQgY29uc3RydWN0aW5nIFtpbmZvXS4gKilcblxuICBsZXQgdG9fbWVzc2FnZSBpbmZvID0gY29tcHV0ZV9pbmZvIGluZm8gW11cbiAgbGV0IG9mX21lc3NhZ2UgbWVzc2FnZSA9IHsgc3RhdGUgPSByZWYgKEZpbmFsIG1lc3NhZ2UpIH1cblxuICBsZXQgaXNfY29tcHV0ZWQgaW5mbyA9XG4gICAgbWF0Y2ggIShpbmZvLnN0YXRlKSB3aXRoXG4gICAgfCBJbml0aWFsIF8gfCBDb21wdXRpbmcgLT4gZmFsc2VcbiAgICB8IEZpbmFsIF8gLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCBvZl9jb25zIGNvbnMgPSB7IHN0YXRlID0gcmVmIChJbml0aWFsIGNvbnMpIH1cbiAgbGV0IG9mX2xhenlfaW5mbyBsYXp5X2luZm8gPSBvZl9jb25zIChDb25zX2xhenlfaW5mbyBsYXp5X2luZm8pXG5cbiAgbGV0IG9mX2xhenlfY29ucyBsYXp5X2NvbnMgPVxuICAgIG9mX2NvbnMgKENvbnNfbGF6eV9pbmZvIChsYXp5IChvZl9jb25zIChMYXp5LmZvcmNlIGxhenlfY29ucykpKSlcbiAgOztcblxuICBsZXQgb2ZfbGF6eV9tZXNzYWdlIGxhenlfbWVzc2FnZSA9XG4gICAgb2ZfY29ucyAoQ29uc19sYXp5X2luZm8gKGxhenkgKG9mX21lc3NhZ2UgKExhenkuZm9yY2UgbGF6eV9tZXNzYWdlKSkpKVxuICA7O1xuZW5kXG5cbm9wZW4gQ29tcHV0ZWRcblxudHlwZSB0ID0gQ29tcHV0ZWQuaW5mb1xuXG5sZXQgZ2xvYmFsaXplID0gQ29tcHV0ZWQuZ2xvYmFsaXplX2luZm9cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5cbigqIEl0IGlzIE9LIHRvIHVzZSBbTWVzc2FnZS50b19zZXhwX2h1bV0sIHdoaWNoIGlzIG5vdCBzdGFibGUsIGJlY2F1c2UgW3Rfb2Zfc2V4cF0gYmVsb3dcbiAgIGNhbiBoYW5kbGUgYW55IHNleHAuICopXG5sZXQgc2V4cF9vZl90IHQgPSBNZXNzYWdlLnRvX3NleHBfaHVtICh0b19tZXNzYWdlIHQpXG5sZXQgdF9vZl9zZXhwIHNleHAgPSBvZl9tZXNzYWdlIChNZXNzYWdlLlNleHAgc2V4cClcbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IEFueSBcIkluZm8udFwiIH1cbmxldCBjb21wYXJlIHQxIHQyID0gU2V4cC5jb21wYXJlIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgY29tcGFyZV9fbG9jYWwgdDEgdDIgPSBjb21wYXJlIChnbG9iYWxpemUgdDEpIChnbG9iYWxpemUgdDIpXG5sZXQgZXF1YWwgdDEgdDIgPSBTZXhwLmVxdWFsIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgZXF1YWxfX2xvY2FsIHQxIHQyID0gZXF1YWwgKGdsb2JhbGl6ZSB0MSkgKGdsb2JhbGl6ZSB0MilcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gU2V4cC5oYXNoX2ZvbGRfdCBzdGF0ZSAoc2V4cF9vZl90IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG5sZXQgdG9fc3RyaW5nX2h1bSB0ID1cbiAgbWF0Y2ggdG9fbWVzc2FnZSB0IHdpdGhcbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgbWVzc2FnZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gKE1lc3NhZ2UudG9fc2V4cF9odW0gbWVzc2FnZSlcbjs7XG5cbmxldCB0b19zdHJpbmdfbWFjaCB0ID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl90IHQpXG5sZXQgb2ZfbGF6eSBsID0gb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChTdHJpbmcgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfc2V4cCBsID0gb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChTZXhwIChMYXp5LmZvcmNlIGwpKSlcbmxldCBvZl9sYXp5X3QgbGF6eV90ID0gb2ZfbGF6eV9pbmZvIGxhenlfdFxubGV0IG9mX3N0cmluZyBtZXNzYWdlID0gb2ZfbWVzc2FnZSAoU3RyaW5nIG1lc3NhZ2UpXG5sZXQgY3JlYXRlZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgb2Zfc3RyaW5nIGZvcm1hdFxubGV0IG9mX3RodW5rIGYgPSBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFN0cmluZyAoZiAoKSkpKVxuXG5sZXQgY3JlYXRlID9oZXJlID9zdHJpY3QgdGFnIHggc2V4cF9vZl94ID1cbiAgbWF0Y2ggc3RyaWN0IHdpdGhcbiAgfCBOb25lIC0+IG9mX2xhenlfbWVzc2FnZSAobGF6eSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKSlcbiAgfCBTb21lICgpIC0+IG9mX21lc3NhZ2UgKFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gb2ZfbWVzc2FnZSAoU2V4cCBzZXhwKVxubGV0IHRhZyB0IH50YWcgPSBvZl9jb25zIChDb25zX3RhZ190ICh0YWcsIHQpKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gb2ZfbGF6eV9jb25zIChsYXp5IChDb25zX3RhZ19hcmcgKFwiXCIsIExhenkuZm9yY2UgdGFnLCB0KSkpXG5sZXQgdGFnX3MgdCB+dGFnID0gb2ZfY29ucyAoQ29uc190YWdfYXJnIChcIlwiLCB0YWcsIHQpKVxubGV0IHRhZ19hcmcgdCB0YWcgeCBzZXhwX29mX3ggPSBvZl9sYXp5X2NvbnMgKGxhenkgKENvbnNfdGFnX2FyZyAodGFnLCBzZXhwX29mX3ggeCwgdCkpKVxubGV0IG9mX2xpc3QgdHMgPSBvZl9jb25zIChDb25zX2xpc3QgdHMpXG5cbmV4Y2VwdGlvbiBFeG4gb2YgdFxuXG5sZXQgKCkgPVxuICAoKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlXG4gICAgIFtleGNlcHRpb24gRXhuIG9mIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdIC4uLiBbQEBAZW5kXV0gdG8gZWxpbWluYXRlIHRoZSBleHRyYVxuICAgICB3cmFwcGluZyBvZiBcIihFeG4gLi4uKVwiLiAqKVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhuXSAoZnVuY3Rpb25cbiAgICB8IEV4biB0IC0+IHNleHBfb2ZfdCB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB0b19leG4gdCA9XG4gIGlmIG5vdCAoaXNfY29tcHV0ZWQgdClcbiAgdGhlbiBFeG4gdFxuICBlbHNlIChcbiAgICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICAgIHwgTWVzc2FnZS5FeG4gZXhuIC0+IGV4blxuICAgIHwgXyAtPiBFeG4gdClcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPVxuICBsZXQgYmFja3RyYWNlID1cbiAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGBHZXQgLT4gU29tZSAoU3RkbGliLlByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gICAgfCBTb21lIChgVGhpcyBzKSAtPiBTb21lIHNcbiAgaW5cbiAgbWF0Y2ggZXhuLCBiYWNrdHJhY2Ugd2l0aFxuICB8IEV4biB0LCBOb25lIC0+IHRcbiAgfCBFeG4gdCwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFdpdGhfYmFja3RyYWNlICh0b19tZXNzYWdlIHQsIGJhY2t0cmFjZSkpKVxuICB8IF8sIE5vbmUgLT4gb2ZfbWVzc2FnZSAoTWVzc2FnZS5FeG4gZXhuKVxuICB8IF8sIFNvbWUgYmFja3RyYWNlIC0+XG4gICAgb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChXaXRoX2JhY2t0cmFjZSAoU2V4cCAoRXhuLnNleHBfb2ZfdCBleG4pLCBiYWNrdHJhY2UpKSlcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbmZvXCJcbiAgbGV0IHBwIHBwZiB0ID0gU3RkbGliLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmdfaHVtIHQpXG5lbmQpXG5cbm1vZHVsZSBJbnRlcm5hbF9yZXByID0gc3RydWN0XG4gIGluY2x1ZGUgTWVzc2FnZVxuXG4gIGxldCB0b19pbmZvID0gb2ZfbWVzc2FnZVxuICBsZXQgb2ZfaW5mbyA9IHRvX21lc3NhZ2VcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGw0IiwiYTEiLCJhMiIsImEzIiwiZ2xvYmFsX2RhdGEiLCJ0X3NleHBfZ3JhbW1hciIsIm1vZHVsZV9uYW1lIiwiU3RkbGliX0Zvcm1hdCIsIkJhc2VfRXhuIiwiU3RkbGliX1ByaW50ZXhjIiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9QcmludGYiLCJCYXNlX1NleHAiLCJCYXNlX0hhc2giLCJCYXNlX0ltcG9ydCIsIkJhc2VfTGlzdCIsIkJhc2VfU291cmNlX2NvZGVfcG9zaXRpb24wIiwiQmFzZV9TdHJpbmcwIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsInNleHBfb2ZfdCIsInBhcmFtIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsImFyZzBfMDAzIiwicmVzMF8wMDQiLCJhcmcwXzAwNSIsInJlczBfMDA2IiwiYXJnMF8wMDciLCJyZXMwXzAwOCIsImFyZzJfMDExIiwiYXJnMV8wMTAiLCJhcmcwXzAwOSIsInJlczBfMDEyIiwicmVzMV8wMTMiLCJyZXMyXzAxNCIsImFyZzFfMDE2IiwiYXJnMF8wMTUiLCJyZXMwXzAxNyIsInJlczFfMDE4IiwiYXJnMl8wMjEiLCJhcmcxXzAyMCIsImFyZzBfMDE5IiwicmVzMF8wMjIiLCJyZXMxXzAyMyIsInJlczJfMDI0IiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJhcmcxXzAzMCIsImFyZzBfMDI5IiwicmVzMF8wMzEiLCJyZXMxXzAzMiIsInRvX3NleHBzX2h1bSIsInQiLCJhYyIsInN0cmluZyIsImV4biIsInNleHAiLCJoZXJlIiwidGFnIiwiYm9keSIsInRzIiwiYmFja3RyYWNlIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsImdsb2JhbGl6ZV9pbmZvIiwiY29tcHV0ZV9pbmZvIiwiY291bnRlciIsImluZm8iLCJzdGFjayIsIm1hdGNoIiwibWVzc2FnZSIsImNvbnMiLCJsYXp5X2luZm8iLCJpbmZvcyIsImFyZyIsImNvbXB1dGVfaW5mb19saXN0IiwiZndkX3ByZWZpeCIsInJldl9zdWZmaXgiLCJ0YWlsIiwibWVzc2FnZXMiLCJjb21wdXRlX21lc3NhZ2UiLCJ0b19tZXNzYWdlIiwib2ZfbWVzc2FnZSIsIm9mX2NvbnMiLCJvZl9sYXp5X2NvbnMiLCJsYXp5X2NvbnMiLCJvZl9sYXp5X21lc3NhZ2UiLCJsYXp5X21lc3NhZ2UiLCJpbnZhcmlhbnQiLCJ0X29mX3NleHAiLCJjb21wYXJlIiwidDEiLCJ0MiIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbCIsImVxdWFsX2xvY2FsIiwiaGFzaF9mb2xkX3QiLCJzdGF0ZSIsImhhc2giLCJ0b19zdHJpbmdfaHVtIiwicyIsInRvX3N0cmluZ19tYWNoIiwib2ZfbGF6eSIsImwiLCJvZl9sYXp5X3NleHAiLCJvZl9sYXp5X3QiLCJvZl9zdHJpbmciLCJjcmVhdGVmIiwiZm9ybWF0Iiwib2ZfdGh1bmsiLCJjcmVhdGUiLCJzdHJpY3QiLCJ4Iiwic2V4cF9vZl94IiwiY3JlYXRlX3MiLCJ0YWdfc19sYXp5IiwidGFnX3MiLCJ0YWdfYXJnIiwib2ZfbGlzdCIsIkV4biIsInRvX2V4biIsIm9mX2V4biIsInBwIiwicHBmIiwiaW5jbHVkZSIsIkJhc2VfSW5mbyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMs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Z25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMTY0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9lcnJvci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgbW9kdWxlIGlzIHRyeWluZyB0byBtaW5pbWl6ZSBkZXBlbmRlbmNpZXMgb24gbW9kdWxlcyBpbiBDb3JlLCBzbyBhcyB0byBhbGxvd1xuICAgW0Vycm9yXSBhbmQgW09yX2Vycm9yXSB0byBiZSB1c2VkIGluIHZhcmlvdXMgcGxhY2VzLiAgUGxlYXNlIGF2b2lkIGFkZGluZyBuZXdcbiAgIGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9cblxubGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIkVycm9yLnRcIiB9XG5sZXRbQGNvbGRdIHJhaXNlIHQgPSByYWlzZSAodG9fZXhuIHQpXG5sZXRbQGNvbGRdIHJhaXNlX3Mgc2V4cCA9IHJhaXNlIChjcmVhdGVfcyBzZXhwKVxubGV0IHRvX2luZm8gdCA9IHRcbmxldCBvZl9pbmZvIHQgPSB0XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FcnJvclwiXG4gIGxldCBwcCA9IHBwXG5lbmQpXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImdsb2JhbF9kYXRhIiwidF9zZXhwX2dyYW1tYXIiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW5mbyIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJjb21wYXJlIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsIiwiZXF1YWxfbG9jYWwiLCJnbG9iYWxpemUiLCJoYXNoX2ZvbGRfdCIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJpbnZhcmlhbnQiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9zdHJpbmciLCJvZl9sYXp5Iiwib2ZfbGF6eV9zZXhwIiwib2ZfdGh1bmsiLCJvZl9sYXp5X3QiLCJjcmVhdGUiLCJjcmVhdGVfcyIsImNyZWF0ZWYiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwib2ZfbGlzdCIsIm9mX2V4biIsInRvX2V4biIsInBwIiwiSW50ZXJuYWxfcmVwciIsInJhaXNlIiwidCIsInJhaXNlX3MiLCJzZXhwIiwidG9faW5mbyIsIm9mX2luZm8iLCJpbmNsdWRlIiwiQmFzZV9FcnJvciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxZQUFBQyxNQUFBQyxHQ1EyQixnREFBVTtBQUFBLFlBQUFDLFFBQUFDLE1BQ0wsT0FBZSxNQUFmLGVBQWU7QUFBQSxZQUFBQyxRQUFBSCxHQUMvQixTQUFDO0FBQUEsWUFBQUksUUFBQUosR0FDRCxTQUFDO0FBQUE7QUFBQSxJQUFBSyxVRFhqQjtBQUFBLElBQUFSLE9BQUE7QUFBQSxJQUFBUztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE3MzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaW52YXJpYW50Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludmFyaWFudF9pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5sZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA6IHVuaXQgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJcIiwgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlXG4gICAgICAgICA7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4blxuICAgICAgICAgOyBcIlwiLCBzZXhwX29mX3QgdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCBjaGVja19maWVsZCB0IGYgZmllbGQgPVxuICB0cnkgZiAoRmllbGQuZ2V0IGZpZWxkIHQpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcInByb2JsZW0gd2l0aCBmaWVsZFwiXG4gICAgICAgICBbIFwiZmllbGRcIiwgc2V4cF9vZl9zdHJpbmcgKEZpZWxkLm5hbWUgZmllbGQpOyBcImV4blwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9leG4iLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiQmFzZV9GaWVsZCIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXhwIiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbjAiLCJCYXNlX0Vycm9yIiwicmFpc2VfcyIsImNzdF9pbnZhcmlhbnRfZmFpbGVkIiwiY3N0X2ZpZWxkIiwiY3N0X3Byb2JsZW1fd2l0aF9maWVsZCIsImludmFyaWFudCIsImhlcmUiLCJ0Iiwic2V4cF9vZl90IiwiZXhuIiwiY2hlY2tfZmllbGQiLCJmaWVsZCIsIkJhc2VfSW52YXJpYW50Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQU4sTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBTyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQVgsVUFBQTtBQUFBLElBQUFZLHVCQUFBO0FBQUEsSUFBQVosWUFBQTtBQUFBLElBQUFhLFlBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLFlBQUFDLFVBQUFDLE1BQUFDLEdBQUFDLFdBQUFmO0FBQUFBLElDTUUsWUFBSTtBQUFBLFVBQUFnQjtBQUFBQTtBQUFBQSxNQUFBQSxNRE5OO0FBQUEsVUNhZTtBQUFBLFVBREc7QUFBQSxVQURIO0FBQUEsS0FGVCxPQUtLLFFBTEwsa0RBS0s7QUFBQTtBQUFBO0FBQUEsWUFBQUMsWUFBQUgsR0FBQWQsR0FBQWtCO0FBQUFBLElBSVQsWUFBSSxjQUFFO0FBQUEsVUFBQUY7QUFBQUE7QUFBQUEsTUFBQUEsTURsQlI7QUFBQSxVQ3VCOEQ7QUFBQSxVQUEzQjtBQUFBLFVBQWY7QUFBQSxLQUZkLE9BRTBFLFFBRjFFLG9EQUUwRTtBQUFBO0FBQUE7QUFBQSxPQUFBRyxpQkR2QmhGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTE3OTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvb3JfZXJyb3IubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID0gKCdhLCBFcnJvci50KSBSZXN1bHQudFxuW0BAZGVyaXZpbmdfaW5saW5lXG4gIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gIGZ1biBfY21wX19hIGFfXzAwN18gYl9fMDA4XyAtPlxuICBSZXN1bHQuY29tcGFyZV9fbG9jYWwgX2NtcF9fYSBFcnJvci5jb21wYXJlX19sb2NhbCBhX18wMDdfIGJfXzAwOF9cbjs7XG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT4gUmVzdWx0LmNvbXBhcmUgX2NtcF9fYSBFcnJvci5jb21wYXJlIGFfXzAwMV8gYl9fMDAyX1xuOztcblxubGV0IGVxdWFsX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMTlfIGJfXzAyMF8gLT5cbiAgUmVzdWx0LmVxdWFsX19sb2NhbCBfY21wX19hIEVycm9yLmVxdWFsX19sb2NhbCBhX18wMTlfIGJfXzAyMF9cbjs7XG5cbmxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMTNfIGJfXzAxNF8gLT4gUmVzdWx0LmVxdWFsIF9jbXBfX2EgRXJyb3IuZXF1YWwgYV9fMDEzXyBiX18wMTRfXG47O1xuXG5sZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAyNV8pIDogKChhX18wMjVfIC0+IGFfXzAyNV8pIC0+IGFfXzAyNV8gdCAtPiBhX18wMjVfIHQpIC0+XG4gIGZ1biBfZ2xvYmFsaXplX2FfXzAyNl8geF9fMDI3XyAtPlxuICBSZXN1bHQuZ2xvYmFsaXplIF9nbG9iYWxpemVfYV9fMDI2XyBFcnJvci5nbG9iYWxpemUgeF9fMDI3X1xuOztcblxubGV0IGhhc2hfZm9sZF90IDpcbiAgICAgICdhLlxuICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgIC0+ICdhIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgaHN2IGFyZyAtPiBSZXN1bHQuaGFzaF9mb2xkX3QgX2hhc2hfZm9sZF9hIEVycm9yLmhhc2hfZm9sZF90IGhzdiBhcmdcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAzMF8geF9fMDMyXyAtPiBSZXN1bHQudF9vZl9zZXhwIF9vZl9hX18wMzBfIEVycm9yLnRfb2Zfc2V4cCB4X18wMzJfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMzNfIHhfXzAzNF8gLT4gUmVzdWx0LnNleHBfb2ZfdCBfb2ZfYV9fMDMzXyBFcnJvci5zZXhwX29mX3QgeF9fMDM0X1xuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZXN1bHQudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hciBFcnJvci50X3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0ICggPj49ICkgPSBSZXN1bHQuKCA+Pj0gKVxubGV0ICggPj58ICkgPSBSZXN1bHQuKCA+PnwgKVxubGV0IGJpbmQgPSBSZXN1bHQuYmluZFxubGV0IGlnbm9yZV9tID0gUmVzdWx0Lmlnbm9yZV9tXG5sZXQgam9pbiA9IFJlc3VsdC5qb2luXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IHJldHVybiA9IFJlc3VsdC5yZXR1cm5cblxubW9kdWxlIE1vbmFkX2luZml4ID0gUmVzdWx0Lk1vbmFkX2luZml4XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIGEgLT4gaW52YXJpYW50X2EgYVxuICB8IEVycm9yIGVycm9yIC0+IEVycm9yLmludmFyaWFudCBlcnJvclxuOztcblxubGV0IG1hcDIgYSBiIH5mID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgT2sgeCwgT2sgeSAtPiBPayAoZiB4IHkpXG4gIHwgT2sgXywgKEVycm9yIF8gYXMgZSkgfCAoRXJyb3IgXyBhcyBlKSwgT2sgXyAtPiBlXG4gIHwgRXJyb3IgZTEsIEVycm9yIGUyIC0+IEVycm9yIChFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG47O1xuXG5tb2R1bGUgRm9yX2FwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBsZXQgbWFwMiA9IG1hcDJcbmVuZClcblxubGV0ICggKj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oICo+IClcbmxldCAoIDwqICkgPSBGb3JfYXBwbGljYXRpdmUuKCA8KiApXG5sZXQgKCA8Kj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oIDwqPiApXG5sZXQgYXBwbHkgPSBGb3JfYXBwbGljYXRpdmUuYXBwbHlcbmxldCBib3RoID0gRm9yX2FwcGxpY2F0aXZlLmJvdGhcbmxldCBtYXAzID0gRm9yX2FwcGxpY2F0aXZlLm1hcDNcblxubW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gRm9yX2FwcGxpY2F0aXZlLkFwcGxpY2F0aXZlX2luZml4XG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5sZXQgb2sgPSBSZXN1bHQub2tcbmxldCBpc19vayA9IFJlc3VsdC5pc19va1xubGV0IGlzX2Vycm9yID0gUmVzdWx0LmlzX2Vycm9yXG5cbmxldCB0cnlfd2l0aCA/KGJhY2t0cmFjZSA9IGZhbHNlKSBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuID9iYWNrdHJhY2U6KGlmIGJhY2t0cmFjZSB0aGVuIFNvbWUgYEdldCBlbHNlIE5vbmUpKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2JhY2t0cmFjZSBmID0gam9pbiAodHJ5X3dpdGggP2JhY2t0cmFjZSBmKVxuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IucmFpc2UgZXJyXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRXJyb3IgKEVycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcblxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSA9IGZ1bmN0aW9uXG4gIHwgT2sgXyBhcyB6IC0+IHpcbiAgfCBFcnJvciBleG4gLT4gb2ZfZXhuID9iYWNrdHJhY2UgZXhuXG47O1xuXG5sZXQgb2Zfb3B0aW9uID0gUmVzdWx0Lm9mX29wdGlvblxuXG5sZXQgZXJyb3IgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRXJyb3IgKEVycm9yLmNyZWF0ZSA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgZXJyb3JfcyBzZXhwID0gRXJyb3IgKEVycm9yLmNyZWF0ZV9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1lc3NhZ2UgPSBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooZnVuIGUgLT4gRXJyb3IudGFnX2FyZyBlIG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBzID0gZXJyb3IgXCJ1bmltcGxlbWVudGVkXCIgcyBzZXhwX29mX3N0cmluZ1xuXG5sZXQgY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vayB+b25fZXJyb3IgPVxuICBtYXRjaCBSZXN1bHQuY29tYmluZV9lcnJvcnMgbGlzdCB3aXRoXG4gIHwgT2sgeCAtPiBPayAob25fb2sgeClcbiAgfCBFcnJvciBlcnJzIC0+IEVycm9yIChvbl9lcnJvciBlcnJzKVxuOztcblxubGV0IGlnbm9yZV91bml0X2xpc3QgKF8gOiB1bml0IGxpc3QpID0gKClcblxubGV0IGVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5ID0gZnVuY3Rpb25cbiAgfCBbIGUgXSAtPiBlXG4gIHwgbGlzdCAtPiBFcnJvci5vZl9saXN0IGxpc3Rcbjs7XG5cbmxldCBhbGwgbGlzdCA9IGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2s6Rm4uaWQgfm9uX2Vycm9yOmVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5XG5cbmxldCBhbGxfdW5pdCBsaXN0ID1cbiAgY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vazppZ25vcmVfdW5pdF9saXN0IH5vbl9lcnJvcjplcnJvcl9vZl9saXN0X2lmX25lY2Vzc2FyeVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGxpc3QgPSBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOkZuLmlkIH5vbl9lcnJvcjpFcnJvci5vZl9saXN0XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGxpc3QgPVxuICBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOmlnbm9yZV91bml0X2xpc3Qgfm9uX2Vycm9yOkVycm9yLm9mX2xpc3Rcbjs7XG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0LnBhcnRpdGlvbl9tYXAgbCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gIG1hdGNoIG9rIHdpdGhcbiAgfCBbXSAtPiBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJzKVxuICB8IF8gLT4gT2sgb2tcbjs7XG5cbmxldCBmaW5kX29rIGwgPVxuICBtYXRjaCBMaXN0LmZpbmRfbWFwIGwgfmY6UmVzdWx0Lm9rIHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW5jdGlvblxuICAgICAgICAgICB8IE9rIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBXaXRoX3JldHVybi53aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgICAgICB8IE9rIF8gYXMgeCAtPiByZXR1cm4geFxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IGl0ZXIgPSBSZXN1bHQuaXRlclxubGV0IGl0ZXJfZXJyb3IgPSBSZXN1bHQuaXRlcl9lcnJvclxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9MaXN0IiwiQmFzZV9FcnJvciIsIkJhc2VfV2l0aF9yZXR1cm4iLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfUmVzdWx0IiwiQmFzZV9JbXBvcnQiLCJCYXNlX1ByaW50ZiIsIkJhc2VfQXBwbGljYXRpdmUiLCJjb21wYXJlX2xvY2FsIiwiY21wX2EiLCJhXzAwNyIsImJfMDA4IiwiY29tcGFyZSIsImFfMDAxIiwiYl8wMDIiLCJlcXVhbF9sb2NhbCIsImFfMDE5IiwiYl8wMjAiLCJlcXVhbCIsImFfMDEzIiwiYl8wMTQiLCJnbG9iYWxpemUiLCJnbG9iYWxpemVfYV8wMjYiLCJ4XzAyNyIsImhhc2hfZm9sZF90IiwiaGFzaF9mb2xkX2EiLCJoc3YiLCJhcmciLCJ0X29mX3NleHAiLCJvZl9hXzAzMCIsInhfMDMyIiwic2V4cF9vZl90Iiwib2ZfYV8wMzMiLCJ4XzAzNCIsInRfc2V4cF9ncmFtbWFyIiwiYV9zZXhwX2dyYW1tYXIiLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJiaW5kIiwiaWdub3JlX20iLCJqb2luIiwibWFwIiwicmV0dXJuJCIsImludmFyaWFudCIsImludmFyaWFudF9hIiwidCIsImEiLCJlcnJvciIsIm1hcDIiLCJiIiwieCIsInkiLCJlIiwiZTEiLCJlMiIsIkZvcl9hcHBsaWNhdGl2ZSIsInN5bWJvbCIsImFwcGx5IiwiYm90aCIsIm1hcDMiLCJpbmNsdWRlIiwiT3Blbl9vbl9yaHMiLCJvayIsImlzX29rIiwiaXNfZXJyb3IiLCJ0cnlfd2l0aCIsIm9wdCIsImJhY2t0cmFjZSIsImV4biIsInRyeV93aXRoX2pvaW4iLCJva19leG4iLCJwYXJhbSIsImVyciIsIm9mX2V4biIsIm9mX2V4bl9yZXN1bHQiLCJ6Iiwib2Zfb3B0aW9uIiwiY3N0X3VuaW1wbGVtZW50ZWQiLCJoZXJlIiwic3RyaWN0IiwibWVzc2FnZSIsInNleHBfb2ZfYSIsImVycm9yX3MiLCJzZXhwIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwiZm9ybWF0IiwidGFnIiwidGFnX3MiLCJ0YWdfc19sYXp5IiwidGFnX2FyZyIsInVuaW1wbGVtZW50ZWQiLCJzIiwiZXJyb3Jfb2ZfbGlzdF9pZl9uZWNlc3NhcnkiLCJsaXN0IiwiYWxsIiwibWF0Y2giLCJlcnJzIiwiYWxsX3VuaXQiLCJjb21iaW5lX2Vycm9ycyIsIm9uX2Vycm9yIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJsIiwiZmluZF9vayIsImZpbmRfbWFwX29rIiwiZWx0IiwiaXRlciIsIml0ZXJfZXJyb3IiLCJCYXNlX09yX2Vycm9yIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsY0FBQUMsT0FBQUMsT0FBQUM7QUFBQUEsSUNRRSxvRUFBa0U7QUFBQTtBQUFBLFlBQUFDLFFBQUFILE9BQUFJLE9BQUFDO0FBQUFBLElBSW5DLG9FQUFvRDtBQUFBO0FBQUEsWUFBQUMsWUFBQU4sT0FBQU8sT0FBQUM7QUFBQUEsSUFLbkYsb0VBQThEO0FBQUE7QUFBQSxZQUFBQyxNQUFBVCxPQUFBVSxPQUFBQztBQUFBQSxJQUkvQixvRUFBZ0Q7QUFBQTtBQUFBLFlBQUFDLFVBQUFDLGlCQUFBQztBQUFBQSxJQU0vRSx1RUFBMkQ7QUFBQTtBQUFBLFlBQUFDLFlBQUFDLGFBQUFDLEtBQUFDO0FBQUFBLElBVS9CLHNFQUF5RDtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsVUFBQUM7QUFBQUEsSUFJMUQsZ0VBQW9EO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQUlwRCxnRUFBb0Q7QUFBQTtBQUFBLFlBQUFDLGVBQUFDO0FBQUFBLElBSXZELGdFQUEyRDtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjRGpEckY7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxZQUFBQyxVQUFBQyxhQUFBQztBQUFBQSxJQ2lFRSxtQkFBQUMsSUFBQSxNQUNVLGlDQUM0QjtBQUFBLFFBQUFDLFFBRnRDO0FBQUEsSUFFaUIsdUNBQXFCO0FBQUE7QUFBQSxZQUFBQyxLQUFBRixHQUFBRyxHQUFBdEQ7QUFBQUEsSUFJdEM7QUFBQSxTQUFBdUQsSUFBQTtBQUFBLHdCQUFBQyxJQUFBLE1BQ21CLCtCQUFPO0FBQUEsU0FBQUMsSUFEMUI7QUFBQTtBQUFBO0FBQUEsU0FBQUMsS0FBQTtBQUFBO0FBQUEsVUFBQUMsS0FBQTtBQUFBLE1BRzhCLDBEQUEwQjtBQUFBO0FBQUEsU0FBQUYsSUFIeEQ7QUFBQTtBQUFBLElBRWlEO0FBQUEsR0FDTztBQUFBO0FBQUEsSUFBQVgsUUQxRTFEO0FBQUEsSUFBQWM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBeEIsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQXdCLGNBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQTtBQUFBLFlBQUFDLFNBQUFDLEtBQUF2RTtBQUFBQSxRQUFBd0UsWUNrSGE7QUFBQSxnQkFDSjtBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLE1EbkhULGdDQ29IVztBQUFBLEtBQU0sNkNBQXFFO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGNBQUFGLFdBQUF4RTtBQUFBQSxJQUdoRCxPQUF1QixpQkFBdkIsdUJBQXVCO0FBQUE7QUFBQSxZQUFBMkUsT0FBQUM7QUFBQUEsSUFFaEQsdUJBQUFyQixJQUFBLFVBQ0Q7QUFBQSxRQUFBc0IsTUFEQztBQUFBLElBRUkscUNBQWU7QUFBQTtBQUFBLFlBQUFDLE9BQUFOLFdBQUFDO0FBQUFBLElBR0UscURBQTZCO0FBQUE7QUFBQSxZQUFBTSxjQUFBUCxXQUFBUTtBQUFBQSxJQUU3QyxlQUNEO0FBQUEsUUFBQVAsTUFEQztBQUFBLElBRUQsNkJBQXFCO0FBQUE7QUFBQTtBQUFBLElBQUFRLFlEbEl0QztBQUFBLElBQUFDLG9CQUFBO0FBQUE7QUFBQSxZQUFBOUIsTUFBQStCLE1BQUFDLFFBQUFDLFNBQUFsQyxHQUFBbUM7QUFBQUEsSUN3SVEsMEVBQWdEO0FBQUE7QUFBQSxZQUFBQyxRQUFBQyxNQUcvQiwyQ0FBcUI7QUFBQSxZQUFBQyxhQUFBSjtBQUFBQSxJQUNiLDhDQUF5QjtBQUFBO0FBQUEsWUFBQUssT0FBQUM7QUFBQUEsSUFDdEMsc0RBQW1DO0FBQUE7QUFBQSxZQUFBQyxJQUFBMUMsR0FBQTBDO0FBQUFBLFFBQUEsSUFDdEM7QUFBQSxxREQ5SWpCLG1CQzhJdUQ7QUFBQTtBQUFBLFlBQUFDLE1BQUEzQyxHQUFBMEM7QUFBQUEsUUFBQSxJQUNwQztBQUFBLHFERC9JbkIsbUJDK0kyRDtBQUFBO0FBQUEsWUFBQUUsV0FBQTVDLEdBQUEwQztBQUFBQSxRQUFBLElBQ25DO0FBQUEscUREaEp4QixtQkNnSnFFO0FBQUE7QUFBQSxZQUFBRyxRQUFBN0MsR0FBQW1DLFNBQUFsQyxHQUFBbUM7QUFBQUEsSUFHbkU7QUFBQTtBQUFBO0FBQUEsc0JBQUE3QjtBQUFBQSxjQUFnQywwREFBbUM7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBdUMsY0FBQUM7QUFBQUEsSUFHaEQsMERBQXNDO0FBQUE7QUFBQSxZQUFBQywyQkFBQUM7QUFBQUEsSUFVM0IsMEJBQUExQyxJQUFBLFNBQ3BCO0FBQUEsSUFDRCxzQ0FBa0I7QUFBQTtBQUFBLFlBQUEyQyxJQUFBRDtBQUFBQSxRQUFBRSxRQVR0QjtBQUFBLElBQTBCLHVCQUFBOUMsSUFBQSxVQUNWO0FBQUEsUUFBQStDLE9BRFU7QUFBQSxJQUVWLDRDQUFlO0FBQUEsR0FVK0M7QUFBQSxZQUFBQyxTQUFBSjtBQUFBQSxRQUFBRSxRQVo5RTtBQUFBLElBQTBCLG1CQUNWO0FBQUEsUUFBQUMsT0FEVTtBQUFBLElBRVYsNENBQWU7QUFBQSxHQWE2QztBQUFBLFlBQUFFLGVBQUFMO0FBQUFBLFFBQUFNLFdBRzFELGdCQUFBSixRQWxCbEI7QUFBQSxJQUEwQix1QkFBQTlDLElBQUEsVUFDVjtBQUFBLFFBQUErQyxPQURVO0FBQUEsSUFFViwwQkFBZTtBQUFBLEdBZ0I2QztBQUFBLFlBQUFJLG9CQUFBUDtBQUFBQSxRQUFBTSxXQUdsRixnQkFBQUosUUFyQk07QUFBQSxJQUEwQixtQkFDVjtBQUFBLFFBQUFDLE9BRFU7QUFBQSxJQUVWLDBCQUFlO0FBQUEsR0FtQmdDO0FBQUEsWUFBQUssdUJBQUFDO0FBQUFBO0FBQUFBLEtBQUFQLFFBSXREO0FBQUEsS0FBQUMsT0FBd0M7QUFBQSxLQUFBbkMsS0FBQTtBQUFBLElBQ3ZELDBCQUNjLGdDQUNGO0FBQUE7QUFBQSxZQUFBMEMsUUFBQUQ7QUFBQUEsUUFBQVAsUUFJTjtBQUFBLElBQTRCLGNBQUE5QyxJQUFBLFVBQ3RCO0FBQUE7QUFBQTtBQUFBLE9BSUw7QUFBQTtBQUFBO0FBQUEsa0JBQUFxQjtBQUFBQSxVQUFlO0FBQUEsV0FDSDtBQUFBLGNBQUFDLE1BREc7QUFBQSxVQUVFO0FBQUEsU0FBSTtBQUFBLElBSHhCLHdDQUcwQjtBQUFBO0FBQUEsWUFBQWlDLFlBQUFGLEdBQUE1RztBQUFBQSxJQUk5QjtBQUFBO0FBQUEsc0JBQUE0RTtBQUFBQTtBQUFBQSxlQUFBO0FBQUEsaUJBR087QUFBQTtBQUFBO0FBQUEsNEJBQUFtQztBQUFBQSx3QkFBQXhELElBQ1M7QUFBQSxvQkFBSyxlQUNJLDJCQUNHO0FBQUEsd0JBQUFzQixNQUZQO0FBQUEsb0JBRUk7QUFBQSxtQkFBRztBQUFBLGNBSnhCLHdDQUkyQjtBQUFBLGFBQUM7QUFBQTtBQUFBO0FBQUEsSUFBQS9CLFFEMU1sQztBQUFBLElBQUFrRSxPQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjA5OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zaWduMC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgaXMgYnJva2VuIG9mZiB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gU2lnbiBhbmQgQ29tcGFyYWJsZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTmVnXG4gIHwgWmVyb1xuICB8IFBvc1xuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSB+bG9jYWxpemUsIGhhc2gsIGVudW1lcmF0ZV1cblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduMC5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgfCBOZWcgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmVnXCJcbiAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbmxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50XG4gICAgICAgaHN2XG4gICAgICAgKG1hdGNoIGFyZyB3aXRoXG4gICAgICAgIHwgTmVnIC0+IDBcbiAgICAgICAgfCBaZXJvIC0+IDFcbiAgICAgICAgfCBQb3MgLT4gMilcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zIF0gOiB0IGxpc3QpXG5cbltAQEBlbmRdXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xXG4gIHwgWmVybyAtPiAwXG4gIHwgUG9zIC0+IDFcbjs7XG5cbmxldCBfID0gaGFzaFxuXG4oKiBJZ25vcmUgdGhlIGhhc2ggZnVuY3Rpb24gcHJvZHVjZWQgYnkgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2hdICopXG5sZXQgaGFzaCA9IHRvX2ludFxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25cIlxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBOZWcgZWxzZSBpZiBuID0gMCB0aGVuIFplcm8gZWxzZSBQb3NcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X05lZyIsImNzdF9Qb3MiLCJjc3RfWmVybyIsImNzdF9uZWciLCJjc3RfcG9zIiwiY3N0X3plcm8iLCJjYW1sX2ludF9jb21wYXJlIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDAzIiwidF9zZXhwX2dyYW1tYXIiLCJhbGwiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9Qb2x5MCIsIkJhc2VfSGFzaCIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsInRfb2Zfc2V4cCIsInNleHBfMDA0IiwibWF0Y2giLCJzZXhwX29mX3QiLCJwYXJhbSIsImNvbXBhcmVfbG9jYWwiLCJjb21wYXJlIiwiaGFzaF9mb2xkX3QiLCJoc3YiLCJhcmciLCJzeW1ib2wiLCJ4IiwieSIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJlcXVhbCIsImVxdWFsX2xvY2FsIiwibWF4IiwibWluIiwiUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIiwib2Zfc3RyaW5nIiwicyIsInRvX3N0cmluZyIsInQiLCJ0b19pbnQiLCJvZl9pbnQiLCJuIiwiQmFzZV9TaWduMCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLFFDWUc7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUE7QUFBQUE7QUFBQUEsS0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFFMEM7QUFBQTtBQUFBLE9BQ0Y7QUFBQTtBQUFBLE1BRkE7QUFBQTtBQUFBLFNBQUFDLFFBRHhDO0FBQUE7QUFBQSxNQWFFO0FBQUEsZ0RBQ29GO0FBQUEsU0FBQUEsVUFkdEY7QUFBQTtBQUFBLE1BV0U7QUFBQSxnREFHb0Y7QUFBQSxhQWR0RjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BT0U7QUFBQSxpREFPb0Y7QUFBQTtBQUFBLE1BTHBGO0FBQUEsZ0RBS29GO0FBQUE7QUFBQSxLQVRwRix5RUFTb0Y7QUFBQTtBQUFBLElBQXRFLDBFQUFzRTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFLdEYsc0JBQ1MsaUJBQ0Msa0JBQ0Q7QUFBQTtBQUFBLEdBQXdCO0FBQUEsT0FBQUMsZ0JBdEJqQyxrQkFBQUMsVUFBQTtBQUFBLFlBQUFDLFlBQUFDLEtBQUFDO0FBQUFBLElBNENFO0FBQUE7QUFBQSxlQUdZO0FBQUE7QUFBQSxlQUNDO0FBQUEsdUJBQ0Q7QUFBQTtBQUFBLElBTFosc0NBS2M7QUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdBQUFDLEdBa0JLLHFCQUFjO0FBQUEsWUFBQUYsU0FBQUMsR0FBQUMsR0FDYixzQkFBZTtBQUFBLFlBQUFGLFNBQUFDLEdBQUFDLEdBQ2YsdUJBQWU7QUFBQSxZQUFBRixTQUFBQyxHQUFBQyxHQUNoQix1QkFBYztBQUFBLFlBQUFGLFNBQUFDLEdBQUFDLEdBQ2QscUJBQWM7QUFBQSxZQUFBRixTQUFBQyxHQUFBQyxHQUNiLHNCQUFlO0FBQUEsWUFBQUMsVUFBQUYsR0FBQUMsR0FDWixxQ0FBa0I7QUFBQSxZQUFBRSxXQUFBSCxHQUFBQyxHQUNqQixxQ0FBbUI7QUFBQSxPQUFBTixZQWY5QztBQUFBLFlBQUFTLE1BQUFKLEdBQUFDLEdBaUJzQix1QkFBYztBQUFBLFlBQUFJLFlBQUFMLEdBQUFDLEdBQ1AsdUJBQWM7QUFBQSxZQUFBSyxJQUFBTixHQUFBQyxHQUNkLHFCQUFjO0FBQUEsWUFBQU0sSUFBQVAsR0FBQUMsR0FDZCxxQkFBYztBQUFBO0FBQUEsSUFBQU87QUFBQUEsTUFwQjNDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxHQXVCMEIsT0FBa0IsVUFBbEIsK0JBQWtCO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsUUFBQSxJQUNiO0FBQUEsSUFBYTtBQUFBO0FBQUEsWUFBQUMsT0FBQXBCO0FBQUFBLElBRWpDLHNCQUNGLGtCQUNDLGtCQUNEO0FBQUE7QUFBQSxHQUFDO0FBQUEsWUFBQXFCLE9BQUFDLEdBUUcsbUNBQWtEO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQXJDL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEdkVGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTIyNTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0NvbXBhcmFibGVfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLHVCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTIyNjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvY29tcGFyYWJsZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDb21wYXJhYmxlX2ludGZcblxubW9kdWxlIFdpdGhfemVybyAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCB6ZXJvIDogdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIGxldCBzZXhwX29mX3QgPSAoVC5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIFBvbHlcbiAgZW5kXG5cbiAgaW5jbHVkZSBQb2x5XG5cbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5cbiAgbW9kdWxlIEMgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlKVxuICBlbmRcblxuICBpbmNsdWRlIENcbmVuZFxuXG5sZXQgZ3QgY21wIGEgYiA9IGNtcCBhIGIgPiAwXG5sZXQgbHQgY21wIGEgYiA9IGNtcCBhIGIgPCAwXG5sZXQgZ2VxIGNtcCBhIGIgPSBjbXAgYSBiID49IDBcbmxldCBsZXEgY21wIGEgYiA9IGNtcCBhIGIgPD0gMFxubGV0IGVxdWFsIGNtcCBhIGIgPSBjbXAgYSBiID0gMFxubGV0IG5vdF9lcXVhbCBjbXAgYSBiID0gY21wIGEgYiA8PiAwXG5sZXQgbWluIGNtcCB0IHQnID0gaWYgbGVxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5sZXQgbWF4IGNtcCB0IHQnID0gaWYgZ2VxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5cbm1vZHVsZSBJbmZpeCAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuZW5kKSA6IEluZml4IHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBsZXQgKCA+ICkgYSBiID0gZ3QgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8ICkgYSBiID0gbHQgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA+PSApIGEgYiA9IGdlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw9ICkgYSBiID0gbGVxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPSApIGEgYiA9IGVxdWFsIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD4gKSBhIGIgPSBub3RfZXF1YWwgVC5jb21wYXJlIGEgYlxuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgQ29tcGFyaXNvbnMgKFQgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgW0BAQGVuZF1cbmVuZCkgOiBDb21wYXJpc29ucyB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuW0BAaW5saW5lIGFsd2F5c11cblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVC5jb21wYXJhdG9yX3dpdG5lc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyYXRvci5jb21wYXJlXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gQ29tcGFyaXNvbnMgKFQpXG4gIGluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgdCB0JyA9IGNvbXBhcmUgdCcgdFxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kKSA9XG5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgW0BpbmxpbmVkIGhpbnRdIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kKVxuXG5tb2R1bGUgSW5oZXJpdCAoQyA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuZW5kKSAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgY29tcG9uZW50IDogdCAtPiBDLnRcbmVuZCkgPVxuTWFrZSAoc3RydWN0XG4gIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl90ID0gKFQuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgY29tcGFyZSB0IHQnID0gQy5jb21wYXJlIChULmNvbXBvbmVudCB0KSAoVC5jb21wb25lbnQgdCcpXG5lbmQpXG5cbigqIGNvbXBhcmUgW3hdIGFuZCBbeV0gbGV4aWNvZ3JhcGhpY2FsbHkgdXNpbmcgZnVuY3Rpb25zIGluIHRoZSBsaXN0IFtjbXBzXSAqKVxubGV0IGxleGljb2dyYXBoaWMgY21wcyB4IHkgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgY21wIDo6IGNtcHMgLT5cbiAgICAgIGxldCByZXMgPSBjbXAgeCB5IGluXG4gICAgICBpZiByZXMgPSAwIHRoZW4gbG9vcCBjbXBzIGVsc2UgcmVzXG4gICAgfCBbXSAtPiAwXG4gIGluXG4gIGxvb3AgY21wc1xuOztcblxubGV0IGxpZnQgY21wIH5mIHggeSA9IGNtcCAoZiB4KSAoZiB5KVxubGV0IHJldmVyc2UgY21wIHggeSA9IGNtcCB5IHhcblxudHlwZSAnYSByZXZlcnNlZCA9ICdhXG5cbmxldCBjb21wYXJlX3JldmVyc2VkIGNtcCB4IHkgPSBjbXAgeSB4XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiY3N0X21heCIsImNzdF9taW4iLCJjc3Rfc3JjX2NvbXBhcmFibGVfbWwiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfU2V4cCIsIkJhc2VfT3JfZXJyb3IiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfUG9seTAiLCJCYXNlX1NpZ24wIiwiZ2VxIiwiY21wIiwiYSIsImIiLCJsZXEiLCJlcXVhbCIsIm1pbiIsInQiLCJtYXgiLCJJbmZpeCIsIlQiLCJzeW1ib2wiLCJDb21wYXJpc29ucyIsImluY2x1ZGUiLCJjb21wYXJlIiwiTWFrZV91c2luZ19jb21wYXJhdG9yIiwic2V4cF9vZl90IiwiY29tcGFyYXRvciIsIlJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsImNsYW1wX2V4biIsImNsYW1wIiwiTWFrZSIsIkluaGVyaXQiLCJDIiwibGV4aWNvZ3JhcGhpYyIsImNtcHMiLCJ4IiwieSIsInBhcmFtIiwicmVzIiwibGlmdCIsInJldmVyc2UiLCJjb21wYXJlX3JldmVyc2VkIiwiQmFzZV9Db21wYXJhYmxlIiwiYXNjZW5kaW5nIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsK0JBQUE7QUFBQSxJQUFB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TSxZQUFBO0FBQUEsU0FBQXVCLFlBQUE7QUFBQSxTQUFBcEIsYUFBQTtBQUFBLFNBQUFiLE1BQUE7QUFBQSxTQUFBRSxNQUFBO0FBQUEsaUJBQUFZLFFBQUFiLEdBQUFjLEtBQUFDO0FBQUFBLGFBQUEsSUMwQzZCLDRCQUFRLElBQUk7QUFBQSxTQUFKO0FBQUEsUUFBYTtBQUFBLGlCQUFBQyxnQkFBQWhCLEdBQUFELEtBQUFFO0FBQUFBLFNBQ1gscUNBQXlCLGdDQUF3QjtBQUFBO0FBQUEsaUJBQUFnQixVQUFBakIsR0FBQUQsS0FBQUU7QUFBQUEsU0FHN0UsNkJBQ1AsbUNBQTJCO0FBQUEsU0FEUjtBQUFBLFFBQ1E7QUFBQSxpQkFBQWlCLE1BQUFsQixHQUFBRCxLQUFBRTtBQUFBQSxTQUl4QjtBQUFBLFVBTUssd0NBQTZCO0FBQUE7QUFBQSxjQURHO0FBQUEsY0FBeEI7QUFBQSxjQUZaO0FBQUEsU0FFc0Qsc0NBQ3JCO0FBQUE7QUFBQTtBQUFBLFNBQUFLLFVEekR6QztBQUFBLFNBQUFJLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUF1QixZQUFBakMsR0Nlc0Isc0NBQWMsQ0FBSTtBQUFBLGlCQUFBa0MsZ0JBQUFsQyxHQUNkLHVDQUFjLENBQUs7QUFBQSxpQkFBQW1DLFlBQUFuQyxHQUN2QixzQ0FBYyxDQUFJO0FBQUEsaUJBQUFvQyxnQkFBQXBDLEdBQ2QsdUNBQWMsQ0FBSztBQUFBLGlCQUFBcUMsS0FBQXJDO0FBQUFBLGFBQUEsSUFDakI7QUFBQSxTQUFnQjtBQUFBO0FBQUEsUURuQjVDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTI1MzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaGFzaGFibGVfaW50Zi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlLktleSAqKVxubW9kdWxlIHR5cGUgS2V5ID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIFZhbHVlcyByZXR1cm5lZCBieSBbaGFzaF0gbXVzdCBiZSBub24tbmVnYXRpdmUuICBBbiBleGNlcHRpb24gd2lsbCBiZSByYWlzZWQgaW4gdGhlXG4gICAgICBjYXNlIHRoYXQgW2hhc2hdIHJldHVybnMgYSBuZWdhdGl2ZSB2YWx1ZS4gKilcbiAgdmFsIGhhc2ggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gICgqKiBUaGlzIGZ1bmN0aW9uIGlzIHNvdW5kIGJ1dCBub3QgY29tcGxldGUsIG1lYW5pbmcgdGhhdCBpZiBpdCByZXR1cm5zIFt0cnVlXSB0aGVuIGl0J3NcbiAgICAgIHNhZmUgdG8gdXNlIHRoZSB0d28gaW50ZXJjaGFuZ2VhYmx5LiAgSWYgaXQncyBbZmFsc2VdLCB5b3UgaGF2ZSBubyBndWFyYW50ZWVzLiAgRm9yXG4gICAgICBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICA+IHV0b3BcbiAgICAgICAgb3BlbiBDb3JlOztcbiAgICAgICAgbGV0IGVxdWFsIChhIDogJ2EgSGFzaHRibF9pbnRmLkhhc2hhYmxlLnQpIGIgPVxuICAgICAgICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgICAgICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgICAgICAgOztcbiAgICAgICAgbGV0IGEgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBsZXQgYiA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGVxdWFsIGEgYjs7ICAoKiBmYWxzZT8hICopXG4gICAgICBdfVxuICAqKVxuICBsZXQgZXF1YWwgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGhhc2hfcGFyYW0gPSBTdGRsaWIuSGFzaHRibC5oYXNoX3BhcmFtXG4gIGxldCBoYXNoID0gU3RkbGliLkhhc2h0YmwuaGFzaFxuICBsZXQgcG9seSA9IHsgaGFzaDsgY29tcGFyZSA9IFBvbHkuY29tcGFyZTsgc2V4cF9vZl90ID0gKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgfVxuXG4gIGxldCBvZl9rZXkgKHR5cGUgYSkgKG1vZHVsZSBLZXkgOiBLZXkgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgeyBoYXNoID0gS2V5Lmhhc2g7IGNvbXBhcmUgPSBLZXkuY29tcGFyZTsgc2V4cF9vZl90ID0gS2V5LnNleHBfb2ZfdCB9XG4gIDs7XG5cbiAgbGV0IHRvX2tleSAodHlwZSBhKSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9ID1cbiAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgaGFzaCA9IGhhc2hcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZCA6IEtleVxuICAgICAgd2l0aCB0eXBlIHQgPSBhKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgSGFzaGFibGVcblxubW9kdWxlIHR5cGUgSGFzaGFibGUgPSBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgSGFzaGFibGUudCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIHBvbHkgOiAnYSB0XG4gIHZhbCBvZl9rZXkgOiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKSAtPiAnYSB0XG4gIHZhbCB0b19rZXkgOiAnYSB0IC0+IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpXG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiZXF1YWwiLCJhIiwiYiIsImhhc2hfcGFyYW0iLCJoYXNoIiwicG9seSIsInBhcmFtIiwib2Zfa2V5IiwiS2V5IiwidG9fa2V5Iiwic2V4cF9vZl90IiwiY29tcGFyZSIsIkhhc2hhYmxlIiwiQmFzZV9IYXNoYWJsZV9pbnRmIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FBQUM7QUFBQUEsUUFBQSxJQzJDSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FHMEM7QUFBQTtBQUFBLElBQUFDLGFEOUM5QztBQUFBLElBQUFDLE9BQUE7QUFBQTtBQUFBLElBQUFDLE9BQUEseUNBQUFDLE9DbURtRSxTQUFhO0FBQUEsWUFBQUMsT0FBQUMsS0FHNUUsbUNBQXFFO0FBQUEsWUFBQUMsT0FBQUg7QUFBQUEsUUFBQUksWUFHNUQsVUFBQUMsVUFBQSxVQUFBUCxPQUFBO0FBQUEsSUFDVDtBQUFBLEdBT2tCO0FBQUE7QUFBQSxJQUFBUSxXRGpFdEI7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTI1NzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSGFzaGFibGVfaW50ZiIsImVxdWFsIiwiaGFzaF9wYXJhbSIsImhhc2giLCJwb2x5Iiwib2Zfa2V5IiwidG9fa2V5IiwiQmFzZV9IYXNoYWJsZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNTkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9TdHJpbmdhYmxlIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsa0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjYwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfSWRlbnRpZmlhYmxlX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx5QkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyNjE4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiQmFzZV9JZGVudGlmaWFibGUiLCJUIiwiaGFzaF9mb2xkX3QiLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwic3ltYm9sIiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJpbmNsdWRlIiwicHAiLCJoYXNoYWJsZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxnQkFBQUM7QUFBQUE7QUFBQUEsU0FBQUMsY0FBQTtBQUFBLFNBQUFDLE9BQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUE7QUFBQSxTQUFBQyxTQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQyxRQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLE1BQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGFBQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFFBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLEtBQUE7QUFBQSxTQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBcEI7QUFBQUE7QUFBQUEsU0FBQUMsY0FBQTtBQUFBLFNBQUFDLE9BQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxZQUFBO0FBQUE7QUFBQSxTQUFBQyxTQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQSxXQUFBO0FBQUEsU0FBQUEsV0FBQTtBQUFBLFNBQUFBLFdBQUE7QUFBQSxTQUFBQyxRQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLE1BQUE7QUFBQSxTQUFBQyxNQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGFBQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLFFBQUE7QUFBQSxTQUFBQyxhQUFBO0FBQUEsU0FBQUMsVUFBQTtBQUFBLFNBQUFDLEtBQUE7QUFBQSxTQUFBQyxXQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTI3NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvdW5pdC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBhbGwgPSAoWyAoKSBdIDogdCBsaXN0KVxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX3VuaXQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF91bml0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF91bml0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9ICh1bml0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3VuaXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gdW5pdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBjb21wYXJlIF8gXyA9IDBcbiAgbGV0IGNvbXBhcmVfX2xvY2FsIF8gXyA9IDBcbiAgbGV0IGVxdWFsX19sb2NhbCBfIF8gPSB0cnVlXG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcIigpXCIgLT4gKClcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJCYXNlLlVuaXQub2Zfc3RyaW5nOiAoKSBleHBlY3RlZFwiXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVW5pdFwiXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG5sZXQgaW52YXJpYW50ICgpID0gKClcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiYWxsIiwibW9kdWxlX25hbWUiLCJCYXNlX0ltcG9ydCIsIkJhc2VfSWRlbnRpZmlhYmxlIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImNzdF9CYXNlX1VuaXRfb2Zfc3RyaW5nX2V4cGVjdCIsImNvbXBhcmUiLCJwYXJhbSIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbF9sb2NhbCIsIm9mX3N0cmluZyIsInRvX3N0cmluZyIsImluY2x1ZGUiLCJzeW1ib2wiLCJlcXVhbCIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwicHAiLCJoYXNoYWJsZSIsImludmFyaWFudCIsIkJhc2VfVW5pdCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLFFBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUosTUFBQTtBQUFBLElBQUFLLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0NhYSwwQkFBTTtBQUFBO0FBQUEsSUFBQUMsWUFBZjtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsWUFBQUMsUUFBQSxHQUFBQyxPQVNnQixTQUFDO0FBQUEsWUFBQUMsY0FBQSxHQUFBRCxPQUNNLFNBQUM7QUFBQSxZQUFBRSxZQUFBLEdBQUFGLE9BQ0gsU0FBSTtBQUFBLFlBQUFHLFVBQUFIO0FBQUFBLElBRVg7QUFBQSxjQUVQO0FBQUEsZUFBMkM7QUFBQTtBQUFBLFlBQUFJLFVBQUFKLE9BR2pDLFdBQUk7QUFBQTtBQUFBLElBQUFLO0FBQUFBLE1BbEJyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQWQsZ0JBQUE7QUFBQSxJQUFBRSxTQUFBO0FBQUEsSUFBQUUsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBTyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFFLFNBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBUixZQUFBO0FBQUEsSUFBQVMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLFVBQUFsQixPQXlCZSxTQUFFO0FBQUE7QUFBQSxJQUFBbUI7QUFBQUEsTUF6QmpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEYkoiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjg1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXG5cbmxldCBnZXRfcG9zX2xlbiA/cG9zID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIHRyeSBSZXN1bHQuT2sgKGdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgcyAtPiBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIHMpXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJCYXNlX0Vycm9yIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiZ2V0X3Bvc19sZW5fZXhuIiwiY2hlY2tfcG9zX2xlbl9leG4iLCJQcml2YXRlIiwiZ2V0X3Bvc19sZW4iLCJwb3MiLCJsZW4iLCJwYXJhbSIsInRvdGFsX2xlbmd0aCIsImV4biIsInRhZyIsInMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLFlBQUFDLFlBQUFDLEtBQUFDLEtBQUFDLE9BQUFDO0FBQUFBLElDSUUsWUFBYztBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLE1ESmhCLDRCQUFBQyxNQUFBO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUEsS0NLZ0Msd0NBQW1CO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQVg7QUFBQUEsTURMbkQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjg5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9iaW5hcnlfc2VhcmNoLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuKCogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCBhIHNlYXJjaCBmb3IgdGhlIGZpcnN0IChyZXNwLiBsYXN0KSBlbGVtZW50XG4gICBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLCBhc3N1bWluZyB0aGF0IHRoZSBwcmVkaWNhdGUgaXMgaW5jcmVhc2luZyBvblxuICAgdGhlIGNvbnRhaW5lciwgbWVhbmluZyB0aGF0LCBpZiB0aGUgY29udGFpbmVyIGlzIFt1MS4uLnVuXSwgdGhlcmUgZXhpc3RzIGFcbiAgIGsgc3VjaCB0aGF0IHAodTEpPS4uLi49cCh1aykgPSBmYWxzZSBhbmQgcCh1aysxKT0uLi4uPXAodW4pPSB0cnVlLlxuICAgSWYgdGhpcyBrID0gMSAocmVzcCBuKSwgZmluZF9sYXN0X25vdF9zYXRpc2Z5aW5nIChyZXNwIGZpbmRfZmlyc3Rfc2F0aXNmeWluZylcbiAgIHdpbGwgcmV0dXJuIE5vbmUuICopXG5cbmxldCByZWMgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgaWYgbG8gPiBoaVxuICB0aGVuIE5vbmVcbiAgZWxzZSBpZiBwcmVkIChnZXQgdCBsbylcbiAgdGhlbiBTb21lIGxvXG4gIGVsc2UgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KGxvICsgMSkgfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhIGNvbnRhaW5lciBbdF0sIGEgcHJlZGljYXRlIFtwcmVkXSBhbmQgdHdvIGluZGljZXMgW2xvIDwgaGldLCBzdWNoIHRoYXRcbiAgIFtwcmVkXSBpcyBpbmNyZWFzaW5nIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uXG5cbiAgIHJldHVybiBhIHJhbmdlIChsbywgaGkpIHdoZXJlOlxuICAgLSBsbyBhbmQgaGkgYXJlIGNsb3NlIGVub3VnaCB0b2dldGhlciBmb3IgYSBsaW5lYXIgc2VhcmNoXG4gICAtIElmIFtwcmVkXSBpcyBub3QgY29uc3RhbnRseSBbZmFsc2VdIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0sIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgIG9uIHdoaWNoIFtwcmVkXSBpcyBbdHJ1ZV0gaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldLiAqKVxuKCogSW52YXJpYW50OiB0aGUgZmlyc3QgZWxlbWVudCBzYXRpc2Z5aW5nIFtwcmVkXSwgaWYgaXQgZXhpc3RzIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXSAqKVxubGV0IHJlYyBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gICgqIFdhcm5pbmc6IHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdGVybWluYXRlIGlmIHRoZSBjb25zdGFudCAoY3VycmVudGx5IDgpIGlzXG4gICAgIHNldCA8PSAxICopXG4gIGlmIGhpIC0gbG8gPD0gOFxuICB0aGVuIGxvLCBoaVxuICBlbHNlIChcbiAgICBsZXQgbWlkID0gbG8gKyAoKGhpIC0gbG8pIC8gMikgaW5cbiAgICBpZiBwcmVkIChnZXQgdCBtaWQpXG4gICAgICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50IGlzIGJldHdlZW4gW2xvXSBhbmQgW21pZF0gKilcbiAgICB0aGVuXG4gICAgICBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaTptaWQgfnByZWRcbiAgICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCwgaWYgaXQgZXhpc3RzLFxuICAgICAgICAgaXMgYmV0d2VlbiBbbWlkKzFdIGFuZCBbaGldICopXG4gICAgZWxzZSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihtaWQgKyAxKSB+aGkgfnByZWQpXG47O1xuXG5sZXQgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbG8gPSBwb3MgaW5cbiAgbGV0IGhpID0gcG9zICsgbGVuIC0gMSBpblxuICBsZXQgbG8sIGhpID0gZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgaW5cbiAgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhbiBhcnJheSB3aXRoIHNoYXBlIFt0cnVlLC4uLnRydWUsZmFsc2UsLi4uZmFsc2VdIChpLmUuLCB0aGUgX3JldmVyc2VfIG9mIHdoYXRcbiAgIGlzIGRlc2NyaWJlZCBhYm92ZSkgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHRydWUgb3IgTm9uZSBpZiB0aGVyZSBhcmUgbm9cbiAgIHRydWUqKVxubGV0IGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5wcmVkIH5nZXQgfmxlbmd0aCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICAoKiBUaGUgbGFzdCBzYXRpc2Z5aW5nIGlzIHRoZSBvbmUganVzdCBiZWZvcmUgdGhlIGZpcnN0IG5vdCBzYXRpc2Z5aW5nICopXG4gICAgbWF0Y2hcbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB+cG9zIH5sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IG5vdCAocHJlZCB4KSlcbiAgICB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgKHBvcyArIGxlbiAtIDEpXG4gICAgKCogVGhpcyBtZWFucyB0aGF0IGFsbCBlbGVtZW50cyBzYXRpc2Z5IHByZWQuXG4gICAgICAgVGhlcmUgaXMgYXQgbGVhc3QgYW4gZWxlbWVudCBhcyAobGVuID4gMCkgKilcbiAgICB8IFNvbWUgaSB3aGVuIGkgPSBwb3MgLT4gTm9uZSAoKiBubyBlbGVtZW50IHNhdGlzZmllcyBwcmVkICopXG4gICAgfCBTb21lIGkgLT4gU29tZSAoaSAtIDEpKVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2hcbiAgP3Bvc1xuICA/bGVuXG4gIHRcbiAgfihsZW5ndGggOiBfIC0+IF8pXG4gIH4oZ2V0IDogXyAtPiBfIC0+IF8pXG4gIH4oY29tcGFyZSA6IF8gLT4gXyAtPiBfKVxuICBob3dcbiAgdlxuICA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8IDApIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMCkgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMCkgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnNlZ21lbnRfb2YgaG93ID1cbiAgbGV0IGlzX2xlZnQgeCA9XG4gICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICB8IGBSaWdodCAtPiBmYWxzZVxuICBpblxuICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X29uX2xlZnQgLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfbGVmdCBbQG5vbnRhaWxdXG4gIHwgYEZpcnN0X29uX3JpZ2h0IC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19yaWdodCBbQG5vbnRhaWxdXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInBvcyIsImxlbiIsInQiLCJnZXQiLCJsZW5ndGgiLCJwcmVkIiwibWF0Y2giLCJoaSIsImxvIiwibWlkIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJ4IiwiaSIsImJpbmFyeV9zZWFyY2giLCJjb21wYXJlIiwiaG93IiwidiIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIiwic2VnbWVudF9vZiIsImlzX2xlZnQiLCJpc19yaWdodCIsIkJhc2VfQmluYXJ5X3NlYXJjaCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsc0JBQUFDLEtBQUFDLEtBQUFDLEdBQUFDLEtBQUFDLFFBQUFDO0FBQUFBO0FBQUFBLEtBQUEsSUM0Q3lFO0FBQUEsS0FBQUMsUUFBckU7QUFBQSxLQUFBTCxRQUErRTtBQUFBLEtBQUFELFFBQUE7QUFBQSxTQUd4RTtBQUFBLEtBQUFPLE9BQUE7QUFBQSxLQUFBQyxPQUNJO0FBQUEsS0FBQUQsS0FBQTtBQUFBO0FBQUEsS0FuQlYsa0RBQUFDLEtBQU87QUFBQTtBQUFBLFVBR1E7QUFBQSxVQUFEO0FBQUEsTUFBQUMsTUFBTDtBQUFBLEtBQ0YsR0FBTCxpQkFBSztBQUFBLE1BQVc7QUFBQSxjQUFBRCxPQU04QixvQ0FBUztBQUFBO0FBQUEsSUFTL0M7QUFBQSxLQXJDYixZQUNLO0FBQUEsS0FDUSxHQUFMLGlCQUFLLHlCQUNSO0FBQUEsU0FBQUEsT0FDMEM7QUFBQSxLQUFRO0FBQUE7QUFBQSxHQWtDSjtBQUFBLFlBQUFFLHFCQUFBVixLQUFBQyxLQUFBQyxHQUFBRyxNQUFBRixLQUFBQztBQUFBQTtBQUFBQSxLQUFBLElBUW9CO0FBQUEsS0FBQUUsUUFBckU7QUFBQSxLQUFBTCxRQUErRTtBQUFBLEtBQUFELFFBQUE7QUFBQSxJQUVqRixnQkFDSztBQUFBO0FBQUEsS0FBQU07QUFBQUEsT0FJRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFBQUssR0FBbUUsOEJBQVE7QUFBQSxJQUFDO0FBQUEsU0FBQUMsSUFBQTtBQUFBLEtBS2hFLDZCQUNHLGlDQUFRO0FBQUE7QUFBQSxZQUpUO0FBQUEsSUFBRCw0Q0FBZTtBQUFBLEdBSUw7QUFBQSxZQUFBQyxjQUFBYixLQUFBQyxLQUFBQyxHQUFBRSxRQUFBRCxLQUFBVyxTQUFBQyxLQUFBQztBQUFBQSxJQWEzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQW9CRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFBQUwsR0FBK0QsNkNBQVcsQ0FBSztBQUFBLGlCQWxCL0U7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFBQUEsR0FBOEQsNENBQVcsQ0FBSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBRzdFO0FBQUE7QUFBQTtBQUFBO0FBQUEsMkJBQUFBLEdBQThELDZDQUFXLENBQUs7QUFBQTtBQUFBO0FBQUEsaUJBa0I5RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFBQUEsR0FBK0QsNENBQVcsQ0FBSSxFQUNLO0FBQUEsSUF4QnJGO0FBQUE7QUFBQSxNQUFBTDtBQUFBQSxRQWVLO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQUFLLEdBQThELDZDQUFXLENBQUs7QUFBQTtBQUFBO0FBQUEsS0FBQztBQUFBLFVBQUFBLElBQUE7QUFBQSxNQUUzRCxTQUFSLG9CQUFRLDJCQUFtQjtBQUFBO0FBQUEsS0FDdEI7QUFBQTtBQUFBO0FBQUEsS0FBQUw7QUFBQUEsT0FUakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQUFLLEdBQStELDZDQUFXLENBQUs7QUFBQSxJQUFDO0FBQUEsU0FBQUEsTUFBQTtBQUFBLEtBRTVELFNBQVIsb0JBQVE7QUFBQSxNQUFtQjtBQUFBO0FBQUEsSUFDdEI7QUFBQSxHQVkrRDtBQUFBLFlBQUFNLHdCQUFBakIsS0FBQUMsS0FBQUMsR0FBQUUsUUFBQUQsS0FBQWUsWUFBQUg7QUFBQUEsYUFBQUksUUFBQVI7QUFBQUEsS0FLN0UscURBRVc7QUFBQTtBQUFBLGFBQUFTLFNBQUFULEdBRUUscUJBQVc7QUFBQSxJQUNoQztBQUFBLGNBRUU7QUFBQSxjQUVBLHlEQUF3RTtBQUFBO0FBQUEsT0FBQVUscUJEekg1RSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMDQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiYWxsIiwiV2hpY2hfdGFyZ2V0X2J5X2tleSIsIldoaWNoX3RhcmdldF9ieV9zZWdtZW50IiwiQmFzZV9CaW5hcnlfc2VhcmNoYWJsZV9pbnRmIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMDcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlX2ludGZcblxubW9kdWxlIHR5cGUgQXJnID0gc2lnXG4gIHR5cGUgJ2EgZWx0XG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBlbHRcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBBcmcpID0gc3RydWN0XG4gIGxldCBnZXQgPSBULmdldFxuICBsZXQgbGVuZ3RoID0gVC5sZW5ndGhcblxuICBsZXQgYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+Y29tcGFyZSBob3cgdlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIEJpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5zZWdtZW50X29mIGhvd1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogSW5kZXhhYmxlKSA9IE1ha2VfZ2VuIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgdHlwZSAnYSBlbHQgPSBULmVsdFxuICB0eXBlICdhIHQgPSBULnRcbmVuZClcblxubW9kdWxlIE1ha2UxIChUIDogSW5kZXhhYmxlMSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgdHlwZSAnYSB0ID0gJ2EgVC50XG5cbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuZW5kKVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiQmFzZV9CaW5hcnlfc2VhcmNoIiwiTWFrZV9nZW4iLCJUIiwiZ2V0IiwibGVuZ3RoIiwiYmluYXJ5X3NlYXJjaCIsInBvcyIsImxlbiIsInQiLCJjb21wYXJlIiwiaG93IiwidiIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIiwic2VnbWVudF9vZiIsIkJhc2VfQmluYXJ5X3NlYXJjaGFibGUiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLFFBQUFDLE1BQUEsTUFBQUMsU0FBQTtBQUFBLGFBQUFDLGNBQUFDLEtBQUFDLEtBQUFDLEdBQUFDLFNBQUFDLEtBQUFDO0FBQUFBLEtDZ0JJO0FBQUEsOERBQW1FO0FBQUE7QUFBQSxhQUFBQyx3QkFBQU4sS0FBQUMsS0FBQUMsR0FBQUssWUFBQUg7QUFBQUEsS0FJbkU7QUFBQSw4REFBOEU7QUFBQTtBQUFBLElEcEJsRjtBQUFBO0FBQUE7QUFBQSxJQUFBSTtBQUFBQSxNQUFBO0FBQUEsZ0JBQUFaO0FBQUFBLFlBQUFDLE1BQUEsTUFBQUMsU0FBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUY7QUFBQUEsWUFBQUMsTUFBQSxNQUFBQyxTQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTMxMDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0JsaXRfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGlCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTMxMjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYnl0ZXMwLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogW0J5dGVzMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbU3RkbGliLkJ5dGVzXS4gW0J5dGVzMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzXG4gICB0aGUgcGFydCBvZiBbU3RkbGliLkJ5dGVzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlclxuICAgdGhhbiBieXRlczAubWwgc2hvdWxkIHVzZSBbU3RkbGliLkJ5dGVzXS4gW0J5dGVzMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZFxuICAgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5CeXRlc10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEJ5dGVzICA9IEJ5dGVzMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBCeXRlcyA9IEJ5dGVzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5CeXRlc10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBVY2hhciA9IFVjaGFyMFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFByaW1pdGl2ZXMgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogKGJ5dGVzW0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiAoYnl0ZXNbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldFxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGNoYXJcbiAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuXG4gIGV4dGVybmFsIHNldFxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChjaGFyW0Bsb2NhbF9vcHRdKVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGNoYXJbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5cbiAgKCogW3Vuc2FmZV9ibGl0X3N0cmluZ10gaXMgbm90IGV4cG9ydGVkIGluIHRoZSBbc3RkbGliXSBzbyB3ZSBleHBvcnQgaXQgaGVyZSAqKVxuICBleHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICA6ICBzcmM6KHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgICAtPiBzcmNfcG9zOmludFxuICAgIC0+IGRzdDooYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50NjRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnQ2NFxuICAgID0gXCIlY2FtbF9ieXRlc19nZXQ2NHVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50NjRbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50MzJcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnQzMlxuICAgID0gXCIlY2FtbF9ieXRlc19nZXQzMnVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzJcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50MzJbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50MTZcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZ1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5lbmRcblxuaW5jbHVkZSBQcmltaXRpdmVzXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgYmxpdCA9IFN0ZGxpYi5CeXRlcy5ibGl0XG5sZXQgYmxpdF9zdHJpbmcgPSBTdGRsaWIuQnl0ZXMuYmxpdF9zdHJpbmdcbmxldCBjb21wYXJlID0gU3RkbGliLkJ5dGVzLmNvbXBhcmVcbmxldCBjb3B5ID0gU3RkbGliLkJ5dGVzLmNvcHlcbmxldCBjcmVhdGUgPSBTdGRsaWIuQnl0ZXMuY3JlYXRlXG5sZXQgc2V0X3VjaGFyX3V0Zl84ID0gU3RkbGliLkJ5dGVzLnNldF91dGZfOF91Y2hhclxubGV0IHNldF91Y2hhcl91dGZfMTZsZSA9IFN0ZGxpYi5CeXRlcy5zZXRfdXRmXzE2bGVfdWNoYXJcbmxldCBzZXRfdWNoYXJfdXRmXzE2YmUgPSBTdGRsaWIuQnl0ZXMuc2V0X3V0Zl8xNmJlX3VjaGFyXG5cbmxldCBzZXRfdXRmXzMyX3VjaGFyIH5zZXRfaW50MzIgYnl0ZXMgaWR4IHVjaGFyID1cbiAgVWNoYXIudG9faW50IHVjaGFyXG4gIHw+IEludF9jb252ZXJzaW9ucy5pbnRfdG9faW50MzJfdHJ1bmMgKCogc2hvdWxkIG5ldmVyIGhhdmUgYW55dGhpbmcgdG8gdHJ1bmNhdGUgKilcbiAgfD4gc2V0X2ludDMyIGJ5dGVzIGlkeDtcbiAgNFxuOztcblxubGV0IHNldF91Y2hhcl91dGZfMzJsZSA9IHNldF91dGZfMzJfdWNoYXIgfnNldF9pbnQzMjpTdGRsaWIuQnl0ZXMuc2V0X2ludDMyX2xlXG5sZXQgc2V0X3VjaGFyX3V0Zl8zMmJlID0gc2V0X3V0Zl8zMl91Y2hhciB+c2V0X2ludDMyOlN0ZGxpYi5CeXRlcy5zZXRfaW50MzJfYmVcblxuZXh0ZXJuYWwgdW5zYWZlX2NyZWF0ZV9sb2NhbCA6IGludCAtPiBieXRlcyA9IFwiQmFzZV91bnNhZmVfY3JlYXRlX2xvY2FsX2J5dGVzXCIgXG5cbmxldCBjcmVhdGVfbG9jYWwgbGVuID1cbiAgaWYgbGVuID4gU3lzMC5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuY3JlYXRlX2xvY2FsXCI7XG4gIHVuc2FmZV9jcmVhdGVfbG9jYWwgbGVuXG47O1xuXG5sZXQgZmlsbCA9IFN0ZGxpYi5CeXRlcy5maWxsXG5sZXQgbWFrZSA9IFN0ZGxpYi5CeXRlcy5tYWtlXG5cbmxldCBtYXAgdCB+KGYgOiBfIC0+IF8pID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBpZiBsID0gMFxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgdCBpKSlcbiAgICBkb25lO1xuICAgIHIpXG47O1xuXG5sZXQgbWFwaSB0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgaWYgbCA9IDBcbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgdCBpKSlcbiAgICBkb25lO1xuICAgIHIpXG47O1xuXG5sZXQgc3ViID0gU3RkbGliLkJ5dGVzLnN1YlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdFxuICA6ICBzcmM6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAtPiBzcmNfcG9zOmludFxuICAtPiBkc3Q6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAtPiBkc3RfcG9zOmludFxuICAtPiBsZW46aW50XG4gIC0+IHVuaXRcbiAgPSBcImNhbWxfYmxpdF9ieXRlc1wiXG4gIFtAQG5vYWxsb2NdXG5cbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuQnl0ZXMudG9fc3RyaW5nXG5sZXQgb2Zfc3RyaW5nID0gU3RkbGliLkJ5dGVzLm9mX3N0cmluZ1xuXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nXG4gIDogIG5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAtPiAoc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmdfcHJvbWlzZV9ub19tdXRhdGlvblxuICA6ICAoc3RyaW5nW0Bsb2NhbF9vcHRdKVxuICAtPiAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0MCIsIkJhc2VfU3lzMCIsIkJhc2VfVWNoYXIwIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJTdGRsaWJfQnl0ZXNMYWJlbHMiLCJQcmltaXRpdmVzIiwibWF4X2xlbmd0aCIsImJsaXQiLCJibGl0X3N0cmluZyIsImNvbXBhcmUiLCJjb3B5IiwiY3JlYXRlIiwic2V0X3VjaGFyX3V0Zl84Iiwic2V0X3VjaGFyX3V0Zl8xNmxlIiwic2V0X3VjaGFyX3V0Zl8xNmJlIiwic2V0X3V0Zl8zMl91Y2hhciIsInNldF9pbnQzMiIsImJ5dGVzIiwiaWR4IiwidWNoYXIiLCJzZXRfdWNoYXJfdXRmXzMybGUiLCJjc3RfQnl0ZXNfY3JlYXRlX2xvY2FsIiwic2V0X3VjaGFyX3V0Zl8zMmJlIiwiY3JlYXRlX2xvY2FsIiwibGVuIiwiZmlsbCIsIm1ha2UiLCJtYXAiLCJ0IiwibCIsInIiLCJpIiwibWFwaSIsInN1YiIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIkJhc2VfQnl0ZXMwIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLFlBQUFDLGlCQUFBQyxXQUFBQyxPQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBLElDNEdFO0FBQUE7QUFBQSxJQUFBLFdBRUc7QUFBQSxJQUFtQjtBQUFBLEdBQ3JCO0FBQUEsV0FHc0I7QUFBQSxZQUFBQyxtQkFBQTtBQUFBO0FBQUEsUUFDcUQ7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLFlBQUFDLG1CQUFBLFNBQXJEO0FBQUEsWUFBQUMsYUFBQUM7QUFBQUEsSUFLdkI7QUFBQSxLQUFxQztBQUFBLElBQ3JDLGtEQUF1QjtBQUFBO0FBQUEsT0FBQUMsT0FOcUQsd0JBQUFDLE9BQUE7QUFBQSxZQUFBQyxJQUFBQyxHQUFBakM7QUFBQUEsUUFBQWtDLElBYTVFO0FBQUEsSUFDQSxZQUNLO0FBQUE7QUFBQSxLQUFBQyxJQUVLO0FBQUEsU0FDSztBQUFBLFNBQUs7QUFBQTtBQUFBLFNBQUFDLElBQUE7QUFBQTtBQUFBLE1BQ21CLDRCQUFwQixjQUFmO0FBQUEsY0FBbUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXJDO0FBQUEsR0FBRTtBQUFBLFlBQUFDLEtBQUFKLEdBQUFqQztBQUFBQSxRQUFBa0MsSUFJSjtBQUFBLElBQ0EsWUFDSztBQUFBO0FBQUEsS0FBQUMsSUFFSztBQUFBLFNBQ0s7QUFBQSxTQUFLO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQSxNQUNxQjtBQUFBLGNBQXRCLGlCQUFmO0FBQUEsY0FBcUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBRXZDO0FBQUEsR0FBRTtBQUFBO0FBQUEsSUFBQUUsTUFqQ3dFO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEbkg5RSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjEzMjQ5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2JsaXQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlblxuICAoU3JjIDogU2VxdWVuY2VfZ2VuKSAoRHN0IDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgU3JjLnQgLT4gJ2EgdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSBTcmMudCwgJ2EgdCkgYmxpdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgdW5zYWZlX2JsaXQgPSBEc3QudW5zYWZlX2JsaXRcblxuICBsZXQgYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpzcmNfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpkc3RfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihEc3QubGVuZ3RoIGRzdCk7XG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuXG4gIDs7XG5cbiAgbGV0IGJsaXRvXG4gICAgfnNyY1xuICAgID8oc3JjX3BvcyA9IDApXG4gICAgPyhzcmNfbGVuID0gU3JjLmxlbmd0aCBzcmMgLSBzcmNfcG9zKVxuICAgIH5kc3RcbiAgICA/KGRzdF9wb3MgPSAwKVxuICAgICgpXG4gICAgPVxuICAgIGJsaXQgfnNyYyB+c3JjX3BvcyB+bGVuOnNyY19sZW4gfmRzdCB+ZHN0X3Bvc1xuICA7O1xuXG4gICgqIFtzdWJdIGFuZCBbc3Vib10gZW5zdXJlIHRoYXQgZXZlcnkgcG9zaXRpb24gb2YgdGhlIGNyZWF0ZWQgc2VxdWVuY2UgaXMgcG9wdWxhdGVkIGJ5XG4gICAgIGFuIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBhcnJheS4gIFRodXMgZXZlcnkgZWxlbWVudCBvZiBbZHN0XSBiZWxvdyBpcyB3ZWxsXG4gICAgIGRlZmluZWQuICopXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIGxldCBkc3QgPSBEc3QuY3JlYXRlX2xpa2UgfmxlbiBzcmMgaW5cbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgZHN0XG4gIDs7XG5cbiAgbGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gICAgc3ViXG4gICAgICBzcmNcbiAgICAgIH5wb3NcbiAgICAgIH5sZW46XG4gICAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgICAgfCBOb25lIC0+IFNyYy5sZW5ndGggc3JjIC0gcG9zKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoU2VxdWVuY2UgOiBzaWdcbiAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgYmxpdFxuZW5kKSA9XG4gIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZTFfZ2VuZXJpYyAoU2VxdWVuY2UgOiBTZXF1ZW5jZTEpID0gTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlIChTZXF1ZW5jZSA6IHNpZ1xuICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICB2YWwgdW5zYWZlX2JsaXQgOiAodCwgdCkgYmxpdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFNlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gU2VxdWVuY2UudFxuXG4gICAgb3BlbiBTZXF1ZW5jZVxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5lbmRcblxubW9kdWxlIE1ha2VfZGlzdGluY3RcbiAgKFNyYyA6IFNlcXVlbmNlKSAoRHN0IDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6IChTcmMudCwgdCkgYmxpdFxuICBlbmQpID1cbiAgTWFrZV9nZW5cbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBTcmMudFxuXG4gICAgICBvcGVuIFNyY1xuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IERzdC50XG5cbiAgICAgIG9wZW4gRHN0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgICBlbmQpXG5cbm1vZHVsZSBNYWtlX3RvX3N0cmluZyAoVCA6IHNpZ1xuICB0eXBlIHRcbmVuZClcbihUb19ieXRlcyA6IFNfZGlzdGluY3Qgd2l0aCB0eXBlIHNyYyA6PSBULnQgd2l0aCB0eXBlIGRzdCA6PSBieXRlcykgPVxuc3RydWN0XG4gIG9wZW4gVG9fYnl0ZXNcblxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWIgc3JjIH5wb3MgfmxlbilcbiAgOztcblxuICBsZXQgc3VibyA/cG9zID9sZW4gc3JjID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3VibyA/cG9zID9sZW4gc3JjKVxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiIsIk1ha2VfZ2VuIiwiU3JjIiwiRHN0IiwidW5zYWZlX2JsaXQiLCJibGl0Iiwic3JjIiwic3JjX3BvcyIsImRzdCIsImRzdF9wb3MiLCJsZW4iLCJibGl0byIsIm9wdCIsInBhcmFtIiwic3JjX2xlbiIsInN1YiIsInBvcyIsInN1Ym8iLCJpIiwiTWFrZV90b19zdHJpbmciLCJUIiwiVG9fYnl0ZXMiLCJCYXNlX0JsaXQiLCJTZXF1ZW5jZSIsImNyZWF0ZV9saWtlIiwibGVuZ3RoIiwiaW5jbHVkZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFNBQUFDLEtBQUFDO0FBQUFBLFFBQUFDLGNBQUE7QUFBQSxhQUFBQyxLQUFBQyxLQUFBQyxTQUFBQyxLQUFBQyxTQUFBQztBQUFBQSxTQUFBLElDdUJvQjtBQUFBLEtBSGhCO0FBQUEsYUFPZ0I7QUFBQSxLQUhoQjtBQUFBLGFBR2dDO0FBQUEsZ0JBQ2hCLDREQUE0QztBQUFBO0FBQUEsYUFBQUMsTUFBQUwsS0FBQSxNQUFBRSxLQUFBSSxLQUFBQztBQUFBQSxTQUFBTixVQUk1RDtBQUFBO0FBQUEsVUFBQU8sVUFBQTtBQUFBO0FBQUE7QUFBQSxXQUVZO0FBQUEsT0FBQUEsVUFBQTtBQUFBLFNBQUFMLFVBRlo7QUFBQSxLQU9BLGdEQUE2QztBQUFBO0FBQUEsYUFBQU0sSUFBQVQsS0FBQVUsS0FBQU47QUFBQUEsU0FBQSxJQU91QjtBQUFBLEtBQXBFO0FBQUEsU0FBQUYsTUFDVTtBQUFBLEtBQ1YsWUFBZ0I7QUFBQSxLQUNoQjtBQUFBLElBQUc7QUFBQSxhQUFBUyxLQUFBTCxLQUFBRixLQUFBSjtBQUFBQSxTQUFBVSxNQUdJO0FBQUEsS0FDUDtBQUFBLFVBQUFFLElBQUEsUUFBQUEsTUFLaUI7QUFBQTtBQUFBO0FBQUEsV0FDRjtBQUFBLE9BQUFBLE1BQUE7QUFBQSxLQU5mLHlCQU1vQztBQUFBO0FBQUEsSUQzRHhDO0FBQUE7QUFBQSxZQUFBQyxlQUFBQyxHQUFBQztBQUFBQSxhQUFBTixJQUFBVCxLQUFBVSxLQUFBTjtBQUFBQSxLQzhIZ0UsT0FBbUIscUJBQW5CLHVDQUFtQjtBQUFBO0FBQUEsYUFBQU8sS0FBQUQsS0FBQU4sS0FBQUo7QUFBQUEsS0FJbkIsT0FBb0IscUJBQXBCLHVDQUFvQjtBQUFBO0FBQUEsSURsSXBGO0FBQUE7QUFBQTtBQUFBLElBQUFnQjtBQUFBQSxNQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLGlCQUFBQyxZQUFBZCxLQUFBRyxPQ3FGNkIsbUNBQVc7QUFBQTtBQUFBLFNBQUFZLFNEckZ4QztBQUFBLFNBQUFyQixjQUFBO0FBQUEsU0FBQXNCO0FBQUFBLFdBQUE7QUFBQSxTQUFBdEIsZ0JBQUE7QUFBQSxTQUFBQyxPQUFBO0FBQUEsU0FBQU0sUUFBQTtBQUFBLFNBQUFJLE1BQUE7QUFBQSxTQUFBRSxPQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBZixLQUFBQztBQUFBQSxZQUFBc0IsU0FBQTtBQUFBLGlCQUFBRCxZQUFBZCxLQUFBRyxPQ2tIK0IsOEJBQVc7QUFBQTtBQUFBLFNBQUFULGNEbEgxQztBQUFBLFNBQUFxQixXQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTMzNzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYm9vbC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCb29sMFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBib29sXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfYm9vbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBmYWxzZTsgdHJ1ZSBdIDogdCBsaXN0KVxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX2Jvb2wgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9ib29sXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9ib29sIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChib29sX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2Jvb2wgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYm9vbF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICAgIHwgcyAtPiBpbnZhbGlkX2FyZ2YgXCJCb29sLm9mX3N0cmluZzogZXhwZWN0ZWQgdHJ1ZSBvciBmYWxzZSBidXQgZ290ICVzXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Jvb2xcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Cb29sXCJcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCB0b19pbnQgeCA9IGJvb2xfdG9faW50IHhcblxubW9kdWxlIE5vbl9zaG9ydF9jaXJjdWl0aW5nID0gc3RydWN0XG4gICgqIFdlIGRvbid0IGV4cG9zZSB0aGlzLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBpbnZhcmlhbnQgbWVudGlvbmVkIGJlbG93IG9mXG4gICAgICh0b19pbnQgdHJ1ZSA9IDEpIGFuZCAodG9faW50IGZhbHNlID0gMCkuICopXG4gIGxldCB1bnNhZmVfb2ZfaW50ICh4IDogaW50KSA6IGJvb2wgPSBTdGRsaWIuT2JqLm1hZ2ljIHhcbiAgbGV0ICggfHwgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsb3IgdG9faW50IGIpXG4gIGxldCAoICYmICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbGFuZCB0b19pbnQgYilcbmVuZFxuXG4oKiBXZSBkbyB0aGlzIGFzIGEgZGlyZWN0IGFzc2VydCBvbiB0aGUgdGhlb3J5IHRoYXQgaXQncyBhIGNoZWFwIHRoaW5nIHRvIHRlc3QgYW5kIGFcbiAgIHJlYWxseSBjb3JlIGludmFyaWFudCB0aGF0IHdlIG5ldmVyIGV4cGVjdCB0byBicmVhaywgYW5kIHdlIHNob3VsZCBiZSBoYXBweSBmb3IgYVxuICAgcHJvZ3JhbSB0byBmYWlsIGltbWVkaWF0ZWx5IGlmIHRoaXMgaXMgdmlvbGF0ZWQuICopXG5sZXQgKCkgPSBhc3NlcnQgKFBvbHkuKCA9ICkgKHRvX2ludCB0cnVlKSAxICYmIFBvbHkuKCA9ICkgKHRvX2ludCBmYWxzZSkgMClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfYm9vbF9tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImFsbCIsIm1vZHVsZV9uYW1lIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX1ByaW50ZiIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJpbnZhbGlkX2FyZ2YiLCJjb21wYXJlIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImhhc2hhYmxlIiwib2Zfc3RyaW5nIiwicyIsInRvX3N0cmluZyIsImluY2x1ZGUiLCJjb21wYXJhdG9yIiwicHAiLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiaW52YXJpYW50IiwicGFyYW0iLCJiZXR3ZWVuIiwidCIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJtaW4iLCJtYXgiLCJjbGFtcF9leG4iLCJjbGFtcCIsInRvX2ludCIsInN5bWJvbCIsImEiLCJiIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbCIsImVxdWFsX2xvY2FsIiwiQmFzZV9Cb29sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLEtBQUFDLEdDa0JhLDBCQUFNO0FBQUE7QUFBQSxJQUFBQyxZQUFmO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFXYztBQUFBLDZCQUdQO0FBQUEsZUFBcUU7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFkNUU7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFELFlBQUE7QUFBQSxJQUFBRSxLQUFBO0FBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsWUFBQUMsVUFBQUMsT0FtQ29CLFNBQUU7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxRQUFBLElBQ0M7QUFBQSxJQUFRLHNEQUFhO0FBQUE7QUFBQSxZQUFBQyxnQkFBQUgsR0FBQUksS0FBQUM7QUFBQUEsSUFDWDtBQUFBO0FBQUEsY0FBeUIsZ0RBQXdCO0FBQUE7QUFBQSxZQUFBQyxVQUFBTixHQUFBSSxLQUFBQztBQUFBQSxJQUc3RTtBQUFBLEtBQ1AsbUNBQTJCO0FBQUEsSUFEUjtBQUFBLEdBQ1E7QUFBQSxZQUFBRSxNQUFBUCxHQUFBSSxLQUFBQztBQUFBQSxJQUl4QjtBQUFBLEtBTUssd0NBQTZCO0FBQUE7QUFBQSxTQURHO0FBQUEsU0FBeEI7QUFBQSxTQUZaO0FBQUEsSUFFc0Qsc0NBQ3JCO0FBQUE7QUFBQSxZQUFBRyxPQUFBekIsR0FHeEIsb0NBQWE7QUFBQSxZQUFBMEIsT0FBQUMsR0FBQUM7QUFBQUEsUUFBQSxJQU1tQixlQUFiLFdBQUE1QixJQUFEO0FBQUEsSUFETTtBQUFBLEdBQ2lCO0FBQUEsWUFBQTBCLFNBQUFDLEdBQUFDO0FBQUFBLFFBQUEsSUFDUixlQUFkLFdBQUE1QixJQUFEO0FBQUEsSUFGTTtBQUFBLEdBRWtCO0FBQUEsV0FNN0I7QUFBQSwrQkFBOEI7QUFBQTtBQUFBLEtBQUFRLFlBQWM7QUFBQSxLQUFBa0IsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUEsV0FBQTtBQUFBLEtBQUFBLFdBQUE7QUFBQSxLQUFBQSxXQUFBO0FBQUEsS0FBQUcsWUFBQTtBQUFBLEtBQUFDLGFBQUE7QUFBQSxLQUFBbkMsWUFBQTtBQUFBLEtBQUFvQyxnQkFBQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxjQUFBO0FBQUEsS0FBQVgsTUFBQTtBQUFBLEtBQUFELE1BQUE7QUFBQSxLQUFBYTtBQUFBQSxPQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQS9CO0FBQUEsRURyRnpDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTM1MjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0VpdGhlcl9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsbUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMzUzNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9laXRoZXIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgRWl0aGVyX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgRWl0aGVyMFxuXG5sZXQgc3dhcCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBTZWNvbmQgeFxuICB8IFNlY29uZCB4IC0+IEZpcnN0IHhcbjs7XG5cbmxldCBpc19maXJzdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiB0cnVlXG4gIHwgU2Vjb25kIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19zZWNvbmQgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gZmFsc2VcbiAgfCBTZWNvbmQgXyAtPiB0cnVlXG47O1xuXG5sZXQgdmFsdWUgKEZpcnN0IHggfCBTZWNvbmQgeCkgPSB4XG5cbmxldCB2YWx1ZV9tYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gZmlyc3QgeFxuICB8IFNlY29uZCB4IC0+IHNlY29uZCB4XG47O1xuXG5sZXQgaXRlciA9IHZhbHVlX21hcFxuXG5sZXQgbWFwIHQgfmZpcnN0IH5zZWNvbmQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBGaXJzdCB4IC0+IEZpcnN0IChmaXJzdCB4KVxuICB8IFNlY29uZCB4IC0+IFNlY29uZCAoc2Vjb25kIHgpXG47O1xuXG5sZXQgZmlyc3QgeCA9IEZpcnN0IHhcbmxldCBzZWNvbmQgeCA9IFNlY29uZCB4XG5cbmxldCBlcXVhbCBlcTEgZXEyIHQxIHQyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IGVxMSB4IHlcbiAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gZXEyIHggeVxuICB8IEZpcnN0IF8sIFNlY29uZCBfIHwgU2Vjb25kIF8sIEZpcnN0IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBsb2NhbF9lcXVhbCBlcTEgZXEyIHQxIHQyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IGVxMSB4IHlcbiAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gZXEyIHggeVxuICB8IEZpcnN0IF8sIFNlY29uZCBfIHwgU2Vjb25kIF8sIEZpcnN0IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpbnZhcmlhbnQgZiBzID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IGYgeFxuICB8IFNlY29uZCB5IC0+IHMgeVxuOztcblxubW9kdWxlIEZvY3VzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBGb2N1cyBvZiB7IHZhbHVlIDogJ2EgfVxuICAgIHwgT3RoZXIgb2YgeyB2YWx1ZSA6ICdiIH1cbmVuZFxuXG5tb2R1bGUgTWFrZV9mb2N1c2VkIChNIDogc2lnXG4gIHR5cGUgKCsnYSwgKydiKSB0XG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICB2YWwgb3RoZXIgOiAnYiAtPiAoXywgJ2IpIHRcbiAgdmFsIGZvY3VzIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBGb2N1cy50XG5cbiAgdmFsIGNvbWJpbmVcbiAgICA6ICAoJ2EsICdkKSB0XG4gICAgLT4gKCdiLCAnZCkgdFxuICAgIC0+IGY6KCdhIC0+ICdiIC0+ICdjKVxuICAgIC0+IG90aGVyOignZCAtPiAnZCAtPiAnZClcbiAgICAtPiAoJ2MsICdkKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIC0+ICgnYywgJ2IpIHQpIC0+ICgnYywgJ2IpIHRcbmVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuICBvcGVuIFdpdGhfcmV0dXJuXG5cbiAgbGV0IG1hcCB0IH5mID1cbiAgICBsZXQgcmVzID0gYmluZCB0IH5mOihmdW4geCAtPiByZXR1cm4gKGYgeCkpIGluXG4gICAgcmVzXG4gIDs7XG5cbiAgaW5jbHVkZSBNb25hZC5NYWtlMl9sb2NhbCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG4gIG1vZHVsZSBBcHAgPSBBcHBsaWNhdGl2ZS5NYWtlMl91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gICAgbGV0IG1hcDIgOiAoJ2EsICd4KSB0IC0+ICgnYiwgJ3gpIHQgLT4gZjooJ2EgLT4gJ2IgLT4gJ2MpIC0+ICgnYywgJ3gpIHQgPVxuICAgICAgZnVuIHQxIHQyIH5mIC0+XG4gICAgICBiaW5kIHQxIH5mOihmdW4geCAtPiBiaW5kIHQyIH5mOihmdW4geSAtPiByZXR1cm4gKGYgeCB5KSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICAgIDs7XG4gIGVuZClcblxuICBpbmNsdWRlIEFwcFxuXG4gIGxldCBjb21iaW5lX2FsbCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgKG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgICAgICAgfCBGb2N1cyBfIC0+IG90aGVyX2xvb3AgZiBhY2MgdHNcbiAgICAgICAgIHwgT3RoZXIgbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8udmFsdWUpIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIChtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICAgICAgIHwgRm9jdXMgeCAtPiByZXR1cm5fbG9vcCBmICh4LnZhbHVlIDo6IGFjYykgdHNcbiAgICAgICAgIHwgT3RoZXIgbyAtPiBvdGhlcl9sb29wIGYgby52YWx1ZSB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIFtdIHRzXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfYWxsX3VuaXQgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIChtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICAgICAgIHwgRm9jdXMgXyAtPiBvdGhlcl9sb29wIGYgYWNjIHRzXG4gICAgICAgICB8IE90aGVyIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvLnZhbHVlKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIChtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICAgICAgIHwgRm9jdXMgeyB2YWx1ZSA9ICgpIH0gLT4gcmV0dXJuX2xvb3AgZiB0c1xuICAgICAgICAgfCBPdGhlciB7IHZhbHVlID0gbyB9IC0+IG90aGVyX2xvb3AgZiBvIHRzKVxuICAgIGluXG4gICAgZnVuIHRzIH5mIC0+IHJldHVybl9sb29wIGYgdHNcbiAgOztcblxuICBsZXQgdG9fb3B0aW9uIHQgPVxuICAgIG1hdGNoIGZvY3VzIHQgd2l0aFxuICAgIHwgRm9jdXMgeCAtPiBTb21lIHgudmFsdWVcbiAgICB8IE90aGVyIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICB8IEZvY3VzIHggLT4geC52YWx1ZVxuICAgIHwgT3RoZXIgXyAtPiBkZWZhdWx0XG4gIDs7XG5cbiAgbGV0IHdpdGhfcmV0dXJuIGYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gcmV0IC0+IG90aGVyIChmIChXaXRoX3JldHVybi5wcmVwZW5kIHJldCB+ZjpyZXR1cm4pKSkgW0Bub250YWlsXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGaXJzdCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgbGV0IHJldHVybiA9IGZpcnN0XG4gIGxldCBvdGhlciA9IHNlY29uZFxuXG4gIGxldCBmb2N1cyB0IDogXyBGb2N1cy50ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEZpcnN0IHggLT4gRm9jdXMgeyB2YWx1ZSA9IHggfVxuICAgIHwgU2Vjb25kIHkgLT4gT3RoZXIgeyB2YWx1ZSA9IHkgfVxuICA7O1xuXG4gIGxldCBjb21iaW5lIHQxIHQyIH5mIH5vdGhlciA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKGYgeCB5KVxuICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAob3RoZXIgeCB5KVxuICAgIHwgU2Vjb25kIHgsIF8gfCBfLCBTZWNvbmQgeCAtPiBTZWNvbmQgeFxuICA7O1xuXG4gIGxldCBiaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRmlyc3QgeCAtPiBmIHhcbiAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbi4gKilcbiAgICB8IFNlY29uZCBfIGFzIHkgLT4geVxuICA7O1xuZW5kKVxuXG5tb2R1bGUgU2Vjb25kID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICBsZXQgcmV0dXJuID0gc2Vjb25kXG4gIGxldCBvdGhlciA9IGZpcnN0XG5cbiAgbGV0IGZvY3VzIHQgOiBfIEZvY3VzLnQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgU2Vjb25kIHggLT4gRm9jdXMgeyB2YWx1ZSA9IHggfVxuICAgIHwgRmlyc3QgeSAtPiBPdGhlciB7IHZhbHVlID0geSB9XG4gIDs7XG5cbiAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IFNlY29uZCAoZiB4IHkpXG4gICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChvdGhlciB4IHkpXG4gICAgfCBGaXJzdCB4LCBfIHwgXywgRmlyc3QgeCAtPiBGaXJzdCB4XG4gIDs7XG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZWNvbmQgeCAtPiBmIHhcbiAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbiwgbGlrZSBbRmlyc3QuYmluZF0gYWJvdmUuICopXG4gICAgfCBGaXJzdCBfIGFzIHkgLT4geVxuICA7O1xuZW5kKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdmLCAncykgX2VpdGhlciA9ICgnZiwgJ3MpIHQgPVxuICAgIHwgRmlyc3Qgb2YgJ2ZcbiAgICB8IFNlY29uZCBvZiAnc1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiQmFzZV9XaXRoX3JldHVybiIsIkJhc2VfTGlzdDAiLCJCYXNlX01vbmFkIiwiQmFzZV9BcHBsaWNhdGl2ZSIsIkJhc2VfRWl0aGVyMCIsImNvbXBhcmVfbG9jYWwiLCJjb21wYXJlIiwiaGFzaF9mb2xkX3QiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsInN3YXAiLCJwYXJhbSIsIngiLCJpc19maXJzdCIsImlzX3NlY29uZCIsInZhbHVlIiwidmFsdWVfbWFwIiwidCIsImZpcnN0Iiwic2Vjb25kIiwibWFwIiwiZXF1YWwiLCJlcTEiLCJlcTIiLCJ0MSIsInQyIiwieSIsImxvY2FsX2VxdWFsIiwiaW52YXJpYW50IiwicyIsIk1ha2VfZm9jdXNlZCIsIk0iLCJyZXR1cm4kIiwib3RoZXIiLCJmb2N1cyIsImNvbWJpbmUiLCJiaW5kIiwicmVzIiwiaW5jbHVkZSIsInN5bWJvbF9iaW5kIiwiTGV0X3N5bnRheCIsIk1vbmFkX2luZml4Iiwiam9pbiIsImlnbm9yZV9tIiwibWFwMiIsIkFwcCIsImJvdGgiLCJzeW1ib2wiLCJzeW1ib2xfbWFwIiwiYXBwbHkiLCJtYXAzIiwiYWxsIiwiYWxsX3VuaXQiLCJBcHBsaWNhdGl2ZV9pbmZpeCIsImNvbWJpbmVfYWxsIiwidHMiLCJhY2MiLCJtYXRjaCIsImNvbWJpbmVfYWxsX3VuaXQiLCJ0b19vcHRpb24iLCJkZWZhdWx0JCIsIndpdGhfcmV0dXJuIiwicmV0IiwiRmlyc3QiLCJTZWNvbmQiLCJFeHBvcnQiLCJCYXNlX0VpdGhlciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxLQUFBQztBQUFBQSxJQ0tXLHVCQUFBQyxJQUFBLFVBQ0k7QUFBQSxRQUFBQSxNQURKO0FBQUEsSUFFSztBQUFBLEdBQU87QUFBQSxZQUFBQyxTQUFBRixPQUdSLDZCQUVNO0FBQUEsWUFBQUcsVUFBQUgsT0FHTCw2QkFFSTtBQUFBLFlBQUFJLE1BQUFK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QztBQUFBQSxJQUlqQztBQUFBLFNBQUFyQixJQUFBO0FBQUEseUJBQUFjLElBQUEsT0FDNEIsK0JBQU87QUFBQSxTQUFBZCxNQURuQztBQUFBO0FBQUE7QUFBQSxTQUFBQSxNQUFBO0FBQUE7QUFBQSxVQUFBYyxNQUFBO0FBQUEsTUFFK0IsdUNBQVc7QUFBQTtBQUFBLFNBQUFkLE1BRjFDO0FBQUE7QUFBQSxJQUcrQjtBQUFBLEdBQVE7QUFBQSxZQUFBd0IsS0FBQW5CLEdBQUF4QjtBQUFBQSxJQUl2QyxlQUdtQjtBQUFBLFFBQUFtQixJQUhuQjtBQUFBLElBQ2EsdUJBRU87QUFBQTtBQUFBLE9BQUFtRCxRRDNMeEI7QUFBQSxZQUFBN0IsUUFBQWpCO0FBQUFBLElDc01JLG1CQUFBUyxJQUFBLE1BRWE7QUFBQSxRQUFBZCxJQUZiO0FBQUEsSUFDYztBQUFBLEdBQ2tCO0FBQUEsWUFBQXVCLFVBQUFYLElBQUFDLElBQUFoQyxHQUFBd0M7QUFBQUEsSUFJaEM7QUFBQSxTQUFBckIsSUFBQTtBQUFBLHlCQUFBYyxJQUFBLE9BRTRCLG1DQUFXO0FBQUEsU0FBQWQsTUFGdkM7QUFBQTtBQUFBO0FBQUEsU0FBQUEsTUFBQTtBQUFBLHlCQUFBYyxNQUFBLE9BQytCLG1DQUFPO0FBQUEsU0FBQWQsTUFEdEM7QUFBQTtBQUFBLElBRzZCO0FBQUEsR0FBTztBQUFBLFlBQUF3QixPQUFBbkIsR0FBQXhCO0FBQUFBLElBSXBDLGVBR2tCO0FBQUEsUUFBQW1CLElBSGxCO0FBQUEsSUFDYyx1QkFFSztBQUFBO0FBQUE7QUFBQSxJQUFBb0QsU0R0TnZCO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMzg5MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9vcHRpb24ubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG4gIHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgICBjb21wYXJlX29wdGlvbl9fbG9jYWxcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfb3B0aW9uXG5cbiAgICBsZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgICAgIGZ1biAodHlwZSBhX18wMDlfKSA6ICgoYV9fMDA5XyAtPiBhX18wMDlfKSAtPiBhX18wMDlfIHQgLT4gYV9fMDA5XyB0KSAtPlxuICAgICAgZ2xvYmFsaXplX29wdGlvblxuICAgIDs7XG5cbiAgICBsZXQgaGFzaF9mb2xkX3QgOlxuICAgICAgICAgICdhLlxuICAgICAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgICAgIC0+ICdhIHRcbiAgICAgICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgID1cbiAgICAgIGhhc2hfZm9sZF9vcHRpb25cbiAgICA7O1xuXG4gICAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gICAgICBvcHRpb25fb2Zfc2V4cFxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICAgIHNleHBfb2Zfb3B0aW9uXG4gICAgOztcblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IG9wdGlvbl9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuICBlbmQgOlxuICAgIHNpZ1xuICAgICAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG4gICAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuU19sb2NhbDEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgZ2xvYmFsaXplIDogKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHRcblxuICAgICAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgICAgW0BAQGVuZF1cbiAgICBlbmQpXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9XG4gIHwgTm9uZVxuICB8IFNvbWUgb2YgJ2FcblxubGV0IGlzX25vbmUgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19zb21lID0gZnVuY3Rpb25cbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCB2YWx1ZV9tYXAgbyB+ZGVmYXVsdCB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiBmIHhcbiAgfCBOb25lIC0+IGRlZmF1bHRcbjs7XG5cbmxldCBpdGVyIG8gfmYgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGludmFyaWFudCBmIHQgPSBpdGVyIHQgfmZcblxubGV0IGNhbGwgeCB+ZiA9XG4gIG1hdGNoIGYgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGYgLT4gZiB4XG47O1xuXG5sZXQgdmFsdWUgdCB+ZGVmYXVsdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuICB8IFNvbWUgeCAtPiB4XG47O1xuXG5sZXQgdmFsdWVfZXhuID9oZXJlID9lcnJvciA/bWVzc2FnZSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU29tZSB4IC0+IHhcbiAgfCBOb25lIC0+XG4gICAgbGV0IGVycm9yID1cbiAgICAgIG1hdGNoIGhlcmUsIGVycm9yLCBtZXNzYWdlIHdpdGhcbiAgICAgIHwgTm9uZSwgTm9uZSwgTm9uZSAtPiBFcnJvci5vZl9zdHJpbmcgXCJPcHRpb24udmFsdWVfZXhuIE5vbmVcIlxuICAgICAgfCBOb25lLCBOb25lLCBTb21lIG0gLT4gRXJyb3Iub2Zfc3RyaW5nIG1cbiAgICAgIHwgTm9uZSwgU29tZSBlLCBOb25lIC0+IGVcbiAgICAgIHwgTm9uZSwgU29tZSBlLCBTb21lIG0gLT4gRXJyb3IudGFnIGUgfnRhZzptXG4gICAgICB8IFNvbWUgcCwgTm9uZSwgTm9uZSAtPlxuICAgICAgICBFcnJvci5jcmVhdGUgXCJPcHRpb24udmFsdWVfZXhuXCIgcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgTm9uZSwgU29tZSBtIC0+IEVycm9yLmNyZWF0ZSBtIHAgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdFxuICAgICAgfCBTb21lIHAsIFNvbWUgZSwgXyAtPlxuICAgICAgICBFcnJvci5jcmVhdGVcbiAgICAgICAgICAodmFsdWUgbWVzc2FnZSB+ZGVmYXVsdDpcIlwiKVxuICAgICAgICAgIChlLCBwKVxuICAgICAgICAgIChzZXhwX29mX3BhaXIgRXJyb3Iuc2V4cF9vZl90IFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QpXG4gICAgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IHZhbHVlX29yX3RodW5rIG8gfmRlZmF1bHQgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT4gZGVmYXVsdCAoKVxuOztcblxubGV0IHRvX2FycmF5IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IFt8fF1cbiAgfCBTb21lIHggLT4gW3wgeCB8XVxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIHggLT4gWyB4IF1cbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgYScgLT4gZXF1YWwgYSBhJ1xuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBfIC0+IDFcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGluaXRcbiAgfCBTb21lIHggLT4gZiBpbml0IHhcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gaWYgZiB4IHRoZW4gdCBlbHNlIE5vbmVcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGVxdWFsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGVxdWFsX19sb2NhbCBmIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4LCBTb21lIHgnIC0+IGYgeCB4J1xuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBzb21lIHggPSBTb21lIHhcblxubGV0IGZpcnN0X3NvbWUgeCB5ID1cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgU29tZSBfIC0+IHhcbiAgfCBOb25lIC0+IHlcbjs7XG5cbmxldCBzb21lX2lmIGNvbmQgeCA9IGlmIGNvbmQgdGhlbiBTb21lIHggZWxzZSBOb25lXG5cbmxldCBtZXJnZSBhIGIgfmYgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBOb25lLCB4IHwgeCwgTm9uZSAtPiB4XG4gIHwgU29tZSBhLCBTb21lIGIgLT4gU29tZSAoZiBhIGIpXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHYgYXMgbyB3aGVuIGYgdiAtPiBvXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIG1hdGNoIGYgKCkgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gZiA9XG4gIG1hdGNoIGYgKCkgd2l0aFxuICB8IHggLT4geFxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgYSAtPiBTb21lIChmIGEpXG47O1xuXG5tb2R1bGUgTW9uYWRfYXJnID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gIGxldCByZXR1cm4geCA9IFNvbWUgeFxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcblxuICBsZXQgYmluZCBvIH5mID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IGYgeFxuICA7O1xuZW5kXG5cbmluY2x1ZGUgTW9uYWQuTWFrZV9sb2NhbCAoTW9uYWRfYXJnKVxuXG5tb2R1bGUgQXBwbGljYXRpdmVfYXJnID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gIGxldCByZXR1cm4geCA9IFNvbWUgeFxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcblxuICBsZXQgbWFwMiB4IHkgfmYgPVxuICAgIG1hdGNoIHgsIHkgd2l0aFxuICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4LCBTb21lIHkgLT4gU29tZSAoZiB4IHkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlX3VzaW5nX21hcDJfbG9jYWwgKEFwcGxpY2F0aXZlX2FyZylcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiY3N0IiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbjAiLCJCYXNlX0Vycm9yIiwiQmFzZV9JbXBvcnQiLCJCYXNlX01vbmFkIiwiQmFzZV9BcHBsaWNhdGl2ZSIsImNvbXBhcmVfbG9jYWwiLCJjb21wYXJlIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJjc3RfT3B0aW9uX3ZhbHVlX2V4biIsImNzdF9PcHRpb25fdmFsdWVfZXhuX05vbmUiLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiaXNfbm9uZSIsInBhcmFtIiwiaXNfc29tZSIsInZhbHVlX21hcCIsIm8iLCJkZWZhdWx0JCIsIngiLCJpdGVyIiwiYSIsImludmFyaWFudCIsInQiLCJjYWxsIiwidmFsdWUiLCJ2YWx1ZV9leG4iLCJoZXJlIiwiZXJyb3IiLCJtZXNzYWdlIiwicCIsImUiLCJtIiwidmFsdWVfb3JfdGh1bmsiLCJ0b19hcnJheSIsInRvX2xpc3QiLCJmb3JfYWxsIiwiZXhpc3RzIiwibWVtIiwiZXF1YWwiLCJsZW5ndGgiLCJmb2xkIiwiaW5pdCIsImZpbmQiLCJmaW5kX21hcCIsImVxdWFsX2xvY2FsIiwic29tZSIsImZpcnN0X3NvbWUiLCJ5Iiwic29tZV9pZiIsImNvbmQiLCJtZXJnZSIsImIiLCJmaWx0ZXIiLCJ2IiwidHJ5X3dpdGgiLCJleG4iLCJ0cnlfd2l0aF9qb2luIiwicmV0dXJuJCIsIm1hcCIsImJpbmQiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJNb25hZF9pbmZpeCIsImpvaW4iLCJpZ25vcmVfbSIsIkxldF9zeW50YXgiLCJtYXAyIiwiYm90aCIsInN5bWJvbCIsInN5bWJvbF9tYXAiLCJhcHBseSIsIm1hcDMiLCJhbGwiLCJhbGxfdW5pdCIsIkFwcGxpY2F0aXZlX2luZml4IiwiQmFzZV9PcHRpb24iXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFD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VTtBQUFBLFlBQUE2QixJQURWO0FBQUEsUUFFaUIsNEJBQUs7QUFBQTtBQUFBLFlBQUF1QyxLQUFBM0MsR0FBQXpCO0FBQUFBLElBVXBCLFFBQ1U7QUFBQSxRQUFBMkIsSUFEVjtBQUFBLElBRVksdUJBQUc7QUFBQTtBQUFBO0FBQUEsSUFBQTBDLFVEcFBuQjtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUgsU0FBQTtBQUFBLElBQUFJLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFSLFNBQUF2QyxHQzZQaUIsY0FBTTtBQUFBLE9BQUF3QyxRRDdQdkI7QUFBQSxZQUFBUSxLQUFBaEQsR0FBQTZCLEdBQUF4RDtBQUFBQSxJQ2lRSTtBQUFBLFNBQUF3RCxNQUFBLE1BQUE3QixNQUFBO0FBQUEsS0FFeUIsbUNBQU87QUFBQTtBQUFBLElBRFQ7QUFBQSxHQUNTO0FBQUE7QUFBQSxJQUFBMEMsWURuUXBDO0FBQUEsSUFBQUgsV0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBUyxPQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBSixTQUFBO0FBQUEsSUFBQUssT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTQxNjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJFbnVtZXJhYmxlIiwiQmFzZV9QcHhfZW51bWVyYXRlX2xpYiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMseUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNDE4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zZXF1ZW5jZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxub3BlbiBDb250YWluZXJfaW50Zi5FeHBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MVxuXG5tb2R1bGUgU3RlcCA9IHN0cnVjdFxuICAoKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2ZcbiAgICAgdGhlIHNlcXVlbmNlICopXG4gIHR5cGUgKCdhLCAncykgdCA9XG4gICAgfCBEb25lXG4gICAgfCBTa2lwIG9mIHsgc3RhdGUgOiAncyB9XG4gICAgfCBZaWVsZCBvZlxuICAgICAgICB7IHZhbHVlIDogJ2FcbiAgICAgICAgOyBzdGF0ZSA6ICdzXG4gICAgICAgIH1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgICAgICdhICdzLlxuICAgICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdzKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDExXyBzX18wMTJfKVxuICAgICAgOiAgKChhX18wMTFfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKHNfXzAxMl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKGFfXzAxMV8sIHNfXzAxMl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2Zfc19fMDAyXyAtPiBmdW5jdGlvblxuICAgIHwgRG9uZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEb25lXCJcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHN0YXRlX18wMDRfIH0gLT5cbiAgICAgIGxldCBibmRzX18wMDNfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDVfID0gX29mX3NfXzAwMl8gc3RhdGVfXzAwNF8gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInN0YXRlXCI7IGFyZ19fMDA1XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBcIlNraXBcIiA6OiBibmRzX18wMDNfKVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IHZhbHVlX18wMDdfOyBzdGF0ZSA9IHN0YXRlX18wMDlfIH0gLT5cbiAgICAgIGxldCBibmRzX18wMDZfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICBsZXQgYXJnX18wMTBfID0gX29mX3NfXzAwMl8gc3RhdGVfXzAwOV8gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInN0YXRlXCI7IGFyZ19fMDEwXyBdIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgIGluXG4gICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgIGxldCBhcmdfXzAwOF8gPSBfb2ZfYV9fMDAxXyB2YWx1ZV9fMDA3XyBpblxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidmFsdWVcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIFwiWWllbGRcIiA6OiBibmRzX18wMDZfKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxub3BlbiBTdGVwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gICgqICdhIGlzIGFuIGl0ZW0gaW4gdGhlIHNlcXVlbmNlLCAncyBpcyB0aGUgc3RhdGUgdGhhdCB3aWxsIHByb2R1Y2UgdGhlIHJlbWFpbmRlciBvZiB0aGVcbiAgICAgc2VxdWVuY2UgKilcbiAgdHlwZSArXyB0ID1cbiAgICB8IFNlcXVlbmNlIDpcbiAgICAgICAgeyBzdGF0ZSA6ICdzXG4gICAgICAgIDsgbmV4dCA6ICdzIC0+ICgnYSwgJ3MpIFN0ZXAudFxuICAgICAgICB9XG4gICAgICAgIC0+ICdhIHRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGdsb2JhbGl6ZSBfIChTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH0pID0gU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9XG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFZpZXcgPSBUXG5cbiAgbGV0IHZpZXcgdCA9IHRcblxuICBsZXQgbmV4dF9zdGVwIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSkgPVxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSB9XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IH1cbiAgOztcblxuICBsZXQgZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGxvb3AgcyBuZXh0IGZpbmlzaCBmIGFjYyA9XG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGYgYWNjIE5vbmUgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gZiBhY2MgKFNvbWUgYSkgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgIGluXG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0IGZpbmlzaCBmIGluaXRcbiAgOztcbmVuZFxuXG5sZXQgdW5mb2xkX3N0ZXAgfmluaXQgfmYgPSBTZXF1ZW5jZSB7IHN0YXRlID0gaW5pdDsgbmV4dCA9IGYgfVxuXG5sZXQgdW5mb2xkIH5pbml0IH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQgfmY6KGZ1biBzIC0+XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RlcC5Eb25lXG4gICAgfCBTb21lIChhLCBzKSAtPiBTdGVwLllpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSlcbjs7XG5cbmxldCB1bmZvbGRfd2l0aCBzIH5pbml0IH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gaW5pdCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChzZWVkLCBzKSAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzZWVkLCBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgIChtYXRjaCBmIHNlZWQgYSB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzZWVkIH0gLT4gU2tpcCB7IHN0YXRlID0gc2VlZCwgcyB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHNlZWQgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzZWVkLCBzIH0pKVxuICAgICAgfVxuOztcblxubGV0IHVuZm9sZF93aXRoX2FuZF9maW5pc2ggcyB+aW5pdCB+cnVubmluZ19zdGVwIH5pbm5lcl9maW5pc2hlZCB+ZmluaXNoaW5nX3N0ZXAgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgSW5uZXJfcnVubmluZyAoaW5pdCwgcylcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biBzdGF0ZSAtPlxuICAgICAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBpbm5lcl9zdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gYElubmVyX2ZpbmlzaGVkIChpbm5lcl9maW5pc2hlZCBzdGF0ZSkgfVxuICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBpbm5lcl9zdGF0ZSB9IC0+XG4gICAgICAgICAgICAgICAgIFNraXAgeyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gaW5uZXJfc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggcnVubmluZ19zdGVwIHN0YXRlIHggd2l0aFxuICAgICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlIH0gLT4gU2tpcCB7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgfVxuICAgICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0geTsgc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0geTsgc3RhdGUgPSBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSB9KSlcbiAgICAgICAgICAgIHwgYElubmVyX2ZpbmlzaGVkIHN0YXRlIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBmaW5pc2hpbmdfc3RlcCBzdGF0ZSB3aXRoXG4gICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5uZXJfZmluaXNoZWQgc3RhdGUgfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0geTsgc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0geTsgc3RhdGUgPSBgSW5uZXJfZmluaXNoZWQgc3RhdGUgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6bCB+ZjooZnVuY3Rpb25cbiAgICB8IFtdIC0+IERvbmVcbiAgICB8IHggOjogbCAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBsIH0pXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIHNlZWQgdiBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgfCBEb25lIC0+IHZcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgdiBuZXh0IGZcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgKGYgdiBhKSBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgaW5pdCBuZXh0IGZcbjs7XG5cbmxldCB0b19saXN0X3JldiB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbClcblxubGV0IHRvX2xpc3QgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pID1cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgdG9fbGlzdCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IFtdXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gKHRvX2xpc3QgW0B0YWlsY2FsbF0pIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGEgOjogKHRvX2xpc3QgW0B0YWlsY2FsbF0pIHMgbmV4dFxuICBpblxuICB0b19saXN0IHMgbmV4dFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X3Ygc3RvcF92ID1cbiAgbGV0IHN0ZXAgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgYGluY2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID4gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBpOyBzdGF0ZSA9IGkgKyBzdHJpZGUgfVxuICAgIHwgYGluY2x1c2l2ZSAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA8IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgICB8IGBleGNsdXNpdmUgd2hlbiBzdHJpZGUgPj0gMCAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA+PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGk7IHN0YXRlID0gaSArIHN0cmlkZSB9XG4gICAgfCBgZXhjbHVzaXZlIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpIDw9IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgaW5cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfdlxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBzdGFydF92ICsgc3RyaWRlXG4gIGluXG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOnN0ZXBcbjs7XG5cbmxldCBvZl9sYXp5IHRfbGF6eSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnRfbGF6eSB+ZjooZnVuIHRfbGF6eSAtPlxuICAgIGxldCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPSBMYXp5LmZvcmNlIHRfbGF6eSBpblxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgU2tpcFxuICAgICAgICB7IHN0YXRlID1cbiAgICAgICAgICAgIChsZXQgdiA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gaW5cbiAgICAgICAgICAgICBsYXp5IHYpXG4gICAgICAgIH1cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgWWllbGRcbiAgICAgICAgeyB2YWx1ZSA9IHhcbiAgICAgICAgOyBzdGF0ZSA9XG4gICAgICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IGluXG4gICAgICAgICAgICAgbGF6eSB2KVxuICAgICAgICB9KVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc2VlZFxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHNlZWQgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gZiBhOyBzdGF0ZSA9IHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSAwLCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gKGksIHMpIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGksIHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGYgaSBhOyBzdGF0ZSA9IGkgKyAxLCBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQgfmY6KGZ1biBhY2MgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGFjYyB4IGluXG4gICAgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gYWNjIH0pXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICB1bmZvbGRfd2l0aCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHggLT5cbiAgICBsZXQgYWNjLCB4ID0gZiBpIGFjYyB4IGluXG4gICAgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gaSArIDEsIGFjYyB9KVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc2VlZFxuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHNlZWQgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBtYXAgfmY6c25kIChmaWx0ZXIgKG1hcGkgdCB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpKVxuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBpIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgKGkgKyAxKSBzIG5leHRcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIDAgc2VlZCBuZXh0XG47O1xuXG5sZXQgdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCA9IGZvbGQgdCB+aW5pdDooW10sIDApIH5mOihmdW4gKGwsIGkpIHggLT4geCA6OiBsLCBpICsgMSlcblxubGV0IHRvX2FycmF5IHQgPVxuICBsZXQgbCwgbGVuID0gdG9fbGlzdF9yZXZfd2l0aF9sZW5ndGggdCBpblxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgeCA6OiBsIC0+XG4gICAgbGV0IGEgPSBBcnJheS5jcmVhdGUgfmxlbiB4IGluXG4gICAgbGV0IHJlYyBsb29wIGkgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gLTEpXG4gICAgICB8IHggOjogbCAtPlxuICAgICAgICBhLihpKSA8LSB4O1xuICAgICAgICBsb29wIChpIC0gMSkgbFxuICAgIGluXG4gICAgbG9vcCAobGVuIC0gMikgbDtcbiAgICBhXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBmIGEgLT4gU29tZSBhXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIChtYXRjaCBmIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggZiBpIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICAgICB8IHNvbWVfYiAtPiBzb21lX2IpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBub3QgKGYgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gbm90IChmIGkgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgaSBhIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgfCBEb25lIC0+ICgpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICBmIGE7XG4gICAgICBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIF8gLT4gZmFsc2VcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBhID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gXyB9IHdoZW4gZXF1YWwgYSBiIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBhXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgYSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZW1wdHkgPSBTZXF1ZW5jZSB7IHN0YXRlID0gKCk7IG5leHQgPSAoZnVuICgpIC0+IERvbmUpIH1cblxubGV0IGJpbmQgdCB+ZiA9XG4gIHVuZm9sZF9zdGVwXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0sIHJlc3QgLT5cbiAgICAgICAgKG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgICB8IERvbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgIFNraXAgeyBzdGF0ZSA9IGVtcHR5LCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgIFNraXAgeyBzdGF0ZSA9IGYgYSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSB9KSlcbiAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0sIHJlc3QgfVxuICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSwgcmVzdCB9KSlcbiAgICB+aW5pdDooZW1wdHksIHQpXG47O1xuXG5sZXQgcmV0dXJuIHggPVxuICB1bmZvbGRfc3RlcCB+aW5pdDooU29tZSB4KSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gRG9uZVxuICAgIHwgU29tZSB4IC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IE5vbmUgfSlcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGxldCBiaW5kID0gYmluZFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5lbmQpXG5cbmxldCBudGggcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IE5vbmVcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgaSBzIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgaSAwIHRoZW4gU29tZSBhIGVsc2UgbG9vcCAoaSAtIDEpIHMgbmV4dFxuICAgIGluXG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgbiBzIG5leHQpXG47O1xuXG5sZXQgbnRoX2V4biBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UubnRoXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggbnRoIHMgbiB3aXRoXG4gICAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UubnRoXCJcbiAgICB8IFNvbWUgeCAtPiB4KVxuOztcblxubW9kdWxlIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBMZWZ0IG9mICdhXG4gICAgfCBSaWdodCBvZiAnYlxuICAgIHwgQm90aCBvZiAnYSAqICdiXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsIDpcbiAgICAgICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMjNfIGJfXzAyNF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAyM18gYl9fMDI0X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDIzXywgYl9fMDI0XyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAyNV8sIExlZnQgX2JfXzAyNl8gLT4gX2NtcF9fYSBfYV9fMDI1XyBfYl9fMDI2X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgTGVmdCBfIC0+IDFcbiAgICAgIHwgUmlnaHQgX2FfXzAyN18sIFJpZ2h0IF9iX18wMjhfIC0+IF9jbXBfX2IgX2FfXzAyN18gX2JfXzAyOF9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBSaWdodCBfIC0+IDFcbiAgICAgIHwgQm90aCAoX2FfXzAyOV8sIF9hX18wMzFfKSwgQm90aCAoX2JfXzAzMF8sIF9iX18wMzJfKSAtPlxuICAgICAgICAobWF0Y2ggX2NtcF9fYSBfYV9fMDI5XyBfYl9fMDMwXyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fYiBfYV9fMDMxXyBfYl9fMDMyX1xuICAgICAgICAgfCBuIC0+IG4pKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIDpcbiAgICAgICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMTNfIGJfXzAxNF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAxM18gYl9fMDE0X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDEzXywgYl9fMDE0XyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAxNV8sIExlZnQgX2JfXzAxNl8gLT4gX2NtcF9fYSBfYV9fMDE1XyBfYl9fMDE2X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgTGVmdCBfIC0+IDFcbiAgICAgIHwgUmlnaHQgX2FfXzAxN18sIFJpZ2h0IF9iX18wMThfIC0+IF9jbXBfX2IgX2FfXzAxN18gX2JfXzAxOF9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBSaWdodCBfIC0+IDFcbiAgICAgIHwgQm90aCAoX2FfXzAxOV8sIF9hX18wMjFfKSwgQm90aCAoX2JfXzAyMF8sIF9iX18wMjJfKSAtPlxuICAgICAgICAobWF0Y2ggX2NtcF9fYSBfYV9fMDE5XyBfYl9fMDIwXyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fYiBfYV9fMDIxXyBfYl9fMDIyX1xuICAgICAgICAgfCBuIC0+IG4pKVxuICA7O1xuXG4gIGxldCBlcXVhbF9fbG9jYWwgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzA0M18gYl9fMDQ0XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDQzXyBiX18wNDRfXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wNDNfLCBiX18wNDRfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDQ1XywgTGVmdCBfYl9fMDQ2XyAtPiBfY21wX19hIF9hX18wNDVfIF9iX18wNDZfXG4gICAgICB8IExlZnQgXywgXyAtPiBmYWxzZVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gZmFsc2VcbiAgICAgIHwgUmlnaHQgX2FfXzA0N18sIFJpZ2h0IF9iX18wNDhfIC0+IF9jbXBfX2IgX2FfXzA0N18gX2JfXzA0OF9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiBmYWxzZVxuICAgICAgfCBfLCBSaWdodCBfIC0+IGZhbHNlXG4gICAgICB8IEJvdGggKF9hX18wNDlfLCBfYV9fMDUxXyksIEJvdGggKF9iX18wNTBfLCBfYl9fMDUyXykgLT5cbiAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fYSBfYV9fMDQ5XyBfYl9fMDUwXykgKF9jbXBfX2IgX2FfXzA1MV8gX2JfXzA1Ml8pKVxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDMzXyBiX18wMzRfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMzNfIGJfXzAzNF9cbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgICAgfCBMZWZ0IF9hX18wMzVfLCBMZWZ0IF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICAgIHwgTGVmdCBfLCBfIC0+IGZhbHNlXG4gICAgICB8IF8sIExlZnQgXyAtPiBmYWxzZVxuICAgICAgfCBSaWdodCBfYV9fMDM3XywgUmlnaHQgX2JfXzAzOF8gLT4gX2NtcF9fYiBfYV9fMDM3XyBfYl9fMDM4X1xuICAgICAgfCBSaWdodCBfLCBfIC0+IGZhbHNlXG4gICAgICB8IF8sIFJpZ2h0IF8gLT4gZmFsc2VcbiAgICAgIHwgQm90aCAoX2FfXzAzOV8sIF9hX18wNDFfKSwgQm90aCAoX2JfXzA0MF8sIF9iX18wNDJfKSAtPlxuICAgICAgICBTdGRsaWIuKCAmJiApIChfY21wX19hIF9hX18wMzlfIF9iX18wNDBfKSAoX2NtcF9fYiBfYV9fMDQxXyBfYl9fMDQyXykpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90XG4gICAgOiB0eXBlIGEgYi5cbiAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAtPiAoYSwgYikgdFxuICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgICBtYXRjaCBhcmcgd2l0aFxuICAgIHwgTGVmdCBfYTAgLT5cbiAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gICAgfCBSaWdodCBfYTAgLT5cbiAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG4gICAgfCBCb3RoIChfYTAsIF9hMSkgLT5cbiAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDIgaW5cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gICAgICBpblxuICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTFcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpXG4gICAgICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAtPiAoJ2EsICdiKSB0XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wNzZfIGJfXzA3N18pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wNzZfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzA3N18pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgLT4gKGFfXzA3Nl8sIGJfXzA3N18pIHQpIC0+XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDU3XyA9IFwic2VxdWVuY2UubWwuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQudFwiIGluXG4gICAgZnVuIF9vZl9hX18wNTNfIF9vZl9iX18wNTRfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBfdGFnX18wNjBfKSA6OiBzZXhwX2FyZ3NfXzA2MV8pIGFzXG4gICAgICAgIF9zZXhwX18wNTlfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA2MV8gd2l0aFxuICAgICAgICAgfCBhcmcwX18wNjJfIDo6IFtdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wNjNfID0gX29mX2FfXzA1M18gYXJnMF9fMDYyXyBpblxuICAgICAgICAgICBMZWZ0IHJlczBfXzA2M19cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgIF9zZXhwX18wNTlfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBfdGFnX18wNjVfKSA6OiBzZXhwX2FyZ3NfXzA2Nl8pIGFzXG4gICAgICAgIF9zZXhwX18wNjRfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA2Nl8gd2l0aFxuICAgICAgICAgfCBhcmcwX18wNjdfIDo6IFtdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wNjhfID0gX29mX2JfXzA1NF8gYXJnMF9fMDY3XyBpblxuICAgICAgICAgICBSaWdodCByZXMwX18wNjhfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgIF90YWdfXzA2NV9cbiAgICAgICAgICAgICBfc2V4cF9fMDY0XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIF90YWdfXzA3MF8pIDo6IHNleHBfYXJnc19fMDcxXykgYXNcbiAgICAgICAgX3NleHBfXzA2OV8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDcxXyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDcyXzsgYXJnMV9fMDczXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wNzRfID0gX29mX2FfXzA1M18gYXJnMF9fMDcyX1xuICAgICAgICAgICBhbmQgcmVzMV9fMDc1XyA9IF9vZl9iX18wNTRfIGFyZzFfXzA3M18gaW5cbiAgICAgICAgICAgQm90aCAocmVzMF9fMDc0XywgcmVzMV9fMDc1XylcbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgX3RhZ19fMDcwX1xuICAgICAgICAgICAgIF9zZXhwX18wNjlfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIHNleHBfXzA1OF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU4X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicmlnaHRcIiB8IFwiUmlnaHRcIikgYXMgc2V4cF9fMDU4XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNThfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgc2V4cF9fMDU4XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNThfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDU2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1Nl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA1Nl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1Nl9cbiAgICAgIHwgc2V4cF9fMDU2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNTZfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdiKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDg4XyBiX18wODlfKVxuICAgICAgOiAgKChhX18wODhfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzA4OV8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKGFfXzA4OF8sIGJfXzA4OV8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDc4XyBfb2ZfYl9fMDc5XyAtPiBmdW5jdGlvblxuICAgIHwgTGVmdCBhcmcwX18wODBfIC0+XG4gICAgICBsZXQgcmVzMF9fMDgxXyA9IF9vZl9hX18wNzhfIGFyZzBfXzA4MF8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgcmVzMF9fMDgxXyBdXG4gICAgfCBSaWdodCBhcmcwX18wODJfIC0+XG4gICAgICBsZXQgcmVzMF9fMDgzXyA9IF9vZl9iX18wNzlfIGFyZzBfXzA4Ml8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IHJlczBfXzA4M18gXVxuICAgIHwgQm90aCAoYXJnMF9fMDg0XywgYXJnMV9fMDg1XykgLT5cbiAgICAgIGxldCByZXMwX18wODZfID0gX29mX2FfXzA3OF8gYXJnMF9fMDg0X1xuICAgICAgYW5kIHJlczFfXzA4N18gPSBfb2ZfYl9fMDc5XyBhcmcxX18wODVfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJCb3RoXCI7IHJlczBfXzA4Nl87IHJlczFfXzA4N18gXVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkJvdGhcIlxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmxldCBtZXJnZV93aXRoX2R1cGxpY2F0ZXNcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9KVxuICB+Y29tcGFyZVxuICA9XG4gIGxldCB1bnNoYWRvd2VkX2NvbXBhcmUgPSBjb21wYXJlIGluXG4gIGxldCBvcGVuIE1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50IGluXG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIHMyIC0+IFNraXAgeyBzdGF0ZSA9IG5leHQxIHMxLCBzMiB9XG4gICAgfCBzMSwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBzMSwgbmV4dDIgczIgfVxuICAgIHwgKFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxJyB9IGFzIHMxKSwgKFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyJyB9IGFzIHMyKVxuICAgICAgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gdW5zaGFkb3dlZF9jb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8IDBcbiAgICAgIHRoZW4gWWllbGQgeyB2YWx1ZSA9IExlZnQgYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMScgfSwgczIgfVxuICAgICAgZWxzZSBpZiBjb21wYXJpc29uID0gMFxuICAgICAgdGhlblxuICAgICAgICBZaWVsZCB7IHZhbHVlID0gQm90aCAoYSwgYik7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEnIH0sIFNraXAgeyBzdGF0ZSA9IHMyJyB9IH1cbiAgICAgIGVsc2UgWWllbGQgeyB2YWx1ZSA9IFJpZ2h0IGI7IHN0YXRlID0gczEsIFNraXAgeyBzdGF0ZSA9IHMyJyB9IH1cbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgRG9uZSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IExlZnQgYTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBEb25lIH1cbiAgICB8IERvbmUsIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBSaWdodCBiOyBzdGF0ZSA9IERvbmUsIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfTsgbmV4dCB9XG47O1xuXG5sZXQgbWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIHMxIHMyIH5jb21wYXJlID1cbiAgbWFwIChtZXJnZV93aXRoX2R1cGxpY2F0ZXMgczEgczIgfmNvbXBhcmUpIH5mOihmdW5jdGlvblxuICAgIHwgTGVmdCB4IHwgUmlnaHQgeCB8IEJvdGggKHgsIF8pIC0+IHgpXG47O1xuXG5sZXQgbWVyZ2Vfc29ydGVkXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9KVxuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSlcbiAgfmNvbXBhcmVcbiAgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBzMiAtPiBTa2lwIHsgc3RhdGUgPSBuZXh0MSBzMSwgczIgfVxuICAgIHwgczEsIFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gczEsIG5leHQyIHMyIH1cbiAgICB8IChZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMScgfSBhcyBzMSksIChZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMicgfSBhcyBzMilcbiAgICAgIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IGNvbXBhcmUgYSBiIGluXG4gICAgICBpZiBjb21wYXJpc29uIDw9IDBcbiAgICAgIHRoZW4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEnIH0sIHMyIH1cbiAgICAgIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczEsIFNraXAgeyBzdGF0ZSA9IHMyJyB9IH1cbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgRG9uZSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgRG9uZSB9XG4gICAgfCBEb25lLCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBEb25lLCBTa2lwIHsgc3RhdGUgPSBzMiB9IH1cbiAgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH07IG5leHQgfVxuOztcblxubGV0IGhkIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbmV4dFxuOztcblxubGV0IGhkX2V4biBzID1cbiAgbWF0Y2ggaGQgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcImhkX2V4blwiXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB0bCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBhIH0gLT4gU29tZSBhXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICAobWF0Y2ggbG9vcCBzIG5leHQgd2l0aFxuICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICB8IFNvbWUgcyAtPiBTb21lIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSlcbjs7XG5cbmxldCB0bF9lYWdlcmx5X2V4biBzID1cbiAgbWF0Y2ggdGwgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRsX2V4blwiXG4gIHwgU29tZSBzIC0+IHNcbjs7XG5cbmxldCBsaWZ0X2lkZW50aXR5IG5leHQgcyA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgRG9uZSAtPiBEb25lXG4gIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGBJZGVudGl0eSBzIH1cbiAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYElkZW50aXR5IHMgfVxuOztcblxubGV0IG5leHQgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFNvbWUgKGEsIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBmaWx0ZXJfb3B0IHMgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gcyAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IE5vbmU7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gU29tZSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgZmlsdGVyX21hcCBzIH5mID0gZmlsdGVyX29wdCAobWFwIHMgfmYpXG5sZXQgZmlsdGVyX21hcGkgcyB+ZiA9IGZpbHRlcl9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBzcGxpdF9uIHMgbiA9XG4gIGxldCByZWMgbG9vcCBzIGkgYWNjdW0gbmV4dCA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiBMaXN0LnJldiBhY2N1bSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBMaXN0LnJldiBhY2N1bSwgZW1wdHlcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBpIGFjY3VtIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyAoaSAtIDEpIChhIDo6IGFjY3VtKSBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuIFtdIG5leHRcbjs7XG5cbmxldCBjaHVua3NfZXhuIHQgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY2h1bmtzX2V4blwiXG4gIGVsc2VcbiAgICB1bmZvbGRfc3RlcCB+aW5pdDp0IH5mOihmdW4gdCAtPlxuICAgICAgbWF0Y2ggc3BsaXRfbiB0IG4gd2l0aFxuICAgICAgfCBbXSwgX2VtcHR5IC0+IERvbmVcbiAgICAgIHwgKF8gOjogXyBhcyB4cyksIHQgLT4gWWllbGQgeyB2YWx1ZSA9IHhzOyBzdGF0ZSA9IHQgfSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBpIGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIGYgaSBhIC0+IFNvbWUgKGksIGEpXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgKGkgKyAxKSBmXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgaSBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgMCBmXG47O1xuXG5sZXQgZmluZF9leG4gcyB+ZiA9XG4gIG1hdGNoIGZpbmQgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLmZpbmRfZXhuXCJcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIG1hdGNoIHMxLCBzMiB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYEZpcnN0X2xpc3QgczFcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgIHwgYEZpcnN0X2xpc3QgczEgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmV4dDEgczEgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gU2tpcCB7IHN0YXRlID0gYFNlY29uZF9saXN0IHMyIH1cbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9IC0+IFNraXAgeyBzdGF0ZSA9IGBGaXJzdF9saXN0IHMxIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9IC0+XG4gICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYEZpcnN0X2xpc3QgczEgfSlcbiAgICAgICAgICAgfCBgU2Vjb25kX2xpc3QgczIgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmV4dDIgczIgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gYFNlY29uZF9saXN0IHMyIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYFNlY29uZF9saXN0IHMyIH0pKVxuICAgICAgfVxuOztcblxubGV0IGNvbmNhdF9tYXAgcyB+ZiA9IGJpbmQgcyB+ZlxubGV0IGNvbmNhdCBzID0gY29uY2F0X21hcCBzIH5mOkZuLmlkXG5sZXQgY29uY2F0X21hcGkgcyB+ZiA9IGNvbmNhdF9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCB6aXAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pIChTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9KSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhLCBiOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH0gfVxuICAgIHwgRG9uZSwgXyB8IF8sIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCB6aXBfZnVsbFxuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSlcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0pXG4gID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGBCb3RoIChhLCBiKTsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9IH1cbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gICAgfCBEb25lLCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYFJpZ2h0IGI7IHN0YXRlID0gRG9uZSwgbmV4dDIgczIgfVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSwgRG9uZSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGBMZWZ0IGE7IHN0YXRlID0gbmV4dDEgczEsIERvbmUgfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfTsgbmV4dCB9XG47O1xuXG5sZXQgYm91bmRlZF9sZW5ndGggKFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0pIH5hdF9tb3N0ID1cbiAgbGV0IHJlYyBsb29wIGkgc2VlZCBuZXh0ID1cbiAgICBpZiBpID4gYXRfbW9zdFxuICAgIHRoZW4gYEdyZWF0ZXJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICB8IERvbmUgLT4gYElzIGlcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gc2VlZCB9IC0+IGxvb3AgaSBzZWVkIG5leHRcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gc2VlZCB9IC0+IGxvb3AgKGkgKyAxKSBzZWVkIG5leHQpXG4gIGluXG4gIGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCBsZW5ndGhfaXNfYm91bmRlZF9ieSA/KG1pbiA9IC0xKSA/bWF4IHQgPVxuICBsZXQgbGVuZ3RoX2lzX2F0X2xlYXN0IChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSA9XG4gICAgbGV0IHJlYyBsb29wIHMgYWNjID1cbiAgICAgIGlmIGFjYyA+PSBtaW5cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgYWNjXG4gICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgcyAoYWNjICsgMSkpXG4gICAgaW5cbiAgICBsb29wIHMgMFxuICBpblxuICBtYXRjaCBtYXggd2l0aFxuICB8IE5vbmUgLT4gbGVuZ3RoX2lzX2F0X2xlYXN0IHRcbiAgfCBTb21lIG1heCAtPlxuICAgIChtYXRjaCBib3VuZGVkX2xlbmd0aCB0IH5hdF9tb3N0Om1heCB3aXRoXG4gICAgIHwgYElzIGxlbiB3aGVuIGxlbiA+PSBtaW4gLT4gdHJ1ZVxuICAgICB8IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgaXRlcmkgcyB+ZiA9IGl0ZXIgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpIFtAbm9udGFpbF1cblxubGV0IGZvbGRpIHMgfmluaXQgfmYgPVxuICBmb2xkIH5pbml0IChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gYWNjIChpLCBzKSAtPiBmIGkgYWNjIHMpIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWR1Y2UgcyB+ZiA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoYSwgcykgLT4gU29tZSAoZm9sZCBzIH5pbml0OmEgfmYpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBzIH5mID1cbiAgbWF0Y2ggcmVkdWNlIHMgfmYgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHJlcyAtPiByZXNcbjs7XG5cbmxldCBncm91cCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgfmJyZWFrID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+aW5pdDooU29tZSAoW10sIHMpKVxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IERvbmVcbiAgICAgIHwgU29tZSAoYWNjLCBzKSAtPlxuICAgICAgICAobWF0Y2ggYWNjLCBuZXh0IHMgd2l0aFxuICAgICAgICAgfCBfLCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gU29tZSAoYWNjLCBzKSB9XG4gICAgICAgICB8IFtdLCBEb25lIC0+IERvbmVcbiAgICAgICAgIHwgYWNjLCBEb25lIC0+IFlpZWxkIHsgdmFsdWUgPSBMaXN0LnJldiBhY2M7IHN0YXRlID0gTm9uZSB9XG4gICAgICAgICB8IFtdLCBZaWVsZCB7IHZhbHVlID0gY3VyOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTb21lIChbIGN1ciBdLCBzKSB9XG4gICAgICAgICB8IChwcmV2IDo6IF8gYXMgYWNjKSwgWWllbGQgeyB2YWx1ZSA9IGN1cjsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgICAgaWYgYnJlYWsgcHJldiBjdXJcbiAgICAgICAgICAgdGhlbiBZaWVsZCB7IHZhbHVlID0gTGlzdC5yZXYgYWNjOyBzdGF0ZSA9IFNvbWUgKFsgY3VyIF0sIHMpIH1cbiAgICAgICAgICAgZWxzZSBTa2lwIHsgc3RhdGUgPSBTb21lIChjdXIgOjogYWNjLCBzKSB9KSlcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIGxhc3RfZWx0IHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGxhc3RfZWx0IHNcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgKG1hdGNoIGxhc3RfZWx0IHdpdGhcbiAgICAgICB8IFNvbWUgYiB3aGVuIGVxdWFsIGEgYiAtPiBTb21lIChiLCBhKVxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBsb29wIChTb21lIGEpIHMpXG4gIGluXG4gIGxvb3AgTm9uZSBzIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyBzIH5lcXVhbCA9XG4gIHVuZm9sZF93aXRoIHMgfmluaXQ6Tm9uZSB+ZjooZnVuIHByZXYgYSAtPlxuICAgIG1hdGNoIHByZXYgd2l0aFxuICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNraXAgeyBzdGF0ZSA9IFNvbWUgYSB9XG4gICAgfCBOb25lIHwgU29tZSBfIC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNvbWUgYSB9KVxuOztcblxubGV0IGNvdW50IHMgfmYgPSBmb2xkIHMgfmluaXQ6MCB+ZjooZnVuIGFjYyBlbHQgLT4gYWNjICsgQm9vbC50b19pbnQgKGYgZWx0KSkgW0Bub250YWlsXVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpIGFjYyBlbHQgLT4gYWNjICsgQm9vbC50b19pbnQgKGYgaSBlbHQpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGluaXQgbiB+ZiA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBmIGk7IHN0YXRlID0gaSArIDEgfSlcbjs7XG5cbmxldCBzdWIgcyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnN1YlwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSAwLCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gKGksIHMpIC0+XG4gICAgICAgICAgICBpZiBpIC0gcG9zID49IGxlblxuICAgICAgICAgICAgdGhlbiBEb25lXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSwgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gaSA+PSBwb3MgLT5cbiAgICAgICAgICAgICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBpICsgMSwgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGkgKyAxLCBzIH0pKVxuICAgICAgfVxuOztcblxubGV0IHRha2UgcyBsZW4gPVxuICBpZiBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS50YWtlXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IDAsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoaSwgcykgLT5cbiAgICAgICAgICAgIGlmIGkgPj0gbGVuXG4gICAgICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gaSArIDEsIHMgfSkpXG4gICAgICB9XG47O1xuXG5sZXQgZHJvcCBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLmRyb3BcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gaSA+PSBsZW4gLT5cbiAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gaSArIDEsIHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSArIDEsIHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCB0YWtlX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gcyAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gZiBhIC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBfIH0gLT4gRG9uZSlcbiAgICAgIH1cbjs7XG5cbmxldCBkcm9wX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgRHJvcHBpbmcgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgfCBgRHJvcHBpbmcgcyAtPlxuICAgICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgRHJvcHBpbmcgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IHdoZW4gZiBhIC0+IFNraXAgeyBzdGF0ZSA9IGBEcm9wcGluZyBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYElkZW50aXR5IHMgfSlcbiAgICAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcylcbiAgICAgIH1cbjs7XG5cbmxldCBzaGlmdF9yaWdodCBzIHggPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgQ29uc2luZyAoc2VlZCwgeClcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgIHwgYENvbnNpbmcgKHNlZWQsIHgpIC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGBJZGVudGl0eSBzZWVkIH1cbiAgICAgICAgICAgfCBgSWRlbnRpdHkgcyAtPiBsaWZ0X2lkZW50aXR5IG5leHQgcylcbiAgICAgIH1cbjs7XG5cbmxldCBzaGlmdF9yaWdodF93aXRoX2xpc3QgcyBsID0gYXBwZW5kIChvZl9saXN0IGwpIHNcbmxldCBzaGlmdF9sZWZ0ID0gZHJvcFxuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IGludGVyc3BlcnNlIHMgfnNlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBJbml0IHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgIHwgYEluaXQgcyAtPlxuICAgICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSW5pdCBzIH1cbiAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYFJ1bm5pbmcgcyB9KVxuICAgICAgICAgICB8IGBSdW5uaW5nIHMgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gYFJ1bm5pbmcgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IHNlcDsgc3RhdGUgPSBgUHV0dGluZyAoYSwgcykgfSlcbiAgICAgICAgICAgfCBgUHV0dGluZyAoYSwgcykgLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gYFJ1bm5pbmcgcyB9KVxuICAgICAgfVxuOztcblxubGV0IHJlcGVhdCB4ID0gdW5mb2xkX3N0ZXAgfmluaXQ6eCB+ZjooZnVuIHggLT4gWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0geCB9KVxuXG5sZXQgY3ljbGVfbGlzdF9leG4geHMgPVxuICBpZiBMaXN0LmlzX2VtcHR5IHhzIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jeWNsZV9saXN0X2V4blwiO1xuICBsZXQgcyA9IG9mX2xpc3QgeHMgaW5cbiAgY29uY2F0X21hcCB+ZjooZnVuICgpIC0+IHMpIChyZXBlYXQgKCkpXG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3Qgc2Egc2IgPSBjb25jYXRfbWFwIHNhIH5mOihmdW4gYSAtPiB6aXAgKHJlcGVhdCBhKSBzYilcbmxldCBzaW5nbGV0b24geCA9IHJldHVybiB4XG5cbmxldCBkZWxheWVkX2ZvbGQgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmZpbmlzaCB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgIHwgTm9uZSAtPiBrIGFjY1xuICAgIHwgU29tZSBhIC0+IGYgYWNjIGEgfmspXG47O1xuXG5sZXQgZm9sZF9tIH5iaW5kIH5yZXR1cm4gdCB+aW5pdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdFxuICAgIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gYWNjKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGFjYyBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgaXRlcl9tIH5iaW5kIH5yZXR1cm4gdCB+ZiA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcFxuICAgIHRcbiAgICB+aW5pdDooKVxuICAgIH5mOihmdW4gKCkgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiAoKSkgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhKSB+ZjprKVxuICAgIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgZm9sZF91bnRpbCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKCdhLCAnYikgQ29udGludWVfb3Jfc3RvcC50KSB3aXRoXG4gICAgICAgfCBTdG9wIHggLT4geFxuICAgICAgIHwgQ29udGludWUgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0IGYgaW5pdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgcyB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IFJlc3VsdC5yZXR1cm4gYWNjXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBhY2NcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgKG1hdGNoIChmIGFjYyBhIDogKF8sIF8pIFJlc3VsdC50KSB3aXRoXG4gICAgICAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICAgICAgIHwgT2sgYWNjIC0+IGxvb3AgcyBuZXh0IGYgYWNjKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvcmNlX2VhZ2VybHkgdCA9IG9mX2xpc3QgKHRvX2xpc3QgdClcblxubGV0IG1lbW9pemUgKHR5cGUgYSkgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVCBvZiAoYSwgdCkgU3RlcC50IExhenkudFxuICBlbmRcbiAgaW5cbiAgbGV0IHJlYyBtZW1vaXplIHMgPSBNLlQgKGxhenkgKGZpbmRfc3RlcCBzKSlcbiAgYW5kIGZpbmRfc3RlcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gZmluZF9zdGVwIHNcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBtZW1vaXplIHMgfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gbWVtb2l6ZSBzOyBuZXh0ID0gKGZ1biAoTS5UIGwpIC0+IExhenkuZm9yY2UgbCkgfVxuOztcblxubGV0IGRyb3BfZWFnZXJseSBzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpIH5sZW4gcyBuZXh0ID1cbiAgICBpZiBpID49IGxlblxuICAgIHRoZW4gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBlbXB0eVxuICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBpIH5sZW4gcyBuZXh0XG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIChpICsgMSkgfmxlbiBzIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCAwIH5sZW4gcyBuZXh0XG47O1xuXG5sZXQgZHJvcF93aGlsZV9vcHRpb24gKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pIH5mID1cbiAgbGV0IHJlYyBsb29wIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHNcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgaWYgZiB4IHRoZW4gbG9vcCBzIGVsc2UgU29tZSAoeCwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSlcbiAgaW5cbiAgbG9vcCBzIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWMgc2tpcF9sb29wIHMgbmV4dCA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgU2tpcCB7IHN0YXRlIH0gLT4gc2tpcF9sb29wIHN0YXRlIG5leHRcbiAgfCAoRG9uZSB8IFlpZWxkIF8pIGFzIG5leHQgLT4gbmV4dFxuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIChTZXF1ZW5jZSBsKSAoU2VxdWVuY2UgcikgPVxuICBsZXQgcmVjIGxvb3AgY29tcGFyZV9hIHNfbCBuZXh0X2wgc19yIG5leHRfciA9XG4gICAgbWF0Y2ggc2tpcF9sb29wIHNfbCBuZXh0X2wsIHNraXBfbG9vcCBzX3IgbmV4dF9yIHdpdGhcbiAgICB8IERvbmUsIERvbmUgLT4gMFxuICAgIHwgRG9uZSwgWWllbGQgXyAtPiAtMVxuICAgIHwgWWllbGQgXywgRG9uZSAtPiAxXG4gICAgfCBZaWVsZCBsLCBZaWVsZCByIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfYSBsLnZhbHVlIHIudmFsdWUgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBsb29wIGNvbXBhcmVfYSBsLnN0YXRlIG5leHRfbCByLnN0YXRlIG5leHRfclxuICAgIHwgU2tpcCBfLCBfIHwgXywgU2tpcCBfIC0+IGZhaWx3aXRoIFwiQnVnOiBUaGlzIGJyYW5jaCBzaG91bGQgYmUgdW5yZWFjaGFibGVcIlxuICBpblxuICBsb29wIGNvbXBhcmVfYSBsLnN0YXRlIGwubmV4dCByLnN0YXRlIHIubmV4dFxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfYV9fbG9jYWwgdDEgdDIgPVxuICBjb21wYXJlIChmdW4geCB5IC0+IGNvbXBhcmVfYV9fbG9jYWwgeCB5KSAoZ2xvYmFsaXplICgpIHQxKSAoZ2xvYmFsaXplICgpIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPVxuICBmb3JfYWxsICh6aXBfZnVsbCB0MSB0MikgfmY6KGZ1bmN0aW9uXG4gICAgfCBgQm90aCAoYTEsIGEyKSAtPiBlcXVhbF9hIGExIGEyXG4gICAgfCBgTGVmdCBfIHwgYFJpZ2h0IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgZXF1YWxfX2xvY2FsIGVxdWFsX2FfX2xvY2FsIHQxIHQyID1cbiAgZXF1YWwgKGZ1biB4IHkgLT4gZXF1YWxfYV9fbG9jYWwgeCB5KSAoZ2xvYmFsaXplICgpIHQxKSAoZ2xvYmFsaXplICgpIHQyKVxuOztcblxubGV0IHJvdW5kX3JvYmluIGxpc3QgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaykgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0gOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYgcyB3aXRoXG4gICAgICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgIFlpZWxkXG4gICAgICAgICAgIHsgdmFsdWUgPSB4XG4gICAgICAgICAgIDsgc3RhdGUgPSB0b2RvX3N0YWNrLCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSA6OiBkb25lX3N0YWNrXG4gICAgICAgICAgIH1cbiAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgU2tpcCB7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0gOjogdG9kb19zdGFjaywgZG9uZV9zdGFjayB9XG4gICAgICAgfCBEb25lIC0+IFNraXAgeyBzdGF0ZSA9IHRvZG9fc3RhY2ssIGRvbmVfc3RhY2sgfSlcbiAgICB8IFtdIC0+XG4gICAgICBpZiBMaXN0LmlzX2VtcHR5IGRvbmVfc3RhY2sgdGhlbiBEb25lIGVsc2UgU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgZG9uZV9zdGFjaywgW10gfVxuICBpblxuICBsZXQgc3RhdGUgPSBsaXN0LCBbXSBpblxuICBTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH1cbjs7XG5cbmxldCBpbnRlcmxlYXZlIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBmMSB9KSA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gZjIgfSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZjIgczIgd2l0aFxuICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gczIgfSAtPlxuICAgICAgICAgWWllbGRcbiAgICAgICAgICAgeyB2YWx1ZSA9IHhcbiAgICAgICAgICAgOyBzdGF0ZSA9IHRvZG9fc3RhY2ssIFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IGYyIH0gOjogZG9uZV9zdGFjaywgczFcbiAgICAgICAgICAgfVxuICAgICAgIHwgU2tpcCB7IHN0YXRlID0gczIgfSAtPlxuICAgICAgICAgU2tpcCB7IHN0YXRlID0gdG9kb19zdGFjaywgU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gZjIgfSA6OiBkb25lX3N0YWNrLCBzMSB9XG4gICAgICAgfCBEb25lIC0+IFNraXAgeyBzdGF0ZSA9IHRvZG9fc3RhY2ssIGRvbmVfc3RhY2ssIHMxIH0pXG4gICAgfCBbXSAtPlxuICAgICAgKG1hdGNoIGYxIHMxLCBkb25lX3N0YWNrIHdpdGhcbiAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB0OyBzdGF0ZSA9IHMxIH0sIF8gLT5cbiAgICAgICAgIFNraXAgeyBzdGF0ZSA9IExpc3QucmV2ICh0IDo6IGRvbmVfc3RhY2spLCBbXSwgczEgfVxuICAgICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgXyAtPiBTa2lwIHsgc3RhdGUgPSBMaXN0LnJldiBkb25lX3N0YWNrLCBbXSwgczEgfVxuICAgICAgIHwgRG9uZSwgXyA6OiBfIC0+IFNraXAgeyBzdGF0ZSA9IExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSB9XG4gICAgICAgfCBEb25lLCBbXSAtPiBEb25lKVxuICBpblxuICBsZXQgc3RhdGUgPSBbXSwgW10sIHMxIGluXG4gIFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfVxuOztcblxubGV0IGludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0IHMxIHMyID1cbiAgbWFwIHMxIH5mOihmdW4geDEgLT4gbWFwIHMyIH5mOihmdW4geDIgLT4geDEsIHgyKSkgfD4gaW50ZXJsZWF2ZVxuOztcblxubGV0IG9mX3NlcSAoc2VxIDogXyBTdGRsaWIuU2VxLnQpID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6c2VxIH5mOihmdW4gc2VxIC0+XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBEb25lXG4gICAgfCBDb25zIChoZCwgdGwpIC0+IFlpZWxkIHsgdmFsdWUgPSBoZDsgc3RhdGUgPSB0bCB9KVxuOztcblxubGV0IHRvX3NlcSAoU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9KSA9XG4gIGxldCByZWMgbG9vcCBzdGF0ZSA9XG4gICAgbWF0Y2ggbmV4dCBzdGF0ZSB3aXRoXG4gICAgfCBEb25lIC0+IFN0ZGxpYi5TZXEuTmlsXG4gICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBsb29wIHN0YXRlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gaGQ7IHN0YXRlIH0gLT4gU3RkbGliLlNlcS5Db25zIChoZCwgZnVuICgpIC0+IGxvb3Agc3RhdGUpXG4gIGluXG4gIGZ1biAoKSAtPiBsb29wIHN0YXRlXG47O1xuXG5tb2R1bGUgR2VuZXJhdG9yID0gc3RydWN0XG4gIHR5cGUgJ2VsdCBzdGVwcyA9IFdyYXAgb2YgKCdlbHQsIHVuaXQgLT4gJ2VsdCBzdGVwcykgU3RlcC50XG5cbiAgbGV0IHVud3JhcCAoV3JhcCBzdGVwKSA9IHN0ZXBcblxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnZWx0KSB0ID0gKCdhIC0+ICdlbHQgc3RlcHMpIC0+ICdlbHQgc3RlcHNcblxuICAgIGxldCByZXR1cm4geCBrID0gayB4XG5cbiAgICBsZXQgYmluZCBtIH5mIGsgPVxuICAgICAgbSAoZnVuIGEgLT5cbiAgICAgICAgbGV0IG0nID0gZiBhIGluXG4gICAgICAgIG0nIGspXG4gICAgOztcblxuICAgIGxldCBtYXAgbSB+ZiBrID0gbSAoZnVuIGEgLT4gayAoZiBhKSlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTIgKFQpXG5cbiAgbGV0IHlpZWxkIGUgayA9IFdyYXAgKFlpZWxkIHsgdmFsdWUgPSBlOyBzdGF0ZSA9IGsgfSlcbiAgbGV0IHRvX3N0ZXBzIHQgPSB0IChmdW4gKCkgLT4gV3JhcCBEb25lKVxuXG4gIGxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSA9XG4gICAgZGVsYXllZF9mb2xkXG4gICAgICBzZXF1ZW5jZVxuICAgICAgfmluaXQ6KClcbiAgICAgIH5mOihmdW4gKCkgeCB+ayBmIC0+IFdyYXAgKFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IChmdW4gKCkgLT4gayAoKSBmKSB9KSlcbiAgICAgIH5maW5pc2g6cmV0dXJuXG4gIDs7XG5cbiAgbGV0IHJ1biB0ID1cbiAgICBsZXQgaW5pdCAoKSA9IHRvX3N0ZXBzIHQgaW5cbiAgICBsZXQgZiB0aHVuayA9IHVud3JhcCAodGh1bmsgKCkpIGluXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQgfmZcbiAgOztcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQm90aCIsImNzdF9MZWZ0IiwiY3N0X1JpZ2h0IiwiY3N0X1NlcXVlbmNlX250aCIsImNzdF9ib3RoIiwiY3N0X2xlZnQiLCJjc3RfcmlnaHQiLCJjc3Rfc3RhdGUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJpbml0IiwiZXJyb3Jfc291cmNlXzA1NyIsIkJhc2VfTGlzdDEiLCJCYXNlX0ltcG9ydCIsIkNhbWxpbnRlcm5hbExhenkiLCJCYXNlX1Jlc3VsdCIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9Cb29sIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9IYXNoIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0FycmF5MCIsIkJhc2VfTW9uYWQiLCJzZXhwX29mX3QiLCJvZl9hXzAwMSIsIm9mX3NfMDAyIiwicGFyYW0iLCJzdGF0ZV8wMDQiLCJhcmdfMDA1IiwiYm5kc18wMDMiLCJzdGF0ZV8wMDkiLCJ2YWx1ZV8wMDciLCJhcmdfMDEwIiwiYm5kc18wMDYiLCJhcmdfMDA4IiwiU3RlcCIsIlQiLCJnbG9iYWxpemUiLCJuZXh0Iiwic3RhdGUiLCJ2aWV3IiwidCIsIm5leHRfc3RlcCIsInMiLCJtYXRjaCIsImEiLCJkZWxheWVkX2ZvbGRfc3RlcCIsImZpbmlzaCIsImxvb3AiLCJhY2MiLCJ1bmZvbGRfc3RlcCIsInVuZm9sZCIsInVuZm9sZF93aXRoIiwic2VlZCIsInVuZm9sZF93aXRoX2FuZF9maW5pc2giLCJydW5uaW5nX3N0ZXAiLCJpbm5lcl9maW5pc2hlZCIsImZpbmlzaGluZ19zdGVwIiwidmFyaWFudCIsInkiLCJpbm5lcl9zdGF0ZSIsIngiLCJvZl9saXN0IiwibCIsImZvbGQiLCJ2IiwidG9fbGlzdF9yZXYiLCJ0b19saXN0IiwiYmxvY2siLCJkc3QiLCJvZmZzZXQiLCJzZXhwX29mX2EiLCJyYW5nZSIsIm9wdCIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdHJpZGUiLCJzdGFydCIsInN0b3AiLCJzdGVwIiwiaSIsIm9mX2xhenkiLCJ0X2xhenkiLCJtYXBpIiwiZm9sZGluZ19tYXAiLCJmb2xkaW5nX21hcGkiLCJmaWx0ZXIiLCJmaWx0ZXJpIiwibGVuZ3RoIiwidG9fYXJyYXkiLCJsZW4iLCJmaW5kIiwiZmluZF9tYXAiLCJzb21lX2IiLCJmaW5kX21hcGkiLCJmb3JfYWxsIiwiZm9yX2FsbGkiLCJleGlzdHMiLCJleGlzdHNpIiwiaXRlciIsImlzX2VtcHR5IiwibWVtIiwiZXF1YWwiLCJiIiwiZW1wdHkiLCJiaW5kIiwicmVzdCIsInJldHVybiQiLCJtYXAiLCJpbmNsdWRlIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiTW9uYWRfaW5maXgiLCJqb2luIiwiaWdub3JlX20iLCJhbGwiLCJhbGxfdW5pdCIsIkxldF9zeW50YXgiLCJjc3RfaGRfZXhuIiwiY3N0X1NlcXVlbmNlX3RsX2V4biIsImNzdF9TZXF1ZW5jZV9jaHVua3NfZXhuIiwiY3N0X1NlcXVlbmNlX2ZpbmRfZXhuIiwiY3N0X1NlcXVlbmNlX3JlZHVjZV9leG4iLCJjc3RfU2VxdWVuY2Vfc3ViIiwiY3N0X1NlcXVlbmNlX3Rha2UiLCJjc3RfU2VxdWVuY2VfZHJvcCIsIm50aCIsIm4iLCJudGhfZXhuIiwiY29tcGFyZV9sb2NhbCIsImNtcF9hIiwiY21wX2IiLCJhXzAyMyIsImJfMDI0IiwiYV8wMjUiLCJiXzAyNiIsImFfMDI3IiwiYl8wMjgiLCJhXzAzMSIsImFfMDI5IiwiYl8wMzIiLCJiXzAzMCIsImNvbXBhcmUiLCJhXzAxMyIsImJfMDE0IiwiYV8wMTUiLCJiXzAxNiIsImFfMDE3IiwiYl8wMTgiLCJhXzAyMSIsImFfMDE5IiwiYl8wMjIiLCJiXzAyMCIsImVxdWFsX2xvY2FsIiwiYV8wNDMiLCJiXzA0NCIsImFfMDQ1IiwiYl8wNDYiLCJhXzA0NyIsImJfMDQ4IiwiYV8wNTEiLCJhXzA0OSIsImJfMDUyIiwiYl8wNTAiLCJhXzAzMyIsImJfMDM0IiwiYV8wMzUiLCJiXzAzNiIsImFfMDM3IiwiYl8wMzgiLCJhXzA0MSIsImFfMDM5IiwiYl8wNDIiLCJiXzA0MCIsImhhc2hfZm9sZF90IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsImhzdiIsImFyZyIsInRfb2Zfc2V4cCIsIm9mX2FfMDUzIiwib2ZfYl8wNTQiLCJzZXhwXzA1OSIsInRhZ18wNjAiLCJzZXhwX2FyZ3NfMDY2IiwiYXJnMF8wNjciLCJyZXMwXzA2OCIsInNleHBfYXJnc18wNjEiLCJhcmcwXzA2MiIsInJlczBfMDYzIiwic2V4cF9hcmdzXzA3MSIsImFyZzFfMDczIiwiYXJnMF8wNzIiLCJyZXMwXzA3NCIsInJlczFfMDc1Iiwib2ZfYV8wNzgiLCJvZl9iXzA3OSIsImFyZzBfMDgwIiwicmVzMF8wODEiLCJhcmcwXzA4MiIsInJlczBfMDgzIiwiYXJnMV8wODUiLCJhcmcwXzA4NCIsInJlczBfMDg2IiwicmVzMV8wODciLCJ0X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJtZXJnZV93aXRoX2R1cGxpY2F0ZXMiLCJuZXh0MiIsInMyIiwibmV4dDEiLCJzMSIsImNvbXBhcmlzb24iLCJtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWQiLCJtZXJnZV9zb3J0ZWQiLCJoZCIsImhkX2V4biIsInRsIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiZmlsdGVyX29wdCIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwaSIsInNwbGl0X24iLCJhY2N1bSIsImNodW5rc19leG4iLCJ4cyIsImZpbmRpIiwiZmluZF9leG4iLCJhcHBlbmQiLCJjb25jYXRfbWFwIiwiY29uY2F0IiwiY29uY2F0X21hcGkiLCJ6aXAiLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwibWF4IiwibWluIiwiaXRlcmkiLCJmb2xkaSIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZXMiLCJncm91cCIsImJyZWFrJCIsImN1ciIsInByZXYiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsImxhc3RfZWx0IiwicmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMiLCJjb3VudCIsImVsdCIsImNvdW50aSIsInN1bSIsIm0iLCJtaW5fZWx0IiwibWF4X2VsdCIsInN1YiIsInBvcyIsInRha2UiLCJkcm9wIiwidGFrZV93aGlsZSIsImRyb3Bfd2hpbGUiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCIsIkluZml4IiwiY3N0X1NlcXVlbmNlX2N5Y2xlX2xpc3RfZXhuIiwiY3N0X0J1Z19UaGlzX2JyYW5jaF9zaG91bGRfYmVfIiwiaW50ZXJzcGVyc2UiLCJzZXAiLCJyZXBlYXQiLCJjeWNsZV9saXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0Iiwic2EiLCJzYiIsInNpbmdsZXRvbiIsImRlbGF5ZWRfZm9sZCIsIm9wdGlvbiIsImsiLCJmb2xkX20iLCJpdGVyX20iLCJmb2xkX3VudGlsIiwiZm9sZF9yZXN1bHQiLCJlIiwiZm9yY2VfZWFnZXJseSIsIm1lbW9pemUiLCJkcm9wX2VhZ2VybHkiLCJkcm9wX3doaWxlX29wdGlvbiIsInNraXBfbG9vcCIsImNvbXBhcmVfYSIsIm5leHRfciIsInNfciIsIm5leHRfbCIsInNfbCIsImMiLCJjb21wYXJlX2FfbG9jYWwiLCJ0MSIsInQyIiwiZXF1YWxfYSIsImVxdWFsX2FfbG9jYWwiLCJyb3VuZF9yb2JpbiIsImxpc3QiLCJkb25lX3N0YWNrIiwidG9kb19zdGFjayIsImludGVybGVhdmUiLCJmMSIsImYyIiwiaW50ZXJsZWF2ZWRfY2FydGVzaWFuX3Byb2R1Y3QiLCJ4MSIsIngyIiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkIiwidG9fc3RlcHMiLCJvZl9zZXF1ZW5jZSIsInNlcXVlbmNlIiwicnVuIiwidGh1bmsiLCJCYXNlX1NlcXVlbmNlIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEdm1CSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2Mjc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3NleHBhYmxlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlXG5cbm1vZHVsZSBPZl9zZXhwYWJsZVxuICAoU2V4cGFibGUgOiBTKSAoTSA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIHRvX3NleHBhYmxlIDogdCAtPiBTZXhwYWJsZS50XG4gICAgdmFsIG9mX3NleHBhYmxlIDogU2V4cGFibGUudCAtPiB0XG4gIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTFcbiAgKFNleHBhYmxlIDogUzEpIChNIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdG9fc2V4cGFibGUgOiAnYSB0IC0+ICdhIFNleHBhYmxlLnRcbiAgICB2YWwgb2Zfc2V4cGFibGUgOiAnYSBTZXhwYWJsZS50IC0+ICdhIHRcbiAgZW5kKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2EgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUyXG4gIChTZXhwYWJsZSA6IFMyKSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBTZXhwYWJsZS50XG4gICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYikgU2V4cGFibGUudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlM1xuICAoU2V4cGFibGUgOiBTMykgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgU2V4cGFibGUudFxuICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IsICdjKSB0XG4gIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3N0cmluZ2FibGUgKE0gOiBTdHJpbmdhYmxlLlMpIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcbndpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5BdG9tIHMgLT5cbiAgICAgICh0cnkgTS5vZl9zdHJpbmcgcyB3aXRoXG4gICAgICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHApXG4gICAgfCBTZXhwLkxpc3QgXyAtPlxuICAgICAgb2Zfc2V4cF9lcnJvclxuICAgICAgICBcIlNleHBhYmxlLk9mX3N0cmluZ2FibGUudF9vZl9zZXhwIGV4cGVjdGVkIGFuIGF0b20sIGJ1dCBnb3QgYSBsaXN0XCJcbiAgICAgICAgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAoTS50b19zdHJpbmcgdClcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOiBNLnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2Ugc3RyaW5nX3NleHBfZ3JhbW1hclxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsImNzdF9TZXhwYWJsZV9PZl9zdHJpbmdhYmxlX3RfbyIsIk9mX3NleHBhYmxlIiwiU2V4cGFibGUiLCJNIiwidF9vZl9zZXhwIiwic2V4cCIsInMiLCJleG4iLCJzZXhwX29mX3QiLCJ0IiwiT2Zfc2V4cGFibGUxIiwiYV9vZl9zZXhwIiwic2V4cF9vZl9hIiwiT2Zfc2V4cGFibGUyIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiT2Zfc2V4cGFibGUzIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwiT2Zfc3RyaW5nYWJsZSIsInRfc2V4cF9ncmFtbWFyIiwiQmFzZV9TZXhwYWJsZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsWUFBQUMsVUFBQUM7QUFBQUEsYUFBQUMsVUFBQUM7QUFBQUEsU0FBQUMsSUNXWTtBQUFBLEtBQ1IsWUFBSTtBQUFBLFdBQUFDO0FBQUFBLFVBQUFBLE1EWlI7QUFBQSxNQ2FhLDZDQUEwQjtBQUFBO0FBQUE7QUFBQSxhQUFBQyxVQUFBQztBQUFBQSxTQUFBLElBR0E7QUFBQSxLQUFpQjtBQUFBO0FBQUEsSURoQnhEO0FBQUE7QUFBQSxZQUFBQyxhQUFBUixVQUFBQztBQUFBQSxhQUFBQyxVQUFBTyxXQUFBTjtBQUFBQSxTQUFBQyxJQzJCWTtBQUFBLEtBQ1IsWUFBSTtBQUFBLFdBQUFDO0FBQUFBLFVBQUFBLE1ENUJSO0FBQUEsTUM2QmEsNkNBQTBCO0FBQUE7QUFBQTtBQUFBLGFBQUFDLFVBQUFJLFdBQUFIO0FBQUFBLFNBQUEsSUFHb0I7QUFBQSxLQUFpQjtBQUFBO0FBQUEsSURoQzVFO0FBQUE7QUFBQSxZQUFBSSxhQUFBWCxVQUFBQztBQUFBQSxhQUFBQyxVQUFBTyxXQUFBRyxXQUFBVDtBQUFBQSxTQUFBQyxJQzJDWTtBQUFBLEtBQ1IsWUFBSTtBQUFBLFdBQUFDO0FBQUFBLFVBQUFBLE1ENUNSO0FBQUEsTUM2Q2EsNkNBQTBCO0FBQUE7QUFBQTtBQUFBLGFBQUFDLFVBQUFJLFdBQUFHLFdBQUFOO0FBQUFBLFNBQUEsSUFJSTtBQUFBLEtBQWlCO0FBQUE7QUFBQSxJRGpENUQ7QUFBQTtBQUFBLFlBQUFPLGFBQUFkLFVBQUFDO0FBQUFBLGFBQUFDLFVBQUFPLFdBQUFHLFdBQUFHLFdBQUFaO0FBQUFBLFNBQUFDLElDNkRZO0FBQUEsS0FDUixZQUFJO0FBQUEsV0FBQUM7QUFBQUEsVUFBQUEsTUQ5RFI7QUFBQSxNQytEYSw2Q0FBMEI7QUFBQTtBQUFBO0FBQUEsYUFBQUMsVUFBQUksV0FBQUcsV0FBQUcsV0FBQVQ7QUFBQUEsU0FBQSxJQUljO0FBQUEsS0FBaUI7QUFBQTtBQUFBLElEbkV0RTtBQUFBO0FBQUEsWUFBQVUsY0FBQWhCO0FBQUFBLGFBQUFDLFVBQUFDO0FBQUFBLEtDa0ZJO0FBQUEsTUFLRSx3RUFFTTtBQUFBLFNBQUFDLElBUFI7QUFBQSxLQUVFLFlBQUs7QUFBQSxXQUFBQztBQUFBQSxVQUFBQSxNRHBGWDtBQUFBLE1DcUZnQiw2Q0FJSjtBQUFBO0FBQUE7QUFBQSxhQUFBQyxVQUFBQyxHQUdrQiwrQkFBZTtBQUFBO0FBQUEsS0FBQVcsaUJBR3pDO0FBQUEsSUFBZ0Q7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQvRnBEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTY0MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYXJyYXkubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbnR5cGUgJ2EgdCA9ICdhIGFycmF5IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9hcnJheV9fbG9jYWxcbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX2FycmF5XG5cbmxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDA5XykgOiAoKGFfXzAwOV8gLT4gYV9fMDA5XykgLT4gYV9fMDA5XyB0IC0+IGFfXzAwOV8gdCkgLT4gZ2xvYmFsaXplX2FycmF5XG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gYXJyYXlfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfYXJyYXlcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBhcnJheV9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxuKCogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBhIG5ldyBpbi1wbGFjZSwgY29uc3RhbnQgaGVhcCBzb3J0aW5nIGFsZ29yaXRobSB0byByZXBsYWNlIHRoZVxuICAgb25lIHVzZWQgYnkgdGhlIHN0YW5kYXJkIGxpYnJhcmllcy4gIEl0cyBvbmx5IHB1cnBvc2UgaXMgdG8gYmUgZmFzdGVyIChob3BlZnVsbHlcbiAgIHN0cmljdGx5IGZhc3RlcikgdGhhbiB0aGUgYmFzZSBzb3J0IGFuZCBzdGFibGVfc29ydC5cblxuICAgQXQgYSBoaWdoIGxldmVsIHRoZSBhbGdvcml0aG0gaXM6XG4gICAtIHBpY2sgdHdvIHBpdm90IHBvaW50cyBieTpcbiAgIC0gcGljayA1IGFyYml0cmFyeSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheVxuICAgLSBzb3J0IHRoZW0gd2l0aGluIHRoZSBhcnJheVxuICAgLSB0YWtlIHRoZSBlbGVtZW50cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgbWlkZGxlIGVsZW1lbnQgb2YgdGhlIHNvcnQgYXMgdGhlIHBpdm90c1xuICAgLSBzb3J0IHRoZSBhcnJheSB3aXRoOlxuICAgLSBhbGwgZWxlbWVudHMgbGVzcyB0aGFuIHBpdm90MSB0byB0aGUgbGVmdCAocmFuZ2UgMSlcbiAgIC0gYWxsIGVsZW1lbnRzID49IHBpdm90MSBhbmQgPD0gcGl2b3QyIGluIHRoZSBtaWRkbGUgKHJhbmdlIDIpXG4gICAtIGFsbCBlbGVtZW50cyA+IHBpdm90MiB0byB0aGUgcmlnaHQgKHJhbmdlIDMpXG4gICAtIGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSBlcXVhbCwgdGhlbiB0aGUgbWlkZGxlIHJhbmdlIGlzIHNvcnRlZCwgc28gaWdub3JlIGl0XG4gICAtIHJlY3Vyc2UgaW50byByYW5nZSAxLCAyIChpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgdW5lcXVhbCksIGFuZCAzXG4gICAtIGR1cmluZyByZWN1cnNpb24gdGhlcmUgYXJlIHR3byBpbmZsZWN0aW9uIHBvaW50czpcbiAgIC0gaWYgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgcmFuZ2UgaXMgc21hbGwsIHVzZSBpbnNlcnRpb24gc29ydCB0byBzb3J0IGl0XG4gICAtIGlmIHRoZSBzdGFjayBkZXB0aCBpcyBsYXJnZSwgc29ydCB0aGUgcmFuZ2Ugd2l0aCBoZWFwLXNvcnQgdG8gYXZvaWQgbl4yIHdvcnN0LWNhc2VcbiAgICAgYmVoYXZpb3JcblxuICAgU2VlIHRoZSBmb2xsb3dpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb246XG4gICAtIFwiRHVhbC1QaXZvdCBRdWlja3NvcnRcIiBieSBWbGFkaW1pciBZYXJvc2xhdnNraXkuXG4gICAgIEF2YWlsYWJsZSBhdFxuICAgICBodHRwOi8vd3d3LmtyaWNoZS5jb20uYXIvcm9vdC9wcm9ncmFtbWluZy9zcGFjZVRpbWVDb21wbGV4aXR5L0R1YWxQaXZvdFF1aWNrc29ydC5wZGZcbiAgIC0gXCJRdWlja3NvcnQgaXMgT3B0aW1hbFwiIGJ5IFNlZGdld2ljayBhbmQgQmVudGxleS5cbiAgICAgU2xpZGVzIGF0IGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+cnMvdGFsa3MvUXVpY2tzb3J0SXNPcHRpbWFsLnBkZlxuICAgLSBodHRwOi8vd3d3LnNvcnRpbmctYWxnb3JpdGhtcy5jb20vcXVpY2stc29ydC0zLXdheSAqKVxuXG5tb2R1bGUgU29ydGVyIChTIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbmVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgU1xuXG4gIGxldCBzd2FwIGFyciBpIGogPVxuICAgIGxldCB0bXAgPSBnZXQgYXJyIGkgaW5cbiAgICBzZXQgYXJyIGkgKGdldCBhcnIgaik7XG4gICAgc2V0IGFyciBqIHRtcFxuICA7O1xuXG4gIG1vZHVsZSB0eXBlIFNvcnQgPSBzaWdcbiAgICB2YWwgc29ydFxuICAgICAgOiAgJ2EgdFxuICAgICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgICAgLT4gbGVmdDppbnQgKCogbGVmdG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHJpZ2h0OmludCAoKiByaWdodG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHVuaXRcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnNlcnRpb25fc29ydCAqKVxuICBtb2R1bGUgSW5zZXJ0aW9uX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgIDEuICB0aGUgc3ViYXJyYXkgYXJyW2xlZnQgLi4gaS0xXSBpcyBzb3J0ZWRcbiAgICAgICAyLiAgdGhlIHN1YmFycmF5IGFycltpKzEgLi4gcG9zXSBpcyBzb3J0ZWQgYW5kIGNvbnRhaW5zIG9ubHkgZWxlbWVudHMgPiB2XG4gICAgICAgMy4gIGFycltpXSBtYXkgYmUgdGhvdWdodCBvZiBhcyBjb250YWluaW5nIHZcbiAgICAqKVxuICAgIGxldCByZWMgaW5zZXJ0X2xvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGkgdiA9XG4gICAgICBsZXQgaV9uZXh0ID0gaSAtIDEgaW5cbiAgICAgIGlmIGlfbmV4dCA+PSBsZWZ0ICYmIGNvbXBhcmUgKGdldCBhcnIgaV9uZXh0KSB2ID4gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHNldCBhcnIgaSAoZ2V0IGFyciBpX25leHQpO1xuICAgICAgICBpbnNlcnRfbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgaV9uZXh0IHYpXG4gICAgICBlbHNlIGlcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICAoKiBsb29wIGludmFyaWFudDpcbiAgICAgICAgIFthcnJdIGlzIHNvcnRlZCBmcm9tIFtsZWZ0XSB0byBbcG9zIC0gMV0sIGluY2x1c2l2ZSAqKVxuICAgICAgZm9yIHBvcyA9IGxlZnQgKyAxIHRvIHJpZ2h0IGRvXG4gICAgICAgIGxldCB2ID0gZ2V0IGFyciBwb3MgaW5cbiAgICAgICAgbGV0IGZpbmFsX3BvcyA9IGluc2VydF9sb29wIGFyciB+bGVmdCB+Y29tcGFyZSBwb3MgdiBpblxuICAgICAgICBzZXQgYXJyIGZpbmFsX3BvcyB2XG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwc29ydCAqKVxuICBtb2R1bGUgSGVhcF9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgIHJvb3QncyBjaGlsZHJlbiBhcmUgYm90aCBlaXRoZXIgcm9vdHMgb2YgbWF4LWhlYXBzIG9yID4gcmlnaHQgKilcbiAgICBsZXQgcmVjIGhlYXBpZnkgYXJyIH5jb21wYXJlIHJvb3QgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCByZWxhdGl2ZV9yb290ID0gcm9vdCAtIGxlZnQgaW5cbiAgICAgIGxldCBsZWZ0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAxIGluXG4gICAgICBsZXQgcmlnaHRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDIgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgbGVmdF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIGxlZnRfY2hpbGQpIChnZXQgYXJyIHJvb3QpID4gMFxuICAgICAgICB0aGVuIGxlZnRfY2hpbGRcbiAgICAgICAgZWxzZSByb290XG4gICAgICBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiByaWdodF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIHJpZ2h0X2NoaWxkKSAoZ2V0IGFyciBsYXJnZXN0KSA+IDBcbiAgICAgICAgdGhlbiByaWdodF9jaGlsZFxuICAgICAgICBlbHNlIGxhcmdlc3RcbiAgICAgIGluXG4gICAgICBpZiBsYXJnZXN0IDw+IHJvb3RcbiAgICAgIHRoZW4gKFxuICAgICAgICBzd2FwIGFyciByb290IGxhcmdlc3Q7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxhcmdlc3QgfmxlZnQgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIEVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgYXJyYXkgYXJlIGFscmVhZHkgaGVhcHMgb2Ygc2l6ZSAxLiAgV2UgbW92ZVxuICAgICAgICAgdGhyb3VnaCB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgYXJyYXkgZnJvbSBiYWNrIHRvIGZyb250IGV4YW1pbmluZyB0aGUgZWxlbWVudCBhdFxuICAgICAgICAgaGFuZCwgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZHJlbiwgZml4aW5nIHRoZSBoZWFwIHByb3BlcnR5IGFzIHdlIGdvLiAqKVxuICAgICAgZm9yIGkgPSAobGVmdCArIHJpZ2h0KSAvIDIgZG93bnRvIGxlZnQgZG9cbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgaSB+bGVmdCB+cmlnaHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ7XG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uLiBpXSBpcyBhIG1heC1oZWFwIEhcbiAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLi4gcmlnaHRdIGlzIHNvcnRlZCAoY2FsbCBpdCBTKVxuICAgICAgICAgMy4gIGV2ZXJ5IGVsZW1lbnQgb2YgSCBpcyBsZXNzIHRoYW4gZXZlcnkgZWxlbWVudCBvZiBTICopXG4gICAgICBmb3IgaSA9IHJpZ2h0IGRvd250byBsZWZ0ICsgMSBkb1xuICAgICAgICBzd2FwIGFyciBsZWZ0IGk7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxlZnQgfmxlZnQgfnJpZ2h0OihpIC0gMSlcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludHJvc29ydCAqKVxuICBtb2R1bGUgSW50cm9fc29ydCA6IHNpZ1xuICAgIGluY2x1ZGUgU29ydFxuXG4gICAgdmFsIGZpdmVfZWxlbWVudF9zb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH4oY29tcGFyZSA6IF8gLT4gXyAtPiBfKSBtMSBtMiBtMyBtNCBtNSA9XG4gICAgICBsZXQgY29tcGFyZV9hbmRfc3dhcCBpIGogPVxuICAgICAgICBpZiBjb21wYXJlIChnZXQgYXJyIGkpIChnZXQgYXJyIGopID4gMCB0aGVuIHN3YXAgYXJyIGkgalxuICAgICAgaW5cbiAgICAgICgqIE9wdGltYWwgNS1lbGVtZW50IHNvcnRpbmcgbmV0d29yazpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIDEtLW8tLS0tLW8tLS0tLW8tLS0tLS0tLS0tLS0tLTFcbiAgICAgICAgICAgICAgIHwgICAgIHwgICAgIHxcbiAgICAgICAgICAgIDItLW8tLS0tLXwtLW8tLXwtLS0tLW8tLW8tLS0tLTJcbiAgICAgICAgICAgICAgICAgICAgIHwgIHwgIHwgICAgIHwgIHxcbiAgICAgICAgICAgIDMtLS0tLS0tLW8tLW8tLXwtLW8tLXwtLW8tLS0tLTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHwgIHxcbiAgICAgICAgICAgIDQtLS0tLW8tLS0tLS0tLW8tLW8tLXwtLS0tLW8tLTRcbiAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgIHxcbiAgICAgICAgICAgIDUtLS0tLW8tLS0tLS0tLS0tLS0tLW8tLS0tLW8tLTVcbiAgICAgICAgICB2fSAqKVxuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtMjtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTU7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0zIG00O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG00IG01IFtAbm9udGFpbF1cbiAgICA7O1xuXG4gICAgKCogY2hvb3NlIHBpdm90cyBmb3IgdGhlIGFycmF5IGJ5IHNvcnRpbmcgNSBlbGVtZW50cyBhbmQgZXhhbWluaW5nIHRoZSBjZW50ZXIgdGhyZWVcbiAgICAgICBlbGVtZW50cy4gIFRoZSBnb2FsIGlzIHRvIGNob29zZSB0d28gcGl2b3RzIHRoYXQgd2lsbCBlaXRoZXI6XG4gICAgICAgLSBicmVhayB0aGUgcmFuZ2UgdXAgaW50byAzIGV2ZW4gcGFydGl0aW9uc1xuICAgICAgICAgb3JcbiAgICAgICAtIGVsaW1pbmF0ZSBhIGNvbW1vbmx5IGFwcGVhcmluZyBlbGVtZW50IGJ5IHNvcnRpbmcgaXQgaW50byB0aGUgY2VudGVyIHBhcnRpdGlvblxuICAgICAgICAgYnkgaXRzZWxmXG4gICAgICAgICBUbyB0aGlzIGVuZCB3ZSBsb29rIGF0IHRoZSBjZW50ZXIgMyBlbGVtZW50cyBvZiB0aGUgNSBhbmQgcmV0dXJuIHBhaXJzIG9mIGVxdWFsXG4gICAgICAgICBlbGVtZW50cyBvciB0aGUgd2lkZXN0IHJhbmdlICopXG4gICAgbGV0IGNob29zZV9waXZvdHMgYXJyIH4oY29tcGFyZSA6IF8gLT4gXyAtPiBfKSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHNpeHRoID0gKHJpZ2h0IC0gbGVmdCkgLyA2IGluXG4gICAgICBsZXQgbTEgPSBsZWZ0ICsgc2l4dGggaW5cbiAgICAgIGxldCBtMiA9IG0xICsgc2l4dGggaW5cbiAgICAgIGxldCBtMyA9IG0yICsgc2l4dGggaW5cbiAgICAgIGxldCBtNCA9IG0zICsgc2l4dGggaW5cbiAgICAgIGxldCBtNSA9IG00ICsgc2l4dGggaW5cbiAgICAgIGZpdmVfZWxlbWVudF9zb3J0IGFyciB+Y29tcGFyZSBtMSBtMiBtMyBtNCBtNTtcbiAgICAgIGxldCBtMl92YWwgPSBnZXQgYXJyIG0yIGluXG4gICAgICBsZXQgbTNfdmFsID0gZ2V0IGFyciBtMyBpblxuICAgICAgbGV0IG00X3ZhbCA9IGdldCBhcnIgbTQgaW5cbiAgICAgIGlmIGNvbXBhcmUgbTJfdmFsIG0zX3ZhbCA9IDBcbiAgICAgIHRoZW4gbTJfdmFsLCBtM192YWwsIHRydWVcbiAgICAgIGVsc2UgaWYgY29tcGFyZSBtM192YWwgbTRfdmFsID0gMFxuICAgICAgdGhlbiBtM192YWwsIG00X3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBtMl92YWwsIG00X3ZhbCwgZmFsc2VcbiAgICA7O1xuXG4gICAgbGV0IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+KGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBwaXZvdDEsIHBpdm90MiwgcGl2b3RzX2VxdWFsID0gY2hvb3NlX3Bpdm90cyBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgbGVmdCA8PSBsIDwgciA8PSByaWdodFxuICAgICAgICAgMi4gIGwgPD0gcCA8PSByXG4gICAgICAgICAzLiAgbCA8PSB4IDwgcCAgICAgaW1wbGllcyBhcnJbeF0gPj0gcGl2b3QxXG4gICAgICAgICBhbmQgYXJyW3hdIDw9IHBpdm90MlxuICAgICAgICAgNC4gIGxlZnQgPD0geCA8IGwgIGltcGxpZXMgYXJyW3hdIDwgcGl2b3QxXG4gICAgICAgICA1LiAgciA8IHggPD0gcmlnaHQgaW1wbGllcyBhcnJbeF0gPiBwaXZvdDIgKilcbiAgICAgIGxldCByZWMgbG9vcCBsIHAgciA9XG4gICAgICAgIGxldCBwdiA9IGdldCBhcnIgcCBpblxuICAgICAgICBpZiBjb21wYXJlIHB2IHBpdm90MSA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc3dhcCBhcnIgcCBsO1xuICAgICAgICAgIGNvbnQgKGwgKyAxKSAocCArIDEpIHIpXG4gICAgICAgIGVsc2UgaWYgY29tcGFyZSBwdiBwaXZvdDIgPiAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgICgqIGxvb3AgaW52YXJpYW50czogIHNhbWUgYXMgdGhvc2Ugb2YgdGhlIG91dGVyIGxvb3AgKilcbiAgICAgICAgICBsZXQgcmVjIHNjYW5fYmFja3dhcmRzIHIgPVxuICAgICAgICAgICAgaWYgciA+IHAgJiYgY29tcGFyZSAoZ2V0IGFyciByKSBwaXZvdDIgPiAwIHRoZW4gc2Nhbl9iYWNrd2FyZHMgKHIgLSAxKSBlbHNlIHJcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCByID0gc2Nhbl9iYWNrd2FyZHMgciBpblxuICAgICAgICAgIHN3YXAgYXJyIHIgcDtcbiAgICAgICAgICBjb250IGwgcCAociAtIDEpKVxuICAgICAgICBlbHNlIGNvbnQgbCAocCArIDEpIHJcbiAgICAgIGFuZCBjb250IGwgcCByID0gaWYgcCA+IHIgdGhlbiBsLCByIGVsc2UgbG9vcCBsIHAgciBpblxuICAgICAgbGV0IGwsIHIgPSBjb250IGxlZnQgbGVmdCByaWdodCBpblxuICAgICAgbCwgciwgcGl2b3RzX2VxdWFsXG4gICAgOztcblxuICAgIGxldCByZWMgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGxlbiA9IHJpZ2h0IC0gbGVmdCArIDEgaW5cbiAgICAgICgqIFRoaXMgdGFrZXMgY2FyZSBvZiBzb21lIGVkZ2UgY2FzZXMsIHN1Y2ggYXMgbGVmdCA+IHJpZ2h0IG9yIHZlcnkgc2hvcnQgYXJyYXlzLFxuICAgICAgICAgc2luY2UgSW5zZXJ0aW9uX3NvcnQuc29ydCBoYW5kbGVzIHRoZXNlIGNhc2VzIHByb3Blcmx5LiAgVGh1cyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICBtYWtlIHN1cmUgdGhhdCBsZWZ0IGFuZCByaWdodCBhcmUgdmFsaWQgaW4gcmVjdXJzaXZlIGNhbGxzLiAqKVxuICAgICAgaWYgbGVuIDw9IDMyXG4gICAgICB0aGVuIEluc2VydGlvbl9zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgICAgZWxzZSBpZiBtYXhfZGVwdGggPCAwXG4gICAgICB0aGVuIEhlYXBfc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbWF4X2RlcHRoID0gbWF4X2RlcHRoIC0gMSBpblxuICAgICAgICBsZXQgbCwgciwgbWlkZGxlX3NvcnRlZCA9IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgaW5cbiAgICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ6KGwgLSAxKTtcbiAgICAgICAgaWYgbm90IG1pZGRsZV9zb3J0ZWQgdGhlbiBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OmwgfnJpZ2h0OnI7XG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQ6KHIgKyAxKSB+cmlnaHQpXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IGhlYXBfc29ydF9zd2l0Y2hfZGVwdGggPVxuICAgICAgICAoKiBXZSBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXQgYSByZWN1cnNpb24gZGVwdGggb2YgMzIuIEdOVSBpbnRyb3NvcnQgdXNlcyAybGcobikuXG4gICAgICAgICAgIFRoZSBleHBlY3RlZCByZWN1cnNpb24gZGVwdGggZm9yIHBlcmZlY3QgMy13YXkgc3BsaXRzIGlzIGxvZ18zKG4pLlxuXG4gICAgICAgICAgIFVzaW5nIDMyIG1lYW5zIGEgYmFsYW5jZWQgMy13YXkgc3BsaXQgd291bGQgd29yayB1cCB0byAzXjMyIGVsZW1lbnRzIChyb3VnaGx5XG4gICAgICAgICAgIDJeNTAgb3IgMTBeMTUpLiBHTlUgcmVhY2hlcyBhIGRlcHRoIG9mIDMyIGF0IDY1NTM2IGVsZW1lbnRzLlxuXG4gICAgICAgICAgIEZvciBzbWFsbCBhcnJheXMsIHRoaXMgbWFrZXMgdXMgbGVzcyBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0LCBidXQgdGhlXG4gICAgICAgICAgIDMyKk4gY29zdCBiZWZvcmUgd2UgZG8gaXMgbm90IHRoYXQgbXVjaC5cblxuICAgICAgICAgICBGb3IgbGFyZ2UgYXJyYXlzLCB0aGlzIG1lYW5zIHdlIGFyZSBtb3JlIGxpa2VseSB0byBiYWlsIG91dCB0byBoZWFwIHNvcnQgYXRcbiAgICAgICAgICAgc29tZSBwb2ludCBpZiB3ZSBnZXQgc29tZSBiYWQgc3BsaXRzIG9yIGlmIHRoZSBhcnJheSBpcyBodWdlLiBCdXQgdGhhdCdzIG9ubHkgYVxuICAgICAgICAgICBjb25zdGFudCBmYWN0b3IgY29zdCBpbiB0aGUgZmluYWwgc3RhZ2VzIG9mIHJlY3Vyc2lvbi5cblxuICAgICAgICAgICBBbGwgaW4gYWxsLCB0aGlzIHNlZW1zIHRvIGJlIGEgc21hbGwgdHJhZGVvZmYgYW5kIGF2b2lkcyBwYXlpbmcgYSBjb3N0IHRvXG4gICAgICAgICAgIGNvbXB1dGUgYSBsb2dhcml0aG0gYXQgdGhlIHN0YXJ0LiAqKVxuICAgICAgICAzMlxuICAgICAgaW5cbiAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGg6aGVhcF9zb3J0X3N3aXRjaF9kZXB0aCB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc29ydCA/cG9zID9sZW4gYXJyIH4oY29tcGFyZSA6IF8gLT4gXyAtPiBfKSA9XG4gICAgbGV0IHBvcywgbGVuID1cbiAgICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggYXJyKVxuICAgIGluXG4gICAgSW50cm9fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdDpwb3MgfnJpZ2h0Oihwb3MgKyBsZW4gLSAxKVxuICA7O1xuZW5kXG5bQEBpbmxpbmVdXG5cbm1vZHVsZSBTb3J0ID0gU29ydGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldFxuICBsZXQgc2V0ID0gdW5zYWZlX3NldFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5lbmQpXG5cbmxldCBzb3J0ID0gU29ydC5zb3J0XG5sZXQgb2ZfYXJyYXkgdCA9IHRcbmxldCB0b19hcnJheSB0ID0gdFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGlzX3NvcnRlZCB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPiAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+PSAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVyZ2UgYTEgYTIgfmNvbXBhcmUgPVxuICBsZXQgbDEgPSBBcnJheS5sZW5ndGggYTEgaW5cbiAgbGV0IGwyID0gQXJyYXkubGVuZ3RoIGEyIGluXG4gIGlmIGwxID0gMFxuICB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsMiA9IDBcbiAgdGhlbiBjb3B5IGExXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMiAwKSAodW5zYWZlX2dldCBhMSAobDEgLSAxKSkgPj0gMFxuICB0aGVuIGFwcGVuZCBhMSBhMlxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgMCkgKHVuc2FmZV9nZXQgYTIgKGwyIC0gMSkpID4gMFxuICB0aGVuIGFwcGVuZCBhMiBhMVxuICBlbHNlIChcbiAgICBsZXQgbGVuID0gbDEgKyBsMiBpblxuICAgIGxldCBtZXJnZWQgPSBjcmVhdGUgfmxlbiAodW5zYWZlX2dldCBhMSAwKSBpblxuICAgIGxldCBhMV9pbmRleCA9IHJlZiAwIGluXG4gICAgbGV0IGEyX2luZGV4ID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IHVzZV9hMSA9XG4gICAgICAgIGlmIGwxID0gIWExX2luZGV4XG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiBsMiA9ICFhMl9pbmRleFxuICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgZWxzZSBjb21wYXJlICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KSA8PSAwXG4gICAgICBpblxuICAgICAgaWYgdXNlX2ExXG4gICAgICB0aGVuIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpO1xuICAgICAgICBhMV9pbmRleCA6PSAhYTFfaW5kZXggKyAxKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KTtcbiAgICAgICAgYTJfaW5kZXggOj0gIWEyX2luZGV4ICsgMSlcbiAgICBkb25lO1xuICAgIG1lcmdlZClcbjs7XG5cbmxldCBjb3B5X21hdHJpeCA9IG1hcCB+Zjpjb3B5XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcCB0IH5mOihmdW4geCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBleHRyZW1hbF9lbGVtZW50IHQgfmNvbXBhcmUgfmtlZXBfbGVmdF9pZiA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZXN1bHQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIGZvciBpID0gMSB0byBsZW5ndGggdCAtIDEgZG9cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgICAgIHJlc3VsdCA6PSBCb29sLnNlbGVjdCAoKGtlZXBfbGVmdF9pZiBbQGlubGluZWRdKSAoY29tcGFyZSB4ICFyZXN1bHQpKSB4ICFyZXN1bHRcbiAgICBkb25lO1xuICAgIFNvbWUgIXJlc3VsdClcbjs7XG5cbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPVxuICAoZXh0cmVtYWxfZWxlbWVudCBbQGlubGluZWRdKSB0IH5jb21wYXJlIH5rZWVwX2xlZnRfaWY6KGZ1biBjb21wYXJlX3Jlc3VsdCAtPlxuICAgIGNvbXBhcmVfcmVzdWx0IDwgMClcbjs7XG5cbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPVxuICAoZXh0cmVtYWxfZWxlbWVudCBbQGlubGluZWRdKSB0IH5jb21wYXJlIH5rZWVwX2xlZnRfaWY6KGZ1biBjb21wYXJlX3Jlc3VsdCAtPlxuICAgIGNvbXBhcmVfcmVzdWx0ID4gMClcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGxldCByZXN1bHQgPVxuICAgIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBsZXQgcmVzdWx0ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0IC0gMSBkb1xuICAgIHJlc3VsdCA6PSAhcmVzdWx0ICsgKGYgKEFycmF5LnVuc2FmZV9nZXQgdCBpKSB8PiBCb29sLnRvX2ludClcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGNvdW50aSB0IH5mID1cbiAgbGV0IHJlc3VsdCA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdCAtIDEgZG9cbiAgICByZXN1bHQgOj0gIXJlc3VsdCArIChmIGkgKEFycmF5LnVuc2FmZV9nZXQgdCBpKSB8PiBCb29sLnRvX2ludClcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwIH5mIHQpKVxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcGkgfmYgdCkpXG5cbmxldCByZXZfaW5wbGFjZSB0ID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICB3aGlsZSAhaSA8ICFqIGRvXG4gICAgc3dhcCB0ICFpICFqO1xuICAgIGluY3IgaTtcbiAgICBkZWNyIGpcbiAgZG9uZVxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IHQgPSBjb3B5IHQgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IG9mX2xpc3RfcmV2IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgYSA6OiBsIC0+XG4gICAgbGV0IGxlbiA9IDEgKyBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbiBhIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgICgqIFdlIHN0YXJ0IGF0IFtsZW4gLSAyXSBiZWNhdXNlIHdlIGFscmVhZHkgcHV0IFthXSBhdCBbdC4obGVuIC0gMSldLiAqKVxuICAgIGZvciBpID0gbGVuIC0gMiBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIHQuKGkpIDwtIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgdFxuOztcblxuKCogW29mX2xpc3RfbWFwXSBhbmQgW29mX2xpc3RfcmV2X21hcF0gYXJlIGJhc2VkIG9uIGZ1bmN0aW9ucyBmcm9tIHRoZSBPQ2FtbFxuICAgZGlzdHJpYnV0aW9uLiAqKVxuXG5sZXQgb2ZfbGlzdF9tYXAgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaGQpO1xuICAgICAgICBmaWxsIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgMSB0bCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgb2ZfbGlzdF9tYXBpIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgMCBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgYSBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICB1bnNhZmVfc2V0IGEgaSAoZiBpIGhkKTtcbiAgICAgICAgZmlsbCBhIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgYSAxIHRsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXAgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXBpIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcGkgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBbfHxdIGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgW3x8XVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSkgW0Bub250YWlsXVxubGV0IGZpbHRlcl9vcHQgdCA9IGZpbHRlcl9tYXAgdCB+ZjpGbi5pZFxuXG5sZXQgcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjIgPVxuICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiAoKVxuICBbQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDJfZXhuIG5hbWUgdDEgdDIgPVxuICBsZXQgbjEgPSBsZW5ndGggdDEgaW5cbiAgbGV0IG4yID0gbGVuZ3RoIHQyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjJcbjs7XG5cbmxldCBpdGVyMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5Lml0ZXIyX2V4blwiIHQxIHQyO1xuICBpdGVyaSB0MSB+ZjooZnVuIGkgeDEgLT4gZiB4MSAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5tYXAyX2V4blwiIHQxIHQyO1xuICBpbml0IChsZW5ndGggdDEpIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZDJfZXhuIHQxIHQyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb2xkMl9leG5cIiB0MSB0MjtcbiAgZm9sZGkgdDEgfmluaXQgfmY6KGZ1biBpIGFjIHggLT4gZiBhYyB4ICh1bnNhZmVfZ2V0IHQyIGkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSkgW0Bub250YWlsXVxuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHMyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZXhpc3RzMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsMl9sb2NhbF9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvcl9hbGwyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbDJfZXhuIHQxIHQyIH5mID0gZm9yX2FsbDJfbG9jYWxfZXhuIHQxIHQyIH5mXG5sZXQgZXF1YWxfX2xvY2FsIGVxdWFsIHQxIHQyID0gbGVuZ3RoIHQxID0gbGVuZ3RoIHQyICYmIGZvcl9hbGwyX2xvY2FsX2V4biB0MSB0MiB+ZjplcXVhbFxubGV0IGVxdWFsIGVxdWFsIHQxIHQyID0gZXF1YWxfX2xvY2FsIGVxdWFsIHQxIHQyXG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZmluZGlfaW50ZXJuYWwgdCB+ZiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gaWZfbm90X2ZvdW5kICgpXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlIChub3QgIWZvdW5kKSAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBmICFpIHZhbHVlXG4gICAgICB0aGVuIChcbiAgICAgICAgdmFsdWVfZm91bmQgOj0gdmFsdWU7XG4gICAgICAgIGZvdW5kIDo9IHRydWUpXG4gICAgICBlbHNlIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgIWZvdW5kIHRoZW4gaWZfZm91bmQgfmk6IWkgfnZhbHVlOiF2YWx1ZV9mb3VuZCBlbHNlIGlmX25vdF9mb3VuZCAoKSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gU29tZSAoaSwgdmFsdWUpKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKVxuOztcblxubGV0IGZpbmRpX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gaSwgdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmY6KGZ1biBfaSB4IC0+IGYgeClcbiAgICB+aWZfZm91bmQ6KGZ1biB+aTpfIH52YWx1ZSAtPiB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9leG46IG5vdCBmb3VuZFwiKSkpXG4gIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIHQgfmYgPSBPcHRpb24ubWFwIChmaW5kaSB0IH5mOihmdW4gX2kgeCAtPiBmIHgpKSB+ZjooZnVuIChfaSwgeCkgLT4geClcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgIWkgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA8PSAxXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVzdWx0ID0gcmVmIE5vbmUgaW5cbiAgICBsZXQgaSA9IHJlZiAxIGluXG4gICAgbGV0IHByZXYgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGN1ciA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZXF1YWwgY3VyICFwcmV2XG4gICAgICB0aGVuIChcbiAgICAgICAgcmVzdWx0IDo9IFNvbWUgKCFwcmV2LCBjdXIpO1xuICAgICAgICBpIDo9IG4pXG4gICAgICBlbHNlIChcbiAgICAgICAgcHJldiA6PSBjdXI7XG4gICAgICAgIGluY3IgaSlcbiAgICBkb25lO1xuICAgICFyZXN1bHQpXG47O1xuXG5sZXQgcmVkdWNlIHQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICAgIGRvbmU7XG4gICAgU29tZSAhcilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHQgfmYgPVxuICBtYXRjaCByZWR1Y2UgdCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcGVybXV0ZSA9IEFycmF5X3Blcm11dGUucGVybXV0ZVxuXG5sZXQgcmFuZG9tX2VsZW1lbnRfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS5yYW5kb21fZWxlbWVudF9leG46IGVtcHR5IGFycmF5XCJcbiAgZWxzZSB0LihSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAobGVuZ3RoIHQpKVxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICB0cnkgU29tZSAocmFuZG9tX2VsZW1lbnRfZXhuIH5yYW5kb21fc3RhdGUgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHppcCB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDIgdGhlbiBOb25lIGVsc2UgU29tZSAobWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpKVxuOztcblxubGV0IHppcF9leG4gdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyXG4gIHRoZW4gZmFpbHdpdGggXCJBcnJheS56aXBfZXhuXCJcbiAgZWxzZSBtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4Milcbjs7XG5cbmxldCB1bnppcCB0ID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuID0gMFxuICB0aGVuIFt8fF0sIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHgsIHkgPSB0LigwKSBpblxuICAgIGxldCByZXMxID0gY3JlYXRlIH5sZW46biB4IGluXG4gICAgbGV0IHJlczIgPSBjcmVhdGUgfmxlbjpuIHkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCB4LCB5ID0gdC4oaSkgaW5cbiAgICAgIHJlczEuKGkpIDwtIHg7XG4gICAgICByZXMyLihpKSA8LSB5XG4gICAgZG9uZTtcbiAgICByZXMxLCByZXMyKVxuOztcblxubGV0IHNvcnRlZF9jb3B5IHQgfmNvbXBhcmUgPVxuICBsZXQgdDEgPSBjb3B5IHQgaW5cbiAgc29ydCB0MSB+Y29tcGFyZTtcbiAgdDFcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgbGV0IChib3RoIDogXyBFaXRoZXIudCB0KSA9IG1hcGkgdCB+ZiBpblxuICBsZXQgZmlyc3RzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IHggLT4gU29tZSB4XG4gICAgICB8IFNlY29uZCBfIC0+IE5vbmUpXG4gIGluXG4gIGxldCBzZWNvbmRzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IF8gLT4gTm9uZVxuICAgICAgfCBTZWNvbmQgeCAtPiBTb21lIHgpXG4gIGluXG4gIGZpcnN0cywgc2Vjb25kc1xuOztcblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBGaXJzdCB4IGVsc2UgU2Vjb25kIHgpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gXyB4IC0+IGYgeCkgW0Bub250YWlsXVxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gXyB4IC0+IGYgeCkgW0Bub250YWlsXVxubGV0IGxhc3QgdCA9IHQuKGxlbmd0aCB0IC0gMSlcblxuKCogQ29udmVydCB0byBhIHNlcXVlbmNlIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHByb3RlY3QgYWdhaW5zdCBtb2RpZmljYXRpb25cbiAgIGluIHRoZSBhcnJheS4gKilcbmxldCB0b19zZXF1ZW5jZV9tdXRhYmxlIHQgPVxuICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gaSAtPlxuICAgIGlmIGkgPj0gbGVuZ3RoIHRcbiAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gdC4oaSk7IHN0YXRlID0gaSArIDEgfSlcbjs7XG5cbmxldCB0b19zZXF1ZW5jZSB0ID0gdG9fc2VxdWVuY2VfbXV0YWJsZSAoY29weSB0KVxuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgdDEgdDIgPVxuICBpZiBpc19lbXB0eSB0MSB8fCBpc19lbXB0eSB0MlxuICB0aGVuIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gICAgbGV0IG4yID0gbGVuZ3RoIHQyIGluXG4gICAgbGV0IHQgPSBjcmVhdGUgfmxlbjoobjEgKiBuMikgKHQxLigwKSwgdDIuKDApKSBpblxuICAgIGxldCByID0gcmVmIDAgaW5cbiAgICBmb3IgaTEgPSAwIHRvIG4xIC0gMSBkb1xuICAgICAgZm9yIGkyID0gMCB0byBuMiAtIDEgZG9cbiAgICAgICAgdC4oIXIpIDwtIHQxLihpMSksIHQyLihpMik7XG4gICAgICAgIGluY3IgclxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgdClcbjs7XG5cbmxldCB0cmFuc3Bvc2UgdHQgPVxuICBpZiBsZW5ndGggdHQgPSAwXG4gIHRoZW4gU29tZSBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB3aWR0aCA9IGxlbmd0aCB0dCBpblxuICAgIGxldCBkZXB0aCA9IGxlbmd0aCB0dC4oMCkgaW5cbiAgICBpZiBleGlzdHMgdHQgfmY6KGZ1biB0IC0+IGxlbmd0aCB0IDw+IGRlcHRoKVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgU29tZSAoaW5pdCBkZXB0aCB+ZjooZnVuIGQgLT4gaW5pdCB3aWR0aCB+ZjooZnVuIHcgLT4gdHQuKHcpLihkKSkpKSlcbjs7XG5cbmxldCB0cmFuc3Bvc2VfZXhuIHR0ID1cbiAgbWF0Y2ggdHJhbnNwb3NlIHR0IHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkudHJhbnNwb3NlX2V4blwiXG4gIHwgU29tZSB0dCcgLT4gdHQnXG47O1xuXG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlLk1ha2UxIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgZ2V0ID0gZ2V0XG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbmVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5cbiAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gW3x8XVxuICAgIGVsc2UgKFxuICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgY3JlYXRlIH5sZW4gdC4oMCkpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbmVuZClcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gaXRlciB0IH5mOmludmFyaWFudF9hXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBTb3J0ID0gU29ydFxuICBtb2R1bGUgU29ydGVyID0gU29ydGVyXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3NyY19hcnJheV9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NlcXVlbmNlIiwiQmFzZV9SYW5kb20iLCJCYXNlX09wdGlvbiIsIkJhc2VfTGlzdCIsIkJhc2VfQm9vbCIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiQmFzZV9BcnJheTAiLCJCYXNlX0FycmF5X3Blcm11dGUiLCJCYXNlX0JpbmFyeV9zZWFyY2hhYmxlIiwiQmFzZV9CbGl0IiwiaW52YWxpZF9hcmdmIiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImNyZWF0ZV9sb2NhbCIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiY29uY2F0IiwiY29weSIsImZpbGwiLCJpbml0IiwibWFrZV9tYXRyaXgiLCJvZl9saXN0Iiwic3ViIiwidG9fbGlzdCIsImZvbGQiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImNvbXBhcmVfbG9jYWwiLCJjb21wYXJlIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsIlNvcnRlciIsIlMiLCJnZXQiLCJzZXQiLCJsZW5ndGgiLCJhcnIiLCJpIiwiaiIsInRtcCIsInNvcnQiLCJsZWZ0IiwicmlnaHQiLCJwb3MiLCJ2IiwiZmluYWxfcG9zIiwiaV9uZXh0IiwiSW5zZXJ0aW9uX3NvcnQiLCJoZWFwaWZ5Iiwicm9vdCIsInJlbGF0aXZlX3Jvb3QiLCJsZWZ0X2NoaWxkIiwicmlnaHRfY2hpbGQiLCJsYXJnZXN0IiwiSGVhcF9zb3J0IiwiZml2ZV9lbGVtZW50X3NvcnQiLCJtMSIsIm0yIiwibTMiLCJtNCIsIm01IiwiY29tcGFyZV9hbmRfc3dhcCIsImludHJvX3NvcnQiLCJtYXhfZGVwdGgiLCJsZW4iLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1hdGNoIiwibWlkZGxlX3NvcnRlZCIsInBpdm90MiIsInBpdm90MSIsImwiLCJwIiwiciIsInB2IiwiSW50cm9fc29ydCIsIlNvcnQiLCJjc3RfQXJyYXlfaXRlcjJfZXhuIiwiY3N0X0FycmF5X21hcDJfZXhuIiwiY3N0X0FycmF5X2ZvbGQyX2V4biIsImNzdF9BcnJheV9leGlzdHMyX2V4biIsImNzdF9BcnJheV9mb3JfYWxsMl9leG4iLCJvZl9hcnJheSIsInQiLCJ0b19hcnJheSIsImlzX2VtcHR5IiwiaXNfc29ydGVkIiwicmVzdWx0IiwiZWx0X2kiLCJlbHRfaV9taW51c18xIiwiaXNfc29ydGVkX3N0cmljdGx5IiwibWVyZ2UiLCJsMSIsImwyIiwibWVyZ2VkIiwiYTFfaW5kZXgiLCJhMl9pbmRleCIsInVzZV9hMSIsImNvcHlfbWF0cml4IiwiZm9sZGluZ19tYXAiLCJhY2MiLCJ4IiwieSIsIm5ld19hY2MiLCJmb2xkX21hcCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsInN1bSIsIm0iLCJleHRyZW1hbF9lbGVtZW50Iiwia2VlcF9sZWZ0X2lmIiwibWluX2VsdCIsImNvbXBhcmVfcmVzdWx0IiwibWF4X2VsdCIsImZvbGRpIiwiZm9sZGluZ19tYXBpIiwiZm9sZF9tYXBpIiwiY291bnQiLCJjb3VudGkiLCJjb25jYXRfbWFwIiwiY29uY2F0X21hcGkiLCJyZXZfaW5wbGFjZSIsInJldiIsIm9mX2xpc3RfcmV2IiwiYSIsIm9mX2xpc3RfbWFwIiwieHMiLCJ0bCIsImhkIiwicGFyYW0iLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwiZmlsdGVyX21hcGkiLCJrIiwiZmlsdGVyX21hcCIsImZpbHRlcl9vcHQiLCJjaGVja19sZW5ndGgyX2V4biIsIm5hbWUiLCJ0MSIsInQyIiwibjEiLCJuMiIsIml0ZXIyX2V4biIsIngxIiwibWFwMl9leG4iLCJmb2xkMl9leG4iLCJhYyIsImZpbHRlciIsImZpbHRlcmkiLCJleGlzdHMiLCJleGlzdHNpIiwibWVtIiwiZXF1YWwiLCJmb3JfYWxsIiwiZm9yX2FsbGkiLCJleGlzdHMyX2V4biIsImZvcl9hbGwyX2xvY2FsX2V4biIsImZvcl9hbGwyX2V4biIsImVxdWFsX2xvY2FsIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInZhbHVlIiwiZmluZGkiLCJmaW5kaV9leG4iLCJmaW5kX2V4biIsImZpbmQiLCJmaW5kX21hcCIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsImZpbmRfbWFwaSIsImNzdF9BcnJheV9yZWR1Y2VfZXhuIiwiZmluZF9tYXBpX2V4biIsImZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIiwibiIsInByZXYiLCJjdXIiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicGVybXV0ZSIsImNzdF9BcnJheV9yYW5kb21fZWxlbWVudF9leG5fZSIsImNzdF9BcnJheV96aXBfZXhuIiwiY3N0X0FycmF5X3RyYW5zcG9zZV9leG4iLCJyYW5kb21fZWxlbWVudF9leG4iLCJvcHQiLCJyYW5kb21fc3RhdGUiLCJyYW5kb21fZWxlbWVudCIsImV4biIsInppcCIsIngyIiwiemlwX2V4biIsInVuemlwIiwicmVzMSIsInJlczIiLCJzb3J0ZWRfY29weSIsInBhcnRpdGlvbl9tYXBpIiwiYm90aCIsImZpcnN0cyIsInNlY29uZHMiLCJwYXJ0aXRpb25pX3RmIiwicGFydGl0aW9uX21hcCIsInBhcnRpdGlvbl90ZiIsImxhc3QiLCJ0b19zZXF1ZW5jZV9tdXRhYmxlIiwidG9fc2VxdWVuY2UiLCJjYXJ0ZXNpYW5fcHJvZHVjdCIsImkxIiwiaTIiLCJ0cmFuc3Bvc2UiLCJ0dCIsIndpZHRoIiwiZGVwdGgiLCJkIiwidyIsInRyYW5zcG9zZV9leG4iLCJpbmNsdWRlIiwiYmluYXJ5X3NlYXJjaCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIiwiY3JlYXRlX2xpa2UiLCJ1bnNhZmVfYmxpdCIsImJsaXQiLCJibGl0byIsInN1Ym8iLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfYSIsIkJhc2VfQXJyYXkiXSwibWFwcGluZ3MiOiJJQUFB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QUEsSUFBQW1KO0FBQUFBLE1BakxqRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkQxdUJGO0FBQUEsR0MwdUJFO0FBQUE7QUFBQSxFRDF1QkYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzU5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfRmxvYXRhYmxlIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsaUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzYwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9mbG9hdDAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBjZWlsID0gU3RkbGliLmNlaWxcbmxldCBmbG9vciA9IFN0ZGxpYi5mbG9vclxubGV0IG1vZF9mbG9hdCA9IFN0ZGxpYi5tb2RfZmxvYXRcbmxldCBtb2RmID0gU3RkbGliLm1vZGZcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgbmFuID0gU3RkbGliLm5hblxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG1heF9maW5pdGVfdmFsdWUgPSBTdGRsaWIubWF4X2Zsb2F0XG5sZXQgZXBzaWxvbl9mbG9hdCA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5sZXQgY2xhc3NpZnlfZmxvYXQgPSBTdGRsaWIuY2xhc3NpZnlfZmxvYXRcbmxldCBhYnNfZmxvYXQgPSBTdGRsaWIuYWJzX2Zsb2F0XG5sZXQgaXNfaW50ZWdlciA9IFN0ZGxpYi5GbG9hdC5pc19pbnRlZ2VyXG5sZXQgKCAqKiApID0gU3RkbGliLiggKiogKVxuXG5sZXQgKCAlLiApIGEgYiA9XG4gICgqIFJhaXNlIGluIGNhc2Ugb2YgYSBuZWdhdGl2ZSBtb2R1bHVzLCBhcyBkb2VzIEludC4oICUgKS4gKilcbiAgaWYgYiA8IDAuXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIiVmICUlICVmIGluIGZsb2F0MC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIiBhIGIgKCk7XG4gIGxldCBtID0gU3RkbGliLm1vZF9mbG9hdCBhIGIgaW5cbiAgKCogUHJvZHVjZSBhIG5vbi1uZWdhdGl2ZSByZXN1bHQgaW4gYW5hbG9neSB3aXRoIEludC4oICUgKS4gKilcbiAgaWYgbSA8IDAuIHRoZW4gbSArLiBiIGVsc2UgbVxuOztcblxuKCogVGhlIGJpdHMgb2YgSU5SSUEncyBbU3RkbGliXSB0aGF0IHdlIGp1c3Qgd2FudCB0byBleHBvc2UgaW4gW0Zsb2F0XS4gTW9zdCBhcmVcbiAgIGFscmVhZHkgZGVwcmVjYXRlZCBpbiBbU3RkbGliXSwgYW5kIGV2ZW50dWFsbHkgYWxsIG9mIHRoZW0gc2hvdWxkIGJlLiAqKVxuaW5jbHVkZSAoXG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgU3RkbGliXG4gICAgaW5jbHVkZSBTdGRsaWIuRmxvYXRcbiAgZW5kIDpcbiAgICBzaWdcbiAgICAgIGV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuXG4gICAgICBleHRlcm5hbCBsZGV4cFxuICAgICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICAgID0gXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIlxuICAgICAgICBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBlbmQpXG5cbigqIFdlIG5lZWQgdGhpcyBpbmRpcmVjdGlvbiBiZWNhdXNlIHRoZXNlIGFyZSBleHBvc2VkIGFzIFwidmFsXCIgaW5zdGVhZCBvZiBcImV4dGVybmFsXCIgKilcbmxldCBmcmV4cCA9IGZyZXhwXG5sZXQgbGRleHAgPSBsZGV4cFxubGV0IGlzX25hbiB4ID0gKHggOiBmbG9hdCkgPD4geFxuXG4oKiBBbiBvcmRlci1wcmVzZXJ2aW5nIGJpamVjdGlvbiBiZXR3ZWVuIGFsbCBmbG9hdHMgZXhjZXB0IGZvciBOYU5zLCBhbmQgOTkuOTUlIG9mXG4gICBpbnQ2NHMuXG5cbiAgIE5vdGUgd2UgZG9uJ3QgZGlzdGluZ3Vpc2ggMC4gYW5kIC0wLiBhcyBzZXBhcmF0ZSB2YWx1ZXMgaGVyZSwgdGhleSBib3RoIG1hcCB0byAwTCwgd2hpY2hcbiAgIG1hcHMgYmFjayB0byAwLlxuXG4gICBUaGlzIHNob3VsZCB3b3JrIGJvdGggb24gbGl0dGxlLWVuZGlhbiBhbmQgaGlnaC1lbmRpYW4gQ1BVcy4gIFdpa2lwZWRpYSBzYXlzOiBcIm9uXG4gICBtb2Rlcm4gc3RhbmRhcmQgY29tcHV0ZXJzIChpLmUuLCBpbXBsZW1lbnRpbmcgSUVFRSA3NTQpLCBvbmUgbWF5IGluIHByYWN0aWNlIHNhZmVseVxuICAgYXNzdW1lIHRoYXQgdGhlIGVuZGlhbm5lc3MgaXMgdGhlIHNhbWUgZm9yIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYXMgZm9yIGludGVnZXJzXCJcbiAgIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VuZGlhbm5lc3MjRmxvYXRpbmctcG9pbnRfYW5kX2VuZGlhbm5lc3MpLlxuKilcbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0ID1cbiAgaWYgaXNfbmFuIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gKCogYWxzbyBpbmNsdWRlcyAtMC4gKilcbiAgICBTb21lIDBMXG4gIGVsc2UgaWYgdCA+IDAuXG4gIHRoZW4gU29tZSAoU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgdClcbiAgZWxzZSBTb21lIChTdGRsaWIuSW50NjQubmVnIChTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCAoLS50KSkpXG47O1xuXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIHggPSBPcHRpb24udmFsdWVfZXhuICh0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4KVxuXG5sZXQgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXIgeCA9XG4gIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgeCAwTFxuICB0aGVuIFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIHhcbiAgZWxzZSB+LS4oU3RkbGliLkludDY0LmZsb2F0X29mX2JpdHMgKFN0ZGxpYi5JbnQ2NC5uZWcgeCkpXG47O1xuXG5sZXQgb25lX3VscCBkaXIgdCA9XG4gIG1hdGNoIHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgd2l0aFxuICB8IE5vbmUgLT4gU3RkbGliLm5hblxuICB8IFNvbWUgeCAtPlxuICAgIG9mX2ludDY0X3ByZXNlcnZlX29yZGVyXG4gICAgICAoU3RkbGliLkludDY0LmFkZFxuICAgICAgICAgeFxuICAgICAgICAgKG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgVXAgLT4gMUxcbiAgICAgICAgICB8IGBEb3duIC0+IC0xTCkpXG47O1xuXG4oKiBbdXBwZXJfYm91bmRfZm9yX2ludF0gYW5kIFtsb3dlcl9ib3VuZF9mb3JfaW50XSBhcmUgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXgvbWluIGZsb2F0XG4gICB0aGF0IGZpdHMgaW4gYSBnaXZlbi1zaXplIGludGVnZXIgd2hlbiByb3VuZGVkIHRvd2FyZHMgMCAodXNpbmcgW2ludF9vZl9mbG9hdF0pLlxuXG4gICBtYXhfaW50L21pbl9pbnQgZGVwZW5kIG9uIFtudW1fYml0c10sIGUuZy4gKy8tIDJeMzAsICsvLSAyXjYyIGlmIDMxLWJpdCwgNjMtYml0XG4gICAocmVzcGVjdGl2ZWx5KSB3aGlsZSBmbG9hdCBpcyBJRUVFIHN0YW5kYXJkIGZvciBkb3VibGUgKDUyIHNpZ25pZmljYW50IGJpdHMpLlxuXG4gICBJbiBhbGwgY2FzZXMsIHdlIHdhbnQgdG8gZ3VhcmFudGVlIHRoYXRcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IDw9IHggPD0gdXBwZXJfYm91bmRfZm9yX2ludF1cbiAgIGlmZiBbaW50X29mX2Zsb2F0IHhdIGZpdHMgaW4gYW4gaW50IHdpdGggW251bV9iaXRzXSBiaXRzLlxuXG4gICBbMiAqKiAobnVtX2JpdHMgLSAxKV0gaXMgdGhlIGZpcnN0IGZsb2F0IGdyZWF0ZXIgdGhhdCBtYXhfaW50LCB3ZSB1c2UgdGhlIHByZWNlZGluZ1xuICAgZmxvYXQgYXMgdXBwZXIgYm91bmQuXG5cbiAgIFstICgyICoqIChudW1fYml0cyAtIDEpKV0gaXMgZXF1YWwgdG8gbWluX2ludC5cbiAgIEZvciBsb3dlciBib3VuZCB3ZSBsb29rIGZvciB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0gc28gdGhhdFxuICAgW2ZdIHJvdW5kcyB0b3dhcmQgemVybyB0byBbbWluX2ludF1cblxuICAgU28gaW4gcGFydGljdWxhciB3ZSB3aWxsIGhhdmU6XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCB4IDw9IC0gKDIgKiogKDEteCkpXVxuICAgW3VwcGVyX2JvdW5kX2Zvcl9pbnQgeCAgPCAgICAyICoqICgxLXgpIF1cbiopXG5sZXQgdXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIG9uZV91bHAgYERvd24gKDIuICoqIGV4cClcbjs7XG5cbmxldCBpc194X21pbnVzX29uZV9leGFjdCB4ID1cbiAgKCogW3ggPSB4IC0uIDEuXSBkb2VzIG5vdCB3b3JrIHdpdGggeDg3IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgYmFja2VuZCAod2hpY2ggaXMgdXNlZFxuICAgICBvbiAzMi1iaXQgb2NhbWwpIGJlY2F1c2Ugb2YgODAtYml0IHJlZ2lzdGVyIHByZWNpc2lvbiBvZiBpbnRlcm1lZGlhdGUgY29tcHV0YXRpb25zLlxuXG4gICAgIEFuIGFsdGVybmF0aXZlIHdheSBvZiBjb21wdXRpbmcgdGhpczogW3ggLS4gb25lX3VscCBgRG93biB4IDw9IDEuXSBpcyBhbHNvIHByb25lIHRvXG4gICAgIHRoZSBzYW1lIHByZWNpc2lvbiBpc3N1ZXM6IHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBbeF0gaXMgNjQtYml0LlxuICAqKVxuICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgbm90IChTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB4ID0gU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgKHggLS4gMS4pKVxuOztcblxubGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gU3RkbGliLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBsZXQgbWluX2ludF9hc19mbG9hdCA9IH4tLigyLiAqKiBleHApIGluXG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbnVtX2JpdHMgLSAxIDwgNTMgKCogNTMgPSAjYml0cyBpbiB0aGUgZmxvYXQncyBtYW50aXNzYSB3aXRoIHNpZ24gaW5jbHVkZWQgKilcbiAgdGhlbiAoXG4gICAgKCogVGhlIHNtYWxsZXN0IGZsb2F0IHRoYXQgcm91bmRzIHRvd2FyZHMgemVybyB0byBbbWluX2ludF0gaXNcbiAgICAgICBbbWluX2ludCAtIDEgKyBlcHNpbG9uXSAqKVxuICAgIGFzc2VydCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCk7XG4gICAgb25lX3VscCBgVXAgKG1pbl9pbnRfYXNfZmxvYXQgLS4gMS4pKVxuICBlbHNlIChcbiAgICAoKiBbbWluX2ludF9hc19mbG9hdF0gaXMgYWxyZWFkeSB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0uICopXG4gICAgYXNzZXJ0IChub3QgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpKTtcbiAgICBtaW5faW50X2FzX2Zsb2F0KVxuOztcblxuKCogWDg2IGRvY3Mgc2F5OlxuXG4gICBJZiBvbmx5IG9uZSB2YWx1ZSBpcyBhIE5hTiAoU05hTiBvciBRTmFOKSBmb3IgdGhpcyBpbnN0cnVjdGlvbiwgdGhlIHNlY29uZCBzb3VyY2VcbiAgIG9wZXJhbmQsIGVpdGhlciBhIE5hTiBvciBhIHZhbGlkIGZsb2F0aW5nLXBvaW50IHZhbHVlXG4gICBpcyB3cml0dGVuIHRvIHRoZSByZXN1bHQuXG5cbiAgIFNvIHdlIGhhdmUgdG8gYmUgVkVSWSBjYXJlZnVsIGhvdyB3ZSB1c2UgdGhlc2UhXG5cbiAgIFRoZXNlIGludHJpbnNpY3Mgd2VyZSBjb3BpZWQgZnJvbSBbT2NhbWxfaW50cmluc2ljc10gdG8gYXZvaWQgYnVpbGQgZGVwcyB3ZSBkb24ndCB3YW50XG4qKVxubW9kdWxlIEludHJpbnNpY3Nfd2l0aF93ZWlyZF9uYW5fYmVoYXZpb3IgPSBzdHJ1Y3RcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBtaW4gYSBiID0gT2NhbWxfaW50cmluc2ljc19rZXJuZWwuRmxvYXQubWluIGEgYlxuICBsZXRbQGlubGluZSBhbHdheXNdIG1heCBhIGIgPSBPY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC5GbG9hdC5tYXggYSBiXG5lbmRcblxubGV0IGNsYW1wX3VuY2hlY2tlZFxuICB+KHRvX2NsYW1wX21heWJlX25hbiA6IGZsb2F0KVxuICB+bWluX3doaWNoX2lzX25vdF9uYW5cbiAgfm1heF93aGljaF9pc19ub3RfbmFuXG4gID1cbiAgKCogV2Ugd2FudCB0byBwcm9wYWdhdGUgbmFuczsgYXMgcGVyIHRoZSB4ODYgZG9jcywgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIHVzZSB0aGVtIGFzIHRoZVxuICAgICBfc2Vjb25kXyBhcmd1bWVudC4gKilcbiAgbGV0IHRfbWF5YmVfbmFuID1cbiAgICBJbnRyaW5zaWNzX3dpdGhfd2VpcmRfbmFuX2JlaGF2aW9yLm1heCBtaW5fd2hpY2hfaXNfbm90X25hbiB0b19jbGFtcF9tYXliZV9uYW5cbiAgaW5cbiAgSW50cmluc2ljc193aXRoX3dlaXJkX25hbl9iZWhhdmlvci5taW4gbWF4X3doaWNoX2lzX25vdF9uYW4gdF9tYXliZV9uYW5cbjs7XG5cbmxldCBib3ggPVxuICAoKiBQcmV2ZW50IHBvdGVudGlhbCBjb25zdGFudCBmb2xkaW5nIG9mIFsrLiAwLl0gaW4gdGhlIG5lYXIgb2NhbWxvcHQgZnV0dXJlLiAqKVxuICBsZXQgeCA9IFN5czAub3BhcXVlX2lkZW50aXR5IDAuIGluXG4gIGZ1biBmIC0+IGYgKy4geFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX2Zsb2F0MF9tbCIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwzIiwiZiIsImEwIiwiYTEiLCJhMiIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfT3B0aW9uIiwiQmFzZV9QcmludGYiLCJTdGRsaWJfRmxvYXQiLCJjZWlsIiwiZmxvb3IiLCJtb2RfZmxvYXQiLCJtb2RmIiwiZmxvYXRfb2Zfc3RyaW5nIiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsIm5hbiIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibWF4X2Zpbml0ZV92YWx1ZSIsImVwc2lsb25fZmxvYXQiLCJjbGFzc2lmeV9mbG9hdCIsImFic19mbG9hdCIsImlzX2ludGVnZXIiLCJzeW1ib2wiLCJhIiwiYiIsIm0iLCJmcmV4cCIsImxkZXhwIiwiaXNfbmFuIiwieCIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyIiwidCIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biIsIm9mX2ludDY0X3ByZXNlcnZlX29yZGVyIiwib25lX3VscCIsImRpciIsIm1hdGNoIiwidXBwZXJfYm91bmRfZm9yX2ludCIsIm51bV9iaXRzIiwiZXhwIiwiaXNfeF9taW51c19vbmVfZXhhY3QiLCJsb3dlcl9ib3VuZF9mb3JfaW50IiwibWluX2ludF9hc19mbG9hdCIsIm1pbiIsIm1heCIsIkludHJpbnNpY3Nfd2l0aF93ZWlyZF9uYW5fYmVoYSIsImNsYW1wX3VuY2hlY2tlZCIsInRvX2NsYW1wX21heWJlX25hbiIsIm1pbl93aGljaF9pc19ub3RfbmFuIiwibWF4X3doaWNoX2lzX25vdF9uYW4iLCJ0X21heWJlX25hbiIsImJveCIsImluY2x1ZGUiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsX2xvY2FsIiwiQmFzZV9GbG9hdDAiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLEtBQUE7QUFBQSxZQUFBQyxNQUFBO0FBQUEsWUFBQUMsVUFBQTtBQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxVQUFBO0FBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQTtBQUFBLFlBQUFBLFNBQUFDLEtBQUFDO0FBQUFBLElDeUJFLFdBQ0s7QUFBQSxRQUFBQyxJQUNHO0FBQUEsSUFFUixnQkFBZSxvQ0FBYTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRRDdCOUI7QUFBQSxJQUFBQyxRQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0NnR2UsdUJBQWdCO0FBQUEsWUFBQUMsd0JBQUFDO0FBQUFBLElBY2xCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBTUQ7QUFBQTtBQUFBLGtCQUNBO0FBQUEsb0JBQWtCLHlCQUE0QixpQ0FBTztBQUFBO0FBQUEsWUFBQUMsNEJBQUFIO0FBQUFBLFFBQUEsSUFHWjtBQUFBLElBQTJCO0FBQUE7QUFBQSxZQUFBSSx3QkFBQUo7QUFBQUEsSUFHM0U7QUFBQSxjQUNFO0FBQUEsY0FDb0Q7QUFBQTtBQUFBLHFCQUFqRCx5QkFBNEIsbUJBQXFCO0FBQUE7QUFBQSxZQUFBSyxRQUFBQyxLQUFBSjtBQUFBQSxRQUFBSyxRQUluRDtBQUFBLElBQXlCLFlBQ3JCO0FBQUEsUUFBQVAsSUFEcUIsY0FHN0I7QUFBQSxJQUNFLE9BSW9CLHdCQUpwQiw2QkFJb0I7QUFBQTtBQUFBLFlBQUFRLG9CQUFBQztBQUFBQSxRQUFBQyxNQXlCTTtBQUFBLElBQ0wsMEJBQVgsa0JBQVc7QUFBQTtBQUFBLFlBQUFDLHFCQUFBWDtBQUFBQSxJQVdwQjtBQUFBO0FBQUEsWUFBRDtBQUFBLGNBQUM7QUFBQSxjQUErQix5QkFBMkIsbUNBQVU7QUFBQTtBQUFBLFlBQUFZLG9CQUFBSDtBQUFBQTtBQUFBQSxLQUFBQyxNQUkzQztBQUFBLEtBQUFHLG1CQUNQLDRCQUFHO0FBQUEsSUFFdkI7QUFBQSxLQVFXO0FBQUEsTUFBdUM7QUFBQSxLQUNuRDtBQUFBO0FBQUEsSUFMTztBQUFBLEtBQ0ssT0FBd0IsZUFBeEIsaURBSUs7QUFBQSxJQUw2QjtBQUFBLEdBSzdCO0FBQUEsWUFBQUMsSUFBQXBCLEdBQUFDLEdBY1csbURBQXFDO0FBQUEsWUFBQW9CLElBQUFyQixHQUFBQyxHQUNyQyxtREFBcUM7QUFBQSxPQUFBcUIsaUNEN01yRTtBQUFBLFlBQUFDO0FBQUFBLElBQUFDLG9CQUFBQyxzQkFBQUM7QUFBQUE7QUFBQUEsS0FBQUM7QUFBQUEsT0M2TWdDO0FBQUE7QUFBQSxJQURBO0FBQUEsK0NBY3lDO0FBQUE7QUFBQSxPQUFBckIsSUFNdkU7QUFBQSxZQUFBc0IsSUFBQXJELEdBQVMsdUNBQU07QUFBQTtBQUFBLElBQUFzRCxVQUFmO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBWixRQUFBO0FBQUEsSUFBQUQsUUFBQTtBQUFBLElBQUFjO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEaE9GIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTc3OTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0ludGFibGUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxlQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTc4MDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0ludF9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxNzgyMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9wb3dfb3ZlcmZsb3dfYm91bmRzLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIHdhcyBhdXRvZ2VuZXJhdGVkIGJ5IC4uL2dlbmVyYXRlL2dlbmVyYXRlX3Bvd19vdmVyZmxvd19ib3VuZHMuZXhlICopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIGhhdmUgdG8gdXNlIEludDY0LnRvX2ludF9leG4gaW5zdGVhZCBvZiBpbnQgY29uc3RhbnRzIHRvIG1ha2VcbiAgIHN1cmUgdGhhdCBmaWxlIGNhbiBiZSBwcmVwcm9jZXNzZWQgb24gMzItYml0IG1hY2hpbmVzLiAqKVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIDogaW50MzIgPSAyMTQ3NDgzNjQ3bFxuXG5sZXQgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50MzIgYXJyYXkgPVxuICBbfCAyMTQ3NDgzNjQ3bFxuICAgOyAyMTQ3NDgzNjQ3bFxuICAgOyA0NjM0MGxcbiAgIDsgMTI5MGxcbiAgIDsgMjE1bFxuICAgOyA3M2xcbiAgIDsgMzVsXG4gICA7IDIxbFxuICAgOyAxNGxcbiAgIDsgMTBsXG4gICA7IDhsXG4gICA7IDdsXG4gICA7IDVsXG4gICA7IDVsXG4gICA7IDRsXG4gICA7IDRsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gIHxdXG47O1xuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSA6IGludCA9IC0xIGxzciAxXG5cbmxldCBpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50IGFycmF5ID1cbiAgbWF0Y2ggSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludCB3aXRoXG4gIHwgMzIgLT4gQXJyYXkubWFwIGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyB+ZjpTdGRsaWIuSW50MzIudG9faW50XG4gIHwgNjMgLT5cbiAgICBbfCBTdGRsaWIuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgIDsgU3RkbGliLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgICA7IFN0ZGxpYi5JbnQ2NC50b19pbnQgMjE0NzQ4MzY0N0xcbiAgICAgOyAxNjY0NTEwXG4gICAgIDsgNDYzNDBcbiAgICAgOyA1NDA0XG4gICAgIDsgMTI5MFxuICAgICA7IDQ2M1xuICAgICA7IDIxNVxuICAgICA7IDExOFxuICAgICA7IDczXG4gICAgIDsgNDlcbiAgICAgOyAzNVxuICAgICA7IDI3XG4gICAgIDsgMjFcbiAgICAgOyAxN1xuICAgICA7IDE0XG4gICAgIDsgMTJcbiAgICAgOyAxMFxuICAgICA7IDlcbiAgICAgOyA4XG4gICAgIDsgN1xuICAgICA7IDdcbiAgICAgOyA2XG4gICAgIDsgNVxuICAgICA7IDVcbiAgICAgOyA1XG4gICAgIDsgNFxuICAgICA7IDRcbiAgICAgOyA0XG4gICAgIDsgNFxuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgIHxdXG4gIHwgMzEgLT5cbiAgICBbfCAxMDczNzQxODIzXG4gICAgIDsgMTA3Mzc0MTgyM1xuICAgICA7IDMyNzY3XG4gICAgIDsgMTAyM1xuICAgICA7IDE4MVxuICAgICA7IDYzXG4gICAgIDsgMzFcbiAgICAgOyAxOVxuICAgICA7IDEzXG4gICAgIDsgMTBcbiAgICAgOyA3XG4gICAgIDsgNlxuICAgICA7IDVcbiAgICAgOyA0XG4gICAgIDsgNFxuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICB8XVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDYzX29uX2ludDY0X3ZhbHVlIDogaW50NjQgPSA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuXG5sZXQgaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgOyA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgOyAyMTQ3NDgzNjQ3TFxuICAgOyAxNjY0NTEwTFxuICAgOyA0NjM0MExcbiAgIDsgNTQwNExcbiAgIDsgMTI5MExcbiAgIDsgNDYzTFxuICAgOyAyMTVMXG4gICA7IDExOExcbiAgIDsgNzNMXG4gICA7IDQ5TFxuICAgOyAzNUxcbiAgIDsgMjdMXG4gICA7IDIxTFxuICAgOyAxN0xcbiAgIDsgMTRMXG4gICA7IDEyTFxuICAgOyAxMExcbiAgIDsgOUxcbiAgIDsgOExcbiAgIDsgN0xcbiAgIDsgN0xcbiAgIDsgNkxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMUxcbiAgIDsgMUxcbiAgfF1cbjs7XG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUgOiBpbnQ2NCA9IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG5cbmxldCBpbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IDMwMzcwMDA0OTlMXG4gICA7IDIwOTcxNTFMXG4gICA7IDU1MTA4TFxuICAgOyA2MjA4TFxuICAgOyAxNDQ4TFxuICAgOyA1MTFMXG4gICA7IDIzNExcbiAgIDsgMTI3TFxuICAgOyA3OExcbiAgIDsgNTJMXG4gICA7IDM4TFxuICAgOyAyOExcbiAgIDsgMjJMXG4gICA7IDE4TFxuICAgOyAxNUxcbiAgIDsgMTNMXG4gICA7IDExTFxuICAgOyA5TFxuICAgOyA4TFxuICAgOyA3TFxuICAgOyA3TFxuICAgOyA2TFxuICAgOyA2TFxuICAgOyA1TFxuICAgOyA1TFxuICAgOyA1TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAxTFxuICB8XVxuOztcblxubGV0IGludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICAgOyAtMzAzNzAwMDQ5OUxcbiAgIDsgLTIwOTcxNTFMXG4gICA7IC01NTEwOExcbiAgIDsgLTYyMDhMXG4gICA7IC0xNDQ4TFxuICAgOyAtNTExTFxuICAgOyAtMjM0TFxuICAgOyAtMTI3TFxuICAgOyAtNzhMXG4gICA7IC01MkxcbiAgIDsgLTM4TFxuICAgOyAtMjhMXG4gICA7IC0yMkxcbiAgIDsgLTE4TFxuICAgOyAtMTVMXG4gICA7IC0xM0xcbiAgIDsgLTExTFxuICAgOyAtOUxcbiAgIDsgLThMXG4gICA7IC03TFxuICAgOyAtN0xcbiAgIDsgLTZMXG4gICA7IC02TFxuICAgOyAtNUxcbiAgIDsgLTVMXG4gICA7IC01TFxuICAgOyAtNExcbiAgIDsgLTRMXG4gICA7IC00TFxuICAgOyAtNExcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0xTFxuICB8XVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial9kdXAiLCJnbG9iYWxfZGF0YSIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbiIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfQXJyYXkwIiwiaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSIsInN3aXRjaGVyIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIiwiaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbCIsImludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyIsIkJhc2VfUG93X292ZXJmbG93X2JvdW5kcyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsK0JDOEV5QztBQUFBLElBQUFDLFdBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUE7QUFBQTtBQUFBLEtBeUl4QztBQUFBO0FBQUEsS0FBQUM7QUFBQUEsT0FuSUw7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFBO0FBQUFBLE9BTjZDO0FBQUEsVUFJdkM7QUFBQTtBQUFBLDZERGxGVjtBQUFBLFVDc0pJO0FBQUE7QUFBQSxJQUFBQyxpQ0F4RTZDO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDlFakQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODI3NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9pbnRfbWF0aC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IG5lZ2F0aXZlX2V4cG9uZW50ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImV4cG9uZW50IGNhbiBub3QgYmUgbmVnYXRpdmVcIiAoKVxubGV0IG92ZXJmbG93ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImludGVnZXIgb3ZlcmZsb3cgaW4gcG93XCIgKClcblxuKCogVG8gaW1wbGVtZW50IFtpbnQ2NF9wb3ddLCB3ZSB1c2UgQyBjb2RlIHJhdGhlciB0aGFuIE9DYW1sIHRvIGVsaW1pbmF0ZSBhbGxvY2F0aW9uLiAqKVxuZXh0ZXJuYWwgaW50X21hdGhfaW50X3BvdyA6IGludCAtPiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YlwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3Bvd1xuICA6ICBpbnQ2NFxuICAtPiBpbnQ2NFxuICAtPiBpbnQ2NFxuICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YlwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1Yl91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgICAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGRsaWIuSW50NjRcblxuICBleHRlcm5hbCAoIDwgKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoID49ICkgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5lbmRcblxuKCogd2UgZG9uJ3QgZG8gW2Fic10gaW4gaW50NjQgY2FzZSB0byBhdm9pZCBhbGxvY2F0aW9uICopXG5sZXQgaW50NjRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgKGJhc2UgPiAxTCB8fCBiYXNlIDwgLTFMKVxuICAgICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgICAgIHx8IChiYXNlID49IDBMXG4gICAgICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpXG4gICAgICAgICB8fCAoYmFzZSA8IDBMXG4gICAgICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgICAgIDwgUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubGV0IGludDYzX3Bvd19vbl9pbnQ2NCBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMUxcbiAgICAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICAgICB8fCBhYnMgYmFzZVxuICAgICAgICAgICAgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICApXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlIHRcblxuICBpbmNsdWRlIEZsb2F0YWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBTdHJpbmdhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoICogKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC8gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIH4tICkgOiB0IC0+IHRcblxuICBpbmNsdWRlIENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCBvZl9pbnRfZXhuIDogaW50IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG5lbmRcblxubW9kdWxlIE1ha2UgKFggOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgb3BlbiBYXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gWC5yZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgb25lID0gb2ZfaW50X2V4biAxXG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gICgqKiBmbG9hdCBkaXZpc2lvbiBvZiBpbnRlZ2VycyAqKVxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGxldCByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPSBpIC0gKGkgJSBtb2R1bHVzKVxuXG4gIGxldCByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBpZiByZW1haW5kZXIgPSB6ZXJvIHRoZW4gaSBlbHNlIGkgKyBtb2R1bHVzIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgaWYgaSA9IHplcm9cbiAgICB0aGVuIHplcm9cbiAgICBlbHNlIGlmIGkgPiB6ZXJvXG4gICAgdGhlbiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgZWxzZSByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuXG4gIGxldCByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGxldCBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA9IG1vZHVsdXMgLSByZW1haW5kZXIgaW5cbiAgICBpZiBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA8PSByZW1haW5kZXJcbiAgICB0aGVuIGkgKyBtb2R1bHVzX21pbnVzX3JlbWFpbmRlclxuICAgIGVsc2UgaSAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfZXhwb25lbnRfY2FuX25vdF9iZV9uZWdhdGkiLCJjc3RfaW50ZWdlcl9vdmVyZmxvd19pbl9wb3ciLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIkJhc2VfUG93X292ZXJmbG93X2JvdW5kcyIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX0ludDY0IiwiaW52YWxpZF9hcmdmIiwibmVnYXRpdmVfZXhwb25lbnQiLCJwYXJhbSIsIm92ZXJmbG93IiwiaW50X3BvdyIsImJhc2UiLCJleHBvbmVudCIsImFicyIsImludDY0X3BvdyIsImludDYzX3Bvd19vbl9pbnQ2NCIsIlByaXZhdGUiLCJCYXNlX0ludF9tYXRoIiwiWCIsInN5bWJvbCIsIngiLCJ5IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJpIiwibW9kdWx1cyIsInJvdW5kX3VwIiwicmVtYWluZGVyIiwicm91bmRfdG93YXJkc196ZXJvIiwidG9fbXVsdGlwbGVfb2YiLCJyb3VuZF9uZWFyZXN0IiwibW9kdWx1c19taW51c19yZW1haW5kZXIiLCJyb3VuZCIsIm9wdCIsImRpciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxrQkFBQUM7QUFBQUEsSUNHMkIsa0RBQXFEO0FBQUE7QUFBQSxZQUFBQyxTQUFBRDtBQUFBQSxJQUM5RCxrREFBZ0Q7QUFBQTtBQUFBLFlBQUFFLFFBQUFDLE1BQUFDO0FBQUFBLElBYWhFLGlCQUFxQjtBQUFBLFlBQ2xCO0FBQUEsSUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRVU7QUFBQSxXQUFILElBQVI7QUFBQTtBQUFBO0FBQUEsYUFGQztBQUFBLFVBR047QUFBQSxJQUNMLHlEQUE4QjtBQUFBO0FBQUE7QUFBQSxJQUFBQyxNRHRCaEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxVQUFBSCxNQUFBQztBQUFBQSxJQ29DSywrQkFBbUI7QUFBQSxZQUNsQiwrQkFBUyxLQUFJO0FBQUEsSUFBSjtBQUFBLGFBQ047QUFBQSxLQUFjO0FBQUE7QUFBQTtBQUFBLGNBQ1Y7QUFBQSxNQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFDUDtBQUFBLGtCQUNFO0FBQUE7QUFBQSxlQUZLO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFHVjtBQUFBLE9BQVM7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUNOO0FBQUEsbUJBQ0U7QUFBQTtBQUFBLGdCQUZJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUxQO0FBQUEsVUFRUjtBQUFBLElBQ0wsMkRBQWdDO0FBQUE7QUFBQSxZQUFBRyxtQkFBQUosTUFBQUM7QUFBQUEsSUFLN0IsK0JBQW1CO0FBQUEsWUFDbkI7QUFBQSxJQUFhO0FBQUEsYUFDVDtBQUFBLEtBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBRVQ7QUFBQSxXQURGO0FBQUE7QUFBQTtBQUFBLGFBRk07QUFBQSxVQUtYO0FBQUEsSUFDTCwyREFBZ0M7QUFBQTtBQUFBO0FBQUEsSUFBQUksVUQxRGxDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLGdCQUFBQztBQUFBQSxpQkFBQUMsT0FBQUMsR0FBQUM7QUFBQUEsU0NzRk87QUFBQSxrQkFLQyx5QkFEQTtBQUFBLFVBRkY7QUFBQTtBQUFBLGFBQUFDLE9BS1M7QUFBQSxTQUNSO0FBQUEsbUJBQWlCO0FBQUEsdUJBQWtCO0FBQUE7QUFBQSxZQUFBQyxNQUc5QjtBQUFBLGlCQUFBSixTQUFBQyxHQUFBQztBQUFBQSxTQUdMO0FBQUEsa0JBS0MseUJBREE7QUFBQSxVQUZGO0FBQUE7QUFBQSxTQUtDLGtDQUF5Qyw2QkFBSztBQUFBLGlCQUEvQiw4QkFBRDtBQUFBLFNBQWUsK0JBQWlCO0FBQUE7QUFBQSxpQkFBQUYsU0FBQUMsR0FBQUM7QUFBQUEsYUFBQSxJQUlwQix5QkFBZDtBQUFBLFNBQVUsdUNBQWM7QUFBQTtBQUFBLGlCQUFBRyxXQUFBQyxHQUFBQztBQUFBQSxhQUFBLElBRU07QUFBQSxTQUFhO0FBQUE7QUFBQSxpQkFBQUMsU0FBQUYsR0FBQUM7QUFBQUEsYUFBQUUsWUFHMUM7QUFBQSxTQUNiLHdDQUFzQjtBQUFBLGlCQUFPO0FBQUEsU0FBVyxxQ0FBWTtBQUFBO0FBQUEsaUJBQUFDLG1CQUFBSixHQUFBSztBQUFBQSxTQUlwRDtBQUFBO0FBQUEsbUJBRUs7QUFBQTtBQUFBLHFCQUNIO0FBQUEscUJBQ0EsMkJBQTBCO0FBQUE7QUFBQSxpQkFBQUMsY0FBQU4sR0FBQUM7QUFBQUE7QUFBQUEsVUFBQUUsWUFJZjtBQUFBLFVBQUFJLDBCQUNjO0FBQUEsU0FDM0I7QUFBQSxtQkFDRTtBQUFBLG1CQUNBLDhCQUFhO0FBQUE7QUFBQSxpQkFBQUMsTUFBQUMsS0FBQVQsR0FBQUs7QUFBQUEsYUFBQUssTUFHTTtBQUFBLFNBQ3hCO0FBQUE7QUFBQTtBQUFBLHFCQUlXO0FBQUEscUJBSEc7QUFBQTtBQUFBO0FBQUEscUJBQ0g7QUFBQSxxQkFDRiwyQkFDc0M7QUFBQTtBQUFBLFFBNUMzQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0RqR3hCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTg1MTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJzdGFnZSIsInVuc3RhZ2UiLCJCYXNlX1N0YWdlZCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxNQUFBO0FBQUEsWUFBQUMsUUFBQTtBQUFBLE9BQUFDLGNBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODUyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfQnl0ZXNfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGtCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTg1MzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvY2hhci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuaW5jbHVkZSBDaGFyMFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBjaGFyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2NoYXIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfY2hhclxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfY2hhciBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfY2hhciA6IHQgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFN0cmluZy5tYWtlIDEgdFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbWF0Y2ggU3RyaW5nLmxlbmd0aCBzIHdpdGhcbiAgICB8IDEgLT4gcy5bMF1cbiAgICB8IF8gLT4gZmFpbHdpdGhmIFwiQ2hhci5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkNoYXJcIlxuZW5kKVxuXG5sZXQgcHAgZm10IGMgPSBTdGRsaWIuRm9ybWF0LmZwcmludGYgZm10IFwiJUNcIiBjXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYWxsID0gQXJyYXkuaW5pdCAyNTYgfmY6dW5zYWZlX29mX2ludCB8PiBBcnJheS50b19saXN0XG5cbmxldCBpc19sb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc191cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19wcmludCA9IGZ1bmN0aW9uXG4gIHwgJyAnIC4uICd+JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3doaXRlc3BhY2UgPSBmdW5jdGlvblxuICB8ICdcXHQnIHwgJ1xcbicgfCAnXFwwMTEnICgqIHZlcnRpY2FsIHRhYiAqKSB8ICdcXDAxMicgKCogZm9ybSBmZWVkICopIHwgJ1xccicgfCAnICcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2FscGhhID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxuKCogV3JpdGluZyB0aGVzZSBvdXQsIGluc3RlYWQgb2YgY2FsbGluZyBbaXNfYWxwaGFdIGFuZCBbaXNfZGlnaXRdLCByZWR1Y2VzXG4gICBydW50aW1lIGJ5IGFwcHJveC4gMzAlICopXG5sZXQgaXNfYWxwaGFudW0gPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9kaWdpdF91bnNhZmUgdCA9IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuXG5sZXQgZ2V0X2RpZ2l0X2V4biB0ID1cbiAgaWYgaXNfZGlnaXQgdFxuICB0aGVuIGdldF9kaWdpdF91bnNhZmUgdFxuICBlbHNlIGZhaWx3aXRoZiBcIkNoYXIuZ2V0X2RpZ2l0X2V4biAlQzogbm90IGEgZGlnaXRcIiB0ICgpXG47O1xuXG5sZXQgZ2V0X2RpZ2l0IHQgPSBpZiBpc19kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2RpZ2l0X3Vuc2FmZSB0KSBlbHNlIE5vbmVcblxubGV0IGlzX2hleF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X2xvd2VyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF91cHBlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0X2V4biA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICcwJ1xuICB8ICdhJyAuLiAnZicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnYScgKyAxMFxuICB8ICdBJyAuLiAnRicgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnQScgKyAxMFxuICB8IHQgLT5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkNoYXIuZ2V0X2hleF9kaWdpdF9leG46IG5vdCBhIGhleGFkZWNpbWFsIGRpZ2l0XCJcbiAgICAgICAgIFsgXCJjaGFyXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdCB0ID0gaWYgaXNfaGV4X2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfaGV4X2RpZ2l0X2V4biB0KSBlbHNlIE5vbmVcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggPj0gKSA9ICggPj0gKVxuICBsZXQgKCA8PSApID0gKCA8PSApXG4gIGxldCAoID0gKSA9ICggPSApXG4gIGxldCAoID4gKSA9ICggPiApXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCAoIDw+ICkgPSAoIDw+IClcbmVuZFxuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBjaGFyIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKGNoYXJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY29tcGFyZSBjMSBjMiA9IGNvbXBhcmUgKGxvd2VyY2FzZSBjMSkgKGxvd2VyY2FzZSBjMilcbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgYzEgYzIgPSBjb21wYXJlIGMxIGMyXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBoYXNoX2ZvbGRfY2hhciBzdGF0ZSAobG93ZXJjYXNlIHQpXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuXG4gIGxldCBlcXVhbF9fbG9jYWwgdDEgdDIgPSBlcXVhbF9pbnQgKGNvbXBhcmVfX2xvY2FsIHQxIHQyKSAwXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0hhc2giLCJCYXNlX1NleHAiLCJCYXNlX0Vycm9yIiwiU3RkbGliX0Zvcm1hdCIsIkJhc2VfU3RyaW5nMCIsIkJhc2VfQ2hhcjAiLCJCYXNlX0lkZW50aWZpYWJsZSIsIkJhc2VfQXJyYXkwIiwiQmFzZV9Db21wYXJhYmxlIiwiZmFpbHdpdGhmIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwiY29tcGFyZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJ0b19zdHJpbmciLCJ0Iiwib2Zfc3RyaW5nIiwicyIsImluY2x1ZGUiLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwiaGFzaGFibGUiLCJwcCIsImZtdCIsImMiLCJpbnZhcmlhbnQiLCJwYXJhbSIsImFsbCIsImNzdF9jaGFyIiwiY3N0X0NoYXJfZ2V0X2hleF9kaWdpdF9leG5fbm90IiwiaXNfbG93ZXJjYXNlIiwiaXNfdXBwZXJjYXNlIiwiaXNfcHJpbnQiLCJpc193aGl0ZXNwYWNlIiwiaXNfZGlnaXQiLCJpc19hbHBoYSIsImlzX2FscGhhbnVtIiwiZ2V0X2RpZ2l0X3Vuc2FmZSIsImdldF9kaWdpdF9leG4iLCJnZXRfZGlnaXQiLCJpc19oZXhfZGlnaXQiLCJpc19oZXhfZGlnaXRfbG93ZXIiLCJpc19oZXhfZGlnaXRfdXBwZXIiLCJnZXRfaGV4X2RpZ2l0X2V4biIsImdldF9oZXhfZGlnaXQiLCJzeW1ib2wiLCJPIiwiYzEiLCJjMiIsImNvbXBhcmVfbG9jYWwiLCJzdGF0ZSIsImVxdWFsIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImVxdWFsX2xvY2FsIiwidDEiLCJ0MiIsIkJhc2VfQ2hhciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtB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QUFBQSxJQUFBUyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFwRCxZQUFBO0FBQUEsSUFBQThDLGtCQUFBO0FBQUEsSUFBQUUsVUFBQTtBQUFBLElBQUFLLGdCQUFBO0FBQUEsSUFBQUgsUUFBQTtBQUFBLElBQUFELFFBQUE7QUFBQSxJQUFBTztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEbEQxRCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4ODgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2J5dGVzX3RyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0MC5JbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbigqIENvbnN0cnVjdCBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAyNTYsIG1hcHBpbmcgZXZlcnkgaW5wdXQgY2hhcmFjdGVyIGNvZGUgdG9cbiAgIGl0cyBjb3JyZXNwb25kaW5nIG91dHB1dCBjaGFyYWN0ZXIuXG5cbiAgIEJlbmNobWFya3MgaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuIHRoZSBsYW1iZGEgKGluY2x1ZGluZyBjb3N0IG9mXG4gICB0aGlzIGZ1bmN0aW9uKSwgZXZlbiBpZiB0YXJnZXQvcmVwbGFjZW1lbnQgYXJlIGp1c3QgMiBjaGFyYWN0ZXJzIGVhY2guXG5cbiAgIFJldHVybiBOb25lIGlmIHRoZSB0cmFuc2xhdGlvbiBtYXAgaXMgZXF1aXZhbGVudCB0byBqdXN0IHRoZSBpZGVudGl0eS4gKilcbmxldCB0cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgbGV0IHRyX21hcCA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgZm9yIGkgPSAwIHRvIDI1NSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGkgKENoYXIub2ZfaW50X2V4biBpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIC0gMSBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCAoU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgaSlcbiAgZG9uZTtcbiAgbGV0IGxhc3RfcmVwbGFjZW1lbnQgPSBTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCAtIDEpIGluXG4gIGZvclxuICAgIGkgPSBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgdG8gU3RyaW5nLmxlbmd0aCB0YXJnZXQgLSAxXG4gIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IGxhc3RfcmVwbGFjZW1lbnRcbiAgZG9uZTtcbiAgbGV0IHJlYyBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIGkgPVxuICAgIGlmIGkgPSAyNTZcbiAgICB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIGkpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgKGkgKyAxKVxuICBpblxuICAoKiBxdWljayBjaGVjayBvbiB0aGUgZmlyc3QgdGFyZ2V0IGNoYXJhY3RlciB3aGljaCB3aWxsIDk5JSBiZSB0cnVlICopXG4gIGxldCBmaXJzdF90YXJnZXQgPSB0YXJnZXQuWzBdIGluXG4gIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGZpcnN0X3RhcmdldCkpIGZpcnN0X3RhcmdldFxuICAgICB8fCBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIDBcbiAgdGhlbiBTb21lIChCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0cl9tYXApXG4gIGVsc2UgTm9uZVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImdsb2JhbF9kYXRhIiwiQmFzZV9DaGFyIiwiQmFzZV9CeXRlczAiLCJCYXNlX0ltcG9ydDAiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpIiwiaW5kZXgiLCJsYXN0X3JlcGxhY2VtZW50IiwiZmlyc3RfdGFyZ2V0IiwiQmFzZV9CeXRlc190ciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxjQUFBQyxRQUFBQztBQUFBQSxRQUFBQyxTQ1llLGdDQUFBQyxNQUNiO0FBQUE7QUFBQSxLQUMrQyxtQ0FBbkI7QUFBQSxhQUFtQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUVsQztBQUFBO0FBQUEsU0FBYjtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQW1FO0FBQUE7QUFBQSxTQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFDLFVBQ3JELHlCQUFaO0FBQUEsTUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBQUM7QUFBQUEsT0FFRjtBQUFBO0FBQUE7QUFBQSxPQUVNO0FBQUE7QUFBQSxTQUROO0FBQUE7QUFBQSxTQUM0RDtBQUFBO0FBQUEsU0FBQUYsTUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxRQUU5Qyx5QkFBWjtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBRSxlQVVpQjtBQUFBLFNBQ2dELDhCQUExQjtBQUFBLElBQXRDO0FBQUEsU0FBQUgsSUFDRztBQUFBO0FBQUEsTUFUSjtBQUFBLGVBQ0s7QUFBQTtBQUFBLGVBQzRDO0FBQUEsT0FBbUIsS0FBNUQseUJBQTRELDBDQUFBQSxNQUUvRDtBQUFBLGVBREE7QUFBQTtBQUFBLE1BTTBCO0FBQUEsTUFFNUI7QUFBQTtBQUFBO0FBQUEsSUFEQTtBQUFBLEdBQ0k7QUFBQSxPQUFBSSxnQkR2Q1giLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODk3MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkJhc2VfU3RyaW5nX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxtQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4OTg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3N0cmluZy5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgVWNoYXIgPSBVY2hhcjBcbmluY2x1ZGUgU3RyaW5nMFxuaW5jbHVkZSBTdHJpbmdfaW50ZlxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX3N0cmluZyA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3N0cmluZ1xuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfc3RyaW5nIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxudHlwZSBlbHQgPSBjaGFyXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbigqIFRoaXMgaXMgY29waWVkL2FkYXB0ZWQgZnJvbSAnYmxpdC5tbCcuXG4gICBbc3ViXSwgW3N1Ym9dIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtCbGl0Lk1ha2UoQnl0ZXMpXSBwbHVzIHVuc2FmZSBjYXN0cyB0by9mcm9tXG4gICBzdHJpbmcgYnV0IHdlcmUgaW5saW5lZCBoZXJlIHRvIGF2b2lkIHVzaW5nIFtCeXRlcy51bnNhZmVfb2Zfc3RyaW5nXSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuKilcbmxldCB1bnNhZmVfc3ViIHNyYyB+cG9zIH5sZW4gPVxuICBpZiBsZW4gPSAwXG4gIHRoZW4gXCJcIlxuICBlbHNlIChcbiAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbjs7XG5cbmxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA9IDAgJiYgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmNcbiAgdGhlbiBzcmNcbiAgZWxzZSAoXG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHNyYyk7XG4gICAgdW5zYWZlX3N1YiBzcmMgfnBvcyB+bGVuKVxuOztcblxubGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gIHN1YlxuICAgIHNyY1xuICAgIH5wb3NcbiAgICB+bGVuOlxuICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgIHwgTm9uZSAtPiBsZW5ndGggc3JjIC0gcG9zKVxuOztcblxubGV0IHJlYyBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfIGNoYXIgPVxuICBwb3MgPCBlbmRfXG4gICYmIChDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHQgcG9zKSBjaGFyIHx8IGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3M6KHBvcyArIDEpIH5lbmRfIGNoYXIpXG47O1xuXG5sZXQgY29udGFpbnMgPyhwb3MgPSAwKSA/bGVuIHQgY2hhciA9XG4gIGxldCB0b3RhbF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9IE9wdGlvbi52YWx1ZSBsZW4gfmRlZmF1bHQ6KHRvdGFsX2xlbmd0aCAtIHBvcykgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXzoocG9zICsgbGVuKSBjaGFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXRbQGlubGluZV0gaW5kZXhfZnJvbV9pbnRlcm5hbCBzdHJpbmcgfmxlbiB+bm90X2ZvdW5kIH5mb3VuZCBjaGFyIH5wb3MgPVxuICBsZXQgcmVjIGxvb3AgfnBvcyA9XG4gICAgaWYgcG9zID49IGxlblxuICAgIHRoZW4gbm90X2ZvdW5kICgpXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgICB0aGVuIGZvdW5kIHBvc1xuICAgIGVsc2UgbG9vcCB+cG9zOihwb3MgKyAxKVxuICBpblxuICBsb29wIH5wb3MgW0Bub250YWlsXVxuOztcblxubGV0IGluZGV4IHQgY2hhciA9XG4gIGluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgY2hhclxuICAgIH5wb3M6MFxuICAgIH5sZW46KGxlbmd0aCB0KVxuICAgIH5mb3VuZDpPcHRpb24uc29tZVxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5kZXhfZXhuIHQgY2hhciA9XG4gIGluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgfnBvczowXG4gICAgfmxlbjoobGVuZ3RoIHQpXG4gICAgfmZvdW5kOkZuLmlkXG4gICAgfm5vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9leG46IG5vdCBmb3VuZFwiKSkpXG4gICAgY2hhciBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgaW5kZXhfZnJvbV9pbnRlcm5hbCB0IGNoYXIgfnBvcyB+bGVuOihsZW5ndGggdCkgfmZvdW5kOk9wdGlvbi5zb21lIH5ub3RfZm91bmQ6KGZ1biAoKSAtPlxuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSkgaW5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSBpbmRleF9mcm9tX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9mcm9tX2V4blxuOztcblxubGV0W0BpbmxpbmVdIHJpbmRleF9mcm9tX2ludGVybmFsIHN0cmluZyBjaGFyIH5mb3VuZCB+bm90X2ZvdW5kIH5wb3MgPVxuICBsZXQgcmVjIGxvb3AgfnBvcyA9XG4gICAgaWYgcG9zIDwgMFxuICAgIHRoZW4gbm90X2ZvdW5kICgpXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgICB0aGVuIGZvdW5kIHBvc1xuICAgIGVsc2UgbG9vcCB+cG9zOihwb3MgLSAxKVxuICBpblxuICBsb29wIH5wb3MgW0Bub250YWlsXVxuOztcblxubGV0IHJpbmRleCB0IGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbFxuICAgIHRcbiAgICBjaGFyXG4gICAgfnBvczoobGVuZ3RoIHQgLSAxKVxuICAgIH5mb3VuZDpPcHRpb24uc29tZVxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmluZGV4X2V4biB0IGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbFxuICAgIHRcbiAgICBjaGFyXG4gICAgfnBvczoobGVuZ3RoIHQgLSAxKVxuICAgIH5mb3VuZDpGbi5pZFxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2V4bjogbm90IGZvdW5kXCIpKSlcbiAgW0Bub250YWlsXVxuOztcblxubGV0IHJpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbCB0IGNoYXIgfnBvcyB+Zm91bmQ6T3B0aW9uLnNvbWUgfm5vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuOztcblxubGV0IHJpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCByaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgaWYgcG9zIDwgLTEgfHwgcG9zID49IGxlbmd0aCB0XG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG5cIlxuICAgIGVsc2UgcmluZGV4X2Zyb21faW50ZXJuYWwgdCB+cG9zIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZnJvbV9leG5cbjs7XG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybjAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5ID0gXyB9IDogU2V4cC50ID1cbiAgICBMaXN0XG4gICAgICBbIExpc3QgWyBBdG9tIFwicGF0dGVyblwiOyBzZXhwX29mX3N0cmluZyBwYXR0ZXJuIF1cbiAgICAgIDsgTGlzdCBbIEF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmUgXVxuICAgICAgXVxuICA7O1xuXG4gIGxldCBwYXR0ZXJuIHQgPSB0LnBhdHRlcm5cbiAgbGV0IGNhc2Vfc2Vuc2l0aXZlIHQgPSB0LmNhc2Vfc2Vuc2l0aXZlXG5cbiAgKCogRmluZCBtYXggbnVtYmVyIG9mIG1hdGNoZWQgY2hhcmFjdGVycyBhdCBbbmV4dF90ZXh0X2NoYXJdLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICBbbWF0Y2hlZF9jaGFyc10uIFRyeSB0byBleHRlbmQgdGhlIGN1cnJlbnQgbWF0Y2gsIGlmIGNoYXJzIGRvbid0IG1hdGNoLCB0cnkgdG8gbWF0Y2hcbiAgICAgZmV3ZXIgY2hhcnMuIElmIGNoYXJzIG1hdGNoIHRoZW4gZXh0ZW5kIHRoZSBtYXRjaC4gKilcbiAgbGV0IGttcF9pbnRlcm5hbF9sb29wIH5tYXRjaGVkX2NoYXJzIH5uZXh0X3RleHRfY2hhciB+cGF0dGVybiB+a21wX2FycmF5IH5jaGFyX2VxdWFsID1cbiAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiBtYXRjaGVkX2NoYXJzIGluXG4gICAgd2hpbGVcbiAgICAgICFtYXRjaGVkX2NoYXJzID4gMFxuICAgICAgJiYgbm90IChjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpKVxuICAgIGRvXG4gICAgICBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5ICghbWF0Y2hlZF9jaGFycyAtIDEpXG4gICAgZG9uZTtcbiAgICBpZiBjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpXG4gICAgdGhlbiBtYXRjaGVkX2NoYXJzIDo9ICFtYXRjaGVkX2NoYXJzICsgMTtcbiAgICAhbWF0Y2hlZF9jaGFyc1xuICA7O1xuXG4gIGxldCBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIG1hdGNoIGNhc2Vfc2Vuc2l0aXZlIHdpdGhcbiAgICB8IHRydWUgLT4gQ2hhci5lcXVhbFxuICAgIHwgZmFsc2UgLT4gQ2hhci5DYXNlbGVzcy5lcXVhbFxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QIHByZS1wcm9jZXNzaW5nIG9mIHRoZSBwYXR0ZXJuOiBidWlsZCB0aGUgaW50IGFycmF5LCB3aGljaCwgZm9yIGVhY2ggaSxcbiAgICAgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBub24tdHJpdmlhbCBwcmVmaXggb2YgcyB3aGljaCBpcyBlcXVhbCB0byBhIHN1ZmZpeFxuICAgICBlbmRpbmcgYXQgcy5baV0gKilcbiAgbGV0IGNyZWF0ZSBwYXR0ZXJuIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbGV0IG4gPSBsZW5ndGggcGF0dGVybiBpblxuICAgIGxldCBrbXBfYXJyYXkgPSBBcnJheS5jcmVhdGUgfmxlbjpuICgtMSkgaW5cbiAgICBpZiBuID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IDAgMDtcbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXI6KHVuc2FmZV9nZXQgcGF0dGVybiBpKVxuICAgICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSBpICFtYXRjaGVkX2NoYXJzXG4gICAgICBkb25lKTtcbiAgICB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfVxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QOiB1c2UgdGhlIHByZS1wcm9jZXNzZWQgcGF0dGVybiB0byBvcHRpbWl6ZSBsb29rLWJlaGluZHMgb24gbm9uLW1hdGNoZXMuXG4gICAgIFdlIHJldHVybiBpbnQgdG8gYXZvaWQgYWxsb2NhdGlvbiBpbiBbaW5kZXhfZXhuXS4gLTEgbWVhbnMgbm8gbWF0Y2guICopXG4gIGxldCBpbmRleF9pbnRlcm5hbCA/KHBvcyA9IDApIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5pbl86dGV4dCA9XG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5ndGggdGV4dCAtIGxlbmd0aCBwYXR0ZXJuXG4gICAgdGhlbiAtMVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBqID0gcmVmIHBvcyBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgd2hpbGUgIWogPCBuICYmICFtYXRjaGVkX2NoYXJzIDwgayBkb1xuICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgIWogaW5cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIGogOj0gIWogKyAxXG4gICAgICBkb25lO1xuICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrIHRoZW4gIWogLSBrIGVsc2UgLTEpXG4gIDs7XG5cbiAgbGV0IG1hdGNoZXMgdCBzdHIgPSBpbmRleF9pbnRlcm5hbCB0IH5pbl86c3RyID49IDBcblxuICBsZXQgaW5kZXggP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwIDwgMCB0aGVuIE5vbmUgZWxzZSBTb21lIHBcbiAgOztcblxuICBsZXQgaW5kZXhfZXhuID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA+PSAwXG4gICAgdGhlbiBwXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiU3Vic3RyaW5nIG5vdCBmb3VuZFwiIFsgXCJzdWJzdHJpbmdcIiwgc2V4cF9vZl9zdHJpbmcgdC5wYXR0ZXJuIF0pXG4gIDs7XG5cbiAgbGV0IGluZGV4X2FsbCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+bWF5X292ZXJsYXAgfmluXzp0ZXh0ID1cbiAgICBpZiBsZW5ndGggcGF0dGVybiA9IDBcbiAgICB0aGVuIExpc3QuaW5pdCAoMSArIGxlbmd0aCB0ZXh0KSB+ZjpGbi5pZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIGxldCBmb3VuZCA9IHJlZiBbXSBpblxuICAgICAgZm9yIGogPSAwIHRvIG4gZG9cbiAgICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGZvdW5kIDo9IChqIC0gaykgOjogIWZvdW5kO1xuICAgICAgICAgICgqIHdlIGp1c3QgZm91bmQgYSBtYXRjaCBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICopXG4gICAgICAgICAgbWF0Y2ggbWF5X292ZXJsYXAgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPiBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5IChrIC0gMSlcbiAgICAgICAgICB8IGZhbHNlIC0+IG1hdGNoZWRfY2hhcnMgOj0gMCk7XG4gICAgICAgIGlmIGogPCBuXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCBqIGluXG4gICAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgICAgfmNoYXJfZXF1YWwpXG4gICAgICBkb25lO1xuICAgICAgTGlzdC5yZXYgIWZvdW5kKVxuICA7O1xuXG4gIGxldCByZXBsYWNlX2ZpcnN0ID9wb3MgdCB+aW5fOnMgfndpdGhfID1cbiAgICBtYXRjaCBpbmRleCA/cG9zIHQgfmluXzpzIHdpdGhcbiAgICB8IE5vbmUgLT4gc1xuICAgIHwgU29tZSBpIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArIGxlbl93aXRoIC0gbGVuX3QpIGluXG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjppO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp3aXRoXyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6aSB+bGVuOmxlbl93aXRoO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOihpICsgbGVuX3QpXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6KGkgKyBsZW5fd2l0aClcbiAgICAgICAgfmxlbjoobGVuX3MgLSBpIC0gbGVuX3QpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuICBsZXQgcmVwbGFjZV9hbGwgdCB+aW5fOnMgfndpdGhfID1cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBtYXRjaCBtYXRjaGVzIHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IGxlbl9zID0gbGVuZ3RoIHMgaW5cbiAgICAgIGxldCBsZW5fdCA9IGxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICAgIGxldCBsZW5fd2l0aCA9IGxlbmd0aCB3aXRoXyBpblxuICAgICAgbGV0IG51bV9tYXRjaGVzID0gTGlzdC5sZW5ndGggbWF0Y2hlcyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuX3MgKyAoKGxlbl93aXRoIC0gbGVuX3QpICogbnVtX21hdGNoZXMpKSBpblxuICAgICAgbGV0IG5leHRfZHN0X3BvcyA9IHJlZiAwIGluXG4gICAgICBsZXQgbmV4dF9zcmNfcG9zID0gcmVmIDAgaW5cbiAgICAgIExpc3QuaXRlciBtYXRjaGVzIH5mOihmdW4gaSAtPlxuICAgICAgICBsZXQgbGVuID0gaSAtICFuZXh0X3NyY19wb3MgaW5cbiAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5zcmNfcG9zOiFuZXh0X3NyY19wb3MgfmRzdCB+ZHN0X3BvczohbmV4dF9kc3RfcG9zIH5sZW47XG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgICAgfnNyYzp3aXRoX1xuICAgICAgICAgIH5zcmNfcG9zOjBcbiAgICAgICAgICB+ZHN0XG4gICAgICAgICAgfmRzdF9wb3M6KCFuZXh0X2RzdF9wb3MgKyBsZW4pXG4gICAgICAgICAgfmxlbjpsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9kc3RfcG9zIDo9ICFuZXh0X2RzdF9wb3MgKyBsZW4gKyBsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9zcmNfcG9zIDo9ICFuZXh0X3NyY19wb3MgKyBsZW4gKyBsZW5fdCk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6IW5leHRfc3JjX3Bvc1xuICAgICAgICB+ZHN0XG4gICAgICAgIH5kc3RfcG9zOiFuZXh0X2RzdF9wb3NcbiAgICAgICAgfmxlbjoobGVuX3MgLSAhbmV4dF9zcmNfcG9zKTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0XG4gIDs7XG5cbiAgbGV0IHNwbGl0X29uIHQgcyA9XG4gICAgbGV0IHBhdHRlcm5fbGVuID0gU3RyaW5nLmxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBMaXN0Lm1hcDJfZXhuXG4gICAgICAoLXBhdHRlcm5fbGVuIDo6IG1hdGNoZXMpXG4gICAgICAobWF0Y2hlcyBAIFsgU3RyaW5nLmxlbmd0aCBzIF0pXG4gICAgICB+ZjooZnVuIGkgaiAtPiBzdWIgcyB+cG9zOihpICsgcGF0dGVybl9sZW4pIH5sZW46KGogLSBpIC0gcGF0dGVybl9sZW4pKVxuICA7O1xuXG4gIG1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gICAgdHlwZSBwdWJsaWMgPSB0XG5cbiAgICB0eXBlIG5vbnJlYyB0ID0gdCA9XG4gICAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgICA7IGttcF9hcnJheSA6IGludCBhcnJheVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBlcXVhbCB+bG9jYWxpemUsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWxfX2xvY2FsID1cbiAgICAgIChmdW4gYV9fMDAzXyBiX18wMDRfIC0+XG4gICAgICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwM18gYl9fMDA0X1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIFN0ZGxpYi4oICYmIClcbiAgICAgICAgICAgICAoZXF1YWxfc3RyaW5nX19sb2NhbCBhX18wMDNfLnBhdHRlcm4gYl9fMDA0Xy5wYXR0ZXJuKVxuICAgICAgICAgICAgIChTdGRsaWIuKCAmJiApXG4gICAgICAgICAgICAgICAgKGVxdWFsX2Jvb2xfX2xvY2FsIGFfXzAwM18uY2FzZV9zZW5zaXRpdmUgYl9fMDA0Xy5jYXNlX3NlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAoZXF1YWxfYXJyYXlfX2xvY2FsIGVxdWFsX2ludF9fbG9jYWwgYV9fMDAzXy5rbXBfYXJyYXkgYl9fMDA0Xy5rbXBfYXJyYXkpKVxuICAgICAgICA6IHQgLT4gdCAtPiBib29sKVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgICBsZXQgc2V4cF9vZl90ID1cbiAgICAgIChmdW4geyBwYXR0ZXJuID0gcGF0dGVybl9fMDA4X1xuICAgICAgICAgICA7IGNhc2Vfc2Vuc2l0aXZlID0gY2FzZV9zZW5zaXRpdmVfXzAxMF9cbiAgICAgICAgICAgOyBrbXBfYXJyYXkgPSBrbXBfYXJyYXlfXzAxMl9cbiAgICAgICAgICAgfSAtPlxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICAgICBsZXQgYm5kc19fMDA3XyA9XG4gICAgICAgICAgIGxldCBhcmdfXzAxM18gPSBzZXhwX29mX2FycmF5IHNleHBfb2ZfaW50IGttcF9hcnJheV9fMDEyXyBpblxuICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwia21wX2FycmF5XCI7IGFyZ19fMDEzXyBdIDo6IGJuZHNfXzAwN19cbiAgICAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgYm5kc19fMDA3XyA9XG4gICAgICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmVfXzAxMF8gaW5cbiAgICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IGFyZ19fMDExXyBdXG4gICAgICAgICAgICA6OiBibmRzX18wMDdfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPVxuICAgICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA4XyBpblxuICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicGF0dGVyblwiOyBhcmdfXzAwOV8gXSA6OiBibmRzX18wMDdfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICBpblxuICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwN19cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCByZXByZXNlbnRhdGlvbiA9IEZuLmlkXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybl9oZWxwZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlYXJjaF9wYXR0ZXJuID0gU2VhcmNoX3BhdHRlcm4wXG5lbmRcblxub3BlbiBTZWFyY2hfcGF0dGVybl9oZWxwZXJcblxubGV0IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2V4biA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5tYXlfb3ZlcmxhcCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2FsbFxuICAgIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pXG4gICAgfm1heV9vdmVybGFwXG4gICAgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2ZpcnN0ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfYWxsIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnN1YnN0cmluZyA9XG4gIE9wdGlvbi5pc19zb21lIChzdWJzdHJfaW5kZXhfZ2VuIHQgfnBhdHRlcm46c3Vic3RyaW5nIH5jYXNlX3NlbnNpdGl2ZSlcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxuXG5sZXQgaXNfc3Vic3RyaW5nX2F0X2dlbiA9XG4gIGxldCByZWMgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3MgfnN1Yl9sZW4gfmNoYXJfZXF1YWwgPVxuICAgIGlmIHN1Yl9wb3MgPSBzdWJfbGVuXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBjaGFyX2VxdWFsICh1bnNhZmVfZ2V0IHN0ciBzdHJfcG9zKSAodW5zYWZlX2dldCBzdWIgc3ViX3BvcylcbiAgICB0aGVuIGxvb3AgfnN0ciB+c3RyX3Bvczooc3RyX3BvcyArIDEpIH5zdWIgfnN1Yl9wb3M6KHN1Yl9wb3MgKyAxKSB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuICAgIGVsc2UgZmFsc2VcbiAgaW5cbiAgZnVuIHN0ciB+cG9zOnN0cl9wb3MgfnN1YnN0cmluZzpzdWIgfmNoYXJfZXF1YWwgLT5cbiAgICBsZXQgc3RyX2xlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgc3ViX2xlbiA9IGxlbmd0aCBzdWIgaW5cbiAgICBpZiBzdHJfcG9zIDwgMCB8fCBzdHJfcG9zID4gc3RyX2xlblxuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIlN0cmluZy5pc19zdWJzdHJpbmdfYXQ6IGludmFsaWQgaW5kZXggJWQgZm9yIHN0cmluZyBvZiBsZW5ndGggJWRcIlxuICAgICAgICBzdHJfcG9zXG4gICAgICAgIHN0cl9sZW5cbiAgICAgICAgKCk7XG4gICAgc3RyX3BvcyArIHN1Yl9sZW4gPD0gc3RyX2xlblxuICAgICYmIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zOjAgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19zdWZmaXhfZ2VuIHN0cmluZyB+c3VmZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBzdHJpbmdfbGVuID49IHN1ZmZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlblxuICAgICAgIHN0cmluZ1xuICAgICAgIH5wb3M6KHN0cmluZ19sZW4gLSBzdWZmaXhfbGVuKVxuICAgICAgIH5zdWJzdHJpbmc6c3VmZml4XG4gICAgICAgfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19wcmVmaXhfZ2VuIHN0cmluZyB+cHJlZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBwcmVmaXhfbGVuID0gbGVuZ3RoIHByZWZpeCBpblxuICBzdHJpbmdfbGVuID49IHByZWZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlbiBzdHJpbmcgfnBvczowIH5zdWJzdHJpbmc6cHJlZml4IH5jaGFyX2VxdWFsXG47O1xuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgYzEgYzIgPSBDaGFyLmNvbXBhcmUgKENoYXIubG93ZXJjYXNlIGMxKSAoQ2hhci5sb3dlcmNhc2UgYzIpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfbG9vcCB+cG9zIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yID1cbiAgICAgIGlmIHBvcyA9IGxlbjFcbiAgICAgIHRoZW4gaWYgcG9zID0gbGVuMiB0aGVuIDAgZWxzZSAtMVxuICAgICAgZWxzZSBpZiBwb3MgPSBsZW4yXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXJfY29tcGFyZV9jYXNlbGVzcyAodW5zYWZlX2dldCBzdHJpbmcxIHBvcykgKHVuc2FmZV9nZXQgc3RyaW5nMiBwb3MpIGluXG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9sb29wIH5wb3M6KHBvcyArIDEpIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yXG4gICAgICAgIHwgXyAtPiBjKVxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgc3RyaW5nMSBzdHJpbmcyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgc3RyaW5nMSBzdHJpbmcyXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgY29tcGFyZV9sb29wXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfnN0cmluZzFcbiAgICAgICAgICB+bGVuMTooU3RyaW5nLmxlbmd0aCBzdHJpbmcxKVxuICAgICAgICAgIH5zdHJpbmcyXG4gICAgICAgICAgfmxlbjI6KFN0cmluZy5sZW5ndGggc3RyaW5nMilcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgYSBiID0gY29tcGFyZV9fbG9jYWwgYSBiXG5cbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9XG4gICAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICAgIGxldCBzdGF0ZSA9IHJlZiAoaGFzaF9mb2xkX2ludCBzdGF0ZSBsZW4pIGluXG4gICAgICBmb3IgcG9zID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIHN0YXRlIDo9IGhhc2hfZm9sZF9jaGFyICFzdGF0ZSAoQ2hhci5sb3dlcmNhc2UgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICAgICAgZG9uZTtcbiAgICAgICFzdGF0ZVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICAgIGxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBpc19wcmVmaXggcyB+cHJlZml4ID0gaXNfcHJlZml4X2dlbiBzIH5wcmVmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZ19hdCA9IGlzX3N1YnN0cmluZ19hdF9nZW4gfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxubGV0IG9mX3N0cmluZyA9IEZuLmlkXG5sZXQgdG9fc3RyaW5nID0gRm4uaWRcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIEJ5dGVzLnNldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA8IDAgdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpIC0gMSkgaW5cbiAgbG9vcCBbXSAobGVuZ3RoIHMgLSAxKVxuOztcblxubGV0IHRvX2xpc3RfcmV2IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA9IGxlbiB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgKyAxKSBpblxuICBsb29wIFtdIDBcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIGkgKHVuc2FmZV9nZXQgdCAobGVuIC0gMSAtIGkpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlc1xuOztcblxuKCoqIEVmZmljaWVudCBzdHJpbmcgc3BsaXR0aW5nICopXG5cbmxldCBsc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcubHNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSkgaW5cbiAgbGV0IGxzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGxpbmUgaW5cbiAgICBsZXQgcG9zID0gaW5kZXhfZnJvbV9pbnRlcm5hbCBsaW5lIH5wb3M6MCB+bGVuIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW4gLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGxzcGxpdDJfZXhuXG47O1xuXG5sZXQgcnNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kICgpID0gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJzcGxpdDJfZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCByc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCBsaW5lIGluXG4gICAgbGV0IHBvcyA9IHJpbmRleF9mcm9tX2ludGVybmFsIGxpbmUgfnBvczoobGVuIC0gMSkgfm5vdF9mb3VuZCB+Zm91bmQ6Rm4uaWQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbiAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcnNwbGl0Ml9leG5cbjs7XG5cbmxldCBsc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKGxzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAocnNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBmIGMpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGkgLT4gU29tZSB0LltpXVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZiB0LltpXSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzKVxuICBpblxuICBsb29wIDAgW0Bub250YWlsXVxuOztcblxubGV0IHJmaW5kaSA/cG9zIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgLSAxKSBpblxuICBsZXQgcG9zID1cbiAgICBtYXRjaCBwb3Mgd2l0aFxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gICAgfCBOb25lIC0+IGxlbmd0aCB0IC0gMVxuICBpblxuICBsb29wIHBvcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKSBbQG5vbnRhaWxdXG5cbmxldCByc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG47O1xuXG5sZXQgZmlyc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSkgW0Bub250YWlsXVxuXG5sZXQgbHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgMCAtPiB0XG4gIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuOztcblxuKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxubGV0IHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiBpIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IG1hcCB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAobGVuZ3RoIHMpIH5mOihmdW4gaSAtPiBzLltpXSlcblxubGV0IGV4aXN0cyA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPCBsZW4gJiYgKGYgcy5baV0gfHwgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9yX2FsbCA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPSBsZW4gfHwgKGYgcy5baV0gJiYgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgaSBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHRcbmxldCBtYXhfZWx0IHQgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0XG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbmxldCBmaW5kX21hcGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxubGV0IGZpbmRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kaSB+aXRlcmkgdCB+ZlxubGV0IGNvdW50aSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuY291bnRpIH5mb2xkaSB0IH5mXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZvcl9hbGxpIH5pdGVyaSB0IH5mXG5sZXQgZXhpc3RzaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZXhpc3RzaSB+aXRlcmkgdCB+ZlxuXG5sZXQgbWVtID1cbiAgbGV0IHJlYyBsb29wIHQgYyB+cG9zOmkgfmxlbiA9XG4gICAgaSA8IGxlbiAmJiAoQ2hhci5lcXVhbCBjICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IGMgfnBvczooaSArIDEpIH5sZW4pXG4gIGluXG4gIGZ1biB0IGMgLT4gbG9vcCB0IGMgfnBvczowIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBpZiBDaGFyLmVxdWFsIHRhcmdldCByZXBsYWNlbWVudFxuICB0aGVuIHNcbiAgZWxzZSBpZiBtZW0gcyB0YXJnZXRcbiAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gaWYgQ2hhci5lcXVhbCBjIHRhcmdldCB0aGVuIHJlcGxhY2VtZW50IGVsc2UgYylcbiAgZWxzZSBzXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBpc19lbXB0eSB0YXJnZXRcbiAgdGhlbiBzdGFnZSBGbi5pZFxuICBlbHNlIGlmIGlzX2VtcHR5IHJlcGxhY2VtZW50XG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aSByZXBsYWNlbWVudCBpcyBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgRm4uaWRcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgaWYgZXhpc3RzIHMgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgKHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSkpXG4gICAgICAgIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSlcbiAgICAgICAgZWxzZSBzKSlcbjs7XG5cbigqIGZhc3QgdmVyc2lvbiwgaWYgd2UgZXZlciBuZWVkIGl0OlxuICAge1tcbiAgICAgbGV0IGNvbmNhdF9hcnJheSB+c2VwIGFyID1cbiAgICAgICBsZXQgYXJfbGVuID0gQXJyYXkubGVuZ3RoIGFyIGluXG4gICAgICAgaWYgYXJfbGVuID0gMCB0aGVuIFwiXCJcbiAgICAgICBlbHNlXG4gICAgICAgICBsZXQgc2VwX2xlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgIGxldCByZXNfbGVuX3JlZiA9IHJlZiAoc2VwX2xlbiAqIChhcl9sZW4gLSAxKSkgaW5cbiAgICAgICAgIGZvciBpID0gMCB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIHJlc19sZW5fcmVmIDo9ICFyZXNfbGVuX3JlZiArIGxlbmd0aCBhci4oaSlcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICBsZXQgcmVzID0gY3JlYXRlICFyZXNfbGVuX3JlZiBpblxuICAgICAgICAgbGV0IHN0cl8wID0gYXIuKDApIGluXG4gICAgICAgICBsZXQgbGVuXzAgPSBsZW5ndGggc3RyXzAgaW5cbiAgICAgICAgIGJsaXQgfnNyYzpzdHJfMCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjAgfmxlbjpsZW5fMDtcbiAgICAgICAgIGxldCBwb3NfcmVmID0gcmVmIGxlbl8wIGluXG4gICAgICAgICBmb3IgaSA9IDEgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICBsZXQgcG9zID0gIXBvc19yZWYgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnNlcCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOnBvcyB+bGVuOnNlcF9sZW47XG4gICAgICAgICAgIGxldCBuZXdfcG9zID0gcG9zICsgc2VwX2xlbiBpblxuICAgICAgICAgICBsZXQgc3RyX2kgPSBhci4oaSkgaW5cbiAgICAgICAgICAgbGV0IGxlbl9pID0gbGVuZ3RoIHN0cl9pIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzdHJfaSB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOm5ld19wb3MgfmxlbjpsZW5faTtcbiAgICAgICAgICAgcG9zX3JlZiA6PSBuZXdfcG9zICsgbGVuX2lcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICByZXNcbiAgIF19ICopXG5cbmxldCBjb25jYXRfYXJyYXkgP3NlcCBhciA9IGNvbmNhdCA/c2VwIChBcnJheS50b19saXN0IGFyKVxubGV0IGNvbmNhdF9tYXAgP3NlcCBzIH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcCAodG9fYXJyYXkgcykgfmYpXG5sZXQgY29uY2F0X21hcGkgP3NlcCB0IH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcGkgKHRvX2FycmF5IHQpIH5mKVxuXG5sZXQgY29uY2F0X2xpbmVzID1cbiAgbGV0IHJlYyBsaW5lX2xlbmd0aHMgfmxpbmVzIH5uZXdsaW5lX2xlbiB+c3VtID1cbiAgICBtYXRjaCBsaW5lcyB3aXRoXG4gICAgfCBbXSAtPiBzdW1cbiAgICB8IGxpbmUgOjogbGluZXMgLT5cbiAgICAgIGxldCBzdW0gPSBzdW0gKyBTdHJpbmcubGVuZ3RoIGxpbmUgKyBuZXdsaW5lX2xlbiBpblxuICAgICAgbGluZV9sZW5ndGhzIH5saW5lcyB+bmV3bGluZV9sZW4gfnN1bVxuICBpblxuICBsZXQgcmVjIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3MgPVxuICAgIG1hdGNoIGxpbmVzIHdpdGhcbiAgICB8IFtdIC0+IHBvc1xuICAgIHwgbGluZSA6OiBsaW5lcyAtPlxuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6bGluZVxuICAgICAgICB+c3JjX3BvczowXG4gICAgICAgIH5kc3Q6YnVmXG4gICAgICAgIH5kc3RfcG9zOnBvc1xuICAgICAgICB+bGVuOihTdHJpbmcubGVuZ3RoIGxpbmUpO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIFN0cmluZy5sZW5ndGggbGluZSBpblxuICAgICAgbGV0IHBvcyA9XG4gICAgICAgIGlmIGNybGZcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXHInO1xuICAgICAgICAgIHBvcyArIDEpXG4gICAgICAgIGVsc2UgcG9zXG4gICAgICBpblxuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXG4nO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIDEgaW5cbiAgICAgIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3NcbiAgaW5cbiAgZnVuID8oY3JsZiA9IGZhbHNlKSBsaW5lcyAtPlxuICAgIGxldCBuZXdsaW5lX2xlbiA9IGlmIGNybGYgdGhlbiAyIGVsc2UgMSBpblxuICAgIGxldCBsZW4gPSBsaW5lX2xlbmd0aHMgfm5ld2xpbmVfbGVuIH5saW5lcyB+c3VtOjAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCB3cml0dGVuID0gd3JpdGVfbGluZXMgfmJ1ZiB+bGluZXMgfmNybGYgfnBvczowIGluXG4gICAgYXNzZXJ0ICh3cml0dGVuID0gbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ1ZlxuOztcblxuKCogW2ZpbHRlciB0IGZdIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuXG4gICBMZXQgW24gPSBsZW5ndGggdF0uXG5cbiAgIDEuIEZpbmQgdGhlIGxvd2VzdCBbaV0gc3VjaCB0aGF0IFtub3QgKGYgdC5baV0pXS5cblxuICAgMi4gSWYgdGhlcmUgaXMgbm8gc3VjaCBbaV0sIHRoZW4gcmV0dXJuIFt0XS5cblxuICAgMy4gSWYgdGhlcmUgaXMgc3VjaCBhbiBbaV0sIGFsbG9jYXRlIGEgc3RyaW5nLCBbb3V0XSwgdG8gaG9sZCB0aGUgcmVzdWx0LiAgW291dF0gaGFzXG4gICBsZW5ndGggW24gLSAxXSwgd2hpY2ggaXMgdGhlIG1heGltdW0gcG9zc2libGUgb3V0cHV0IHNpemUgZ2l2ZW4gdGhhdCB0aGVyZSBpcyBhdCBsZWFzdFxuICAgb25lIGNoYXJhY3RlciBub3Qgc2F0aXNmeWluZyBbZl0uXG5cbiAgIDQuIENvcHkgY2hhcmFjdGVycyBhdCBpbmRpY2VzIDAgLi4uIFtpIC0gMV0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDUuIFdhbGsgdGhyb3VnaCBjaGFyYWN0ZXJzIGF0IGluZGljZXMgW2krMV0gLi4uIFtuLTFdIG9mIFt0XSwgY29weWluZyB0aG9zZSB0aGF0XG4gICBzYXRpc2Z5IFtmXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNi4gSWYgd2UgY29tcGxldGVseSBmaWxsZWQgW291dF0sIHRoZW4gcmV0dXJuIGl0LiAgSWYgbm90LCByZXR1cm4gdGhlIHByZWZpeCBvZiBbb3V0XVxuICAgdGhhdCB3ZSBkaWQgZmlsbCBpbi5cblxuICAgVGhpcyBhbGdvcml0aG0gaGFzIHRoZSBwcm9wZXJ0eSB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgYSBuZXcgc3RyaW5nIGlmIHRoZXJlJ3NcbiAgIG5vdGhpbmcgdG8gZmlsdGVyLCB3aGljaCBpcyBhIGNvbW1vbiBjYXNlLiAqKVxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgIWkgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgIWkgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIFNvbWUgKGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9pZl9leGlzdHMgcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3BfcHJlZml4X2V4biBzIH5wcmVmaXggPVxuICBtYXRjaCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3BfcHJlZml4X2V4biAlUyAlU1wiIHMgcHJlZml4ICgpXG47O1xuXG5sZXQgY2hvcF9zdWZmaXggcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIFNvbWUgKGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9pZl9leGlzdHMgcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3Bfc3VmZml4X2V4biBzIH5zdWZmaXggPVxuICBtYXRjaCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3Bfc3VmZml4X2V4biAlUyAlU1wiIHMgc3VmZml4ICgpXG47O1xuXG5tb2R1bGUgRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeCA9IHN0cnVjdFxuICAoKiBXaGVuIHRha2luZyBhIHN0cmluZyBwcmVmaXggb3Igc3VmZml4LCB3ZSBleHRyYWN0IGZyb20gdGhlIHNob3J0ZXN0IGlucHV0IGF2YWlsYWJsZVxuICAgICBpbiBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiBvbmUgb2Ygb3VyIGlucHV0cyB3aXRob3V0IGFsbG9jYXRpbmcgYSBuZXcgc3RyaW5nLiAqKVxuXG4gIGxldCBzaG9ydGVyIGEgYiA9IGlmIGxlbmd0aCBhIDw9IGxlbmd0aCBiIHRoZW4gYSBlbHNlIGJcblxuICBsZXQgc2hvcnRlc3QgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+IExpc3QuZm9sZCByZXN0IH5pbml0OmZpcnN0IH5mOnNob3J0ZXJcbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgZm9yIGNvbW1vbiBwcmVmaXgvc3VmZml4IGFic3RyYWN0IG92ZXIgW2dldF9wb3NdLCB3aGljaCBpc1xuICAgICBlaXRoZXIgW3Bvc19mcm9tX2xlZnRdIG9yIFtwb3NfZnJvbV9yaWdodF0uICopXG5cbiAgbGV0IHBvc19mcm9tX2xlZnQgKF8gOiB0KSAoaSA6IGludCkgPSBpXG4gIGxldCBwb3NfZnJvbV9yaWdodCB0IGkgPSBsZW5ndGggdCAtIGkgLSAxXG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyID1cbiAgICBpZiBsZW5fc29fZmFyID49IG1heF9sZW5cbiAgICB0aGVuIG1heF9sZW5cbiAgICBlbHNlIGlmIENoYXIuZXF1YWxcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYSAoZ2V0X3BvcyBhIGxlbl9zb19mYXIpKVxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBiIChnZXRfcG9zIGIgbGVuX3NvX2ZhcikpXG4gICAgdGhlbiBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOihsZW5fc29fZmFyICsgMSlcbiAgICBlbHNlIGxlbl9zb19mYXJcbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgPVxuICAgIGxldCBtYXhfbGVuID0gbWluIChsZW5ndGggYSkgKGxlbmd0aCBiKSBpblxuICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICA7O1xuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgbGlzdCB+Z2V0X3BvcyB+bWF4X2xlbiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBtYXhfbGVuXG4gICAgfCBzZWNvbmQgOjogcmVzdCAtPlxuICAgICAgbGV0IG1heF9sZW4gPVxuICAgICAgICAoKiBXZSBjYWxsIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoXSBzb1xuICAgICAgICAgICB0aGF0IFttYXhfbGVuXSBsaW1pdHMgb3VyIHRyYXZlcnNhbCBvZiBbZmlyc3RdIGFuZCBbc2Vjb25kXS4gKilcbiAgICAgICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGZpcnN0IHNlY29uZCB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gICAgICBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3Agc2Vjb25kIHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3MgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gMFxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogUHJlY29tcHV0aW5nIFttYXhfbGVuXSBiYXNlZCBvbiBbc2hvcnRlc3QgbGlzdF0gc2F2ZXMgdXMgd29yayBpbiBsb25nZXIgc3RyaW5ncyxcbiAgICAgICAgIGF0IHRoZSBjb3N0IG9mIGFuIGV4dHJhIHBhc3Mgb3ZlciB0aGUgc3BpbmUgb2YgW2xpc3RdLlxuXG4gICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBsb25nZXN0IHByZWZpeCBvZiB0aGUgc3RyaW5nczpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIGxldCBsb25nX2EgPSBMaXN0LmluaXQgMTAwMCB+ZjooRm4uY29uc3QgJ2EnKVxuICAgICAgICAgICAgWyBsb25nX2E7IGxvbmdfYTsgJ2FhJyBdXG4gICAgICAgICB2fVxuXG4gICAgICAgICB0aGUgYXBwcm9hY2ggYmVsb3cgd2lsbCBqdXN0IGNoZWNrIHRoZSBmaXJzdCB0d28gY2hhcmFjdGVycyBvZiBhbGwgdGhlIHN0cmluZ3MuXG4gICAgICAqKVxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggKHNob3J0ZXN0IGxpc3QpIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIHRoYXQgcHJvZHVjZSBhIHN0cmluZyBhYnN0cmFjdCBvdmVyIFt0YWtlXSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgIFtwcmVmaXhdIG9yIFtzdWZmaXhdLiAqKVxuXG4gIGxldCBjb21tb25fZ2VuZXJpYzIgYSBiIH5nZXRfcG9zIH50YWtlID1cbiAgICBsZXQgbGVuID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgaW5cbiAgICAoKiBVc2UgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBzdHJpbmdzLCBzbyB0aGF0IGlmIHRoZSBzaG9ydGVyIG9uZSBpcyB0aGUgc2hhcmVkXG4gICAgICAgcHJlZml4LCBbdGFrZV0gd29uJ3QgYWxsb2NhdGUgYW5vdGhlciBzdHJpbmcuICopXG4gICAgdGFrZSAoc2hvcnRlciBhIGIpIGxlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYyBsaXN0IH5nZXRfcG9zIH50YWtlID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIEFzIHdpdGggW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0sIHdlIGJhc2UgW21heF9sZW5dIG9uIFtzaG9ydGVzdCBsaXN0XS4gV2UgYWxzb1xuICAgICAgICAgdXNlIHRoaXMgcmVzdWx0IGZvciBbdGFrZV0sIGJlbG93LCB0byBwb3RlbnRpYWxseSBhdm9pZCBhbGxvY2F0aW5nIGEgc3RyaW5nLiAqKVxuICAgICAgbGV0IHMgPSBzaG9ydGVzdCBsaXN0IGluXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCBzIGluXG4gICAgICBpZiBtYXhfbGVuID0gMFxuICAgICAgdGhlbiBcIlwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgKCogV2UgY2FsbCBkaXJlY3RseSBpbnRvIFtjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSB0byBhdm9pZCByZWNvbXB1dGluZyBbc2hvcnRlc3QgbGlzdF0uICopXG4gICAgICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICAgICAgICBpblxuICAgICAgICB0YWtlIHMgbGVuKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeFxuXG4gIGxldCBjb21tb25fcHJlZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbmVuZFxuXG4oKiBUaGVyZSB1c2VkIHRvIGJlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIHRoYXQgd2FzIGZhc3RlciBmb3IgdmVyeSBzaG9ydCBzdHJpbmdzXG4gICAocGVha2luZyBhdCA0MCUgZmFzdGVyIGZvciA0LTYgY2hhciBsb25nIHN0cmluZ3MpLlxuICAgVGhpcyBuZXcgZnVuY3Rpb24gaXMgYXJvdW5kIDIwJSBmYXN0ZXIgdGhhbiB0aGUgZGVmYXVsdCBoYXNoIGZ1bmN0aW9uLCBidXQgc2xvd2VyXG4gICB0aGFuIHRoZSBwcmV2aW91cyBjdXN0b20gaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHRoZSBuZXcgT0NhbWwgZnVuY3Rpb24gaXMgd2VsbFxuICAgYmVoYXZlZCwgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gZGl2ZXJnZSBmcm9tIHRoZSBkZWZhdWx0IE9DYW1sXG4gICBpbXBsZW1lbnRhdGlvbiBkb2VzLCB3aGljaCBpcyBhIGRlc2lyYWJsZSBwcm9wZXJ0eS4gKFRoZSBvbmx5IHdheSB0byBhdm9pZCB0aGVcbiAgIGRpdmVyZ2VuY2UgaXMgdG8gZXhwb3NlIHRoZSBtYWNybyByZWRlZmluZWQgaW4gaGFzaF9zdHVicy5jIGluIHRoZSBoYXNoLmggaGVhZGVyIG9mXG4gICB0aGUgT0NhbWwgY29tcGlsZXIuKSAqKVxubW9kdWxlIEhhc2ggPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgaGFzaCA6IHN0cmluZyAtPiBpbnQgPSBcIkJhc2VfaGFzaF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFtpbmNsdWRlIEhhc2hdIHRvIG1ha2UgdGhlIFtleHRlcm5hbF0gdmVyc2lvbiBvdmVycmlkZSB0aGUgW2hhc2hdIGZyb21cbiAgIFtIYXNoYWJsZS5NYWtlX2JpbmFibGVdLCBzbyB0aGF0IHdlIGdldCBhIGxpdHRsZSBiaXQgb2YgYSBzcGVlZHVwIGJ5IGV4cG9zaW5nIGl0IGFzXG4gICBleHRlcm5hbCBpbiB0aGUgbWxpLiAqKVxubGV0IF8gPSBoYXNoXG5cbmluY2x1ZGUgSGFzaFxuXG4oKiBmb3IgaW50ZXJhY3RpdmUgdG9wLWxldmVscyAtLSBtb2R1bGVzIGRlcml2aW5nIGZyb20gU3RyaW5nIHNob3VsZCBoYXZlIFN0cmluZydzIHByZXR0eVxuICAgcHJpbnRlci4gKilcbmxldCBwcCBwcGYgc3RyaW5nID0gU3RkbGliLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCBvZl9saXN0ID0gb2ZfY2hhcl9saXN0XG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkuZ2V0IGEpXG5cbmxldCB0b19zZXF1ZW5jZSB0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBwb3MgLT5cbiAgICBpZiBwb3MgPj0gbGVuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgcG9zOyBzdGF0ZSA9IHBvcyArIDEgfSlcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBzID0gb2ZfbGlzdCAoU2VxdWVuY2UudG9fbGlzdCBzKVxubGV0IGFwcGVuZCA9ICggXiApXG5cbmxldCBwYWRfcmlnaHQgPyhjaGFyID0gJyAnKSBzIH5sZW4gPVxuICBsZXQgc3JjX2xlbiA9IGxlbmd0aCBzIGluXG4gIGlmIHNyY19sZW4gPj0gbGVuXG4gIHRoZW4gc1xuICBlbHNlIChcbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+ZHN0OnJlcyB+c3JjX3BvczowIH5kc3RfcG9zOjAgfmxlbjpzcmNfbGVuO1xuICAgIEJ5dGVzLmZpbGwgfnBvczpzcmNfbGVuIH5sZW46KGxlbiAtIHNyY19sZW4pIHJlcyBjaGFyO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzKVxuOztcblxubGV0IHBhZF9sZWZ0ID8oY2hhciA9ICcgJykgcyB+bGVuID1cbiAgbGV0IHNyY19sZW4gPSBsZW5ndGggcyBpblxuICBpZiBzcmNfbGVuID49IGxlblxuICB0aGVuIHNcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfmRzdDpyZXMgfnNyY19wb3M6MCB+ZHN0X3BvczoobGVuIC0gc3JjX2xlbikgfmxlbjpzcmNfbGVuO1xuICAgIEJ5dGVzLmZpbGwgfnBvczowIH5sZW46KGxlbiAtIHNyY19sZW4pIHJlcyBjaGFyO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzKVxuOztcblxuKCogQ2FsbGVkIHVwb24gZmlyc3QgZGlmZmVyZW5jZSBnZW5lcmF0ZWQgYnkgZmlsdGVyaW5nLiBBbGxvY2F0ZXMgW2J1ZmZlcl9sZW5dIGJ5dGVzXG4gICBmb3IgbmV3IHJlc3VsdCwgYW5kIGNvcGllcyBbcHJlZml4X2xlbl0gdW5jaGFuZ2VkIGNoYXJhY3RlcnMgZnJvbSBbc3JjXS5cbiAgIEFsd2F5cyByZXR1cm5zIGEgbG9jYWwgYnVmZmVyLiAqKVxubGV0IGxvY2FsX2NvcHlfcHJlZml4IHNyYyB+cHJlZml4X2xlbiB+YnVmZmVyX2xlbiA9XG4gIGxldCBkc3QgPSBCeXRlcy5jcmVhdGVfbG9jYWwgYnVmZmVyX2xlbiBpblxuICBCeXRlcy5QcmltaXRpdmVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5kc3QgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46cHJlZml4X2xlbjtcbiAgZHN0XG47O1xuXG4oKiBDb3BpZXMgYSBwZXJoYXBzLWxvY2FsIGJ1ZmZlciBpbnRvIGEgZGVmaW5pdGVseS1nbG9iYWwgc3RyaW5nLiAqKVxubGV0IGxvY2FsX2NvcHlfdG9fc3RyaW5nIGJ1ZiB+cG9zID1cbiAgbGV0IHN0ciA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6YnVmIGluXG4gIHVuc2FmZV9zdWIgc3RyIH5wb3M6MCB+bGVuOnBvcyBbQG5vbnRhaWxdXG47O1xuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIHN0cnVjdFxuICAgICgqIGZpbHRlcl9tYXAgaGVscGVycyAqKVxuXG4gICAgKCogRmlsdGVycyBmcm9tIHN0cmluZyBbc3JjXSBpbnRvIGFuIGFsbG9jYXRlZCBidWZmZXIgW2RzdF07XG4gICAgICAgY29waWVzIHRoZSBhbGxvY2F0ZWQgYnVmZmVyIHRvIGEgaGVhcC1hbGxvY2F0ZWQgcmVzdWx0IHN0cmluZy5cblxuICAgICAgIFByZS1jb25kaXRpb25zOlxuICAgICAgIFtzcmNfbGVuID0gbGVuZ3RoIHNyY11cbiAgICAgICBbc3JjICE9IGRzdF1cbiAgICAgICBbMCA8PSBzcmNfcG9zIDwgc3JjX2xlbl1cbiAgICAgICBbMCA8PSBkc3RfcG9zIDwgbGVuZ3RoIGRzdF1cbiAgICAqKVxuICAgIGxldCBmaWx0ZXJfbWFwaV9pbnRvIHNyYyBkc3QgfmYgfnNyY19wb3MgfmRzdF9wb3MgfnNyY19sZW4gPVxuICAgICAgbGV0IGRzdF9wb3MgPSByZWYgZHN0X3BvcyBpblxuICAgICAgZm9yIHNyY19wb3MgPSBzcmNfcG9zIHRvIHNyY19sZW4gLSAxIGRvXG4gICAgICAgIG1hdGNoIGYgc3JjX3BvcyAodW5zYWZlX2dldCBzcmMgc3JjX3Bvcykgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IGRzdCAhZHN0X3BvcyBjO1xuICAgICAgICAgIGluY3IgZHN0X3Bvc1xuICAgICAgZG9uZTtcbiAgICAgIGxvY2FsX2NvcHlfdG9fc3RyaW5nIGRzdCB+cG9zOiFkc3RfcG9zXG4gICAgOztcblxuICAgICgqIEZpbHRlcnMgW3RdLiBJZiB0aGUgcmVzdWx0IHR1cm5zIG91dCB0byBiZSBpZGVudGljYWwgdG8gdGhlIGlucHV0LCByZXR1cm5zIFt0XVxuICAgICAgIGRpcmVjdGx5IHdpdGhvdXQgbmVlZGluZyB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBhbmQgdHJhdmVyc2UgdGhlIHN0cmluZyB0d2ljZS5cblxuICAgICAgIFByZS1jb25kaXRpb246IFtsZW4gPT0gbGVuZ3RoIHRdXG4gICAgICAgUHJlLWNvbmRpdGlvbjogWzAgPD0gcG9zIDw9IGxlbl0gKilcbiAgICBsZXQgcmVjIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiB0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCB0IHBvcyBpblxuICAgICAgICBsZXQgbmV4dCA9IEludC5zdWNjIHBvcyBpblxuICAgICAgICBtYXRjaCBmIHBvcyBjMSB3aXRoXG4gICAgICAgIHwgU29tZSBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgICAoKiBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBjb250aW51ZSAqKVxuICAgICAgICAgIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvczpuZXh0IH5sZW5cbiAgICAgICAgfCBvcHRpb24gLT5cbiAgICAgICAgICAoKiBJZiBhIGNoYXJhY3RlciBoYXMgYmVlbiBjaGFuZ2VkIG9yIGRyb3BwZWQsIGJlZ2luIGFuIG91dHB1dCBidWZmZXIgdXAgdG9cbiAgICAgICAgICAgICBbcG9zXSwgYW5kIHdyaXRlIHRoZSBuZXcgY2hhcmFjdGVyIGludG8gaXQuICopXG4gICAgICAgICAgbGV0IGNvcHkgPSBsb2NhbF9jb3B5X3ByZWZpeCB0IH5wcmVmaXhfbGVuOnBvcyB+YnVmZmVyX2xlbjpsZW4gaW5cbiAgICAgICAgICBsZXQgZHN0X3BvcyA9XG4gICAgICAgICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHBvc1xuICAgICAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBjb3B5IHBvcyBjO1xuICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBmaWx0ZXJfbWFwaV9pbnRvIHQgY29weSB+ZiB+c3JjX3BvczpuZXh0IH5kc3RfcG9zIH5zcmNfbGVuOmxlbiBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGZpbHRlcl9tYXAgZnVuY3Rpb25zICopXG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPSBmaWx0ZXJfbWFwaV9tYXliZV9pZCB0IH5mIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSBbQG5vbnRhaWxdXG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICAoKiBwYXJ0aXRpb24gaGVscGVycyAqKVxuXG4gICAgbGV0IHBhcnRpdGlvbl9tYXBfaW50byBzcmMgfmZzdHMgfnNuZHMgfmYgfmxlbiB+c3JjX3BvcyB+ZnN0X3BvcyB+c25kX3BvcyA9XG4gICAgICBsZXQgZnN0X3BvcyA9IHJlZiBmc3RfcG9zIGluXG4gICAgICBsZXQgc25kX3BvcyA9IHJlZiBzbmRfcG9zIGluXG4gICAgICBmb3Igc3JjX3BvcyA9IHNyY19wb3MgdG8gbGVuIC0gMSBkb1xuICAgICAgICBtYXRjaCAoZiAodW5zYWZlX2dldCBzcmMgc3JjX3BvcykgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBmc3RzICFmc3RfcG9zIGM7XG4gICAgICAgICAgaW5jciBmc3RfcG9zXG4gICAgICAgIHwgU2Vjb25kIGMgLT5cbiAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHNuZHMgIXNuZF9wb3MgYztcbiAgICAgICAgICBpbmNyIHNuZF9wb3NcbiAgICAgIGRvbmU7XG4gICAgICBsb2NhbF9jb3B5X3RvX3N0cmluZyBmc3RzIH5wb3M6IWZzdF9wb3MsIGxvY2FsX2NvcHlfdG9fc3RyaW5nIHNuZHMgfnBvczohc25kX3Bvc1xuICAgIDs7XG5cbiAgICBsZXQgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlIHNyYyB+ZiB+bGVuIH5wb3M6c3JjX3BvcyB+ZnN0X3BvcyB+c25kX3BvcyBlaXRoZXIgPVxuICAgICAgbGV0IGZzdHMgPSBsb2NhbF9jb3B5X3ByZWZpeCBzcmMgfnByZWZpeF9sZW46ZnN0X3BvcyB+YnVmZmVyX2xlbjpsZW4gaW5cbiAgICAgIGxldCBzbmRzID0gbG9jYWxfY29weV9wcmVmaXggc3JjIH5wcmVmaXhfbGVuOnNuZF9wb3MgfmJ1ZmZlcl9sZW46bGVuIGluXG4gICAgICBsZXQgZnN0X3Bvcywgc25kX3BvcyA9XG4gICAgICAgIG1hdGNoIChlaXRoZXIgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBmc3RzIGZzdF9wb3MgYztcbiAgICAgICAgICBmc3RfcG9zICsgMSwgc25kX3Bvc1xuICAgICAgICB8IFNlY29uZCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzbmRzIHNuZF9wb3MgYztcbiAgICAgICAgICBmc3RfcG9zLCBzbmRfcG9zICsgMVxuICAgICAgaW5cbiAgICAgIHBhcnRpdGlvbl9tYXBfaW50b1xuICAgICAgICBzcmNcbiAgICAgICAgfmZzdHNcbiAgICAgICAgfnNuZHNcbiAgICAgICAgfmZcbiAgICAgICAgfmxlblxuICAgICAgICB+c3JjX3Bvczooc3JjX3BvcyArIDEpXG4gICAgICAgIH5mc3RfcG9zXG4gICAgICAgIH5zbmRfcG9zIFtAbm9udGFpbF1cbiAgICA7O1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb25fbWFwX2ZpcnN0X21heWJlX2lkIHNyYyB+ZiB+cG9zIH5sZW4gPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIHNyYywgXCJcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjMSA9IHVuc2FmZV9nZXQgc3JjIHBvcyBpblxuICAgICAgICBtYXRjaCAoZiBjMSA6IChfLCBfKSBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfZmlyc3RfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoocG9zICsgMSlcbiAgICAgICAgfCBlaXRoZXIgLT5cbiAgICAgICAgICBwYXJ0aXRpb25fbWFwX2RpZmZlcmVuY2VcbiAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfmZcbiAgICAgICAgICAgIH5sZW5cbiAgICAgICAgICAgIH5wb3NcbiAgICAgICAgICAgIH5mc3RfcG9zOnBvc1xuICAgICAgICAgICAgfnNuZF9wb3M6MFxuICAgICAgICAgICAgZWl0aGVyIFtAbm9udGFpbF0pXG4gICAgOztcblxuICAgIGxldCByZWMgcGFydGl0aW9uX21hcF9zZWNvbmRfbWF5YmVfaWQgc3JjIH5mIH5wb3MgfmxlbiA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gXCJcIiwgc3JjXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCBzcmMgcG9zIGluXG4gICAgICAgIG1hdGNoIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgU2Vjb25kIGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpXG4gICAgICAgIHwgZWl0aGVyIC0+XG4gICAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+bGVuXG4gICAgICAgICAgICB+cG9zXG4gICAgICAgICAgICB+ZnN0X3BvczowXG4gICAgICAgICAgICB+c25kX3Bvczpwb3NcbiAgICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIHBhcnRpdGlvbiBmdW5jdGlvbnMgKilcblxuICBsZXQgcGFydGl0aW9uX21hcCBzcmMgfmYgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggc3JjIGluXG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIiwgXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCBzcmMgMCBpblxuICAgICAgbWF0Y2ggKGYgYzEgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgIHwgRmlyc3QgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+IHBhcnRpdGlvbl9tYXBfZmlyc3RfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoxXG4gICAgICB8IFNlY29uZCBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgcGFydGl0aW9uX21hcF9zZWNvbmRfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoxXG4gICAgICB8IGVpdGhlciAtPlxuICAgICAgICBwYXJ0aXRpb25fbWFwX2RpZmZlcmVuY2VcbiAgICAgICAgICBzcmNcbiAgICAgICAgICB+ZlxuICAgICAgICAgIH5sZW5cbiAgICAgICAgICB+cG9zOjBcbiAgICAgICAgICB+ZnN0X3BvczowXG4gICAgICAgICAgfnNuZF9wb3M6MFxuICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgcGFydGl0aW9uX21hcCB0IH5mOihmdW4gYyAtPiBpZiBmIGMgdGhlbiBGaXJzdCBjIGVsc2UgU2Vjb25kIGMpIFtAbm9udGFpbF1cbiAgOztcbmVuZFxuXG5sZXQgZWRpdF9kaXN0YW5jZSBzMSBzMiA9XG4gICgqIFdlIG1haW50YWluIGEgdGFibGUgb2YgZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIGFsbCBpbmRpY2VzIG9mIHRoZSBzaG9ydGVyIHN0cmluZywgYW5kXG4gICAgIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cyBpbmRpY2VzIG9mIHRoZSBsb25nZXIgc3RyaW5nLiAqKVxuICBsZXQgczEsIHMyID0gaWYgU3RyaW5nLmxlbmd0aCBzMSA8PSBTdHJpbmcubGVuZ3RoIHMyIHRoZW4gczEsIHMyIGVsc2UgczIsIHMxIGluXG4gIGxldCB0YWJsZSA9IEFycmF5LmNyZWF0ZV9sb2NhbCB+bGVuOigyICogKDEgKyBTdHJpbmcubGVuZ3RoIHMxKSkgMCBpblxuICBsZXQgYXQgaSBqID0gKGkgKiAyKSArIChqIG1vZCAyKSBpblxuICBmb3IgaSA9IDEgdG8gU3RyaW5nLmxlbmd0aCBzMSBkb1xuICAgICgqIEluc2VydCBbaV0gY2hhcmFjdGVycyB3aGVuIFtqPTBdLiAqKVxuICAgIHRhYmxlLihhdCBpIDApIDwtIGlcbiAgZG9uZTtcbiAgZm9yIGogPSAxIHRvIFN0cmluZy5sZW5ndGggczIgZG9cbiAgICAoKiBJbnNlcnQgW2pdIGNoYXJhY3RlcnMgd2hlbiBbaT0wXS4gKilcbiAgICB0YWJsZS4oYXQgMCBqKSA8LSBqO1xuICAgIGZvciBpID0gMSB0byBTdHJpbmcubGVuZ3RoIHMxIGRvXG4gICAgICBpZiBDaGFyLmVxdWFsIHMxLltpIC0gMV0gczIuW2ogLSAxXVxuICAgICAgdGhlblxuICAgICAgICAoKiBOb3RoaW5nIHRvIGVkaXQgZm9yIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcbiAgICAgICAgdGFibGUuKGF0IGkgaikgPC0gdGFibGUuKGF0IChpIC0gMSkgKGogLSAxKSlcbiAgICAgIGVsc2UgKFxuICAgICAgICAoKiBFZGl0IHRoZSBjdXJyZW50IGNoYXJhY3RlciBieSBzdWJzdGl0dXRpb24sIGFkZGl0aW9uLCBvciBkZWxldGlvbi4gKilcbiAgICAgICAgbGV0IHN1YiA9IHRhYmxlLihhdCAoaSAtIDEpIChqIC0gMSkpIGluXG4gICAgICAgIGxldCBhZGQgPSB0YWJsZS4oYXQgKGkgLSAxKSBqKSBpblxuICAgICAgICBsZXQgZGVsID0gdGFibGUuKGF0IGkgKGogLSAxKSkgaW5cbiAgICAgICAgdGFibGUuKGF0IGkgaikgPC0gMSArIG1pbiBzdWIgKG1pbiBhZGQgZGVsKSlcbiAgICBkb25lXG4gIGRvbmU7XG4gICgqIFJldHVybiB0aGUgZmluYWwgcmVzdWx0LiAqKVxuICB0YWJsZS4oYXQgKFN0cmluZy5sZW5ndGggczEpIChTdHJpbmcubGVuZ3RoIHMyKSlcbjs7XG5cbm1vZHVsZSBFc2NhcGluZyA9IHN0cnVjdFxuICAoKiBJZiB0aGlzIGlzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0byB1cGRhdGUgW2VzY2FwZV0sIHdoaWNoIGF0dGVtcHRzIHRvIGVuc3VyZSBhbGwgdGhlXG4gICAgIGludmFyaWFudHMgY2hlY2tlZCBoZXJlLiAgKilcbiAgbGV0IGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgZnVuYyA9XG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgaWYgTGlzdC5Bc3NvYy5tZW0gZXNjYXBld29ydGh5X21hcCB+ZXF1YWw6Q2hhci5lcXVhbCBlc2NhcGVfY2hhclxuICAgICAgdGhlbiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICBlbHNlIChlc2NhcGVfY2hhciwgZXNjYXBlX2NoYXIpIDo6IGVzY2FwZXdvcnRoeV9tYXBcbiAgICBpblxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgKC0xKSBpblxuICAgIGxldCB2YWxzID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2IGZhbHNlIGluXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gT2sgYXJyXG4gICAgICB8IChjX2Zyb20sIGNfdG8pIDo6IGwgLT5cbiAgICAgICAgbGV0IGssIHYgPVxuICAgICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICAgIHwgYEVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX2Zyb20sIGNfdG9cbiAgICAgICAgICB8IGBVbmVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX3RvLCBjX2Zyb21cbiAgICAgICAgaW5cbiAgICAgICAgaWYgYXJyLihrKSA8PiAtMSB8fCB2YWxzLihDaGFyLnRvX2ludCB2KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgICAgXCJlc2NhcGV3b3J0aHlfbWFwIG5vdCBvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgIFsgXCJjX2Zyb21cIiwgc2V4cF9vZl9jaGFyIGNfZnJvbVxuICAgICAgICAgICAgICAgOyBcImNfdG9cIiwgc2V4cF9vZl9jaGFyIGNfdG9cbiAgICAgICAgICAgICAgIDsgKCBcImVzY2FwZXdvcnRoeV9tYXBcIlxuICAgICAgICAgICAgICAgICAsIHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2ZfY2hhciBzZXhwX29mX2NoYXIpIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgXSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYXJyLihrKSA8LSBDaGFyLnRvX2ludCB2O1xuICAgICAgICAgIHZhbHMuKENoYXIudG9faW50IHYpIDwtIHRydWU7XG4gICAgICAgICAgbG9vcCBsKVxuICAgIGluXG4gICAgbG9vcCBlc2NhcGV3b3J0aHlfbWFwXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBFc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAoKiBjYWxjdWxhdGUgYSBsaXN0IG9mIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgZmlyc3QsIHRoZSBvcmRlclxuICAgICAgICAgICAgICBpcyBmcm9tIHRhaWwgdG8gaGVhZCAqKVxuICAgICAgICAgIGxldCB0b19lc2NhcGVfbGVuID0gcmVmIDAgaW5cbiAgICAgICAgICBsZXQgdG9fZXNjYXBlID1cbiAgICAgICAgICAgIGZvbGRpIHNyYyB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGMgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBjKSB3aXRoXG4gICAgICAgICAgICAgIHwgLTEgLT4gYWNjXG4gICAgICAgICAgICAgIHwgbiAtPlxuICAgICAgICAgICAgICAgICgqIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgKilcbiAgICAgICAgICAgICAgICBpbmNyIHRvX2VzY2FwZV9sZW47XG4gICAgICAgICAgICAgICAgKGksIENoYXIudW5zYWZlX29mX2ludCBuKSA6OiBhY2MpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCB0b19lc2NhcGUgd2l0aFxuICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAoKiBbdG9fZXNjYXBlXSBkaXZpZGUgW3NyY10gdG8gW0xpc3QubGVuZ3RoIHRvX2VzY2FwZSArIDFdIHBpZWNlcyBzZXBhcmF0ZWQgYnlcbiAgICAgICAgICAgICAgICB0aGUgY2hhcnMgdG8gZXNjYXBlLlxuXG4gICAgICAgICAgICAgICAgTGV0cyB0YWtlXG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIGVzY2FwZV9nZW5fZXhuXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGV3b3J0aHlfbWFwOlsoJ2EnLCAnQScpOyAoJ2InLCAnQicpOyAoJ2MnLCAnQycpXVxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBlX2NoYXI6J18nXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgYW5kIGFzc3VtZSB0aGUgc3RyaW5nIHRvIGVzY2FwZSBpc1xuXG4gICAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgICAgdGhlbiBbdG9fZXNjYXBlXSBpcyBbKDExLCAnQycpOyAoNywgJ0InKTsgKDMsICdBJyldLlxuXG4gICAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBbZHN0XSBvZiBsZW5ndGggW2xlbmd0aCBzcmMgKyAzXSB0byBzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICByZXN1bHQsIGNvcHkgcGllY2UgXCIzMzNcIiB0byBbZHN0XSBkaXJlY3RseSwgdGhlbiBjb3B5ICdfJyBhbmQgJ0MnIHRvIFtkc3RdO1xuICAgICAgICAgICAgICAgIHRoZW4gbW92ZSBvbiB0byBuZXh0OyBhZnRlciAzIGl0ZXJhdGlvbnMsIGNvcHkgcGllY2UgXCIwMDBcIiBhbmQgd2UgYXJlIGRvbmUuXG5cbiAgICAgICAgICAgICAgICBGaW5hbGx5IHRoZSByZXN1bHQgd2lsbCBiZVxuXG4gICAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIiAqKVxuICAgICAgICAgICAgbGV0IHNyY19sZW4gPSBsZW5ndGggc3JjIGluXG4gICAgICAgICAgICBsZXQgZHN0X2xlbiA9IHNyY19sZW4gKyAhdG9fZXNjYXBlX2xlbiBpblxuICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBkc3RfbGVuIGluXG4gICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgIHwgKGlkeCwgZXNjYXBlZF9jaGFyKSA6OiB0b19lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAoKltpZHhdID0gdGhlIGNoYXIgdG8gZXNjYXBlKilcbiAgICAgICAgICAgICAgICAoKiB0YWtlIGZpcnN0IGl0ZXJhdGlvbiBmb3IgZXhhbXBsZSAqKVxuICAgICAgICAgICAgICAgICgqIGNhbGN1bGF0ZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMSBiZWNhdXNlIHdlIGRvbid0IGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMSBpblxuICAgICAgICAgICAgICAgICgqIHNldCB0aGUgZHN0X3BvcyB0byBjb3B5IHRvICopXG4gICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIsIHNldCBbc3JjX3Bvc10gdG8gW2lkeCArIDFdIHRvIHNraXAgJ2MnICopXG4gICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMSkgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDIgdG8gY29weSAnXycgYW5kICdDJyAqKVxuICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDIgaW5cbiAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IGRzdF9wb3MgZXNjYXBlX2NoYXI7XG4gICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCAoZHN0X3BvcyArIDEpIGVzY2FwZWRfY2hhcjtcbiAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX2VzY2FwZVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdIGZpcnN0ICopXG4gICAgICAgICAgICBsb29wIHNyY19sZW4gZHN0X2xlbiB0b19lc2NhcGU7XG4gICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCBlc2NhcGUgfmVzY2FwZXdvcnRoeSB+ZXNjYXBlX2NoYXIgPVxuICAgICgqIEZvciBbZXNjYXBlX2dlbl9leG5dLCB3ZSBkb24ndCBrbm93IGhvdyB0byBmaXggaW52YWxpZCBlc2NhcGV3b3J0aHlfbWFwIHNvIHdlIGhhdmVcbiAgICAgICB0byByYWlzZSBleGNlcHRpb247IGJ1dCBpbiB0aGlzIGNhc2UsIHdlIGtub3cgaG93IHRvIGZpeCBkdXBsaWNhdGVkIGVsZW1lbnRzIGluXG4gICAgICAgZXNjYXBld29ydGh5IGxpc3QsIHNvIHdlIGp1c3QgZml4IGl0IGluc3RlYWQgb2YgcmFpc2luZyBleGNlcHRpb24gdG8gbWFrZSB0aGlzXG4gICAgICAgZnVuY3Rpb24gZWFzaWVyIHRvIHVzZS4gICopXG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgZXNjYXBld29ydGh5XG4gICAgICB8PiBMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOkNoYXIuY29tcGFyZVxuICAgICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBjIC0+IGMsIGMpXG4gICAgaW5cbiAgICBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXJcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYFVuZXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgKCogQ29udGludWUgdGhlIGV4YW1wbGUgaW4gW2VzY2FwZV9nZW5fZXhuXSwgbm93IHdlIHVuZXNjYXBlXG5cbiAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIlxuXG4gICAgICAgICAgICAgIGJhY2sgdG9cblxuICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgVGhlbiBbdG9fdW5lc2NhcGVdIGlzIFsxNDsgOTsgNF0sIHdoaWNoIGlzIGluZGV4ZXMgb2YgJ18ncy5cblxuICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIHN0cmluZyBbZHN0XSB0byBzdG9yZSB0aGUgcmVzdWx0LCBjb3B5IFwiMzMzXCIgdG8gaXQsIHRoZW4gY29weVxuICAgICAgICAgICAgICAnYycsIHRoZW4gbW92ZSBvbiB0byBuZXh0IGl0ZXJhdGlvbi4gQWZ0ZXIgMyBpdGVyYXRpb25zIGNvcHkgXCIwMDBcIiBhbmQgd2UgYXJlXG4gICAgICAgICAgICAgIGRvbmUuICAqKVxuICAgICAgICAgICgqIGluZGV4ZXMgb2YgZXNjYXBlIGNoYXJzICopXG4gICAgICAgICAgbGV0IHRvX3VuZXNjYXBlID1cbiAgICAgICAgICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyBhY2MgPVxuICAgICAgICAgICAgICBpZiBpID49IGxlbmd0aCBzcmNcbiAgICAgICAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHNyYyB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMgaW5cbiAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICAoaSArIDEpXG4gICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwaW5nIC0+IGkgOjogYWNjXG4gICAgICAgICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGFjYykpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbG9vcCAwIGBMaXRlcmFsIFtdXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCB0b191bmVzY2FwZSB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZScgLT5cbiAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbmd0aCBzcmMgLSBMaXN0Lmxlbmd0aCB0b191bmVzY2FwZSkgaW5cbiAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAoKiBbaWR4XSA9IGluZGV4IG9mIGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgICAoKiB0YWtlIDFzdCBpdGVyYXRpb24gYXMgZXhhbXBsZSwgY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMiB0b1xuICAgICAgICAgICAgICAgICAgICBza2lwICdfQycgKilcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAyIGluXG4gICAgICAgICAgICAgICAgKCogcG9pbnQgW2RzdF9wb3NdIHRvIHRoZSBwb3NpdGlvbiB0byBjb3B5IFwiMzMzXCIgdG8gKilcbiAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiAqKVxuICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDIpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAxIHRvIGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMSBpblxuICAgICAgICAgICAgICAgIEJ5dGVzLnNldFxuICAgICAgICAgICAgICAgICAgZHN0XG4gICAgICAgICAgICAgICAgICBkc3RfcG9zXG4gICAgICAgICAgICAgICAgICAobWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBzcmMuW2lkeCArIDFdKSB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCAtMSAtPiBzcmMuW2lkeCArIDFdXG4gICAgICAgICAgICAgICAgICAgfCBuIC0+IENoYXIudW5zYWZlX29mX2ludCBuKTtcbiAgICAgICAgICAgICAgICAoKiB1cGRhdGUgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gKilcbiAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgaWR4IDwgbGVuZ3RoIHNyYyAtIDFcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gKilcbiAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYykgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIGZvciBlc2NhcGVkIHN0cmluZyBlbmRpbmcgd2l0aCBhbiBlc2NhcGluZyBjaGFyIGxpa2UgXCIwMDBfXCIsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICB0aGUgbGFzdCBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMgLSAxKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGUnO1xuICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlIH5lc2NhcGVfY2hhciA9IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXA6W10gfmVzY2FwZV9jaGFyXG5cbiAgbGV0IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCByZWMgbG9vcCBwIGNudCA9XG4gICAgICBpZiBwIDwgMCB8fCBDaGFyLiggPD4gKSBzdHIuW3BdIGVzY2FwZV9jaGFyIHRoZW4gY250IGVsc2UgbG9vcCAocCAtIDEpIChjbnQgKyAxKVxuICAgIGluXG4gICAgbG9vcCAocG9zIC0gMSkgMFxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IG9kZCA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgbW9kIDIgPSAxIGluXG4gICAgbWF0Y2ggb2RkLCBDaGFyLmVxdWFsIHN0ci5bcG9zXSBlc2NhcGVfY2hhciB3aXRoXG4gICAgfCB0cnVlLCAodHJ1ZSB8IGZhbHNlKSAtPiBgRXNjYXBlZFxuICAgIHwgZmFsc2UsIHRydWUgLT4gYEVzY2FwaW5nXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gYExpdGVyYWxcbiAgOztcblxuICBsZXQgY2hlY2tfYm91bmQgc3RyIHBvcyBmdW5jdGlvbl9uYW1lID1cbiAgICBpZiBwb3MgPj0gbGVuZ3RoIHN0ciB8fCBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiJXM6IG91dCBvZiBib3VuZHNcIiBmdW5jdGlvbl9uYW1lICgpXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBpbmcgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwaW5nXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBpbmcgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwZWQgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwZWRcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGVkIC0+IHRydWVcbiAgICB8IGBFc2NhcGluZyB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfbGl0ZXJhbCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfbGl0ZXJhbFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaW5kZXhfZnJvbVwiO1xuICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyA9XG4gICAgICBpZiBpID49IHBvc1xuICAgICAgICAgJiYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICAgICYmIENoYXIuZXF1YWwgc3RyLltpXSBjaGFyXG4gICAgICB0aGVuIFNvbWUgaVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpID0gaSArIDEgaW5cbiAgICAgICAgaWYgaSA+PSBsZW5ndGggc3RyXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIGxvb3AgaSAodXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHN0YXR1cykpXG4gICAgaW5cbiAgICBsb29wIHBvcyAoZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcylcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcbiAgbGV0IGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuXG4gIGxldCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwicmluZGV4X2Zyb21cIjtcbiAgICAoKiBpZiB0aGUgdGFyZ2V0IGNoYXIgaXMgdGhlIHNhbWUgYXMgW2VzY2FwZV9jaGFyXSwgd2UgaGF2ZSBubyB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgZXNjYXBlX2NoYXIgaXMgbGl0ZXJhbCwgc28ganVzdCByZXR1cm4gTm9uZSAqKVxuICAgIGlmIENoYXIuZXF1YWwgY2hhciBlc2NhcGVfY2hhclxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIHBvcyA9XG4gICAgICAgIGlmIHBvcyA8IDBcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBlc2NhcGVfY2hhcnMgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGluXG4gICAgICAgICAgaWYgZXNjYXBlX2NoYXJzIG1vZCAyID0gMCAmJiBDaGFyLmVxdWFsIHN0ci5bcG9zXSBjaGFyXG4gICAgICAgICAgdGhlbiBTb21lIHBvc1xuICAgICAgICAgIGVsc2UgbG9vcCAocG9zIC0gZXNjYXBlX2NoYXJzIC0gMSkpXG4gICAgICBpblxuICAgICAgbG9vcCBwb3MpXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcInJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCByaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICBpZiBpc19lbXB0eSBzdHIgdGhlbiBOb25lIGVsc2UgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICBsZXQgcmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gICgqIFtzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b25dIHdvcmtzIHNpbWlsYXJseSB0byBbU3RyaW5nLnNwbGl0X2dlbl0sIHdpdGggYW5cbiAgICAgYWRkaXRpb25hbCByZXF1aXJlbWVudDogb25seSBzcGxpdCBvbiBsaXRlcmFsIGNoYXJzLCBub3QgZXNjYXBpbmcgb3IgZXNjYXBlZCAqKVxuICBsZXQgc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uID1cbiAgICBsZXQgaXNfZGVsaW0gPVxuICAgICAgbWF0Y2ggb24gd2l0aFxuICAgICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gICAgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIHBvcyA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gTGlzdC5yZXYgKHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihsZW4gLSBsYXN0X3BvcykgOjogYWNjKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBzdGF0dXMgaW5cbiAgICAgICAgaWYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAgICAgICYmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihwb3MgLSBsYXN0X3BvcykgaW5cbiAgICAgICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgc3RhdHVzIChwb3MgKyAxKSAocG9zICsgMSkpXG4gICAgICAgIGVsc2UgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIChwb3MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgW10gYExpdGVyYWwgMCAwXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG4gIGxldCBzcGxpdF9vbl9jaGFycyBzdHIgfm9uOmNoYXJzID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyX2xpc3QgY2hhcnMpXG5cbiAgbGV0IHNwbGl0X2F0IHN0ciBwb3MgPVxuICAgIHN1YiBzdHIgfnBvczowIH5sZW46cG9zLCBzdWIgc3RyIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBzdHIgLSBwb3MgLSAxKVxuICA7O1xuXG4gIGxldCBsc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IHJzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcbiAgbGV0IHJzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChyaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG5cbiAgKCogW2xhc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYW5kIFtmaXJzdF9ub25fZHJvcF9saXRlcmFsXSBhcmUgZWl0aGVyIGJvdGggW05vbmVdIG9yIGJvdGhcbiAgICAgW1NvbWVdLiBJZiBbU29tZV0sIHRoZW4gdGhlIGZvcm1lciBpcyA+PSB0aGUgbGF0dGVyLiAqKVxuICBsZXQgbGFzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICByZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgbGZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG5tb2R1bGUgTWFrZV91dGYgKEZvcm1hdCA6IHNpZ1xuICB2YWwgY29kZWNfbmFtZSA6IHN0cmluZ1xuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIGlzX3ZhbGlkIDogdCAtPiBib29sXG4gIHZhbCBieXRlX2xlbmd0aCA6IFVjaGFyLnQgLT4gaW50XG4gIHZhbCBnZXRfZGVjb2RlX3Jlc3VsdCA6IHQgLT4gYnl0ZV9wb3M6aW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbiAgdmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBVY2hhci50IC0+IGludFxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBlbHQgPSBVY2hhci50XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBjb2RlY19uYW1lID0gRm9ybWF0LmNvZGVjX25hbWVcbiAgbGV0IGlzX3ZhbGlkID0gRm9ybWF0LmlzX3ZhbGlkXG5cbiAgbGV0IHJhaXNlX2dldF9tZXNzYWdlID1cbiAgICBsYXp5XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiJXMuZ2V0OiBpbnZhbGlkICVzIGVuY29kaW5nIGF0IGdpdmVuIHBvc2l0aW9uXCJcbiAgICAgICAgIEZvcm1hdC5tb2R1bGVfbmFtZVxuICAgICAgICAgRm9ybWF0LmNvZGVjX25hbWUpXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9nZXQgdCBwb3MgPVxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgKExhenkuZm9yY2UgcmFpc2VfZ2V0X21lc3NhZ2UpIFsgXCJcIiwgQXRvbSB0OyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3MgXSlcbiAgOztcblxuICBsZXQgZ2V0IHQgfmJ5dGVfcG9zID1cbiAgICAoKiBFdmVuIGlmIFt0XSBpcyB2YWxpZGF0ZWQsIHdlIG5lZWQgdG8gdmFsaWRhdGUgW3Bvc10sIHNvIHdlIGNoZWNrIHRoZSBkZWNvZGluZyAqKVxuICAgIGxldCBkZWNvZGUgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgdCB+Ynl0ZV9wb3MgaW5cbiAgICBpZiBVY2hhci51dGZfZGVjb2RlX2lzX3ZhbGlkIGRlY29kZVxuICAgIHRoZW4gVWNoYXIudXRmX2RlY29kZV91Y2hhciBkZWNvZGVcbiAgICBlbHNlIHJhaXNlX2dldCB0IGJ5dGVfcG9zXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IEZuLmlkXG4gIGxldCBvZl9zdHJpbmdfdW5jaGVja2VkID0gRm4uaWRcblxuICBsZXQgcmFpc2Vfb2Zfc3RyaW5nX21lc3NhZ2UgPVxuICAgIGNvbmNhdCBbIEZvcm1hdC5tb2R1bGVfbmFtZTsgXCIub2Zfc3RyaW5nOiBpbnZhbGlkIFwiOyBjb2RlY19uYW1lIF1cbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX29mX3N0cmluZyBzdHJpbmcgPVxuICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSByYWlzZV9vZl9zdHJpbmdfbWVzc2FnZSBbIFwiXCIsIEF0b20gc3RyaW5nIF0pXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzdHJpbmcgPVxuICAgIG1hdGNoIGlzX3ZhbGlkIHN0cmluZyB3aXRoXG4gICAgfCB0cnVlIC0+IHN0cmluZ1xuICAgIHwgZmFsc2UgLT4gcmFpc2Vfb2Zfc3RyaW5nIHN0cmluZ1xuICA7O1xuXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGVuZClcblxuICBpbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgbGV0IGhhc2ggPSBoYXNoXG4gICAgbGV0IGhhc2hfZm9sZF90ID0gaGFzaF9mb2xkX3RcbiAgICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICBsZXQgdF9vZl9zZXhwID0gdF9vZl9zZXhwXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gRm9ybWF0Lm1vZHVsZV9uYW1lXG4gIGVuZClcblxuICBsZXQgdG9fc2VxdWVuY2UgdCA9XG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDowIH5mOihmdW4gYnl0ZV9wb3MgLT5cbiAgICAgIGlmIGJ5dGVfcG9zID49IGxlblxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGRlY29kZSA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdCB0IH5ieXRlX3BvcyBpblxuICAgICAgICBTb21lIChVY2hhci51dGZfZGVjb2RlX3VjaGFyIGRlY29kZSwgYnl0ZV9wb3MgKyBVY2hhci51dGZfZGVjb2RlX2xlbmd0aCBkZWNvZGUpKSlcbiAgOztcblxuICBsZXQgZm9sZCB0IH5pbml0OmFjYyB+ZiA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0IHJlYyBsb29wIGJ5dGVfcG9zIGFjYyA9XG4gICAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIGJ5dGVfcG9zIGxlblxuICAgICAgdGhlbiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgZGVjb2RlID0gRm9ybWF0LmdldF9kZWNvZGVfcmVzdWx0IHQgfmJ5dGVfcG9zIGluXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAoYnl0ZV9wb3MgKyBVY2hhci51dGZfZGVjb2RlX2xlbmd0aCBkZWNvZGUpXG4gICAgICAgICAgKGYgYWNjIChVY2hhci51dGZfZGVjb2RlX3VjaGFyIGRlY29kZSkpKVxuICAgIGluXG4gICAgbG9vcCAwIGFjYyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHNhbml0aXplIHQgPVxuICAgIGxldCBsZW4gPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIHBvcyB1Y2hhciAtPiBwb3MgKyBGb3JtYXQuYnl0ZV9sZW5ndGggdWNoYXIpIGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIHBvcyB1Y2hhciAtPiBwb3MgKyBGb3JtYXQuc2V0IGJ5dGVzIHBvcyB1Y2hhcikgaW5cbiAgICBhc3NlcnQgKEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpieXRlc1xuICA7O1xuXG4gIGxldCBvZl9saXN0IHVjaGFycyA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZCB1Y2hhcnMgfmluaXQ6MCB+ZjooZnVuIG4gdSAtPiBuICsgRm9ybWF0LmJ5dGVfbGVuZ3RoIHUpIGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPVxuICAgICAgTGlzdC5mb2xkIHVjaGFycyB+aW5pdDowIH5mOihmdW4gcG9zIHVjaGFyIC0+IHBvcyArIEZvcm1hdC5zZXQgYnl0ZXMgcG9zIHVjaGFyKVxuICAgIGluXG4gICAgYXNzZXJ0IChJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW4pO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6Ynl0ZXNcbiAgOztcblxuICBsZXQgb2ZfYXJyYXkgdWNoYXJzID1cbiAgICBsZXQgbGVuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHVjaGFycyAtIDEgZG9cbiAgICAgIGxlbiA6PSAhbGVuICsgRm9ybWF0LmJ5dGVfbGVuZ3RoIHVjaGFycy4oaSlcbiAgICBkb25lO1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSAhbGVuIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB1Y2hhcnMgLSAxIGRvXG4gICAgICBwb3MgOj0gIXBvcyArIEZvcm1hdC5zZXQgYnl0ZXMgIXBvcyB1Y2hhcnMuKGkpXG4gICAgZG9uZTtcbiAgICBhc3NlcnQgKEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgIXBvcyAhbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ5dGVzXG4gIDs7XG5cbiAgbGV0IGNvbmNhdCBsaXN0ID0gY29uY2F0IH5zZXA6XCJcIiBsaXN0XG5cbiAgbGV0IHNwbGl0IHQgfm9uID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIH5zdGFydCB+dW50aWwgPVxuICAgICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCB1bnRpbCBsZW5cbiAgICAgIHRoZW4gWyBzdWIgdCB+cG9zOnN0YXJ0IH5sZW46KHVudGlsIC0gc3RhcnQpIF1cbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdWNoYXIgPSBnZXQgdCB+Ynl0ZV9wb3M6dW50aWwgaW5cbiAgICAgICAgbGV0IG5leHQgPSB1bnRpbCArIEZvcm1hdC5ieXRlX2xlbmd0aCB1Y2hhciBpblxuICAgICAgICBpZiBVY2hhci5lcXVhbCB1Y2hhciBvblxuICAgICAgICB0aGVuIHN1YiB0IH5wb3M6c3RhcnQgfmxlbjoodW50aWwgLSBzdGFydCkgOjogbG9vcCB+c3RhcnQ6bmV4dCB+dW50aWw6bmV4dFxuICAgICAgICBlbHNlIGxvb3AgfnN0YXJ0IH51bnRpbDpuZXh0KVxuICAgIGluXG4gICAgbG9vcCB+c3RhcnQ6MCB+dW50aWw6MCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlMF93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBtb2R1bGUgRWx0ID0gVWNoYXJcblxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgY29uY2F0ID0gY29uY2F0XG4gICAgbGV0IG9mX2xpc3QgPSBvZl9saXN0XG4gICAgbGV0IG9mX2FycmF5ID0gb2ZfYXJyYXlcbiAgICBsZXQgaW5pdCA9IGBEZWZpbmVfdXNpbmdfb2ZfYXJyYXlcbiAgICBsZXQgbGVuZ3RoID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXIgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgICBsZXQgaXRlcmkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgICBsZXQgY29uY2F0X21hcGkgPSBgRGVmaW5lX3VzaW5nX2NvbmNhdFxuICBlbmQpXG5cbiAgbGV0IGFwcGVuZCA9IEMuYXBwZW5kXG4gIGxldCBjb25jYXRfbWFwID0gQy5jb25jYXRfbWFwXG4gIGxldCBjb25jYXRfbWFwaSA9IEMuY29uY2F0X21hcGlcbiAgbGV0IGNvdW50ID0gQy5jb3VudFxuICBsZXQgY291bnRpID0gQy5jb3VudGlcbiAgbGV0IGV4aXN0cyA9IEMuZXhpc3RzXG4gIGxldCBleGlzdHNpID0gQy5leGlzdHNpXG4gIGxldCBmaWx0ZXIgPSBDLmZpbHRlclxuICBsZXQgZmlsdGVyX21hcCA9IEMuZmlsdGVyX21hcFxuICBsZXQgZmlsdGVyX21hcGkgPSBDLmZpbHRlcl9tYXBpXG4gIGxldCBmaWx0ZXJpID0gQy5maWx0ZXJpXG4gIGxldCBmaW5kID0gQy5maW5kXG4gIGxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbiAgbGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG4gIGxldCBmaW5kaSA9IEMuZmluZGlcbiAgbGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxuICBsZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuICBsZXQgZm9sZGkgPSBDLmZvbGRpXG4gIGxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG4gIGxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcbiAgbGV0IGluaXQgPSBDLmluaXRcbiAgbGV0IGlzX2VtcHR5ID0gQy5pc19lbXB0eVxuICBsZXQgaXRlciA9IEMuaXRlclxuICBsZXQgaXRlcmkgPSBDLml0ZXJpXG4gIGxldCBsZW5ndGggPSBDLmxlbmd0aFxuICBsZXQgbWFwID0gQy5tYXBcbiAgbGV0IG1hcGkgPSBDLm1hcGlcbiAgbGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbiAgbGV0IG1lbSA9IEMubWVtXG4gIGxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG4gIGxldCBwYXJ0aXRpb25fbWFwID0gQy5wYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBDLnBhcnRpdGlvbl90ZlxuICBsZXQgc3VtID0gQy5zdW1cbiAgbGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxuICBsZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxuICBsZXQgbGVuZ3RoX2luX3VjaGFycyA9IGxlbmd0aFxuZW5kXG5cbm1vZHVsZSBVdGY4ID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLThcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU3RyaW5nLlV0ZjhcIlxuICBsZXQgaXNfdmFsaWQgPSBpc192YWxpZF91dGZfOFxuICBsZXQgYnl0ZV9sZW5ndGggPSBVY2hhci51dGZfOF9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBnZXRfdXRmXzhfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfOFxuZW5kKVxuXG5tb2R1bGUgVXRmMTZsZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0xNkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYxNmxlXCJcbiAgbGV0IGlzX3ZhbGlkID0gaXNfdmFsaWRfdXRmXzE2bGVcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gVWNoYXIudXRmXzE2X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IGdldF91dGZfMTZsZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8xNmxlXG5lbmQpXG5cbm1vZHVsZSBVdGYxNmJlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTE2QkVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU3RyaW5nLlV0ZjE2YmVcIlxuICBsZXQgaXNfdmFsaWQgPSBpc192YWxpZF91dGZfMTZiZVxuICBsZXQgYnl0ZV9sZW5ndGggPSBVY2hhci51dGZfMTZfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8xNmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzE2YmVcbmVuZClcblxubW9kdWxlIE1ha2VfdXRmMzIgKEZvcm1hdCA6IHNpZ1xuICB2YWwgY29kZWNfbmFtZSA6IHN0cmluZ1xuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIGdldF9kZWNvZGVfcmVzdWx0IDogdCAtPiBieXRlX3BvczppbnQgLT4gVWNoYXIudXRmX2RlY29kZVxuICB2YWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IFVjaGFyLnQgLT4gaW50XG5lbmQpID1cbk1ha2VfdXRmIChzdHJ1Y3RcbiAgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGJ5dGVfbGVuZ3RoIF8gPSA0XG4gIGxldCBjb2RlY19uYW1lID0gRm9ybWF0LmNvZGVjX25hbWVcbiAgbGV0IG1vZHVsZV9uYW1lID0gRm9ybWF0Lm1vZHVsZV9uYW1lXG4gIGxldCBzZXQgPSBGb3JtYXQuc2V0XG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdFxuXG4gIGxldCBpc192YWxpZCB0ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gICAgbWF0Y2ggbGVuIG1vZCA0IHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGxldCByZWMgbG9vcCBieXRlX3BvcyA9XG4gICAgICAgIG1hdGNoIGJ5dGVfcG9zIDwgbGVuIHdpdGhcbiAgICAgICAgfCBmYWxzZSAtPiB0cnVlXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGxldCByZXN1bHQgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgdCB+Ynl0ZV9wb3MgaW5cbiAgICAgICAgICBVY2hhci51dGZfZGVjb2RlX2lzX3ZhbGlkIHJlc3VsdCAmJiBsb29wIChieXRlX3BvcyArIDQpXG4gICAgICBpblxuICAgICAgbG9vcCAwIFtAbm9udGFpbF1cbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcbmVuZClcblxubW9kdWxlIFV0ZjMybGUgPSBNYWtlX3V0ZjMyIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYzMmxlXCJcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8zMmxlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMybGVcbmVuZClcblxubW9kdWxlIFV0ZjMyYmUgPSBNYWtlX3V0ZjMyIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkJFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYzMmJlXCJcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8zMmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMyYmVcbmVuZClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2Nhc2Vfc2Vuc2l0aXZlIiwiY3N0X2NoYXIiLCJjc3RfZXNjYXBlX2NoYXIiLCJjc3RfcGF0dGVybiIsImNzdF9wb3MiLCJjc3Rfc3JjX3N0cmluZ19tbCIsImNzdF9zdHIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiY2FtbF9ieXRlc19zZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJjb2RlY19uYW1lIiwibW9kdWxlX25hbWUiLCJCYXNlX0NoYXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfVWNoYXIwIiwiQmFzZV9CeXRlczAiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfTGlzdCIsIkJhc2VfU2VxdWVuY2UiLCJCYXNlX1NleHAiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9QcmludGYiLCJCYXNlX1NleHBhYmxlIiwiQmFzZV9JZGVudGlmaWFibGUiLCJCYXNlX0luZGV4ZWRfY29udGFpbmVyIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfT3B0aW9uIiwiQmFzZV9BcnJheTAiLCJCYXNlX0ludDAiLCJTdGRsaWJfRm9ybWF0IiwiQmFzZV9CeXRlc190ciIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9IYXNoIiwiQmFzZV9PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uIiwiQmFzZV9TdHJpbmcwIiwiQmFzZV9FcnJvciIsIkJhc2VfU3RhZ2VkIiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9Db21wYXJhYmxlIiwibWF4X2xlbmd0aCIsInN5bWJvbF9jb25jYXQiLCJjYXBpdGFsaXplIiwiY29tcGFyZSIsImVzY2FwZWQiLCJsb3dlcmNhc2UiLCJtYWtlIiwidW5jYXBpdGFsaXplIiwidXBwZXJjYXNlIiwiaXNfdmFsaWRfdXRmXzgiLCJpc192YWxpZF91dGZfMTZsZSIsImlzX3ZhbGlkX3V0Zl8xNmJlIiwiZ2V0X3V0Zl84X3VjaGFyIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiZ2V0X3V0Zl8zMmxlX3VjaGFyIiwiZ2V0X3V0Zl8zMmJlX3VjaGFyIiwiY29uY2F0IiwiaXRlciIsInNwbGl0X2xpbmVzIiwiaW52YWxpZF9hcmdmIiwicmFpc2VfcyIsInN0YWdlIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImhhc2hhYmxlIiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJjc3RfU3RyaW5nX2luZGV4X2Zyb21fZXhuIiwiY3N0X1N0cmluZ19yaW5kZXhfZnJvbV9leG4iLCJjc3Rfc3Vic3RyaW5nIiwiY3N0X1N1YnN0cmluZ19ub3RfZm91bmQiLCJpbnZhcmlhbnQiLCJwYXJhbSIsInVuc2FmZV9zdWIiLCJzcmMiLCJwb3MiLCJsZW4iLCJkc3QiLCJzdWIiLCJzdWJvIiwib3B0IiwiaSIsImNvbnRhaW5zIiwidCIsImNoYXIiLCJ0b3RhbF9sZW5ndGgiLCJlbmQiLCJpc19lbXB0eSIsImluZGV4Iiwic3RyaW5nIiwiZm91bmQiLCJpbmRleF9leG4iLCJpbmRleF9mcm9tIiwiaW5kZXhfZnJvbV9leG4iLCJyaW5kZXgiLCJyaW5kZXhfZXhuIiwicmluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbV9leG4iLCJjYXNlX3NlbnNpdGl2ZSIsInBhdHRlcm4iLCJrbXBfaW50ZXJuYWxfbG9vcCIsIm1hdGNoZWRfY2hhcnMiLCJuZXh0X3RleHRfY2hhciIsImttcF9hcnJheSIsImNoYXJfZXF1YWwiLCJnZXRfY2hhcl9lcXVhbCIsImNyZWF0ZSIsIm4iLCJpbmRleF9pbnRlcm5hbCIsInRleHQiLCJqIiwiayIsIm1hdGNoZXMiLCJzdHIiLCJpbiQiLCJwIiwiaW5kZXhfYWxsIiwibWF5X292ZXJsYXAiLCJyZXBsYWNlX2ZpcnN0IiwicyIsIndpdGgkIiwibWF0Y2giLCJsZW5fcyIsImxlbl90IiwibGVuX3dpdGgiLCJyZXBsYWNlX2FsbCIsIm51bV9tYXRjaGVzIiwibmV4dF9kc3RfcG9zIiwibmV4dF9zcmNfcG9zIiwic3BsaXRfb24iLCJwYXR0ZXJuX2xlbiIsImVxdWFsX2xvY2FsIiwiYV8wMDMiLCJiXzAwNCIsImVxdWFsIiwiYSIsImIiLCJrbXBfYXJyYXlfMDEyIiwiY2FzZV9zZW5zaXRpdmVfMDEwIiwicGF0dGVybl8wMDgiLCJhcmdfMDEzIiwiYm5kc18wMDciLCJhcmdfMDExIiwiYXJnXzAwOSIsInJlcHJlc2VudGF0aW9uIiwic3Vic3RyX2luZGV4X2dlbiIsInN1YnN0cl9pbmRleF9leG5fZ2VuIiwic3Vic3RyX2luZGV4X2FsbF9nZW4iLCJzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4iLCJzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIiwiaXNfc3Vic3RyaW5nX2dlbiIsInN1YnN0cmluZyIsInN1YnN0cl9pbmRleCIsInN1YnN0cl9pbmRleF9leG4iLCJzdWJzdHJfaW5kZXhfYWxsIiwic3Vic3RyX3JlcGxhY2VfZmlyc3QiLCJzdWJzdHJfcmVwbGFjZV9hbGwiLCJpc19zdWJzdHJpbmciLCJpc19zdWJzdHJpbmdfYXRfZ2VuIiwic3RyX3BvcyIsInN0cl9sZW4iLCJzdWJfbGVuIiwic3ViX3BvcyIsImlzX3N1ZmZpeF9nZW4iLCJzdWZmaXgiLCJzdHJpbmdfbGVuIiwic3VmZml4X2xlbiIsImlzX3ByZWZpeF9nZW4iLCJwcmVmaXgiLCJwcmVmaXhfbGVuIiwiY29tcGFyZV9sb2NhbCIsInN0cmluZzEiLCJzdHJpbmcyIiwibGVuMiIsImxlbjEiLCJjMiIsImMxIiwiYyIsInN0YXRlIiwiaXNfc3VmZml4IiwiaXNfcHJlZml4IiwiaXNfc3Vic3RyaW5nX2F0Iiwic3ltYm9sIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNzdF9leHBlY3Rpbmdfbm9ubmVnYXRpdmVfYXJndSIsImNzdF9kcm9wX3ByZWZpeCIsImNzdF9kcm9wX3N1ZmZpeCIsImNzdF9wcmVmaXgiLCJjc3Rfc3VmZml4IiwiY3N0X3RyX211bHRpX3JlcGxhY2VtZW50X2lzX2VtIiwiY3N0X2VzY2FwZXdvcnRoeV9tYXAiLCJjc3RfY190byIsImNzdF9jX2Zyb20iLCJjc3RfZXNjYXBld29ydGh5X21hcF9ub3Rfb25lX3QiLCJjc3RfaXNfY2hhcl9lc2NhcGluZyIsImNzdF9pc19jaGFyX2VzY2FwZWQiLCJjc3RfaXNfY2hhcl9saXRlcmFsIiwiY3N0X2luZGV4X2Zyb20iLCJjc3RfaW5kZXhfZnJvbV9leG5fbm90X2ZvdW5kIiwiY3N0X3JpbmRleF9mcm9tIiwiY3N0X3JpbmRleF9mcm9tX2V4bl9ub3RfZm91bmQiLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiY3N0X29mX3N0cmluZ19pbnZhbGlkIiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwiaW5pdCIsInRvX2xpc3QiLCJhY2MiLCJ0b19saXN0X3JldiIsInJldiIsInJlcyIsImxzcGxpdDJfZXhuIiwiZGVsaW0iLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJsaW5lIiwib24iLCJleG4iLCJyc3BsaXQyIiwiY2hhcl9saXN0X21lbSIsImwiLCJ0bCIsImhkIiwic3BsaXRfZ2VuIiwidmFyaWFudCIsImlzX2RlbGltIiwibGFzdF9wb3MiLCJwb3MxIiwic3ViX3N0ciIsInNwbGl0Iiwic3BsaXRfb25fY2hhcnMiLCJjaGFycyIsIndyYXBfc3ViX24iLCJuYW1lIiwib25fZXJyb3IiLCJkcm9wX3ByZWZpeCIsImRyb3Bfc3VmZml4IiwibGZpbmRpIiwiZmluZCIsImZpbmRfbWFwIiwicmZpbmRpIiwibGFzdF9ub25fZHJvcCIsImRyb3AiLCJyc3RyaXAiLCJmaXJzdF9ub25fZHJvcCIsImxzdHJpcCIsInN0cmlwIiwibGVuZ3RoIiwiZmlyc3QiLCJsYXN0IiwibWFwaSIsIm1hcCIsInRvX2FycmF5IiwiZXhpc3RzIiwiZm9yX2FsbCIsImZvbGQiLCJhYyIsImZvbGRpIiwiaXRlcmkiLCJjb3VudCIsInN1bSIsIm0iLCJtaW5fZWx0IiwibWF4X2VsdCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsImZpbmRfbWFwaSIsImZpbmRpIiwiY291bnRpIiwiZm9yX2FsbGkiLCJleGlzdHNpIiwibWVtIiwidHIiLCJ0YXJnZXQiLCJyZXBsYWNlbWVudCIsInRyX211bHRpIiwidHJfbWFwIiwiY29uY2F0X2FycmF5Iiwic2VwIiwiYXIiLCJjb25jYXRfbWFwIiwiY29uY2F0X21hcGkiLCJjb25jYXRfbGluZXMiLCJsaW5lcyIsImNybGYiLCJuZXdsaW5lX2xlbiIsImJ1ZiIsIndyaXR0ZW4iLCJmaWx0ZXIiLCJvdXQiLCJvdXRfcG9zIiwiZmlsdGVyaSIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJsaXN0IiwicmVzdCIsInBvc19mcm9tX2xlZnQiLCJwb3NfZnJvbV9yaWdodCIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCIsImdldF9wb3MiLCJtYXhfbGVuIiwibGVuX3NvX2ZhciIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGgiLCJjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCIsInNlY29uZCIsImNvbW1vbl9nZW5lcmljX2xlbmd0aCIsImNvbW1vbl9nZW5lcmljMiIsInRha2UiLCJjb21tb25fZ2VuZXJpYyIsImNvbW1vbl9wcmVmaXgiLCJjb21tb25fc3VmZml4IiwiY29tbW9uX3ByZWZpeDIiLCJjb21tb25fc3VmZml4MiIsImNvbW1vbl9wcmVmaXhfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeF9sZW5ndGgiLCJjb21tb25fcHJlZml4Ml9sZW5ndGgiLCJjb21tb25fc3VmZml4Ml9sZW5ndGgiLCJwcCIsInBwZiIsIm9mX2NoYXIiLCJvZl9jaGFyX2xpc3QiLCJvZl9hcnJheSIsInRvX3NlcXVlbmNlIiwib2Zfc2VxdWVuY2UiLCJwYWRfcmlnaHQiLCJzcmNfbGVuIiwicGFkX2xlZnQiLCJsb2NhbF9jb3B5X3ByZWZpeCIsImJ1ZmZlcl9sZW4iLCJsb2NhbF9jb3B5X3RvX3N0cmluZyIsImZpbHRlcl9tYXBpIiwic3JjX3BvcyIsIm9wdGlvbiIsImNvcHkiLCJkc3RfcG9zIiwiZmlsdGVyX21hcCIsInBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSIsImZzdF9wb3MiLCJzbmRfcG9zIiwiZWl0aGVyIiwiZnN0cyIsInNuZHMiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uX3RmIiwiZWRpdF9kaXN0YW5jZSIsInMyIiwiczEiLCJ0YWJsZSIsImF0IiwiYWRkIiwiZGVsIiwiYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoIiwiZXNjYXBld29ydGh5X21hcCIsImVzY2FwZV9jaGFyIiwiYXJyIiwidmFscyIsImNfdG8iLCJjX2Zyb20iLCJ2IiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImVzY2FwZWRfY2hhciIsImVzY2FwZV9nZW5fZXhuIiwiZXNjYXBlIiwidW5lc2NhcGVfZ2VuIiwic3RhdHVzIiwidG9fdW5lc2NhcGUiLCJpZHgiLCJsb29wIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJlc2NhcGVfY2hhcnMiLCJzcGxpdF9hdCIsImxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsImZpcnN0X25vbl9kcm9wX2xpdGVyYWwiLCJyc3RyaXBfbGl0ZXJhbCIsImxzdHJpcF9saXRlcmFsIiwic3RyaXBfbGl0ZXJhbCIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJNYWtlX3V0ZiIsIkZvcm1hdCIsImlzX3ZhbGlkIiwicmFpc2VfZ2V0X21lc3NhZ2UiLCJyYWlzZV9nZXQiLCJnZXQiLCJieXRlX3BvcyIsImRlY29kZSIsIm9mX3N0cmluZ191bmNoZWNrZWQiLCJyYWlzZV9vZl9zdHJpbmdfbWVzc2FnZSIsInJhaXNlX29mX3N0cmluZyIsInNhbml0aXplIiwidWNoYXIiLCJieXRlcyIsIm9mX2xpc3QiLCJ1Y2hhcnMiLCJ1Iiwic3RhcnQiLCJ1bnRpbCIsImJsb2NrIiwib2Zmc2V0IiwiQyIsImFwcGVuZCIsImJ5dGVfbGVuZ3RoIiwic2V0IiwiVXRmOCIsIlV0ZjE2bGUiLCJVdGYxNmJlIiwiTWFrZV91dGYzMiIsImdldF9kZWNvZGVfcmVzdWx0IiwicmVzdWx0IiwiVXRmMzJsZSIsIlV0ZjMyYmUiLCJCYXNlX1N0cmluZyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQTNCLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBNEIsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBRCxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBRCxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBRCxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBRCxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEdjVCRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMzMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2J5dGVzLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbmluY2x1ZGUgQnl0ZXNfaW50ZlxuXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYnl0ZXMgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfYnl0ZXMgOiB0IC0+IHQpXG4gIGxldCB0X29mX3NleHAgPSAoYnl0ZXNfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYnl0ZXMgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYnl0ZXNfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEJ5dGVzMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5CeXRlc1wiXG4gIGxldCBwcCBmbXQgdCA9IFN0ZGxpYi5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlU1wiICh0b19zdHJpbmcgdClcbmVuZFxuXG5pbmNsdWRlIFRcblxubW9kdWxlIFRvX2J5dGVzID0gQmxpdC5NYWtlIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IGNyZWF0ZSB+bGVuID0gY3JlYXRlIGxlblxuZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFQpIChUb19ieXRlcylcblxubW9kdWxlIEZyb21fc3RyaW5nID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIGVuZClcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgbiAwXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIkJ5dGVzLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gc2V0IHQgaSBjKTtcbiAgdFxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgKGkgLSAxKSAodW5zYWZlX2dldCB0IGkgOjogYWNjKVxuICBpblxuICBsb29wIHQgKGxlbmd0aCB0IC0gMSkgW11cbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcbmxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gbWFwaSB0IH5mXG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBwb3MgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzIGkpIHRhcmdldCB0aGVuIHVuc2FmZV9zZXQgcyBpIHJlcGxhY2VtZW50XG4gIGRvbmVcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAwXG4gIHRoZW4gc3RhZ2UgaWdub3JlXG4gIGVsc2UgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgMFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGk6IHJlcGxhY2VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgaWdub3JlXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IHMgaSAoU3RyaW5nLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCAodW5zYWZlX2dldCBzIGkpKSlcbiAgICAgICAgZG9uZSkpXG47O1xuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgY29udGFpbnMgP3BvcyA/bGVuIHQgY2hhciA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbGFzdCA9IHBvcyArIGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIGxhc3RcbiAgICAmJiAoQ2hhci5lcXVhbCAoZ2V0IHQgaSkgY2hhciB8fCBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG5tb2R1bGUgVXRmOCA9IHN0cnVjdFxuICBsZXQgc2V0ID0gc2V0X3VjaGFyX3V0Zl84XG5lbmRcblxubW9kdWxlIFV0ZjE2bGUgPSBzdHJ1Y3RcbiAgbGV0IHNldCA9IHNldF91Y2hhcl91dGZfMTZsZVxuZW5kXG5cbm1vZHVsZSBVdGYxNmJlID0gc3RydWN0XG4gIGxldCBzZXQgPSBzZXRfdWNoYXJfdXRmXzE2YmVcbmVuZFxuXG5tb2R1bGUgVXRmMzJsZSA9IHN0cnVjdFxuICBsZXQgc2V0ID0gc2V0X3VjaGFyX3V0Zl8zMmxlXG5lbmRcblxubW9kdWxlIFV0ZjMyYmUgPSBzdHJ1Y3RcbiAgbGV0IHNldCA9IHNldF91Y2hhcl91dGZfMzJiZVxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiQmFzZV9DaGFyIiwiQmFzZV9JbXBvcnQiLCJCYXNlX09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24iLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0J5dGVzX3RyIiwiQmFzZV9BcnJheTAiLCJCYXNlX0xpc3QiLCJCYXNlX1ByaW50ZiIsIlN0ZGxpYl9Gb3JtYXQiLCJCYXNlX1N0YWdlZCIsIkJhc2VfQnl0ZXMwIiwiQmFzZV9CbGl0IiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsInN0YWdlIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJtYXhfbGVuZ3RoIiwiY29tcGFyZSIsImNvcHkiLCJjcmVhdGUiLCJzZXRfdWNoYXJfdXRmXzgiLCJzZXRfdWNoYXJfdXRmXzE2bGUiLCJzZXRfdWNoYXJfdXRmXzE2YmUiLCJzZXRfdWNoYXJfdXRmXzMybGUiLCJzZXRfdWNoYXJfdXRmXzMyYmUiLCJjcmVhdGVfbG9jYWwiLCJmaWxsIiwibWFrZSIsIm1hcCIsIm1hcGkiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmciLCJwcCIsImZtdCIsInQiLCJsZW4iLCJUb19ieXRlcyIsImJsaXQiLCJibGl0byIsInVuc2FmZV9ibGl0Iiwic3ViIiwic3VibyIsImNvbXBhcmF0b3IiLCJpbmNsdWRlIiwiVG9fc3RyaW5nIiwibGVuZ3RoIiwiRnJvbV9zdHJpbmciLCJjc3RfdHJfbXVsdGlfcmVwbGFjZW1lbnRfaXNfdGgiLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiaW52YXJpYW50IiwicGFyYW0iLCJpbml0IiwibiIsImkiLCJvZl9jaGFyX2xpc3QiLCJsIiwiYyIsInRvX2xpc3QiLCJhY2MiLCJ0b19hcnJheSIsImZvbGQiLCJwb3MiLCJmb2xkaSIsInRyIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJzIiwidHJfbXVsdGkiLCJtYXRjaCIsInRyX21hcCIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwibWluIiwibWF4IiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb250YWlucyIsImNoYXIiLCJsYXN0IiwiVXRmOCIsIlV0ZjE2bGUiLCJVdGYxNmJlIiwiVXRmMzJsZSIsIlV0ZjMyYmUiLCJzeW1ib2wiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsIiwiZXF1YWxfbG9jYWwiLCJCYXNlX0J5dGVzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEckdGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjI2NzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaGV4X2xleGVyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiIyAxIFwic3JjL2hleF9sZXhlci5tbGxcIlxuIFxudHlwZSByZXN1bHQgPVxufCBOZWcgb2Ygc3RyaW5nXG58IFBvcyBvZiBzdHJpbmdcblxuIyA4IFwic3JjL2hleF9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDI3XFwwMDBcXDA4MlxcMDAwXFwxMDVcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgcGFyc2VfaGV4IGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG5sZXRcbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiMgMTM1IFwic3JjL2hleF9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMykgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTQgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggTmVnIGJvZHkgKVxuIyAxMzkgXCJzcmMvaGV4X2xleGVyLm1sXCJcblxuICB8IDEgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxNDUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAyKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNSBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQb3MgYm9keSApXG4jIDE0OSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIm9jYW1sX2xleF90YWJsZXMiLCJTdGRsaWJfTGV4aW5nIiwicGFyc2VfaGV4IiwibGV4YnVmIiwib2NhbWxfbGV4X3N0YXRlIiwiYm9keSIsIkJhc2VfSGV4X2xleGVyIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsTUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsUUFBQUMsa0JDOEhHO0FBQUE7QUFBQTtBQUFBLE1BQUFBO0FBQUFBLFFBRUs7QUFBQTtBQUFBLEtBQXlEO0FBQUE7QUFBQSxPQUFBQztBQUFBQSxTQU0vRDtBQUFBLE1EdElGO0FBQUE7QUFBQSxLQ2dJaUU7QUFBQTtBQUFBLE9BQUFBO0FBQUFBLFNBZ0IvRDtBQUFBLE1EaEpGO0FBQUE7QUFBQSxLQ3FKeUI7QUFBQSxLQUFnQztBQUFBO0FBQUEsR0F2QnBCO0FBQUEsT0FBQUMsaUJEOUhyQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyNzI5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ludF9zdHJpbmdfY29udmVyc2lvbnMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuKCogc3RyaW5nIGNvbnZlcnNpb25zICopXG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgPVxuICBsZXQgaW5wdXRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpbnB1dCBpblxuICBpZiBpbnB1dF9sZW5ndGggPD0gY2hhcnNfcGVyX2RlbGltaXRlclxuICB0aGVuIGlucHV0XG4gIGVsc2UgKFxuICAgIGxldCBoYXNfc2lnbiA9XG4gICAgICBtYXRjaCBpbnB1dC5bMF0gd2l0aFxuICAgICAgfCAnKycgfCAnLScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgbnVtX2RpZ2l0cyA9IGlmIGhhc19zaWduIHRoZW4gaW5wdXRfbGVuZ3RoIC0gMSBlbHNlIGlucHV0X2xlbmd0aCBpblxuICAgIGxldCBudW1fZGVsaW1pdGVycyA9IChudW1fZGlnaXRzIC0gMSkgLyBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IG91dHB1dF9sZW5ndGggPSBpbnB1dF9sZW5ndGggKyBudW1fZGVsaW1pdGVycyBpblxuICAgIGxldCBvdXRwdXQgPSBCeXRlcy5jcmVhdGUgb3V0cHV0X2xlbmd0aCBpblxuICAgIGxldCBpbnB1dF9wb3MgPSByZWYgKGlucHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG91dHB1dF9wb3MgPSByZWYgKG91dHB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gcmVmIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgZmlyc3RfZGlnaXRfcG9zID0gaWYgaGFzX3NpZ24gdGhlbiAxIGVsc2UgMCBpblxuICAgIHdoaWxlICFpbnB1dF9wb3MgPj0gZmlyc3RfZGlnaXRfcG9zIGRvXG4gICAgICBpZiAhbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGRlbGltaXRlcjtcbiAgICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgICBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIDo9IGNoYXJzX3Blcl9kZWxpbWl0ZXIpO1xuICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBpbnB1dC5bIWlucHV0X3Bvc107XG4gICAgICBkZWNyIGlucHV0X3BvcztcbiAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgIGRlY3IgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlclxuICAgIGRvbmU7XG4gICAgaWYgaGFzX3NpZ24gdGhlbiBCeXRlcy5zZXQgb3V0cHV0IDAgaW5wdXQuWzBdO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0cHV0KVxuOztcblxubGV0IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlciA9XG4gIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlcjozXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzIGlucHV0ID0gaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyOidfJ1xubGV0IHNleHBfb2ZfaW50X3N0eWxlID0gU2V4cC5vZl9pbnRfc3R5bGVcblxubW9kdWxlIE1ha2UgKEkgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5lbmQpID1cbnN0cnVjdFxuICBvcGVuIElcblxuICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDNcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBzID0gdG9fc3RyaW5nIHQgaW5cbiAgICBTZXhwLkF0b21cbiAgICAgIChtYXRjaCAhc2V4cF9vZl9pbnRfc3R5bGUgd2l0aFxuICAgICAgIHwgYFVuZGVyc2NvcmVzIC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgcyB+Y2hhcnNfcGVyX2RlbGltaXRlciB+ZGVsaW1pdGVyOidfJ1xuICAgICAgIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaGV4IChJIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TX2xvY2FsIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgdmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgKCA8ICkgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFRfaGV4ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gSS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA9IChJLmNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBJLmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IEkuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDRcblxuICAgIGxldCB0b19zdHJpbmcnID9kZWxpbWl0ZXIgdCA9XG4gICAgICBsZXQgbWFrZV9zdWZmaXggPVxuICAgICAgICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gSS50b19zdHJpbmdcbiAgICAgICAgfCBTb21lIGRlbGltaXRlciAtPlxuICAgICAgICAgIGZ1biB0IC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKEkudG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgICAgIGluXG4gICAgICBpZiBJLiggPCApIHQgSS56ZXJvIHRoZW4gXCItMHhcIiBeIG1ha2Vfc3VmZml4IChJLm5lZyB0KSBlbHNlIFwiMHhcIiBeIG1ha2Vfc3VmZml4IHRcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyB0ID0gdG9fc3RyaW5nJyB0ID9kZWxpbWl0ZXI6Tm9uZVxuICAgIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID0gdG9fc3RyaW5nJyB0IH5kZWxpbWl0ZXJcblxuICAgIGxldCBpbnZhbGlkIHN0ciA9XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiJXMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgSS5tb2R1bGVfbmFtZSBzdHIgKClcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBzdHIgPVxuICAgICAgSS5vZl9zdHJpbmcgKFN0cmluZy5maWx0ZXIgc3RyIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICdfJykpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICAgIGxldCBtb2R1bGUgTCA9IEhleF9sZXhlciBpblxuICAgICAgbGV0IGxleCA9IFN0ZGxpYi5MZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgcmVzdWx0ID0gT3B0aW9uLnRyeV93aXRoIChmdW4gKCkgLT4gTC5wYXJzZV9oZXggbGV4KSBpblxuICAgICAgaWYgbGV4LmxleF9jdXJyX3BvcyA9IGxleC5sZXhfYnVmZmVyX2xlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbnZhbGlkIHN0clxuICAgICAgICB8IFNvbWUgKE5lZyBib2R5KSAtPiBJLm5lZyAob2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICAgIHwgU29tZSAoUG9zIGJvZHkpIC0+IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgZWxzZSBpbnZhbGlkIHN0clxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBIZXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRfaGV4XG4gICAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zdHJpbmdhYmxlIChUX2hleClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2VfYmluYXJ5IChJIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlNfbG9jYWwgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuU19sb2NhbCB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIFtAQEBlbmRdXG5cbiAgdmFsIGNseiA6IHQgLT4gaW50XG4gIHZhbCAoIGxzciApIDogdCAtPiBpbnQgLT4gdFxuICB2YWwgKCBsYW5kICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgdG9faW50X2V4biA6IHQgLT4gaW50XG4gIHZhbCBudW1fYml0cyA6IGludFxuICB2YWwgemVybyA6IHRcbiAgdmFsIG9uZSA6IHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBCaW5hcnkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBJLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKEkuY29tcGFyZV9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICAgIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBiaXRzIHQgPSBpZiBJLmVxdWFsX19sb2NhbCB0IEkuemVybyB0aGVuIDAgZWxzZSBJLm51bV9iaXRzIC0gSS5jbHogdFxuXG4gICAgbGV0IHRvX3N0cmluZ19zdWZmaXggKHQgOiB0KSA9XG4gICAgICBsZXQgYml0cyA9IGJpdHMgdCBpblxuICAgICAgaWYgYml0cyA9IDBcbiAgICAgIHRoZW4gXCIwXCJcbiAgICAgIGVsc2VcbiAgICAgICAgU3RyaW5nLmluaXQgYml0cyB+ZjooZnVuIGNoYXJfaW5kZXggLT5cbiAgICAgICAgICBsZXQgYml0X2luZGV4ID0gYml0cyAtIGNoYXJfaW5kZXggLSAxIGluXG4gICAgICAgICAgbGV0IGJpdCA9IEkuKCh0IGxzciBiaXRfaW5kZXgpIGxhbmQgb25lKSBpblxuICAgICAgICAgIENoYXIudW5zYWZlX29mX2ludCAoQ2hhci50b19pbnQgJzAnICsgSS50b19pbnRfZXhuIGJpdCkpXG4gICAgOztcblxuICAgIGxldCB0b19zdHJpbmcgKHQgOiB0KSA9IFwiMGJcIiBeIHRvX3N0cmluZ19zdWZmaXggdFxuXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPVxuICAgICAgXCIwYlwiIF4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nX3N1ZmZpeCB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyOjRcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCAodCA6IHQpIDogU2V4cC50ID0gQXRvbSAodG9fc3RyaW5nX2h1bSB0KVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfMGIiLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9DaGFyIiwiQmFzZV9TdHJpbmciLCJCYXNlX0hleF9sZXhlciIsIlN0ZGxpYl9MZXhpbmciLCJCYXNlX09wdGlvbiIsIkJhc2VfUHJpbnRmIiwiQmFzZV9TZXhwYWJsZSIsIkJhc2VfQnl0ZXMiLCJCYXNlX1NleHAiLCJpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IiwiaW5wdXQiLCJkZWxpbWl0ZXIiLCJjaGFyc19wZXJfZGVsaW1pdGVyIiwiaW5wdXRfbGVuZ3RoIiwibWF0Y2giLCJoYXNfc2lnbiIsIm51bV9kaWdpdHMiLCJudW1fZGVsaW1pdGVycyIsIm91dHB1dF9sZW5ndGgiLCJvdXRwdXQiLCJpbnB1dF9wb3MiLCJvdXRwdXRfcG9zIiwibnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciIsImZpcnN0X2RpZ2l0X3BvcyIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJzZXhwX29mX2ludF9zdHlsZSIsImNzdF8weCIsImNzdF8wIiwiQmFzZV9JbnRfc3RyaW5nX2NvbnZlcnNpb25zIiwiSSIsInRvX3N0cmluZ19odW0iLCJvcHQiLCJ0Iiwic2V4cF9vZl90IiwicyIsImNvbXBhcmVfbG9jYWwiLCJjb21wYXJlIiwiYSIsImIiLCJoYXNoX2ZvbGRfdCIsImZ1bmMiLCJoYXNoIiwieCIsInRvX3N0cmluZyIsIm1ha2Vfc3VmZml4IiwiaW52YWxpZCIsInN0ciIsIm9mX3N0cmluZ193aXRoX2RlbGltaXRlciIsImMiLCJvZl9zdHJpbmciLCJsZXgiLCJyZXN1bHQiLCJwYXJhbSIsImJvZHkiLCJpbmNsdWRlIiwidF9zZXhwX2dyYW1tYXIiLCJ0X29mX3NleHAiLCJ0b19zdHJpbmdfc3VmZml4IiwiYml0cyIsImNoYXJfaW5kZXgiLCJiaXRfaW5kZXgiLCJiaXQiXSwibWFw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QUFBQSwwQkFDeUI7QUFBQSwwQkFBbEI7QUFBQSwwQkFBRDtBQUFBLHFCQUFvQztBQUFBLHNCQUFDO0FBQUE7QUFBQSxpQkFBQWxCLFVBQUFYO0FBQUFBLGFBQUEsSUFHL0I7QUFBQSxTQUFrQjtBQUFBO0FBQUEsaUJBQUFGLGNBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLFVBQUF0QixZQUUvQjtBQUFBLGNBQ1QsdUJBQXVCO0FBQUEsU0FBc0Q7QUFBQTtBQUFBLGlCQUFBdUIsVUFBQUQsR0FHaEQsK0JBQWlCO0FBQUEsUUF4QnJEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHRDlLTiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyOTgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3BvcGNvdW50Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqIEMgc3R1YiBmb3IgaW50IHBvcGNvdW50IHRvIHVzZSB0aGUgUE9QQ05UIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG5leHRlcm5hbCBpbnRfcG9wY291bnQgOiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudFwiIFtAQG5vYWxsb2NdXG5cbigqIFRvIG1haW50YWluIGphdmFzY3JpcHQgY29tcGF0aWJpbGl0eSBhbmQgZW5hYmxlIHVuYm94aW5nLCB3ZSBpbXBsZW1lbnQgcG9wY291bnQgaW5cbiAgIE9DYW1sIHJhdGhlciB0aGFuIHVzZSBDIHN0dWJzLiBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb206XG4gICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYW1taW5nX3dlaWdodCNFZmZpY2llbnRfaW1wbGVtZW50YXRpb24gKilcbmxldCBpbnQ2NF9wb3Bjb3VudCA9XG4gIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICBsZXQgKCArICkgPSBhZGQgaW5cbiAgbGV0ICggLSApID0gc3ViIGluXG4gIGxldCAoICogKSA9IG11bCBpblxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaW5cbiAgbGV0ICggbGFuZCApID0gbG9nYW5kIGluXG4gIGxldCBtMSA9IDB4NTU1NTU1NTU1NTU1NTU1NUwgaW5cbiAgKCogMGIwMTAxMDEwMS4uLiAqKVxuICBsZXQgbTIgPSAweDMzMzMzMzMzMzMzMzMzMzNMIGluXG4gICgqIDBiMDAxMTAwMTEuLi4gKilcbiAgbGV0IG00ID0gMHgwZjBmMGYwZjBmMGYwZjBmTCBpblxuICAoKiAwYjAwMDAxMTExLi4uICopXG4gIGxldCBoMDEgPSAweDAxMDEwMTAxMDEwMTAxMDFMIGluXG4gICgqIDEgYml0IHNldCBwZXIgYnl0ZSAqKVxuICBmdW4gW0BpbmxpbmVdIHggLT5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgcGFpciBvZiBiaXRzICopXG4gICAgbGV0IHggPSB4IC0gKCh4IGxzciAxKSBsYW5kIG0xKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSA0IGJpdHMgKilcbiAgICBsZXQgeCA9ICh4IGxhbmQgbTIpICsgKCh4IGxzciAyKSBsYW5kIG0yKSBpblxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBieXRlICopXG4gICAgbGV0IHggPSAoeCArICh4IGxzciA0KSkgbGFuZCBtNCBpblxuICAgICgqIHN1bSB0aGUgYml0IGNvdW50cyBpbiB0aGUgdG9wIGJ5dGUgYW5kIHNoaWZ0IGl0IGRvd24gKilcbiAgICB0b19pbnQgKCh4ICogaDAxKSBsc3IgNTYpXG47O1xuXG5sZXQgaW50MzJfcG9wY291bnQgPVxuICAoKiBPbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpcyBmYXN0ZXIgdGhhbiBpbXBsZW1lbnRpbmcgdXNpbmcgW2ludDMyXSBhcml0aG1ldGljLiAqKVxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmTCBpblxuICBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKFN0ZGxpYi5JbnQ2NC5sb2dhbmQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQzMiB4KSBtYXNrKVxuOztcblxubGV0IG5hdGl2ZWludF9wb3Bjb3VudCA9XG4gIG1hdGNoIFN0ZGxpYi5OYXRpdmVpbnQuc2l6ZSB3aXRoXG4gIHwgMzIgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDMyX3BvcGNvdW50IChTdGRsaWIuTmF0aXZlaW50LnRvX2ludDMyIHgpXG4gIHwgNjQgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChTdGRsaWIuSW50NjQub2ZfbmF0aXZlaW50IHgpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9hbmQiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJnbG9iYWxfZGF0YSIsIm0xIiwibTIiLCJtNCIsImgwMSIsIm1hc2siLCJTdGRsaWJfTmF0aXZlaW50IiwiQXNzZXJ0X2ZhaWx1cmUiLCJpbnQ2NF9wb3Bjb3VudCIsIngiLCJpbnQzMl9wb3Bjb3VudCIsIm1hdGNoIiwibmF0aXZlaW50X3BvcGNvdW50IiwiQmFzZV9Qb3Bjb3VudCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsZUFBQUM7QUFBQUE7QUFBQUEsS0FBQUE7QUFBQUEsT0N5Qlk7QUFBQSxjQUFJLGVBQUM7QUFBQSxLQUFBQTtBQUFBQSxPQUVMO0FBQUE7QUFBQSxTQUFjLGVBQUM7QUFBQSxLQUFBQTtBQUFBQSxPQUVmO0FBQUEsMkJBQUs7QUFBQSxJQUVMLE9BQWlCO0FBQUEsYUFBbEI7QUFBQSxlQUFDLHNDQUFpQjtBQUFBO0FBQUEsWUFBQUMsZUFBQUQ7QUFBQUEsSUFNNEIsT0FBK0IsZUFBcEQsZUFBcUIsOEJBQStCO0FBQUE7QUFBQSxPQUFBRSxRQUF0RjtBQUFBO0FBQUEsUUFBQUMscUJBS1EsU0FBQUgsR0FBK0Q7QUFBQTtBQUFBLElBTHZFO0FBQUEsS0FPTztBQUFBO0FBQUEsS0FBQUc7QUFBQUEsT0FEQyxTQUFBSCxHQUFrQyxPQUE2QixlQUE3Qix1QkFBNkI7QUFBQTtBQUFBO0FBQUEsSUFBQUk7QUFBQUEsTUFOdkU7QUFBQSxtQkRyQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQ3FDRTtBQUFBO0FBQUEsRURyQ0YiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzA0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zaWduLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNpZ24wXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChTaWduMClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCB0b19zdHJpbmdfaHVtID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gXCJuZWdhdGl2ZVwiXG4gIHwgWmVybyAtPiBcInplcm9cIlxuICB8IFBvcyAtPiBcInBvc2l0aXZlXCJcbjs7XG5cbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xLlxuICB8IFplcm8gLT4gMC5cbiAgfCBQb3MgLT4gMS5cbjs7XG5cbmxldCBmbGlwID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gUG9zXG4gIHwgWmVybyAtPiBaZXJvXG4gIHwgUG9zIC0+IE5lZ1xuOztcblxubGV0ICggKiApIHQgdCcgPSBvZl9pbnQgKHRvX2ludCB0ICogdG9faW50IHQnKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhdCB0aGUgZW5kLCBhZnRlciBhbnlcbiAgIGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvXG4gICB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXNcbiAgIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NpZ24wIiwiQmFzZV9JZGVudGlmaWFibGUiLCJ0X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbG9jYWwiLCJhbGwiLCJSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUiLCJ0b19pbnQiLCJvZl9pbnQiLCJoYXNoX2ZvbGRfdCIsImhhc2giLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwicHAiLCJoYXNoYWJsZSIsImNzdF9uZWdhdGl2ZSIsImNzdF96ZXJvIiwiY3N0X3Bvc2l0aXZlIiwidG9fc3RyaW5nX2h1bSIsInBhcmFtIiwidG9fZmxvYXQiLCJmbGlwIiwic3ltYm9sIiwidCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJjb21wYXJlIiwiZXF1YWwiLCJlcXVhbF9sb2NhbCIsIm1heCIsIm1pbiIsIkJhc2VfU2lnbiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLGNBQUFDO0FBQUFBLElDU29CO0FBQUE7QUFBQSxPQUNUO0FBQUE7QUFBQSxPQUNDO0FBQUEsZUFDRDtBQUFBO0FBQUEsR0FBVTtBQUFBLFlBQUFDLFNBQUFEO0FBQUFBLElBR04sc0JBQ0osbUJBQ0MsbUJBQ0Q7QUFBQTtBQUFBLEdBQUU7QUFBQSxZQUFBRSxLQUFBRjtBQUFBQSxJQUdGLHNCQUNBLGlCQUNDLGtCQUNEO0FBQUE7QUFBQSxHQUFHO0FBQUEsWUFBQUcsT0FBQUMsS0FBQUE7QUFBQUEsUUFBQSxJQUdzQixlQUFYO0FBQUEsSUFBRCxPQUFzQixPQUF0QixpQ0FBc0I7QUFBQTtBQUFBO0FBQUEsSUFBQUQsV0QzQjlDO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBRSxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMTY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ludC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnRfaW50ZlxuaW5jbHVkZSBJbnQwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlIHggeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZSB4IHlcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIHRyeSBvZl9zdHJpbmcgcyB3aXRoXG4gICAgfCBfIC0+IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG5lbmRcblxubGV0IG51bV9iaXRzID0gSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgdG9fZmxvYXQgPSBTdGRsaWIuZmxvYXRfb2ZfaW50XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gU3RkbGliLmludF9vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAgICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBTdGRsaWIuaW50X29mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2UgKFQpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2hleCAoc3RydWN0XG4gIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG5lZyA9ICggfi0gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICBsZXQgb2Zfc3RyaW5nIHMgPSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCIleFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50XCJcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbjptaW5fIH5tYXg6bWF4XyA9IG1pbiB0IG1heF8gfD4gbWF4IG1pbl9cblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogKHRbQGxvY2FsX29wdF0pIC0+IChpbnQzMltAbG9jYWxfb3B0XSkgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50MzJfdHJ1bmMgOiAoaW50MzJbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50NjRfdHJ1bmMgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50X3RydW5jIDogKG5hdGl2ZWludFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuXG5sZXQgcHJlZCBpID0gaSAtIDFcbmxldCBzdWNjIGkgPSBpICsgMVxubGV0IHRvX2ludCBpID0gaVxubGV0IHRvX2ludF9leG4gPSB0b19pbnRcbmxldCBvZl9pbnQgaSA9IGlcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgbWF4X3ZhbHVlID0gU3RkbGliLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBTdGRsaWIubWluX2ludFxubGV0IG1heF92YWx1ZV8zMF9iaXRzID0gMHgzRkZGX0ZGRkZcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgb2ZfaW50MzJfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50MzIgPSBDb252LmludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCB0b19pbnQ2NCA9IENvbnYuaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgYWJzIHggPSBhYnMgeFxuXG4oKiBub3RlIHRoYXQgcmVtIGlzIG5vdCBzYW1lIGFzICUgKilcbmxldCByZW0gYSBiID0gYSBtb2QgYlxubGV0IGluY3IgPSBTdGRsaWIuaW5jclxubGV0IGRlY3IgPSBTdGRsaWIuZGVjclxubGV0IHNoaWZ0X3JpZ2h0IGEgYiA9IGEgYXNyIGJcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsIGEgYiA9IGEgbHNyIGJcbmxldCBzaGlmdF9sZWZ0IGEgYiA9IGEgbHNsIGJcbmxldCBiaXRfbm90IGEgPSBsbm90IGFcbmxldCBiaXRfb3IgYSBiID0gYSBsb3IgYlxubGV0IGJpdF9hbmQgYSBiID0gYSBsYW5kIGJcbmxldCBiaXRfeG9yIGEgYiA9IGEgbHhvciBiXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnRfcG93XG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IC0gMSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCArIDFcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggLSAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kICh4IC0gMSkgPSAwXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogICgqIE5vdGUgdGhhdCB3ZSBwYXNzIHRoZSB0YWdnZWQgaW50IGhlcmUuIFNlZSBpbnRfbWF0aF9zdHVicy5jIGZvciBkZXRhaWxzIG9uIHdoeVxuICAgICAgICAgIHRoaXMgaXMgY29ycmVjdC4gKilcbiAgICAgICBpbnRcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6X3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnRbQHVudGFnZ2VkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6X3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBpZiBpID0gMSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoaSAtIDEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBzaWduID0gU2lnbi5vZl9pbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludF9wb3Bjb3VudFxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9pbnRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlYWRkaW50XCJcbiAgZXh0ZXJuYWwgKCAtICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVzdWJpbnRcIlxuICBleHRlcm5hbCAoICogKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW11bGludFwiXG4gIGV4dGVybmFsICggLyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlZGl2aW50XCJcbiAgZXh0ZXJuYWwgKCB+LSApIDogKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgbW9kdWxlIEYgPSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgbGV0IHJlbSA9IHJlbVxuICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgZW5kKVxuXG4gIGluY2x1ZGUgRlxuXG4gIGV4dGVybmFsIGJzd2FwMTYgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVic3dhcDE2XCJcblxuICAoKiBUaGVzZSBpbmxpbmVkIHZlcnNpb25zIG9mICglKSwgKC8lKSwgYW5kICgvLykgcGVyZm9ybSBiZXR0ZXIgdGhhbiB0aGVpciBmdW5jdG9yaXplZFxuICAgICBjb3VudGVycGFydHMgaW4gW0ZdIChzZWUgYmVuY2htYXJrcyBiZWxvdykuXG5cbiAgICAgVGhlIHJlYXNvbiB0aGVzZSBmdW5jdGlvbnMgYXJlIGlubGluZWQgaW4gW0ludF0gYnV0IG5vdCBpbiBhbnkgb2YgdGhlIG90aGVyIGludGVnZXJcbiAgICAgbW9kdWxlcyBpcyB0aGF0IHRoZXkgZXhpc3RlZCBpbiBbSW50XSBhbmQgW0ludF0gYWxvbmUgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZlxuICAgICB0aGUgW0ludF9tYXRoLk1ha2VdIGZ1bmN0b3IsIGFuZCB3ZSBkaWRuJ3Qgd2FudCB0byBkZWdyYWRlIHRoZWlyIHBlcmZvcm1hbmNlLlxuXG4gICAgIFdlIHdvbid0IHByZS1lbXB0aXZlbHkgZG8gdGhlIHNhbWUgZm9yIG5ldyBmdW5jdGlvbnMsIHVubGVzcyBzb21lb25lIGNhcmVzLCBvbiBhIGNhc2VcbiAgICAgYnkgY2FzZSBmYXNoaW9uLiAgKilcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gcmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYW5kaW50XCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJW9yaW50XCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG4gIGxldCBsbm90ID0gbG5vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuICBleHRlcm5hbCAoIGxzciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlbHNyaW50XCJcbiAgZXh0ZXJuYWwgKCBhc3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWFzcmludFwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnRdIGFuZCBbSW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE9fRiA9IE8uRlxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBpbmNsdWRpbmcgZnVuY3RvclxuICAgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X3giLCJjc3RfYXJndW1lbnRfbXVzdF9iZV9zdHJpY3RseV8iLCJjYW1sX2RpdiIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9QcmludGYiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfU2NhbmYiLCJCYXNlX0Zsb2F0MCIsIkJhc2VfSW50MCIsIkJhc2VfSW50X2NvbnZlcnNpb25zIiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9Db21wYXJhYmxlIiwiQmFzZV9JbnRfc3RyaW5nX2NvbnZlcnNpb25zIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsIkJhc2VfSW50X21hdGgiLCJCYXNlX0Vycm9yIiwiQmFzZV9TaWduIiwiQmFzZV9Qb3Bjb3VudCIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJnbG9iYWxpemUiLCJoYXNoX2ZvbGRfdCIsImZ1bmMiLCJoYXNoIiwieCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsInRfc2V4cF9ncmFtbWFyIiwiaGFzaGFibGUiLCJjb21wYXJlIiwicyIsImV4biIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsInRvX2Zsb2F0Iiwib2ZfZmxvYXRfdW5jaGVja2VkIiwib2ZfZmxvYXQiLCJ6ZXJvIiwib25lIiwiY29tcGFyYXRvciIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJpbmNsdWRlIiwidG9fc3RyaW5nX2h1bSIsImNvbXBhcmVfbG9jYWwiLCJhIiwiYiIsIm5lZyIsInN5bWJvbCIsImkiLCJIZXgiLCJwcCIsImNzdF9tYXgiLCJjc3RfbWluIiwiY3N0X2NsYW1wX3JlcXVpcmVzX21pbl9tYXgiLCJpbnZhcmlhbnQiLCJwYXJhbSIsImJldHdlZW4iLCJ0IiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsIm1pbiIsIm1heCIsImNsYW1wX2V4biIsImNsYW1wIiwicHJlZCIsInN1Y2MiLCJ0b19pbnQiLCJvZl9pbnRfZXhuIiwibWF4X3ZhbHVlIiwibWluX3ZhbHVlIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50IiwiYWJzIiwicmVtIiwiaW5jciIsImRlY3IiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJzaGlmdF9sZWZ0IiwiYml0X25vdCIsImJpdF9vciIsImJpdF9hbmQiLCJiaXRfeG9yIiwicG93IiwiZSIsInJhaXNlX3MiLCJjc3RfSW50X2Zsb29yX2xvZzJfZ290X2ludmFsaWQiLCJjc3RfSW50X2NlaWxfbG9nMl9nb3RfaW52YWxpZF8iLCJub25fcG9zaXRpdmVfYXJndW1lbnQiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJjZWlsX2xvZzIiLCJzaWduIiwicG9wY291bnQiLCJlcXVhbF9sb2NhbCIsImVxdWFsIiwibGFuZCIsImxzciIsImNseiIsIkJpbmFyeSIsIkYiLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJ5IiwicnZhbCIsImxub3QiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiQmFzZV9JbnQiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FB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QUFBO0FBQUEsSUFBQUQsTUFBQTtBQUFBLElBQUE2RDtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JEL1BKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0MrUEk7QUFBQTtBQUFBLEVEL1BKIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjM2MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU3lzMCIsImJhY2tlbmRfdHlwZSIsImludGVyYWN0aXZlIiwib3NfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIndvcmRfc2l6ZV9pbl9iaXRzIiwiaW50X3NpemVfaW5fYml0cyIsImJpZ19lbmRpYW4iLCJtYXhfc3RyaW5nX2xlbmd0aCIsIm1heF9hcnJheV9sZW5ndGgiLCJydW50aW1lX3ZhcmlhbnQiLCJydW50aW1lX3BhcmFtZXRlcnMiLCJhcmd2IiwiZ2V0X2FyZ3YiLCJvY2FtbF92ZXJzaW9uIiwiZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJnZXRlbnZfZXhuIiwiZ2V0ZW52IiwiQmFzZV9TeXMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzY4OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9vYmpfbG9jYWwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxudHlwZSB0ID0gU3RkbGliLk9iai50XG50eXBlIHJhd19kYXRhID0gU3RkbGliLk9iai5yYXdfZGF0YVxuXG5leHRlcm5hbCBtYWdpYyA6IChfW0Bsb2NhbF9vcHRdKSAtPiAoX1tAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCByZXByIDogKF9bQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAoX1tAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzaXplIDogKHRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJW9ial9zaXplXCJcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBzaXplIHQgPSBzaXplIChTeXMub3BhcXVlX2lkZW50aXR5IHQpXG5cbmV4dGVybmFsIGlzX2ludCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5cbigqIFRoZSByZXN1bHQgZG9lc24ndCBuZWVkIHRvIGJlIG1hcmtlZCBsb2NhbCBiZWNhdXNlIHRoZSBkYXRhIGlzIGNvcGllZCBpbnRvIGEgZnJlc2hcbiAgIG5hdGl2ZWludCBibG9jayByZWdhcmRsZXNzLiAqKVxuZXh0ZXJuYWwgcmF3X2ZpZWxkIDogKHRbQGxvY2FsX29wdF0pIC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZFxuICA6ICAodFtAbG9jYWxfb3B0XSlcbiAgLT4gaW50XG4gIC0+IHJhd19kYXRhXG4gIC0+IHVuaXRcbiAgPSBcImNhbWxfb2JqX3NldF9yYXdfZmllbGRcIlxuXG5leHRlcm5hbCB0YWcgOiAodFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuXG4oKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG9uIHRoZSBsb2NhbCBzdGFjay4gUmV0dXJucyBbZmFsc2VdIGZvciBpbW1lZGlhdGVzLiAqKVxuZXh0ZXJuYWwgaXNfc3RhY2sgOiAodFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiY2FtbF9kdW1teV9vYmpfaXNfc3RhY2tcIlxuXG50eXBlIHN0YWNrX29yX2hlYXAgPVxuICB8IEltbWVkaWF0ZVxuICB8IFN0YWNrXG4gIHwgSGVhcFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIGNvbXBhcmVdXG5cbmxldCBzdGFja19vcl9oZWFwX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwib2JqX2xvY2FsLm1sLnN0YWNrX29yX2hlYXBcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImltbWVkaWF0ZVwiIHwgXCJJbW1lZGlhdGVcIikgLT4gSW1tZWRpYXRlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdGFja1wiIHwgXCJTdGFja1wiKSAtPiBTdGFja1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaGVhcFwiIHwgXCJIZWFwXCIpIC0+IEhlYXBcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW1tZWRpYXRlXCIgfCBcIkltbWVkaWF0ZVwiKSA6OiBfKSBhc1xuICAgICBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwic3RhY2tcIiB8IFwiU3RhY2tcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImhlYXBcIiB8IFwiSGVhcFwiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiBzdGFja19vcl9oZWFwKVxuOztcblxubGV0IHNleHBfb2Zfc3RhY2tfb3JfaGVhcCA9XG4gIChmdW5jdGlvblxuICAgfCBJbW1lZGlhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW1tZWRpYXRlXCJcbiAgIHwgU3RhY2sgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RhY2tcIlxuICAgfCBIZWFwIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkhlYXBcIlxuICAgIDogc3RhY2tfb3JfaGVhcCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgY29tcGFyZV9zdGFja19vcl9oZWFwID0gKFN0ZGxpYi5jb21wYXJlIDogc3RhY2tfb3JfaGVhcCAtPiBzdGFja19vcl9oZWFwIC0+IGludClcblxuW0BAQGVuZF1cblxubGV0IHN0YWNrX29yX2hlYXAgcmVwciA9XG4gIGlmIGlzX2ludCByZXByXG4gIHRoZW4gSW1tZWRpYXRlXG4gIGVsc2UgKFxuICAgIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICAgIHwgU3lzLk5hdGl2ZSAtPiBpZiBpc19zdGFjayByZXByIHRoZW4gU3RhY2sgZWxzZSBIZWFwXG4gICAgfCBTeXMuQnl0ZWNvZGUgLT4gSGVhcFxuICAgIHwgU3lzLk90aGVyIF8gLT4gSGVhcClcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9IZWFwIiwiY3N0X0ltbWVkaWF0ZSIsImNzdF9TdGFjayIsImNzdF9oZWFwIiwiY3N0X2ltbWVkaWF0ZSIsImNzdF9zdGFjayIsImdsb2JhbF9kYXRhIiwiZXJyb3Jfc291cmNlXzAwMyIsIkJhc2VfU3lzIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwic2l6ZSIsInQiLCJzdGFja19vcl9oZWFwX29mX3NleHAiLCJzZXhwXzAwNCIsIm1hdGNoIiwic2V4cF9vZl9zdGFja19vcl9oZWFwIiwicGFyYW0iLCJjb21wYXJlX3N0YWNrX29yX2hlYXAiLCJzdGFja19vcl9oZWFwIiwicmVwciIsIkJhc2VfT2JqX2xvY2FsIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsUUNzQ0c7QUFBQTtBQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0E1QjBCLG9CQUE0QjtBQUFBLFlBQUFDLHNCQUFBQztBQUFBQTtBQUFBQTtBQUFBQSxLQTRCdEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBRTRDO0FBQUE7QUFBQSxPQURRO0FBQUE7QUFBQSxNQUVWO0FBQUE7QUFBQSxTQUFBQyxRQUgxQztBQUFBO0FBQUEsTUFhRTtBQUFBLGdEQUNvRjtBQUFBLFNBQUFBLFVBZHRGO0FBQUE7QUFBQSxNQVdFO0FBQUEsZ0RBR29GO0FBQUEsYUFkdEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQU9FO0FBQUEsaURBT29GO0FBQUE7QUFBQSxNQVR0RTtBQUFBLGdEQVNzRTtBQUFBO0FBQUEsS0FMcEYseUVBS29GO0FBQUE7QUFBQSxJQUF0RSwwRUFBc0U7QUFBQTtBQUFBLFlBQUFDLHNCQUFBQztBQUFBQSxJQUt0RixzQkFDZSxpQkFDSixrQkFDRDtBQUFBO0FBQUEsR0FBeUI7QUFBQSxPQUFBQyx3QkF0Qm5DO0FBQUEsWUFBQUMsY0FBQUM7QUFBQUEsSUErQkQsNkJBQ0s7QUFBQSxRQUFBTCxRQUNBO0FBQUE7QUFBQSwwQkFFZ0I7QUFBQSxlQUVHO0FBQUE7QUFBQTtBQUFBLElBQUFNO0FBQUFBLE1BckN2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR0Q0giLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMzc4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9vYmpfYXJyYXkubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIG1haW50YWluIHRoZSBwcm9wZXJ0eSB0aGF0IGFsbCB2YWx1ZXMgb2YgdHlwZSBbdF0gZG8gbm90IGhhdmUgdGhlIHRhZ1xuICAgW2RvdWJsZV9hcnJheV90YWddLiAgU29tZSBmdW5jdGlvbnMgYmVsb3cgYXNzdW1lIHRoaXMgaW4gb3JkZXIgdG8gYXZvaWQgdGVzdGluZyB0aGVcbiAgIHRhZywgYW5kIHdpbGwgc2VnZmF1bHQgaWYgdGhpcyBwcm9wZXJ0eSBkb2Vzbid0IGhvbGQuICopXG50eXBlIHQgPSBTdGRsaWIuT2JqLnQgYXJyYXlcblxubGV0IGludmFyaWFudCB0ID1cbiAgYXNzZXJ0IChTdGRsaWIuT2JqLnRhZyAoU3RkbGliLk9iai5yZXByIHQpIDw+IFN0ZGxpYi5PYmouZG91YmxlX2FycmF5X3RhZylcbjs7XG5cbmxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggKCogd291bGQgY2hlY2sgZm9yIGZsb2F0IGFycmF5cyBpbiAzMiBiaXQsIGJ1dCB3aGF0ZXZlciAqKVxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBTZXhwLkF0b21cbiAgICAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgWyBcIjxPYmpfYXJyYXkudCBvZiBsZW5ndGggXCI7IEludC50b19zdHJpbmcgKGxlbmd0aCB0KTsgXCI+XCIgXSlcbjs7XG5cbmxldCB6ZXJvX29iaiA9IFN0ZGxpYi5PYmoucmVwciAoMCA6IGludClcblxuKCogV2UgY2FsbCBbQXJyYXkuY3JlYXRlXSB3aXRoIGEgdmFsdWUgdGhhdCBpcyBub3QgYSBmbG9hdCBzbyB0aGF0IHRoZSBhcnJheSBkb2Vzbid0IGdldFxuICAgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxubGV0IGNyZWF0ZV96ZXJvIH5sZW4gPSBBcnJheS5jcmVhdGUgfmxlbiB6ZXJvX29ialxubGV0IGVtcHR5ID0gW3x8XVxuXG50eXBlIG5vdF9hX2Zsb2F0ID1cbiAgfCBOb3RfYV9mbG9hdF8wXG4gIHwgTm90X2FfZmxvYXRfMSBvZiBpbnRcblxubGV0IF9ub3RfYV9mbG9hdF8wID0gTm90X2FfZmxvYXRfMFxubGV0IF9ub3RfYV9mbG9hdF8xID0gTm90X2FfZmxvYXRfMSA0MlxuXG5sZXQgZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAgSXQgaXMgTk9UIG9rIHRvIHVzZSBbaW50IGFycmF5XSBzaW5jZSAoaWZcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBpbmxpbmVkIGFuZCB0aGUgYXJyYXkgY29udGFpbnMgaW4taGVhcCBib3hlZCB2YWx1ZXMpIHdyb25nIHJlZ2lzdGVyXG4gICAgIHR5cGluZyBtYXkgcmVzdWx0LCBsZWFkaW5nIHRvIGEgZmFpbHVyZSB0byByZWdpc3RlciBuZWNlc3NhcnkgR0Mgcm9vdHMuICopXG4gIFN0ZGxpYi5PYmoucmVwclxuICAgICgqIFtTeXMub3BhcXVlX2lkZW50aXR5XSBpcyByZXF1aXJlZCBvbiB0aGUgYXJyYXkgYmVjYXVzZSB0aGlzIGNvZGUgYnJlYWtzIHRoZSB1c3VhbFxuICAgICAgIGFzc3VtcHRpb25zIGFib3V0IGFycmF5IGtpbmRzIHRoYXQgdGhlIEZsYW1iZGEgMiBvcHRpbWlzZXIgY2FuIHNlZS4gKilcbiAgICAoKFN5cy5vcGFxdWVfaWRlbnRpdHkgKFN0ZGxpYi5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KSkuKGkpXG4gICAgICA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxuICBTdGRsaWIuT2JqLnJlcHJcbiAgICAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgIChTeXMub3BhcXVlX2lkZW50aXR5IChPYmpfbG9jYWwubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KSlcbiAgICAgICBpXG4gICAgICA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIFNhbWUgY29tbWVudCBhcyBbdW5zYWZlX2dldF0uIFN5cy5vcGFxdWVfaWRlbnRpdHkgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb21cbiAgICAgcG90ZW50aWFsbHkgd3JvbmdseSBndWVzc2luZyB0aGUgdHlwZSBvZiB0aGUgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgZWxlbWVudCwgdGhhdFxuICAgICBpcyBwcmV2ZW50IHRoZSBpbXBsaWNhdGlvbjogKE9iai50YWcgb2JqID0gT2JqLmRvdWJsZV90YWcpID0+IChPYmoudGFnIHQgPVxuICAgICBPYmouZG91YmxlX2FycmF5X3RhZykgd2hpY2ggZmxhbWJkYSBoYXMgdHJpZWQgaW4gdGhlIHBhc3QgKGF0IGxlYXN0IHRoYXQncyBhc3N1bWluZ1xuICAgICB0aGUgY29tcGlsZXIgcmVzcGVjdHMgU3lzLm9wYXF1ZV9pZGVudGl0eSwgd2hpY2ggaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqX2xvY2FsLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpXG4gICAgaVxuICAgIChTdGRsaWIuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBzYW1lIGFzIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSBidXQgc2FmZSAqKVxuICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoU3RkbGliLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKS4oaSlcbiAgICA8LSAoU3RkbGliLk9iai5vYmogKFN5cy5vcGFxdWVfaWRlbnRpdHkgb2JqKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBpbnQgPVxuICAoKiBUaGlzIHNraXBzIFtjYW1sX21vZGlmeV0sIHdoaWNoIGlzIE9LIGlmIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZhbHVlcyBhcmUgaW50ZWdlcnMuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqX2xvY2FsLm1hZ2ljICh0IDogdCkgOiBpbnQgYXJyYXkpKVxuICAgIGlcbiAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSBpbnQpXG47O1xuXG4oKiBGb3IgW3NldF0gYW5kIFt1bnNhZmVfc2V0XSwgaWYgYSBwb2ludGVyIGlzIGludm9sdmVkLCB3ZSBmaXJzdCBkbyBhIHBoeXNpY2FsLWVxdWFsaXR5XG4gICB0ZXN0IHRvIHNlZSBpZiB0aGUgcG9pbnRlciBpcyBjaGFuZ2luZy4gIElmIG5vdCwgd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGUgW3NldF0sIHdoaWNoXG4gICBzYXZlcyBhIGNhbGwgdG8gW2NhbWxfbW9kaWZ5XS4gIFdlIHRoaW5rIHRoaXMgcGh5c2ljYWwtZXF1YWxpdHkgdGVzdCBpcyB3b3J0aCBpdFxuICAgYmVjYXVzZSBpdCBpcyB2ZXJ5IGNoZWFwIChib3RoIHZhbHVlcyBhcmUgYWxyZWFkeSBhdmFpbGFibGUgZnJvbSB0aGUgW2lzX2ludF0gdGVzdClcbiAgIGFuZCBiZWNhdXNlIFtjYW1sX21vZGlmeV0gaXMgZXhwZW5zaXZlLiAqKVxuXG5sZXQgc2V0IHQgaSBvYmogPVxuICAoKiBXZSB1c2UgW2dldF0gZmlyc3QgYnV0IHRoZW4gd2UgdXNlIFtBcnJheS51bnNhZmVfc2V0XSBzaW5jZSB3ZSBrbm93IHRoYXQgW2ldIGlzXG4gICAgIHZhbGlkLiAqKVxuICBsZXQgb2xkX29iaiA9IGdldCB0IGkgaW5cbiAgaWYgU3RkbGliLk9iai5pc19pbnQgb2xkX29iaiAmJiBTdGRsaWIuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoU3RkbGliLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0IHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmogJiYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgU3RkbGliLk9iai5pc19pbnQgb2xkX29iaiAmJiBTdGRsaWIuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoU3RkbGliLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBhID0gZ2V0IHQgaSBpblxuICBsZXQgYiA9IGdldCB0IGogaW5cbiAgdW5zYWZlX3NldCB0IGkgYjtcbiAgdW5zYWZlX3NldCB0IGogYVxuOztcblxubGV0IGNyZWF0ZSB+bGVuIHggPVxuICAoKiBJZiB3ZSBjYW4sIHVzZSBbQXJyYXkuY3JlYXRlXSBkaXJlY3RseS4gRXZlbiB0aG91Z2ggW2lzX2ludF0gY2hlY2sgaXMgc3Vic3VtZWQgYnlcbiAgICAgdGhlIHRhZyBjaGVjaywgY2hlY2tpbmcgaXQgaXMgbXVjaCBmYXN0ZXIsIHNpbmNlIGl0IGF2b2lkcyBhIEMgZnVuY3Rpb24gY2FsbC4gICopXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IHggfHwgU3RkbGliLk9iai50YWcgeCA8PiBTdGRsaWIuT2JqLmRvdWJsZV90YWdcbiAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiB4XG4gIGVsc2UgKFxuICAgICgqIE90aGVyd2lzZSB1c2UgW2NyZWF0ZV96ZXJvXSBhbmQgc2V0IHRoZSBjb250ZW50cyAqKVxuICAgIGxldCB0ID0gY3JlYXRlX3plcm8gfmxlbiBpblxuICAgIGxldCB4ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSB4IGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeFxuICAgIGRvbmU7XG4gICAgdClcbjs7XG5cbmxldCBzaW5nbGV0b24gb2JqID0gY3JlYXRlIH5sZW46MSBvYmpcblxuKCogUHJlLWNvbmRpdGlvbjogdC4oaSkgaXMgYW4gaW50ZWdlci4gKilcbmxldCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIG9iaiA9XG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChTdGRsaWIuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2VcbiAgICAoKiBbdC4oaSldIGlzIGFuIGludGVnZXIgYW5kIFtvYmpdIGlzIG5vdCwgc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaWYgdGhleSBhcmVcbiAgICAgICBlcXVhbC4gKilcbiAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHVuc2FmZV9zZXRfaW50IHQgaSBpbnQgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBpbnRcbiAgZWxzZSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgaW50KVxuOztcblxubGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIHQgaSA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgbm90IChTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKFN0ZGxpYi5PYmoucmVwciAwKVxuOztcblxuKCoqIFt1bnNhZmVfYmxpdF0gaXMgbGlrZSBbQXJyYXkuYmxpdF0sIGV4Y2VwdCBpdCB1c2VzIG91ciBvd24gZm9yLWxvb3AgdG8gYXZvaWRcbiAgICBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlLiAgSXRzIHBlcmZvcm1hbmNlIGlzIHN0aWxsIG5vdCBjb21wYXJhYmxlIHRvIGEgbWVtY3B5LiAqKVxubGV0IHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgKCogV2hlbiBbcGh5c19lcXVhbCBzcmMgZHN0XSwgd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIFtkc3RfcG9zIDwgc3JjX3Bvc10gYW5kIGhhdmUgdGhlXG4gICAgIGZvciBsb29wIGdvIGluIHRoZSByaWdodCBkaXJlY3Rpb24gc28gdGhhdCB3ZSBkb24ndCBvdmVyd3JpdGUgZGF0YSB0aGF0IHdlIHN0aWxsIG5lZWRcbiAgICAgdG8gcmVhZC4gIFdoZW4gW25vdCAocGh5c19lcXVhbCBzcmMgZHN0KV0sIGRvaW5nIHRoaXMgaXMgaGFybWxlc3MuICBGcm9tIGFcbiAgICAgbWVtb3J5LXBlcmZvcm1hbmNlIHBlcnNwZWN0aXZlLCBpdCBkb2Vzbid0IG1hdHRlciB3aGV0aGVyIG9uZSBsb29wcyB1cCBvciBkb3duLlxuICAgICBDb25zdGFudC1zdHJpZGUgYWNjZXNzLCBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzaG91bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgKGF0IGxlYXN0IG9uXG4gICAgIGFuIGludGVsIGk3KS4gIFNvLCB3ZSBkb24ndCBkbyBhIGNoZWNrIGZvciBbcGh5c19lcXVhbCBzcmMgZHN0XSBhbmQgYWx3YXlzIGxvb3AgdXAgaW5cbiAgICAgdGhhdCBjYXNlLiAqKVxuICBpZiBkc3RfcG9zIDwgc3JjX3Bvc1xuICB0aGVuXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkc3RfcG9zICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzcmNfcG9zICsgaSkpXG4gICAgZG9uZVxuICBlbHNlXG4gICAgZm9yIGkgPSBsZW4gLSAxIGRvd250byAwIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbjs7XG5cbmluY2x1ZGUgQmxpdC5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgY3JlYXRlID0gY3JlYXRlX3plcm9cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuZW5kKVxuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlX3plcm8gfmxlbjoobGVuZ3RoIHNyYykgaW5cbiAgYmxpdG8gfnNyYyB+ZHN0ICgpO1xuICBkc3Rcbjs7XG5cbmxldCBzdWIgPSBBcnJheS5zdWJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfb2JqX3RhZyIsImNhbWxfY2FsbDYiLCJmIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0ltcG9ydCIsIlN0ZGxpYl9PYmoiLCJCYXNlX0FycmF5MCIsIkJhc2VfSW50MCIsIkJhc2VfU3RyaW5nMCIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9CbGl0IiwiY3N0X09ial9hcnJheV90X29mX2xlbmd0aCIsImludmFyaWFudCIsInQiLCJsZW5ndGgiLCJzZXhwX29mX3QiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwibGVuIiwiZW1wdHkiLCJnZXQiLCJpIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwiaW50Iiwic2V0Iiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJzd2FwIiwiaiIsImEiLCJiIiwiY3JlYXRlIiwieCIsInNpbmdsZXRvbiIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfYmxpdCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiaW5jbHVkZSIsImJsaXQiLCJibGl0byIsInN1Ym8iLCJjb3B5Iiwic3ViIiwiQmFzZV9PYmpfYXJyYXkiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQTtB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VjtBQUFBLElBQWtCO0FBQUEsR0FDZjtBQUFBO0FBQUEsSUFBQU8sTURqTUw7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjM5NzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvdW5pZm9ybV9hcnJheS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG4oKiBXQVJOSU5HOlxuICAgV2UgdXNlIG5vbi1tZW1vcnktc2FmZSB0aGluZ3MgdGhyb3VnaG91dCB0aGUgW1RydXN0ZWRdIG1vZHVsZS5cbiAgIE1vc3Qgb2YgaXQgaXMgb25seSBzYWZlIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHR5cGUgc2lnbmF0dXJlIChlLmcuIGV4cG9zaW5nXG4gICBbdmFsIGNvcHkgOiAnYSB0IC0+ICdiIHRdIHdvdWxkIGJlIGEgYmlnIG1pc3Rha2UpLiAqKVxubW9kdWxlIFRydXN0ZWQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGVfb2JqX2FycmF5IDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzd2FwIDogXyB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX2dldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCB1bnNhZmVfZ2V0X2xvY2FsIDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHVuc2FmZV9zZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3RvX2FycmF5X2lucGxhY2VfX3Byb21pc2Vfbm90X2FfZmxvYXQgOiAnYSB0IC0+ICdhIGFycmF5XG4gIHZhbCBzZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBCbGl0LmJsaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIDogXyB0IC0+IGludCAtPiB1bml0XG4gIHZhbCBzdWIgOiAnYSB0IC0+IHBvczppbnQgLT4gbGVuOmludCAtPiAnYSB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gT2JqX2FycmF5LnRcblxuICBsZXQgZW1wdHkgPSBPYmpfYXJyYXkuZW1wdHlcbiAgbGV0IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZV9vYmpfYXJyYXkgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGUgfmxlbiB4ID0gT2JqX2FycmF5LmNyZWF0ZSB+bGVuIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHNpbmdsZXRvbiB4ID0gT2JqX2FycmF5LnNpbmdsZXRvbiAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCBzd2FwIHQgaSBqID0gT2JqX2FycmF5LnN3YXAgdCBpIGpcbiAgbGV0IGdldCBhcnIgaSA9IFN0ZGxpYi5PYmoub2JqIChPYmpfYXJyYXkuZ2V0IGFyciBpKVxuICBsZXQgc2V0IGFyciBpIHggPSBPYmpfYXJyYXkuc2V0IGFyciBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9nZXRfbG9jYWwgYXJyIGkgPSBTdGRsaWIuT2JqLm9iaiAoT2JqX2FycmF5LnVuc2FmZV9nZXQgYXJyIGkpXG4gIGxldCB1bnNhZmVfZ2V0IGFyciBpID0gdW5zYWZlX2dldF9sb2NhbCBhcnIgaVxuICBsZXQgdW5zYWZlX3NldCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXQgYXJyIGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX3NldF9pbnQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0X2ludCBhcnIgaSB4XG5cbiAgbGV0IHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeFxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgKCogW3RdIGlzIGp1c3QgYW4gYXJyYXkgdW5kZXIgdGhlIGhvb2QsIGl0IGp1c3QgaGFzIHNwZWNpYWwgY29uc2lkZXJhdGlvbnMgYWJvdXQgW3RdIG5vdFxuICAgICBiZWluZyBhIGZsb2F0LiAqKVxuICBsZXQgdW5zYWZlX3RvX2FycmF5X2lucGxhY2VfX3Byb21pc2Vfbm90X2FfZmxvYXQgYXJyID0gU3RkbGliLk9iai5tYWdpYyBhcnJcbiAgbGV0IGxlbmd0aCA9IE9ial9hcnJheS5sZW5ndGhcbiAgbGV0IHVuc2FmZV9ibGl0ID0gT2JqX2FycmF5LnVuc2FmZV9ibGl0XG4gIGxldCBjb3B5ID0gT2JqX2FycmF5LmNvcHlcblxuICBsZXQgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPSBPYmpfYXJyYXkuc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyID0gT2JqX2FycmF5LnVuc2FmZV9jbGVhcl9pZl9wb2ludGVyXG4gIGxldCBzdWIgPSBPYmpfYXJyYXkuc3ViXG5lbmRcblxuaW5jbHVkZSBUcnVzdGVkXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIGFzc2VydCAoU3RkbGliLk9iai50YWcgKFN0ZGxpYi5PYmoucmVwciB0KSA8PiBTdGRsaWIuT2JqLmRvdWJsZV9hcnJheV90YWcpXG47O1xuXG5sZXQgaW5pdCBsIH5mID1cbiAgaWYgbCA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlVuaWZvcm1fYXJyYXkuaW5pdFwiXG4gIGVsc2UgKFxuICAgIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjpsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgZG9uZTtcbiAgICByZXMpXG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyID0gaW5pdCB+ZjooQXJyYXkudW5zYWZlX2dldCBhcnIpIChBcnJheS5sZW5ndGggYXJyKSBbQG5vbnRhaWxdXG5sZXQgbWFwIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSkgW0Bub250YWlsXVxubGV0IG1hcGkgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgaSAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpIFtAbm9udGFpbF1cblxubGV0IGl0ZXIgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZVxuOztcblxubGV0IGZvbGRpIGEgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGFjYyA6PSBmIGkgIWFjYyAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IHRvX2xpc3QgdCA9IExpc3QuaW5pdCB+ZjooZ2V0IHQpIChsZW5ndGggdClcblxubGV0IG9mX2xpc3QgbCA9XG4gIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIHggLT4gc2V0IHJlcyBpIHgpO1xuICByZXNcbjs7XG5cbmxldCBvZl9saXN0X3JldiBsID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgeCAtPiBzZXQgcmVzIChsZW4gLSBpIC0gMSkgeCk7XG4gIHJlc1xuOztcblxuKCogSXQgaXMgbm90IHNhZmUgZm9yIFt0b19hcnJheV0gdG8gYmUgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBjb2RlIHRoYXRcbiAgIHJlbGllcyBvbiBbZmxvYXQgYXJyYXldcyBiZWluZyB1bmJveGVkLCBmb3IgZXhhbXBsZSBpbiBbYmluX3dyaXRlX2FycmF5XS4gKilcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICFpICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIChsZW5ndGggLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICFpICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByID0gcmVmIGVtcHR5IGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgZW1wdHlcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSkgW0Bub250YWlsXVxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5cbmxldCBmb2xkMl9leG4gdDEgdDIgfmluaXQgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQxIGluXG4gIGlmIGxlbmd0aCB0MiA8PiBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZvbGQyX2V4blwiO1xuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBhY2MgOj0gZiAhYWNjICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpXG4gIGRvbmU7XG4gICFhY2Ncbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggdDEgaW5cbiAgaWYgbGVuZ3RoIHQyIDw+IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMl9leG5cIjtcbiAgaW5pdCBsZW4gfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBjb25jYXQgdHMgPVxuICBsZXQgdG90YWxfbGVuID0gTGlzdC5zdW0gKG1vZHVsZSBJbnQpIHRzIH5mOihmdW4gdCAtPiBsZW5ndGggdCkgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOnRvdGFsX2xlbiBpblxuICBpZ25vcmVcbiAgICAoTGlzdC5mb2xkIHRzIH5pbml0OjAgfmY6KGZ1biBzb19mYXIgdCAtPlxuICAgICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgICBzZXQgcmVzIChzb19mYXIgKyBpKSAoZ2V0IHQgaSlcbiAgICAgICBkb25lO1xuICAgICAgIHNvX2ZhciArIGxlbilcbiAgICAgIDogaW50KTtcbiAgcmVzXG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9IHRvX2xpc3QgdCB8PiBMaXN0Lm1hcGkgfmYgfD4gY29uY2F0XG5sZXQgY29uY2F0X21hcCB0IH5mID0gdG9fbGlzdCB0IHw+IExpc3QubWFwIH5mIHw+IGNvbmNhdFxuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgbGV0IGxlZnQsIHJpZ2h0ID0gcmVmIGVtcHR5LCByZWYgZW1wdHkgaW5cbiAgbGV0IGxlZnRfaWR4LCByaWdodF9pZHggPSByZWYgMCwgcmVmIDAgaW5cbiAgbGV0IGFwcGVuZCBkYXRhIGlkeCB2YWx1ZSA9XG4gICAgaWYgIWlkeCA9IDAgdGhlbiBkYXRhIDo9IGNyZWF0ZSB+bGVuOihsZW5ndGggdCkgdmFsdWU7XG4gICAgdW5zYWZlX3NldCAhZGF0YSAhaWR4IHZhbHVlO1xuICAgIGluY3IgaWR4XG4gIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBtYXRjaCAoZiAodW5zYWZlX2dldCB0IGkpIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgYSAtPiBhcHBlbmQgbGVmdCBsZWZ0X2lkeCBhXG4gICAgfCBTZWNvbmQgYSAtPiBhcHBlbmQgcmlnaHQgcmlnaHRfaWR4IGFcbiAgZG9uZTtcbiAgbGV0IHRyaW0gZGF0YSBpZHggPVxuICAgIGlmICFpZHggPSBsZW5ndGggdFxuICAgIHRoZW4gIWRhdGFcbiAgICBlbHNlIGlmICFpZHggPiAwXG4gICAgdGhlbiBzdWIgfnBvczowIH5sZW46IWlkeCAhZGF0YVxuICAgIGVsc2UgZW1wdHlcbiAgaW5cbiAgdHJpbSBsZWZ0IGxlZnRfaWR4LCB0cmltIHJpZ2h0IHJpZ2h0X2lkeFxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiAhaSB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgKG5vdCAhZm91bmQpICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGYgIWkgdmFsdWVcbiAgICAgIHRoZW4gKFxuICAgICAgICB2YWx1ZV9mb3VuZCA6PSB2YWx1ZTtcbiAgICAgICAgZm91bmQgOj0gdHJ1ZSlcbiAgICAgIGVsc2UgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiAhZm91bmQgdGhlbiBTb21lICghaSwgIXZhbHVlX2ZvdW5kKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID0gT3B0aW9uLm1hcCAoZmluZGkgdCB+ZjooZnVuIF9pIHggLT4gZiB4KSkgfmY6KGZ1biAoX2ksIHgpIC0+IHgpXG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBmIGkgPVxuICAgIGlmIGkgPj0gbGVuXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgdCBpIGluXG4gICAgICBtYXRjaCBmIGkgeCB3aXRoXG4gICAgICB8IGZhbHNlIC0+IGxvb3AgZiAoaSArIDEpXG4gICAgICB8IHRydWUgLT4gU29tZSAoaSwgeCkpXG4gIGluXG4gIGxvb3AgZiAwXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAoZ3JhbW1hciA6IGVsdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBlbHQgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKEFycmF5LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5pbmNsdWRlXG4gIFNleHBhYmxlLk9mX3NleHBhYmxlMVxuICAgIChBcnJheSlcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19hcnJheVxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2ZfYXJyYXlcbiAgICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIGVtcHR5XG4gICAgZWxzZSAoXG4gICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICBjcmVhdGUgfmxlbiAoZ2V0IHQgMCkpXG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbmVuZClcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHBweF9jb21wYXJlIFtjb21wYXJlX2FycmF5XSBidXQgdXNlcyBvdXIgW3Vuc2FmZV9nZXRdIGFuZCBbbGVuZ3RoXS4gKilcbmxldCBjb21wYXJlX19sb2NhbCBjb21wYXJlX2VsdCBhIGIgPVxuICBpZiBwaHlzX2VxdWFsIGEgYlxuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbGV0IGxlbl9hID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGVuX2IgPSBsZW5ndGggYiBpblxuICAgIGxldCByZXQgPSBjb21wYXJlIGxlbl9hIGxlbl9iIGluXG4gICAgaWYgcmV0IDw+IDBcbiAgICB0aGVuIHJldFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgdGhlbiAwXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsID0gdW5zYWZlX2dldF9sb2NhbCBhIGlcbiAgICAgICAgICBhbmQgciA9IHVuc2FmZV9nZXRfbG9jYWwgYiBpIGluXG4gICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgbG9vcCAoaSArIDEpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgMCBbQG5vbnRhaWxdKSlcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYlxuXG5tb2R1bGUgU29ydCA9IEFycmF5LlByaXZhdGUuU29ydGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0XG5lbmQpXG5cbmxldCBzb3J0ID0gU29ydC5zb3J0XG5cbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGUuTWFrZTEgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRcbmVuZClcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3NyY191bmlmb3JtX2FycmF5X21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0NvbnRhaW5lciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9BcnJheSIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIkJhc2VfT3B0aW9uIiwiQmFzZV9MaXN0IiwiQmFzZV9JbnQiLCJTdGRsaWJfT2JqIiwiQmFzZV9PYmpfYXJyYXkiLCJCYXNlX1NleHBhYmxlIiwiQmFzZV9CbGl0IiwiQmFzZV9CaW5hcnlfc2VhcmNoYWJsZSIsImVtcHR5IiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwibGVuIiwiY3JlYXRlX29ial9hcnJheSIsImNyZWF0ZSIsIngiLCJzaW5nbGV0b24iLCJzd2FwIiwidCIsImkiLCJqIiwiZ2V0IiwiYXJyIiwic2V0IiwidW5zYWZlX2dldF9sb2NhbCIsInVuc2FmZV9nZXQiLCJ1bnNhZmVfc2V0IiwidW5zYWZlX3NldF9pbnQiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4iLCJ1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV8iLCJ1bnNhZmVfdG9fYXJyYXlfaW5wbGFjZV9wcm9taXMiLCJsZW5ndGgiLCJ1bnNhZmVfYmxpdCIsImNvcHkiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJ1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkiLCJzZXRfd2l0aF9jYW1sX21vZGlmeSIsInVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIiwic3ViIiwiY3N0X1VuaWZvcm1fYXJyYXlfaW5pdCIsImNzdF9BcnJheV9mb2xkMl9leG4iLCJjc3RfQXJyYXlfbWFwMl9leG4iLCJkdW1teSIsImludmFyaWFudCIsImluaXQiLCJsIiwicmVzIiwib2ZfYXJyYXkiLCJtYXAiLCJtYXBpIiwiaXRlciIsIml0ZXJpIiwiZm9sZGkiLCJhY2MiLCJmb2xkIiwiciIsInRvX2xpc3QiLCJvZl9saXN0Iiwib2ZfbGlzdF9yZXYiLCJ0b19hcnJheSIsImV4aXN0cyIsInJlc3VsdCIsImV4aXN0c2kiLCJmb3JfYWxsIiwiZm9yX2FsbGkiLCJmaWx0ZXJfbWFwaSIsImsiLCJtYXRjaCIsImEiLCJmaWx0ZXJpIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImZvbGQyX2V4biIsIm1hcDJfZXhuIiwiY29uY2F0IiwidHMiLCJ0b3RhbF9sZW4iLCJzb19mYXIiLCJjb25jYXRfbWFwaSIsImNvbmNhdF9tYXAiLCJwYXJ0aXRpb25fbWFwIiwicmlnaHQiLCJsZWZ0IiwicmlnaHRfaWR4IiwibGVmdF9pZHgiLCJhcHBlbmQiLCJkYXRhIiwiaWR4IiwidmFsdWUiLCJ0cmltIiwiZmluZF9tYXAiLCJ2YWx1ZV9mb3VuZCIsImZpbmRfbWFwaSIsImZpbmQiLCJwYXJhbSIsImZvdW5kIiwiZmluZGkiLCJ0X3NleHBfZ3JhbW1hciIsImdyYW1tYXIiLCJpbmNsdWRlIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwiY3JlYXRlX2xpa2UiLCJibGl0IiwiYmxpdG8iLCJzdWJvIiwibWluX2VsdCIsImNvbXBhcmUiLCJtYXhfZWx0IiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmVfZWx0IiwiYiIsImxlbl9hIiwibGVuX2IiLCJyZXQiLCJTb3J0Iiwic29ydCIsImJpbmFyeV9zZWFyY2giLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsIkJhc2VfVW5pZm9ybV9hcnJheSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyw0QkFBQUM7QUFBQUEsSUNvQ3lDLHdDQUEwQjtBQUFBO0FBQUEsWUFBQUMsaUJBQUFELEtBQ3JDLHdDQUEwQjtBQUFBLFlBQUFFLE9BQUFGLEtBQUFHLEdBQ2xDLDJDQUF5QztBQUFBLFlBQUFDLFVBQUFELEdBQzNDLHVDQUF1QztBQUFBLFlBQUFFLEtBQUFDLEdBQUFDLEdBQUFDLEdBQ3hDLDZDQUFvQjtBQUFBLFlBQUFDLElBQUFD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QUFBQTtBQUFBLEtBUkUsZ0JBQ0s7QUFBQTtBQUFBLE1BQUEwQixJQUVLO0FBQUEsTUFBQVUsSUFDQTtBQUFBLE1BQUFULE1BQ0U7QUFBQSxLQUNWLGNBQWlCO0FBQUEsU0FBQTNCLE1BQWM7QUFBQSxLQUFPO0FBQUE7QUFBQSxHQUV2QjtBQUFBLFlBQUF3RixRQUFBRyxhQUFBMUMsR0FBQTJDO0FBQUFBLElBR0ssdUNBQThCO0FBQUE7QUFBQTtBQUFBLElBQUFJLE9EM1g1RDtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBakIsWUFBQTtBQUFBLElBQUFrQixnQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9VY2hhcl9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsa0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS91Y2hhci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuaW5jbHVkZSBVY2hhcl9pbnRmXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5cbmluY2x1ZGUgVWNoYXIwXG5cbmxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhclwiXG5sZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IEhhc2guZm9sZF9pbnQgc3RhdGUgKHRvX2ludCB0KVxubGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcblxuKCogTm90IGZvciBleHBvcnQuIFN0cmluZyBmb3JtYXRzIGV4cG9ydGVkIHZpYSBbVXRmKl0gbW9kdWxlcyBiZWxvdy4gKilcbmxldCB0b19zdHJpbmdfaW50ZXJuYWwgdCA9IFByaW50Zi5zcHJpbnRmIFwiVSslMDRYXCIgKHRvX2ludCB0KVxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmdfaW50ZXJuYWwgdClcblxubGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgU2V4cC5MaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG4gIHwgU2V4cC5BdG9tIHMgLT5cbiAgICAodHJ5IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIlUrJVhcIiAoZnVuIGkgLT4gVWNoYXIwLm9mX2ludCBpKSB3aXRoXG4gICAgIHwgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG9mIHRoZSBmb3JtIFUrWFhYWCBuZWVkZWRcIiBzZXhwKVxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2Ugc3RyaW5nX3NleHBfZ3JhbW1hclxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gbW9kdWxlX25hbWVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ19pbnRlcm5hbFxuZW5kKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgaW50X2lzX3NjYWxhciA9IGlzX3ZhbGlkXG5cbmxldCBzdWNjX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5zdWNjIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnN1Y2NfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHN1Y2MgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAuc3VjYyBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBwcmVkX2V4biBjID1cbiAgdHJ5IFVjaGFyMC5wcmVkIGMgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+IGZhaWx3aXRoZiBcIlVjaGFyLnByZWRfZXhuOiAlc1wiIG1zZyAoKVxuOztcblxubGV0IHByZWQgYyA9XG4gIHRyeSBTb21lIChVY2hhcjAucHJlZCBjKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcbjs7XG5cbmxldCBvZl9zY2FsYXIgaSA9IGlmIGludF9pc19zY2FsYXIgaSB0aGVuIFNvbWUgKHVuc2FmZV9vZl9pbnQgaSkgZWxzZSBOb25lXG5cbmxldCBvZl9zY2FsYXJfZXhuIGkgPVxuICBpZiBpbnRfaXNfc2NhbGFyIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci5vZl9pbnRfZXhuIGdvdCBhIGludmFsaWQgVW5pY29kZSBzY2FsYXIgdmFsdWU6ICUwNFhcIiBpICgpXG47O1xuXG5sZXQgdG9fc2NhbGFyIHQgPSBVY2hhcjAudG9faW50IHRcbmxldCB0b19jaGFyIGMgPSBpZiBpc19jaGFyIGMgdGhlbiBTb21lICh1bnNhZmVfdG9fY2hhciBjKSBlbHNlIE5vbmVcblxubGV0IHRvX2NoYXJfZXhuIGMgPVxuICBpZiBpc19jaGFyIGNcbiAgdGhlbiB1bnNhZmVfdG9fY2hhciBjXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIudG9fY2hhcl9leG4gZ290IGEgbm9uIGxhdGluLTEgY2hhcmFjdGVyOiBVKyUwNFhcIiAodG9faW50IGMpICgpXG47O1xuXG5tb2R1bGUgRGVjb2RlX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBVY2hhcjAudXRmX2RlY29kZVxuXG4gIGxldCBjb21wYXJlIDogdCAtPiB0IC0+IGludCA9IFBvbHkuY29tcGFyZVxuICBsZXQgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFBvbHkuZXF1YWxcblxuICBsZXQgaGFzaF9mb2xkX3QgOiBIYXNoLnN0YXRlIC0+IHQgLT4gSGFzaC5zdGF0ZSA9XG4gICAgZnVuIHN0YXRlIHQgLT4gaGFzaF9mb2xkX2ludCBzdGF0ZSAoSGFzaGFibGUuaGFzaCB0KVxuICA7O1xuXG4gIGxldCBoYXNoIDogdCAtPiBpbnQgPSBIYXNoYWJsZS5oYXNoXG4gIGxldCBpc192YWxpZCA9IFVjaGFyMC51dGZfZGVjb2RlX2lzX3ZhbGlkXG4gIGxldCBieXRlc19jb25zdW1lZCA9IFVjaGFyMC51dGZfZGVjb2RlX2xlbmd0aFxuICBsZXQgdWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciA9IFVjaGFyMC51dGZfZGVjb2RlX3VjaGFyXG4gIGxldCBzZXhwX29mX3QgdCA9IHNleHBfb2ZfdCAodWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciB0KVxuXG4gIGxldCB1Y2hhciB0ID1cbiAgICBtYXRjaCBpc192YWxpZCB0IHdpdGhcbiAgICB8IHRydWUgLT4gU29tZSAodWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciB0KVxuICAgIHwgZmFsc2UgLT4gTm9uZVxuICA7O1xuXG4gIGxldFtAemVyb19hbGxvY10gdWNoYXJfZXhuIHQgPVxuICAgIG1hdGNoIGlzX3ZhbGlkIHQgd2l0aFxuICAgIHwgdHJ1ZSAtPiB1Y2hhcl9vcl9yZXBsYWNlbWVudF9jaGFyIHRcbiAgICB8IGZhbHNlIC0+XG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChBdG9tIFwiVWNoYXIuRGVjb2RlX3Jlc3VsdC51Y2hhcl9leG4gd2FzIGNhbGxlZCBvbiBhbiBpbnZhbGlkIGRlY29kZSByZXN1bHRcIilcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV91dGYgKEZvcm1hdCA6IHNpZ1xuICB2YWwgY29kZWNfbmFtZSA6IHN0cmluZ1xuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIGJ5dGVfbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGdldF9kZWNvZGVfcmVzdWx0IDogc3RyaW5nIC0+IGJ5dGVfcG9zOmludCAtPiBEZWNvZGVfcmVzdWx0LnRcbiAgdmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiB0IC0+IGludFxuZW5kKSA6IFV0ZiA9IHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IEZvcm1hdC5jb2RlY19uYW1lXG4gIGxldCBieXRlX2xlbmd0aCA9IEZvcm1hdC5ieXRlX2xlbmd0aFxuXG4gIGxldCB0b19zdHJpbmcgdCA9XG4gICAgbGV0IGxlbiA9IGJ5dGVfbGVuZ3RoIHQgaW5cbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHBvcyA9IEZvcm1hdC5zZXQgYnl0ZXMgMCB0IGluXG4gICAgYXNzZXJ0IChJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW4pO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6Ynl0ZXNcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nX21lc3NhZ2UgPVxuICAgIEZvcm1hdC5tb2R1bGVfbmFtZSBeIFwiLm9mX3N0cmluZzogZXhwZWN0ZWQgYSBzaW5nbGUgVW5pY29kZSBjaGFyYWN0ZXJcIlxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2Vfb2Zfc3RyaW5nIHN0cmluZyA9XG4gICAgRXJyb3IucmFpc2VfcyAoU2V4cC5tZXNzYWdlIG9mX3N0cmluZ19tZXNzYWdlIFsgXCJzdHJpbmdcIiwgQXRvbSBzdHJpbmcgXSlcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHN0cmluZyA9XG4gICAgbGV0IGRlY29kZSA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdCBzdHJpbmcgfmJ5dGVfcG9zOjAgaW5cbiAgICBsZXQgc3RyaW5nX2xlbiA9IFN0cmluZy5sZW5ndGggc3RyaW5nIGluXG4gICAgbGV0IGRlY29kZV9sZW4gPSBEZWNvZGVfcmVzdWx0LmJ5dGVzX2NvbnN1bWVkIGRlY29kZSBpblxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgc3RyaW5nX2xlbiBkZWNvZGVfbGVuXG4gICAgICAgJiYgRGVjb2RlX3Jlc3VsdC5pc192YWxpZCBkZWNvZGVcbiAgICB0aGVuIERlY29kZV9yZXN1bHQudWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciBkZWNvZGVcbiAgICBlbHNlIHJhaXNlX29mX3N0cmluZyBzdHJpbmdcbiAgOztcbmVuZFxuXG5tb2R1bGUgVXRmOCA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi04XCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyLlV0ZjhcIlxuICBsZXQgYnl0ZV9sZW5ndGggPSB1dGZfOF9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBTdHJpbmcuZ2V0X3V0Zl84X3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzhcbmVuZClcblxubW9kdWxlIFV0ZjE2bGUgPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMTZMRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhci5VdGYxNmxlXCJcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gdXRmXzE2X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IFN0cmluZy5nZXRfdXRmXzE2bGVfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfMTZsZVxuZW5kKVxuXG5tb2R1bGUgVXRmMTZiZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0xNkJFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyLlV0ZjE2YmVcIlxuICBsZXQgYnl0ZV9sZW5ndGggPSB1dGZfMTZfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gU3RyaW5nLmdldF91dGZfMTZiZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8xNmJlXG5lbmQpXG5cbm1vZHVsZSBVdGYzMmxlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTMyTEVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXIuVXRmMzJsZVwiXG4gIGxldCBieXRlX2xlbmd0aCBfID0gNFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBTdHJpbmcuZ2V0X3V0Zl8zMmxlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMybGVcbmVuZClcblxubW9kdWxlIFV0ZjMyYmUgPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMzJCRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhci5VdGYzMmJlXCJcbiAgbGV0IGJ5dGVfbGVuZ3RoIF8gPSA0XG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IFN0cmluZy5nZXRfdXRmXzMyYmVfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfMzJiZVxuZW5kKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9VIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiY29kZWNfbmFtZSIsIkJhc2VfU2V4cCIsIkJhc2VfRXJyb3IiLCJCYXNlX0J5dGVzMCIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0hhc2hhYmxlIiwiQmFzZV9VY2hhcjAiLCJTdGRsaWIiLCJTdGRsaWJfU2NhbmYiLCJCYXNlX1ByaW50ZiIsIkJhc2VfSGFzaCIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1N0cmluZzAiLCJmYWlsd2l0aGYiLCJpc192YWxpZCIsImlzX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsInVuc2FmZV9vZl9pbnQiLCJ0b19pbnQiLCJvZl9jaGFyIiwiY29tcGFyZSIsIm1pbl92YWx1ZSIsIm1heF92YWx1ZSIsImJ5dGVfb3JkZXJfbWFyayIsInJlcGxhY2VtZW50X2NoYXIiLCJ1dGZfOF9ieXRlX2xlbmd0aCIsInV0Zl8xNl9ieXRlX2xlbmd0aCIsImNzdF9VY2hhcl90X29mX3NleHBfYXRvbV9vZl90aCIsImNzdF9VY2hhcl90X29mX3NleHBfYXRvbV9uZWVkZSIsImhhc2hfZm9sZF90Iiwic3RhdGUiLCJ0IiwiaGFzaCIsInRvX3N0cmluZ19pbnRlcm5hbCIsInNleHBfb2ZfdCIsInRfb2Zfc2V4cCIsInNleHAiLCJzIiwiaSIsImV4biIsInRfc2V4cF9ncmFtbWFyIiwiaW5jbHVkZSIsInBwIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsImludmFyaWFudCIsInBhcmFtIiwic3VjY19leG4iLCJjIiwidGFnIiwibXNnIiwic3VjYyIsInByZWRfZXhuIiwicHJlZCIsIm9mX3NjYWxhciIsIm9mX3NjYWxhcl9leG4iLCJ0b19zY2FsYXIiLCJ0b19jaGFyIiwidG9fY2hhcl9leG4iLCJlcXVhbCIsImJ5dGVzX2NvbnN1bWVkIiwidWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciIsImNzdF9vZl9zdHJpbmdfZXhwZWN0ZWRfYV9zaW5nbCIsImNzdF9zdHJpbmciLCJ1Y2hhciIsInVjaGFyX2V4biIsIk1ha2VfdXRmIiwiRm9ybWF0IiwiYnl0ZV9sZW5ndGgiLCJ0b19zdHJpbmciLCJsZW4iLCJieXRlcyIsInBvcyIsIm9mX3N0cmluZ19tZXNzYWdlIiwib2Zfc3RyaW5nIiwic3RyaW5nIiwiZGVjb2RlIiwic3RyaW5nX2xlbiIsImRlY29kZV9sZW4iLCJnZXRfZGVjb2RlX3Jlc3VsdCIsInNldCIsIlV0ZjgiLCJVdGYxNmxlIiwiVXRmMTZiZSIsIlV0ZjMybGUiLCJVdGYzMmJlIiwic3ltYm9sIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbF9sb2NhbCIsIm1heCIsIm1pbiIsIkJhc2VfVWNoYXIiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFELGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFELGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFELGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFELGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFELGdCQUFBO0FBQUEsSUFBQUUsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFB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O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQTlDLFlBQUE7QUFBQSxJQUFBK0MsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBdEUsWUFBQTtBQUFBLElBQUF5QyxVQUFBO0FBQUEsSUFBQThCLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxQmxEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQ5NDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvdHlwZV9lcXVhbF9pbnRmLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqIFRoZSBwdXJwb3NlIG9mIFtUeXBlX2VxdWFsXSBpcyB0byByZXByZXNlbnQgdHlwZSBlcXVhbGl0aWVzIHRoYXQgdGhlIHR5cGUgY2hlY2tlclxuICAgIG90aGVyd2lzZSB3b3VsZCBub3Qga25vdywgcGVyaGFwcyBiZWNhdXNlIHRoZSB0eXBlIGVxdWFsaXR5IGRlcGVuZHMgb24gZHluYW1pYyBkYXRhLFxuICAgIG9yIHBlcmhhcHMgYmVjYXVzZSB0aGUgdHlwZSBzeXN0ZW0gaXNuJ3QgcG93ZXJmdWwgZW5vdWdoLlxuXG4gICAgQSB2YWx1ZSBvZiB0eXBlIFsoYSwgYikgVHlwZV9lcXVhbC50XSByZXByZXNlbnRzIHRoYXQgdHlwZXMgW2FdIGFuZCBbYl0gYXJlIGVxdWFsLlxuICAgIE9uZSBjYW4gdGhpbmsgb2Ygc3VjaCBhIHZhbHVlIGFzIGEgcHJvb2Ygb2YgdHlwZSBlcXVhbGl0eS4gIFRoZSBbVHlwZV9lcXVhbF0gbW9kdWxlXG4gICAgaGFzIG9wZXJhdGlvbnMgZm9yIGNvbnN0cnVjdGluZyBhbmQgbWFuaXB1bGF0aW5nIHN1Y2ggcHJvb2ZzLiAgRm9yIGV4YW1wbGUsIHRoZVxuICAgIGZ1bmN0aW9ucyBbcmVmbF0sIFtzeW1dLCBhbmQgW3RyYW5zXSBleHByZXNzIHRoZSB1c3VhbCBwcm9wZXJ0aWVzIG9mIHJlZmxleGl2aXR5LFxuICAgIHN5bW1ldHJ5LCBhbmQgdHJhbnNpdGl2aXR5IG9mIGVxdWFsaXR5LlxuXG4gICAgSWYgb25lIGhhcyBhIHZhbHVlIFt0IDogKGEsIGIpIFR5cGVfZXF1YWwudF0gdGhhdCBwcm92ZXMgdHlwZXMgW2FdIGFuZCBbYl0gYXJlIGVxdWFsLFxuICAgIHRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgW3RdIHRvIHNhZmVseSBjb252ZXJ0IGEgdmFsdWUgb2YgdHlwZSBbYV0gdG8gYSB2YWx1ZSBvZiB0eXBlXG4gICAgW2JdOiBbVHlwZV9lcXVhbC5jb252XSBvciBwYXR0ZXJuIG1hdGNoaW5nIG9uIFtUeXBlX2VxdWFsLlRdOlxuXG4gICAge1tcbiAgICAgIGxldCBmICh0eXBlIGEpICh0eXBlIGIpICh0IDogKGEsIGIpIFR5cGVfZXF1YWwudCkgKGEgOiBhKSA6IGIgPVxuICAgICAgICBUeXBlX2VxdWFsLmNvbnYgdCBhXG5cbiAgICAgIGxldCBmICh0eXBlIGEpICh0eXBlIGIpICh0IDogKGEsIGIpIFR5cGVfZXF1YWwudCkgKGEgOiBhKSA6IGIgPVxuICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gdCBpbiBhXG4gICAgXX1cblxuICAgIEF0IHJ1bnRpbWUsIGNvbnZlcnNpb24gYnkgZWl0aGVyIG1lYW5zIGlzIGp1c3QgdGhlIGlkZW50aXR5IC0tIG5vdGhpbmcgaXMgY2hhbmdpbmdcbiAgICBhYm91dCB0aGUgdmFsdWUuICBDb25zaXN0ZW50IHdpdGggdGhpcywgYSB2YWx1ZSBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdIGlzIGFsd2F5cyBqdXN0XG4gICAgYSBjb25zdHJ1Y3RvciBbVHlwZV9lcXVhbC5UXTsgdGhlIHZhbHVlIGhhcyBubyBpbnRlcmVzdGluZyBzZW1hbnRpYyBjb250ZW50LlxuICAgIFtUeXBlX2VxdWFsXSBnZXRzIGl0cyBwb3dlciBmcm9tIHRoZSBhYmlsaXR5IHRvLCBpbiBhIHR5cGUtc2FmZSB3YXksIHByb3ZlIHRvIHRoZSB0eXBlXG4gICAgY2hlY2tlciB0aGF0IHR3byB0eXBlcyBhcmUgZXF1YWwuICBUaGUgW1R5cGVfZXF1YWwudF0gdmFsdWUgdGhhdCBpcyBwYXNzZWQgaXNcbiAgICBuZWNlc3NhcnkgZm9yIHRoZSB0eXBlLWNoZWNrZXIncyBydWxlcyB0byBiZSBjb3JyZWN0LCBidXQgdGhlIGNvbXBpbGVyIGNvdWxkLCBpblxuICAgIHByaW5jaXBsZSwgbm90IHBhc3MgYXJvdW5kIHZhbHVlcyBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdIGF0IHJ1bnRpbWUuXG4qKVxuXG5vcGVuISBJbXBvcnRcbm9wZW4gVFxuXG4oKiovKiopXG5cbm1vZHVsZSBUeXBlX2VxdWFsX2RlZm5zIChUeXBlX2VxdWFsIDogVC5UMikgPSBzdHJ1Y3RcbiAgKCoqIFRoZSBbTGlmdCpdIG1vZHVsZSB0eXBlcyBhcmUgdXNlZCBieSB0aGUgW0xpZnQqXSBmdW5jdG9ycy4gU2VlIGJlbG93LiAqKVxuXG4gIG1vZHVsZSB0eXBlIExpZnQgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBsaWZ0IDogKCdhLCAnYikgVHlwZV9lcXVhbC50IC0+ICgnYSB0LCAnYiB0KSBUeXBlX2VxdWFsLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTGlmdDIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBsaWZ0XG4gICAgICA6ICAoJ2ExLCAnYjEpIFR5cGVfZXF1YWwudFxuICAgICAgLT4gKCdhMiwgJ2IyKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgoJ2ExLCAnYTIpIHQsICgnYjEsICdiMikgdCkgVHlwZV9lcXVhbC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIExpZnQzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGxpZnRcbiAgICAgIDogICgnYTEsICdiMSkgVHlwZV9lcXVhbC50XG4gICAgICAtPiAoJ2EyLCAnYjIpIFR5cGVfZXF1YWwudFxuICAgICAgLT4gKCdhMywgJ2IzKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgoJ2ExLCAnYTIsICdhMykgdCwgKCdiMSwgJ2IyLCAnYjMpIHQpIFR5cGVfZXF1YWwudFxuICBlbmRcblxuICAoKiogW0luamVjdGl2ZV0gaXMgYW4gaW50ZXJmYWNlIHRoYXQgc3RhdGVzIHRoYXQgYSB0eXBlIGlzIGluamVjdGl2ZSwgd2hlcmUgdGhlIHR5cGUgaXNcbiAgICAgIHZpZXdlZCBhcyBhIGZ1bmN0aW9uIGZyb20gdHlwZXMgdG8gb3RoZXIgdHlwZXMuIEl0IHByZWRhdGVzIE9DYW1sJ3Mgc3VwcG9ydCBmb3JcbiAgICAgIGV4cGxpY2l0IGluamVjdGl2aXR5IGFubm90YXRpb25zIGluIHRoZSB0eXBlIHN5c3RlbS5cblxuICAgICAgVGhlIHR5cGljYWwgcHJpb3IgdXNhZ2Ugd2FzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHRcbiAgICAgICAgaW5jbHVkZSBJbmplY3RpdmUgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgXX1cblxuICAgICAgRm9yIGV4YW1wbGUsIFsnYSBsaXN0XSBpcyBhbiBpbmplY3RpdmUgdHlwZSwgYmVjYXVzZSB3aGVuZXZlciBbJ2EgbGlzdCA9ICdiIGxpc3RdLFxuICAgICAgd2Uga25vdyB0aGF0IFsnYV0gPSBbJ2JdLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgd2UgZGVmaW5lOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHQgPSB1bml0XG4gICAgICBdfVxuXG4gICAgICB0aGVuIGNsZWFybHkgW3RdIGlzbid0IGluamVjdGl2ZSwgYmVjYXVzZSwgZS5nLiwgW2ludCB0ID0gYm9vbCB0XSwgYnV0XG4gICAgICBbaW50IDw+IGJvb2xdLlxuXG4gICAgICBJZiBbbW9kdWxlIE0gOiBJbmplY3RpdmVdLCB0aGVuIFtNLnN0cmlwXSBwcm92aWRlcyBhIHdheSB0byBnZXQgYSBwcm9vZiB0aGF0IHR3b1xuICAgICAgdHlwZXMgYXJlIGVxdWFsIGZyb20gYSBwcm9vZiB0aGF0IGJvdGggdHlwZXMgdHJhbnNmb3JtZWQgYnkgW00udF0gYXJlIGVxdWFsLiBBXG4gICAgICB0eXBpY2FsIGltcGxlbWVudGF0aW9uIGxvb2tlZCBsaWtlIHRoaXM6XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBzdHJpcCAodHlwZSBhKSAodHlwZSBiKVxuICAgICAgICAgICAgICAoVHlwZV9lcXVhbC5UIDogKGEgdCwgYiB0KSBUeXBlX2VxdWFsLnQpIDogKGEsIGIpIFR5cGVfZXF1YWwudCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5UXG4gICAgICBdfVxuXG4gICAgICBUaGlzIHdpbGwgbm90IHR5cGUgY2hlY2sgZm9yIGFsbCB0eXBlIGNvbnN0cnVjdG9ycyAoY2VydGFpbmx5IG5vdCBmb3Igbm9uLWluamVjdGl2ZVxuICAgICAgb25lcyEpLCBidXQgaXQncyBhbHdheXMgc2FmZSB0byB0cnkgdGhlIGFib3ZlIGltcGxlbWVudGF0aW9uIGlmIHlvdSBhcmUgdW5zdXJlLiBJZlxuICAgICAgT0NhbWwgYWNjZXB0cyB0aGlzIGRlZmluaXRpb24sIHRoZW4gdGhlIHR5cGUgaXMgaW5qZWN0aXZlLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWZcbiAgICAgIE9DYW1sIGRvZXNuJ3QsIHRoZW4gdGhlIHR5cGUgbWF5IG9yIG1heSBub3QgYmUgaW5qZWN0aXZlLiBGb3IgZXhhbXBsZSwgaWYgdGhlXG4gICAgICBkZWZpbml0aW9uIG9mIHRoZSB0eXBlIGRlcGVuZHMgb24gYWJzdHJhY3QgdHlwZXMgdGhhdCBtYXRjaCBbSW5qZWN0aXZlXSwgT0NhbWwgd2lsbFxuICAgICAgbm90IGF1dG9tYXRpY2FsbHkgdXNlIHRoZWlyIGluamVjdGl2aXR5LCBhbmQgb25lIHdpbGwgaGF2ZSB0byB3cml0ZSBhIG1vcmVcbiAgICAgIGNvbXBsaWNhdGVkIGRlZmluaXRpb24gb2YgW3N0cmlwXSB0aGF0IGNhdXNlcyBPQ2FtbCB0byB1c2UgdGhhdCBmYWN0LiBGb3IgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgbW9kdWxlIEYgKE0gOiBUeXBlX2VxdWFsLkluamVjdGl2ZSkgOiBUeXBlX2VxdWFsLkluamVjdGl2ZSA9IHN0cnVjdFxuICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIE0udCAqIGludFxuXG4gICAgICAgICAgbGV0IHN0cmlwICh0eXBlIGEpICh0eXBlIGIpXG4gICAgICAgICAgICAgICAgKGUgOiAoYSB0LCBiIHQpIFR5cGVfZXF1YWwudCkgOiAoYSwgYikgVHlwZV9lcXVhbC50ID1cbiAgICAgICAgICAgIGxldCBlMSwgXyA9IFR5cGVfZXF1YWwuZGV0dXBsZTIgZSBpblxuICAgICAgICAgICAgTS5zdHJpcCBlMVxuICAgICAgICAgIDs7XG4gICAgICAgIGVuZFxuICAgICAgXX1cblxuICAgICAgSWYgaW4gdGhlIGRlZmluaXRpb24gb2YgW0ZdIHdlIGhhZCB3cml0dGVuIHRoZSBzaW1wbGVyIGltcGxlbWVudGF0aW9uIG9mIFtzdHJpcF0gdGhhdFxuICAgICAgZGlkbid0IHVzZSBbTS5zdHJpcF0sIHRoZW4gT0NhbWwgd291bGQgaGF2ZSByZXBvcnRlZCBhIHR5cGUgZXJyb3IuXG4gICopXG4gIG1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHN0cmlwIDogKCdhIHQsICdiIHQpIFR5cGVfZXF1YWwudCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnRcbiAgZW5kXG4gIFtAQGRlcHJlY2F0ZWRcbiAgICBcIltzaW5jZSAyMDIzLTA4XSBPQ2FtbCBub3cgc3VwcG9ydHMgaW5qZWN0aXZpdHkgYW5ub3RhdGlvbnMuIFt0eXBlICEnYSB0XSBkZWNsYXJlcyBcXFxuICAgICB0aGF0IFsnYSB0XSBpcyBpbmplY3RpdmUgd2l0aCByZXNwZWN0IHRvIFsnYV0uXCJdXG5cbiAgKCoqIFtJbmplY3RpdmUyXSBpcyBmb3IgYSBiaW5hcnkgdHlwZSB0aGF0IGlzIGluamVjdGl2ZSBpbiBib3RoIHR5cGUgYXJndW1lbnRzLiAqKVxuICBtb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gICAgdHlwZSAoJ2ExLCAnYTIpIHRcblxuICAgIHZhbCBzdHJpcFxuICAgICAgOiAgKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgnYTEsICdiMSkgVHlwZV9lcXVhbC50ICogKCdhMiwgJ2IyKSBUeXBlX2VxdWFsLnRcbiAgZW5kXG4gIFtAQGRlcHJlY2F0ZWRcbiAgICBcIltzaW5jZSAyMDIzLTA4XSBPQ2FtbCBub3cgc3VwcG9ydHMgaW5qZWN0aXZpdHkgYW5ub3RhdGlvbnMuIFt0eXBlICEnYSB0XSBkZWNsYXJlcyBcXFxuICAgICB0aGF0IFsnYSB0XSBpcyBpbmplY3RpdmUgd2l0aCByZXNwZWN0IHRvIFsnYV0uXCJdXG5cbiAgKCoqIFtDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHldIGlzIGEgZnVuY3RvciB0aGF0IHByb3ZlcyB0aGF0IGNvbXBvc2l0aW9uIG9mXG4gICAgICBpbmplY3RpdmUgdHlwZXMgaXMgaW5qZWN0aXZlLiAqKVxuICBtb2R1bGUgQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2aXR5IChNMSA6IEluamVjdGl2ZSkgKE0yIDogSW5qZWN0aXZlKSA6XG4gICAgSW5qZWN0aXZlIHdpdGggdHlwZSAnYSB0ID0gJ2EgTTEudCBNMi50ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgTTEudCBNMi50XG5cbiAgICBsZXQgc3RyaXAgZSA9IE0xLnN0cmlwIChNMi5zdHJpcCBlKVxuICBlbmRcbiAgW0BAYWxlcnQgXCItZGVwcmVjYXRlZFwiXVxuICBbQEBkZXByZWNhdGVkXG4gICAgXCJbc2luY2UgMjAyMy0wOF0gT0NhbWwgbm93IHN1cHBvcnRzIGluamVjdGl2aXR5IGFubm90YXRpb25zLiBbdHlwZSAhJ2EgdF0gZGVjbGFyZXMgXFxcbiAgICAgdGhhdCBbJ2EgdF0gaXMgaW5qZWN0aXZlIHdpdGggcmVzcGVjdCB0byBbJ2FdLlwiXVxuZW5kXG5cbm1vZHVsZSBUeXBlX2VxdWFsX2lkX2RlZm5zIChJZCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSB0eXBlIEFyZzAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBcmcxID0gc2lnXG4gICAgdHlwZSAhJ2EgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFyZzIgPSBzaWdcbiAgICB0eXBlICghJ2EsICEnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQXJnMyA9IHNpZ1xuICAgIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0eXBlX2VxdWFsX2lkIDogdCBJZC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2EgdCBJZC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2IgSWQudCAtPiAoJ2EsICdiKSB0IElkLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2IgSWQudCAtPiAnYyBJZC50IC0+ICgnYSwgJ2IsICdjKSB0IElkLnRcbiAgZW5kXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgdHlwZSBUeXBlX2VxdWFsID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdCA9IFQgOiAoJ2EsICdhKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3RcbiAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIGp1c3QgYW4gYWxpYXMsIG5lZWRlZCB3aGVuIFt0XSBnZXRzIHNoYWRvd2VkIGJlbG93ICopXG4gIHR5cGUgKCdhLCAnYikgZXF1YWwgOj0gKCdhLCAnYikgdFxuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgVHlwZV9lcXVhbF9kZWZucyAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgZXF1YWxcbiAgZW5kKVxuXG4gICgqKiBbcmVmbF0sIFtzeW1dLCBhbmQgW3RyYW5zXSBjb25zdHJ1Y3QgcHJvb2ZzIHRoYXQgdHlwZSBlcXVhbGl0eSBpcyByZWZsZXhpdmUsXG4gICAgICBzeW1tZXRyaWMsIGFuZCB0cmFuc2l0aXZlLiAqKVxuXG4gIHZhbCByZWZsIDogKCdhLCAnYSkgdFxuICB2YWwgc3ltIDogKCdhLCAnYikgdCAtPiAoJ2IsICdhKSB0XG4gIHZhbCB0cmFucyA6ICgnYSwgJ2IpIHQgLT4gKCdiLCAnYykgdCAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIFtjb252IHQgeF0gdXNlcyB0aGUgdHlwZSBlcXVhbGl0eSBbdCA6IChhLCBiKSB0XSBhcyBldmlkZW5jZSB0byBzYWZlbHkgY2FzdCBbeF1cbiAgICAgIGZyb20gdHlwZSBbYV0gdG8gdHlwZSBbYl0uICBbY29udl0gaXMgc2VtYW50aWNhbGx5IGp1c3QgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuXG4gICAgICBJbiBhIHByb2dyYW0gdGhhdCBoYXMgW3QgOiAoYSwgYikgdF0gd2hlcmUgb25lIGhhcyBhIHZhbHVlIG9mIHR5cGUgW2FdIHRoYXQgb25lXG4gICAgICB3YW50cyB0byB0cmVhdCBhcyBhIHZhbHVlIG9mIHR5cGUgW2JdLCBpdCBpcyBvZnRlbiBzdWZmaWNpZW50IHRvIHBhdHRlcm4gbWF0Y2ggb25cbiAgICAgIFtUeXBlX2VxdWFsLlRdIHJhdGhlciB0aGFuIHVzZSBbY29udl0uIEhvd2V2ZXIsIHRoZXJlIGFyZSBzaXR1YXRpb25zIHdoZXJlIE9DYW1sJ3NcbiAgICAgIHR5cGUgY2hlY2tlciB3aWxsIG5vdCB1c2UgdGhlIHR5cGUgZXF1YWxpdHkgW2EgPSBiXSwgYW5kIG9uZSBtdXN0IHVzZSBbY29udl0uIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgbW9kdWxlIEYgKE0xIDogc2lnIHR5cGUgdCBlbmQpIChNMiA6IHNpZyB0eXBlIHQgZW5kKSA6IHNpZ1xuICAgICAgICAgIHZhbCBmIDogKE0xLnQsIE0yLnQpIGVxdWFsIC0+IE0xLnQgLT4gTTIudFxuICAgICAgICBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgICBsZXQgZiBlcXVhbCAobTEgOiBNMS50KSA9IGNvbnYgZXF1YWwgbTFcbiAgICAgICAgZW5kXG4gICAgICBdfVxuXG4gICAgICBJZiBvbmUgd3JvdGUgdGhlIGJvZHkgb2YgW0ZdIHVzaW5nIHBhdHRlcm4gbWF0Y2hpbmcgb24gW1RdOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgZiAoVCA6IChNMS50LCBNMi50KSBlcXVhbCkgKG0xIDogTTEudCkgPSAobTEgOiBNMi50KVxuICAgICAgXX1cblxuICAgICAgdGhpcyB3b3VsZCBnaXZlIGEgdHlwZSBlcnJvci4gKilcbiAgdmFsIGNvbnYgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICdiXG5cbiAgKCoqIEl0IGlzIGFsd2F5cyBzYWZlIHRvIGNvbmNsdWRlIHRoYXQgaWYgdHlwZSBbYV0gZXF1YWxzIFtiXSwgdGhlbiBmb3IgYW55IHR5cGUgWydhIHRdLFxuICAgICAgdHlwZSBbYSB0XSBlcXVhbHMgW2IgdF0uIFRoZSBPQ2FtbCB0eXBlIGNoZWNrZXIgdXNlcyB0aGlzIGZhY3Qgd2hlbiBpdCBjYW4uIEhvd2V2ZXIsXG4gICAgICBzb21ldGltZXMsIGUuZy4sIHdoZW4gdXNpbmcgW2NvbnZdLCBvbmUgbmVlZHMgdG8gZXhwbGljaXRseSB1c2UgdGhpcyBmYWN0IHRvXG4gICAgICBjb25zdHJ1Y3QgYW4gYXBwcm9wcmlhdGUgW1R5cGVfZXF1YWwudF0uIFRoZSBbTGlmdCpdIGZ1bmN0b3JzIGRvIHRoaXMuICopXG5cbiAgbW9kdWxlIExpZnQgKFQgOiBUMSkgOiBMaWZ0IHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuICBtb2R1bGUgTGlmdDIgKFQgOiBUMikgOiBMaWZ0MiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgbW9kdWxlIExpZnQzIChUIDogVDMpIDogTGlmdDMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBULnRcblxuICAoKiogW3R1cGxlMl0gYW5kIFtkZXR1cGxlMl0gY29udmVydCBiZXR3ZWVuIGVxdWFsaXR5IG9uIGEgMi10dXBsZSBhbmQgaXRzIGNvbXBvbmVudHMuICopXG5cbiAgdmFsIGRldHVwbGUyIDogKCdhMSAqICdhMiwgJ2IxICogJ2IyKSB0IC0+ICgnYTEsICdiMSkgdCAqICgnYTIsICdiMikgdFxuICB2YWwgdHVwbGUyIDogKCdhMSwgJ2IxKSB0IC0+ICgnYTIsICdiMikgdCAtPiAoJ2ExICogJ2EyLCAnYjEgKiAnYjIpIHRcblxuICAoKiogW0lkXSBwcm92aWRlcyBpZGVudGlmaWVycyBmb3IgdHlwZXMsIGFuZCB0aGUgYWJpbGl0eSB0byB0ZXN0ICh2aWEgW0lkLnNhbWVdKSBhdFxuICAgICAgcnVudGltZSBpZiB0d28gaWRlbnRpZmllcnMgYXJlIGVxdWFsLCBhbmQgaWYgc28gdG8gZ2V0IGEgcHJvb2Ygb2YgZXF1YWxpdHkgb2YgdGhlaXJcbiAgICAgIHR5cGVzLiAgVW5saWtlIHZhbHVlcyBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdLCB2YWx1ZXMgb2YgdHlwZSBbSWQudF0gZG8gaGF2ZSBzZW1hbnRpY1xuICAgICAgY29udGVudCBhbmQgbXVzdCBoYXZlIGEgbm9udHJpdmlhbCBydW50aW1lIHJlcHJlc2VudGF0aW9uLiAqKVxuICBtb2R1bGUgSWQgOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgVHlwZV9lcXVhbF9pZF9kZWZucyAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICAgIGVuZClcblxuICAgICgqKiBFdmVyeSBbSWQudF0gY29udGFpbnMgYSB1bmlxdWUgaWQgdGhhdCBpcyBkaXN0aW5jdCBmcm9tIHRoZSBbVWlkLnRdIGluIGFueSBvdGhlclxuICAgICAgICBbSWQudF0uICopXG4gICAgbW9kdWxlIFVpZCA6IHNpZ1xuICAgICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIGluY2x1ZGUgQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBlbmRcblxuICAgIHZhbCB1aWQgOiBfIHQgLT4gVWlkLnRcblxuICAgICgqKiBbY3JlYXRlIH5uYW1lXSBkZWZpbmVzIGEgbmV3IHR5cGUgaWRlbnRpdHkuIFR3byBjYWxscyB0byBbY3JlYXRlXSB3aWxsIHJlc3VsdCBpblxuICAgICAgICB0d28gZGlzdGluY3QgaWRlbnRpZmllcnMsIGV2ZW4gZm9yIHRoZSBzYW1lIGFyZ3VtZW50cyB3aXRoIHRoZSBzYW1lIHR5cGUuIElmIHRoZVxuICAgICAgICB0eXBlIFsnYV0gZG9lc24ndCBzdXBwb3J0IHNleHAgY29udmVyc2lvbiwgdGhlbiBhIGdvb2QgcHJhY3RpY2UgaXMgdG8gaGF2ZSB0aGVcbiAgICAgICAgY29udmVydGVyIGJlIFtbJXNleHBfb2Y6IF9dXSwgKG9yIFtzZXhwX29mX29wYXF1ZV0sIGlmIG5vdCB1c2luZyBwcHhfc2V4cF9jb252KS5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiBuYW1lOnN0cmluZyAtPiAoJ2EgLT4gU2V4cC50KSAtPiAnYSB0XG5cbiAgICAoKiogQWNjZXNzb3JzICopXG5cbiAgICB2YWwgaGFzaCA6IF8gdCAtPiBpbnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgICB2YWwgdG9fc2V4cCA6ICdhIHQgLT4gJ2EgLT4gU2V4cC50XG4gICAgdmFsIGhhc2hfZm9sZF90IDogSGFzaC5zdGF0ZSAtPiBfIHQgLT4gSGFzaC5zdGF0ZVxuXG4gICAgKCoqIFtzYW1lX3dpdG5lc3MgdDEgdDJdIGFuZCBbc2FtZV93aXRuZXNzX2V4biB0MSB0Ml0gcmV0dXJuIGEgdHlwZSBlcXVhbGl0eSBwcm9vZiBpZmZcbiAgICAgICAgdGhlIHR3byBpZGVudGlmaWVycyBhcmUgdGhlIHNhbWUgKGkuZS4sIHBoeXNpY2FsbHkgZXF1YWwsIHJlc3VsdGluZyBmcm9tIHRoZSBzYW1lXG4gICAgICAgIGNhbGwgdG8gW2NyZWF0ZV0pLiAgVGhpcyBpcyBhIHVzZWZ1bCB3YXkgdG8gYWNoaWV2ZSBhIHNvcnQgb2YgZHluYW1pYyB0eXBpbmcuXG4gICAgICAgIFtzYW1lX3dpdG5lc3NdIGRvZXMgbm90IGFsbG9jYXRlIGEgW1NvbWVdIGV2ZXJ5IHRpbWUgaXQgaXMgY2FsbGVkLlxuXG4gICAgICAgIFtzYW1lIHQxIHQyID0gaXNfc29tZSAoc2FtZV93aXRuZXNzIHQxIHQyKV0uXG4gICAgKilcblxuICAgIHZhbCBzYW1lIDogXyB0IC0+IF8gdCAtPiBib29sXG4gICAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBlcXVhbCBvcHRpb25cbiAgICB2YWwgc2FtZV93aXRuZXNzX2V4biA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBlcXVhbFxuXG4gICAgbW9kdWxlIENyZWF0ZTAgKFQgOiBBcmcwKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudFxuICAgIG1vZHVsZSBDcmVhdGUxIChUIDogQXJnMSkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcbiAgICBtb2R1bGUgQ3JlYXRlMiAoVCA6IEFyZzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgbW9kdWxlIENyZWF0ZTMgKFQgOiBBcmczKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJUeXBlX2VxdWFsX2RlZm5zIiwiVHlwZV9lcXVhbCIsIkNvbXBvc2l0aW9uX3ByZXNlcnZlc19pbmplY3RpdiIsIk0xIiwiTTIiLCJzdHJpcCIsImUiLCJUeXBlX2VxdWFsX2lkX2RlZm5zIiwiSWQiLCJCYXNlX1R5cGVfZXF1YWxfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsaUJBQUFDO0FBQUFBLGFBQUFDLCtCQUFBQyxJQUFBQztBQUFBQSxjQUFBQyxNQUFBQztBQUFBQSxVQUFBLElDaUoyQjtBQUFBLE1BQVk7QUFBQTtBQUFBLEtEakp2QztBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLG9CQUFBQyxJQUFBLFdDcU9HO0FBQUEsT0FBQUMsdUJEck9IIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQ5NzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ2IpIHQgPSBUIDogKCdhLCAnYSkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6XG4gICAgICAnYSAnYi5cbiAgICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGFfXzAwM18gYl9fMDA0XylcbiAgICA6ICAoKGFfXzAwM18gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDA0XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKGFfXzAwM18sIGJfXzAwNF8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gVCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCJcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmluY2x1ZGUgVHlwZV9lcXVhbF9pbnRmLlR5cGVfZXF1YWxfZGVmbnMgKHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBlcXVhbFxuZW5kKVxuXG5sZXQgcmVmbCA9IFRcbmxldCBzeW0gKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChiLCBhKSB0ID0gVFxubGV0IHRyYW5zICh0eXBlIGEgYiBjKSAoVCA6IChhLCBiKSB0KSAoVCA6IChiLCBjKSB0KSA6IChhLCBjKSB0ID0gVFxubGV0IGNvbnYgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSAoYSA6IGEpIDogYiA9IGFcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuXG5tb2R1bGUgTGlmdDIgKFggOiBzaWdcbiAgdHlwZSAoJ2ExLCAnYTIpIHRcbmVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGExIGIxIGEyIGIyKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdClcbiAgICA6ICgoYTEsIGEyKSBYLnQsIChiMSwgYjIpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubW9kdWxlIExpZnQzIChYIDogc2lnXG4gIHR5cGUgKCdhMSwgJ2EyLCAnYTMpIHRcbmVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGExIGIxIGEyIGIyIGEzIGIzKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdCkgKFQgOiAoYTMsIGIzKSB0KVxuICAgIDogKChhMSwgYTIsIGEzKSBYLnQsIChiMSwgYjIsIGIzKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbmxldCBkZXR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEgKiBhMiwgYjEgKiBiMikgdCkgOiAoYTEsIGIxKSB0ICogKGEyLCBiMikgdCA9XG4gIFQsIFRcbjs7XG5cbmxldCB0dXBsZTIgKHR5cGUgYTEgYTIgYjEgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSA6IChhMSAqIGEyLCBiMSAqIGIyKSB0ID0gVFxuXG5tb2R1bGUgSWQgPSBzdHJ1Y3RcbiAgKCogW2tleV0gaXMgYW4gZXh0ZW5zaWJsZSBHQURUIHVzZWQgdG8gbWludCwgYW5kIHBhdHRlcm4gbWF0Y2ggb24sIHR5cGUgd2l0bmVzc2VzLiAqKVxuICB0eXBlIF8ga2V5ID0gLi5cblxuICBtb2R1bGUgVWlkID0gc3RydWN0XG4gICAgKCogQSB1bmlxdWUgaWQgY29udGFpbnMgYW4gW2ludF0gcmVwcmVzZW50aW5nIGEgKHBvc3NpYmx5IHBhcmFtZXRlcml6ZWQpIHR5cGUsIGFuZCBhXG4gICAgICAgbGlzdCBvZiB1aWRzIGZvciB0aGUgcGFyYW1ldGVycyB0byB0aGF0IHR5cGUuICopXG4gICAgdHlwZSB0ID0gVCBvZiBpbnQgKiB0IGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHBfb2ZdXG5cbiAgICBsZXQgcmVjIGNvbXBhcmUgPVxuICAgICAgKGZ1biBhX18wMDVfIGJfXzAwNl8gLT5cbiAgICAgICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDA1XyBiX18wMDZfXG4gICAgICAgICB0aGVuIDBcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBtYXRjaCBhX18wMDVfLCBiX18wMDZfIHdpdGhcbiAgICAgICAgICAgfCBUIChfYV9fMDA3XywgX2FfXzAwOV8pLCBUIChfYl9fMDA4XywgX2JfXzAxMF8pIC0+XG4gICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50IF9hX18wMDdfIF9iX18wMDhfIHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IGNvbXBhcmVfbGlzdCBjb21wYXJlIF9hX18wMDlfIF9iX18wMTBfXG4gICAgICAgICAgICAgIHwgbiAtPiBuKSlcbiAgICAgICAgOiB0IC0+IHQgLT4gaW50KVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIChoYXNoX2ZvbGRfdCA6XG4gICAgICAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgID1cbiAgICAgIChmdW4gaHN2IGFyZyAtPlxuICAgICAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgICAgIHwgVCAoX2EwLCBfYTEpIC0+XG4gICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IF9hMFxuICAgICAgICAgICBpblxuICAgICAgICAgICBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfdCBoc3YgX2ExXG4gICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgICBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCByZWMgc2V4cF9vZl90ID1cbiAgICAgIChmdW4gKFQgKGFyZzBfXzAxM18sIGFyZzFfXzAxNF8pKSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxNV8gPSBzZXhwX29mX2ludCBhcmcwX18wMTNfXG4gICAgICAgICBhbmQgcmVzMV9fMDE2XyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX3QgYXJnMV9fMDE0XyBpblxuICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVFwiOyByZXMwX18wMTVfOyByZXMxX18wMTZfIF1cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZClcblxuICAgICgqIFdlIHVzZSB0aGUgZXh0ZW5zaW9uIGNvbnN0cnVjdG9yIGlkIGZvciBhIFtrZXldIGFzIHRoZSB1bmlxdWUgaWQgZm9yIGl0cyB0eXBlLiAqKVxuICAgIGxldCBjcmVhdGUgKGtleSA6IF8ga2V5KSBhcmdzID1cbiAgICAgIGxldCB0YWcgPVxuICAgICAgICBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoU3RkbGliLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIGtleSlcbiAgICAgIGluXG4gICAgICBUICh0YWcsIGFyZ3MpXG4gICAgOztcbiAgZW5kXG5cbiAgKCogRXZlcnkgdHlwZS1lcXVhbCBpZCBtdXN0IHN1cHBvcnQgdGhlc2Ugb3BlcmF0aW9ucy4gKilcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgKCogSG93IHRvIHJlbmRlciB2YWx1ZXMgb2YgdGhlIHR5cGUuICopXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cC50XG5cbiAgICAoKiBBIHVuaXF1ZSBpZCBmb3IgdGhpcyB0eXBlLiAqKVxuICAgIHZhbCB1aWQgOiBVaWQudFxuXG4gICAgKCogTmFtZSBvZiB0aGUgdHlwZS1lcXVhbCBpZC4gKilcbiAgICB2YWwgaWRfbmFtZSA6IHN0cmluZ1xuXG4gICAgKCogU2V4cCBvZiB0aGUgdHlwZS1lcXVhbCBpZC4gKilcbiAgICB2YWwgaWRfc2V4cCA6IFNleHAudFxuXG4gICAgKCogW2tleV0gdmFsdWUgZm9yIHRoZSB0eXBlLiAqKVxuICAgIHZhbCB0eXBlX2tleSA6IHQga2V5XG5cbiAgICAoKiB0eXBlIGVxdWFsaXR5OiBnaXZlbiBhbm90aGVyIGtleSwgcHJvZHVjZSBhbiBbZXF1YWxdIGlmIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lXG4gICAgICAgdHlwZSBpbnN0YW5jZSAqKVxuICAgIHZhbCB0eXBlX2VxdWFsIDogJ2Ega2V5IC0+ICh0LCAnYSkgZXF1YWwgb3B0aW9uXG4gIGVuZFxuXG4gICgqIEFuIFtJZC50XSBpcyBhIGZpcnN0LWNsYXNzIG1vZHVsZSBpbXBsZW1lbnRpbmcgdGhlIGFib3ZlIG9wZXJhdGlvbnMuICopXG4gIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gIGxldCB1aWQgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpID0gQS51aWRcbiAgbGV0IG5hbWUgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpID0gQS5pZF9uYW1lXG4gIGxldCBzZXhwX29mX3QgKHR5cGUgYSkgXyAoKG1vZHVsZSBBKSA6IGEgdCkgPSBBLmlkX3NleHBcbiAgbGV0IHRvX3NleHAgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpID0gQS5zZXhwX29mX3RcbiAgbGV0IGhhc2ggdCA9IFVpZC5oYXNoICh1aWQgdClcbiAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBVaWQuaGFzaF9mb2xkX3Qgc3RhdGUgKHVpZCB0KVxuXG4gIGxldCBzYW1lX3dpdG5lc3MgKHR5cGUgYSBiKSAoKG1vZHVsZSBBKSA6IGEgdCkgKChtb2R1bGUgQikgOiBiIHQpID1cbiAgICBBLnR5cGVfZXF1YWwgQi50eXBlX2tleVxuICA7O1xuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIHQxIHQyID1cbiAgICBtYXRjaCBzYW1lX3dpdG5lc3MgdDEgdDIgd2l0aFxuICAgIHwgU29tZSBlcXVhbCAtPiBlcXVhbFxuICAgIHwgTm9uZSAtPlxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiVHlwZV9lcXVhbC5JZC5zYW1lX3dpdG5lc3NfZXhuIGdvdCBkaWZmZXJlbnQgaWRzXCJcbiAgICAgICAgICAgWyAoIFwiXCJcbiAgICAgICAgICAgICAsIHNleHBfb2ZfcGFpciAoc2V4cF9vZl90IHNleHBfb2Zfb3BhcXVlKSAoc2V4cF9vZl90IHNleHBfb2Zfb3BhcXVlKSAodDEsIHQyKVxuICAgICAgICAgICAgIClcbiAgICAgICAgICAgXSlcbiAgOztcblxuICBsZXQgc2FtZSB0MSB0MiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIHQxIHQyIHdpdGhcbiAgICB8IFNvbWUgXyAtPiB0cnVlXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gIDs7XG5cbiAgaW5jbHVkZSBUeXBlX2VxdWFsX2ludGYuVHlwZV9lcXVhbF9pZF9kZWZucyAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcbiAgZW5kKVxuXG4gIG1vZHVsZSBDcmVhdGUwIChUIDogQXJnMCkgPSBzdHJ1Y3RcbiAgICB0eXBlIF8ga2V5ICs9IFQwIDogVC50IGtleVxuXG4gICAgbGV0IHR5cGVfZXF1YWxfaWQgOiBULnQgdCA9XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBULnRcblxuICAgICAgICBsZXQgaWRfbmFtZSA9IFQubmFtZVxuICAgICAgICBsZXQgaWRfc2V4cCA9IFNleHAuQXRvbSBpZF9uYW1lXG4gICAgICAgIGxldCBzZXhwX29mX3QgPSBULnNleHBfb2ZfdFxuICAgICAgICBsZXQgdHlwZV9rZXkgPSBUMFxuICAgICAgICBsZXQgdWlkID0gVWlkLmNyZWF0ZSB0eXBlX2tleSBbXVxuXG4gICAgICAgIGxldCB0eXBlX2VxdWFsICh0eXBlIG90aGVyKSAob3RoZXJrZXkgOiBvdGhlciBrZXkpIDogKHQsIG90aGVyKSBlcXVhbCBvcHRpb24gPVxuICAgICAgICAgIG1hdGNoIG90aGVya2V5IHdpdGhcbiAgICAgICAgICB8IFQwIC0+IFNvbWUgVFxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIDs7XG4gICAgICBlbmQpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIENyZWF0ZTEgKFQgOiBBcmcxKSA9IHN0cnVjdFxuICAgIHR5cGUgXyBrZXkgKz0gVDEgOiAnYSBrZXkgLT4gJ2EgVC50IGtleVxuXG4gICAgbGV0IHR5cGVfZXF1YWxfaWQgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpIDogYSBULnQgdCA9XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBBLnQgVC50XG5cbiAgICAgICAgbGV0IGlkX25hbWUgPSBULm5hbWVcbiAgICAgICAgbGV0IGlkX3NleHAgPSBTZXhwLkxpc3QgWyBBdG9tIGlkX25hbWU7IEEuaWRfc2V4cCBdXG4gICAgICAgIGxldCBzZXhwX29mX3QgdCA9IFQuc2V4cF9vZl90IEEuc2V4cF9vZl90IHRcbiAgICAgICAgbGV0IHR5cGVfa2V5ID0gVDEgQS50eXBlX2tleVxuICAgICAgICBsZXQgdWlkID0gVWlkLmNyZWF0ZSB0eXBlX2tleSBbIEEudWlkIF1cblxuICAgICAgICBsZXQgdHlwZV9lcXVhbCAodHlwZSBvdGhlcikgKG90aGVya2V5IDogb3RoZXIga2V5KSA6ICh0LCBvdGhlcikgZXF1YWwgb3B0aW9uID1cbiAgICAgICAgICBtYXRjaCBvdGhlcmtleSB3aXRoXG4gICAgICAgICAgfCBUMSBha2V5IC0+XG4gICAgICAgICAgICAobWF0Y2ggQS50eXBlX2VxdWFsIGFrZXkgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSBUIC0+IFNvbWUgVFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIDs7XG4gICAgICBlbmQpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIENyZWF0ZTIgKFQgOiBBcmcyKSA9IHN0cnVjdFxuICAgIHR5cGUgXyBrZXkgKz0gVDIgOiAnYSBrZXkgKiAnYiBrZXkgLT4gKCdhLCAnYikgVC50IGtleVxuXG4gICAgbGV0IHR5cGVfZXF1YWxfaWQgKHR5cGUgYSBiKSAoKG1vZHVsZSBBKSA6IGEgdCkgKChtb2R1bGUgQikgOiBiIHQpIDogKGEsIGIpIFQudCB0ID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IChBLnQsIEIudCkgVC50XG5cbiAgICAgICAgbGV0IGlkX25hbWUgPSBULm5hbWVcbiAgICAgICAgbGV0IGlkX3NleHAgPSBTZXhwLkxpc3QgWyBBdG9tIGlkX25hbWU7IEEuaWRfc2V4cDsgQi5pZF9zZXhwIF1cbiAgICAgICAgbGV0IHNleHBfb2ZfdCB0ID0gVC5zZXhwX29mX3QgQS5zZXhwX29mX3QgQi5zZXhwX29mX3QgdFxuICAgICAgICBsZXQgdHlwZV9rZXkgPSBUMiAoQS50eXBlX2tleSwgQi50eXBlX2tleSlcbiAgICAgICAgbGV0IHVpZCA9IFVpZC5jcmVhdGUgdHlwZV9rZXkgWyBBLnVpZDsgQi51aWQgXVxuXG4gICAgICAgIGxldCB0eXBlX2VxdWFsICh0eXBlIG90aGVyKSAob3RoZXJrZXkgOiBvdGhlciBrZXkpIDogKHQsIG90aGVyKSBlcXVhbCBvcHRpb24gPVxuICAgICAgICAgIG1hdGNoIG90aGVya2V5IHdpdGhcbiAgICAgICAgICB8IFQyIChha2V5LCBia2V5KSAtPlxuICAgICAgICAgICAgKG1hdGNoIEEudHlwZV9lcXVhbCBha2V5LCBCLnR5cGVfZXF1YWwgYmtleSB3aXRoXG4gICAgICAgICAgICAgfCBTb21lIFQsIFNvbWUgVCAtPiBTb21lIFRcbiAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgICAgOztcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlMyAoVCA6IEFyZzMpID0gc3RydWN0XG4gICAgdHlwZSBfIGtleSArPSBUMyA6ICdhIGtleSAqICdiIGtleSAqICdjIGtleSAtPiAoJ2EsICdiLCAnYykgVC50IGtleVxuXG4gICAgbGV0IHR5cGVfZXF1YWxfaWRcbiAgICAgICh0eXBlIGEgYiBjKVxuICAgICAgKChtb2R1bGUgQSkgOiBhIHQpXG4gICAgICAoKG1vZHVsZSBCKSA6IGIgdClcbiAgICAgICgobW9kdWxlIEMpIDogYyB0KVxuICAgICAgOiAoYSwgYiwgYykgVC50IHRcbiAgICAgID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IChBLnQsIEIudCwgQy50KSBULnRcblxuICAgICAgICBsZXQgaWRfbmFtZSA9IFQubmFtZVxuICAgICAgICBsZXQgaWRfc2V4cCA9IFNleHAuTGlzdCBbIEF0b20gaWRfbmFtZTsgQS5pZF9zZXhwOyBCLmlkX3NleHA7IEMuaWRfc2V4cCBdXG4gICAgICAgIGxldCBzZXhwX29mX3QgdCA9IFQuc2V4cF9vZl90IEEuc2V4cF9vZl90IEIuc2V4cF9vZl90IEMuc2V4cF9vZl90IHRcbiAgICAgICAgbGV0IHR5cGVfa2V5ID0gVDMgKEEudHlwZV9rZXksIEIudHlwZV9rZXksIEMudHlwZV9rZXkpXG4gICAgICAgIGxldCB1aWQgPSBVaWQuY3JlYXRlIHR5cGVfa2V5IFsgQS51aWQ7IEIudWlkOyBDLnVpZCBdXG5cbiAgICAgICAgbGV0IHR5cGVfZXF1YWwgKHR5cGUgb3RoZXIpIChvdGhlcmtleSA6IG90aGVyIGtleSkgOiAodCwgb3RoZXIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggb3RoZXJrZXkgd2l0aFxuICAgICAgICAgIHwgVDMgKGFrZXksIGJrZXksIGNrZXkpIC0+XG4gICAgICAgICAgICAobWF0Y2ggQS50eXBlX2VxdWFsIGFrZXksIEIudHlwZV9lcXVhbCBia2V5LCBDLnR5cGVfZXF1YWwgY2tleSB3aXRoXG4gICAgICAgICAgICAgfCBTb21lIFQsIFNvbWUgVCwgU29tZSBUIC0+IFNvbWUgVFxuICAgICAgICAgICAgIHwgTm9uZSwgXywgXyB8IF8sIE5vbmUsIF8gfCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgICAgOztcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBsZXQgY3JlYXRlICh0eXBlIGEpIH5uYW1lIHNleHBfb2ZfdCA9XG4gICAgbGV0IG1vZHVsZSBUID1cbiAgICAgIENyZWF0ZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBhXG5cbiAgICAgICAgbGV0IG5hbWUgPSBuYW1lXG4gICAgICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICAgIGVuZClcbiAgICBpblxuICAgIFQudHlwZV9lcXVhbF9pZFxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9UIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsImNzdCIsIkJhc2VfSW1wb3J0IiwiQmFzZV9TZXhwIiwiQmFzZV9FcnJvciIsIlN0ZGxpYl9PYmoiLCJCYXNlX0hhc2giLCJCYXNlX1R5cGVfZXF1YWxfaW50ZiIsIkJhc2VfQ29tcGFyYWJsZSIsInNleHBfb2ZfdCIsIm9mX2FfMDAxIiwib2ZfYl8wMDIiLCJwYXJhbSIsImluY2x1ZGUiLCJDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXYiLCJzeW0iLCJ0cmFucyIsImNvbnYiLCJhIiwiTGlmdCIsIlgiLCJsaWZ0IiwiTGlmdDIiLCJMaWZ0MyIsImRldHVwbGUyIiwidHVwbGUyIiwiY29tcGFyZSIsImFfMDA1IiwiYl8wMDYiLCJiXzAxMCIsImJfMDA4IiwiYV8wMDkiLCJhXzAwNyIsIm4iLCJsZXRyZWNfZnVuY3Rpb25fY29udGV4dCIsImhhc2hfZm9sZF90IiwiaHN2IiwiYXJnIiwiaGFzaCIsIngiLCJmdW5jIiwiYXJnMV8wMTQiLCJhcmcwXzAxMyIsInJlczBfMDE1IiwicmVzMV8wMTYiLCJzeW1ib2wiLCJlcXVhbCIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwiY3N0X1R5cGVfZXF1YWxfSWRfc2FtZV93aXRuZXNzIiwiY3N0X0Jhc2VfVHlwZV9lcXVhbF9JZF9DcmVhdGUwIiwiY3N0X0Jhc2VfVHlwZV9lcXVhbF9JZF9DcmVhdGUxIiwiY3N0X0Jhc2VfVHlwZV9lcXVhbF9JZF9DcmVhdGUyIiwiY3N0X0Jhc2VfVHlwZV9lcXVhbF9JZF9DcmVhdGUzIiwiZHVtbXkiLCJjcmVhdGUiLCJrZXkiLCJhcmdzIiwidGFnIiwidWlkIiwiQSIsIm5hbWUiLCJ0b19zZXhwIiwidCIsInN0YXRlIiwic2FtZV93aXRuZXNzIiwiQiIsInNhbWVfd2l0bmVzc19leG4iLCJ0MSIsInQyIiwibWF0Y2giLCJzYW1lIiwiQ3JlYXRlMCIsIlQiLCJUMCIsImlkX25hbWUiLCJpZF9zZXhwIiwidHlwZV9lcXVhbCIsIm90aGVya2V5IiwidHlwZV9lcXVhbF9pZCIsIkJhc2VfVHlwZV9lcXVhbCIsIlQxIiwidHlwZV9rZXkiLCJha2V5IiwiVDIiLCJia2V5IiwiVDMiLCJDIiwiY2tleSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxrQkFBQTtB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QixNQU9ZO0FBQUEsbUJBQUFrQixXQUFBQztBQUFBQSxlQUFBcEIsTUFHUjtBQUFBLDBCQUtPO0FBQUE7QUFBQSxZQUFBMkIsT0FMUDtBQUFBLFlBQUFGLE9BQUE7QUFBQSxZQUFBYixRQUVTO0FBQUEsWUFBQUEsVUFBbUI7QUFBQSxXQUFpQixxQkFDdEI7QUFBQSxXQUNHO0FBQUEsVUFDZjtBQUFBLFVBUmlDO0FBQUEsU0FVNUM7QUFBQSxTRHRRVjtBQUFBO0FBQUEsaUJBQUFHO0FBQUFBLGFBQUFhLEtBQUE7QUFBQSxrQkFBQVAsY0FBQW5CLEdBQUFNLEdBQUFxQjtBQUFBQTtBQUFBQSxXQUFBWixVQ29STTtBQUFBLFdBQUFDO0FBQUFBLGFBQUE7QUFBQSxtQkFBQXpFLFVBQUE0RCxHQUtvQiw0Q0FBaUQ7QUFBQTtBQUFBLFdBQUFtQixXQUxyRTtBQUFBLFdBQUF2QixNQU9ZO0FBQUEsbUJBQUFrQixXQUFBQztBQUFBQSxlQUFBcEIsTUFHUjtBQUFBLDBCQUtPO0FBQUE7QUFBQSxZQUFBOEIsT0FMUDtBQUFBLFlBQUFILE9BQUE7QUFBQSxZQUFBRixPQUFBO0FBQUEsWUFBQWIsUUFFUztBQUFBLFlBQUFBLFVBQW1CO0FBQUEsWUFBQUEsVUFBbUI7QUFBQSxXQUFpQixnQ0FDakM7QUFBQSxXQUNjO0FBQUEsVUFDbEM7QUFBQSxVQVJ3QztBQUFBLFNBVW5EO0FBQUEsU0RyU1Y7QUFBQTtBQUFBLEdDd0dNO0FBQUE7QUFBQSxFRHhHTiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MjUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9TdGFja19pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsa0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNTI2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9vcHRpb25fYXJyYXkubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuKCoqIFsnYSBDaGVhcF9vcHRpb24udF0gaXMgbGlrZSBbJ2Egb3B0aW9uXSwgYnV0IGl0IGRvZXNuJ3QgYm94IFtzb21lIF9dIHZhbHVlcy5cblxuICAgIFRoZXJlIGFyZSBzZXZlcmFsIHRoaW5ncyB0aGF0IGFyZSB1bnNhZmUgYWJvdXQgaXQ6XG5cbiAgICAtIFtmbG9hdCB0IGFycmF5XSAob3IgYW55IGFycmF5LWJhY2tlZCBjb250YWluZXIpIGlzIG5vdCBtZW1vcnktc2FmZVxuICAgICAgYmVjYXVzZSBmbG9hdCBhcnJheSBvcHRpbWl6YXRpb24gaXMgaW5jb21wYXRpYmxlIHdpdGggdW5ib3hlZCBvcHRpb25cbiAgICAgIG9wdGltaXphdGlvbi4gWW91IGhhdmUgdG8gdXNlIFtVbmlmb3JtX2FycmF5LnRdIGluc3RlYWQgb2YgW2FycmF5XS5cblxuICAgIC0gTmVzdGVkIG9wdGlvbnMgKFsnYSB0IHRdKSBkb24ndCB3b3JrLiBUaGV5IGFyZSBiZWxpZXZlZCB0byBiZVxuICAgICAgbWVtb3J5LXNhZmUsIGJ1dCBub3QgcGFyYW1ldHJpYy5cblxuICAgIC0gQSByZWNvcmQgd2l0aCBbZmxvYXQgdF1zIGluIGl0IHNob3VsZCBiZSBzYWZlLCBidXQgaXQncyBvbmx5IFt0XSBiZWluZ1xuICAgICAgYWJzdHJhY3QgdGhhdCBnaXZlcyB5b3Ugc2FmZXR5LiBJZiB0aGUgY29tcGlsZXIgd2FzIHNtYXJ0IGVub3VnaCB0byBwZWVrXG4gICAgICB0aHJvdWdoIHRoZSBtb2R1bGUgc2lnbmF0dXJlIHRoZW4gaXQgY291bGQgZGVjaWRlIHRvIGNvbnN0cnVjdCBhIGZsb2F0XG4gICAgICBhcnJheSBpbnN0ZWFkLiAqKVxubW9kdWxlIENoZWFwX29wdGlvbiA9IHN0cnVjdFxuICAoKiBUaGlzIGlzIHRha2VuIGZyb20gY29yZS4gUmF0aGVyIHRoYW4gZXhwb3NlIGl0IGluIHRoZSBwdWJsaWMgaW50ZXJmYWNlIG9mIGJhc2UsIGp1c3RcbiAgICAga2VlcCBhIGNvcHkgYXJvdW5kIGhlcmUuICopXG4gIGxldCBwaHlzX3NhbWUgKHR5cGUgYSBiKSAoYSA6IGEpIChiIDogYikgPSBwaHlzX2VxdWFsIGEgKFN0ZGxpYi5PYmoubWFnaWMgYiA6IGEpXG5cbiAgbW9kdWxlIFQwIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbm9uZSA6IF8gdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBpc19ub25lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfc29tZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgdmFsdWVfdW5zYWZlIDogJ2EgdCAtPiAnYVxuICAgIHZhbCBpdGVyX3NvbWUgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSArJ2EgdFxuXG4gICAgKCogQmVpbmcgYSBwb2ludGVyLCBubyBvbmUgb3V0c2lkZSB0aGlzIG1vZHVsZSBjYW4gY29uc3RydWN0IGEgdmFsdWUgdGhhdCBpc1xuICAgICAgIFtwaHlzX3NhbWVdIGFzIHRoaXMgb25lLlxuXG4gICAgICAgSXQgd291bGQgYmUgc2ltcGxlciB0byB1c2UgdGhpcyB2YWx1ZSBhcyBbbm9uZV0sIGJ1dCB3ZSB1c2UgYW4gaW1tZWRpYXRlIGluc3RlYWRcbiAgICAgICBiZWNhdXNlIGl0IGxldHMgdXMgYXZvaWQgY2FtbF9tb2RpZnkgd2hlbiBzZXR0aW5nIHRvIFtub25lXSwgbWFraW5nIGNlcnRhaW5cbiAgICAgICBiZW5jaG1hcmtzIHNpZ25pZmljYW50bHkgZmFzdGVyIChlLmcuIC4uL2JlbmNoL2FycmF5X3F1ZXVlLmV4ZSkuXG5cbiAgICAgICB0aGlzIGNvZGUgaXMgZHVwbGljYXRlZCBpbiBNb3B0aW9uLCBhbmQgaWYgd2UgZmluZCB5ZXQgYW5vdGhlciBwbGFjZSB3aGVyZSB3ZSB3YW50XG4gICAgICAgaXQgd2Ugc2hvdWxkIHJlY29uc2lkZXIgbWFraW5nIGl0IHNoYXJlZC4gKilcbiAgICBsZXQgbm9uZV9zdWJzdGl0dXRlIDogXyB0ID1cbiAgICAgIFN0ZGxpYi5PYmoub2JqIChTdGRsaWIuT2JqLm5ld19ibG9jayBTdGRsaWIuT2JqLmFic3RyYWN0X3RhZyAxKVxuICAgIDs7XG5cbiAgICBsZXQgbm9uZSA6IF8gdCA9XG4gICAgICAoKiBUaGUgbnVtYmVyIHdhcyBwcm9kdWNlZCBieVxuICAgICAgICAgWzwgL2Rldi91cmFuZG9tIHRyIC1jIC1kICcxMjM0NTY3ODkwYWJjZGVmJyB8IGhlYWQgLWMgMTZdLlxuXG4gICAgICAgICBUaGUgaWRlYSBpcyB0aGF0IGEgcmFuZG9tIG51bWJlciB3aWxsIGhhdmUgbG93ZXIgcHJvYmFiaWxpdHkgdG8gY29sbGlkZSB3aXRoXG4gICAgICAgICBhbnl0aGluZyB0aGFuIGFueSBudW1iZXIgd2UgY2FuIGNob29zZSBvdXJzZWx2ZXMuXG5cbiAgICAgICAgIFdlIGFyZSB1c2luZyBhIHBvbHltb3JwaGljIHZhcmlhbnQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyIGNvbnN0YW50IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgIGlzIGEgY29tcGlsZXIgYnVnIHdoZXJlIGl0IHdyb25nbHkgYXNzdW1lcyB0aGF0IHRoZSByZXN1bHQgb2YgW2lmIF8gdGhlbiBjIGVsc2VcbiAgICAgICAgIHldIGlzIG5vdCBhIHBvaW50ZXIgaWYgW2NdIGlzIGFuIGludGVnZXIgY29tcGlsZS10aW1lIGNvbnN0YW50LiAgVGhpcyBpcyBiZWluZ1xuICAgICAgICAgZml4ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL3B1bGwvNTU1LiAgVGhlIFwibWVtb3J5IGNvcnJ1cHRpb25cIiB0ZXN0XG4gICAgICAgICBiZWxvdyBkZW1vbnN0cmF0ZXMgdGhlIGlzc3VlLiAgKilcbiAgICAgIFN0ZGxpYi5PYmoubWFnaWMgYHg2ZThlZTM0NzhlMWQ3NDQ5XG4gICAgOztcblxuICAgIGxldCBpc19ub25lIHggPSBwaHlzX2VxdWFsIHggbm9uZVxuICAgIGxldCBpc19zb21lIHggPSBub3QgKHBoeXNfZXF1YWwgeCBub25lKVxuXG4gICAgbGV0IHNvbWUgKHR5cGUgYSkgKHggOiBhKSA6IGEgdCA9XG4gICAgICBpZiBwaHlzX3NhbWUgeCBub25lIHRoZW4gbm9uZV9zdWJzdGl0dXRlIGVsc2UgU3RkbGliLk9iai5tYWdpYyB4XG4gICAgOztcblxuICAgIGxldCB2YWx1ZV91bnNhZmUgKHR5cGUgYSkgKHggOiBhIHQpIDogYSA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHggbm9uZV9zdWJzdGl0dXRlIHRoZW4gU3RkbGliLk9iai5tYWdpYyBub25lIGVsc2UgU3RkbGliLk9iai5tYWdpYyB4XG4gICAgOztcblxuICAgIGxldCB2YWx1ZV9leG4geCA9XG4gICAgICBpZiBpc19zb21lIHhcbiAgICAgIHRoZW4gdmFsdWVfdW5zYWZlIHhcbiAgICAgIGVsc2UgZmFpbHdpdGggXCJPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuOiB0aGUgZWxlbWVudCBpcyBbTm9uZV1cIlxuICAgIDs7XG5cbiAgICBsZXQgaXRlcl9zb21lIHQgfmYgPSBpZiBpc19zb21lIHQgdGhlbiBmICh2YWx1ZV91bnNhZmUgdClcbiAgZW5kXG5cbiAgbW9kdWxlIFQxID0gc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuXG4gICAgbGV0IG9mX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgfCBTb21lIHggLT4gc29tZSB4XG4gICAgOztcblxuICAgIGxldFtAaW5saW5lXSB0b19vcHRpb24geCA9IGlmIGlzX3NvbWUgeCB0aGVuIFNvbWUgKHZhbHVlX3Vuc2FmZSB4KSBlbHNlIE5vbmVcbiAgICBsZXRbQGlubGluZV0gdG9fb3B0aW9uX2xvY2FsIHggPSBpZiBpc19zb21lIHggdGhlbiBTb21lICh2YWx1ZV91bnNhZmUgeCkgZWxzZSBOb25lXG4gICAgbGV0IHRvX3NleHBhYmxlID0gdG9fb3B0aW9uXG4gICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfb3B0aW9uXG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKE9wdGlvbi50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuICAgIDs7XG4gIGVuZFxuXG4gIGluY2x1ZGUgVDFcbiAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZTEgKE9wdGlvbikgKFQxKVxuZW5kXG5cbnR5cGUgJ2EgdCA9ICdhIENoZWFwX29wdGlvbi50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMDFfIHhfXzAwM18gLT5cbiAgVW5pZm9ybV9hcnJheS50X29mX3NleHAgKENoZWFwX29wdGlvbi50X29mX3NleHAgX29mX2FfXzAwMV8pIHhfXzAwM19cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwNF8geF9fMDA1XyAtPlxuICBVbmlmb3JtX2FycmF5LnNleHBfb2ZfdCAoQ2hlYXBfb3B0aW9uLnNleHBfb2ZfdCBfb2ZfYV9fMDA0XykgeF9fMDA1X1xuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICBVbmlmb3JtX2FycmF5LnRfc2V4cF9ncmFtbWFyIChDaGVhcF9vcHRpb24udF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hcilcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBlbXB0eSA9IFVuaWZvcm1fYXJyYXkuZW1wdHlcbmxldCBjcmVhdGUgfmxlbiA9IFVuaWZvcm1fYXJyYXkuY3JlYXRlIH5sZW4gQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBpbml0IG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiAoZiBpKSkgW0Bub250YWlsXVxubGV0IGluaXRfc29tZSBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5zb21lIChmIGkpKSBbQG5vbnRhaWxdXG5sZXQgbGVuZ3RoID0gVW5pZm9ybV9hcnJheS5sZW5ndGhcbmxldFtAaW5saW5lXSBnZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0W0BpbmxpbmVdIGdldF9sb2NhbCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uX2xvY2FsIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19ub25lIHQgaSA9IENoZWFwX29wdGlvbi5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfc29tZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfc29tZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IHNldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiB4KVxubGV0IHNldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHNldF9ub25lIHQgaSA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxubGV0IHN3YXAgdCBpIGogPSBVbmlmb3JtX2FycmF5LnN3YXAgdCBpIGpcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX2dldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgdW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUgdCBpID1cbiAgQ2hlYXBfb3B0aW9uLnZhbHVlX3Vuc2FmZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbjs7XG5cbmxldCB1bnNhZmVfaXNfc29tZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfc29tZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLm9mX29wdGlvbiB4KVxubGV0IHVuc2FmZV9zZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgdW5zYWZlX3NldF9ub25lIHQgaSA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcblxubGV0IGNsZWFyIHQgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgdW5zYWZlX3NldF9ub25lIHQgaVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgaW5wdXQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGlucHV0IC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBpbnB1dCBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlciBpbnB1dCB+ZiA9IGl0ZXJpIGlucHV0IH5mOihmdW4gKF8gOiBpbnQpIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5cbmxldCBmb2xkaSBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiBhY2MgOj0gZiBpICFhY2MgZWxlbSk7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkIGlucHV0IH5pbml0IH5mID0gZm9sZGkgaW5wdXQgfmluaXQgfmY6KGZ1biAoXyA6IGludCkgYWNjIHggLT4gZiBhY2MgeCkgW0Bub250YWlsXVxuXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyLk1ha2VfZ2VuIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCBfLCBfKSB0ID0gJ2EgdFxuICB0eXBlICdhIGVsdCA9ICdhIG9wdGlvblxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbiAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG5lbmQpXG5cbmxldCBsZW5ndGggPSBVbmlmb3JtX2FycmF5Lmxlbmd0aFxuXG5sZXQgbWFwaSBpbnB1dCB+ZiA9XG4gIGxldCBvdXRwdXQgPSBjcmVhdGUgfmxlbjoobGVuZ3RoIGlucHV0KSBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiB1bnNhZmVfc2V0IG91dHB1dCBpIChmIGkgZWxlbSkpO1xuICBvdXRwdXRcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBpIGlucHV0IH5mOihmdW4gKF8gOiBpbnQpIGVsZW0gLT4gZiBlbGVtKSBbQG5vbnRhaWxdXG5cbmxldCBtYXBfc29tZSBpbnB1dCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXQgaW5cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuIGluXG4gIGxldCAoKSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBvcHQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgaW5wdXQgaSBpblxuICAgICAgQ2hlYXBfb3B0aW9uLml0ZXJfc29tZSBvcHQgfmY6KGZ1biB4IC0+IHVuc2FmZV9zZXRfc29tZSBvdXRwdXQgaSAoZiB4KSlcbiAgICBkb25lXG4gIGluXG4gIG91dHB1dFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID0gaW5pdCAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuXG5sZXQgb2ZfYXJyYXlfc29tZSBhcnJheSA9XG4gIGluaXRfc29tZSAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTFfZ2VuZXJpYyAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgbGV0IHVuc2FmZV9ibGl0ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfYmxpdFxuZW5kKVxuXG5sZXQgY29weSA9IFVuaWZvcm1fYXJyYXkuY29weVxuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVuc2FmZV9jaGVhcF9vcHRpb24gPSBDaGVhcF9vcHRpb25cbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0FycmF5IiwiQmFzZV9JbXBvcnQiLCJCYXNlX1VuaWZvcm1fYXJyYXkiLCJCYXNlX09wdGlvbiIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIlN0ZGxpYl9PYmoiLCJCYXNlX1NleHBhYmxlIiwiQmFzZV9JbmRleGVkX2NvbnRhaW5lciIsIkJhc2VfQmxpdCIsIm5vbmVfc3Vic3RpdHV0ZSIsIm5vbmUiLCJjc3RfT3B0aW9uX2FycmF5X2dldF9zb21lX2V4bl8iLCJpc19ub25lIiwieCIsImlzX3NvbWUiLCJzb21lIiwidmFsdWVfdW5zYWZlIiwidmFsdWVfZXhuIiwib2Zfc2V4cGFibGUiLCJwYXJhbSIsInRvX3NleHBhYmxlIiwiaW5jbHVkZSIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsIm9mX2FfMDAxIiwieF8wMDMiLCJvZl9hXzAwNCIsInhfMDA1IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsImVtcHR5IiwiY3JlYXRlIiwibGVuIiwiaW5pdCIsIm4iLCJpIiwiaW5pdF9zb21lIiwiZ2V0IiwidCIsImdldF9sb2NhbCIsImdldF9zb21lX2V4biIsInNldCIsInNldF9zb21lIiwic2V0X25vbmUiLCJzd2FwIiwiaiIsInVuc2FmZV9nZXQiLCJ1bnNhZmVfZ2V0X3NvbWVfZXhuIiwidW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUiLCJ1bnNhZmVfaXNfc29tZSIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImlucHV0IiwiYWNjIiwiZWxlbSIsImZvbGQiLCJmb2xkaSIsIml0ZXIiLCJpdGVyaSIsImxlbmd0aCIsImlzX2VtcHR5IiwibWVtIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZXhpc3RzIiwiZm9yX2FsbCIsImNvdW50Iiwic3VtIiwiZmluZCIsImZpbmRfbWFwIiwidG9fbGlzdCIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZXhpc3RzaSIsImZvcl9hbGxpIiwiY291bnRpIiwiZmluZGkiLCJmaW5kX21hcGkiLCJtYXAiLCJvdXRwdXQiLCJtYXBfc29tZSIsIm9wdCIsIm9mX2FycmF5IiwiYXJyYXkiLCJvZl9hcnJheV9zb21lIiwidG9fYXJyYXkiLCJjcmVhdGVfbGlrZSIsInVuc2FmZV9ibGl0IiwiYmxpdCIsImJsaXRvIiwic3ViIiwic3VibyIsImNvcHkiLCJCYXNlX09wdGlvbl9hcnJheSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsa0JDNkNxQjtBQUFBLElBQUFDLE9BQWdEO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLFFBQUFDLEdBa0JqRCw4QkFBaUI7QUFBQSxZQUFBQyxRQUFBRCxHQUNqQixvQ0FBdUI7QUFBQSxZQUFBRSxLQUFBRixHQUdsQiwyQ0FBNkM7QUFBQSxZQUFBRyxhQUFBSCxHQUloRSx1Q0FBa0Y7QUFBQSxZQUFBSSxVQUFBSjtBQUFBQSxJQUkvRTtBQUFBLGNBQ0U7QUFBQSxjQUNBLDJEQUEyRDtBQUFBO0FBQUEsWUFBQUssWUFBQUM7QUFBQUEsSUFTbEQsWUFDSjtBQUFBLFFBQUFOLElB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDdDckUiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNTYyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zdGFjay5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTdGFja19pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gW0RlcXVlXSBpbiB0aGF0IGl0IHVzZXMgYW4gYXJyYXkgb2YgWydhXSBhbmRcbiAgIGEgbXV0YWJsZSBbaW50XSB0byBpbmRpY2F0ZSB3aGF0IGluIHRoZSBhcnJheSBpcyB1c2VkLiAgV2UgY2hvb3NlIHRvIGltcGxlbWVudCBbU3RhY2tdXG4gICBkaXJlY3RseSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgW0RlcXVlXSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIEUuZy4gYSBzaW1wbGVcbiAgIG1pY3JvYmVuY2htYXJrIHNob3dzIHRoYXQgcHVzaC9wb3AgaXMgYWJvdXQgMjAlIGZhc3Rlci4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB7IGxlbmd0aCA9IGxlbmd0aF9fMDAzXzsgZWx0cyA9IGVsdHNfXzAwNV8gfSAtPlxuICBsZXQgYm5kc19fMDAyXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAwNV8gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwM18gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IHNleHBfb2ZfdCA9IGBSZWJvdW5kX2xhdGVyXG5sZXQgXyA9IHNleHBfb2ZfdFxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hICh7IGxlbmd0aDsgZWx0cyB9IGFzIHQpIDogdW5pdCA9XG4gIHRyeVxuICAgIGFzc2VydCAoMCA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICAgIGludmFyaWFudF9hIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgaSlcbiAgICBkb25lO1xuICAgICgqIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB1bnVzZWQgZWxlbWVudHMgYXJlIHVuc2V0IHRvIGF2b2lkIGEgc3BhY2VcbiAgICAgICBsZWFrLiAqKVxuICAgIGZvciBpID0gbGVuZ3RoIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyAtIDEgZG9cbiAgICAgIGFzc2VydCAobm90IChPcHRpb25fYXJyYXkuaXNfc29tZSBlbHRzIGkpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiU3RhY2suaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiZXhuXCIsIGV4biB8PiBFeG4uc2V4cF9vZl90OyBcInN0YWNrXCIsIHQgfD4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2Zfb3BhcXVlIF0pXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpICgpIDogYSB0ID0geyBsZW5ndGggPSAwOyBlbHRzID0gT3B0aW9uX2FycmF5LmVtcHR5IH1cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG4oKiBUaGUgb3JkZXIgaW4gd2hpY2ggZWxlbWVudHMgYXJlIHZpc2l0ZWQgaGFzIGJlZW4gY2hvc2VuIHNvIGFzIHRvIGJlIGJhY2t3YXJkc1xuICAgY29tcGF0aWJsZSB3aXRoIFtTdGRsaWIuU3RhY2tdICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAhciAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbmVuZClcblxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfbGlzdCAodHlwZSBhKSAobCA6IGEgbGlzdCkgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxcbiAgdGhlbiBjcmVhdGUgKClcbiAgZWxzZSAoXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjooMiAqIGxlbmd0aCkgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgZm9yIGkgPSBsZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgT3B0aW9uX2FycmF5LnNldF9zb21lIGVsdHMgaSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHsgbGVuZ3RoOyBlbHRzIH0pXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAoTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHJlc2l6ZSB0IHNpemUgPVxuICBsZXQgYXJyID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOnNpemUgaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfnNyYzp0LmVsdHMgfmRzdDphcnIgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46dC5sZW5ndGg7XG4gIHQuZWx0cyA8LSBhcnJcbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBuZXdfY2FwYWNpdHkgPVxuICBsZXQgbmV3X2NhcGFjaXR5ID0gbWF4IG5ld19jYXBhY2l0eSAobGVuZ3RoIHQpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0IHRoZW4gcmVzaXplIHQgbmV3X2NhcGFjaXR5XG47O1xuXG5sZXQgcHVzaCB0IGEgPVxuICBpZiB0Lmxlbmd0aCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzIHRoZW4gcmVzaXplIHQgKDIgKiAodC5sZW5ndGggKyAxKSk7XG4gIE9wdGlvbl9hcnJheS5zZXRfc29tZSB0LmVsdHMgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgcG9wX25vbmVtcHR5IHQgPVxuICBsZXQgaSA9IHQubGVuZ3RoIC0gMSBpblxuICBsZXQgcmVzdWx0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGk7XG4gIHQubGVuZ3RoIDwtIGk7XG4gIHJlc3VsdFxuOztcblxubGV0IHBvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnBvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgcG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9ub25lbXB0eSB0KVxubGV0IHBvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSBwb3BfZXJyb3IgZWxzZSBwb3Bfbm9uZW1wdHkgdFxubGV0IHRvcF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgKHQubGVuZ3RoIC0gMSlcbmxldCB0b3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay50b3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHRvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3Bfbm9uZW1wdHkgdClcbmxldCB0b3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgdG9wX2Vycm9yIGVsc2UgdG9wX25vbmVtcHR5IHRcbmxldCBjb3B5IHsgbGVuZ3RoOyBlbHRzIH0gPSB7IGxlbmd0aDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jb3B5IGVsdHMgfVxuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDApXG47O1xuXG5sZXQgdW50aWxfZW1wdHkgdCBmID1cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGYgKHBvcF9ub25lbXB0eSB0KTtcbiAgICAgIGxvb3AgKCkpXG4gIGluXG4gIGxvb3AgKCkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgbWF0Y2ggZiAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+IHB1c2ggdF9yZXN1bHQgeFxuICBkb25lO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgeCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgICBpZiBmIHggdGhlbiBwdXNoIHRfcmVzdWx0IHhcbiAgZG9uZTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHdyaXRlX2luZGV4ID0gcmVmIDAgaW5cbiAgRXhuLnByb3RlY3RcbiAgICB+ZjooZnVuICgpIC0+XG4gICAgICBmb3IgcmVhZF9pbmRleCA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICAgIGxldCB4ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQuZWx0cyByZWFkX2luZGV4IGluXG4gICAgICAgIGlmIGYgeFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpZiAhd3JpdGVfaW5kZXggPCByZWFkX2luZGV4XG4gICAgICAgICAgdGhlbiBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyAhd3JpdGVfaW5kZXggeDtcbiAgICAgICAgICBpbmNyIHdyaXRlX2luZGV4KVxuICAgICAgZG9uZSlcbiAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICBmb3IgaSA9ICF3cml0ZV9pbmRleCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSB0LmVsdHMgaVxuICAgICAgZG9uZTtcbiAgICAgIHQubGVuZ3RoIDwtICF3cml0ZV9pbmRleCkgW0Bub250YWlsXVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgcHVzaCB0IHg7XG4gIHRcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfc3RhY2tfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDUiLCJhMiIsImEzIiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfSW1wb3J0IiwiQmFzZV9PcHRpb25fYXJyYXkiLCJCYXNlX0V4biIsIkJhc2VfRXJyb3IiLCJCYXNlX0xpc3QiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfU2V4cCIsIkJhc2VfQ29udGFpbmVyIiwicmFpc2VfcyIsImNzdF9zdGFjayIsImNzdF9leG4iLCJjc3RfU3RhY2tfaW52YXJpYW50X2ZhaWxlZCIsImNhcGFjaXR5IiwidCIsImludmFyaWFudCIsImludmFyaWFudF9hIiwibGVuZ3RoIiwiZWx0cyIsImkiLCJleG4iLCJvZl9hXzAwMSIsImxlbmd0aF8wMDMiLCJlbHRzXzAwNSIsImFyZ18wMDYiLCJibmRzXzAwMiIsImFyZ18wMDQiLCJjcmVhdGUiLCJwYXJhbSIsImlzX2VtcHR5IiwiZm9sZCIsImluaXQiLCJyIiwiaXRlciIsIkMiLCJtZW0iLCJleGlzdHMiLCJmb3JfYWxsIiwiY291bnQiLCJzdW0iLCJmaW5kIiwiZmluZF9tYXAiLCJ0b19saXN0IiwidG9fYXJyYXkiLCJtaW5fZWx0IiwibWF4X2VsdCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsIm9mX2xpc3QiLCJsIiwibWF0Y2giLCJhIiwic2V4cF9vZl90Iiwic2V4cF9vZl9hIiwidF9vZl9zZXhwIiwiYV9vZl9zZXhwIiwic2V4cCIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsInJlc2l6ZSIsInNpemUiLCJhcnIiLCJzZXRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJwdXNoIiwicG9wX25vbmVtcHR5IiwicmVzdWx0IiwicG9wX2Vycm9yIiwicG9wIiwicG9wX2V4biIsInRvcF9ub25lbXB0eSIsInRvcF9lcnJvciIsInRvcCIsInRvcF9leG4iLCJjb3B5IiwiY2xlYXIiLCJ1bnRpbF9lbXB0eSIsImZpbHRlcl9tYXAiLCJ0X3Jlc3VsdCIsIngiLCJmaWx0ZXIiLCJmaWx0ZXJfaW5wbGFjZSIsIndyaXRlX2luZGV4IiwicmVhZF9pbmRleCIsInNpbmdsZXRvbiIsIkJhc2VfU3RhY2siXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFB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TUFqRXVEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxSjFEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjU5OTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuKCogVGhpcyBpcyBsaWZ0ZWQgb3V0IG9mIFtNXSBiZWNhdXNlIFtTb3VyY2VfY29kZV9wb3NpdGlvbjBdIGV4cG9ydHMgW1N0cmluZzBdXG4gICBhcyBbU3RyaW5nXSwgd2hpY2ggZG9lcyBub3QgZXhwb3J0IGEgaGFzaCBmdW5jdGlvbi4gKilcbmxldCBoYXNoX292ZXJyaWRlIHsgU3RkbGliLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfYm9sOyBwb3NfY251bSB9ID1cbiAgU3RyaW5nLmhhc2ggcG9zX2ZuYW1lXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2xudW1cbiAgbHhvciBJbnQuaGFzaCBwb3NfYm9sXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2NudW1cbjs7XG5cbm1vZHVsZSBNID0gc3RydWN0XG4gIGluY2x1ZGUgU291cmNlX2NvZGVfcG9zaXRpb24wXG5cbiAgbGV0IGhhc2ggPSBoYXNoX292ZXJyaWRlXG5lbmRcblxuaW5jbHVkZSBNXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChNKVxuXG5sZXQgZXF1YWxfX2xvY2FsIGEgYiA9IGVxdWFsX2ludCAoY29tcGFyZV9fbG9jYWwgYSBiKSAwXG5cbmxldCBvZl9wb3MgKHBvc19mbmFtZSwgcG9zX2xudW0sIHBvc19jbnVtLCBfKSA9XG4gIHsgcG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgPSAwIH1cbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0ludCIsIkJhc2VfU291cmNlX2NvZGVfcG9zaXRpb24wIiwiQmFzZV9Db21wYXJhYmxlIiwiaGFzaF9vdmVycmlkZSIsInBhcmFtIiwicG9zX2NudW0iLCJwb3NfYm9sIiwicG9zX2xudW0iLCJwb3NfZm5hbWUiLCJjb21wYXJlX2xvY2FsIiwiaGFzaF9mb2xkX3QiLCJjb21wYXJhdG9yIiwidG9fc3RyaW5nIiwic2V4cF9vZl90IiwiaW5jbHVkZSIsInN5bWJvbCIsImVxdWFsIiwiY29tcGFyZSIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJlcXVhbF9sb2NhbCIsImEiLCJiIiwib2ZfcG9zIiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsWUFBQUMsY0FBQUM7QUFBQUE7QUFBQUEsS0FBQUMsV0NJa0I7QUFBQSxLQUFBQyxVQUFBO0FBQUEsS0FBQUMsV0FBQTtBQUFBLEtBQUFDLFlBQUE7QUFBQSxTQUlYO0FBQUEsU0FEQTtBQUFBLFNBREE7QUFBQSxTQURMO0FBQUE7QUFBQTtBQUFBLElBRXFCLHdDQUNDO0FBQUE7QUFBQTtBQUFBLElBQUFDLGdCRFJ4QjtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQWIsZUFBQTtBQUFBLFlBQUFjLFlBQUFDLEdBQUFDO0FBQUFBLFFBQUEsSUNvQmlDO0FBQUEsSUFBb0IseUNBQUU7QUFBQTtBQUFBLFlBQUFDLE9BQUF4QjtBQUFBQSxRQUFBQyxXQUU1QyxVQUFBRSxXQUFBLFVBQUFDLFlBQUE7QUFBQSxJQUNUO0FBQUEsR0FBOEM7QUFBQTtBQUFBLElBQUFxQjtBQUFBQSxNRHZCaEQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNjA5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zaWduX29yX25hbi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmVnXG4gICAgfCBaZXJvXG4gICAgfCBQb3NcbiAgICB8IE5hblxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ25fb3JfbmFuLm1sLlQudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgIHwgTmFuIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5hblwiXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlBvc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgKGZ1biBoc3YgYXJnIC0+XG4gICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50XG4gICAgICAgICBoc3ZcbiAgICAgICAgIChtYXRjaCBhcmcgd2l0aFxuICAgICAgICAgIHwgTmVnIC0+IDBcbiAgICAgICAgICB8IFplcm8gLT4gMVxuICAgICAgICAgIHwgUG9zIC0+IDJcbiAgICAgICAgICB8IE5hbiAtPiAzKVxuICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gIDs7XG5cbiAgbGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zOyBOYW4gXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnbl9vcl9uYW5cIlxuZW5kXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogVC50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogVC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBULnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IFQudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBULnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogVC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgb2Zfc2lnbiA9IGZ1bmN0aW9uXG4gIHwgU2lnbi5OZWcgLT4gTmVnXG4gIHwgU2lnbi5aZXJvIC0+IFplcm9cbiAgfCBTaWduLlBvcyAtPiBQb3Ncbjs7XG5cbmxldCB0b19zaWduX2V4biA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFNpZ24uTmVnXG4gIHwgWmVybyAtPiBTaWduLlplcm9cbiAgfCBQb3MgLT4gU2lnbi5Qb3NcbiAgfCBOYW4gLT4gaW52YWxpZF9hcmcgXCJCYXNlLlNpZ25fb3JfbmFuLnRvX3NpZ25fZXhuOiBOYW5cIlxuOztcblxubGV0IG9mX2ludCBuID0gb2Zfc2lnbiAoU2lnbi5vZl9pbnQgbilcbmxldCB0b19pbnRfZXhuIHQgPSBTaWduLnRvX2ludCAodG9fc2lnbl9leG4gdClcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG4gIHwgTmFuIC0+IE5hblxuOztcblxubGV0ICggKiApIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTmFuLCBfIHwgXywgTmFuIC0+IE5hblxuICB8IF8gLT4gb2Zfc2lnbiAoU2lnbi4oICogKSAodG9fc2lnbl9leG4gdCkgKHRvX3NpZ25fZXhuIHQnKSlcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gXCJuZWdhdGl2ZVwiXG4gIHwgWmVybyAtPiBcInplcm9cIlxuICB8IFBvcyAtPiBcInBvc2l0aXZlXCJcbiAgfCBOYW4gLT4gXCJub3QtYS1udW1iZXJcIlxuOztcblxuKCogSW5jbHVkZSBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBhbnkgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdFxuICAgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X05hbiIsImNzdF9OZWciLCJjc3RfUG9zIiwiY3N0X1plcm8iLCJjc3RfbmFuIiwiY3N0X25lZyIsImNzdF9wb3MiLCJjc3RfemVybyIsImNhbWxfaW50X2NvbXBhcmUiLCJnbG9iYWxfZGF0YSIsImVycm9yX3NvdXJjZV8wMDMiLCJ0X3NleHBfZ3JhbW1hciIsImFsbCIsIm1vZHVsZV9uYW1lIiwiQmFzZV9TaWduIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1BvbHkwIiwiQmFzZV9IYXNoIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiQmFzZV9JZGVudGlmaWFibGUiLCJ0X29mX3NleHAiLCJzZXhwXzAwNCIsIm1hdGNoIiwic2V4cF9vZl90IiwicGFyYW0iLCJjb21wYXJlIiwiaGFzaF9mb2xkX3QiLCJoc3YiLCJhcmciLCJoYXNoIiwib2Zfc3RyaW5nIiwicyIsInRvX3N0cmluZyIsInQiLCJzeW1ib2wiLCJ4IiwieSIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJjb21wYXJlX2xvY2FsIiwiZXF1YWwiLCJlcXVhbF9sb2NhbCIsIm1heCIsIm1pbiIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJwcCIsImhhc2hhYmxlIiwiY3N0X0Jhc2VfU2lnbl9vcl9uYW5fdG9fc2lnbl9lIiwiY3N0X25lZ2F0aXZlIiwiY3N0X3Bvc2l0aXZlIiwiY3N0X25vdF9hX251bWJlciIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsIm9mX2ludCIsIm4iLCJ0b19pbnRfZXhuIiwiZmxpcCIsInRvX3N0cmluZ19odW0iLCJCYXNlX1NpZ25fb3JfbmFuIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsUUNZSztBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBO0FBQUFBO0FBQUFB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QWUsUUFBZiw0QkFBZTtBQUFBLFlBQUFDLFdBQUF6QjtBQUFBQSxRQUFBLElBQ1A7QUFBQSxJQUFlO0FBQUE7QUFBQSxZQUFBMEIsS0FBQW5DO0FBQUFBLElBRW5DO0FBQUE7QUFBQSxPQUNBO0FBQUE7QUFBQSxPQUNDO0FBQUE7QUFBQSxPQUNEO0FBQUEsZUFDQTtBQUFBO0FBQUEsR0FBRztBQUFBLFlBQUFVLFNBQUFELEtBQUFBO0FBQUFBLElBSVo7QUFBQSxhQUUyQyxvQkFBaEI7QUFBQSxLQUFaLE9BQTZDLFFBQTdDLCtCQUE2QztBQUFBO0FBQUEsSUFEdkM7QUFBQSxHQUN1QztBQUFBLFlBQUEyQixjQUFBcEM7QUFBQUEsSUFHMUM7QUFBQTtBQUFBLE9BQ1Q7QUFBQTtBQUFBLE9BQ0M7QUFBQTtBQUFBLE9BQ0Q7QUFBQSxlQUNBO0FBQUE7QUFBQSxHQUFjO0FBQUE7QUFBQSxJQUFBcUM7QUFBQUEsTUF0RXJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDdFSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MzU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1NleHAiLCJCYXNlX0NvbXBhcmFibGUiLCJzeW1ib2wiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiaGFzaCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsImVxdWFsIiwiY29tcGFyZSIsIk5vdF9mb3VuZF9zIiwiT2Zfc2V4cF9lcnJvciIsIm1lc3NhZ2UiLCJkZWZhdWx0X2luZGVudCIsInBwX2h1bSIsInBwX2h1bV9pbmRlbnQiLCJwcF9tYWNoIiwicHAiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJ0b19zdHJpbmciLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsImVxdWFsX2xvY2FsIiwiY29tcGFyZV9sb2NhbCIsInRfc2V4cF9ncmFtbWFyIiwiaW52YXJpYW50Iiwib2Zfc3RyaW5nIiwiQmFzZV9TZXhwX3dpdGhfY29tcGFyYWJsZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNjQ1NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkRlZmluaXRpb25zIiwiQmFzZV9EaWN0aW9uYXJ5X2ltbXV0YWJsZV9pbnRmIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQ0FBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NDcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9EaWN0aW9uYXJ5X2ltbXV0YWJsZSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLDRCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjY0ODMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX0hhc2hlciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGNBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNjQ5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICB8IEluY2wgb2YgJ2FcbiAgfCBFeGNsIG9mICdhXG4gIHwgVW5ib3VuZGVkXG5bQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXIsIGdsb2JhbGl6ZV1cblxubGV0IGFsbCA6ICdhLiAnYSBsaXN0IC0+ICdhIHQgbGlzdCA9XG4gIGZ1biBfYWxsX29mX2EgLT5cbiAgUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgfCBlbnVtZXJhdGVfXzAwMV8gOjogbCAtPiBtYXAgbCAoSW5jbCBlbnVtZXJhdGVfXzAwMV8gOjogYWNjKVxuICAgICBpblxuICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgIChQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICAgICB8IGVudW1lcmF0ZV9fMDAyXyA6OiBsIC0+IG1hcCBsIChFeGNsIGVudW1lcmF0ZV9fMDAyXyA6OiBhY2MpXG4gICAgICAgIGluXG4gICAgICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgICAgWyBVbmJvdW5kZWQgXSlcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDE4XykgOiAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XyB0KSAtPlxuICBsZXQgZXJyb3Jfc291cmNlX18wMDZfID0gXCJtYXliZV9ib3VuZC5tbC50XCIgaW5cbiAgZnVuIF9vZl9hX18wMDNfIC0+IGZ1bmN0aW9uXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIF90YWdfXzAwOV8pIDo6IHNleHBfYXJnc19fMDEwXykgYXNcbiAgICAgIF9zZXhwX18wMDhfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTBfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDExXyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgIEluY2wgcmVzMF9fMDEyX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDA5X1xuICAgICAgICAgICBfc2V4cF9fMDA4XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgX3RhZ19fMDE0XykgOjogc2V4cF9hcmdzX18wMTVfKSBhc1xuICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNV8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTZfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2FfXzAwM18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgRXhjbCByZXMwX18wMTdfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMTRfXG4gICAgICAgICAgIF9zZXhwX18wMTNfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgLT4gVW5ib3VuZGVkXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5jbFwiIHwgXCJJbmNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJleGNsXCIgfCBcIkV4Y2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSA6OiBfKSBhc1xuICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBzZXhwX18wMDVfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gKHR5cGUgYV9fMDI0XykgOiAoKGFfXzAyNF8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMjRfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2FfXzAxOV8gLT4gZnVuY3Rpb25cbiAgfCBJbmNsIGFyZzBfXzAyMF8gLT5cbiAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmNsXCI7IHJlczBfXzAyMV8gXVxuICB8IEV4Y2wgYXJnMF9fMDIyXyAtPlxuICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4Y2xcIjsgcmVzMF9fMDIzXyBdXG4gIHwgVW5ib3VuZGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuYm91bmRlZFwiXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJJbmNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFeGNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiVW5ib3VuZGVkXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICBmdW4gKHR5cGUgYV9fMDI1XykgOiAoKGFfXzAyNV8gLT4gYV9fMDI1XykgLT4gYV9fMDI1XyB0IC0+IGFfXzAyNV8gdCkgLT5cbiAgZnVuIF9nbG9iYWxpemVfYV9fMDI2XyB4X18wMjdfIC0+XG4gIG1hdGNoIHhfXzAyN18gd2l0aFxuICB8IFVuYm91bmRlZCBhcyB4X18wMjhfIC0+IHhfXzAyOF9cbiAgfCBJbmNsIGFyZ19fMDI5XyAtPiBJbmNsIChfZ2xvYmFsaXplX2FfXzAyNl8gYXJnX18wMjlfKVxuICB8IEV4Y2wgYXJnX18wMzBfIC0+IEV4Y2wgKF9nbG9iYWxpemVfYV9fMDI2XyBhcmdfXzAzMF8pXG47O1xuXG5bQEBAZW5kXVxuXG50eXBlIGludGVydmFsX2NvbXBhcmlzb24gPVxuICB8IEJlbG93X2xvd2VyX2JvdW5kXG4gIHwgSW5fcmFuZ2VcbiAgfCBBYm92ZV91cHBlcl9ib3VuZFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbmxldCBpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDMzXyA9IFwibWF5YmVfYm91bmQubWwuaW50ZXJ2YWxfY29tcGFyaXNvblwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgLT4gQmVsb3dfbG93ZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIC0+IEluX3JhbmdlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSAtPiBBYm92ZV91cHBlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAzNF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDM0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSA6OiBfKSBhcyBzZXhwX18wMzRfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMzRfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMzJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDMyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDMyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDMyX1xuICAgfCBzZXhwX18wMzJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMzNfIHNleHBfXzAzMl9cbiAgICA6IFNleHBsaWIwLlNleHAudCAtPiBpbnRlcnZhbF9jb21wYXJpc29uKVxuOztcblxubGV0IHNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW5jdGlvblxuICAgfCBCZWxvd19sb3dlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJCZWxvd19sb3dlcl9ib3VuZFwiXG4gICB8IEluX3JhbmdlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluX3JhbmdlXCJcbiAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQWJvdmVfdXBwZXJfYm91bmRcIlxuICAgIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKGludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbWFyIDogaW50ZXJ2YWxfY29tcGFyaXNvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkJlbG93X2xvd2VyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJJbl9yYW5nZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiQWJvdmVfdXBwZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbl9fbG9jYWwgPVxuICAoU3RkbGliLmNvbXBhcmUgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW4gYSBiIC0+IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbl9fbG9jYWwgYSBiXG4gICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IChoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiA6XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludFxuICAgICAgIGhzdlxuICAgICAgIChtYXRjaCBhcmcgd2l0aFxuICAgICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IDBcbiAgICAgICAgfCBJbl9yYW5nZSAtPiAxXG4gICAgICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gMilcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaF9pbnRlcnZhbF9jb21wYXJpc29uIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24gaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gSW5jbCAoZiBpbmNsKVxuICB8IEV4Y2wgZXhjbCAtPiBFeGNsIChmIGV4Y2wpXG4gIHwgVW5ib3VuZGVkIC0+IFVuYm91bmRlZFxuOztcblxubGV0IGlzX2xvd2VyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgaW5jbCBhIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBleGNsIGEgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBpc191cHBlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGEgaW5jbCA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgYSBleGNsIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIG1hdGNoIGxvd2VyIHdpdGhcbiAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgfCBJbmNsIGxvd2VyIHwgRXhjbCBsb3dlciAtPlxuICAgIChtYXRjaCB1cHBlciB3aXRoXG4gICAgIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gICAgIHwgSW5jbCB1cHBlciB8IEV4Y2wgdXBwZXIgLT4gY29tcGFyZSBsb3dlciB1cHBlciA+IDApXG47O1xuXG5sZXQgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBpZiBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlXG4gIHRoZW4gZmFpbHdpdGggXCJNYXliZV9ib3VuZC5jb21wYXJlX3RvX2ludGVydmFsX2V4bjogbG93ZXIgYm91bmQgPiB1cHBlciBib3VuZFwiXG47O1xuXG5sZXQgY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgY2hlY2tfaW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgfmNvbXBhcmU7XG4gIGlmIG5vdCAoaXNfbG93ZXJfYm91bmQgbG93ZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEJlbG93X2xvd2VyX2JvdW5kXG4gIGVsc2UgaWYgbm90IChpc191cHBlcl9ib3VuZCB1cHBlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQWJvdmVfdXBwZXJfYm91bmRcbiAgZWxzZSBJbl9yYW5nZVxuOztcblxubGV0IGludGVydmFsX2NvbnRhaW5zX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBtYXRjaCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgd2l0aFxuICB8IEluX3JhbmdlIC0+IHRydWVcbiAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IGZhbHNlXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQWJvdmVfdXBwZXJfYm91bmQiLCJjc3RfQmVsb3dfbG93ZXJfYm91bmQiLCJjc3RfRXhjbCIsImNzdF9Jbl9yYW5nZSIsImNzdF9JbmNsIiwiY3N0X1VuYm91bmRlZCIsImNzdF9hYm92ZV91cHBlcl9ib3VuZCIsImNzdF9iZWxvd19sb3dlcl9ib3VuZCIsImNzdF9leGNsIiwiY3N0X2luX3JhbmdlIiwiY3N0X2luY2wiLCJjc3RfdW5ib3VuZGVkIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImVycm9yX3NvdXJjZV8wMDYiLCJlcnJvcl9zb3VyY2VfMDMzIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9zZXhwX2dyYW1tIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0hhc2giLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX0xpc3QiLCJhbGwiLCJhbGxfb2ZfYSIsImwiLCJhY2MiLCJlbnVtZXJhdGVfMDAyIiwiZW51bWVyYXRlXzAwMSIsInRfb2Zfc2V4cCIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJtYXRjaCIsInRhZ18wMDkiLCJzZXhwX2FyZ3NfMDEwIiwiYXJnMF8wMTEiLCJyZXMwXzAxMiIsInNleHBfYXJnc18wMTUiLCJhcmcwXzAxNiIsInJlczBfMDE3Iiwic2V4cF9vZl90Iiwib2ZfYV8wMTkiLCJwYXJhbSIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZSIsImdsb2JhbGl6ZV9hXzAyNiIsInhfMDI3IiwiYXJnXzAyOSIsImFyZ18wMzAiLCJpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAiLCJzZXhwXzAzNCIsInNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbl9sbyIsImNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImNzdF9NYXliZV9ib3VuZF9jb21wYXJlX3RvX2ludCIsImhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIiwiaHN2IiwiYXJnIiwiaGFzaF9pbnRlcnZhbF9jb21wYXJpc29uIiwibWFwIiwidCIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJhIiwiY29tcGFyZSIsImlzX3VwcGVyX2JvdW5kIiwiYm91bmRzX2Nyb3NzZWQiLCJsb3dlciIsInVwcGVyIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJCYXNlX01heWJlX2JvdW5kIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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LDhCQUNlO0FBQUEsUUFBQUcsVUFEZjtBQUFBLElBR0UsOEJBQ2dCO0FBQUEsUUFBQUMsVUFEaEI7QUFBQSxJQUU4Qix3REFBbUI7QUFBQSxHQUFLO0FBQUEsWUFBQUMsd0JBQUFGLE9BQUFDLE9BQUFMLEdBQUFDO0FBQUFBLElBSXJEO0FBQUEsS0FDRTtBQUFBLElBS0U7QUFBQSxjQUVLO0FBQUEsZUFFQztBQUFBO0FBQUEsWUFBQU0sc0JBQUFILE9BQUFDLE9BQUFMLEdBQUFDO0FBQUFBLElBSVAsc0VBRTBDO0FBQUE7QUFBQTtBQUFBLElBQUFPO0FBQUFBLE1BcERoRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRC9MRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2ODE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL21hcF9pbnRmLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSBPcl9kdXBsaWNhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICBbIGBPayBvZiAnYVxuICAgIHwgYER1cGxpY2F0ZVxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgIHwgYE9rIF9sZWZ0X18wMDNfLCBgT2sgX3JpZ2h0X18wMDRfIC0+IF9jbXBfX2EgX2xlZnRfXzAwM18gX3JpZ2h0X18wMDRfXG4gICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gMFxuICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDVfIGJfXzAwNl8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwNV8gYl9fMDA2X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICB8IGBPayBfbGVmdF9fMDA3XywgYE9rIF9yaWdodF9fMDA4XyAtPiBfY21wX19hIF9sZWZ0X18wMDdfIF9yaWdodF9fMDA4X1xuICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IHRydWVcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDA5XyAtPiBmdW5jdGlvblxuICAgIHwgYE9rIHZfXzAxMF8gLT4gU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgX29mX2FfXzAwOV8gdl9fMDEwXyBdXG4gICAgfCBgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkR1cGxpY2F0ZVwiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gY29tcGFyYXRvcjooJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gKCdrZXksICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICAgICAnayAndi4gKCdrIC0+ICdrIC0+IGludCkgLT4gKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGxldCB0X18wMTNfLCB0X18wMTRfID0gYV9fMDExXyBpblxuICAgIGxldCB0X18wMTVfLCB0X18wMTZfID0gYl9fMDEyXyBpblxuICAgIG1hdGNoIF9jbXBfX2sgdF9fMDEzXyB0X18wMTVfIHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGlmIFN0ZGxpYi4oID09ICkgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAoJ2sgLT4gJ2sgLT4gYm9vbCkgLT4gKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YpIHQgLT4gKCdrLCAndikgdCAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDI3XyBiX18wMjhfIC0+XG4gICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgbGV0IHRfXzAzMV8sIHRfXzAzMl8gPSBiX18wMjhfIGluXG4gICAgU3RkbGliLiggJiYgKVxuICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgKGlmIFN0ZGxpYi4oID09ICkgdF9fMDMwXyB0X18wMzJfXG4gICAgICAgdGhlbiB0cnVlXG4gICAgICAgZWxzZSAoXG4gICAgICAgICBtYXRjaCB0X18wMzBfLCB0X18wMzJfIHdpdGhcbiAgICAgICAgIHwgYExlZnQgX2xlZnRfXzAzM18sIGBMZWZ0IF9yaWdodF9fMDM0XyAtPiBfY21wX192IF9sZWZ0X18wMzNfIF9yaWdodF9fMDM0X1xuICAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAzNV8sIGBSaWdodCBfcmlnaHRfXzAzNl8gLT4gX2NtcF9fdiBfbGVmdF9fMDM1XyBfcmlnaHRfXzAzNl9cbiAgICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAzN18sIGBVbmVxdWFsIF9yaWdodF9fMDM4XyAtPlxuICAgICAgICAgICBsZXQgdF9fMDM5XywgdF9fMDQwXyA9IF9sZWZ0X18wMzdfIGluXG4gICAgICAgICAgIGxldCB0X18wNDFfLCB0X18wNDJfID0gX3JpZ2h0X18wMzhfIGluXG4gICAgICAgICAgIFN0ZGxpYi4oICYmICkgKF9jbXBfX3YgdF9fMDM5XyB0X18wNDFfKSAoX2NtcF9fdiB0X18wNDBfIHRfXzA0Ml8pXG4gICAgICAgICB8IHgsIHkgLT4gU3RkbGliLiggPSApIHggeSkpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdrKVxuICAgICAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICd2KVxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgLT4gKCdrLCAndikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJtYXBfaW50Zi5tbC5TeW1tZXRyaWNfZGlmZl9lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2Zfa19fMDQzXyBfb2Zfdl9fMDQ0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNjdfOyBhcmcxX18wNjhfIF0gLT5cbiAgICAgICAgbGV0IHJlczBfXzA2OV8gPSBfb2Zfa19fMDQzXyBhcmcwX18wNjdfXG4gICAgICAgIGFuZCByZXMxX18wNzBfID1cbiAgICAgICAgICBsZXQgc2V4cF9fMDY2XyA9IGFyZzFfXzA2OF8gaW5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG1hdGNoIHNleHBfXzA2Nl8gd2l0aFxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyBhcyBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIDo6IHNleHBfYXJnc19fMDUwXykgYXNcbiAgICAgICAgICAgICAgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiBhcyBfdGFnX18wNjNfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2NF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDY1XyA9IF9vZl92X18wNDRfIGFyZzBfXzA2NF8gaW5cbiAgICAgICAgICAgICAgICAgICAgYExlZnQgcmVzMF9fMDY1X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjNfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiBhcyBfdGFnX18wNjBfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2MV8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDYyXyA9IF9vZl92X18wNDRfIGFyZzBfXzA2MV8gaW5cbiAgICAgICAgICAgICAgICAgICAgYFJpZ2h0IHJlczBfXzA2Ml9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiBhcyBfdGFnX18wNTFfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA1OF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU5XyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggYXJnMF9fMDU4XyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNTJfOyBhcmcxX18wNTNfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDUyX1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2Zfdl9fMDQ0XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMwX18wNTRfLCByZXMxX18wNTVfXG4gICAgICAgICAgICAgICAgICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNleHBfXzA1Nl9cbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgYFVuZXF1YWwgcmVzMF9fMDU5X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNTFfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuTm9fdmFyaWFudF9tYXRjaCAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgIHNleHBfXzA2Nl9cbiAgICAgICAgaW5cbiAgICAgICAgcmVzMF9fMDY5XywgcmVzMV9fMDcwX1xuICAgICAgfCBzZXhwX18wNzFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgZXJyb3Jfc291cmNlX18wNTdfIDIgc2V4cF9fMDcxX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnayAndi5cbiAgICAgICAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdrLCAndikgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9rX18wNzJfIF9vZl92X18wNzNfIChhcmcwX18wODFfLCBhcmcxX18wODJfKSAtPlxuICAgIGxldCByZXMwX18wODNfID0gX29mX2tfXzA3Ml8gYXJnMF9fMDgxX1xuICAgIGFuZCByZXMxX18wODRfID1cbiAgICAgIG1hdGNoIGFyZzFfXzA4Ml8gd2l0aFxuICAgICAgfCBgTGVmdCB2X18wNzRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX3ZfXzA3M18gdl9fMDc0XyBdXG4gICAgICB8IGBSaWdodCB2X18wNzVfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl92X18wNzNfIHZfXzA3NV8gXVxuICAgICAgfCBgVW5lcXVhbCB2X18wNzZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbFwiXG4gICAgICAgICAgOyAobGV0IGFyZzBfXzA3N18sIGFyZzFfXzA3OF8gPSB2X18wNzZfIGluXG4gICAgICAgICAgICAgbGV0IHJlczBfXzA3OV8gPSBfb2Zfdl9fMDczXyBhcmcwX18wNzdfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzA4MF8gPSBfb2Zfdl9fMDczXyBhcmcxX18wNzhfIGluXG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDc5XzsgcmVzMV9fMDgwXyBdKVxuICAgICAgICAgIF1cbiAgICBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA4M187IHJlczFfXzA4NF8gXVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2tfc2V4cF9ncmFtbWFyIF8ndl9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBMaXN0XG4gICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAoIF8na19zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID0gQ29ucyAoXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJVbmVxdWFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgLCBFbXB0eSApICkpXG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgICAgICdsZWZ0ICdyaWdodC5cbiAgICAgICAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDg1XyBiX18wODZfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wODVfIGJfXzA4Nl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzA4NV8sIGJfXzA4Nl8gd2l0aFxuICAgICAgfCBgTGVmdCBfbGVmdF9fMDg3XywgYExlZnQgX3JpZ2h0X18wODhfIC0+IF9jbXBfX2xlZnQgX2xlZnRfXzA4N18gX3JpZ2h0X18wODhfXG4gICAgICB8IGBSaWdodCBfbGVmdF9fMDg5XywgYFJpZ2h0IF9yaWdodF9fMDkwXyAtPiBfY21wX19yaWdodCBfbGVmdF9fMDg5XyBfcmlnaHRfXzA5MF9cbiAgICAgIHwgYEJvdGggX2xlZnRfXzA5MV8sIGBCb3RoIF9yaWdodF9fMDkyXyAtPlxuICAgICAgICBsZXQgdF9fMDkzXywgdF9fMDk0XyA9IF9sZWZ0X18wOTFfIGluXG4gICAgICAgIGxldCB0X18wOTVfLCB0X18wOTZfID0gX3JpZ2h0X18wOTJfIGluXG4gICAgICAgIChtYXRjaCBfY21wX19sZWZ0IHRfXzA5M18gdF9fMDk1XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fcmlnaHQgdF9fMDk0XyB0X18wOTZfXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuY29tcGFyZSB4IHkpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAgICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fbGVmdCBfY21wX19yaWdodCBhX18wOTdfIGJfXzA5OF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzA5N18gYl9fMDk4X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDk3XywgYl9fMDk4XyB3aXRoXG4gICAgICB8IGBMZWZ0IF9sZWZ0X18wOTlfLCBgTGVmdCBfcmlnaHRfXzEwMF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDk5XyBfcmlnaHRfXzEwMF9cbiAgICAgIHwgYFJpZ2h0IF9sZWZ0X18xMDFfLCBgUmlnaHQgX3JpZ2h0X18xMDJfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18xMDFfIF9yaWdodF9fMTAyX1xuICAgICAgfCBgQm90aCBfbGVmdF9fMTAzXywgYEJvdGggX3JpZ2h0X18xMDRfIC0+XG4gICAgICAgIGxldCB0X18xMDVfLCB0X18xMDZfID0gX2xlZnRfXzEwM18gaW5cbiAgICAgICAgbGV0IHRfXzEwN18sIHRfXzEwOF8gPSBfcmlnaHRfXzEwNF8gaW5cbiAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fbGVmdCB0X18xMDVfIHRfXzEwN18pIChfY21wX19yaWdodCB0X18xMDZfIHRfXzEwOF8pXG4gICAgICB8IHgsIHkgLT4gU3RkbGliLiggPSApIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAgICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICAgICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfbGVmdF9fMTA5XyBfb2ZfcmlnaHRfXzExMF8gLT4gZnVuY3Rpb25cbiAgICB8IGBMZWZ0IHZfXzExMV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX2xlZnRfXzEwOV8gdl9fMTExXyBdXG4gICAgfCBgUmlnaHQgdl9fMTEyXyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3JpZ2h0X18xMTBfIHZfXzExMl8gXVxuICAgIHwgYEJvdGggdl9fMTEzXyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiXG4gICAgICAgIDsgKGxldCBhcmcwX18xMTRfLCBhcmcxX18xMTVfID0gdl9fMTEzXyBpblxuICAgICAgICAgICBsZXQgcmVzMF9fMTE2XyA9IF9vZl9sZWZ0X18xMDlfIGFyZzBfXzExNF9cbiAgICAgICAgICAgYW5kIHJlczFfXzExN18gPSBfb2ZfcmlnaHRfXzExMF8gYXJnMV9fMTE1XyBpblxuICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18xMTZfOyByZXMxX18xMTdfIF0pXG4gICAgICAgIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkNvbnRpbnVlX29yX3N0b3AgKilcbm1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb250aW51ZVxuICAgIHwgU3RvcFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBDb250aW51ZTsgU3RvcCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoU3RkbGliLiggPSApIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgQ29udGludWUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ29udGludWVcIlxuICAgICB8IFN0b3AgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RvcFwiXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuRmluaXNoZWRfb3JfdW5maW5pc2hlZCAqKVxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEZpbmlzaGVkXG4gICAgfCBVbmZpbmlzaGVkXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEZpbmlzaGVkOyBVbmZpbmlzaGVkIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChTdGRsaWIuKCA9ICkgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgfCBGaW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJGaW5pc2hlZFwiXG4gICAgIHwgVW5maW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmZpbmlzaGVkXCJcbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgJ2NtcCBjbXBcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X2ltbXV0YWJsZS5BY2Nlc3NvcnNcbiAgICAgIHdpdGggdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgIGFuZCB0eXBlICgna2V5LCAnZGF0YSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ2RhdGEsICdjbXApIHRcbiAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCBfLCAnY21wKSBhY2Nlc3NvciA6PSAoJ2tleSwgJ2NtcCwgJ2ZuKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNldFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IGxpc3QpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGNoYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgdXBkYXRlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgICAgICAtPiB1bml0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGZvbGRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0XG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2FjYyAtPiAnYWNjKVxuICAgICAgICAtPiAnYWNjIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayBrZXkgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHVuemlwIDogKCdrLCAndjEgKiAndjIsICdjbXApIHQgLT4gKCdrLCAndjEsICdjbXApIHQgKiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21wYXJlX2RpcmVjdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZXF1YWxcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgICAtPiBmOihrZXk6J2sga2V5IC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1lcmdlX2Rpc2pvaW50X2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IGNvbWJpbmU6KGtleTonayBrZXkgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgICAgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KCdhY2MgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVxuICAgICAgICAtPiAnYWNjIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KCd2IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgdmFsIHN1bWlcbiAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICdrIGtleVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrIGtleSAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHNwbGl0X2xlX2d0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbHRfZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBsb3dlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiB1cHBlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBtaW46J2sga2V5XG4gICAgICAgIC0+IG1heDonayBrZXlcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgICAgIC0+ICdhY2MgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayBrZXkgLT4gbWF4OidrIGtleSAtPiAoJ2sga2V5ICogJ3YpIGxpc3QgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgICAgLT4gJ2sga2V5XG4gICAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnayBrZXksICd2LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAgICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonayBrZXlcbiAgICAgICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonayBrZXlcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gY29tcGFyZTooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgICAgLT4gJ2tleVxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gc2VnbWVudF9vZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAgICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA6IHNpZ1xuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIgQS50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgQS50XG5cbiAgICB2YWwgZmlsdGVyX21hcGlcbiAgICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24gQS50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgQS50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0XG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdHJlZVxuICB0eXBlICdrIGtleVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIGNyZWF0ZV9vcHRpb25zXG4gIHR5cGUgKCdhLCAnY21wLCAneikgYWNjZXNzX29wdGlvbnNcbiAgdHlwZSAnY21wIGNtcFxuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X2ltbXV0YWJsZS5DcmVhdG9yc1xuICAgICAgd2l0aCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICdkYXRhLCAnY21wKSB0IDo9ICgna2V5LCAnZGF0YSwgJ2NtcCkgdFxuICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksIF8sICdjbXApIGNyZWF0b3IgOj0gKCdrZXksICdjbXAsICdmbikgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgZW1wdHkgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcbiAgdmFsIHNpbmdsZXRvbiA6ICgnaywgJ2NtcCwgJ2sga2V5IC0+ICd2IC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAgICAgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KVxuICAgICAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIga2V5IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAoICdrMlxuICAgICAgLCAnY21wMlxuICAgICAgLCAoJ2sxLCAndiwgJ2NtcDEpIHQgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KSAtPiAoJ2syLCAndiwgJ2NtcDIpIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgdHJhbnNwb3NlX2tleXNcbiAgICA6ICggJ2sxXG4gICAgICAsICdjbXAxXG4gICAgICAsICggJ2syXG4gICAgICAgICwgJ2NtcDJcbiAgICAgICAgLCAoJ2sxLCAoJ2syLCAnYSwgJ2NtcDIpIHQsICdjbXAxKSB0IC0+ICgnazIsICgnazEsICdhLCAnY21wMSkgdCwgJ2NtcDIpIHQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9ucyApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCBsZW46aW50IC0+IGY6KGludCAtPiAnayBrZXkgKiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBsaXN0IC0+IGluaXQ6J3YyIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF1cbiAgICAgIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgICAgLT4gaW5pdDondjJcbiAgICAgICAgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpXG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdFxuICAgICAgICAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpXG4gICAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdCAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2V4blxuICAgIDogKCdrLCAnY21wLCAndiBsaXN0IC0+IGdldF9rZXk6KCd2IC0+ICdrIGtleSkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9tdWx0aVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICd2IGxpc3QgLT4gZ2V0X2tleTooJ3YgLT4gJ2sga2V5KSAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdFxuICAgICAgICAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpXG4gICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAtPiBmOignYWNjIC0+ICd2IC0+ICdhY2MpXG4gICAgICAgIC0+ICgnaywgJ2FjYywgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICd2IGxpc3QgLT4gZ2V0X2tleTooJ3YgLT4gJ2sga2V5KSAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdCkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdrLCAnY21wLCAoJ2sga2V5LCAndiwgJ2NtcCkgdHJlZSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWVcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAnYSBjbXBcbiAgdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnNcbiAgdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnNcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gICAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIGNtcFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhvdXRfY29tcGFyYXRvci50XG5lbmRcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3RcbiAgICA6ICAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICgndiAtPiBTZXhwLnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBjb21wYXJlX21fX3RcbiAgICA6ICAobW9kdWxlIENvbXBhcmVfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gaW50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsX21fX3RcbiAgICA6ICAobW9kdWxlIEVxdWFsX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGhhc2hfZm9sZF9tX190XG4gICAgOiAgKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+IChIYXNoLnN0YXRlIC0+ICd2IC0+IEhhc2guc3RhdGUpXG4gICAgLT4gSGFzaC5zdGF0ZVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5lbmRcblxubW9kdWxlIHR5cGUgTWFwID0gc2lnXG4gICgqKiBbTWFwXSBpcyBhIGZ1bmN0aW9uYWwgZGF0YSBzdHJ1Y3R1cmUgKGJhbGFuY2VkIGJpbmFyeSB0cmVlKSBpbXBsZW1lbnRpbmcgZmluaXRlIG1hcHNcbiAgICAgIG92ZXIgYSB0b3RhbGx5LW9yZGVyZWQgZG9tYWluLCBjYWxsZWQgYSBcImtleVwiLiAqKVxuXG4gIHR5cGUgKCEna2V5LCArISd2YWx1ZSwgISdjbXApIHRcblxuICBtb2R1bGUgT3JfZHVwbGljYXRlID0gT3JfZHVwbGljYXRlXG4gIG1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gQ29udGludWVfb3Jfc3RvcFxuXG4gIG1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkIDogc2lnXG4gICAgdHlwZSB0ID0gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50ID1cbiAgICAgIHwgRmluaXNoZWRcbiAgICAgIHwgVW5maW5pc2hlZFxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9lbnVtZXJhdGVfbGliLkVudW1lcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogTWFwcyBbQ29udGludWVdIHRvIFtGaW5pc2hlZF0gYW5kIFtTdG9wXSB0byBbVW5maW5pc2hlZF0uICopXG4gICAgdmFsIG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdFxuXG4gICAgKCoqIE1hcHMgW0ZpbmlzaGVkXSB0byBbQ29udGludWVdIGFuZCBbVW5maW5pc2hlZF0gdG8gW1N0b3BdLiAqKVxuICAgIHZhbCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnRcbiAgZW5kXG5cbiAgbW9kdWxlIE1lcmdlX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnbGVmdCwgJ3JpZ2h0KSB0ID1cbiAgICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgICAgfCBgQm90aCBvZiAnbGVmdCAqICdyaWdodFxuICAgICAgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIHZhbCBjb21wYXJlXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBpbnRcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGJvb2wpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBib29sXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2xlZnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdyaWdodCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIGxlZnQgOiAoJ2xlZnQsIF8pIHQgLT4gJ2xlZnQgb3B0aW9uXG4gICAgdmFsIHJpZ2h0IDogKF8sICdyaWdodCkgdCAtPiAncmlnaHQgb3B0aW9uXG4gICAgdmFsIGxlZnRfdmFsdWUgOiAoJ2xlZnQsIF8pIHQgLT4gZGVmYXVsdDonbGVmdCAtPiAnbGVmdFxuICAgIHZhbCByaWdodF92YWx1ZSA6IChfLCAncmlnaHQpIHQgLT4gZGVmYXVsdDoncmlnaHQgLT4gJ3JpZ2h0XG5cbiAgICB2YWwgdmFsdWVzXG4gICAgICA6ICAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gbGVmdF9kZWZhdWx0OidsZWZ0XG4gICAgICAtPiByaWdodF9kZWZhdWx0OidyaWdodFxuICAgICAgLT4gJ2xlZnQgKiAncmlnaHRcbiAgZW5kXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIChsZXQgbWFwID1cbiAgICAgICAgICAgICBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgIFsgXCJhXCIsIDE7IFwiYVwiLCAxMDsgXCJiXCIsIDI7IFwiYlwiLCAyMDsgXCJiXCIsIDIwMCBdXG4gICAgICAgICAgICAgICB+aW5pdDpJbnQuU2V0LmVtcHR5XG4gICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByaW50X3MgWyVzZXhwIChtYXAgOiBJbnQuU2V0LnQgU3RyaW5nLk1hcC50KV0pOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaXRlcmkgfml0ZXJpXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0XSwgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB0YWtpbmcgYSBjb25jcmV0ZVxuICAgICAgZGF0YSBzdHJ1Y3R1cmUsIGl0IHRha2VzIGFuIGl0ZXJhdGlvbiBmdW5jdGlvbi4gIEZvciBpbnN0YW5jZSwgdG8gY29udmVydCBhIHN0cmluZyB0YWJsZVxuICAgICAgaW50byBhIG1hcDogW29mX2l0ZXJpIChtb2R1bGUgU3RyaW5nKSB+ZjooSGFzaHRibC5pdGVyaSB0YWJsZSldLiAgSXQgaXMgZmFzdGVyIHRoYW5cbiAgICAgIGFkZGluZyB0aGUgZWxlbWVudHMgb25lIGJ5IG9uZS4gKilcbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogTGlrZSBbb2ZfaXRlcmldIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXkgYyAoU2VxdWVuY2UudG9fYXJyYXlcbiAgICAgIHNlcSldLCBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBhcnJheS5cblxuICAgICAgVGhlIHNlcXVlbmNlIHdpbGwgYmUgZm9sZGVkIG92ZXIgb25jZSwgYW5kIHRoZSBhZGRpdGlvbmFsIHRpbWUgY29tcGxleGl0eSBpcyB7ZSBPKG4pfS5cbiAgKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0IGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG5cbiAgICAgIElmIHlvdXIgc2VxdWVuY2UgaXMgaW5jcmVhc2luZywgdXNlIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXS5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX29yX2Vycm9yIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X29yX2Vycm9yIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9leG4gYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC5cblxuICAgICAgW29mX3NlcXVlbmNlX211bHRpIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX2ZvbGQgYyBzZXEgfmluaXQgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZm9sZCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmluaXQgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfcmVkdWNlIGMgc2VxIH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X3JlZHVjZSBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDb25zdHJ1Y3RzIGEgbWFwIGZyb20gYSBsaXN0IG9mIHZhbHVlcywgd2hlcmUgW2dldF9rZXldIGV4dHJhY3RzIGEga2V5IGZyb20gYSB2YWx1ZS5cbiAgKilcbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIF1cblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJldHVybnMgW0Vycm9yXSBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvclxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigndiAtPiAnaylcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9leG5cbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcHJvZHVjZXMgbGlzdHMgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrKVxuICAgIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmVzb2x2ZXMgZHVwbGljYXRlIGtleXMgdGhlIHNhbWUgd2F5IFtvZl9hbGlzdF9mb2xkXSBkb2VzLiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrKVxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ3YgLT4gJ2FjYylcbiAgICAtPiAoJ2ssICdhY2MsICdjbXApIHRcblxuICAoKiogTGlrZSBbb2ZfbGlzdF93aXRoX2tleV07IHJlc29sdmVzIGR1cGxpY2F0ZSBrZXlzIHRoZSBzYW1lIHdheSBbb2ZfYWxpc3RfcmVkdWNlXSBkb2VzLiAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleV9yZWR1Y2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBUZXN0cyB3aGV0aGVyIGEgbWFwIGlzIGVtcHR5LiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFtsZW5ndGggbWFwXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gW21hcF0uICBPKDEpLCBidXQgW1RyZWUubGVuZ3RoXSBpc1xuICAgICAgTyhuKS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgbmV3IGJpbmRpbmc7IGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgYm91bmQsIGl0c1xuICAgICAgcHJldmlvdXMgYmluZGluZyBkaXNhcHBlYXJzLiAqKVxuICB2YWwgc2V0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthZGQgdCB+a2V5IH5kYXRhXSBhZGRzIGEgbmV3IGVudHJ5IHRvIFt0XSBtYXBwaW5nIFtrZXldIHRvIFtkYXRhXSBhbmQgcmV0dXJucyBbYE9rXVxuICAgICAgd2l0aCB0aGUgbmV3IG1hcCwgb3IgaWYgW2tleV0gaXMgYWxyZWFkeSBwcmVzZW50IGluIFt0XSwgcmV0dXJucyBbYER1cGxpY2F0ZV0uICopXG4gIHZhbCBhZGQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBJZiBba2V5XSBpcyBub3QgcHJlc2VudCB0aGVuIGFkZCBhIHNpbmdsZXRvbiBsaXN0LCBvdGhlcndpc2UsIGNvbnMgZGF0YSBvbnRvIHRoZVxuICAgICAgaGVhZCBvZiB0aGUgZXhpc3RpbmcgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogSWYgdGhlIGtleSBpcyBwcmVzZW50LCB0aGVuIHJlbW92ZSBpdHMgaGVhZCBlbGVtZW50OyBpZiB0aGUgcmVzdWx0IGlzIGVtcHR5LCByZW1vdmVcbiAgICAgIHRoZSBrZXkuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIHRoZSBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vbmUuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICd2IGxpc3RcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gcmV0dXJucyBhIG5ldyBtYXAgW21dIHRoYXQgaXMgdGhlIHNhbWUgYXMgW3RdIG9uIGFsbCBrZXlzIGV4Y2VwdFxuICAgICAgZm9yIFtrZXldLCBhbmQgd2hvc2UgdmFsdWUgZm9yIFtrZXldIGlzIGRlZmluZWQgYnkgW2ZdLCBpLmUuLCBbZmluZCBtIGtleSA9IGYgKGZpbmRcbiAgICAgIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBbU29tZSB2YWx1ZV0gYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgW05vbmVdIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIHJhaXNpbmcgW1N0ZGxpYi5Ob3RfZm91bmRdIG9yIFtOb3RfZm91bmRfc11cbiAgICAgIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYW55IGJpbmRpbmcgZm9yIHRoZSBrZXkgaW4gcXVlc3Rpb24gcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbbWVtIG1hcCBrZXldIHRlc3RzIHdoZXRoZXIgW21hcF0gY29udGFpbnMgYSBiaW5kaW5nIGZvciBba2V5XS4gKilcbiAgdmFsIG1lbSA6ICgnaywgXywgJ2NtcCkgdCAtPiAnayAtPiBib29sXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIFtmXSByZXR1cm5zIFtTdG9wXS4gSWYgW2ZdIHJldHVybnMgW1N0b3BdLCB0aGUgZmluYWxcbiAgICAgIHJlc3VsdCBpcyBbVW5maW5pc2hlZF0uIE90aGVyd2lzZSwgdGhlIGZpbmFsIHJlc3VsdCBpcyBbRmluaXNoZWRdLiAqKVxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyByZXBsYWNlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiopXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIENvbnZlcnQgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHRvIGEgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHVzaW5nIFtmXS4gKilcbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgKCoqIExpa2UgW21hcF9rZXlzXSwgYnV0IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLCB1bnRpbCB0aGUgZmlyc3RcbiAgICAgIHRpbWUgdGhhdCBbZl0gcmV0dXJucyBbU3RvcCBfXS4gSWYgW2ZdIHJldHVybnMgW1N0b3AgZmluYWxdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgIGltbWVkaWF0ZWx5IHdpdGggdGhlIHZhbHVlIFtmaW5hbF0uIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCBhbmQgdGhlIGZpbmFsXG4gICAgICBjYWxsIHRvIFtmXSByZXR1cm5zIFtDb250aW51ZSBsYXN0XSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFtmaW5pc2ggbGFzdF0uICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBkZWNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZF9yaWdodFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBGb2xkcyBvdmVyIHR3byBtYXBzIHNpZGUgYnkgc2lkZSwgbGlrZSBbaXRlcjJdLiAqKVxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICAoKiogW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl9tYXBpXSBydW4gaW4gTyhuKVxuICAgICAgdGltZS5cblxuICAgICAgW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW3BhcnRpdGlvbl90Zl0gYW5kIFtwYXJ0aXRpb25pX3RmXSBrZWVwIGEgbG90XG4gICAgICBvZiBzaGFyaW5nIGJldHdlZW4gdGhlaXIgcmVzdWx0IGFuZCB0aGUgb3JpZ2luYWwgbWFwLiAgRHJvcHBpbmcgb3Iga2VlcGluZyBhIHJ1biBvZlxuICAgICAgW2tdIGNvbnNlY3V0aXZlIGVsZW1lbnRzIGNvc3RzIFtPKGxvZyhrKSldIGV4dHJhIG1lbW9yeS4gS2VlcGluZyB0aGUgZW50aXJlIG1hcFxuICAgICAgY29zdHMgbm8gZXh0cmEgbWVtb3J5IGF0IGFsbDogW2ZpbHRlciB+ZjooZnVuIF8gLT4gdHJ1ZSldIHJldHVybnMgdGhlIG9yaWdpbmFsIG1hcC5cbiAgKilcbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyBmaWx0ZXJlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXBpIHQgfmZdIHJldHVybnMgdHdvIG5ldyBbdF1zLCB3aXRoIGVhY2gga2V5IGluIFt0XSBhcHBlYXJpbmcgaW5cbiAgICAgIGV4YWN0bHkgb25lIG9mIHRoZSByZXN1bHRpbmcgbWFwcyBkZXBlbmRpbmcgb24gaXRzIG1hcHBpbmcgaW4gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUHJvZHVjZXMgW09rXSBvZiBhIG1hcCBpbmNsdWRpbmcgYWxsIGtleXMgaWYgYWxsIGRhdGEgaXMgW09rXSwgb3IgYW4gW0Vycm9yXVxuICAgICAgaW5jbHVkaW5nIGFsbCBlcnJvcnMgb3RoZXJ3aXNlLiAqKVxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIEdpdmVuIGEgbWFwIG9mIHR1cGxlcywgcHJvZHVjZXMgYSB0dXBsZSBvZiBtYXBzLiBFcXVpdmFsZW50IHRvOlxuICAgICAgW21hcCB0IH5mOmZzdCwgbWFwIHQgfmY6c25kXSAqKVxuICB2YWwgdW56aXAgOiAoJ2ssICd2MSAqICd2MiwgJ2NtcCkgdCAtPiAoJ2ssICd2MSwgJ2NtcCkgdCAqICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgYSB0b3RhbCBvcmRlcmluZyBiZXR3ZWVuIG1hcHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHRvdGFsIG9yZGVyaW5nIHVzZWRcbiAgICAgIHRvIGNvbXBhcmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXF1YWwga2V5cyBpbiB0aGUgdHdvIG1hcHMuICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIG1hcHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgbSkuY29tcGFyZV0gb2YgdGhlIG1hcCBbbV0gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnayBIYXNoLmZvbGRlciAtPiAndiBIYXNoLmZvbGRlciAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCBjbXAgbTEgbTJdIHRlc3RzIHdoZXRoZXIgdGhlIG1hcHMgW20xXSBhbmQgW20yXSBhcmUgZXF1YWwsIHRoYXQgaXMsIGNvbnRhaW5cbiAgICAgIHRoZSBzYW1lIGtleXMgYW5kIGFzc29jaWF0ZSBlYWNoIGtleSB3aXRoIHRoZSBzYW1lIHZhbHVlLiAgW2NtcF0gaXMgdGhlIGVxdWFsaXR5XG4gICAgICBwcmVkaWNhdGUgdXNlZCB0byBjb21wYXJlIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sgbGlzdFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgKCoqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBmcm9tIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gKCoqIGRlZmF1bHQgaXMgW2BJbmNyZWFzaW5nXSAqKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiB7MiBBZGRpdGlvbmFsIG9wZXJhdGlvbnMgb24gbWFwc30gKilcblxuICAoKiogTWVyZ2VzIHR3byBtYXBzLiBUaGUgcnVudGltZSBpcyBPKGxlbmd0aCh0MSkgKyBsZW5ndGgodDIpKS4gWW91IHNob3VsZG4ndCB1c2UgdGhpc1xuICAgICAgZnVuY3Rpb24gdG8gbWVyZ2UgYSBsaXN0IG9mIG1hcHM7IGNvbnNpZGVyIHVzaW5nIFttZXJnZV9kaXNqb2luX2V4bl0gb3JcbiAgICAgIFttZXJnZV9za2V3ZWRdIGluc3RlYWQuICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBNZXJnZXMgdHdvIGRpY3Rpb25hcmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgb2YgZGF0YSBhbmQgZGlzam9pbnQgc2V0cyBvZiBrZXlzLlxuICAgICAgUmFpc2VzIGlmIGFueSBrZXlzIG92ZXJsYXAuICopXG4gIHZhbCBtZXJnZV9kaXNqb2ludF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICAgIDogICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gcmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uXG4gICAgICBJdCBpcyBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudFxuICAgICAgb2Ygc3RydWN0dXJlLiBUaGUga2V5cyBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlIHdpbGwgYmUgaW4gc29ydGVkIG9yZGVyLlxuXG4gICAgICBJdCBpcyBhc3N1bWVkIHRoYXQgW2RhdGFfZXF1YWxdIGlzIGF0IGxlYXN0IGFzIGVxdWF0aW5nIGFzIHBoeXNpY2FsIGVxdWFsaXR5OiB0aGF0XG4gICAgICBbcGh5c19lcXVhbCB4IHldIGltcGxpZXMgW2RhdGFfZXF1YWwgeCB5XS4gT3RoZXJ3aXNlLCBbc3ltbWV0cmljX2RpZmZdIG1heSBiZWhhdmUgaW5cbiAgICAgIHVuZXhwZWN0ZWQgd2F5cy4gRm9yIGV4YW1wbGUsIHdpdGggW35kYXRhX2VxdWFsOihmdW4gXyBfIC0+IGZhbHNlKV0gaXQgaXMgTk9UXG4gICAgICBuZWNlc3NhcmlseSB0aGUgY2FzZSB0aGUgcmVzdWx0aW5nIGNoYW5nZSBzZXF1ZW5jZSB3aWxsIGNvbnRhaW4gYW4gZWxlbWVudFxuICAgICAgWyhrLCBgVW5lcXVhbCBfKV0gZm9yIGV2ZXJ5IGtleSBba10gc2hhcmVkIGJ5IGJvdGggbWFwcy5cblxuICAgICAgV2FybmluZzogRmxvYXQgZXF1YWxpdHkgdmlvbGF0ZXMgdGhpcyBwcm9wZXJ0eSEgW3BoeXNfZXF1YWwgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXNcbiAgICAgIHRydWUsIGJ1dCBbRmxvYXQuKD0pIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzIGZhbHNlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW2ZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIGZvbGRzIGFjcm9zcyBhbiBpbXBsaWNpdCBzZXF1ZW5jZSBvZiBjaGFuZ2VzXG4gICAgICBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0sIGluIHNvcnRlZCBvcmRlciBieSBrZXlzLiBFcXVpdmFsZW50IHRvXG4gICAgICBbU2VxdWVuY2UuZm9sZCAoc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwpXSwgYW5kIG1vcmUgZWZmaWNpZW50LiAqKVxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICAoKiogW21pbl9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1pbmltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBbbWF4X2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWF4aW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgW21hcF0gaXMgZW1wdHkuICopXG4gIHZhbCBtYXhfZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFN3YXAgdGhlIGlubmVyIGFuZCBvdXRlciBrZXlzIG9mIG5lc3RlZCBtYXBzLiBJZiBbdHJhbnNwb3NlX2tleXMgbSBhID0gYl0sIHRoZW5cbiAgICAgIFtmaW5kX2V4biAoZmluZF9leG4gYSBpKSBqID0gZmluZF9leG4gKGZpbmRfZXhuIGIgaikgaV0uICopXG4gIHZhbCB0cmFuc3Bvc2Vfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgKCdrMiwgJ3YsICdjbXAyKSB0LCAnY21wMSkgdFxuICAgIC0+ICgnazIsICgnazEsICd2LCAnY21wMSkgdCwgJ2NtcDIpIHRcblxuICAoKiogVGhlc2UgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHNpbWlsYXIgZnVuY3Rpb25zIGluIFtMaXN0XS4gKilcblxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooJ3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICB2YWwgc3VtaVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFtzcGxpdCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSwgdGhlIG1hcHBpbmcgb2YgW2tleV0gaWZcbiAgICAgIGFueSwgYW5kIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtzcGxpdF9sZV9ndCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHRoYXQgYXJlIGxlc3Mgb3IgZXF1YWwgdG8gW2tleV0gYW5kIGFcbiAgICAgIG1hcCBvZiBrZXlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdF9sZV9ndCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3NwbGl0X2x0X2dlIHQga2V5XSByZXR1cm5zIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrZXldIGFuZCBhIG1hcCBvZlxuICAgICAga2V5cyB0aGF0IGFyZSBncmVhdGVyIG9yIGVxdWFsIHRvIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0X2x0X2dlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0XSByZXR1cm5zIFtgT2sgbWFwXSB3aGVyZSBbbWFwXSBjb250YWlucyBhbGwgdGhlXG4gICAgICBbKGtleSwgdmFsdWUpXSBwYWlycyBmcm9tIHRoZSB0d28gaW5wdXQgbWFwcyBpZiBhbGwgdGhlIGtleXMgZnJvbSBbbG93ZXJfcGFydF0gYXJlXG4gICAgICBsZXNzIHRoYW4gYWxsIHRoZSBrZXlzIGZyb20gW3VwcGVyX3BhcnRdLiAgT3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgIFtgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc10uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbikgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VyIGlucHV0IG1hcC4gIFRoaXMgY2FuIGJlXG4gICAgICBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIFtNYXAubWVyZ2VdIG9yIHJlcGVhdGVkIFtNYXAuYWRkXS5cblxuICAgICAge1tcbiAgICAgICAgYXNzZXJ0IChtYXRjaCBNYXAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IHdpdGhcbiAgICAgICAgICB8IGBPayB3aG9sZV9tYXAgLT5cbiAgICAgICAgICAgIE1hcC50b19hbGlzdCB3aG9sZV9tYXBcbiAgICAgICAgICAgID0gTGlzdC5hcHBlbmQgKHRvX2FsaXN0IGxvd2VyX3BhcnQpICh0b19hbGlzdCB1cHBlcl9wYXJ0KVxuICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gdHJ1ZSk7XG4gICAgICBdfSAqKVxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICAoKiogW3N1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZF0gcmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUgZW50cmllcyBmcm9tXG4gICAgICBbdF0gd2hvc2Uga2V5cyBsaWUgaW5zaWRlIHRoZSBpbnRlcnZhbCBpbmRpY2F0ZWQgYnkgW35sb3dlcl9ib3VuZF0gYW5kXG4gICAgICBbfnVwcGVyX2JvdW5kXS4gIElmIHRoaXMgaW50ZXJ2YWwgaXMgZW1wdHksIGFuIGVtcHR5IG1hcCBpcyByZXR1cm5lZC5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIG91dHB1dCBtYXAuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIG91dHB1dCBtYXAuICopXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2ZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mXSBmb2xkcyBbZl0gKHdpdGggaW5pdGlhbCB2YWx1ZSBbfmluaXRdKVxuICAgICAgb3ZlciBhbGwga2V5cyAoYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzKSB0aGF0IGFyZSBpbiB0aGUgcmFuZ2UgW1ttaW4sIG1heF1dXG4gICAgICAoaW5jbHVzaXZlKS4gICopXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBtaW46J2tcbiAgICAtPiBtYXg6J2tcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBbcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXhdIHJldHVybnMgYW4gYXNzb2NpYXRpdmUgbGlzdCBvZiB0aGUgZWxlbWVudHMgd2hvc2Uga2V5c1xuICAgICAgbGllIGluIFtbbWluLCBtYXhdXSAoaW5jbHVzaXZlKSwgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGJlaW5nIGF0IHRoZSBoZWFkIG9mIHRoZVxuICAgICAgbGlzdC4gKilcbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sgLT4gbWF4OidrIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIFtjbG9zZXN0X2tleSB0IGRpciBrXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XSB3aXRoIFtrZXldIGNsb3Nlc3QgdG9cbiAgICAgIFtrXSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gaW5lcXVhbGl0eSBib3VuZC5cblxuICAgICAgRm9yIGV4YW1wbGUsIFtjbG9zZXN0X2tleSB0IGBMZXNzX3RoYW4ga10gd291bGQgYmUgdGhlIHBhaXIgd2l0aCB0aGUgY2xvc2VzdCBrZXkgdG9cbiAgICAgIFtrXSB3aGVyZSBba2V5IDwga10uXG5cbiAgICAgIFt0b19zZXF1ZW5jZV0gY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBzYW1lIHJlc3VsdHMgYXMgW2Nsb3Nlc3Rfa2V5XS4gIEl0IGlzIGxlc3NcbiAgICAgIGVmZmljaWVudCBmb3IgaW5kaXZpZHVhbCBsb29rdXBzIGJ1dCBtb3JlIGVmZmljaWVudCBmb3IgZmluZGluZyBtYW55IGVsZW1lbnRzIHN0YXJ0aW5nXG4gICAgICBhdCBzb21lIHZhbHVlLiAqKVxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdrXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbbnRoIHQgbl0gZmluZHMgdGhlIChrZXksIHZhbHVlKSBwYWlyIG9mIHJhbmsgbiAoaS5lLiwgc3VjaCB0aGF0IHRoZXJlIGFyZSBleGFjdGx5IG5cbiAgICAgIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBmb3VuZCBrZXkpLCBpZiBvbmUgZXhpc3RzLiAgTyhsb2cobGVuZ3RoIHQpICsgbikgdGltZS4gKilcbiAgdmFsIG50aCA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICdrICogJ3ZcblxuICAoKiogW3JhbmsgdCBrXSBJZiBba10gaXMgaW4gW3RdLCByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tdIGluXG4gICAgICBbdF0sIGFuZCBbTm9uZV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgcmFuayA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gaW50IG9wdGlvblxuXG4gICgqKiBbdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XVxuICAgICAgZ2l2ZXMgYSBzZXF1ZW5jZSBvZiBrZXktdmFsdWUgcGFpcnMgYmV0d2VlbiBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSwgcHJlc2VudGVkIGluIFtvcmRlcl0uICBJZlxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA+IGtleXNfbGVzc19vcl9lcXVhbF90b10sIHRoZSBzZXF1ZW5jZSBpc1xuICAgICAgZW1wdHkuXG5cbiAgICAgIFdoZW4gbmVpdGhlciBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBub3IgW2tleXNfbGVzc19vcl9lcXVhbF90b10gYXJlXG4gICAgICBwcm92aWRlZCwgdGhlIGNvc3QgaXMgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIHRvIHByb2R1Y2VcbiAgICAgIGVhY2ggZWxlbWVudC4gSWYgZWl0aGVyIGlzIHByb3ZpZGVkIChhbmQgaXMgdXNlZCBieSB0aGUgb3JkZXIgcGFyYW1ldGVyXG4gICAgICBwcm92aWRlZCksIHRoZW4gdGhlIHRoZSBjb3N0IGlzIE8obikgdXAgZnJvbnQsIGFuZCBhbW9ydGl6ZWQgTygxKSB0b1xuICAgICAgcHJvZHVjZSBlYWNoIGVsZW1lbnQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzona1xuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdXG4gICAgICBzcGVjaWZpZWQgYnkgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgICAgXVxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIHdoaWNoXSB0YWtlcyBhIFtzZWdtZW50X29mXSBmdW5jdGlvbiB0aGF0XG4gICAgICBkaXZpZGVzIFt0XSBpbnRvIHR3byAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8IHNlZ21lbnRfb2YgZWx0ID0gYExlZnQgfCBzZWdtZW50X29mIGVsdCA9IGBSaWdodCB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZVxuICAgICAgc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5IFt3aGljaF06IFtgTGFzdF9vbl9sZWZ0XSB5aWVsZHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGVcbiAgICAgIGxlZnQgc2VnbWVudCwgd2hpbGUgW2BGaXJzdF9vbl9yaWdodF0geWllbGRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSByaWdodCBzZWdtZW50LlxuICAgICAgSXQgcmV0dXJucyBbTm9uZV0gaWYgdGhlIHNlZ21lbnQgaXMgZW1wdHkuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbc2VnbWVudF9vZl0gc2VnbWVudHMgW3RdIGFzIGluIHRoZVxuICAgICAgZGlhZ3JhbSwgYW5kIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBkb2Vzbid0IHNlZ21lbnQgW3RdLiAgQmVoYXZpb3JcbiAgICAgIGlzIGFsc28gdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IFsgYExhc3Rfb25fbGVmdCB8IGBGaXJzdF9vbl9yaWdodCBdXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zdWJyYW5nZV0gdGFrZXMgYSBbY29tcGFyZV0gZnVuY3Rpb24gdGhhdCBkaXZpZGVzIFt0XSBpbnRvIHRocmVlXG4gICAgICAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzIHdpdGggcmVzcGVjdCB0byBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdOlxuXG4gICAgICB7dlxuICAgICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgSW5fcmFuZ2UgfCBBYm92ZV91cHBlcl9ib3VuZCB8XG4gICAgICB2fVxuXG4gICAgICBhbmQgcmV0dXJucyBhIG1hcCBvZiB0aGUgW0luX3JhbmdlXSBzZWdtZW50LlxuXG4gICAgICBSdW50aW1lIGlzIE8obG9nIG0gKyBuKSB3aGVyZSBbbV0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgbWFwIGFuZCBbbl0gaXMgdGhlXG4gICAgICBsZW5ndGggb2YgdGhlIG91dHB1dC4gVGhlIGxpbmVhciB0ZXJtIGluIFtuXSBpcyB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dC5cblxuICAgICAgQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIFtjb21wYXJlXSBkb2VzIG5vdCBzZWdtZW50IFt0XSBhcyBzaG93biBhYm92ZSwgb3IgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIGl0cyBpbnB1dHMuICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyB0cmF2ZXJzYWxzIHRvIHJlY29uc3RydWN0IGEgbWFwIHdpdGhpbiBhbiBhcHBsaWNhdGl2ZS4gVXNlc1xuICAgICAgW0xhenlfYXBwbGljYXRpdmVdIHNvIHRoYXQgdGhlIG1hcCBjYW4gYmUgdHJhdmVyc2VkIHdpdGhpbiB0aGUgYXBwbGljYXRpdmUsIHJhdGhlclxuICAgICAgdGhhbiBuZWVkaW5nIHRvIGJlIHRyYXZlcnNlZCBhbGwgYXQgb25jZSwgb3V0c2lkZSB0aGUgYXBwbGljYXRpdmUuICopXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA6IHNpZ1xuICAgIHZhbCBtYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcblxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uIEEudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IEEudFxuICBlbmRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gaW50IE1hcC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IChTdHJpbmcudCwgaW50LCBTdHJpbmcuY29tcGFyYXRvcl93aXRuZXNzKSBNYXAudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBNYXAuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgW1N0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzc11cbiAgICAgIC0tIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuXG5cbiAgICAgIEluIGFkZGl0aW9uLCB3aGVuIHVzaW5nIFtAQGRlcml2aW5nXSwgdGhlIHJlcXVpcmVtZW50cyBvbiB0aGUga2V5IG1vZHVsZSBhcmUgb25seVxuICAgICAgdGhvc2UgbmVlZGVkIHRvIHNhdGlzZnkgd2hhdCB5b3UgYXJlIHRyeWluZyB0byBkZXJpdmUgb24gdGhlIG1hcCBpdHNlbGYuIFNheSB5b3VcbiAgICAgIHdyaXRlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHQgPSBpbnQgTWFwLk0oWCkudCBbQEBkZXJpdmluZyBoYXNoXVxuICAgICAgXX1cblxuICAgICAgdGhlbiB0aGlzIHdpbGwgYmUgd2VsbCB0eXBlZCBleGFjdGx5IGlmIFtYXSBjb250YWlucyBhdCBsZWFzdDpcbiAgICAgIC0gYSB0eXBlIFt0XSB3aXRoIG5vIHBhcmFtZXRlcnNcbiAgICAgIC0gYSBjb21wYXJhdG9yIHdpdG5lc3NcbiAgICAgIC0gYSBbaGFzaF9mb2xkX3RdIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IHR5cGUgKilcbiAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdrZXksICd2YWx1ZSwgJ2NtcCkgdCA6PSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0XG5cbiAgKCoqIFtVc2luZ19jb21wYXJhdG9yXSBpcyBhIHNpbWlsYXIgaW50ZXJmYWNlIGFzIHRoZSB0b3BsZXZlbCBvZiBbTWFwXSwgZXhjZXB0IHRoZVxuICAgICAgZnVuY3Rpb25zIHRha2UgYSBbfmNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRdLCB3aGVyZWFzIHRoZSBmdW5jdGlvbnMgYXQgdGhlXG4gICAgICB0b3BsZXZlbCBvZiBbTWFwXSB0YWtlIGEgWygnaywgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdrLCArJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgIG1vZHVsZSBUcmVlIDogc2lnXG4gICAgICB0eXBlICgrJ2ssICsndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgLT4gKFNleHAudCAtPiAnaylcbiAgICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAgICAgaW5jbHVkZVxuICAgICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICAgICAgd2l0aCB0eXBlICdjIGNtcCA6PSAnY1xuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhfY29tcGFyYXRvci50XG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICAgICB3aXRoIHR5cGUgJ2sga2V5IDo9ICdrXG4gICAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gJ2NcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdFxuICAgICAgOiAgJ2sgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICd2IEhhc2guZm9sZGVyXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICAoKiogVG8gZ2V0IGFyb3VuZCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24sIGFwcGx5IHRoZSBmdW5jdG9yIGFuZCBpbmNsdWRlIGl0LiBZb3VcbiAgICAgICAgY2FuIHNlZSBhbiBleGFtcGxlIG9mIHRoaXMgaW4gdGhlIFtQb2x5XSBzdWJtb2R1bGUgYmVsb3cuICopXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBBIHBvbHltb3JwaGljIE1hcC4gKilcbiAgbW9kdWxlIFBvbHkgOlxuICAgIFNfcG9seVxuICAgICAgd2l0aCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0ID0gKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICAgIGFuZCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0cmVlID1cbiAgICAgICAgKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAgICBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGEgdHJlZSB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyYXRvci4gKilcbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogRXh0cmFjdCBhIHRyZWUgZnJvbSBhIG1hcC4gKilcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cbiAgKCoqIHsyIE1vZHVsZXMgYW5kIG1vZHVsZSB0eXBlcyBmb3IgZXh0ZW5kaW5nIFtNYXBdfVxuXG4gICAgICBGb3IgdXNlIGluIGV4dGVuc2lvbnMgb2YgQmFzZSwgbGlrZSBbQ29yZV0uICopXG5cbiAgbW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IFdpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxuICBtb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gV2l0aG91dF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9MZWZ0IiwiY3N0X1JpZ2h0IiwiY3N0X1VuZXF1YWwiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2VxdWFsIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJlcnJvcl9zb3VyY2VfMDU3IiwiYWxsIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiY29tcGFyZSIsImNtcF9hIiwiYV8wMDEiLCJiXzAwMiIsInZhcmlhbnQiLCJyaWdodF8wMDQiLCJsZWZ0XzAwMyIsImVxdWFsIiwiYV8wMDUiLCJiXzAwNiIsInJpZ2h0XzAwOCIsImxlZnRfMDA3Iiwic2V4cF9vZl90Iiwib2ZfYV8wMDkiLCJwYXJhbSIsInZfMDEwIiwiT3JfZHVwbGljYXRlIiwiV2l0aG91dF9jb21wYXJhdG9yIiwiV2l0aF9jb21wYXJhdG9yIiwiV2l0aF9maXJzdF9jbGFzc19tb2R1bGUiLCJjbXBfayIsImNtcF92IiwiYV8wMTEiLCJiXzAxMiIsInRfMDE0IiwidF8wMTMiLCJ0XzAxNiIsInRfMDE1IiwibiIsInJpZ2h0XzAxOCIsImxlZnRfMDE3IiwicmlnaHRfMDIyIiwibGVmdF8wMjEiLCJ0XzAyNCIsInRfMDIzIiwidF8wMjYiLCJ0XzAyNSIsInJpZ2h0XzAyMCIsImxlZnRfMDE5IiwiYV8wMjciLCJiXzAyOCIsInRfMDMwIiwidF8wMjkiLCJ0XzAzMiIsInRfMDMxIiwicmlnaHRfMDM0IiwibGVmdF8wMzMiLCJyaWdodF8wMzgiLCJsZWZ0XzAzNyIsInRfMDQwIiwidF8wMzkiLCJ0XzA0MiIsInRfMDQxIiwicmlnaHRfMDM2IiwibGVmdF8wMzUiLCJ0X29mX3NleHAiLCJvZl9rXzA0MyIsIm9mX3ZfMDQ0Iiwic2V4cF8wNzEiLCJhcmcxXzA2OCIsImFyZzBfMDY3IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsIm1hdGNoIiwic2V4cF9hcmdzXzA1MCIsImFyZzBfMDU4IiwiYXJnMV8wNTMiLCJhcmcwXzA1MiIsInJlczBfMDU0IiwicmVzMV8wNTUiLCJyZXMwXzA1OSIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJhcmcwXzA2NCIsInJlczBfMDY1IiwicmVzMV8wNzAiLCJleG4iLCJvZl9rXzA3MiIsIm9mX3ZfMDczIiwiYXJnMV8wODIiLCJhcmcwXzA4MSIsInJlczBfMDgzIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsInRfc2V4cF9ncmFtbWFyIiwia19zZXhwX2dyYW1tYXIiLCJ2X3NleHBfZ3JhbW1hciIsIlN5bW1ldHJpY19kaWZmX2VsZW1lbnQiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJNZXJnZV9lbGVtZW50IiwiQ29udGludWVfb3Jfc3RvcCIsIkZpbmlzaGVkX29yX3VuZmluaXNoZWQiLCJCYXNlX01hcF9pbnRmIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFFBQUFDLE9BQUFDLE9BQUFDO0FBQUFBLElDWUksb0JBQ0s7QUFBQSxJQUNBO0FBQUEsNERBR3lCO0FBQUE7QUFBQTtBQUFBLFNBQUFDLFVBSHpCO0FBQUE7QUFBQSxVQUFBQyxZQUFBLFVBQUFDLFdBQUE7QUFBQSxNQUVvQyw2Q0FFVjtBQUFBO0FBQUE7QUFBQSxJQUFuQixpQ0FBbUI7QUFBQTtBQUFBLFlBQUFDLE1BQUFOLE9BQUFPLE9BQUFDO0FBQUFBLElBSy9CLG9CQUNLO0FBQUEsSUFDQTtBQUFBLDREQUd5QjtBQUFBO0FBQUE7QUFBQSxTQUFBTCxVQUh6QjtBQUFBO0FBQUEsVUFBQU0sWUFBQSxVQUFBQyxXQUFBO0FBQUEsTUFFb0MsNkNBRVo7QUFBQTtBQUFBO0FBQUEsSUFBakIsK0JBQWlCO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQUk3Qiw4QkFFZ0I7QUFBQSxRQUFBQyxRQUZoQjtBQUFBLElBQytELHVEQUFtQjtBQUFBLEdBQ3BDO0FBQUE7QUFBQSxJQUFBQyxlRG5DbEQ7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxRQytHSTtBQUFBO0FBQUE7QUFBQSxJQUFBbEMsY0FBQTtBQUFBLElBQUFELFlBQUE7QUFBQSxJQUFBRCxXQUFBO0FBQUEsWUFBQWlCLFVBQUFvQixPQUFBQyxPQUFBQyxPQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxRQWxEQTtBQUFBLEtBQUFDLFFBQUE7QUFBQSxLQUFBQyxRQUNBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLElBQ007QUFBQSxJQUF1QixZQWV0QjtBQUFBLElBYkwsb0JBQ0s7QUFBQSxZQUNBO0FBQUE7QUFBQTtBQUFBLFVBQUF4QixVQUFBO0FBQUE7QUFBQSxXQUFBeUIsWUFBQSxVQUFBQyxXQUFBO0FBQUEsT0FFd0MsNkNBU3ZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQVhEO0FBQUE7QUFBQSxXQUFBMUIsWUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFBMkIsWUFBQTtBQUFBLFNBQUFDLFdBQUE7QUFBQSxTQUFBQyxRQUtEO0FBQUEsU0FBQUMsUUFBQTtBQUFBLFNBQUFDLFFBQ0E7QUFBQSxTQUFBQyxRQUFBO0FBQUEsU0FBQVIsTUFDTztBQUFBLFFBQXVCLG1CQUN0QixxQ0FHTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQXhCLFlBWEQ7QUFBQTtBQUFBLFdBQUFpQyxZQUFBLFVBQUFDLFdBQUE7QUFBQSxPQUcwQyw2Q0FRekM7QUFBQTtBQUFBO0FBQUEsSUFETSxpQ0FDTjtBQUFBO0FBQUEsWUFBQS9CLFFBQUFhLE9BQUFDLE9BQUFrQixPQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxRQVFSO0FBQUEsS0FBQUMsUUFBQTtBQUFBLEtBQUFDLFFBQ0E7QUFBQSxLQUFBQyxRQUFBO0FBQUEsU0FFRTtBQUFBLElBQXlCO0FBQUEseUJBRW5CO0FBQUEsYUFDQTtBQUFBO0FBQUE7QUFBQSxXQUFBeEMsVUFBQTtBQUFBO0FBQUEsWUFBQXlDLFlBQUEsVUFBQUMsV0FBQTtBQUFBLFFBRXdDLDZDQU1mO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVJ6QjtBQUFBO0FBQUEsWUFBQTFDLFlBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQTJDLFlBQUE7QUFBQSxVQUFBQyxXQUFBO0FBQUEsVUFBQUMsUUFLRDtBQUFBLFVBQUFDLFFBQUE7QUFBQSxVQUFBQyxRQUNBO0FBQUEsVUFBQUMsUUFBQTtBQUFBLGNBQ2M7QUFBQSxTQUF5Qiw4Q0FDYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBQWhELFlBUnpCO0FBQUE7QUFBQSxZQUFBaUQsWUFBQSxVQUFBQyxXQUFBO0FBQUEsUUFHMEMsNkNBS2pCO0FBQUE7QUFBQTtBQUFBLGFBQWxCO0FBQUE7QUFBQTtBQUFBLGFBWFk7QUFBQTtBQUFBLEdBV007QUFBQSxZQUFBQyxVQUFBQyxVQUFBQyxVQUFBQztBQUFBQSxJQVdqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFBQyxXQUFBO0FBQUEsUUFBQUMsV0FBQTtBQUFBLFFBQUFDLFdBRXFCO0FBQUEsT0FHZjtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQUFDLFdBQUE7QUFBQTtBQUFBLFlBR0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQU9RO0FBQUEsbUJBREw7QUFBQTtBQUFBO0FBQUEsaUJBRkE7QUFBQTtBQUFBO0FBQUEsZUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDLFFBQUE7QUFBQTtBQUFBLGNBQUFBLFVBQUE7QUFBQTtBQUFBLGVBQUFDLGdCQUFBLFVBQUFGLGFBQUE7QUFBQSxXQVFIO0FBQUE7QUFBQTtBQUFBLHNCQTBDUTtBQUFBO0FBQUEsY0FwQkw7QUFBQSxtQkFBQUcsV0FBQTtBQUFBO0FBQUE7QUFBQSxnQkFFRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFBQUMsV0FBQTtBQUFBLG9CQUFBQyxXQUFBO0FBQUEsb0JBQUFDLFdBR3FCO0FBQUEsb0JBQUFDLFdBQ0E7QUFBQSxvQkFBQUMsV0FDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUFBO0FBQUFBLG1CQUVBO0FBQUE7QUFBQTtBQUFBLHVCQUtKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBMUJIO0FBQUE7QUFBQSxlQUFBQyxXQUFBO0FBQUEsZUFBQUMsV0FFb0I7QUFBQSxtQkFDakI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFmSDtBQUFBO0FBQUEsY0FBQUMsV0FBQTtBQUFBLGNBQUFDLFdBRW9CO0FBQUEsa0JBQ2pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FxQ047QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFJQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBO0FBQUE7QUFBQSxhQUFBQztBQUFBQSxZQUFBQSxNRGpMZDtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUFEO0FBQUFBLFdDc0xZO0FBQUE7QUFBQSxPQUlKO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFFQTtBQUFBO0FBQUE7QUFBQSxZQUFBL0QsWUFBQWlFLFVBQUFDLFVBQUFoRTtBQUFBQTtBQUFBQSxLQUFBaUUsV0FVSjtBQUFBLEtBQUFDLFdBQUE7QUFBQSxLQUFBQyxXQUNpQjtBQUFBLEtBQUE3RSxVQUFzQjtBQUFBO0FBQUE7QUFBQSxNQUFBOEUsUUFBQTtBQUFBLE1BQUFDLFdBSWdDLGVBQW5CO0FBQUE7QUFBQTtBQUFBLE1BQUFDLFFBSmI7QUFBQSxNQUFBQyxXQVFuQztBQUFBLE1BQUFDLFdBQUE7QUFBQSxNQUFBQyxXQUdzQjtBQUFBLE1BQUFDLFdBQ0E7QUFBQSxNQUFBTCxXQUNqQjtBQUFBO0FBQUE7QUFBQSxNQUFBTSxRQWI4QjtBQUFBLE1BQUFOLFdBTWlDLGVBQW5CO0FBQUEsSUFVckQ7QUFBQSxHQUE2QztBQUFBLFlBQUFPLGVBQUFDLGdCQUFBQztBQUFBQSxJQVU3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBcUNDO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQXZKRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUE3RixVQUFBOEYsVUFBQUMsV0FBQUMsT0FBQUM7QUFBQUEsSUE4S0Esb0JBQ0s7QUFBQSxZQUNBO0FBQUE7QUFBQTtBQUFBLFVBQUE3RixVQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUE4RixZQUFBO0FBQUEsUUFBQUMsV0FBQTtBQUFBLFFBQUFDLFFBS0Q7QUFBQSxRQUFBQyxRQUFBO0FBQUEsUUFBQUMsUUFDQTtBQUFBLFFBQUFDLFFBQUE7QUFBQSxRQUFBM0UsSUFDTztBQUFBLE9BQTBCLGlCQUN6Qix1Q0FFbUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBVjFCO0FBQUE7QUFBQSxXQUFBeEIsWUFBQTtBQUFBO0FBQUEsWUFBQW9HLFlBQUEsVUFBQUMsV0FBQTtBQUFBLFFBRXdDLGdEQVFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBckcsWUFWMUI7QUFBQTtBQUFBLFdBQUFzRyxZQUFBLFVBQUFDLFdBQUE7QUFBQSxPQUcwQyxpREFPaEI7QUFBQTtBQUFBO0FBQUEsSUFBbkIsaUNBQW1CO0FBQUE7QUFBQSxZQUFBcEcsUUFBQXVGLFVBQUFDLFdBQUFhLE9BQUFDO0FBQUFBLElBWS9CLG9CQUNLO0FBQUEsWUFDQTtBQUFBO0FBQUE7QUFBQSxVQUFBekcsVUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFBMEcsWUFBQTtBQUFBLFFBQUFDLFdBQUE7QUFBQSxRQUFBQyxRQUtEO0FBQUEsUUFBQUMsUUFBQTtBQUFBLFFBQUFDLFFBQ0E7QUFBQSxRQUFBQyxRQUFBO0FBQUEsWUFDYztBQUFBLE9BQTRCLGtEQUNqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FSeEI7QUFBQTtBQUFBLFdBQUEvRyxZQUFBO0FBQUE7QUFBQSxZQUFBZ0gsWUFBQSxVQUFBQyxXQUFBO0FBQUEsUUFFd0MsZ0RBTWhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBakgsWUFSeEI7QUFBQTtBQUFBLFdBQUFrSCxZQUFBLFVBQUFDLFdBQUE7QUFBQSxPQUcwQyxpREFLbEI7QUFBQTtBQUFBO0FBQUEsSUFBakIsK0JBQWlCO0FBQUE7QUFBQSxZQUFBM0csWUFBQTRHLGFBQUFDLGNBQUEzRztBQUFBQSxRQUFBVixVQVU3QjtBQUFBO0FBQUE7QUFBQSxNQUFBc0gsUUFBQTtBQUFBLE1BQUFDLFdBTUU7QUFBQSxNQUFBQyxXQUFBO0FBQUEsTUFBQUMsV0FHc0I7QUFBQSxNQUFBQyxXQUNBO0FBQUEsS0FDakI7QUFBQTtBQUFBLElBWFA7QUFBQSxTQUFBQyxRQUFBO0FBQUEsS0FFa0QsMERBQXNCO0FBQUE7QUFBQSxRQUFBQyxRQUZ4RTtBQUFBLElBSW1ELDJEQUF1QjtBQUFBLEdBUXJFO0FBQUE7QUFBQSxJQUFBQyxnQkF0T0w7QUFBQSxJQUFBakksWUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBTyxRQUFBLE1EL0dKO0FBQUEsWUFBQUssWUFBQUUsT0N1V0ssb0JBRW1DO0FBQUE7QUFBQSxJQUFBb0gsbUJBMVBwQztBQUFBLElBQUFsSSxZQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFPLFFBQUEsTUQvR0o7QUFBQSxZQUFBSyxZQUFBRSxPQzRYSyxvQkFFK0M7QUFBQTtBQUFBLElBQUFxSCx5QkEvUWhEO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQvR0oiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNzI5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIk5hbWVkIiwiQmFzZV9TZXRfaW50ZiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNzMwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9zZXQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXRfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEVtcHR5XG4gICAgKCogTGVhZiBpcyB0aGUgc2FtZSBhcyBOb2RlIHdpdGggZW1wdHkgY2hpbGRyZW4gYnV0IHVzZXMgbGVzcyBzcGFjZS4gKilcbiAgICB8IExlYWYgb2YgeyBlbHQgOiAnYSB9XG4gICAgfCBOb2RlIG9mXG4gICAgICAgIHsgbGVmdCA6ICdhIHRcbiAgICAgICAgOyBlbHQgOiAnYVxuICAgICAgICA7IHJpZ2h0IDogJ2EgdFxuICAgICAgICA7IGhlaWdodCA6IGludFxuICAgICAgICA7IHNpemUgOiBpbnRcbiAgICAgICAgfVxuXG4gIHR5cGUgJ2EgdHJlZSA9ICdhIHRcblxuICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZSBjaGlsZHJlbiBkaWZmZXIgYnlcbiAgICAgYXQgbW9zdCAyLiAqKVxuICBsZXRbQGlubGluZSBhbHdheXNdIGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IDFcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBoOyBzaXplID0gXyB9IC0+IGhcbiAgOztcblxuICBsZXRbQGlubGluZSBhbHdheXNdIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IDFcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gcyB9IC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IGg7IHNpemUgPSBuIH0gLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIG4gPSBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICAgICAgICAmJiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICAgICYmIGxvb3AgbG93ZXIgKFNvbWUgdikgY29tcGFyZV9lbHQgbFxuICAgICAgICAmJiBsb29wIChTb21lIHYpIHVwcGVyIGNvbXBhcmVfZWx0IHJcbiAgICBpblxuICAgIGZ1biB0IH5jb21wYXJlX2VsdCAtPiBsb29wIE5vbmUgTm9uZSBjb21wYXJlX2VsdCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgeyBlbHQgPSBfIH0gfCBOb2RlIF8gLT4gZmFsc2VcbiAgOztcblxuICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9IChoZWlnaHQgW0BpbmxpbmVkXSkgbCBpblxuICAgIGxldCBociA9IChoZWlnaHQgW0BpbmxpbmVkXSkgciBpblxuICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICBpZiBoID0gMVxuICAgIHRoZW4gTGVhZiB7IGVsdCA9IHYgfVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNsID0gKGxlbmd0aCBbQGlubGluZWRdKSBsIGluXG4gICAgICBsZXQgc3IgPSAobGVuZ3RoIFtAaW5saW5lZF0pIHIgaW5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBoOyBzaXplID0gc2wgKyBzciArIDEgfSlcbiAgOztcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5TZXQgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGsgPSBmIGkgaW5cbiAgICAgICAgTGVhZiB7IGVsdCA9IGsgfVxuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYgeyBlbHQgPSBrbCB9KSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYgeyBlbHQgPSBrbCB9KSBrIChMZWFmIHsgZWx0ID0ga3IgfSlcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgICgqIFdlIGRvbid0IGNoZWNrIGlmIHRoZSBhcnJheSBpcyBzb3J0ZWQgb3Iga2V5cyBhcmUgZHVwbGljYXRlZCwgYmVjYXVzZSB0aGF0XG4gICAgICAgICBjaGVja2luZyBpcyBzbG93ZXIgdGhhbiB0aGUgd2hvbGUgW29mX3NvcnRlZF9hcnJheV0gZnVuY3Rpb24gKilcbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDIgfHwgY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHRcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdClcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2VsdCBhcnJheS4oaSkgYXJyYXkuKGkgKyAxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCkpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy4gKilcblxuICBsZXQgYmFsIGwgdiByID1cbiAgICBsZXQgaGwgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIGwgaW5cbiAgICBsZXQgaHIgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgobCk+aChyKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsbDsgZWx0ID0gbHY7IHJpZ2h0ID0gbHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIHsgZWx0ID0gbHJ2IH0gLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgbGwpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgRW1wdHkpIGxydiAoY3JlYXRlIEVtcHR5IHYgcilcbiAgICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbHJsOyBlbHQgPSBscnY7IHJpZ2h0ID0gbHJyOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgeyBlbHQgPSBfIH0gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChyKT5oKGwpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IHJsOyBlbHQgPSBydjsgcmlnaHQgPSBycjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgeyBlbHQgPSBybHYgfSAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBycik7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgRW1wdHkpIHJsdiAoY3JlYXRlIEVtcHR5IHJ2IHJyKVxuICAgICAgICAgIHwgTm9kZSB7IGxlZnQgPSBybGw7IGVsdCA9IHJsdjsgcmlnaHQgPSBybHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycikpKVxuICAgIGVsc2UgKGNyZWF0ZSBbQGlubGluZWRdKSBsIHYgclxuICA7O1xuXG4gICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gIGV4Y2VwdGlvbiBTYW1lXG5cbiAgbGV0IGFkZCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IExlYWYgeyBlbHQgPSB4IH1cbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBjcmVhdGUgKExlYWYgeyBlbHQgPSB4IH0pIHYgRW1wdHlcbiAgICAgICAgZWxzZSBjcmVhdGUgRW1wdHkgdiAoTGVhZiB7IGVsdCA9IHggfSlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gYmFsIChhdXggbCkgdiByXG4gICAgICAgIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW2FkZF0gdGhhdCBhc3N1bWVzIHRoYXQgW3hdIGlzIGxlc3MgdGhhbiBhbGwgZXhpc3RpbmcgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBhZGRfbWluIHggdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIHsgZWx0ID0geCB9XG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHg7IHJpZ2h0ID0gdDsgaGVpZ2h0ID0gMjsgc2l6ZSA9IDIgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gYmFsIChhZGRfbWluIHggbCkgdiByXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW2FkZF0gdGhhdCBhc3N1bWVzIHRoYXQgW3hdIGlzIGdyZWF0ZXIgdGhhbiBhbGwgZXhpc3RpbmcgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBhZGRfbWF4IHQgeCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIHsgZWx0ID0geCB9XG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IE5vZGUgeyBsZWZ0ID0gdDsgZWx0ID0geDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMjsgc2l6ZSA9IDIgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gYmFsIGwgdiAoYWRkX21heCByIHgpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZSByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kXG4gICAgIHIuICopXG4gIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBhZGRfbWluIHYgclxuICAgIHwgXywgRW1wdHkgLT4gYWRkX21heCBsIHZcbiAgICB8IExlYWYgeyBlbHQgPSBsdiB9LCBfIC0+IGFkZF9taW4gbHYgKGFkZF9taW4gdiByKVxuICAgIHwgXywgTGVhZiB7IGVsdCA9IHJ2IH0gLT4gYWRkX21heCAoYWRkX21heCBsIHYpIHJ2XG4gICAgfCAoIE5vZGUgeyBsZWZ0ID0gbGw7IGVsdCA9IGx2OyByaWdodCA9IGxyOyBoZWlnaHQgPSBsaDsgc2l6ZSA9IF8gfVxuICAgICAgLCBOb2RlIHsgbGVmdCA9IHJsOyBlbHQgPSBydjsgcmlnaHQgPSBycjsgaGVpZ2h0ID0gcmg7IHNpemUgPSBfIH0gKSAtPlxuICAgICAgaWYgbGggPiByaCArIDJcbiAgICAgIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcilcbiAgICAgIGVsc2UgaWYgcmggPiBsaCArIDJcbiAgICAgIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnJcbiAgICAgIGVsc2UgY3JlYXRlIGwgdiByXG4gIDs7XG5cbiAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2OyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgIC0+IFNvbWUgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgYWNjID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHZhbHVlIH0gLT4gZiBhY2MgdmFsdWUgW0Bub250YWlsXVxuICAgICAgfCBOb2RlIHsgbGVmdDsgZWx0ID0gdmFsdWU7IHJpZ2h0OyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiBsZWZ0IGFjYyB3aXRoXG4gICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiBhY2MgdmFsdWUgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgICAgfCBDb250aW51ZSBhIC0+IGZvbGRfdW50aWxfaGVscGVyIH5mIHJpZ2h0IGEpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgdCBpbml0IHdpdGhcbiAgICB8IENvbnRpbnVlIHggLT4gZmluaXNoIHggW0Bub250YWlsXVxuICAgIHwgU3RvcCB4IC0+IHhcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gdjsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfVxuICAgICAgLT4gU29tZSB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IHJcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBiYWwgdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcbiAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBqb2luIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gIGxldCBzcGxpdCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHNwbGl0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIFNvbWUgdiwgRW1wdHlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIEVtcHR5LCBOb25lLCBMZWFmIHsgZWx0ID0gdiB9XG4gICAgICAgIGVsc2UgTGVhZiB7IGVsdCA9IHYgfSwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBsLCBTb21lIHYsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGwsIG1heWJlX2VsdCwgcmwgPSBzcGxpdCBsIGluXG4gICAgICAgICAgbGwsIG1heWJlX2VsdCwgam9pbiBybCB2IHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsciwgbWF5YmVfZWx0LCByciA9IHNwbGl0IHIgaW5cbiAgICAgICAgICBqb2luIGwgdiBsciwgbWF5YmVfZWx0LCBycilcbiAgICBpblxuICAgIHNwbGl0IHRcbiAgOztcblxuICBsZXQgcmVjIHNwbGl0X2xlX2d0IHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHksIEVtcHR5XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICBpZiBjb21wYXJlX2VsdCB4IHYgPj0gMCB0aGVuIExlYWYgeyBlbHQgPSB2IH0sIEVtcHR5IGVsc2UgRW1wdHksIExlYWYgeyBlbHQgPSB2IH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gYWRkX21heCBsIHYsIHJcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIHJsID0gc3BsaXRfbGVfZ3QgbCB4IH5jb21wYXJlX2VsdCBpblxuICAgICAgICBsbCwgam9pbiBybCB2IHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxyLCByciA9IHNwbGl0X2xlX2d0IHIgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgam9pbiBsIHYgbHIsIHJyKVxuICA7O1xuXG4gIGxldCByZWMgc3BsaXRfbHRfZ2UgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgIGlmIGNvbXBhcmVfZWx0IHggdiA+IDAgdGhlbiBMZWFmIHsgZWx0ID0gdiB9LCBFbXB0eSBlbHNlIEVtcHR5LCBMZWFmIHsgZWx0ID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIGwsIGFkZF9taW4gdiByXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBybCA9IHNwbGl0X2x0X2dlIGwgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgbGwsIGpvaW4gcmwgdiByKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsciwgcnIgPSBzcGxpdF9sdF9nZSByIHggfmNvbXBhcmVfZWx0IGluXG4gICAgICAgIGpvaW4gbCB2IGxyLCBycilcbiAgOztcblxuICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gIGxldCByZWMgbWVtIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gZmFsc2VcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMFxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMCB8fCBtZW0gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiB4ID0gTGVhZiB7IGVsdCA9IHggfVxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICBpZiBjb21wYXJlX2VsdCB4IHYgPSAwIHRoZW4gRW1wdHkgZWxzZSBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgciBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0Ol8gPVxuICAgIGxldCByZWMgYXV4IHQgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBpZiBpID0gMCB0aGVuIEVtcHR5IGVsc2UgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsIGkpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByIChpIC0gbF9zaXplIC0gMSkpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgaSB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgdW5pb24gczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgICAgICB8IExlYWYgeyBlbHQgPSB2MSB9LCBfIC0+XG4gICAgICAgICAgdW5pb24gKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYxOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxOyBzaXplID0gMSB9KSBzMlxuICAgICAgICB8IF8sIExlYWYgeyBlbHQgPSB2MiB9IC0+XG4gICAgICAgICAgdW5pb24gczEgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYyOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxOyBzaXplID0gMSB9KVxuICAgICAgICB8ICggTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IGgxOyBzaXplID0gXyB9XG4gICAgICAgICAgLCBOb2RlIHsgbGVmdCA9IGwyOyBlbHQgPSB2MjsgcmlnaHQgPSByMjsgaGVpZ2h0ID0gaDI7IHNpemUgPSBfIH0gKSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxXG4gICAgICAgICAgICB0aGVuIGFkZCBzMSB2MiB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBsZXQgbDIsIF8sIHIyID0gc3BsaXQgczIgdjEgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpKVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSkpXG4gICAgaW5cbiAgICB1bmlvbiBzMSBzMlxuICA7O1xuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIHhzID1cbiAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIExpc3QuZm9sZCB4cyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjIHggLT4gdW5pb24gYWMgKHRvX3RyZWUgeCkgfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlciBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IChMZWFmIHsgZWx0IH0gYXMgc2luZ2xldG9uKSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCAoTGVhZiB7IGVsdCB9IGFzIHNpbmdsZXRvbilcbiAgICAgICAgICAtPiBpZiBtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQgdGhlbiBzaW5nbGV0b24gZWxzZSBFbXB0eVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9LCB0MiAtPlxuICAgICAgICAgIChtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICAgICB8IGwyLCBOb25lLCByMiAtPiBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgIHwgbDIsIFNvbWUgdjEsIHIyIC0+IGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpKSlcbiAgICBpblxuICAgIGludGVyIHMxIHMyXG4gIDs7XG5cbiAgbGV0IGRpZmYgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBFbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gLT4gRW1wdHlcbiAgICAgICAgfCB0MSwgRW1wdHkgLT4gdDFcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdjEgfSwgdDIgLT5cbiAgICAgICAgICBkaWZmIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2MTsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSkgdDJcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGwxOyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgIHwgbDIsIFNvbWUgXywgcjIgLT4gY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMikpKVxuICAgIGluXG4gICAgZGlmZiBzMSBzMlxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnYSwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdhICogJ2EgdHJlZSAqICgnYSwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHMgKGUgOiAoXywgaW5jcmVhc2luZykgdCkgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBjb25zIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgcyAoZSA6IChfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGNvbnNfcmlnaHQgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl9zZXQgcyA6IChfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyBzIEVuZFxuICAgIGxldCBvZl9zZXRfcmlnaHQgcyA6IChfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCBzIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHY7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDE7IHNpemUgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgICAgbG9vcCAoTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gdjsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSkgZVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9XG4gICAgICAgICAgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgbG9vcCByIChNb3JlICh2LCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGUxIGUyID1cbiAgICAgIGxldCByZWMgbG9vcCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIGUxLCBlMiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIHIxLCBlMSksIE1vcmUgKHYyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCBlMSBlMlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGl0ZXIgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gKClcbiAgICAgIHwgTW9yZSAoYSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgZiBhO1xuICAgICAgICBpdGVyIChjb25zIHRyZWUgZW51bSkgfmZcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIyIGNvbXBhcmVfZWx0IHQxIHQyIH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gKClcbiAgICAgICAgfCBFbmQsIF8gLT4gaXRlciB0MiB+ZjooZnVuIGEgLT4gZiAoYFJpZ2h0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBCb3RoIChhMSwgYTIpKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYExlZnQgYTEpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBmIChgUmlnaHQgYTIpO1xuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgOiAoKF8sIF8pIEVpdGhlci50LCBfKSBTZXF1ZW5jZS5TdGVwLnQgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBTZWNvbmQgZWx0OyBzdGF0ZSA9IEVuZCwgY29ucyB0cmVlIGVudW0gfVxuICAgICAgICB8IE1vcmUgKGVsdCwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBlbHQ7IHN0YXRlID0gY29ucyB0cmVlIGVudW0sIEVuZCB9XG4gICAgICAgIHwgKE1vcmUgKGExLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoYTIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBuZXh0X3N0YXRlIH0pXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBhMTsgc3RhdGUgPSBjb25zIHRyZWUxIGVudW0xLCByaWdodCB9XG4gICAgICAgICAgZWxzZSBZaWVsZCB7IHZhbHVlID0gU2Vjb25kIGEyOyBzdGF0ZSA9IGxlZnQsIGNvbnMgdHJlZTIgZW51bTIgfVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGs7IHN0YXRlID0gRW51bS5jb25zIHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPlxuICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrOyBzdGF0ZSA9IEVudW0uY29uc19yaWdodCB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgY29tcGFyYXRvclxuICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgdFxuICAgID1cbiAgICBsZXQgaW5jbHVzaXZlX2JvdW5kIHNpZGUgdCBib3VuZCA9XG4gICAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IGwsIG1heWJlLCByID0gc3BsaXQgdCBib3VuZCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGxldCB0ID0gc2lkZSAobCwgcikgaW5cbiAgICAgIG1hdGNoIG1heWJlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0XG4gICAgICB8IFNvbWUgZWx0IC0+IGFkZCB0IGVsdCB+Y29tcGFyZV9lbHRcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGxlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6Z3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0Omxlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIHZcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKSBbQG5vbnRhaWxdXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IHggPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0IFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgY29tcGFyYXRvclxuICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgdFxuICAgIHQnXG4gICAgPVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQpXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCcpXG4gICAgICB+Y29tcGFyZTpcbiAgICAgICAgKG1hdGNoIG9yZGVyIHdpdGhcbiAgICAgICAgIHwgYEluY3JlYXNpbmcgLT4gY29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB8IGBEZWNyZWFzaW5nIC0+IEZuLmZsaXAgY29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHMxIHMyIH5jb21wYXJlX2VsdCB+ZiA9XG4gICAgRW51bS5pdGVyMiBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMikgfmZcbiAgOztcblxuICBsZXQgZXF1YWwgczEgczIgfmNvbXBhcmVfZWx0ID0gY29tcGFyZSBjb21wYXJlX2VsdCBzMSBzMiA9IDBcblxuICBsZXQgaXNfc3Vic2V0IHMxIH5vZl86czIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGlzX3N1YnNldCBzMSB+b2ZfOnMyID1cbiAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICB8IEVtcHR5LCBfIC0+IHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYxIH0sIHQyIC0+IG1lbSB0MiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH0sIExlYWYgeyBlbHQgPSB2MiB9XG4gICAgICAgIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiB7ZWx0PXJhdGhlcn0gdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8ICggTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgICAgLCAoTm9kZSB7IGxlZnQgPSBsMjsgZWx0ID0gdjI7IHJpZ2h0ID0gcjI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gYXMgdDIpICkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgcGh5c19lcXVhbCBzMSBzMiB8fCAoaXNfc3Vic2V0IGwxIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86cjIpXG4gICAgICAgICAgKCogTm90ZSB0aGF0IGhlaWdodCBhbmQgc2l6ZSBkb24ndCBtYXR0ZXIgaGVyZS4gKilcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaXNfc3Vic2V0XG4gICAgICAgICAgICAoTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDA7IHNpemUgPSAwIH0pXG4gICAgICAgICAgICB+b2ZfOmwyXG4gICAgICAgICAgJiYgaXNfc3Vic2V0IHIxIH5vZl86dDJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlzX3N1YnNldFxuICAgICAgICAgICAgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSAwOyBzaXplID0gMCB9KVxuICAgICAgICAgICAgfm9mXzpyMlxuICAgICAgICAgICYmIGlzX3N1YnNldCBsMSB+b2ZfOnQyXG4gICAgaW5cbiAgICBpc19zdWJzZXQgczEgfm9mXzpzMlxuICA7O1xuXG4gIGxldCByZWMgYXJlX2Rpc2pvaW50IHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiB7IGVsdCB9LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgeyBlbHQgfSAtPlxuICAgICAgbm90IChtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGwxOyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSwgdDIgLT5cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICB8IGwyLCBOb25lLCByMiAtPlxuICAgICAgICAgIGFyZV9kaXNqb2ludCBsMSBsMiB+Y29tcGFyZV9lbHQgJiYgYXJlX2Rpc2pvaW50IHIxIHIyIH5jb21wYXJlX2VsdFxuICAgICAgICB8IF8sIFNvbWUgXywgXyAtPiBmYWxzZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID1cbiAgICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgdlxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHQgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgcmVjIGZvbGQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gZiBhY2N1IHZcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBmb2xkIH5mIHIgfmluaXQ6KGYgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSB2KVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2VsZW0gc3RhdGUgdCA9XG4gICAgZm9sZCB0IH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpIH5mOmhhc2hfZm9sZF9lbGVtXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5cbiAgbGV0IHJlYyBmb2xkX3JpZ2h0IHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgdiBhY2N1XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIHYgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgcmVjIGZvcl9hbGwgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gcCB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgcCB2ICYmIGZvcl9hbGwgfmY6cCBsICYmIGZvcl9hbGwgfmY6cCByXG4gIDs7XG5cbiAgbGV0IHJlYyBleGlzdHMgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IHAgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIHAgdiB8fCBleGlzdHMgfmY6cCBsIHx8IGV4aXN0cyB+ZjpwIHJcbiAgOztcblxuICBsZXQgZmlsdGVyIHMgfmY6cCA9XG4gICAgbGV0IHJlYyBmaWx0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSBhcyB0IC0+IGlmIHAgdiB0aGVuIHQgZWxzZSBFbXB0eVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSBhcyB0IC0+XG4gICAgICAgIGxldCBsJyA9IGZpbHQgbCBpblxuICAgICAgICBsZXQga2VlcF92ID0gcCB2IGluXG4gICAgICAgIGxldCByJyA9IGZpbHQgciBpblxuICAgICAgICBpZiBrZWVwX3YgJiYgcGh5c19lcXVhbCBsIGwnICYmIHBoeXNfZXF1YWwgciByJ1xuICAgICAgICB0aGVuIHRcbiAgICAgICAgZWxzZSBpZiBrZWVwX3ZcbiAgICAgICAgdGhlbiBqb2luIGwnIHYgcidcbiAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcbiAgICBpblxuICAgIGZpbHQgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGZpbHRcbiAgICAgICAgICAoZmlsdFxuICAgICAgICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgICAgICAgICBsKVxuICAgICAgICAgIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiBzIH5mOnAgPVxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBFbXB0eVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IGFzIHQgLT4gaWYgcCB2IHRoZW4gdCwgRW1wdHkgZWxzZSBFbXB0eSwgdFxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSBhcyB0IC0+XG4gICAgICAgIGxldCBsJ3QsIGwnZiA9IGxvb3AgbCBpblxuICAgICAgICBsZXQga2VlcF92X3QgPSBwIHYgaW5cbiAgICAgICAgbGV0IHIndCwgcidmID0gbG9vcCByIGluXG4gICAgICAgIGxldCBtayBrZWVwX3YgbCcgcicgPVxuICAgICAgICAgIGlmIGtlZXBfdiAmJiBwaHlzX2VxdWFsIGwgbCcgJiYgcGh5c19lcXVhbCByIHInXG4gICAgICAgICAgdGhlbiB0XG4gICAgICAgICAgZWxzZSBpZiBrZWVwX3ZcbiAgICAgICAgICB0aGVuIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG4gICAgICAgIGluXG4gICAgICAgIG1rIGtlZXBfdl90IGwndCByJ3QsIG1rIChub3Qga2VlcF92X3QpIGwnZiByJ2ZcbiAgICBpblxuICAgIGxvb3AgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IHYgOjogYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG4gIDs7XG5cbiAgbGV0IGVsZW1lbnRzIHMgPSBlbGVtZW50c19hdXggW10gc1xuXG4gIGxldCBjaG9vc2UgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IFNvbWUgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBlbHQgPSB2OyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gU29tZSB2XG4gIDs7XG5cbiAgbGV0IGNob29zZV9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlNldC5jaG9vc2VfZXhuOiBlbXB0eSBzZXRcIikgaW5cbiAgICBsZXQgY2hvb3NlX2V4biB0ID1cbiAgICAgIG1hdGNoIGNob29zZSB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2IC0+IHZcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBjaG9vc2VfZXhuXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgbHN0IH5jb21wYXJlX2VsdCA9XG4gICAgTGlzdC5mb2xkIGxzdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgfmNvbXBhcmVfZWx0ID1cbiAgICBTZXF1ZW5jZS5mb2xkIHNlcXVlbmNlIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCB0b19saXN0IHMgPSBlbGVtZW50cyBzXG5cbiAgbGV0IG9mX2FycmF5IGEgfmNvbXBhcmVfZWx0ID1cbiAgICBBcnJheS5mb2xkIGEgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgKCogZmFzdGVyIGJ1dCBlcXVpdmFsZW50IHRvIFtBcnJheS5vZl9saXN0ICh0b19saXN0IHQpXSAqKVxuICBsZXQgdG9fYXJyYXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gW3x8XVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBbfCB2IHxdXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IHMgfSAtPlxuICAgICAgbGV0IHJlcyA9IEFycmF5LmNyZWF0ZSB+bGVuOnMgdiBpblxuICAgICAgbGV0IHBvc19yZWYgPSByZWYgMCBpblxuICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgKCogSW52YXJpYW50OiBvbiBlbnRyeSBhbmQgb24gZXhpdCB0byBbbG9vcF0sICFwb3NfcmVmIGlzIHRoZSBuZXh0XG4gICAgICAgICAgIGF2YWlsYWJsZSBjZWxsIGluIHRoZSBhcnJheS4gKilcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZlxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgbG9vcCBsO1xuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgICAgIGxvb3AgclxuICAgICAgaW5cbiAgICAgIGxvb3AgbDtcbiAgICAgICgqIHJlcy4oIXBvc19yZWYpIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgKGJ5IEFycmF5LmNyZWF0ZSB+bGVuOmFib3ZlKS4gKilcbiAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgIGxvb3AgcjtcbiAgICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiB+Y29tcGFyZV9lbHQgPVxuICAgIGZvbGQgdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCAoZiB4KSB+Y29tcGFyZV9lbHQpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgc2V0IH5lcXVpdiA9XG4gICAgbGV0IHJlYyBsb29wIHNldCBlcXVpdl9jbGFzc2VzID1cbiAgICAgIGlmIGlzX2VtcHR5IHNldFxuICAgICAgdGhlbiBlcXVpdl9jbGFzc2VzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHggPSBjaG9vc2VfZXhuIHNldCBpblxuICAgICAgICBsZXQgZXF1aXZfeCwgbm90X2VxdWl2X3ggPVxuICAgICAgICAgIHBhcnRpdGlvbl90ZiBzZXQgfmY6KGZ1biBlbHQgLT4gcGh5c19lcXVhbCB4IGVsdCB8fCBlcXVpdiB4IGVsdClcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCBub3RfZXF1aXZfeCAoZXF1aXZfeCA6OiBlcXVpdl9jbGFzc2VzKSlcbiAgICBpblxuICAgIGxvb3Agc2V0IFtdIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gU29tZSB2XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggZmluZCBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbmQgciB+ZlxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX21hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gZiB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgKG1hdGNoIGYgdiB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICAobWF0Y2ggZmluZF9tYXAgbCB+ZiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIHIgfmZcbiAgICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNldC5maW5kX2V4biBmYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIGVsZW1lbnRcIlxuICAgIHwgU29tZSBlIC0+IGVcbiAgOztcblxuICBsZXQgcmVjIG50aCB0IGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBpID0gMCB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gcyB9IC0+XG4gICAgICBpZiBpID49IHNcbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjIDwgMCB0aGVuIG50aCBsIGkgZWxzZSBpZiBjID0gMCB0aGVuIFNvbWUgdiBlbHNlIG50aCByIChpIC0gbF9zaXplIC0gMSkpXG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHhzIGxlZnRvdmVycyBhbHJlYWR5X3NlZW4gPVxuICAgICAgbWF0Y2ggeHMgd2l0aFxuICAgICAgfCBbXSAtPiBMaXN0LnJldiBsZWZ0b3ZlcnNcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgaWYgbWVtIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHRcbiAgICAgICAgdGhlbiBsb29wIHRsIGxlZnRvdmVycyBhbHJlYWR5X3NlZW5cbiAgICAgICAgZWxzZSBsb29wIHRsIChoZCA6OiBsZWZ0b3ZlcnMpIChhZGQgYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdClcbiAgICBpblxuICAgIGxvb3AgeHMgW10gZW1wdHlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBhX29mX3NleHAgc2V4cCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5MaXN0IGxzdCAtPlxuICAgICAgbGV0IGVsdF9sc3QgPSBMaXN0Lm1hcCBsc3QgfmY6YV9vZl9zZXhwIGluXG4gICAgICBsZXQgc2V0ID0gb2ZfbGlzdCBlbHRfbHN0IH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgbGVuZ3RoIHNldCA9IExpc3QubGVuZ3RoIGxzdFxuICAgICAgdGhlbiBzZXRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc2V0ID0gcmVmIGVtcHR5IGluXG4gICAgICAgIExpc3QuaXRlcjJfZXhuIGxzdCBlbHRfbHN0IH5mOihmdW4gZWxfc2V4cCBlbCAtPlxuICAgICAgICAgIGlmIG1lbSAhc2V0IGVsIH5jb21wYXJlX2VsdFxuICAgICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGR1cGxpY2F0ZSBlbGVtZW50IGluIHNldFwiIGVsX3NleHBcbiAgICAgICAgICBlbHNlIHNldCA6PSBhZGQgIXNldCBlbCB+Y29tcGFyZV9lbHQpO1xuICAgICAgICBhc3NlcnQgZmFsc2UpXG4gICAgfCBzZXhwIC0+IG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIGVsIGFjYyAtPiBzZXhwX29mX2EgZWwgOjogYWNjKSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBsZXQgaXNfc3Vic2V0XG4gICAgICAoc3Vic2V0IDogXyBOYW1lZC50KVxuICAgICAgfm9mXzooc3VwZXJzZXQgOiBfIE5hbWVkLnQpXG4gICAgICB+c2V4cF9vZl9lbHRcbiAgICAgIH5jb21wYXJlX2VsdFxuICAgICAgPVxuICAgICAgbGV0IGludmFsaWRfZWxlbWVudHMgPSBkaWZmIHN1YnNldC5zZXQgc3VwZXJzZXQuc2V0IH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgaXNfZW1wdHkgaW52YWxpZF9lbGVtZW50c1xuICAgICAgdGhlbiBPayAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgPSBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgaW52YWxpZF9lbGVtZW50cyBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIChzdWJzZXQubmFtZSBeIFwiIGlzIG5vdCBhIHN1YnNldCBvZiBcIiBeIHN1cGVyc2V0Lm5hbWUpXG4gICAgICAgICAgICAgWyBcImludmFsaWRfZWxlbWVudHNcIiwgaW52YWxpZF9lbGVtZW50c19zZXhwIF0pKVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgczEgczIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdCA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG4gICAgICAgIFsgaXNfc3Vic2V0IHMxIH5vZl86czIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICA7IGlzX3N1YnNldCBzMiB+b2ZfOnMxIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgXVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdhLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICdhIFRyZWUwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAnYSBUcmVlMC50XG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGNvbXBhcmF0b3IgfSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yIH1cblxubGV0IGxpa2VfbWF5YmVfbm9fb3AgKHsgdHJlZSA9IG9sZF90cmVlOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpIHRyZWUgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgY29tcGFyZV9lbHQgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCBjb21wYXJhdG9yX3MgdCA9IENvbXBhcmF0b3IudG9fbW9kdWxlIHQuY29tcGFyYXRvclxuICBsZXQgaW52YXJpYW50cyB0ID0gVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdC50cmVlXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdC50cmVlXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHQudHJlZVxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0LnRyZWVcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdC50cmVlXG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdC50cmVlXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZiB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgYSBiIH5mID0gVHJlZTAuaXRlcjIgYS50cmVlIGIudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IGEpXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdC50cmVlIH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQudHJlZSB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQudHJlZSB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQudHJlZSB+ZlxuICBsZXQgbWVtIHQgYSA9IFRyZWUwLm1lbSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGxpa2VfbWF5YmVfbm9fb3AgdCAoVHJlZTAuZmlsdGVyIHQudHJlZSB+ZilcbiAgbGV0IGFkZCB0IGEgPSBsaWtlIHQgKFRyZWUwLmFkZCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgcmVtb3ZlIHQgYSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLnVuaW9uIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGludGVyIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuaW50ZXIgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmRpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY29tcGFyZV9lbHQgdDEpIHQxLnRyZWUgdDIudHJlZVxuICBsZXQgZXF1YWwgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgbGV0IGlzX3N1YnNldCB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdC50cmVlIH5vZl86b2ZfLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuXG4gIGxldCBhcmVfZGlzam9pbnQgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBsZXQgdG9fbmFtZWRfdHJlZSAobmFtZWQgOiAoXywgXykgdCBOYW1lZC50KSA9IHsgbmFtZWQgd2l0aCBzZXQgPSBuYW1lZC5zZXQudHJlZSB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IHN1YnNldCB+b2ZfOnN1cGVyc2V0ID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICAodG9fbmFtZWRfdHJlZSBzdWJzZXQpXG4gICAgICAgIH5vZl86KHRvX25hbWVkX3RyZWUgc3VwZXJzZXQpXG4gICAgICAgIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgc3Vic2V0LnNldClcbiAgICAgICAgfnNleHBfb2ZfZWx0OnN1YnNldC5zZXQuY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHQxIHQyID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXQgWyBpc19zdWJzZXQgdDEgfm9mXzp0MjsgaXNfc3Vic2V0IHQyIH5vZl86dDEgXVxuICAgIDs7XG5cbiAgICBpbmNsdWRlIE5hbWVkXG4gIGVuZFxuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgbGV0IHRyZWVfdCwgdHJlZV9mID0gVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCB0cmVlX3QsIGxpa2VfbWF5YmVfbm9fb3AgdCB0cmVlX2ZcbiAgOztcblxuICBsZXQgc3BsaXQgdCBhID1cbiAgICBsZXQgdHJlZTEsIGIsIHRyZWUyID0gVHJlZTAuc3BsaXQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgYiwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2xlX2d0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCB0cmVlMiA9IFRyZWUwLnNwbGl0X2xlX2d0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBzcGxpdF9sdF9nZSB0IGEgPVxuICAgIGxldCB0cmVlMSwgdHJlZTIgPSBUcmVlMC5zcGxpdF9sdF9nZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWUxLCBsaWtlIHQgdHJlZTJcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgdCB+ZXF1aXYgPSBMaXN0Lm1hcCAoVHJlZTAuZ3JvdXBfYnkgdC50cmVlIH5lcXVpdikgfmY6KGxpa2UgdClcbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdC50cmVlIGlcbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZV9pbmRleCB0LnRyZWUgaSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgdC5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0LnRyZWUgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQudHJlZSB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICB0LnRyZWVcbiAgICAgIHQnLnRyZWVcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQgPVxuICAgIFRyZWUwLmhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQudHJlZVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjb21wYXJlIF8gXyB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5cbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9ICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWVcblxuICBsZXQgY2UgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKSBhX29mX3NleHAgc2V4cFxuICA7O1xuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3I6XyBlID0gVHJlZTAuc2luZ2xldG9uIGVcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHRcbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9IFRyZWUwLmludmFyaWFudHMgdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgZWxlbWVudHMgdCA9IFRyZWUwLmVsZW1lbnRzIHRcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHRcbiAgbGV0IGNob29zZV9leG4gdCA9IFRyZWUwLmNob29zZV9leG4gdFxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0XG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0IH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5pbml0IH5mXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmZcbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mXG4gIGxldCBpdGVyMiB+Y29tcGFyYXRvciBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhIGIgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLm1lbSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLmFkZCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnJlbW92ZSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb24gfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC51bmlvbiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpbnRlciB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmludGVyIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGRpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5jb21wYXJlIChjZSBjb21wYXJhdG9yKSB0MSB0MlxuICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQgfm9mXyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IGFyZV9kaXNqb2ludCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuYXJlX2Rpc2pvaW50IHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjpfIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC51bmlvbl9saXN0IGwgfnRvX3RyZWU6Rm4uaWQgfmNvbXBhcmF0b3JcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgdCB+ZXF1aXYgPSBUcmVlMC5ncm91cF9ieSB0IH5lcXVpdlxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0X2xlX2d0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0X2xlX2d0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzcGxpdF9sdF9nZSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5zcGxpdF9sdF9nZSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0IGlcbiAgbGV0IHJlbW92ZV9pbmRleCB+Y29tcGFyYXRvciB0IGkgPSBUcmVlMC5yZW1vdmVfaW5kZXggdCBpIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0XG4gIGxldCB0b190cmVlIHQgPSB0XG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdCA9IHRcblxuICBsZXQgdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCdcbiAgOztcblxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgaW5jbHVkZSBUcmVlMC5OYW1lZFxuXG4gICAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0MSB+b2ZfOnQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICB0MVxuICAgICAgICB+b2ZfOnQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmVxdWFsXG4gICAgICAgIHQxXG4gICAgICAgIHQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgdCA9ICgnZWx0LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl90cmVlXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuY29tcGFyZSBhX29mX3NleHAgc2V4cClcbiAgOztcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG5cbiAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEVsdCA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyBjb21wYXJhdG9yID0gRWx0LmNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG4gIGVuZFxuXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgZSA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBlIH1cblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC51bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIGwpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIGxldCB0cmVlID1cbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLk1vbmFkX2luZml4LihcbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgID4+fCBmdW4gdHJlZSAtPiB7IGNvbXBhcmF0b3I7IHRyZWUgfSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm1hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3JcbiAgICA7IHRyZWUgPSBUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB9XG4gIDs7XG5cbiAgbW9kdWxlIFRyZWUgPSBUcmVlXG5lbmRcblxubGV0IHRvX2NvbXBhcmF0b3IgPSBDb21wYXJhdG9yLm9mX21vZHVsZVxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbmxldCB0b190cmVlID0gVXNpbmdfY29tcGFyYXRvci50b190cmVlXG5sZXQgb2ZfdHJlZSBtIHQgPSBVc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoRWx0IDogc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgKHR5cGUgZWx0IGNtcClcbiAgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOkVsdC5jb21wYXJhdG9yIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdClcbiAgOiAoZWx0LCBfKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGVsdCkgc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEVsdC5oYXNoX2ZvbGRfdCBzdGF0ZVxuOztcblxubGV0IGhhc2hfbV9fdCBmb2xkZXIgdCA9XG4gIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9tX190IGZvbGRlciAoSGFzaC5jcmVhdGUgKCkpIHQgaW5cbiAgSGFzaC5nZXRfaGFzaF92YWx1ZSBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gIHR5cGUgbm9ucmVjICdlbHQgdCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IHVuaW9uX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvciBhXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX3NlcXVlbmNlIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG1hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgZmlsdGVyX21hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfb2Zfc29ydGVkX2FycmF5X2R1cGxpY2F0ZWQiLCJjc3Rfc3JjX3NldF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiQmFzZV9IYXNoIiwiQmFzZV9JbXBvcnQiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX09yX2Vycm9yIiwiQmFzZV9Db250YWluZXIiLCJCYXNlX0xpc3QiLCJCYXNlX0NvbXBhcmF0b3IiLCJCYXNlX1NleHAiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfQXJyYXkiLCJCYXNlX1NlcXVlbmNlIiwiQmFzZV9GbiIsIkJhc2VfT3B0aW9uIiwiQmFzZV9FeG4iLCJCYXNlX1dpdGhfcmV0dXJuIiwiU2V4cGxpYjBfU2V4cF9jb252Iiwid2l0aF9yZXR1cm4iLCJjc3Rfb2Zfc29ydGVkX2FycmF5X2VsZW1lbnRzX2EiLCJoZWlnaHQiLCJwYXJhbSIsImgiLCJsZW5ndGgiLCJzIiwiaW5fcmFuZ2UiLCJsb3dlciIsInVwcGVyIiwiY29tcGFyZV9lbHQiLCJ2IiwibG9vcCIsInQiLCJuIiwiciIsImwiLCJobCIsImhyIiwiaW52YXJpYW50cyIsImlzX2VtcHR5IiwiY3JlYXRlIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImxlbiIsImkiLCJrIiwia2wiLCJrciIsImxlZnRfbGVuZ3RoIiwicmlnaHRfbGVuZ3RoIiwibGVmdCIsInJpZ2h0Iiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCIsImFycmF5IiwiYXJyYXlfbGVuZ3RoIiwibmV4dCIsIm9mX3NvcnRlZF9hcnJheSIsImluY3JlYXNpbmciLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJTYW1lIiwiYWRkIiwieCIsImF1eCIsImMiLCJleG4iLCJhZGRfbWluIiwiYWRkX21heCIsImpvaW4iLCJsaCIsInJoIiwibWluX2VsdCIsIlNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQiLCJTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IiwiY3N0X1NldF9yZW1vdmVfbWluX2VsdCIsIm1pbl9lbHRfZXhuIiwibWF0Y2giLCJmb2xkX3VudGlsIiwiaW5pdCIsImZpbmlzaCIsImZvbGRfdW50aWxfaGVscGVyIiwiYWNjIiwidmFsdWUiLCJtYXhfZWx0IiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsIm1lcmdlIiwidDEiLCJ0MiIsImNvbmNhdCIsInNwbGl0IiwibWF5YmVfZWx0Iiwic3BsaXRfbGVfZ3QiLCJzcGxpdF9sdF9nZSIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsIm1lbSIsInJlbW92ZSIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwiczEiLCJzMiIsImgxIiwicjEiLCJ2MSIsImwxIiwidjIiLCJoMiIsInIyIiwibDIiLCJ1bmlvbl9saXN0IiwiY29tcGFyYXRvciIsInRvX3RyZWUiLCJ4cyIsImFjIiwiaW50ZXIiLCJvdGhlcl9zZXQiLCJzaW5nbGV0b24iLCJlbHQiLCJkaWZmIiwiY29ucyIsImUiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0Iiwic3ltbWV0cmljX2RpZmYiLCJzdGVwIiwic3RhdGUiLCJlbnVtJCIsInRyZWUiLCJlbnVtMiIsInRyZWUyIiwiY29tcGFyZV9yZXN1bHQiLCJuZXh0X3N0YXRlIiwidG9fc2VxdWVuY2UiLCJvcHQiLCJncmVhdGVyX29yX2VxdWFsX3RvIiwibGVzc19vcl9lcXVhbF90byIsIm9yZGVyIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsImJvdW5kIiwibWF5YmUiLCJrZXkiLCJjb21wYXJlIiwiZmluZF9maXJzdF9zYXRpc2Z5aW5nIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJiaW5hcnlfc2VhcmNoIiwiaG93IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiIsImUxIiwiaXRlcjIiLCJlbnVtMSIsInRyZWUxIiwiYSIsImVxdWFsIiwiaXNfc3Vic2V0IiwiYXJlX2Rpc2pvaW50IiwiaXRlciIsImZvbGQiLCJhY2N1IiwiY291bnQiLCJzdW0iLCJtIiwiZm9sZF9yaWdodCIsImZvcl9hbGwiLCJwIiwiZXhpc3RzIiwiZmlsdGVyIiwiZmlsdCIsImtlZXBfdiIsImZpbHRlcl9tYXAiLCJwYXJ0aXRpb25fdGYiLCJsX2YiLCJsX3QiLCJrZWVwX3ZfdCIsInJfZiIsInJfdCIsIm1rIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJub3RfZm91bmQiLCJjc3RfU2V0X2ZpbmRfZXhuX2ZhaWxlZF90b19maW4iLCJjc3RfU2V0X3Rfb2Zfc2V4cF9saXN0X25lZWRlZCIsImNzdF9TZXRfdF9vZl9zZXhwX2R1cGxpY2F0ZV9lbCIsImNzdF9pbnZhbGlkX2VsZW1lbnRzIiwiY3N0X2lzX25vdF9hX3N1YnNldF9vZiIsImNob29zZV9leG4iLCJvZl9saXN0IiwibHN0Iiwib2Zfc2VxdWVuY2UiLCJzZXF1ZW5jZSIsIm9mX2FycmF5IiwidG9fYXJyYXkiLCJyZXMiLCJwb3NfcmVmIiwibWFwIiwiZ3JvdXBfYnkiLCJzZXQiLCJlcXVpdiIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJmaW5kIiwiZmluZF9tYXAiLCJmaW5kX2V4biIsIm50aCIsInN0YWJsZV9kZWR1cF9saXN0IiwibGVmdG92ZXJzIiwiYWxyZWFkeV9zZWVuIiwidGwiLCJoZCIsInRfb2Zfc2V4cF9kaXJlY3QiLCJhX29mX3NleHAiLCJzZXhwIiwiZWx0X2xzdCIsImVsX3NleHAiLCJlbCIsInNleHBfb2ZfdCIsInNleHBfb2ZfYSIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwiY29tcGFyYXRvcl9zIiwidG9fbGlzdCIsImZvbGRfcmVzdWx0IiwiYiIsImNvbXBhcmVfZGlyZWN0Iiwib2YiLCJ0b19uYW1lZF90cmVlIiwibmFtZWQiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJoYXNoX2ZvbGRfZGlyZWN0IiwiaGFzaF9mb2xkX2VsZW0iLCJlbXB0eSIsIm9mX3RyZWUiLCJOYW1lZCIsIkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsIkVsdCIsInRvX2NvbXBhcmF0b3IiLCJNIiwic2V4cF9vZl9tX3QiLCJtX3Rfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX21fdCIsImVxdWFsX21fdCIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX21fdCIsImZvbGRlciIsImluY2x1ZGUiLCJCYXNlX1NldCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQ0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWpDLGlDQ3lFSTtBQUFBLElBQUFBLG1DQUFBO0FBQUEsSUFBQWtDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUM7QUFBQUEsSUFwQzJCLDhCQUNoQjtBQUFBLElBRGdCLG1CQUVMO0FBQUEsUUFBQUMsSUFGSztBQUFBLElBR3NDO0FBQUEsR0FBQztBQUFBLFlBQUFDLE9BQUFGO0FBQUFBLElBR3ZDLDhCQUNoQjtBQUFBLElBRGdCLG1CQUVMO0FBQUEsUUFBQUcsSUFGSztBQUFBLElBR3NDO0FBQUEsR0FBQztBQUFBLFlBQUFDLFNBQUFDLE9BQUFDLE9BQUFDLGFBQUFDO0FBQUFBLElBS2hFO0FBQUE7QUFBQSxNQUFBSCxVQUFBO0FBQUEsVUFFaUI7QUFBQTtBQUFBLGFBRE47QUFBQSxJQURYO0FBQUE7QUFBQSxVQUFBQyxVQUFBO0FBQUEsTUFNZ0Isc0RBQW1CO0FBQUE7QUFBQSxhQUR6QjtBQUFBO0FBQUE7QUFBQSxhQUxWO0FBQUE7QUFBQSxHQU11QztBQUFBLFlBQUFHLEtBQUFKLFNBQUFDLE9BQUFDLGFBQUFHO0FBQUFBLFFBQUFMLFFBR3ZDLFNBQUFLLElBQUE7QUFBQTtBQUFBLCtCQUNXO0FBQUEsS0FEWDtBQUFBLFVBQUFGLElBQUE7QUFBQSxNQUVzQiw2Q0FTZ0I7QUFBQTtBQUFBO0FBQUEsTUFBQUcsSUFYdEM7QUFBQSxNQUFBVixJQUFBO0FBQUEsTUFBQVcsSUFBQTtBQUFBLE1BQUFKLE1BQUE7QUFBQSxNQUFBSyxJQUFBO0FBQUEsTUFBQUMsS0FJVztBQUFBLE1BQUFDLEtBQ0E7QUFBQSxVQUNMO0FBQUEsVUFBSjtBQUFBLEtBQWE7QUFBQTtBQUFBLFdBQ047QUFBQTtBQUFBLE1BQWE7QUFBQTtBQUFBLFlBQ0Y7QUFBQSxZQUFYO0FBQUE7QUFBQTtBQUFBLE9BQXVCO0FBQUEsZ0JBQzNCO0FBQUEsUUFBa0M7QUFBQSxpQkFDbEM7QUFBQSxTQUFpQyxVQUFBVixVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBREM7QUFBQTtBQUFBO0FBQUEsZ0JBRFA7QUFBQTtBQUFBO0FBQUEsZUFEVjtBQUFBO0FBQUE7QUFBQSxjQURQO0FBQUE7QUFBQTtBQUFBLEdBS3VCO0FBQUEsWUFBQVcsV0FBQU4sR0FBQUgsYUFFbEIsaUNBQTRCO0FBQUEsWUFBQVUsU0FBQWpCLE9BR3JDLHdDQUV1QjtBQUFBLFlBQUFrQixPQUFBTCxHQUFBTCxHQUFBSTtBQUFBQTtBQUFBQSxLQUFBRSxLQVEzQjtBQUFBLEtBQUFDLEtBQ0E7QUFBQSxLQUFBZDtBQUFBQSxPQUNUO0FBQUEsVUFBeUI7QUFBQSxVQUFZO0FBQUEsSUFDckMsWUFDSztBQUFBO0FBQUEsS0FBQWtCLEtBRU07QUFBQSxLQUFBQyxLQUNBO0FBQUEsU0FDK0M7QUFBQSw0REFBVztBQUFBLEdBQUc7QUFBQSxZQUFBQywrQkFBQUMsS0FBQWxEO0FBQUFBLGFBQUFxQyxLQUFBRSxHQUFBdkMsR0FBQW1EO0FBQUFBLEtBT3RFO0FBQUE7QUFBQTtBQUFBLFNBQ087QUFBQTtBQUFBLGFBQUFDLE1BRUcsa0JBQ1I7QUFBQTtBQUFBO0FBQUEsVUFBQUMsS0FFUztBQUFBLFVBQUFELE1BQ0QsY0FBRTtBQUFBLFNBQ1YsOEJBWW1CO0FBQUE7QUFBQTtBQUFBLFVBQUFDLE9BVlY7QUFBQSxVQUFBRCxNQUNELGNBQUU7QUFBQSxVQUFBRSxLQUNELGNBQUU7QUFBQSxTQUNYLHNDQU9tQjtBQUFBO0FBQUE7QUFBQSxNQUFBQyxjQUxEO0FBQUEsVUFDQztBQUFBLE1BQUFDLGVBQUE7QUFBQSxNQUFBQyxPQUNSO0FBQUEsTUFBQUwsSUFDSCxjQUFFO0FBQUEsVUFDd0I7QUFBQSxNQUFBTSxRQUF0QixzQkFBcUI7QUFBQSxLQUNqQyw2QkFBbUI7QUFBQTtBQUFBLElBRXZCLHNCQUFhO0FBQUE7QUFBQSxZQUFBQywwQkFBQUMsT0FBQXpCO0FBQUFBLFFBQUEwQixlQUliO0FBQUE7QUFBQTtBQUFBLEtBQ0E7QUFBQSxjQUcrQztBQUFBLE1BQVYsUUFBWix3QkFBWTtBQUFBO0FBQUEsUUFBQUM7QUFBQUEsVUFFOUIsU0FBQVg7QUFBQUE7QUFBQUEsWUFBQSxJQUFnQjtBQUFBO0FBQUEsV0FBUCx3Q0FBNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUFXLE9BRHJDLFNBQUFYLEdBQVMsd0NBQVM7QUFBQTtBQUFBLElBR3pCLHlEQUEwRDtBQUFBO0FBQUEsWUFBQVksZ0JBQUFILE9BQUF6QjtBQUFBQSxRQUFBZSxNQUkxRDtBQUFBO0FBQUEsS0FHRTtBQUFBLHVCQUFBVjtBQUFBQTtBQUFBQSxnQkFBQSxJQUVnQztBQUFBLGdCQUFBVyxJQUF0Qix3QkFBWTtBQUFBLGdCQUFBYTtBQUFBQSxrQkFBbUI7QUFBQSxxQkFDOUI7QUFBQTtBQUFBLHNCQUFTO0FBQUE7QUFBQSxvQkFHTDtBQUFBLG9CQUFzQjtBQUFBO0FBQUEsb0JBQUFiLE1BQUE7QUFBQTtBQUFBO0FBQUEsc0JBQ0U7QUFBQSxzQkFBUDtBQUFBLGtCQUFBQTtBQUFBQSxvQkFBdEI7QUFBQSxtQ0FBWTtBQUFBLGlCQUF1QjtBQUFBLGtCQUNsQztBQUFBO0FBQUEsb0JBQVM7QUFBQTtBQUFBO0FBQUEsa0JBSVo7QUFBQTtBQUFBLG9CQUFTO0FBQUEseUJBTDRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQU9qQyx5REFBOEM7QUFBQSxnQkFBQztBQUFBLElBaEIvQix5REFBOEM7QUFBQSxHQWdCZjtBQUFBLFlBQUFjLElBQUF4QixHQUFBTCxHQUFBSTtBQUFBQSxRQUFBRSxLQU9wRCxXQUFBQyxLQUNBO0FBQUEsSUFDRDtBQUFBLEtBQ0g7QUFBQSxNQUVRO0FBQUEsS0FGUjtBQUFBLE1BR21CO0FBQUEsU0FBQXVCLEtBSG5CLE1BQUFDLEtBQUEsTUFBQUMsS0FBQSxVQUtlO0FBQUEsS0FBYixvQkFDZSxPQUFlLGVBQWYsaUJBeUJRO0FBQUEsS0F4QnJCO0FBQUEsTUFFUTtBQUFBLEtBRlI7QUFBQSxVQUFBQyxNQUFBLE9BQUFDLFFBQUEsT0FBQUMsTUFBQSxXQU82QjtBQUFBLE1BQXZCLE9BQWtCLE9BQWxCLDhCQWlCZTtBQUFBO0FBQUEsU0FBQUQsTUF4QnJCO0FBQUEsS0FJTTtBQUFBLE1BQWE7QUFBQSxhQUNZO0FBQUEsS0FBekIsT0FBb0IsT0FBcEIsMEJBbUJlO0FBQUE7QUFBQSxJQWhCakIsNENBZ0JSLHNCQUF5QjtBQUFBLElBZnpCO0FBQUEsS0FFUTtBQUFBLElBRlI7QUFBQSxLQUdtQjtBQUFBLFFBQUFFLEtBSG5CLE1BQUFDLEtBQUEsTUFBQUMsS0FBQSxVQUtlO0FBQUEsSUFBYixvQkFDUyxPQUFlLE9BQWYseUJBU2M7QUFBQSxJQVJyQjtBQUFBLEtBRVE7QUFBQSxJQUZSO0FBQUEsU0FBQUMsTUFBQSxPQUFBQyxRQUFBLE9BQUFDLE1BQUEsV0FPMkI7QUFBQSxLQUFyQixPQUFnQixPQUFoQiw0QkFDZTtBQUFBO0FBQUEsUUFBQUQsTUFSckI7QUFBQSxJQUlNO0FBQUEsS0FBYTtBQUFBLFlBQ1U7QUFBQSxJQUF2QixPQUFrQixPQUFsQix3QkFHZTtBQUFBO0FBQUEsT0FBQUUsT0E1SDlCO0FBQUEsWUFBQUMsSUFBQXpDLEdBQUEwQyxHQUFBN0M7QUFBQUEsYUFBQThDLElBQUFyRDtBQUFBQSxLQW9JYyw4QkFDRDtBQUFBLEtBREM7QUFBQSxVQUFBUSxJQUFBLFVBQUE4QyxJQUdGO0FBQUEsTUFDUjtBQUFBLGdCQUNLO0FBQUEseUJBR0EsdUJBREEsb0JBUWU7QUFBQTtBQUFBO0FBQUEsTUFBQTFDLElBZlY7QUFBQSxNQUFBSixNQUFBO0FBQUEsTUFBQUssSUFBQTtBQUFBLE1BQUF5QyxNQVVGO0FBQUEsS0FDUjtBQUFBLGVBQ0s7QUFBQSwwQkFHZSxZQUFQLFVBREcsSUFBUCxlQUNXO0FBQUE7QUFBQSxJQUV4QixZQUFJO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTUQ5TlI7QUFBQSxzQkMrTmM7QUFBQSxLRC9OZDtBQUFBO0FBQUEsR0MrTmU7QUFBQSxZQUFBQyxRQUFBSixHQUFBMUM7QUFBQUEsSUFLWCwwQkFDVztBQUFBLElBRFgsZUFFc0I7QUFBQSxRQUFBRSxJQUZ0QixNQUFBSixJQUFBLE1BQUFLLElBQUE7QUFBQSxJQUdxRSxPQUFhLElBQWIsb0JBQWlCO0FBQUE7QUFBQSxZQUFBNEMsUUFBQS9DLEdBQUEwQztBQUFBQSxJQUt0RiwwQkFDVztBQUFBLElBRFgsZUFFc0I7QUFBQSxRQUFBeEMsSUFGdEIsTUFBQUosSUFBQSxNQUFBSyxJQUFBO0FBQUEsSUFHeUUsT0FBYSxVQUFiLGNBQWE7QUFBQTtBQUFBLFlBQUE2QyxLQUFBN0MsR0FBQUwsR0FBQUk7QUFBQUEsSUFNdEYsMEJBQ2Msb0JBVUs7QUFBQSxJQVhuQjtBQUFBLFNBQUErQyxLQUFBLE1BQUFyQixLQUFBLE1BQUFDLE9BQUEsTUFBQUMsS0FBQTtBQUFBO0FBQUEseUJBQUFLLEtBQUEsTUFJa0MsT0FBYSxRQUFiLGtCQU9mO0FBQUEsVUFBQWUsS0FYbkIsTUFBQWhCLEtBQUEsTUFBQUMsT0FBQSxNQUFBQyxLQUFBO0FBQUEsTUFPVTtBQUFBLGdCQUNvQixjQUFiO0FBQUEsZ0JBQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFDUyxJQUFiO0FBQUEsa0JBQ0osZUFBWTtBQUFBO0FBQUE7QUFBQSxJQVhuQiwwQkFFYyxvQkFTSztBQUFBLFFBQUFQLEtBWG5CO0FBQUEsSUFHcUMsT0FBYSxZQUFiLGNBUWxCO0FBQUE7QUFBQSxZQUFBc0IsUUFBQTdEO0FBQUFBLFFBQUFBLFFBSUg7QUFBQTtBQUFBLG1DQUNMO0FBQUEsS0FESztBQUFBLFVBQUFRLElBQUE7QUFBQTtBQUFBLFVBQUFLLElBQUE7QUFBQTtBQUFBLFVBQUFMLElBQUE7QUFBQTtBQUFBLEtBR1g7QUFBQTtBQUFBLEdBQ3FFO0FBQUE7QUFBQSxJQUFBc0Q7QUFBQUEsTUEvTDFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQXFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQTlEO0FBQUFBLE1BRUUsMkNBRUU7QUFBQSxNQUNLO0FBQUEsS0FBYTtBQUFBO0FBQUEsSUFBQStEO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBUXRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBL0Q7QUFBQUEsTUFFRSwyQ0FFRTtBQUFBLE1BQ0s7QUFBQSxLQUFhO0FBQUE7QUFBQSxJQUFBZ0UseUJBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxZQUFBdkQ7QUFBQUEsUUFBQXdELFFBTWhCO0FBQUEsSUFBUztBQUFBLEtBQ0w7QUFBQSxRQUFBMUQsSUFESztBQUFBLElBRUg7QUFBQSxHQUFDO0FBQUEsWUFBQTJELFdBQUF6RCxHQUFBMEQsTUFBQWhHLEdBQUFpRztBQUFBQSxhQUFBQyxrQkFBQWxHLEdBQUFzQyxLQUFBNkQ7QUFBQUEsU0FBQTdELElBS1gsS0FBQTZELE1BQUE7QUFBQTtBQUFBLGdDQUNXO0FBQUEsTUFEWCxtQkFBQUMsUUFBQSxNQUUwQixnQ0FPMEI7QUFBQTtBQUFBLE9BQUExQyxRQVRwRDtBQUFBLE9BQUEwQyxVQUFBO0FBQUEsT0FBQTNDLE9BQUE7QUFBQSxPQUFBdUIsSUFJUztBQUFBLE1BQTZCLGVBQ2pCO0FBQUEsVUFBQW1CLFFBRGlCLE1BQUFuQixNQUcxQjtBQUFBLE1BQVcsaUJBQ0M7QUFBQSxVQUFBbUIsUUFERDtBQUFBLE1BRUQ7QUFBQTtBQUFBO0FBQUEsSUFBOEI7QUFBQSxRQUFBTCxRQUVoRDtBQUFBLElBQTJCLHVCQUFBZCxJQUFBLFVBQ2pCLDRCQUNIO0FBQUEsUUFBQUEsTUFGb0I7QUFBQSxJQUVyQjtBQUFBLEdBQUM7QUFBQSxZQUFBcUIsUUFBQXpFO0FBQUFBLFFBQUFBLFFBR0c7QUFBQTtBQUFBLG1DQUNMO0FBQUEsS0FESztBQUFBLFVBQUFRLElBQUE7QUFBQTtBQUFBLDJDQUFBSSxJQUFBLFVBSWlEO0FBQUEsVUFBQUosSUFKakQ7QUFBQTtBQUFBLEtBR1g7QUFBQTtBQUFBLEdBQ3FFO0FBQUEsWUFBQWtFLFlBQUFoRTtBQUFBQSxRQUFBd0QsUUFJcEU7QUFBQSxJQUFTO0FBQUEsS0FDTDtBQUFBLFFBQUExRCxJQURLO0FBQUEsSUFFSDtBQUFBLEdBQUM7QUFBQSxZQUFBbUUsZUFBQTNFO0FBQUFBLElBS1U7QUFBQSxLQUNaLDBEQUlpQjtBQUFBLElBTEwsbUJBRUQ7QUFBQSxRQUFBYSxJQUZDO0FBQUEsa0NBQUFELElBQUEsVUFHOEM7QUFBQSxRQUFBQSxNQUg5QyxVQUFBSixJQUFBO0FBQUEsSUFLakIsT0FBa0IsSUFBbEIsMEJBQXNCO0FBQUE7QUFBQSxZQUFBb0UsTUFBQUMsSUFBQUM7QUFBQUEsSUFNNUIsMkJBQ2M7QUFBQSxJQURkLDJCQUVjO0FBQUEsWUFDb0I7QUFBQSxJQUFqQixPQUFnQixRQUFoQixtQkFBb0M7QUFBQTtBQUFBLFlBQUFDLE9BQUFGLElBQUFDO0FBQUFBLElBTXJEO0FBQUEsU0FBQXBFLElBQUE7QUFBQTtBQUFBO0FBQUEsY0FFbUM7QUFBQSxNQUFqQixPQUFnQixTQUFoQixtQkFBb0M7QUFBQTtBQUFBLFNBQUFBLElBRnREO0FBQUE7QUFBQSxJQUN5QjtBQUFBLEdBQzZCO0FBQUEsWUFBQXNFLE1BQUF0RSxHQUFBMEMsR0FBQTdDO0FBQUFBLGFBQUF5RSxNQUFBdEU7QUFBQUEsS0FLcEQsMEJBQ1c7QUFBQSxLQURYO0FBQUEsVUFBQUYsSUFBQSxNQUFBOEMsSUFHVTtBQUFBLE1BQ1I7QUFBQTtBQUFBLDhEQWU2QjtBQUFBO0FBQUE7QUFBQSxNQUFBMUMsSUFuQi9CO0FBQUEsTUFBQUosTUFBQTtBQUFBLE1BQUFLLElBQUE7QUFBQSxNQUFBeUMsTUFVVTtBQUFBLEtBQ1IsY0FDSztBQUFBLEtBQ0E7QUFBQTtBQUFBLE9BQUFZLFFBS3FCO0FBQUEsT0FBQXRCLEtBQU87QUFBQSxPQUFBcUMsWUFBQTtBQUFBLE9BQUEzQyxLQUFBO0FBQUEsTUFDL0IsMkNBQVc7QUFBQTtBQUFBO0FBQUEsTUFBQTRCLFVBSmE7QUFBQSxNQUFBcEIsS0FBTztBQUFBLE1BQUFtQyxjQUFBO0FBQUEsTUFBQXpDLEtBQUE7QUFBQSxLQUNoQiw2Q0FBVztBQUFBLElBR0M7QUFBQSxJQUVqQyxlQUFPO0FBQUE7QUFBQSxZQUFBMEMsWUFBQXhFLEdBQUEwQyxHQUFBN0M7QUFBQUEsSUFJUCwwQkFDVztBQUFBLElBRFg7QUFBQSxTQUFBQyxJQUFBO0FBQUEsS0FHSztBQUFBO0FBQUEsNkJBV2U7QUFBQTtBQUFBLFFBQUFJLElBZHBCLE1BQUFKLE1BQUEsTUFBQUssSUFBQSxNQUFBeUMsSUFLVTtBQUFBLElBQ1IsWUFDSyw4QkFBVztBQUFBLElBQ1g7QUFBQSxTQUFBWSxRQUtVLGdDQUFBdEIsS0FBNEIsVUFBQU4sS0FBQTtBQUFBLEtBQ3pDLGdDQUFXO0FBQUE7QUFBQTtBQUFBLEtBQUE0QixVQUpFO0FBQUEsS0FBQXBCLEtBQTRCO0FBQUEsS0FBQU4sS0FBQTtBQUFBLElBQ3JDLGdDQUFXO0FBQUEsR0FHQztBQUFBLFlBQUEyQyxZQUFBekUsR0FBQTBDLEdBQUE3QztBQUFBQSxJQUlwQiwwQkFDVztBQUFBLElBRFg7QUFBQSxTQUFBQyxJQUFBO0FBQUEsS0FHSztBQUFBO0FBQUEsNkJBV2U7QUFBQTtBQUFBLFFBQUFJLElBZHBCLE1BQUFKLE1BQUEsTUFBQUssSUFBQSxNQUFBeUMsSUFLVTtBQUFBLElBQ1IsWUFDUSw4QkFBVztBQUFBLElBQ2Q7QUFBQSxTQUFBWSxRQUtVLGdDQUFBdEIsS0FBNEIsVUFBQU4sS0FBQTtBQUFBLEtBQ3pDLGdDQUFXO0FBQUE7QUFBQTtBQUFBLEtBQUE0QixVQUpFO0FBQUEsS0FBQXBCLEtBQTRCO0FBQUEsS0FBQU4sS0FBQTtBQUFBLElBQ3JDLGdDQUFXO0FBQUEsR0FHQztBQUFBLE9BQUE0QyxpQ0FoSUU7QUFBQSxZQUFBQyxJQUFBM0UsS0FBQTBDLEdBQUE3QztBQUFBQSxRQUFBRyxJQXdJdEI7QUFBQTtBQUFBLCtCQUNXO0FBQUEsS0FEWDtBQUFBLFVBQUFGLElBQUEsTUFBQThDLElBR1U7QUFBQSxNQUNSO0FBQUE7QUFBQTtBQUFBLE1BQUExQyxJQUpGO0FBQUEsTUFBQUosTUFBQTtBQUFBLE1BQUFLLElBQUE7QUFBQSxNQUFBeUMsTUFNVTtBQUFBLFVBQ1I7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFvRDtBQUFBLFlBQUFnQyxPQUFBNUUsR0FBQTBDLEdBQUE3QztBQUFBQSxhQUFBOEMsSUFBQTNDO0FBQUFBLEtBT3BELDBCQUNXLG1DQUtzRTtBQUFBLEtBTmpGO0FBQUEsVUFBQUYsSUFBQTtBQUFBLE1BR0s7QUFBQTtBQUFBLGdCQUFvQyw0QkFHd0M7QUFBQTtBQUFBLFNBQUFJLElBTmpGLE1BQUFKLE1BQUEsTUFBQUssSUFBQSxNQUFBeUMsSUFLVTtBQUFBLEtBQ1I7QUFBQSxlQUFjO0FBQUEsd0JBQWlFLFlBQVAsVUFBbEIsSUFBUCxlQUFnQztBQUFBO0FBQUEsSUFFbkYsWUFBSTtBQUFBLFVBQUFDO0FBQUFBLFNBQUFBLE1EOWJSO0FBQUEsc0JDK2JjO0FBQUEsS0QvYmQ7QUFBQTtBQUFBLEdDK2JlO0FBQUEsWUFBQWdDLGFBQUE3RSxHQUFBYSxHQUFBdkI7QUFBQUEsYUFBQXFELElBQUEzQyxHQUFBYTtBQUFBQSxLQUtULDBCQUNXLG1DQVM0QjtBQUFBLEtBVnZDLGVBRXNCLHFCQUF5Qiw0QkFRUjtBQUFBO0FBQUEsTUFBQVgsSUFWdkM7QUFBQSxNQUFBSixJQUFBO0FBQUEsTUFBQUssSUFBQTtBQUFBLE1BQUEyRSxTQUllO0FBQUEsTUFBQWxDLElBQ2I7QUFBQSxLQUNBLFlBQ0ssa0JBR2dDO0FBQUEsS0FGaEMsVUFDSSxPQUFTLElBQVQsZ0JBQzRCO0FBQUEsYUFBaEI7QUFBQSxLQUFELE9BQWlCLFVBQXhCLE9BQU8sa0NBQWlCO0FBQUE7QUFBQSxJQUV6QyxZQUFJO0FBQUEsVUFBQUM7QUFBQUEsU0FBQUEsTURoZFI7QUFBQSxzQkNpZGM7QUFBQSxLRGpkZDtBQUFBO0FBQUEsR0NpZGU7QUFBQSxZQUFBa0MsTUFBQUMsSUFBQUMsSUFBQXBGO0FBQUFBLGFBQUFrRixNQUFBQyxNQUFBQztBQUFBQSxTQUFBRCxLQUtULE1BQUFDLEtBQUE7QUFBQTtBQUFBLG9CQUNLO0FBQUEsTUFDQTtBQUFBLFdBQUFqRixJQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFrRixLQUFBLE9BQUFDLEtBQUEsT0FBQUMsT0FBQSxPQUFBQyxLQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDLEtBQUEsT0FBQUwsT0FNRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FOQztBQUFBLFlBQUFHLEtBQUEsT0FBQUosT0FJRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQUFoRixJQUpDO0FBQUE7QUFBQSxNQUVzQjtBQUFBO0FBQUEsU0FBQXVGLEtBSjNCLE9BQUFDLEtBQUEsT0FBQUYsT0FBQSxPQUFBRyxLQUFBO0FBQUEsS0FXSTtBQUFBLE1BRUUsYUFDSyxpQ0FRZ0M7QUFBQTtBQUFBLE9BQUFqQyxRQU5uQjtBQUFBLE9BQUFnQyxPQUF3QjtBQUFBLE9BQUFDLE9BQUE7QUFBQSxXQUNsQjtBQUFBLE1BQWpCLE9BQWEsS0FBYix5QkFLOEI7QUFBQTtBQUFBLEtBSmxDLGFBQ0EsaUNBR2tDO0FBQUE7QUFBQSxNQUFBakMsVUFEckI7QUFBQSxNQUFBMkIsT0FBd0I7QUFBQSxNQUFBRSxPQUFBO0FBQUEsVUFDbEI7QUFBQSxLQUFqQixPQUFhLEtBQWIseUJBQWdDO0FBQUE7QUFBQSxJQUU3QyxvQkFBVztBQUFBO0FBQUEsWUFBQUssV0FBQUMsWUFBQUMsU0FBQUM7QUFBQUEsUUFBQWhHLGNBSVg7QUFBQSxJQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUFpRyxJQUFBcEQ7QUFBQUEsY0FBa0QsT0FBVyxVQUFYLG9DQUF3QjtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFxRCxNQUFBZixJQUFBQyxJQUFBcEY7QUFBQUEsYUFBQWtHLE1BQUFmLElBQUFDO0FBQUFBLEtBS3pFLGNBQ0s7QUFBQSxLQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQUFFLEtBQUE7QUFBQSxVQUFBQyxLQUFBO0FBQUEsVUFBQUMsS0FBQTtBQUFBLGNBTU07QUFBQSxVQUFBN0IsUUFBd0I7QUFBQSxVQUFBaUMsS0FBQTtBQUFBO0FBQUEsY0FBQUQsS0FBQSxNQUFBSixPQUFBLGNBRWE7QUFBQSxVQUFqQixPQUFhLEtBQWIsdUJBQWdDO0FBQUE7QUFBQSxhQUFBSSxPQUY1QixVQUNTO0FBQUEsU0FBZCxPQUFhLE9BQWIsaUJBQ2lDO0FBQUE7QUFBQSxZQUFBUSxZQVIxRCxJQUFBQyxZQUFBLElBQUFDLE1BQUE7QUFBQTtBQUFBO0FBQUEsV0FBQUYsWUFBQSxJQUFBQyxZQUFBLElBQUFDLE1BQUE7QUFBQTtBQUFBLE1BSUssdURBSXFEO0FBQUE7QUFBQSxLQU5wQztBQUFBLElBTW9DO0FBQUEsSUFFakUsb0JBQVc7QUFBQTtBQUFBLFlBQUFDLEtBQUFuQixJQUFBQyxJQUFBcEY7QUFBQUEsYUFBQXNHLEtBQUFuQixNQUFBQztBQUFBQSxTQUFBRCxLQUtUO0FBQUE7QUFBQSxvQkFDSztBQUFBLE1BQ0EsMkJBRVc7QUFBQSxNQUZYLDJCQUdZO0FBQUEsTUFIWjtBQUFBO0FBQUEsUUFBQUcsS0FBQTtBQUFBLFFBQUFDLE9BQUE7QUFBQSxRQUFBQyxLQUFBO0FBQUEsWUFPTTtBQUFBLFFBQUFJLEtBQXdCO0FBQUE7QUFBQSxZQUFBRCxLQUFBLFVBRVU7QUFBQSxRQUFiLE9BQVksT0FBWixnQkFBMkI7QUFBQTtBQUFBLFdBQUFBLE9BRnhCLFVBQ1M7QUFBQSxPQUFoQixPQUFZLEtBQVosc0JBQytCO0FBQUE7QUFBQSxVQUFBSixLQVR0RCxPQUFBSixPQUtEO0FBQUE7QUFBQTtBQUFBLElBSXVEO0FBQUEsSUFFN0QsbUJBQVU7QUFBQTtBQUFBLFlBQUFvQixLQUFBM0csS0FBQTRHO0FBQUFBLFFBQUE1RyxJQVlSLEtBQUE0RyxJQUFBO0FBQUE7QUFBQSwrQkFDVztBQUFBLEtBRFgsbUJBQUF2RyxJQUFBLE1BRXNCO0FBQUEsU0FBQUksSUFGdEIsTUFBQUosTUFBQSxNQUFBSyxJQUFBLE1BQUFrRyxNQUlFO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBdUI7QUFBQSxZQUFBQyxXQUFBN0csS0FBQTRHO0FBQUFBLFFBQUE1RyxJQUl6QixLQUFBNEcsSUFBQTtBQUFBO0FBQUEsK0JBQ1c7QUFBQSxLQURYLG1CQUFBdkcsSUFBQSxNQUVzQjtBQUFBLFNBQUFJLElBRnRCLE1BQUFKLE1BQUEsTUFBQUssSUFBQSxNQUFBa0csTUFJRTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQTZCO0FBQUEsWUFBQUUsT0FBQTlHLEdBR0UsaUJBQVU7QUFBQSxZQUFBK0csZUFBQXJDLElBQUFDLElBQUF2RTtBQUFBQSxhQUFBNEcsS0FBQUM7QUFBQUEsU0FBQXZGLE9BZ0Z6QztBQUFBO0FBQUEsVUFBQXFDLFFBQUE7QUFBQSxrQkFDYztBQUFBLFVBQUFtRCxTQURkLFVBQUFDLFNBQUEsVUFBQVYsUUFBQTtBQUFBLE1BRzJDLG9EQUFjO0FBQUE7QUFBQSxTQUFBOUUsUUFIekQsVUFBQXVGLFFBQUEsU0FBQUMsT0FBQSxTQUFBVixNQUFBO0FBQUEsaUJBS3FDLCtDQUFjO0FBQUE7QUFBQSxNQUFBVyxRQUxuRDtBQUFBLE1BQUFDLFFBQUE7QUFBQSxNQUFBL0ksS0FBQTtBQUFBLE1BQUFnSixpQkFPdUI7QUFBQSxLQUNyQjtBQUFBLE1BUUs7QUFBQSx1Q0FFeUM7QUFBQSxrQ0FEUCwwQkFDeUI7QUFBQSxLQVQzRDtBQUFBLFVBQUFDLGFBR0k7QUFBQTtBQUFBLGNBQ2tCLG9CQUFBQSxhQUFGLElBQWhCO0FBQUEsS0FFUDtBQUFBLElBRzhEO0FBQUEsWUFFN0IsZ0JBQVg7QUFBQSxJQUFTLDRDQUFvQjtBQUFBO0FBQUEsWUFBQUM7QUFBQUEsSUFBQXRCLFlBQUF1QixLQUFBQyxxQkFBQUMsa0JBQUFwSDtBQUFBQSxRQUFBcUgsUUFrQzNEO0FBQUEsYUFBQUMsZ0JBQUFDLE1BQUF2SCxHQUFBd0g7QUFBQUE7QUFBQUEsTUFBQTNILGNBT0U7QUFBQSxNQUFBMkQsUUFDa0I7QUFBQSxNQUFBdEQsSUFBMEI7QUFBQSxNQUFBdUgsUUFBQTtBQUFBLE1BQUF0SCxJQUFBO0FBQUEsTUFBQUgsTUFDcEM7QUFBQSxLQUNSLFlBQ1U7QUFBQSxTQUFBa0csTUFEVjtBQUFBLEtBRWMsaUNBQXNCO0FBQUE7QUFBQSxJQUV0QztBQUFBO0FBQUEsVUFFa0Q7QUFBQSxNQUFBbEc7QUFBQUEsUUFBeEM7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFBd0M7QUFBQSxNQUFBd0I7QUFBQUEsUUE3Q2xELFNBQUFtRjtBQUFBQSxTQUNFLFlBQ2M7QUFBQSxhQUFBTixJQURkLFVBQUFyRyxJQUFBLFVBQUFjLElBQUE7QUFBQSxTQUVrRSx5QkFBYTtBQUFBLFFBQUU7QUFBQSxLQUVuRjtBQUFBO0FBQUEsT0FBQTRHLE1BQUE7QUFBQSxPQUFBQyxVQUdnQjtBQUFBLE9BQUEzSCxJQW5HZDtBQUFBLE9BQUFxRyxJQUFBO0FBQUE7QUFBQSxPQVRFLDhCQUFBM0MsT0FBQTtBQUFBO0FBQUEsWUFBQTVELElBQUEsTUFBQUUsTUFHRTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFHLElBSEYsTUFBQUQsSUFBQSxNQUFBSixNQUFBO0FBQUEsUUFLTztBQUFBLGFBQUFJLE1BQWEsTUFBQUosTUFBQSxNQUFBdUcsTUFFbEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRmtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBM0MsT0FzR1o7QUFBQSxLQUdaLCtDQXVDZ0U7QUFBQTtBQUFBO0FBQUEsU0FEWDtBQUFBLEtBQUExRDtBQUFBQSxPQUEzQztBQUFBO0FBQUE7QUFBQTtBQUFBLHdCQUEyQztBQUFBLGFBQUF3QixPQUFBbUY7QUFBQUEsS0FqQ25ELFlBQ2M7QUFBQSxTQUFBTixJQURkLFVBQUFyRyxJQUFBLFVBQUFjLElBQUE7QUFBQSxLQUcyQywrQkFBbUI7QUFBQSxJQUFFO0FBQUEsSUFFbEU7QUFBQTtBQUFBLE1BQUE0RyxRQUFBO0FBQUEsTUFBQUMsWUFHZ0I7QUFBQSxNQUFBM0gsTUFwR2Q7QUFBQSxNQUFBcUcsTUFBQTtBQUFBO0FBQUEsTUFURSxnQ0FBQTNDLFNBQUE7QUFBQTtBQUFBLFdBQUE1RCxNQUFBLFFBQUFFLE1BR0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBRyxNQUhGLFFBQUFMLE1BQUE7QUFBQSxPQUtPO0FBQUEsUUFBYTtBQUFBO0FBQUEsWUFBQUksTUFBQSxRQUFBSixNQUFBLFFBQUF1RyxNQUVsQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FBQTNDLFNBekJtQztBQUFBLElBaUl6QyxtREF3QmdFO0FBQUE7QUFBQSxZQUFBa0Usc0JBQUE1SCxLQUFBdEM7QUFBQUEsUUFBQXNDLElBSWhFO0FBQUE7QUFBQSwrQkFDVztBQUFBLEtBRFgsbUJBQUFGLElBQUEsTUFFeUIsb0NBT1E7QUFBQSxTQUFBSSxJQVRqQyxNQUFBSixNQUFBLE1BQUFLLElBQUE7QUFBQSxLQUlLO0FBQUEsVUFBQXVDLElBRUs7QUFBQSxNQUEwQix1QkFHSDtBQUFBO0FBQUEsS0FMekI7QUFBQTtBQUFBLEdBS3lCO0FBQUEsWUFBQW1GLHFCQUFBN0gsS0FBQXRDO0FBQUFBLFFBQUFzQyxJQUlqQztBQUFBO0FBQUEsK0JBQ1c7QUFBQSxLQURYLG1CQUFBRixJQUFBLE1BRXlCLG9DQU9PO0FBQUEsU0FBQUksSUFUaEMsTUFBQUosTUFBQSxNQUFBSyxJQUFBO0FBQUEsS0FJSztBQUFBLFVBQUF1QyxJQUVLO0FBQUEsTUFBeUIsdUJBR0g7QUFBQTtBQUFBLEtBTHhCO0FBQUE7QUFBQSxHQUt3QjtBQUFBLFlBQUFvRixjQUFBOUgsR0FBQTJILFNBQUFJLEtBQUFqSTtBQUFBQSxJQUloQztBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQWNFO0FBQUE7QUFBQSwyQkFBQTRDLEdBQXFDLDZDQUFXLENBQUs7QUFBQSxpQkFackQ7QUFBQTtBQUFBLDJCQUFBQSxHQUFvQyw0Q0FBVyxDQUFJO0FBQUE7QUFBQTtBQUFBLGlCQUVuRDtBQUFBO0FBQUEsMkJBQUFBLEdBQW9DLDZDQUFXLENBQUs7QUFBQSxpQkFZcEQ7QUFBQTtBQUFBLDJCQUFBQSxHQUFxQyw0Q0FBVyxDQUFJLEVBQVk7QUFBQSxJQWhCbEU7QUFBQTtBQUFBLE1BQUF3RDtBQUFBQSxRQVVTO0FBQUEsc0JBQUF4RCxHQUFvQyw2Q0FBVyxDQUFLO0FBQUEsS0FBQyxZQUFBQSxJQUFBLFFBQ3RDLG9DQUFtQjtBQUFBLEtBQ3JCO0FBQUE7QUFBQTtBQUFBLEtBQUF3RDtBQUFBQSxPQU5iO0FBQUEscUJBQUF4RCxHQUFxQyw2Q0FBVyxDQUFLO0FBQUEsSUFBQztBQUFBLFNBQUFBLE1BQUE7QUFBQSxLQUN2QyxzQ0FBbUI7QUFBQTtBQUFBLElBQ3JCO0FBQUEsR0FRNEM7QUFBQSxZQUFBc0Ysd0JBQUFoSSxHQUFBaUksWUFBQUY7QUFBQUEsYUFBQUcsUUFBQXhGO0FBQUFBLEtBSzFELHFEQUVXO0FBQUE7QUFBQSxhQUFBeUYsU0FBQXpGLEdBRUUscUJBQVc7QUFBQSxJQUNoQztBQUFBLGNBQ21CO0FBQUEsY0FDRSxrQ0FBOEM7QUFBQTtBQUFBLFlBQUEwRjtBQUFBQSxJQUFBekMsWUFBQXVCLEtBQUFDLHFCQUFBQyxrQkFBQXBILEtBQUFBO0FBQUFBLFFBQUFxSCxRQUluRTtBQUFBLElBT0E7QUFBQSxhQUtzQjtBQUFBO0FBQUE7QUFBQSxVQUNBO0FBQUE7QUFBQSxVQUEwQixlQUExQjtBQUFBO0FBQUE7QUFBQSxPQUpwQjtBQUFBO0FBQUE7QUFBQSxPQURBO0FBQUE7QUFBQSxJQUF3RSw0Q0FLekI7QUFBQTtBQUFBLFlBQUFNLFFBQUE5SCxhQUFBbUYsSUFBQUM7QUFBQUEsUUFBQW9ELE9BSVAsWUFBQUMsT0FBakIsWUFBQUEsS0E1THZCLE1BQUFELEtBQUE7QUFBQTtBQUFBLEtBWkUsMkJBd01zRDtBQUFBLEtBeE10RCxTQUdZO0FBQUE7QUFBQSxNQUFBQSxPQUhaO0FBQUEsTUFBQTdDLEtBQUE7QUFBQSxNQUFBRixLQUFBO0FBQUEsTUFBQWdELE9BQUE7QUFBQSxNQUFBbkQsS0FBQTtBQUFBLE1BQUFDLEtBQUE7QUFBQSxNQUFBeEMsSUFLVTtBQUFBLEtBQ1IsWUFDSztBQUFBLEtBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQUF5RixPQUVrQixnQkFBQUMsT0FBYjtBQUFBLE1BQVk7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQThMOEI7QUFBQSxZQUFBQyxNQUFBdkQsSUFBQUMsSUFBQXBGLGFBQUFuQztBQUFBQSxRQUFBMEcsT0FJbEIsWUFBQUQsT0FBakI7QUFBQTtBQUFBO0FBQUEsU0FBQUEsS0FsS3JCLE1BQUFDLEtBQUE7QUFBQTtBQUFBLE1BbEJFO0FBQUEsbUJBQUE5RSxVQUFBO0FBQUE7QUFBQSxPQUFBdUgsUUFBQTtBQUFBLE9BQUFDLFFBQUE7QUFBQSxPQUFBL0ksS0FBQTtBQUFBLE9BQUF5SyxRQUFBO0FBQUEsT0FBQUMsUUFBQTtBQUFBLE9BQUE1SyxLQUFBO0FBQUEsT0FBQWtKLGlCQUt1QjtBQUFBLE1BQ3JCO0FBQUEsT0FFRTtBQUFBLFdBQUEzQyxPQUN3QixvQkFBQUQsT0FBbkI7QUFBQSxPQUFrQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BTXZCO0FBQUEsV0FBQUMsT0FDUTtBQUFBLE9BQWtCO0FBQUE7QUFBQTtBQUFBLE9BSjFCO0FBQUEsV0FBQUQsT0FDSztBQUFBLE9BQWtCO0FBQUE7QUFBQTtBQUFBLEtBSzdCLFNBakJnQjtBQUFBLFNBQUE3RSxRQWlCaEI7QUFBQTtBQUFBLE1BM0JXLFlBQ0Y7QUFBQSxVQUFBcUgsUUFERSxVQUFBQyxPQUFBLFVBQUE4QixJQUFBO0FBQUEsTUFXd0I7QUFBQSxNQVBaLFFBQWhCO0FBQUE7QUFBQTtBQUFBLElBdUJQO0FBQUEsS0EzQlcsY0FDRjtBQUFBLFNBQUEvQixTQURFLFlBQUFDLFNBQUEsWUFBQThCLE1BQUE7QUFBQSxLQVl3QjtBQUFBLEtBUlosVUFBaEI7QUFBQTtBQUFBLEdBeUxrRDtBQUFBLFlBQUFDLE1BQUEzRCxJQUFBQyxJQUFBcEY7QUFBQUEsSUFHOUIsaURBQXlCO0FBQUEsR0FBSTtBQUFBLFlBQUErSSxVQUFBNUQsSUFBQUMsSUFBQXBGO0FBQUFBLGFBQUErSSxVQUFBNUQsTUFBQUM7QUFBQUEsU0FBQUQsS0FJeEQsTUFBQUMsS0FBQTtBQUFBO0FBQUEsaUNBQ2M7QUFBQSxNQURkO0FBQUEsV0FBQUUsS0FBQSxPQUFBQyxPQUFBLE9BQUFDLEtBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUMsS0FBQTtBQUFBLFNBTUU7QUFBQSxVQUlHLHNEQUFpQjtBQUFBLFNBQ1Q7QUFBQTtBQUFBO0FBQUEsU0FBQUUsS0FYYjtBQUFBLFNBQUFGLE9BQUE7QUFBQSxTQUFBRyxLQUFBO0FBQUEsU0FBQTdDLElBY1U7QUFBQSxRQUNSO0FBQUEsU0FJSztBQUFBLGtCQU9IO0FBQUEsVUFFUztBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQVBUO0FBQUEsU0FFUztBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQU5UO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQXFCO0FBQUEsU0FBb0I7QUFBQTtBQUFBO0FBQUEsUUFBekM7QUFBQTtBQUFBO0FBQUEsTUFqQkosMkJBRWM7QUFBQSxVQUFBd0MsS0FGZDtBQUFBLE1BRzJCLCtCQTBCQTtBQUFBO0FBQUE7QUFBQSxJQUU3Qix3QkFBb0I7QUFBQTtBQUFBLFlBQUF5RCxhQUFBN0QsTUFBQUMsTUFBQXBGO0FBQUFBLFFBQUFtRixLQUlwQixNQUFBQyxLQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUUsS0FBQSxPQUFBQyxLQUFBLE9BQUFDLEtBQUE7QUFBQSxTQUtFLGNBQ0s7QUFBQSxpQkFFRyw0QkFBQUksS0FBd0I7QUFBQSxrQkFHWjtBQUFBLGFBQUFELEtBSFksVUFFNUI7QUFBQSxTQUErQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQVEsWUFWckMsSUFBQUUsTUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBRixZQUFBLElBQUFFLE1BQUE7QUFBQTtBQUFBLE1BR00sMkNBQWdDO0FBQUE7QUFBQSxLQUZiO0FBQUE7QUFBQSxHQVVHO0FBQUEsWUFBQTRDLEtBQUE5SSxHQUFBdEM7QUFBQUEsYUFBQW9MLEtBQUF4SjtBQUFBQSxTQUFBQSxRQUliO0FBQUE7QUFBQSxvQ0FDRjtBQUFBLE1BREUsdUJBQUFRLElBQUEsVUFFUyx1QkFJZDtBQUFBLFVBQUFJLElBTkssVUFBQUosTUFBQSxVQUFBSyxJQUFBO0FBQUEsTUFJWDtBQUFBLE1BQ0E7QUFBQSxNQUFHO0FBQUE7QUFBQSxJQUNHO0FBQUEsSUFFVixjQUFpQjtBQUFBO0FBQUEsWUFBQTRJLEtBQUF0SixLQUFBdUosUUFBQXRMO0FBQUFBLFFBQUErQixJQU1qQixLQUFBdUosT0FBQTtBQUFBO0FBQUEsK0JBQ1c7QUFBQSxLQURYLG1CQUFBbEosSUFBQSxNQUVzQiw2QkFFd0I7QUFBQTtBQUFBLE1BQUFJLElBSjlDO0FBQUEsTUFBQUosTUFBQTtBQUFBLE1BQUFLLElBQUE7QUFBQSxNQUFBNkksU0FJa0IsY0FBRztBQUFBLEtBQXlCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsTUFBQWpKLEdBQUF0QyxHQU8vQiwrQ0FBMEI7QUFBQSxZQUFBd0wsSUFBQUMsR0FBQW5KLEdBQUF0QyxHQUMxQixrREFBMEI7QUFBQSxZQUFBMEwsV0FBQTNKLEtBQUF1SixRQUFBdEw7QUFBQUEsUUFBQStCLElBR3pDLEtBQUF1SixPQUFBO0FBQUE7QUFBQSwrQkFDVztBQUFBLEtBRFgsbUJBQUFsSixJQUFBLE1BRXNCLDZCQUVvQztBQUFBO0FBQUEsTUFBQUksSUFKMUQ7QUFBQSxNQUFBSixNQUFBO0FBQUEsTUFBQUssSUFBQTtBQUFBLE1BQUE2SSxTQUl3QixtQkFBSztBQUFBLEtBQTZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUssUUFBQXJKLEtBQUFzSjtBQUFBQSxRQUFBdEosSUFJMUQ7QUFBQTtBQUFBLCtCQUNXO0FBQUEsS0FEWCxtQkFBQUYsSUFBQSxNQUVzQix1QkFFbUI7QUFBQSxTQUFBSSxJQUp6QyxNQUFBSixNQUFBLE1BQUFLLElBQUEsVUFJRTtBQUFBLEtBQUc7QUFBQSxjQUFJO0FBQUEsTUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQWxCO0FBQUE7QUFBQTtBQUFBLEdBQW9DO0FBQUEsWUFBQW9KLE9BQUF2SixLQUFBc0o7QUFBQUEsUUFBQXRKLElBSXpDO0FBQUE7QUFBQSwrQkFDVztBQUFBLEtBRFgsbUJBQUFGLElBQUEsTUFFc0IsdUJBRWlCO0FBQUEsU0FBQUksSUFKdkMsTUFBQUosTUFBQSxNQUFBSyxJQUFBLFVBSUU7QUFBQSxLQUFHO0FBQUE7QUFBQSxrQkFBSSxjQUFhO0FBQUEsS0FBakI7QUFBQTtBQUFBLEdBQWtDO0FBQUEsWUFBQXFKLE9BQUEvSixHQUFBNko7QUFBQUEsYUFBQUcsS0FBQXpKO0FBQUFBLEtBSXhCLDBCQUNGO0FBQUEsS0FERSxtQkFBQUYsSUFBQSxNQUVpQiwrQkFTWDtBQUFBO0FBQUEsTUFBQUksSUFYTjtBQUFBLE1BQUFKLE1BQUE7QUFBQSxNQUFBSyxJQUFBO0FBQUEsTUFBQUEsTUFJRjtBQUFBLE1BQUF1SixTQUNJO0FBQUEsTUFBQXhKLE1BQ0o7QUFBQSxLQUNULHFDQUNLO0FBQUEsS0FDQSxnQkFDQSxzQkFDQSxnQkFBWTtBQUFBO0FBQUEsSUFFckIsY0FBaUI7QUFBQTtBQUFBLFlBQUF5SixXQUFBbEssR0FBQTZKLEdBQUF6SjtBQUFBQSxhQUFBNEosS0FBQVQsUUFBQTFKO0FBQUFBLFNBQUEwSixPQUlKLFFBQUExSixRQUFBO0FBQUE7QUFBQSxvQ0FDQTtBQUFBLE1BREE7QUFBQSxXQUFBUSxJQUFBLFVBQUEwRCxRQUdGO0FBQUEsT0FBRyxZQUNDO0FBQUEsV0FBQTFELE1BREQ7QUFBQSxPQUVHLGtDQVFWO0FBQUE7QUFBQTtBQUFBLE9BQUFJLElBYk07QUFBQSxPQUFBSixNQUFBO0FBQUEsT0FBQUssSUFBQTtBQUFBLE9BQUFxRCxVQVNHO0FBQUEsTUFBRztBQUFBLFdBQUExRCxNQUFBLGdCQUVHO0FBQUE7QUFBQSxlQUZIO0FBQUEsVUFBQWtKLFNBRGI7QUFBQSxNQUlLO0FBQUE7QUFBQTtBQUFBLElBQ0o7QUFBQSxJQUVQLGlCQUF1QjtBQUFBO0FBQUEsWUFBQVksYUFBQW5LLEdBQUE2SjtBQUFBQSxhQUFBdkosS0FBQUM7QUFBQUEsS0FJUiwwQkFDRjtBQUFBLEtBREU7QUFBQSxVQUFBRixJQUFBO0FBQUEsTUFFaUIsK0NBWWtCO0FBQUE7QUFBQTtBQUFBLE1BQUFJLElBZG5DO0FBQUEsTUFBQUosTUFBQTtBQUFBLE1BQUFLLElBQUE7QUFBQSxNQUFBcUQsUUFJSTtBQUFBLE1BQUFxRyxNQUFNO0FBQUEsTUFBQUMsTUFBQTtBQUFBLE1BQUFDLFdBQ047QUFBQSxNQUFBdkcsVUFDQTtBQUFBLE1BQUF3RyxNQUFNO0FBQUEsTUFBQUMsTUFBQTtBQUFBLGNBQUFDLEdBQUFSLFFBQUF2SixLQUFBRDtBQUFBQSxNQUVuQixxQ0FDSztBQUFBLE1BQ0EsZ0JBQ0Esc0JBQ0EsZ0JBQVk7QUFBQTtBQUFBLGFBRUU7QUFBQSxLQUFyQixxQ0FBbUI7QUFBQSxJQUEyQjtBQUFBLElBRWxELGNBQWlCO0FBQUE7QUFBQSxZQUFBaUssYUFBQW5CLFFBQUExSjtBQUFBQSxRQUFBMEosT0FHRSxRQUFBMUosUUFBQTtBQUFBO0FBQUEsbUNBQ1I7QUFBQSxLQURRLHVCQUFBUSxJQUFBLFVBRUc7QUFBQTtBQUFBLE1BQUFJLElBRkg7QUFBQSxNQUFBSixNQUFBO0FBQUEsTUFBQUssSUFBQTtBQUFBLE1BQUE2SSxTQUlFO0FBQUEsS0FBbUI7QUFBQTtBQUFBO0FBQUEsR0FBRztBQUFBLFlBQUFvQixTQUFBM0ssR0FHNUIseUJBQWlCO0FBQUEsWUFBQTRLLE9BQUFySztBQUFBQSxJQUdoQywwQkFDVztBQUFBLElBRFgsbUJBQUFGLElBQUEsTUFFc0I7QUFBQSxRQUFBQSxNQUZ0QjtBQUFBLElBR2lFO0FBQUEsR0FBTTtBQUFBO0FBQUEsSUFBQXdLLFlBaHJCakQ7QUFBQSxJQUFBQztBQUFBQSxNQTJyQnRCO0FBQUEsSUFBQUMsZ0NBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsWUFBQUMsV0FBQTVLO0FBQUFBLFFBQUF3RCxRQUxRO0FBQUEsSUFBUSxZQUNKO0FBQUEsUUFBQTFELElBREk7QUFBQSxJQUVGO0FBQUEsR0FBQztBQUFBLFlBQUErSyxRQUFBQyxLQUFBakw7QUFBQUEsSUFPZjtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBRyxHQUFBMEMsR0FBeUMsNkJBQW9CLEdBQUM7QUFBQTtBQUFBLFlBQUFxSSxZQUFBQyxVQUFBbkw7QUFBQUEsSUFJOUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUcsR0FBQTBDLEdBQWtELDZCQUFvQixHQUFDO0FBQUE7QUFBQSxZQUFBdUksU0FBQXZDLEdBQUE3STtBQUFBQSxJQU12RTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBRyxHQUFBMEMsR0FBd0MsNkJBQW9CLEdBQUM7QUFBQTtBQUFBLFlBQUF3SSxTQUFBNUw7QUFBQUEsSUFJaEQsOEJBQ0Y7QUFBQSxJQURFLHVCQUFBUSxJQUFBLFVBRVM7QUFBQTtBQUFBLEtBQUFMLElBRlQ7QUFBQSxLQUFBUyxJQUFBO0FBQUEsS0FBQUosTUFBQTtBQUFBLEtBQUFLLElBQUE7QUFBQSxLQUFBZ0wsTUFJRDtBQUFBLEtBQUFDLFVBQ1Y7QUFBQSxhQUFBckwsS0FBQVQ7QUFBQUEsU0FBQUEsUUFDZTtBQUFBO0FBQUEsb0NBR0Y7QUFBQSxNQUhFO0FBQUEsV0FBQVEsSUFBQSxjQUtYO0FBQUE7QUFBQSxPQUFtQjtBQUFBO0FBQUE7QUFBQSxVQUFBSSxJQUxSLFVBQUFKLE1BQUEsVUFBQUssSUFBQTtBQUFBLE1BUVg7QUFBQSxjQUFNO0FBQUEsTUFDTjtBQUFBLE1BQW1CO0FBQUEsTUFFbkI7QUFBQTtBQUFBLElBQU07QUFBQSxJQUVWO0FBQUEsSUFBTTtBQUFBLElBR047QUFBQSxJQUFNO0FBQUEsR0FDSDtBQUFBLFlBQUFrTCxJQUFBckwsR0FBQXRDLEdBQUFtQztBQUFBQSxJQUlMO0FBQUE7QUFBQTtBQUFBLHNCQUFBRyxHQUFBMEMsR0FBd0MsT0FBSyxPQUFMLDhCQUFrQixHQUFDO0FBQUE7QUFBQSxZQUFBNEksU0FBQUMsS0FBQUM7QUFBQUEsUUFBQUQsUUFjM0QsS0FBQUUsZ0JBQUE7QUFBQTtBQUFBLEtBVEssb0JBQ0U7QUFBQSxTQUFBL0ksSUFFSztBQUFBLFNBQUFBLE1BQ1I7QUFBQTtBQUFBLE1BQUFjO0FBQUFBLFFBQ0U7QUFBQTtBQUFBLG1CQUFBMEM7QUFBQUEsZUFBQSxJQUFnQztBQUFBLHFEQUErQjtBQUFBO0FBQUEsTUFBQXdGLGNBQUM7QUFBQSxNQUFBQyxVQUFBO0FBQUEsTUFBQUYsa0JBRWxFO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FFa0I7QUFBQSxZQUFBRyxLQUFBNUwsS0FBQXRDO0FBQUFBLFFBQUFzQyxJQUl0QjtBQUFBO0FBQUEsK0JBQ1c7QUFBQSxLQURYLG1CQUFBRixJQUFBLE1BRXlCLG9DQU9GO0FBQUEsU0FBQUksSUFUdkIsTUFBQUosTUFBQSxNQUFBSyxJQUFBO0FBQUEsS0FJSyx1QkFDRTtBQUFBLFNBQUFELE1BRUc7QUFBQSxLQUFTLFFBRUU7QUFBQSxLQUZGO0FBQUE7QUFBQSxHQUVJO0FBQUEsWUFBQTJMLFNBQUE3TCxLQUFBdEM7QUFBQUEsUUFBQXNDLElBSXZCO0FBQUE7QUFBQSwrQkFDVztBQUFBLEtBRFgsbUJBQUFGLElBQUEsTUFFc0IsdUJBT0k7QUFBQSxTQUFBSSxJQVQxQixNQUFBSixNQUFBLE1BQUFLLElBQUEsTUFBQUQsTUFJUztBQUFBLEtBQUcsUUFDUTtBQUFBLFNBQUFBLE1BRVI7QUFBQSxLQUFhLFFBRUY7QUFBQSxLQUZFO0FBQUE7QUFBQSxHQUVDO0FBQUEsWUFBQTRMLFNBQUE5TCxHQUFBdEM7QUFBQUEsUUFBQThGLFFBSXBCO0FBQUEsSUFBUztBQUFBLEtBQ0wsa0VBQ0c7QUFBQSxRQUFBNkMsSUFGRTtBQUFBLElBRUg7QUFBQSxHQUFDO0FBQUEsWUFBQTBGLElBQUEvTCxLQUFBYTtBQUFBQSxRQUFBYixJQUliLEtBQUFhLElBQUE7QUFBQTtBQUFBLCtCQUNXO0FBQUEsS0FEWCxtQkFBQWYsSUFBQSxNQUVzQiwyQkFPMEQ7QUFBQSxTQUFBTCxJQVRoRixNQUFBUyxJQUFBLE1BQUFKLE1BQUEsTUFBQUssSUFBQTtBQUFBLEtBSUUsV0FDSztBQUFBLFNBQUEyRSxTQUVVLFdBQUFsQyxJQUNiO0FBQUEsS0FDQTtBQUFBLE1BQTJCLFlBQWM7QUFBQTtBQUFBLFdBQW1CO0FBQUEsT0FBQS9CLE1BQUQ7QUFBQSxNQUFnQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQTNFO0FBQUE7QUFBQSxHQUE0RTtBQUFBLFlBQUFtTCxrQkFBQW5HLElBQUFoRztBQUFBQTtBQUFBQSxLQUFBZ0csT0FZaEY7QUFBQSxLQUFBb0csWUFBQTtBQUFBLEtBQUFDLGVBQUE7QUFBQTtBQUFBLEtBUEUsV0FDUSwwQ0FNTTtBQUFBLFNBQUFDLEtBUGQsU0FBQUMsS0FBQTtBQUFBLEtBR0s7QUFBQSxNQUFnQztBQUFBO0FBQUE7QUFBQSxPQUFBRixpQkFFSjtBQUFBLE9BQUFELGNBQWtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBRXJEO0FBQUEsWUFBQUksaUJBQUFDLFdBQUFDLE1BQUExTTtBQUFBQSxJQUloQjtBQUFBLEtBYVUsdUVBQStDO0FBQUE7QUFBQSxLQUFBaUwsTUFiekQ7QUFBQSxLQUFBMEIsVUFFZ0I7QUFBQSxLQUFBakIsTUFDSjtBQUFBLFNBQ007QUFBQSxJQUFiLHNCQUNFO0FBQUEsUUFBQUEsUUFDQTtBQUFBLElBRUg7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFBa0IsU0FBQUM7QUFBQUEsT0FDSztBQUFBLGlCQUNFO0FBQUE7QUFBQTtBQUFBLDZCQUNPLGtDQUF3QjtBQUFBO0FBQUEsSUFBQztBQUFBLEdBRWM7QUFBQSxZQUFBQyxVQUFBQyxXQUFBNU07QUFBQUEsSUFJL0M7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFBQTBNLElBQUE3SSxLQUF5QywwQ0FBWSxDQUFPLEdBQUU7QUFBQTtBQUFBLFlBQUErRSxZQUFBaUUsUUFBQUMsVUFBQUMsYUFBQWxOO0FBQUFBLFFBQUFtTixtQkFVL0M7QUFBQSxJQUNwQiwrQkFDRTtBQUFBO0FBQUEsS0FBQUMsd0JBRXlCO0FBQUEsU0FHUjtBQUFBLFNBQWY7QUFBQTtBQUFBLE9BREg7QUFBQTtBQUFBLElBRWlELHNDQUFDO0FBQUE7QUFBQSxZQUFBQyxLQUFBNU4sT0FBQXNIO0FBQUFBLFFBQUFqQixhQXVCbkQ7QUFBQSxJQUFnQztBQUFBLEdBQW9CO0FBQUEsWUFBQXdILGlCQUFBQyxPQUFBeEc7QUFBQUEsUUFBQXlHLFdBRXhDLFVBQUExSCxhQUFBO0FBQUEsSUFDbkIsd0RBQWdFO0FBQUE7QUFBQSxZQUFBOUYsWUFBQUcsR0FHOUMsZUFBK0I7QUFBQSxZQUFBMkYsV0FBQTNGLEdBRzlCLFlBQVk7QUFBQSxZQUFBc04sYUFBQXROLEdBQ1YsMENBQWlDO0FBQUEsWUFBQU0sYUFBQU47QUFBQUEsUUFBQSxJQUNFO0FBQUEsSUFBZTtBQUFBO0FBQUEsWUFBQVIsU0FBQVEsR0FDeEQsbUJBQW1CO0FBQUEsWUFBQU8sV0FBQVAsR0FDakIscUJBQXFCO0FBQUEsWUFBQW9LLFdBQUFwSyxHQUNyQixxQkFBcUI7QUFBQSxZQUFBbUQsVUFBQW5ELEdBQ3RCLG9CQUFvQjtBQUFBLFlBQUF1RCxjQUFBdkQsR0FDaEIsd0JBQXdCO0FBQUEsWUFBQStELFVBQUEvRCxHQUM1QixvQkFBb0I7QUFBQSxZQUFBZ0UsY0FBQWhFLEdBQ2hCLHdCQUF3QjtBQUFBLFlBQUFxSyxTQUFBckssR0FDN0IsbUJBQW1CO0FBQUEsWUFBQTRLLGFBQUE1SyxHQUNmLHVCQUF1QjtBQUFBLFlBQUF1TixRQUFBdk4sT0FBQVAsSUFDMUIsTUE1TEEsa0JBNExvQjtBQUFBLFlBQUF5TCxXQUFBbEwsR0FDbkIscUJBQXFCO0FBQUEsWUFBQStJLE9BQUEvSSxHQUFBMEQsTUFBQWhHLEdBQ2hCLDBCQUEwQjtBQUFBLFlBQUErRixhQUFBekQsR0FBQTBELE1BQUFoRyxHQUFBaUc7QUFBQUEsSUFDWix3Q0FBd0M7QUFBQTtBQUFBLFlBQUF5RixhQUFBcEosR0FBQTBELE1BQUFoRyxHQUNoRCxnQ0FBZ0M7QUFBQSxZQUFBOFAsWUFBQXhOLEdBQUEwRCxNQUFBaEc7QUFBQUEsSUFDL0IsdURBQXNDO0FBQUE7QUFBQSxZQUFBb0wsT0FBQTlJLEdBQUF0QyxHQUNuRCxvQkFBb0I7QUFBQSxZQUFBNkssUUFBQUcsR0FBQStFLEdBQUEvUDtBQUFBQSxRQUFBLElBQ3lCO0FBQUEsSUFBZTtBQUFBO0FBQUEsWUFBQTZMLFNBQUF2SixHQUFBdEMsR0FDMUQsc0JBQXNCO0FBQUEsWUFBQTJMLFVBQUFySixHQUFBdEMsR0FDckIsdUJBQXVCO0FBQUEsWUFBQXVMLFFBQUFqSixHQUFBdEMsR0FDekIscUJBQXFCO0FBQUEsWUFBQXdMLE1BQUFDLEdBQUFuSixHQUFBdEMsR0FDckIsc0JBQXFCO0FBQUEsWUFBQWtPLE9BQUE1TCxHQUFBdEMsR0FDdEIsb0JBQW9CO0FBQUEsWUFBQW9PLFdBQUE5TCxHQUFBdEMsR0FDaEIsd0JBQXdCO0FBQUEsWUFBQW1PLFdBQUE3TCxHQUFBdEMsR0FDeEIsd0JBQXdCO0FBQUEsWUFBQWlILE1BQUEzRSxHQUFBMEksT0FBQSxJQUNFLGdCQUFlO0FBQUEsWUFBQWMsU0FBQXhKLEdBQUF0QyxHQUN4QixPQUF3QixvQkFBeEIsZ0JBQXdCO0FBQUEsWUFBQStFLE1BQUF6QyxHQUFBMEk7QUFBQUEsUUFBQSxJQUNQO0FBQUEsSUFBakMsT0FBaUQsUUFBakQsZ0JBQWlEO0FBQUE7QUFBQSxZQUFBOUQsU0FBQTVFLEdBQUEwSTtBQUFBQSxRQUFBLElBQ1Y7QUFBQSxJQUFwQyxPQUFvRCxRQUFwRCxtQkFBb0Q7QUFBQTtBQUFBLFlBQUEzRCxRQUFBWixJQUFBQztBQUFBQSxRQUFBLElBQ1I7QUFBQSxJQUExQyxPQUEyRCxTQUEzRCx1QkFBMkQ7QUFBQTtBQUFBLFlBQUEyQixRQUFBNUIsSUFBQUM7QUFBQUEsUUFBQSxJQUNqQjtBQUFBLElBQTFDLE9BQTJELFNBQTNELHVCQUEyRDtBQUFBO0FBQUEsWUFBQStCLE9BQUFoQyxJQUFBQztBQUFBQSxRQUFBLElBQ25CO0FBQUEsSUFBekMsT0FBMEQsU0FBMUQsc0JBQTBEO0FBQUE7QUFBQSxZQUFBb0MsaUJBQUFyQyxJQUFBQztBQUFBQSxRQUFBLElBRy9CO0FBQUEsSUFBZ0I7QUFBQTtBQUFBLFlBQUFzSixlQUFBdkosSUFBQUM7QUFBQUEsUUFBQSxJQUczQjtBQUFBLFdBQWdCLFFBQWhCLHNCQUFnQztBQUFBO0FBQUEsWUFBQXVFLFFBQUF4RSxJQUFBQztBQUFBQSxRQUFBLElBQ2Q7QUFBQSxJQUFnQjtBQUFBO0FBQUEsWUFBQXdFLFlBQUE1SSxHQUFBMk47QUFBQUEsUUFBQSxJQUNGO0FBQUEsSUFBZTtBQUFBO0FBQUEsWUFBQTlFLGVBQUExRSxJQUFBQztBQUFBQSxRQUFBLElBR3RDO0FBQUEsSUFBZ0I7QUFBQTtBQUFBLFlBQUF3SixjQUFBQyxPQUlqQixrQ0FBbUM7QUFBQSxZQUFBakYsWUFBQWlFLFFBQUFDO0FBQUFBO0FBQUFBLEtBQUEsSUFNakU7QUFBQSxTQURSO0FBQUE7QUFBQSxJQURMLE9BQXNCLFlBQXRCLCtCQUc0QztBQUFBO0FBQUEsWUFBQW5FLFFBQUF4RSxJQUFBQztBQUFBQSxRQUFBLElBSU8saUNBQXRCO0FBQUEsSUFBb0Isc0NBQXdCO0FBQUE7QUFBQSxZQUFBd0YsZUFBQTVKLEdBQUF0QztBQUFBQTtBQUFBQSxLQUFBOEYsUUFPeEQ7QUFBQSxLQUFBc0ssU0FBNEI7QUFBQSxLQUFBQyxTQUFBO0FBQUEsU0FDdEI7QUFBQSxJQUEzQiwwQ0FBeUI7QUFBQSxHQUEyQjtBQUFBLFlBQUF6SixRQUFBdEUsR0FBQTBJO0FBQUFBO0FBQUFBLEtBQUEsSUFJSTtBQUFBLEtBQUFsRixRQUFsQztBQUFBLEtBQUFzRCxRQUFpRDtBQUFBLEtBQUEyRyxJQUFBO0FBQUEsS0FBQWhGLFFBQUE7QUFBQSxTQUN0RDtBQUFBLElBQWpCLGdDQUFZO0FBQUEsR0FBaUI7QUFBQSxZQUFBakUsY0FBQXhFLEdBQUEwSTtBQUFBQTtBQUFBQSxLQUFBLElBSThCO0FBQUEsS0FBQWxGLFFBQXhDO0FBQUEsS0FBQXNELFFBQXVEO0FBQUEsS0FBQTJCLFFBQUE7QUFBQSxTQUM1RDtBQUFBLElBQWQsNkJBQVk7QUFBQSxHQUFjO0FBQUEsWUFBQWhFLGNBQUF6RSxHQUFBMEk7QUFBQUE7QUFBQUEsS0FBQSxJQUlpQztBQUFBLEtBQUFsRixRQUF4QztBQUFBLEtBQUFzRCxRQUF1RDtBQUFBLEtBQUEyQixRQUFBO0FBQUEsU0FDNUQ7QUFBQSxJQUFkLDZCQUFZO0FBQUEsR0FBYztBQUFBLFlBQUE2QyxXQUFBdEwsR0FBQXdMO0FBQUFBLFFBQUEsSUFHSztBQUFBLElBQThCLCtDQUFJLG9CQUFRO0FBQUE7QUFBQSxZQUFBTyxNQUFBL0wsR0FBQWEsR0FDN0QsbUJBQWtCO0FBQUEsWUFBQWdFLGVBQUE3RSxHQUFBYTtBQUFBQSxRQUFBLElBQ3dDO0FBQUEsSUFBMUMsT0FBMEQsUUFBMUQseUJBQTBEO0FBQUE7QUFBQSxZQUFBOEwsWUFBQUMsV0FBQXROLE9BQUFVLEdBQzFELGlDQUFnQztBQUFBO0FBQUEsWUFBQWlILGNBQUFJLE9BQUFGLHFCQUFBQyxrQkFBQXBIO0FBQUFBLElBRzVEO0FBQUEsc0VBQW1GO0FBQUE7QUFBQSxZQUFBOEgsZ0JBQUE5SCxHQUFBMkgsU0FBQUksS0FBQWpJO0FBQUFBLElBR2hELDJDQUF5QztBQUFBO0FBQUEsWUFBQWtJLDBCQUFBaEksR0FBQWlJLFlBQUFGO0FBQUFBLElBRzVFLHFEQUFvRDtBQUFBO0FBQUEsWUFBQUs7QUFBQUEsSUFBQWYsT0FBQUYscUJBQUFDLGtCQUFBcEgsS0FBQUE7QUFBQUEsSUFJcEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBTVM7QUFBQTtBQUFBLFlBQUFnTyxpQkFBQUMsZ0JBQUF2SCxPQUFBMUc7QUFBQUEsUUFBQUEsTUFJVCxVQXhaa0M7QUFBQSxJQUFyQixPQUFnQyxVQUFoQyx1REF3WmtEO0FBQUE7QUFBQSxZQUFBMkgsVUFBQSxHQUFBckksT0FBQTZFLElBQUFDLElBTTNDLDZCQUFvQjtBQUFBLFlBQUFpSSxtQkFBQTFHLFlBQUEyRyxXQUFBQztBQUFBQSxJQVFXLHVEQUFlO0FBQUE7QUFBQSxZQUFBMkIsTUFBQTVPLE9BSTFDLHNDQUErQjtBQUFBLFlBQUEyRyxVQUFBM0csT0FBQStHLEdBcjJCdkMsY0FzMkIrQjtBQUFBLFlBQUE3RyxTQUFBUSxHQUNsQyxnQkFBYztBQUFBLFlBQUFNLGFBQUFxRixZQUFBM0YsR0FDaUQ7QUFBQSxZQUFBTyxXQUFBUCxHQUM3RCxrQkFBZ0I7QUFBQSxZQUFBb0ssV0FBQXBLLEdBQ2hCLGtCQUFnQjtBQUFBLFlBQUFtRCxVQUFBbkQsR0FDakIsaUJBQWU7QUFBQSxZQUFBdUQsY0FBQXZELEdBQ1gscUJBQW1CO0FBQUEsWUFBQStELFVBQUEvRCxHQUN2QixpQkFBZTtBQUFBLFlBQUFnRSxjQUFBaEUsR0FDWCxxQkFBbUI7QUFBQSxZQUFBcUssU0FBQXJLLEdBQ3hCLGdCQUFjO0FBQUEsWUFBQTRLLGFBQUE1SyxHQUNWLG9CQUFrQjtBQUFBLFlBQUF1TixVQUFBdk4sR0E1VHJCLGtCQTZUZTtBQUFBLFlBQUFrTCxXQUFBbEwsR0FDZCxrQkFBZ0I7QUFBQSxZQUFBOEksT0FBQTlJLEdBQUF0QyxHQUNqQixpQkFBZTtBQUFBLFlBQUE2TCxTQUFBdkosR0FBQXRDLEdBQ2IsbUJBQWlCO0FBQUEsWUFBQTJMLFVBQUFySixHQUFBdEMsR0FDaEIsb0JBQWtCO0FBQUEsWUFBQXVMLFFBQUFqSixHQUFBdEMsR0FDcEIsa0JBQWdCO0FBQUEsWUFBQXdMLE1BQUFDLEdBQUFuSixHQUFBdEMsR0FDaEIsbUJBQWdCO0FBQUEsWUFBQWtPLE9BQUE1TCxHQUFBdEMsR0FDakIsaUJBQWU7QUFBQSxZQUFBb08sV0FBQTlMLEdBQUF0QyxHQUNYLHFCQUFtQjtBQUFBLFlBQUFtTyxXQUFBN0wsR0FBQXRDLEdBQ25CLHFCQUFtQjtBQUFBLFlBQUFxTCxPQUFBL0ksR0FBQTBELE1BQUFoRyxHQUNqQix1QkFBcUI7QUFBQSxZQUFBK0YsYUFBQXpELEdBQUEwRCxNQUFBaEcsR0FBQWlHLFFBQ1AscUNBQW1DO0FBQUE7QUFBQSxZQUFBeUYsYUFBQXBKLEdBQUEwRCxNQUFBaEcsR0FDM0MsNkJBQTJCO0FBQUEsWUFBQTJOLE1BQUExRixZQUFBM0YsR0FBQXRDLEdBQ2U7QUFBQSxZQUFBOEwsU0FBQXhKLEdBQUF0QyxHQUNwRCxtQkFBaUI7QUFBQSxZQUFBaU0sYUFBQWhFLFlBQUEzRixHQUFBdEM7QUFBQUEsSUFDaUQ7QUFBQTtBQUFBLFlBQUFrTSxlQUFBNUosR0FBQXRDLEdBQzVELHlCQUF1QjtBQUFBLFlBQUE2SyxRQUFBNUMsWUFBQStDLEdBQUErRSxHQUFBL1A7QUFBQUEsSUFDK0I7QUFBQTtBQUFBLFlBQUFpSCxNQUFBZ0IsWUFBQTNGLEdBQUEwSSxHQUNWO0FBQUEsWUFBQWpHLE1BQUFrRCxZQUFBM0YsR0FBQTBJLEdBQ0E7QUFBQSxZQUFBOUQsU0FBQWUsWUFBQTNGLEdBQUEwSSxHQUNNO0FBQUEsWUFBQTNELFFBQUFZLFlBQUF4QixJQUFBQyxJQUNFO0FBQUEsWUFBQTJCLFFBQUFKLFlBQUF4QixJQUFBQyxJQUNBO0FBQUEsWUFBQStCLE9BQUFSLFlBQUF4QixJQUFBQyxJQUNGO0FBQUEsWUFBQW9DLGlCQUFBYixZQUFBeEIsSUFBQUM7QUFBQUEsSUFHakI7QUFBQTtBQUFBLFlBQUFzSixpQkFBQS9ILFlBQUF4QixJQUFBQyxJQUdXLHFDQUFNO0FBQUE7QUFBQSxZQUFBdUUsUUFBQWhELFlBQUF4QixJQUFBQyxJQUNFO0FBQUEsWUFBQXdFLFlBQUFqRCxZQUFBM0YsR0FBQTJOO0FBQUFBLElBQ1U7QUFBQTtBQUFBLFlBQUE5RSxlQUFBbEQsWUFBQXhCLElBQUFDO0FBQUFBLElBRy9CO0FBQUE7QUFBQSxZQUFBeUcsVUFBQWxGLFlBQUF4RixHQUdpQjtBQUFBLFlBQUE0SyxjQUFBcEYsWUFBQWxHO0FBQUFBLElBQ1E7QUFBQTtBQUFBLFlBQUF3TCxXQUFBdEYsWUFBQStDLEdBQ047QUFBQSxZQUFBckgsNEJBQUFzRSxZQUFBK0M7QUFBQUEsSUFHVjtBQUFBO0FBQUEsWUFBQS9ILGlDQUFBckIsT0FBQXNCLEtBQUFsRCxHQUk5RCw2Q0FBOEM7QUFBQTtBQUFBLFlBQUErRCxrQkFBQWtFLFlBQUErQztBQUFBQSxJQUd3QztBQUFBO0FBQUEsWUFBQWhELGFBQUFDLFlBQUF4RjtBQUFBQSxJQUN6RCwwQ0RyMUNqQyxjQ3ExQzhFO0FBQUE7QUFBQSxZQUFBNkwsb0JBQUFyRyxZQUFBRTtBQUFBQSxJQUduQjtBQUFBO0FBQUEsWUFBQXlGLFdBQUF0TCxHQUFBd0wsT0FHakMseUJBQXVCO0FBQUEsWUFBQWxILFFBQUFxQixZQUFBM0YsR0FBQTBJLEdBQ3lCO0FBQUEsWUFBQWxFLGNBQUFtQixZQUFBM0YsR0FBQTBJO0FBQUFBLElBQ1k7QUFBQTtBQUFBLFlBQUFqRSxjQUFBa0IsWUFBQTNGLEdBQUEwSTtBQUFBQSxJQUNBO0FBQUE7QUFBQSxZQUFBcUQsTUFBQS9MLEdBQUFhLEdBQ3RFLGdCQUFhO0FBQUEsWUFBQWdFLGVBQUFjLFlBQUEzRixHQUFBYTtBQUFBQSxJQUMyRDtBQUFBO0FBQUEsWUFBQThMLFlBQUFDLFdBQUF0TixPQUFBVSxHQUN4RCw4QkFBMkI7QUFBQSxZQUFBNEYsUUFBQTVGLEdBQ3pDLFNBQUM7QUFBQSxZQUFBbU8sUUFBQTdPLE9BQUFVLEdBQ2EsU0FBQztBQUFBLFlBQUFpSDtBQUFBQSxJQUFBdEIsWUFBQTBCLE9BQUFGLHFCQUFBQyxrQkFBQXBIO0FBQUFBLElBRzdCO0FBQUEseUVBQTRFO0FBQUE7QUFBQSxZQUFBOEgsZ0JBQUF4SSxPQUFBVSxHQUFBMkgsU0FBQUksS0FBQWpJLEdBRzNCLHdDQUFvQztBQUFBO0FBQUEsWUFBQWtJLDBCQUFBMUksT0FBQVUsR0FBQWlJLFlBQUFGLEtBR3JGLGtEQUErQztBQUFBO0FBQUEsWUFBQUs7QUFBQUEsSUFBQXpDLFlBQUEwQixPQUFBRixxQkFBQUMsa0JBQUFwSCxLQUFBQTtBQUFBQSxJQUkvQztBQUFBLDhFQUFxRjtBQUFBO0FBQUEsWUFBQXdOLGNBQUF4TixHQUFBMEQsTUFBQWhHO0FBQUFBLElBRzFELHVEQUFzQztBQUFBO0FBQUEsWUFBQWtMLFlBQUFqRCxZQUFBeEIsSUFBQUM7QUFBQUEsSUFTakMsd0RBQ2dCO0FBQUE7QUFBQSxZQUFBdUUsUUFBQWhELFlBQUF4QixJQUFBQztBQUFBQTtBQUFBQSxLQUFBdkUsY0E3RzlCO0FBQUEsS0FBQWtOLGNBb0hjO0FBQUEsU0F4UTFCO0FBQUEsU0FEQTtBQUFBLElBQThDLHNDQTBRSjtBQUFBO0FBQUEsT0FBQXFCLFFBMWFoRDtBQUFBLFlBQUF4SSxVQUFBNUYsR0FvYmMsWUFBTTtBQUFBLFlBQUFtTyxVQUFBeEksWUFBQWlCLE1BQ1MsNkJBQW9CO0FBQUEsWUFBQXlGLG1CQUFBMUcsWUFBQTJHLFdBQUFDO0FBQUFBLFFBQUEzRixPQUsvQztBQUFBLElBTDJCO0FBQUEsR0FLNEM7QUFBQSxZQUFBc0gsUUFBQXZJO0FBQUFBLElBR25EO0FBQUEsR0FBa0M7QUFBQSxZQUFBMEksK0JBQUFDO0FBQUFBLFFBQUFKLFFEeDVDNUQ7QUFBQTtBQUFBO0FBQUEsWUFBQWpJLFlBQUFOLFlBQUFVLEdDODVDc0UsK0JBQUU7QUFBQSxZQUFBWCxhQUFBQyxZQUFBeEY7QUFBQUEsUUFBQXlHLE9BR2hEO0FBQUEsSUFqQlM7QUFBQSxHQWlCZ0M7QUFBQSxZQUFBdkYsNEJBQUFzRSxZQUFBckU7QUFBQUEsUUFBQXNGLE9BSzNEO0FBQUEsSUFFRjtBQUFBLEdBQW9CO0FBQUEsWUFBQWpHLGlDQUFBZ0YsWUFBQS9FLEtBQUFsRDtBQUFBQSxRQUFBa0osT0FJQTtBQUFBLElBNUJTO0FBQUEsR0E0QnVDO0FBQUEsWUFBQW5GLGtCQUFBa0UsWUFBQXJFO0FBQUFBLFFBQUEsSUFLbEU7QUFBQSxJQUFzRTtBQUFBO0FBQUE7QUFBQSxzQkFBQXNGLE1BQ3RELDZCQUFvQixFQUFDO0FBQUE7QUFBQSxZQUFBaUUsVUFBQWxGLFlBQUF4RjtBQUFBQSxJQUlsQixpREFBMEQ7QUFBQSxHQUFFO0FBQUEsWUFBQTRLLGNBQUFwRixZQUFBbEc7QUFBQUEsSUFJNUQscURBQThEO0FBQUEsR0FBRTtBQUFBLFlBQUF3TCxXQUFBdEYsWUFBQStDO0FBQUFBLElBSWhFLGtEQUEyRDtBQUFBLEdBQUU7QUFBQSxZQUFBc0Qsb0JBQUFyRyxZQUFBRTtBQUFBQSxJQUlsRiwyQ0FBcUU7QUFBQTtBQUFBLFlBQUF3RixNQUFBMUYsWUFBQTNGLEdBQUF0QztBQUFBQSxJQUloRCxtREFBOEQ7QUFBQSxHQUFFO0FBQUEsWUFBQWlNLGFBQUFoRSxZQUFBM0YsR0FBQXRDO0FBQUFBLElBSzVFLDBEQUFxRTtBQUFBLEdBQzdFO0FBQUEsT0FBQTZRLGdCQWpmRDtBQUFBLFlBQUFMLFFBQUEvRTtBQUFBQSxRQUFBeEQsYUF3ZjZDO0FBQUEsSUEzRHZCO0FBQUEsR0EyRHdDO0FBQUEsWUFBQU0sWUFBQWtELEdBQUFULEdBQ1AsT0FBaUIsWUFBakIsb0JBQW1CO0FBQUEsWUFBQWhELGFBQUF5RCxHQUFBVCxHQUNqQixPQUFpQixhQUFqQixvQkFBbUI7QUFBQSxZQUFBckgsNEJBQUE4SCxHQUFBVDtBQUFBQSxJQUd2QixPQUFpQiw0QkFBakIsb0JBQW1CO0FBQUE7QUFBQSxZQUFBL0gsaUNBQUF3SSxHQUFBdkksS0FBQWxEO0FBQUFBLElBSVosT0FBaUIsaUNBQWpCLHlCQUF5QjtBQUFBO0FBQUEsWUFBQStELGtCQUFBMEgsR0FBQVQ7QUFBQUEsSUFHbEIsT0FBaUIsa0JBQWpCLG9CQUFtQjtBQUFBO0FBQUEsWUFBQW1DLFVBQUExQixHQUFBVCxHQUNuQyxPQUFpQixVQUFqQixvQkFBbUI7QUFBQSxZQUFBcUMsY0FBQTVCLEdBQUFULEdBQ1gsT0FBaUIsY0FBakIsb0JBQW1CO0FBQUEsWUFBQXVDLFdBQUE5QixHQUFBVCxHQUN6QixPQUFpQixXQUFqQixvQkFBbUI7QUFBQSxZQUFBc0Qsb0JBQUE3QyxHQUFBVDtBQUFBQSxJQUczQixPQUFpQixvQkFBakIsb0JBQW1CO0FBQUE7QUFBQSxZQUFBMkMsTUFBQWxDLEdBQUFULEdBQUFoTCxHQUdsQixPQUFpQixNQUFqQix1QkFBc0I7QUFBQSxZQUFBaU0sYUFBQVIsR0FBQVQsR0FBQWhMO0FBQUFBLElBQ1IsT0FBaUIsYUFBakIsdUJBQXNCO0FBQUE7QUFBQSxZQUFBeVEsVUFBQWhGLEdBQUF2QztBQUFBQSxRQUFBakIsYUFFL0I7QUFBQSxJQTNGdEI7QUFBQSxHQTJGeUM7QUFBQSxZQUFBNkksRUFBQUYsS0QzK0MxRSxXQ20vQ0c7QUFBQSxZQUFBRyxZQUFBSCxLQUFBdE87QUFBQUEsSUFpQ0Qsb0NBQUFWLE9BQWtDLFNBQWEsT0FBRztBQUFBO0FBQUEsWUFBQW9QLFlBQUFKLEtBQUEvQjtBQUFBQSxJQVFsRCwrQ0FBK0U7QUFBQTtBQUFBLFlBQUFvQyxpQkFBQUw7QUFBQUEsUUFBQSxJQU1sRDtBQUFBLElBQXNDO0FBQUE7QUFBQSxZQUFBTSxZQUFBdFAsT0FBQTZFLElBQUFDLElBR3JCLDZCQUFvQjtBQUFBLFlBQUF5SyxVQUFBdlAsT0FBQTZFLElBQUFDLElBQ3hCLHNCQUFXO0FBQUEsWUFBQTBLLGNBQUFSLEtBQUE1SDtBQUFBQSxRQUFBLElBR3JEO0FBQUEsdUJEemlERixzQ0N5aURFO0FBQUEsR0FBc0M7QUFBQSxZQUFBcUksU0FBQUMsUUFBQWhQO0FBQUFBLFFBQUEwRyxRQUkxQixzQkFBc0IsK0JBQXRCO0FBQUEsSUFDWixxQ0FBeUI7QUFBQTtBQUFBO0FBQUEsSUFBQWYsZUFubEJ2QjtBQUFBLElBQUFzSixVQUFBO0FBQUEsSUFBQWYsVUFBQTtBQUFBLFlBQUFqSSxZQUFBeUMsR0FnbUJnQixtQ0FBd0M7QUFBQSxZQUFBaEQsYUFBQWdELEdBQ3ZDLG9DQUF5QztBQUFBLFlBQUFySCw0QkFBQXFIO0FBQUFBLElBRzFELG1EQUF3RDtBQUFBO0FBQUEsWUFBQS9ILGlDQUFBQyxLQUFBbEQ7QUFBQUEsSUFJeEQsNkRBQXFFO0FBQUE7QUFBQSxZQUFBK0Qsa0JBQUFpSCxHQUcvQyx5Q0FBOEM7QUFBQSxZQUFBbUMsVUFBQW5DLEdBQ3RELGlDQUFzQztBQUFBLFlBQUFxQyxjQUFBckMsR0FDbEMscUNBQTBDO0FBQUEsWUFBQXVDLFdBQUF2QyxHQUM3QyxrQ0FBdUM7QUFBQSxZQUFBc0Qsb0JBQUF0RDtBQUFBQSxJQUM5QiwyQ0FBZ0Q7QUFBQTtBQUFBLFlBQUEyQyxNQUFBM0MsR0FBQWhMLEdBQzNELGdDQUFxQztBQUFBLFlBQUFpTSxhQUFBakIsR0FBQWhMLEdBQzlCLHVDQUE0QztBQUFBLFlBQUF5USxVQUFBdkgsTUFDL0MsK0JBQW9CO0FBQUEsWUFBQWhCLFVBQUE1RixHQUN2QixZQUFNO0FBQUE7QUFBQSxRQW5uQnBCO0FBQUEsSUFBQWtQO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDM5QkoiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOTUwNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9yZWYubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG4gIHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIHJlZlxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZfX2xvY2FsXG4gICAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfcmVmXG4gICAgbGV0IGVxdWFsX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPSBlcXVhbF9yZWZfX2xvY2FsXG4gICAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZlxuXG4gICAgbGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gICAgICBmdW4gKHR5cGUgYV9fMDE3XykgOiAoKGFfXzAxN18gLT4gYV9fMDE3XykgLT4gYV9fMDE3XyB0IC0+IGFfXzAxN18gdCkgLT5cbiAgICAgIGdsb2JhbGl6ZV9yZWZcbiAgICA7O1xuXG4gICAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IHJlZl9vZl9zZXhwXG4gICAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfcmVmXG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiByZWZfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cbiAgZW5kIDpcbiAgICBzaWdcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIHJlZlxuICAgICAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuU19sb2NhbDEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuU19sb2NhbDEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgZ2xvYmFsaXplIDogKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHRcblxuICAgICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgICAgW0BAQGVuZF1cbiAgICBlbmQpXG5cbigqIEluIHRoZSBkZWZpbml0aW9uIG9mIFt0XSwgd2UgZG8gbm90IGhhdmUgW1tAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXSBiZWNhdXNlXG4gICBpbiBnZW5lcmFsLCBzeW50YXggZXh0ZW5zaW9ucyB0ZW5kIHRvIHVzZSB0aGUgaW1wbGVtZW50YXRpb24gd2hlbiBhdmFpbGFibGUgcmF0aGVyIHRoYW5cbiAgIHVzaW5nIHRoZSBhbGlhcy4gIEhlcmUgdGhhdCB3b3VsZCBsZWFkIHRvIHVzZSB0aGUgcmVjb3JkIHJlcHJlc2VudGF0aW9uIFsgeyBtdXRhYmxlXG4gICBjb250ZW50cyA6ICdhIH0gXSB3aGljaCB3b3VsZCByZXN1bHQgaW4gZGlmZmVyZW50IChhbmQgdW53YW50ZWQpIGJlaGF2aW9yLiAgKilcbnR5cGUgJ2EgdCA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuZXh0ZXJuYWwgY3JlYXRlIDogJ2EgLT4gKCdhIHRbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAoJ2EgdFtAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogKCdhIHRbQGxvY2FsX29wdF0pIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG5sZXQgc3dhcCB0MSB0MiA9XG4gIGxldCB0bXAgPSAhdDEgaW5cbiAgdDEgOj0gIXQyO1xuICB0MiA6PSB0bXBcbjs7XG5cbmxldCByZXBsYWNlIHQgZiA9IHQgOj0gZiAhdFxuXG5sZXQgc2V0X3RlbXBvcmFyaWx5IHQgYSB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gIXQgaW5cbiAgdCA6PSBhO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHQgOj0gcmVzdG9yZV90bylcbjs7XG5cbm1vZHVsZSBBbmRfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVCA6ICdhIHJlZiAqICdhIC0+IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgc2V0IChUIChyLCBhKSkgPSByIDo9IGFcbiAgbGV0IHNldHMgdHMgPSBMaXN0Lml0ZXIgdHMgfmY6c2V0XG4gIGxldCBzbmFwc2hvdCAoVCAociwgXykpID0gVCAociwgIXIpXG4gIGxldCBzbmFwc2hvdHMgdHMgPSBMaXN0Lm1hcCB0cyB+ZjpzbmFwc2hvdFxuZW5kXG5cbmxldCBzZXRzX3RlbXBvcmFyaWx5IGFuZF92YWx1ZXMgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9IEFuZF92YWx1ZS5zbmFwc2hvdHMgYW5kX3ZhbHVlcyBpblxuICBBbmRfdmFsdWUuc2V0cyBhbmRfdmFsdWVzO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IEFuZF92YWx1ZS5zZXRzIHJlc3RvcmVfdG8pXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0V4biIsIkJhc2VfTGlzdCIsIkJhc2VfSW1wb3J0IiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmUiLCJlcXVhbF9sb2NhbCIsImVxdWFsIiwiZ2xvYmFsaXplIiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJhX3NleHBfZ3JhbW1hciIsInN3YXAiLCJ0MSIsInQyIiwidG1wIiwicmVwbGFjZSIsInQiLCJzZXRfdGVtcG9yYXJpbHkiLCJhIiwicmVzdG9yZV90byIsInBhcmFtIiwic2V0IiwiciIsInNldHMiLCJ0cyIsInNuYXBzaG90Iiwic2V0c190ZW1wb3JhcmlseSIsImFuZF92YWx1ZXMiLCJCYXNlX1JlZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxZQUFBQyxlQUFBQztBQUFBQSxJQ3FCOEIsa0RBQWlDO0FBQUE7QUFBQSxZQUFBQyxLQUFBQyxJQUFBQztBQUFBQSxRQUFBQyxNQW1DN0Q7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUEsR0FBUztBQUFBLFlBQUFDLFFBQUFDLEdBQUFwQixHQUdZLDRCQUFJO0FBQUEsWUFBQXFCLGdCQUFBRCxHQUFBRSxHQUFBdEI7QUFBQUEsUUFBQXVCLGFBR3pCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSwrQkFBQUMsT0FBbUMsNEJBQWUsRUFBQztBQUFBO0FBQUEsWUFBQUMsSUFBQUQsV0FBQUYsSUFNM0MsVUFBQUksSUFBQSxVQUFhLG1CQUFNO0FBQUEsWUFBQUMsS0FBQUMsSUFDYix3Q0FBbUI7QUFBQSxZQUFBQyxTQUFBTCxXQUFBRSxJQUNwQixVQUFhLG9CQUFTO0FBQUEsWUFBQUksaUJBQUFDLFlBQUEvQjtBQUFBQSxRQUFBdUIsYUFDaEI7QUFBQSxJQUtuQjtBQUFBLElBQXlCO0FBQUEsK0JBQUFDLE9BQ1UsdUJBQXlCLEdBQUM7QUFBQTtBQUFBO0FBQUEsSUFBQVE7QUFBQUEsTURqRi9EIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjk1NzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJCYXNlX1F1ZXVlX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxrQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NTg5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3F1ZXVlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbigqIFt0XSBzdG9yZXMgdGhlIFt0Lmxlbmd0aF0gcXVldWUgZWxlbWVudHMgYXQgY29uc2VjdXRpdmUgaW5jcmVhc2luZyBpbmRpY2VzIG9mIFt0LmVsdHNdLFxuICAgbW9kIHRoZSBjYXBhY2l0eSBvZiBbdF0sIHdoaWNoIGlzIFtPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c10uICBUaGUgY2FwYWNpdHkgaXNcbiAgIHJlcXVpcmVkIHRvIGJlIGEgcG93ZXIgb2YgdHdvICh1c2VyLXJlcXVlc3RlZCBjYXBhY2l0aWVzIGFyZSByb3VuZGVkIHVwIHRvIHRoZSBuZWFyZXN0XG4gICBwb3dlciksIHNvIHRoYXQgbW9kIGNhbiBxdWlja2x5IGJlIGNvbXB1dGVkIHVzaW5nIFtsYW5kIHQubWFza10sIHdoZXJlIFt0Lm1hc2sgPVxuICAgY2FwYWNpdHkgdCAtIDFdLiAgU28sIHF1ZXVlIGVsZW1lbnQgW2ldIGlzIGF0IFt0LmVsdHMuKCAodC5mcm9udCArIGkpIGxhbmQgdC5tYXNrICldLlxuXG4gICBbbnVtX211dGF0aW9uc10gaXMgdXNlZCB0byBkZXRlY3QgbW9kaWZpY2F0aW9uIGR1cmluZyBpdGVyYXRpb24uICopXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbnVtX211dGF0aW9ucyA6IGludFxuICA7IG11dGFibGUgZnJvbnQgOiBpbnRcbiAgOyBtdXRhYmxlIG1hc2sgOiBpbnRcbiAgOyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgZWx0cyA6ICdhIE9wdGlvbl9hcnJheS50XG4gIH1cbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDFfXG4gICAgICB7IG51bV9tdXRhdGlvbnMgPSBudW1fbXV0YXRpb25zX18wMDNfXG4gICAgICA7IGZyb250ID0gZnJvbnRfXzAwNV9cbiAgICAgIDsgbWFzayA9IG1hc2tfXzAwN19cbiAgICAgIDsgbGVuZ3RoID0gbGVuZ3RoX18wMDlfXG4gICAgICA7IGVsdHMgPSBlbHRzX18wMTFfXG4gICAgICB9IC0+XG4gIGxldCBibmRzX18wMDJfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDEyXyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDExXyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDEyXyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDEwXyA9IHNleHBfb2ZfaW50IGxlbmd0aF9fMDA5XyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9pbnQgbWFza19fMDA3XyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXNrXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA2XyA9IHNleHBfb2ZfaW50IGZyb250X18wMDVfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImZyb250XCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA0XyA9IHNleHBfb2ZfaW50IG51bV9tdXRhdGlvbnNfXzAwM18gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibnVtX211dGF0aW9uc1wiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwMl9cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBnbG9iYWxpemUgXyB0ID1cbiAgeyBudW1fbXV0YXRpb25zID0gdC5udW1fbXV0YXRpb25zXG4gIDsgZnJvbnQgPSB0LmZyb250XG4gIDsgbWFzayA9IHQubWFza1xuICA7IGxlbmd0aCA9IHQubGVuZ3RoXG4gIDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jb3B5IHQuZWx0c1xuICB9XG47O1xuXG5tb2R1bGUgdHlwZSBTID0gUXVldWVfaW50Zi5TXG5cbmxldCBpbmNfbnVtX211dGF0aW9ucyB0ID0gdC5udW1fbXV0YXRpb25zIDwtIHQubnVtX211dGF0aW9ucyArIDFcbmxldCBjYXBhY2l0eSB0ID0gdC5tYXNrICsgMVxubGV0IGVsdHNfaW5kZXggdCBpID0gKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFza1xubGV0IHVuc2FmZV9nZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfaXNfc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfaXNfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIGEgPSBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpIGFcbmxldCB1bnNhZmVfdW5zZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxuXG5sZXQgY2hlY2tfaW5kZXhfZXhuIHQgaSA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gdC5sZW5ndGhcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiUXVldWUgaW5kZXggb3V0IG9mIGJvdW5kc1wiXG4gICAgICAgICBbIFwiaW5kZXhcIiwgaSB8PiBJbnQuc2V4cF9vZl90OyBcImxlbmd0aFwiLCB0Lmxlbmd0aCB8PiBJbnQuc2V4cF9vZl90IF0pXG47O1xuXG5sZXQgZ2V0IHQgaSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIHVuc2FmZV9nZXQgdCBpXG47O1xuXG5sZXQgc2V0IHQgaSBhID1cbiAgY2hlY2tfaW5kZXhfZXhuIHQgaTtcbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgdW5zYWZlX3NldCB0IGkgYVxuOztcblxubGV0IGlzX2VtcHR5IHQgPSB0Lmxlbmd0aCA9IDBcbmxldCBsZW5ndGggeyBsZW5ndGg7IF8gfSA9IGxlbmd0aFxuXG5sZXRbQGNvbGRdIFtAaW5saW5lIG5ldmVyXSByYWlzZV9tdXRhdGlvbl9kdXJpbmdfaXRlcmF0aW9uIHQgPVxuICBFcnJvci5yYWlzZV9zXG4gICAgKFNleHAubWVzc2FnZVxuICAgICAgIFwibXV0YXRpb24gb2YgcXVldWUgZHVyaW5nIGl0ZXJhdGlvblwiXG4gICAgICAgWyBcIlwiLCB0IHw+IGdsb2JhbGl6ZSAoKSB8PiBzZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgXSlcbjs7XG5cbmxldCBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zID1cbiAgaWYgdC5udW1fbXV0YXRpb25zIDw+IG51bV9tdXRhdGlvbnMgdGhlbiByYWlzZV9tdXRhdGlvbl9kdXJpbmdfaXRlcmF0aW9uIHRcbjs7XG5cbmxldCBjb21wYXJlX19sb2NhbCA9XG4gIGxldCByZWMgdW5zYWZlX2NvbXBhcmVfZnJvbSBjb21wYXJlX2VsdCBwb3MgfnQxIH50MiB+bGVuMSB+bGVuMiB+bXV0MSB+bXV0MiA9XG4gICAgbWF0Y2ggcG9zID0gbGVuMSwgcG9zID0gbGVuMiB3aXRoXG4gICAgfCB0cnVlLCB0cnVlIC0+IDBcbiAgICB8IHRydWUsIGZhbHNlIC0+IC0xXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiAxXG4gICAgfCBmYWxzZSwgZmFsc2UgLT5cbiAgICAgIGxldCB4ID0gY29tcGFyZV9lbHQgKHVuc2FmZV9nZXQgdDEgcG9zKSAodW5zYWZlX2dldCB0MiBwb3MpIGluXG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDEgbXV0MTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgICAgKG1hdGNoIHggd2l0aFxuICAgICAgIHwgMCAtPiB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyXG4gICAgICAgfCBuIC0+IG4pXG4gIGluXG4gIGZ1biBjb21wYXJlX2VsdCB0MSB0MiAtPlxuICAgIGlmIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB0aGVuIDBcbiAgICBlbHNlXG4gICAgICB1bnNhZmVfY29tcGFyZV9mcm9tXG4gICAgICAgIGNvbXBhcmVfZWx0XG4gICAgICAgIDBcbiAgICAgICAgfnQxXG4gICAgICAgIH50MlxuICAgICAgICB+bGVuMTp0MS5sZW5ndGhcbiAgICAgICAgfmxlbjI6dDIubGVuZ3RoXG4gICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgfm11dDI6dDIubnVtX211dGF0aW9uc1xuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgdDEgdDIgPSBjb21wYXJlX19sb2NhbCBjb21wYXJlX2VsdCB0MSB0MlxuXG5sZXQgZXF1YWxfX2xvY2FsID1cbiAgbGV0IHJlYyB1bnNhZmVfZXF1YWxfZnJvbSBlcXVhbF9lbHQgcG9zIH50MSB+dDIgfm11dDEgfm11dDIgfmxlbiA9XG4gICAgcG9zID0gbGVuXG4gICAgfHxcbiAgICBsZXQgYiA9IGVxdWFsX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDEgbXV0MTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDIgbXV0MjtcbiAgICBiICYmIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCAocG9zICsgMSkgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuXG4gIGluXG4gIGZ1biBlcXVhbF9lbHQgdDEgdDIgLT5cbiAgICBwaHlzX2VxdWFsIHQxIHQyXG4gICAgfHxcbiAgICBsZXQgbGVuMSA9IHQxLmxlbmd0aCBpblxuICAgIGxldCBsZW4yID0gdDIubGVuZ3RoIGluXG4gICAgbGVuMSA9IGxlbjJcbiAgICAmJiB1bnNhZmVfZXF1YWxfZnJvbVxuICAgICAgICAgZXF1YWxfZWx0XG4gICAgICAgICAwXG4gICAgICAgICB+dDFcbiAgICAgICAgIH50MlxuICAgICAgICAgfmxlbjpsZW4xXG4gICAgICAgICB+bXV0MTp0MS5udW1fbXV0YXRpb25zXG4gICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgZXF1YWwgZXF1YWxfZWx0IHQxIHQyID0gZXF1YWxfX2xvY2FsIGVxdWFsX2VsdCB0MSB0MlxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBsZXQgeyBudW1fbXV0YXRpb25zOyBtYXNrID0gXzsgZWx0czsgZnJvbnQ7IGxlbmd0aCB9ID0gdCBpblxuICBhc3NlcnQgKGZyb250ID49IDApO1xuICBhc3NlcnQgKGZyb250IDwgY2FwYWNpdHkgdCk7XG4gIGxldCBjYXBhY2l0eSA9IGNhcGFjaXR5IHQgaW5cbiAgYXNzZXJ0IChjYXBhY2l0eSA9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gIGFzc2VydCAoY2FwYWNpdHkgPj0gMSk7XG4gIGFzc2VydCAoSW50LmlzX3BvdzIgY2FwYWNpdHkpO1xuICBhc3NlcnQgKGxlbmd0aCA+PSAwKTtcbiAgYXNzZXJ0IChsZW5ndGggPD0gY2FwYWNpdHkpO1xuICBmb3IgaSA9IDAgdG8gY2FwYWNpdHkgLSAxIGRvXG4gICAgaWYgaSA8IHQubGVuZ3RoXG4gICAgdGhlbiAoXG4gICAgICBpbnZhcmlhbnRfYSAodW5zYWZlX2dldCB0IGkpO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9ucylcbiAgICBlbHNlIGFzc2VydCAobm90ICh1bnNhZmVfaXNfc2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldCBjcmVhdGUgKHR5cGUgYSkgP2NhcGFjaXR5ICgpIDogYSB0ID1cbiAgbGV0IGNhcGFjaXR5ID1cbiAgICBtYXRjaCBjYXBhY2l0eSB3aXRoXG4gICAgfCBOb25lIC0+IDJcbiAgICB8IFNvbWUgY2FwYWNpdHkgLT5cbiAgICAgIGlmIGNhcGFjaXR5IDwgMFxuICAgICAgdGhlblxuICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIFwiY2Fubm90IGhhdmUgcXVldWUgd2l0aCBuZWdhdGl2ZSBjYXBhY2l0eVwiXG4gICAgICAgICAgICAgWyBcImNhcGFjaXR5XCIsIGNhcGFjaXR5IHw+IEludC5zZXhwX29mX3QgXSlcbiAgICAgIGVsc2UgaWYgY2FwYWNpdHkgPSAwXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgSW50LmNlaWxfcG93MiBjYXBhY2l0eVxuICBpblxuICB7IG51bV9tdXRhdGlvbnMgPSAwXG4gIDsgZnJvbnQgPSAwXG4gIDsgbWFzayA9IGNhcGFjaXR5IC0gMVxuICA7IGxlbmd0aCA9IDBcbiAgOyBlbHRzID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOmNhcGFjaXR5XG4gIH1cbjs7XG5cbmxldCBibGl0X3RvX2FycmF5IH5zcmMgZHN0ID1cbiAgYXNzZXJ0IChzcmMubGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZHN0KTtcbiAgbGV0IGZyb250X2xlbiA9IEludC5taW4gc3JjLmxlbmd0aCAoY2FwYWNpdHkgc3JjIC0gc3JjLmZyb250KSBpblxuICBsZXQgcmVzdF9sZW4gPSBzcmMubGVuZ3RoIC0gZnJvbnRfbGVuIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5sZW46ZnJvbnRfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6c3JjLmZyb250IH5kc3QgfmRzdF9wb3M6MDtcbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpyZXN0X2xlbiB+c3JjOnNyYy5lbHRzIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3Bvczpmcm9udF9sZW5cbjs7XG5cbmxldCBzZXRfY2FwYWNpdHlfaW50ZXJuYWwgdCBuZXdfY2FwYWNpdHkgPVxuICBsZXQgZHN0ID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOm5ld19jYXBhY2l0eSBpblxuICBibGl0X3RvX2FycmF5IH5zcmM6dCBkc3Q7XG4gIHQuZnJvbnQgPC0gMDtcbiAgdC5tYXNrIDwtIG5ld19jYXBhY2l0eSAtIDE7XG4gIHQuZWx0cyA8LSBkc3Rcbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBkZXNpcmVkX2NhcGFjaXR5ID1cbiAgKCogV2UgYWxsb3cgYXJndW1lbnRzIGxlc3MgdGhhbiAxIHRvIFtzZXRfY2FwYWNpdHldLCBidXQgdHJhbnNsYXRlIHRoZW0gdG8gMSB0byBzaW1wbGlmeVxuICAgICB0aGUgY29kZSB0aGF0IHJlbGllcyBvbiB0aGUgYXJyYXkgbGVuZ3RoIGJlaW5nIGEgcG93ZXIgb2YgMi4gKilcbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IG5ld19jYXBhY2l0eSA9IEludC5jZWlsX3BvdzIgKG1heCAxIChtYXggZGVzaXJlZF9jYXBhY2l0eSB0Lmxlbmd0aCkpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0IHRoZW4gc2V0X2NhcGFjaXR5X2ludGVybmFsIHQgbmV3X2NhcGFjaXR5XG47O1xuXG5sZXQgZW5xdWV1ZSB0IGEgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA9IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHlfaW50ZXJuYWwgdCAoMiAqIHQubGVuZ3RoKTtcbiAgdW5zYWZlX3NldCB0IHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IGVucXVldWVfZnJvbnQgdCBhID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gc2V0X2NhcGFjaXR5X2ludGVybmFsIHQgKDIgKiB0Lmxlbmd0aCk7XG4gIGxldCBmcm9udCA9ICh0LmZyb250IC0gMSkgbGFuZCB0Lm1hc2sgaW5cbiAgdC5mcm9udCA8LSBmcm9udDtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICB1bnNhZmVfc2V0IHQgMCBhXG47O1xuXG5sZXQgZGVxdWV1ZV9ub25lbXB0eSB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IGVsdHMgPSB0LmVsdHMgaW5cbiAgbGV0IGZyb250ID0gdC5mcm9udCBpblxuICBsZXQgcmVzID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGZyb250IGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSBlbHRzIGZyb250O1xuICB0LmZyb250IDwtIGVsdHNfaW5kZXggdCAxO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIHJlc1xuOztcblxubGV0IGJhY2tfaW5kZXggdCA9IGVsdHNfaW5kZXggdCAodC5sZW5ndGggLSAxKVxuXG5sZXQgZGVxdWV1ZV9iYWNrX25vbmVtcHR5IHQgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgZWx0cyA9IHQuZWx0cyBpblxuICBsZXQgYmFjayA9IGJhY2tfaW5kZXggdCBpblxuICBsZXQgcmVzID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGJhY2sgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIGVsdHMgYmFjaztcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICByZXNcbjs7XG5cbmxldCBkZXF1ZXVlX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGRlcXVldWVfbm9uZW1wdHkgdFxubGV0IGRlcXVldWUgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZGVxdWV1ZV9ub25lbXB0eSB0KVxubGV0IGRlcXVldWVfYW5kX2lnbm9yZV9leG4gKHR5cGUgZWx0KSAodCA6IGVsdCB0KSA9IGlnbm9yZSAoZGVxdWV1ZV9leG4gdCA6IGVsdClcblxubGV0IGRlcXVldWVfYmFja19leG4gdCA9XG4gIGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBTdGRsaWIuUXVldWUuRW1wdHkgZWxzZSBkZXF1ZXVlX2JhY2tfbm9uZW1wdHkgdFxuOztcblxubGV0IGRlcXVldWVfYmFjayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChkZXF1ZXVlX2JhY2tfbm9uZW1wdHkgdClcbmxldCBmcm9udF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIHQuZnJvbnRcbmxldCBiYWNrX25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgKGJhY2tfaW5kZXggdClcbmxldCBsYXN0X25vbmVtcHR5IHQgPSB1bnNhZmVfZ2V0IHQgKHQubGVuZ3RoIC0gMSlcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGZyb250X25vbmVtcHR5IHQpXG5sZXQgcGVla19leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBTdGRsaWIuUXVldWUuRW1wdHkgZWxzZSBmcm9udF9ub25lbXB0eSB0XG5sZXQgcGVla19iYWNrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGJhY2tfbm9uZW1wdHkgdClcbmxldCBwZWVrX2JhY2tfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgYmFja19ub25lbXB0eSB0XG5sZXQgbGFzdCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChsYXN0X25vbmVtcHR5IHQpXG5sZXQgbGFzdF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBTdGRsaWIuUXVldWUuRW1wdHkgZWxzZSBsYXN0X25vbmVtcHR5IHRcblxubGV0IGRyYWluIHQgfmYgfndoaWxlXyA9XG4gIHdoaWxlIChub3QgKGlzX2VtcHR5IHQpKSAmJiB3aGlsZV8gKGZyb250X25vbmVtcHR5IHQpIGRvXG4gICAgZiAoZGVxdWV1ZV9ub25lbXB0eSB0KVxuICBkb25lXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICB1bnNhZmVfdW5zZXQgdCBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwO1xuICAgIHQuZnJvbnQgPC0gMClcbjs7XG5cbmxldCBibGl0X3RyYW5zZmVyIH5zcmMgfmRzdCA/bGVuICgpID1cbiAgaW5jX251bV9tdXRhdGlvbnMgc3JjO1xuICBpbmNfbnVtX211dGF0aW9ucyBkc3Q7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IHNyYy5sZW5ndGhcbiAgICB8IFNvbWUgbGVuIC0+XG4gICAgICBpZiBsZW4gPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJRdWV1ZS5ibGl0X3RyYW5zZmVyOiBuZWdhdGl2ZSBsZW5ndGhcIlxuICAgICAgICAgICAgIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gICAgICBtaW4gbGVuIHNyYy5sZW5ndGhcbiAgaW5cbiAgaWYgbGVuID4gMFxuICB0aGVuIChcbiAgICBzZXRfY2FwYWNpdHkgZHN0IChtYXggKGNhcGFjaXR5IGRzdCkgKGRzdC5sZW5ndGggKyBsZW4pKTtcbiAgICBsZXQgZHN0X3N0YXJ0ID0gZHN0LmZyb250ICsgZHN0Lmxlbmd0aCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAoKiBUaGlzIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gc2ltcGx5IFtlbnF1ZXVlIGRzdCAoZGVxdWV1ZV9ub25lbXB0eSBzcmMpXSAqKVxuICAgICAgbGV0IHNyY19pID0gKHNyYy5mcm9udCArIGkpIGxhbmQgc3JjLm1hc2sgaW5cbiAgICAgIGxldCBkc3RfaSA9IChkc3Rfc3RhcnQgKyBpKSBsYW5kIGRzdC5tYXNrIGluXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lXG4gICAgICAgIGRzdC5lbHRzXG4gICAgICAgIGRzdF9pXG4gICAgICAgIChPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biBzcmMuZWx0cyBzcmNfaSk7XG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHNyYy5lbHRzIHNyY19pXG4gICAgZG9uZTtcbiAgICBkc3QubGVuZ3RoIDwtIGRzdC5sZW5ndGggKyBsZW47XG4gICAgc3JjLmZyb250IDwtIChzcmMuZnJvbnQgKyBsZW4pIGxhbmQgc3JjLm1hc2s7XG4gICAgc3JjLmxlbmd0aCA8LSBzcmMubGVuZ3RoIC0gbGVuKVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBzZXRfY2FwYWNpdHkgdCAoSW50Lm1heCAoY2FwYWNpdHkgdCkgKHQubGVuZ3RoICsgTGlzdC5sZW5ndGggbCkpO1xuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICAgIGxldCByID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgICBkb25lO1xuICAgICFyKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBhIC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbigqIFtpdGVyXSBpcyBpbXBsZW1lbnRlZCBkaXJlY3RseSBiZWNhdXNlIGltcGxlbWVudGluZyBpdCBpbiB0ZXJtcyBvZiBbZm9sZF0gaXNcbiAgIHNsb3dlci4gKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBbXSBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHJlc3VsdCA6PSB1bnNhZmVfZ2V0IHQgaSA6OiAhcmVzdWx0XG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbmVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgY291bnRpID0gQy5jb3VudGlcbmxldCBleGlzdHNpID0gQy5leGlzdHNpXG5sZXQgZmluZF9tYXBpID0gQy5maW5kX21hcGlcbmxldCBmaW5kaSA9IEMuZmluZGlcbmxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcblxuKCogRm9yIFtjb25jYXRfbWFwXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl0sIHdlIGRvbid0IGNyZWF0ZSBbdF9yZXN1bHRdIHdpdGggW3RdJ3NcbiAgIGNhcGFjaXR5IGJlY2F1c2Ugd2UgaGF2ZSBubyBpZGVhIGhvdyBtYW55IGVsZW1lbnRzIFt0X3Jlc3VsdF0gd2lsbCB1bHRpbWF0ZWx5IGhvbGQuICopXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlciB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0MiA9IGZpbHRlcmkgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlIH5jYXBhY2l0eTpzcmMubGVuZ3RoICgpIGluXG4gIGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QuZWx0cztcbiAgZHN0Lmxlbmd0aCA8LSBzcmMubGVuZ3RoO1xuICBkc3Rcbjs7XG5cbmxldCBvZl9saXN0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OihMaXN0Lmxlbmd0aCBsKSAoKSBpblxuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG4oKiBUaGUgcXVldWUgW3RdIHJldHVybmVkIGJ5IFtjcmVhdGVdIHdpbGwgaGF2ZSBbdC5sZW5ndGggPSAwXSwgW3QuZnJvbnQgPSAwXSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IEludC5jZWlsX3BvdzIgbGVuXS4gIFNvLCB3ZSBvbmx5IGhhdmUgdG8gc2V0IFt0Lmxlbmd0aF0gdG8gW2xlbl0gYWZ0ZXJcbiAgIHRoZSBibGl0IHRvIG1haW50YWluIGFsbCB0aGUgaW52YXJpYW50czogW3QubGVuZ3RoXSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICBpbiB0aGUgcXVldWUsIFt0LmZyb250XSBpcyB0aGUgYXJyYXkgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHF1ZXVlLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAqKVxubGV0IGluaXQgbGVuIH5mID1cbiAgaWYgbGVuIDwgMFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIlF1ZXVlLmluaXQ6IG5lZ2F0aXZlIGxlbmd0aFwiIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTpsZW4gKCkgaW5cbiAgYXNzZXJ0IChPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyA+PSBsZW4pO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIGkgKGYgaSlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gbGVuO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkudW5zYWZlX2dldCBhKVxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IHQubGVuZ3RoIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IG1hcCB0YSB+ZiA9XG4gIGxldCBudW1fbXV0YXRpb25zID0gdGEubnVtX211dGF0aW9ucyBpblxuICBsZXQgdGIgPSBjcmVhdGUgfmNhcGFjaXR5OnRhLmxlbmd0aCAoKSBpblxuICB0Yi5sZW5ndGggPC0gdGEubGVuZ3RoO1xuICBmb3IgaSA9IDAgdG8gdGEubGVuZ3RoIC0gMSBkb1xuICAgIGxldCBiID0gZiAodW5zYWZlX2dldCB0YSBpKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0YSBudW1fbXV0YXRpb25zO1xuICAgIE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdGIuZWx0cyBpIGJcbiAgZG9uZTtcbiAgdGJcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIG1hcCB0IH5mOihmdW4gYSAtPlxuICAgIGxldCByZXN1bHQgPSBmICFpIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICByZXN1bHQpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eToxICgpIGluXG4gIGVucXVldWUgdCB4O1xuICB0XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gdG9fbGlzdCB0IHw+IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIHw+IG9mX2xpc3RcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5tb2R1bGUgSXRlcmF0aW9uID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBzdGFydCBxID0gcS5udW1fbXV0YXRpb25zXG4gIGxldCBhc3NlcnRfbm9fbXV0YXRpb25fc2luY2Vfc3RhcnQgdCBxID0gZW5zdXJlX25vX211dGF0aW9uIHEgdFxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9sZW5ndGgiLCJjc3Rfc3JjX3F1ZXVlX21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJCYXNlX0xpc3QiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfT3B0aW9uX2FycmF5IiwiQmFzZV9BcnJheSIsIkJhc2VfSW50IiwiQmFzZV9TZXhwIiwiQmFzZV9FcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX1F1ZXVlIiwiQmFzZV9JbmRleGVkX2NvbnRhaW5lciIsImNzdF9pbmRleCIsImNzdF9RdWV1ZV9pbmRleF9vdXRfb2ZfYm91bmRzIiwiY3N0X211dGF0aW9uX29mX3F1ZXVlX2R1cmluZ19pIiwiY3N0X2NhcGFjaXR5IiwiY3N0X2Nhbm5vdF9oYXZlX3F1ZXVlX3dpdGhfbmVnIiwiY3N0X1F1ZXVlX2JsaXRfdHJhbnNmZXJfbmVnYXRpIiwiZHVtbXkiLCJnbG9iYWxpemUiLCJwYXJhbSIsInQiLCJpbmNfbnVtX211dGF0aW9ucyIsImNhcGFjaXR5IiwiZWx0c19pbmRleCIsImkiLCJ1bnNhZmVfZ2V0IiwidW5zYWZlX3NldCIsImEiLCJjaGVja19pbmRleF9leG4iLCJnZXQiLCJzZXQiLCJpc19lbXB0eSIsImxlbmd0aCIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJvZl9hXzAwMSIsIm51bV9tdXRhdGlvbnNfMDAzIiwiZnJvbnRfMDA1IiwibWFza18wMDciLCJsZW5ndGhfMDA5IiwiZWx0c18wMTEiLCJhcmdfMDEyIiwiYm5kc18wMDIiLCJhcmdfMDEwIiwiYXJnXzAwOCIsImFyZ18wMDYiLCJhcmdfMDA0IiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmVfZWx0IiwidDEiLCJ0MiIsIm11dDIiLCJtdXQxIiwibGVuMiIsImxlbjEiLCJwb3MiLCJtYXRjaCIsIngiLCJjb21wYXJlIiwiZXF1YWxfbG9jYWwiLCJlcXVhbF9lbHQiLCJiIiwiZXF1YWwiLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfYSIsImZyb250IiwiZWx0cyIsImNyZWF0ZSIsImJsaXRfdG9fYXJyYXkiLCJzcmMiLCJkc3QiLCJmcm9udF9sZW4iLCJyZXN0X2xlbiIsInNldF9jYXBhY2l0eV9pbnRlcm5hbCIsIm5ld19jYXBhY2l0eSIsInNldF9jYXBhY2l0eSIsImRlc2lyZWRfY2FwYWNpdHkiLCJlbnF1ZXVlIiwiZW5xdWV1ZV9mcm9udCIsImRlcXVldWVfbm9uZW1wdHkiLCJyZXMiLCJiYWNrX2luZGV4IiwiZGVxdWV1ZV9iYWNrX25vbmVtcHR5IiwiYmFjayIsImRlcXVldWVfZXhuIiwiZGVxdWV1ZSIsImRlcXVldWVfYW5kX2lnbm9yZV9leG4iLCJkZXF1ZXVlX2JhY2tfZXhuIiwiZGVxdWV1ZV9iYWNrIiwiZnJvbnRfbm9uZW1wdHkiLCJiYWNrX25vbmVtcHR5IiwibGFzdF9ub25lbXB0eSIsInBlZWsiLCJwZWVrX2V4biIsInBlZWtfYmFjayIsInBlZWtfYmFja19leG4iLCJsYXN0IiwibGFzdF9leG4iLCJkcmFpbiIsIndoaWxlJCIsImNsZWFyIiwiYmxpdF90cmFuc2ZlciIsImxlbiIsImRzdF9zdGFydCIsInNyY19pIiwiZHN0X2kiLCJlbnF1ZXVlX2FsbCIsImwiLCJmb2xkIiwiaW5pdCIsInIiLCJmb2xkaSIsImFjYyIsIml0ZXIiLCJpdGVyaSIsInRvX2xpc3QiLCJyZXN1bHQiLCJDIiwiY291bnQiLCJleGlzdHMiLCJmaW5kIiwiZmluZF9tYXAiLCJmb2xkX3Jlc3VsdCIsImZvbGRfdW50aWwiLCJmb3JfYWxsIiwibWF4X2VsdCIsIm1lbSIsIm1pbl9lbHQiLCJzdW0iLCJjb3VudGkiLCJleGlzdHNpIiwiZmluZF9tYXBpIiwiZmluZGkiLCJmb3JfYWxsaSIsImNzdF9RdWV1ZV9pbml0X25lZ2F0aXZlX2xlbmd0aCIsImNvbmNhdF9tYXAiLCJ0X3Jlc3VsdCIsImNvbmNhdF9tYXBpIiwiZmlsdGVyX21hcCIsImZpbHRlcl9tYXBpIiwiZmlsdGVyIiwiZmlsdGVyaSIsImZpbHRlcl9pbnBsYWNlIiwiZmlsdGVyaV9pbnBsYWNlIiwiY29weSIsIm9mX2xpc3QiLCJvZl9hcnJheSIsInRvX2FycmF5IiwibWFwIiwidGEiLCJ0YiIsIm1hcGkiLCJzaW5nbGV0b24iLCJzZXhwX29mX3QiLCJzZXhwX29mX2EiLCJ0X29mX3NleHAiLCJhX29mX3NleHAiLCJzZXhwIiwidF9zZXhwX2dyYW1tYXIiLCJncmFtbWFyIiwic3RhcnQiLCJxIiwiYXNzZXJ0X25vX211dGF0aW9uX3NpbmNlX3N0YXJ0IiwiSXRlcmF0aW9uIiwiQmFzZV9RdWV1ZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFB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QSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHRKRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMzczLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL25vdGhpbmcubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gfFxuXG4gIGxldCB1bnJlYWNoYWJsZV9jb2RlX2xvY2FsID0gZnVuY3Rpb25cbiAgICB8IChfIDogdCkgLT4gLlxuICA7O1xuXG4gIGxldCB1bnJlYWNoYWJsZV9jb2RlIHggPSB1bnJlYWNoYWJsZV9jb2RlX2xvY2FsIHhcbiAgbGV0IGFsbCA9IFtdXG4gIGxldCBoYXNoX2ZvbGRfdCBfIHQgPSB1bnJlYWNoYWJsZV9jb2RlIHRcbiAgbGV0IGhhc2ggPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBjb21wYXJlIGEgXyA9IHVucmVhY2hhYmxlX2NvZGUgYVxuICBsZXQgY29tcGFyZV9fbG9jYWwgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBlcXVhbF9fbG9jYWwgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBzZXhwX29mX3QgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCB0X29mX3NleHAgc2V4cCA9IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV90eXBlIFwiQmFzZS5Ob3RoaW5nLnRcIiBzZXhwXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbiAgbGV0IHRvX3N0cmluZyA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IG9mX3N0cmluZyAoXyA6IHN0cmluZykgPSBmYWlsd2l0aCBcIkJhc2UuTm90aGluZy5vZl9zdHJpbmc6IG5vdCBzdXBwb3J0ZWRcIlxuICBsZXQgZ2xvYmFsaXplID0gdW5yZWFjaGFibGVfY29kZVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5vdGhpbmdcIlxuZW5kKVxuXG5sZXQgbXVzdF9iZV9ub25lIDogdCBvcHRpb24gLT4gdW5pdCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgXyAtPiAuXG47O1xuXG5sZXQgbXVzdF9iZV9lbXB0eSA6IHQgbGlzdCAtPiB1bml0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IF8gOjogXyAtPiAuXG47O1xuXG5sZXQgbXVzdF9iZV9vayA6ICgnb2ssIHQpIFJlc3VsdC50IC0+ICdvayA9IGZ1bmN0aW9uXG4gIHwgT2sgb2sgLT4gb2tcbiAgfCBFcnJvciBfIC0+IC5cbjs7XG5cbmxldCBtdXN0X2JlX2Vycm9yIDogKHQsICdlcnIpIFJlc3VsdC50IC0+ICdlcnIgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gLlxuICB8IEVycm9yIGVycm9yIC0+IGVycm9yXG47O1xuXG5sZXQgbXVzdF9iZV9maXJzdCA6ICgnZmlyc3QsIHQpIEVpdGhlci50IC0+ICdmaXJzdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgZmlyc3QgLT4gZmlyc3RcbiAgfCBTZWNvbmQgXyAtPiAuXG47O1xuXG5sZXQgbXVzdF9iZV9zZWNvbmQgOiAodCwgJ3NlY29uZCkgRWl0aGVyLnQgLT4gJ3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiAuXG4gIHwgU2Vjb25kIHNlY29uZCAtPiBzZWNvbmRcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImdsb2JhbF9kYXRhIiwidF9zZXhwX2dyYW1tYXIiLCJtb2R1bGVfbmFtZSIsIkJhc2VfSW1wb3J0IiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwiTWF0Y2hfZmFpbHVyZSIsIkJhc2VfSWRlbnRpZmlhYmxlIiwidW5yZWFjaGFibGVfY29kZV9sb2NhbCIsInBhcmFtIiwidW5yZWFjaGFibGVfY29kZSIsIngiLCJjc3RfQmFzZV9Ob3RoaW5nX3QiLCJjc3RfQmFzZV9Ob3RoaW5nX29mX3N0cmluZ19ub3QiLCJoYXNoX2ZvbGRfdCIsInQiLCJjb21wYXJlIiwiYSIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbF9sb2NhbCIsInRfb2Zfc2V4cCIsInNleHAiLCJvZl9zdHJpbmciLCJpbmNsdWRlIiwiaGFzaCIsInNleHBfb2ZfdCIsInRvX3N0cmluZyIsInN5bWJvbCIsImVxdWFsIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJwcCIsImhhc2hhYmxlIiwibXVzdF9iZV9ub25lIiwibXVzdF9iZV9lbXB0eSIsIm11c3RfYmVfb2siLCJvayIsIm11c3RfYmVfZXJyb3IiLCJlcnJvciIsIm11c3RfYmVfZmlyc3QiLCJmaXJzdCIsIm11c3RfYmVfc2Vjb25kIiwic2Vjb25kIiwiQmFzZV9Ob3RoaW5nIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQTtBQUFBLFlBQUFDLHVCQUFBQztBQUFBQSxJQ0srQjtBQUFBLEdBQ2I7QUFBQSxZQUFBQyxpQkFBQUMsR0FHUyxnQ0FBd0I7QUFBQTtBQUFBLElBQUFDLHFCRFRuRDtBQUFBLElBQUFDLGlDQUFBO0FBQUEsWUFBQUMsWUFBQUwsT0FBQU0sR0NTMkIsZ0NBRWU7QUFBQSxZQUFBQyxRQUFBQyxHQUFBUixPQUZmLGdDQUlXO0FBQUEsWUFBQVMsY0FBQUQsR0FBQVIsT0FKWCxnQ0FLa0I7QUFBQSxZQUFBVSxZQUFBRixHQUFBUixPQUxsQixnQ0FNZ0I7QUFBQSxZQUFBVyxVQUFBQztBQUFBQSxJQUVwQix3RUFBeUQ7QUFBQTtBQUFBLFlBQUFDLFVBQUFiO0FBQUFBLElBR2pELGtFQUFnRDtBQUFBO0FBQUE7QUFBQSxJQUFBYztBQUFBQSxNRHBCL0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFULGdCQUFBO0FBQUEsSUFBQVUsT0FBQTtBQUFBLElBQUFKLGNBQUE7QUFBQSxJQUFBSyxZQUFBO0FBQUEsSUFBQUgsY0FBQTtBQUFBLElBQUFJLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQVosWUFBQTtBQUFBLElBQUFhLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxhQUFBOUIsT0NpQ1ksU0FBRTtBQUFBLFlBQUErQixjQUFBL0IsT0FLSixTQUFFO0FBQUEsWUFBQWdDLFdBQUFoQyxXQUFBaUMsS0FJZ0MsVUFDL0IsVUFDRztBQUFBLFlBQUFDLGNBQUFsQyxXQUFBbUMsUUFHaUMsVUFFOUIsYUFBSztBQUFBLFlBQUFDLGNBQUFwQyxXQUFBcUMsUUFHNkIsVUFDbEMsYUFDRjtBQUFBLFlBQUFDLGVBQUF0QyxXQUFBdUMsU0FHdUMsVUFFbkMsY0FBTTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQzRDNCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzA0OTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvbmF0aXZlaW50Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuTmF0aXZlaW50XG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX25hdGl2ZWludCA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChuYXRpdmVpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfbmF0aXZlaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IG5hdGl2ZWludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gIGxldCBvZl9zdHJpbmdfb3B0ID0gb2Zfc3RyaW5nX29wdFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlIChUKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9oZXggKHN0cnVjdFxuICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbnhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiVueFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnQuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50XCJcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IG51bV9iaXRzID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAgICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIk5hdGl2ZWludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5OYXRpdmVpbnQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBTdGRsaWIuTmF0aXZlaW50LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gU3RkbGliLk5hdGl2ZWludC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgKHggOiBuYXRpdmVpbnQpID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gU3RkbGliLk5hdGl2ZWludC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5OYXRpdmVpbnQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgU3RkbGliLk5hdGl2ZWludC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBTdGRsaWIuTmF0aXZlaW50LnByZWQgeCA9IDBuXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgbmF0aXZlaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIFN0ZGxpYi5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgaWYgU3RkbGliLk5hdGl2ZWludC5lcXVhbCBpIFN0ZGxpYi5OYXRpdmVpbnQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoU3RkbGliLk5hdGl2ZWludC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX25hdGl2ZWludCB0ID0gdFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgdCA9IHRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5uYXRpdmVpbnRfcG9wY291bnRcbmxldCBvZl9pbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jXG4gIDogIChuYXRpdmVpbnRbQGxvY2FsX29wdF0pXG4gIC0+IChpbnQzMltAbG9jYWxfb3B0XSlcbiAgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfbmF0aXZlaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9uYXRpdmVpbnRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGluY2x1ZGUgUHJlX09cblxuICAgIGxldCByZW0gPSByZW1cbiAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbTmF0aXZlaW50XSBhbmQgW05hdGl2ZWludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmV4dGVybmFsIGJzd2FwIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWJzd2FwX25hdGl2ZVwiXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9ueCIsImNzdF9hcmd1bWVudF9tdXN0X2JlX3N0cmljdGx5XyIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwibW9kdWxlX25hbWUiLCJCYXNlX0ludF9tYXRoIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTmF0aXZlaW50IiwiQmFzZV9QcmludGYiLCJCYXNlX0Zsb2F0MCIsIlN0ZGxpYl9TY2FuZiIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfSW50X3N0cmluZ19jb252ZXJzaW9ucyIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJCYXNlX1dvcmRfc2l6ZSIsIkJhc2VfRXJyb3IiLCJCYXNlX1BvcGNvdW50IiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJpbmNsdWRlIiwiY29tcGFyZSIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJjb21wYXJhdG9yIiwiemVybyIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwidG9fc3RyaW5nX2h1bSIsImNvbXBhcmVfbG9jYWwiLCJhIiwiYiIsIm5lZyIsInN5bWJvbCIsImkiLCJzIiwiSGV4IiwicHAiLCJpbnZhcmlhbnQiLCJwYXJhbSIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJzaGlmdF9yaWdodCIsInNoaWZ0X2xlZnQiLCJiaXRfbm90IiwiYml0X3hvciIsImJpdF9vciIsImJpdF9hbmQiLCJtaW5fdmFsdWUiLCJtYXhfdmFsdWUiLCJhYnMiLCJwcmVkIiwic3VjYyIsInJlbSIsIm1pbnVzX29uZSIsIm9uZSIsInRvX2Zsb2F0Iiwib2ZfZmxvYXRfdW5jaGVja2VkIiwib2ZfZmxvYXQiLCJyYWlzZV9zIiwiY3N0X05hdGl2ZWludF9mbG9vcl9sb2cyX2dvdF9pIiwiY3N0X05hdGl2ZWludF9jZWlsX2xvZzJfZ290X2luIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImxzciIsImxhbmQiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJjZWlsX2xvZzIiLCJiZXR3ZWVuIiwidCIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJtaW4iLCJtYXgiLCJjbGFtcF9leG4iLCJjbGFtcCIsImluY3IiLCJyIiwiZGVjciIsIm9mX25hdGl2ZWludCIsInRvX25hdGl2ZWludCIsInBvcGNvdW50Iiwib2ZfaW50X2V4biIsInRvX2ludCIsInRvX2ludF9leG4iLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQzMiIsInRvX2ludDMyIiwidG9faW50MzJfZXhuIiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4iLCJvZl9pbnQ2NF90cnVuYyIsInRvX2ludDY0IiwicG93IiwiZSIsImVxdWFsX2xvY2FsIiwiZXF1YWwiLCJjbHoiLCJCaW5hcnkiLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiQmFzZV9OYXRpdmVpbnQiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFWLFFBQUE7QUFBQSxJQUFBQSxNQUFBO0FBQUEsSUFBQVcsY0FBQTtBQUFBLElBQUFBLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0NjYSwwQkFBTTtBQUFBO0FBQUEsSUFBQUMsWUFBZjtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBVCxZQUFBO0FBQUEsSUFBQVUsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQXBCLFlBQUE7QUFBQSxJQUFBcUIsZ0JBQUE7QUFBQSxJQUFBYixjQUFBO0FBQUEsSUFBQWMsZ0JBQUE7QUFBQSxZQUFBckIsVUFBQXNCLEdBQUFDLEdBa0N3QixzQ0FBa0I7QUFBQSxPQUFBckIsZ0JBbEMxQyxrQkFBQUMsU0FBQTtBQUFBLFlBQUFDLE9BQUFDLEdBeUNTLDRCQUFNO0FBQUEsT0FBQVMsU0FBZjtBQUFBLFlBQUFVLElBQUEsR0R2REo7QUFBQTtBQUFBLElBQUFDLFNDdURJO0FBQUE7QUFBQTtBQUFBLFlBQUFmLFlBQUFnQjtBQUFBQSxJQVFnQixrREFBc0I7QUFBQTtBQUFBLFlBQUFmLFlBQUFnQjtBQUFBQSxJQUN0QjtBQUFBLDJERGhFcEIsV0NnRXFEO0FBQUE7QUFBQTtBQUFBLElBQUE1QjtBQUFBQSxNQVRqRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUE2QixNQUFBO0FBQUEsSUFBQTdCO0FBQUFBLE1BQUE7QUFBQSxJQUFBOEIsS0FBQTtBQUFBLFlBQUFDLFVBQUFDLE9BeUJvQixTQUFFO0FBQUE7QUFBQSxJQUFBQyxXQUNYO0FBQUEsSUFBQUMsb0JBQ1M7QUFBQSxJQUFBQyxvQkFDQTtBQUFBLFlBQUFDLG9CQUFBLE1EbkZ4QjtBQUFBLFlBQUFDLFlBQUE7QUFBQSxZQUFBQyxXQUFBO0FBQUEsT0FBQUMsVUNtRjJEO0FBQUEsWUFBQUMsUUFBQSxNRG5GM0Q7QUFBQSxZQUFBQyxPQUFBO0FBQUEsWUFBQUMsUUFBQTtBQUFBO0FBQUEsSUFBQUMsWUNtRjJEO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxZQUFBdEIsU0FBQSxHRG5GM0Q7QUFBQTtBQUFBLElBQUF1QixZQ21GMkQ7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQW5DLFNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBb0MsU0FBQSxHRG5GM0Q7QUFBQSxZQUFBQyxtQkFBQTtBQUFBLFlBQUFDLFNBQUE1RTtBQUFBQSxJQ3lHRSxxREFFZTtBQUFBLFlBSVg7QUFBQSxJQUFjLHFEQUNaO0FBQUE7QUFBQTtBQUFBLElBQUE2RSxVQTdCbUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLFlBQUFDLHNCQUFBNUI7QUFBQUEsSUF1Q3ZELGtEQUEyRDtBQUFBO0FBQUEsWUFBQTZCLElBQUEsTUQxSC9EO0FBQUEsWUFBQUMsS0FBQTtBQUFBLFlBQUFDLFVBQUF6RDtBQUFBQSxJQ21JTyx5Q0FBYTtBQUFBO0FBQUEsS0FBQUEsTUFDUjtBQUFBLEtBQUFBLE1BQ0E7QUFBQSxLQUFBQSxNQUNBO0FBQUEsS0FBQUEsTUFDQTtBQUFBLEtBQUFBLE1BQ0E7QUFBQSxLQUFBQSxNQUNBO0FBQUEsS0FBQUEsTUFHQTtBQUFBLElBQ1IsMENBQXVCO0FBQUE7QUFBQSxZQUFBMEQsV0FBQTFEO0FBQUFBLElBS3BCLDJDQUFhO0FBQUE7QUFBQSxLQUFBQSxJQUNSO0FBQUEsS0FBQUEsTUFDQTtBQUFBLEtBQUFBLE1BQ0E7QUFBQSxLQUFBQSxNQUNBO0FBQUEsS0FBQUEsTUFDQTtBQUFBLEtBQUFBLE1BQ0E7QUFBQSxJQUN3QjtBQUFBO0FBQUEsWUFBQTJELFFBQUEzRDtBQUFBQSxJQUk3Qix5Q0FBYTtBQUFBLFlBQ1Q7QUFBQSxJQUF1QiwyQ0FBSztBQUFBO0FBQUEsWUFBQTRELFdBQUF2QztBQUFBQSxJQWtCaEM7QUFBQSxhQUtVO0FBQUEsS0FIWCxRQUNFO0FBQUE7QUFBQTtBQUFBLFNBR1c7QUFBQSxTQUFmO0FBQUEsSUFBWSx1Q0FBUTtBQUFBO0FBQUEsWUFBQXdDLFVBQUF4QztBQUFBQSxJQUtqQjtBQUFBLGFBS1U7QUFBQSxLQUhYLFFBQ0U7QUFBQTtBQUFBLElBR0QsNERBQ0U7QUFBQTtBQUFBO0FBQUEsT0FDVyxvQ0FBSTtBQUFBLElBQXlCO0FBQUE7QUFBQSxZQUFBeUMsUUFBQUMsR0FBQUMsS0FBQUM7QUFBQUEsUUFBQSxJQU10QjtBQUFBLElBQVEsc0RBQWE7QUFBQTtBQUFBLFlBQUFDLGdCQUFBSCxHQUFBSSxLQUFBQztBQUFBQSxRQUFBLElBQ0o7QUFBQSxJQUFjLDhDQUFRO0FBQUE7QUFBQSxZQUFBQyxVQUFBTixHQUFBSSxLQUFBQztBQUFBQSxJQUd6RDtBQUFBLEtBQ1AsbUNBQTJCO0FBQUEsSUFEUjtBQUFBLEdBQ1E7QUFBQSxZQUFBRSxNQUFBUCxHQUFBSSxLQUFBQztBQUFBQSxJQUl4QjtBQUFBLEtBTUssd0NBQTZCO0FBQUE7QUFBQSxTQURHO0FBQUEsU0FBeEI7QUFBQSxTQUZaO0FBQUEsSUFFc0Qsc0NBQ3JCO0FBQUE7QUFBQSxPQUFBaEQsV0FySW9CLGtCQUFBQSxXQUFBO0FBQUEsWUFBQUEsU0FBQSxNRG5GM0Q7QUFBQSxZQUFBQSxTQUFBO0FBQUEsWUFBQW1ELEtBQUFDLEdDZ08wQjtBQUFBLFlBQUFDLEtBQUFELEdBQ0E7QUFBQSxZQUFBRSxhQUFBWCxHQUNMLFNBQUM7QUFBQSxZQUFBWSxhQUFBWixHQUVELFNBQUM7QUFBQTtBQUFBLElBQUFhLFdBakpxQztBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLFlBQUFDLElBQUF0RSxHQUFBdUU7QUFBQUEsUUFBQSxJQXVLTyxtQkFBZjtBQUFBLElBQTFCLE9BQXdELFdBQXhELHFDQUF3RDtBQUFBO0FBQUEsWUFBQXJFLFNBQUFGLEdBQUF1RSxHQUNoRSxnQkFBTztBQUFBLE9BQUF6RSxrQkF4S21DO0FBQUEsWUFBQXJCLFVBQUFzQixHQUFBQyxHQThLL0Isd0NBQWtCO0FBQUEsT0FBQXdFLGNBOUthO0FBQUEsWUFBQUMsTUFBQTFFLEdBQUFDLEdBZ0xqQyxvQ0FBZ0I7QUFBQSxPQUFBckIsZ0JBaExpQixrQkFBQUMsU0FBQTtBQUFBLFlBQUFDLE9BQUFDLEdBdUw5Qyw0QkFBTTtBQUFBLFlBQUE0RixJQUFBLEdEMVFuQjtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUMwUUk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQXpFLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUExQjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBMEIsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQTBFLFFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBeEcsWUFBQTtBQUFBLElBQUEwQixZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBK0UsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBekcsWUFBQTtBQUFBLElBQUFxQixrQkFBQTtBQUFBLElBQUEyRSxVQUFBO0FBQUEsSUFBQUQsZ0JBQUE7QUFBQSxJQUFBdEIsTUFBQTtBQUFBLElBQUFELE1BQUE7QUFBQSxJQUFBa0M7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJEMVFKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQzBRSTtBQUFBO0FBQUEsRUQxUUoiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozMDk3NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9tYXAubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNYXBfaW50ZlxuXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLkZpbmlzaGVkX29yX3VuZmluaXNoZWRcblxuICAoKiBUaGVzZSB0d28gZnVuY3Rpb25zIGFyZSB0ZXN0ZWQgaW4gW3Rlc3RfbWFwLm1sXSB0byBtYWtlIHN1cmUgb3VyIHVzZSBvZlxuICAgICBbU3RkbGliLk9iai5tYWdpY10gaXMgY29ycmVjdCBhbmQgc2FmZS4gKilcbiAgbGV0IG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdCA9IFN0ZGxpYi5PYmoubWFnaWNcbiAgbGV0IHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudCA9IFN0ZGxpYi5PYmoubWFnaWNcbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLk1lcmdlX2VsZW1lbnRcblxuICBsZXQgbGVmdCA9IGZ1bmN0aW9uXG4gICAgfCBgUmlnaHQgXyAtPiBOb25lXG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IFNvbWUgbGVmdFxuICA7O1xuXG4gIGxldCByaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gU29tZSByaWdodFxuICA7O1xuXG4gIGxldCBsZWZ0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYFJpZ2h0IF8gLT4gZGVmYXVsdFxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgXyAtPiBkZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHZhbHVlcyB0IH5sZWZ0X2RlZmF1bHQgfnJpZ2h0X2RlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgbGVmdCAtPiBsZWZ0LCByaWdodF9kZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgLT4gbGVmdF9kZWZhdWx0LCByaWdodFxuICAgIHwgYEJvdGggKGxlZnQsIHJpZ2h0KSAtPiBsZWZ0LCByaWdodFxuICA7O1xuZW5kXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmV4Y2VwdGlvbiBEdXBsaWNhdGUgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBEdXBsaWNhdGVdIChmdW5jdGlvblxuICAgIHwgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5EdXBsaWNhdGVcIlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBbV2l0aF9sZW5ndGgudF0gYWxsb3dzIHVzIHRvIHN0b3JlIGxlbmd0aCBpbmZvcm1hdGlvbiBvbiB0aGUgc3RhY2sgd2hpbGVcbiAgIGtlZXBpbmcgdGhlIHRyZWUgZ2xvYmFsLiBUaGlzIHNhdmVzIHVwIHRvIE8obG9nIG4pIGJsb2NrcyBvZiBoZWFwIGFsbG9jYXRpb24uICopXG5tb2R1bGUgV2l0aF9sZW5ndGggOiBzaWdcbiAgdHlwZSAnYSB0ID0gcHJpdmF0ZVxuICAgIHsgdHJlZSA6ICdhXG4gICAgOyBsZW5ndGggOiBpbnRcbiAgICB9XG5cbiAgdmFsIHdpdGhfbGVuZ3RoIDogJ2EgLT4gaW50IC0+ICdhIHRcbiAgdmFsIHdpdGhfbGVuZ3RoX2dsb2JhbCA6ICdhIC0+IGludCAtPiAnYSB0XG4gIHZhbCBnbG9iYWxpemUgOiAnYSB0IC0+ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgdHJlZSA6ICdhXG4gICAgOyBsZW5ndGggOiBpbnRcbiAgICB9XG5cbiAgbGV0IHdpdGhfbGVuZ3RoIHRyZWUgbGVuZ3RoID0geyB0cmVlOyBsZW5ndGggfVxuICBsZXQgd2l0aF9sZW5ndGhfZ2xvYmFsIHRyZWUgbGVuZ3RoID0geyB0cmVlOyBsZW5ndGggfVxuICBsZXQgZ2xvYmFsaXplIHsgdHJlZTsgbGVuZ3RoIH0gPSB7IHRyZWU7IGxlbmd0aCB9XG5lbmRcblxub3BlbiBXaXRoX2xlbmd0aFxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBMZWFmIG9mXG4gICAgICAgIHsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgfVxuICAgIHwgTm9kZSBvZlxuICAgICAgICB7IGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICAgIDsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgOyByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgICAgOyBoZWlnaHQgOiBpbnRcbiAgICAgICAgfVxuXG4gIHR5cGUgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIHRcblxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IGRhdGEgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IGggfSAtPiBoXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9rZXkgbG93ZXIgayA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2tleSBrIHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBfIH0gLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIGspIGNvbXBhcmVfa2V5IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSBrKSB1cHBlciBjb21wYXJlX2tleSByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9rZXkgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9rZXkgdFxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbnM6IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDIsIGhsID0gaGVpZ2h0KGwpLCBociA9IGhlaWdodChyKSAqKVxuICBsZXRbQGlubGluZV0gY3JlYXRlX3dpdGhfaGVpZ2h0cyB+aGwgfmhyIGwgeCBkIHIgPVxuICAgIGlmIGhsID0gMCAmJiBociA9IDBcbiAgICB0aGVuIExlYWYgeyBrZXkgPSB4OyBkYXRhID0gZCB9XG4gICAgZWxzZVxuICAgICAgTm9kZVxuICAgICAgICB7IGxlZnQgPSBsXG4gICAgICAgIDsga2V5ID0geFxuICAgICAgICA7IGRhdGEgPSBkXG4gICAgICAgIDsgcmlnaHQgPSByXG4gICAgICAgIDsgaGVpZ2h0ID0gKGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKVxuICAgICAgICB9XG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAyICopXG4gIGxldCBjcmVhdGUgbCB4IGQgciA9IGNyZWF0ZV93aXRoX2hlaWdodHMgfmhsOihoZWlnaHQgbCkgfmhyOihoZWlnaHQgcikgbCB4IGQgclxuICBsZXQgc2luZ2xldG9uIGtleSBkYXRhID0gTGVhZiB7IGtleTsgZGF0YSB9XG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuTWFwIG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA6IChfLCBfKSB0ID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGssIHYgPSBmIGkgaW5cbiAgICAgICAgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH1cbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIE5vZGVcbiAgICAgICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0ga2w7IGRhdGEgPSB2bCB9XG4gICAgICAgICAgOyBrZXkgPSBrXG4gICAgICAgICAgOyBkYXRhID0gdlxuICAgICAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgIH1cbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciwgdnIgPSBmIChpICsgMikgaW5cbiAgICAgICAgTm9kZVxuICAgICAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBrbDsgZGF0YSA9IHZsIH1cbiAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICA7IGRhdGEgPSB2XG4gICAgICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBrcjsgZGF0YSA9IHZyIH1cbiAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICB9XG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgdiByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDJcbiAgICAgICAgIHx8XG4gICAgICAgICBsZXQgazAsIF8gPSBhcnJheS4oMCkgaW5cbiAgICAgICAgIGxldCBrMSwgXyA9IGFycmF5LigxKSBpblxuICAgICAgICAgY29tcGFyZV9rZXkgazAgazEgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICB3aXRoX2xlbmd0aCAob2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbjphcnJheV9sZW5ndGggfmY6bmV4dCkgYXJyYXlfbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+XG4gICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSlcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oMCkpIChmc3QgYXJyYXkuKDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LihpKSkgKGZzdCBhcnJheS4oaSArIDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSB8PiBnbG9iYWxpemUpKVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMyAqKVxuICBsZXRbQGlubGluZV0gYmFsIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsIGluXG4gICAgbGV0IGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBociArIDIgKilcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsbDsga2V5ID0gbHY7IGRhdGEgPSBsZDsgcmlnaHQgPSBscjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgeyBrZXkgPSBscnY7IGRhdGEgPSBscmQgfSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgRW1wdHkpIGxydiBscmQgKGNyZWF0ZSBFbXB0eSB4IGQgcilcbiAgICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbHJsOyBrZXkgPSBscnY7IGRhdGEgPSBscmQ7IHJpZ2h0ID0gbHJyOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaGwgKyAyICopXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gcmw7IGtleSA9IHJ2OyBkYXRhID0gcmQ7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIHsga2V5ID0gcmx2OyBkYXRhID0gcmxkIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIEVtcHR5KSBybHYgcmxkIChjcmVhdGUgRW1wdHkgcnYgcmQgcnIpXG4gICAgICAgICAgfCBOb2RlIHsgbGVmdCA9IHJsbDsga2V5ID0gcmx2OyBkYXRhID0gcmxkOyByaWdodCA9IHJscjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpKSlcbiAgICBlbHNlIGNyZWF0ZV93aXRoX2hlaWdodHMgfmhsIH5ociBsIHggZCByXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiW01hcC5hZGRfZXhuXSBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5cbiAgbW9kdWxlIEFkZF9vcl9zZXQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBBZGRfZXhuX2ludGVybmFsXG4gICAgICB8IEFkZF9leG5cbiAgICAgIHwgU2V0XG4gIGVuZFxuXG4gIGxldCByZWMgZmluZF9hbmRfYWRkX29yX3NldFxuICAgIHRcbiAgICB+bGVuZ3RoXG4gICAgfmtleTp4XG4gICAgfmRhdGFcbiAgICB+Y29tcGFyZV9rZXlcbiAgICB+c2V4cF9vZl9rZXlcbiAgICB+KGFkZF9vcl9zZXQgOiBBZGRfb3Jfc2V0LnQpXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gd2l0aF9sZW5ndGggKExlYWYgeyBrZXkgPSB4OyBkYXRhIH0pIChsZW5ndGggKyAxKVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5ID0geDsgZGF0YSB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIHdpdGhfbGVuZ3RoXG4gICAgICAgICAgKE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0geDsgZGF0YSB9XG4gICAgICAgICAgICAgOyBrZXkgPSB2XG4gICAgICAgICAgICAgOyBkYXRhID0gZFxuICAgICAgICAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKGxlbmd0aCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIHdpdGhfbGVuZ3RoXG4gICAgICAgICAgKE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgICAgICAgIDsga2V5ID0gdlxuICAgICAgICAgICAgIDsgZGF0YSA9IGRcbiAgICAgICAgICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHg7IGRhdGEgfVxuICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKGxlbmd0aCArIDEpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT5cbiAgICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB4OyBkYXRhOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSkgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsLCByLCBsZW5ndGggPVxuICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPVxuICAgICAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICAgICAgICAgfmxlbmd0aFxuICAgICAgICAgICAgICAgIH5rZXk6eFxuICAgICAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICAgICAgbFxuICAgICAgICAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgICAgICAgIH5zZXhwX29mX2tleVxuICAgICAgICAgICAgICAgIH5hZGRfb3Jfc2V0XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbCwgciwgbGVuZ3RoKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCB9ID1cbiAgICAgICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgICAgICB+a2V5OnhcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgIHJcbiAgICAgICAgICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICAgICAgICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgICAgICAgICB+YWRkX29yX3NldFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGwsIHIsIGxlbmd0aClcbiAgICAgICAgaW5cbiAgICAgICAgd2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW3NldCddIGZvciB0aGUgY2FzZSB3aGVuIFtrZXldIGlzIGxlc3MgdGhhbiBhbGwgdGhlIGV4aXN0aW5nIGtleXMgKilcbiAgbGV0IHJlYyBzZXRfbWluIGtleSBkYXRhIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgTm9kZSB7IGxlZnQgPSBMZWFmIHsga2V5OyBkYXRhIH07IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgbCA9IHNldF9taW4ga2V5IGRhdGEgbCBpblxuICAgICAgYmFsIGwgdiBkIHJcbiAgOztcblxuICAoKiBzcGVjaWFsaXphdGlvbiBvZiBbc2V0J10gZm9yIHRoZSBjYXNlIHdoZW4gW2tleV0gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGVcbiAgICAgZXhpc3Rpbmcga2V5cyAgKilcbiAgbGV0IHJlYyBzZXRfbWF4IHQga2V5IGRhdGEgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gTGVhZiB7IGtleTsgZGF0YSB9OyBoZWlnaHQgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgciA9IHNldF9tYXggciBrZXkgZGF0YSBpblxuICAgICAgYmFsIGwgdiBkIHJcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXQ6QWRkX2V4blxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleVxuICAgICAgfmFkZF9vcl9zZXQ6QWRkX2V4bl9pbnRlcm5hbFxuICA7O1xuXG4gIGxldCBzZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXk6KGZ1biBfIC0+IExpc3QgW10pXG4gICAgICB+YWRkX29yX3NldDpTZXRcbiAgOztcblxuICBsZXQgc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleSA9IChzZXQgdCB+bGVuZ3RoOjAgfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpLnRyZWVcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgIHR5cGUgKCdrLCAnZCkgdFxuXG4gICAgdmFsIGVtcHR5IDogKCdrLCAnZCkgdFxuICAgIHZhbCBtYXhfa2V5IDogKCdrLCAnZCkgdCAtPiAnayBvcHRpb25cbiAgICB2YWwgYWRkX3VuY2hlY2tlZCA6ICgnaywgJ2QpIHQgLT4ga2V5OidrIC0+IGRhdGE6J2QgLT4gKCdrLCAnZCkgdFxuICAgIHZhbCB0b190cmVlX3VuY2hlY2tlZCA6ICgnaywgJ2QpIHQgLT4gKCdrLCAnZCkgdHJlZVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnaywgJ2QpIHQgPSAoJ2sgKiAnZCkgbGlzdFxuXG4gICAgbGV0IGVtcHR5ID0gW11cblxuICAgIGxldCBtYXhfa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCAoa2V5LCBfKSA6OiBfIC0+IFNvbWUga2V5XG4gICAgOztcblxuICAgIGxldCBhZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YSA9IChrZXksIGRhdGEpIDo6IHRcblxuICAgIGxldCB0b190cmVlX3VuY2hlY2tlZCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IEVtcHR5XG4gICAgICB8IFsgKGtleSwgZGF0YSkgXSAtPiBMZWFmIHsga2V5OyBkYXRhIH1cbiAgICAgIHwgbGlzdCAtPlxuICAgICAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbGlzdCBpblxuICAgICAgICBsZXQgbGlzdCA9IHJlZiBsaXN0IGluXG4gICAgICAgIGxldCByZWMgbG9vcCBsZW4gPVxuICAgICAgICAgIG1hdGNoIGxlbiwgIWxpc3Qgd2l0aFxuICAgICAgICAgIHwgMSwgKGtleSwgZGF0YSkgOjogdGFpbCAtPlxuICAgICAgICAgICAgbGlzdCA6PSB0YWlsO1xuICAgICAgICAgICAgTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgICAgICAgfCAyLCAoazIsIGQyKSA6OiAoazEsIGQxKSA6OiB0YWlsIC0+XG4gICAgICAgICAgICBsaXN0IDo9IHRhaWw7XG4gICAgICAgICAgICBOb2RlXG4gICAgICAgICAgICAgIHsgbGVmdCA9IEVtcHR5XG4gICAgICAgICAgICAgIDsga2V5ID0gazFcbiAgICAgICAgICAgICAgOyBkYXRhID0gZDFcbiAgICAgICAgICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBrMjsgZGF0YSA9IGQyIH1cbiAgICAgICAgICAgICAgOyBoZWlnaHQgPSAyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB8IDMsIChrMywgZDMpIDo6IChrMiwgZDIpIDo6IChrMSwgZDEpIDo6IHRhaWwgLT5cbiAgICAgICAgICAgIGxpc3QgOj0gdGFpbDtcbiAgICAgICAgICAgIE5vZGVcbiAgICAgICAgICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGsxOyBkYXRhID0gZDEgfVxuICAgICAgICAgICAgICA7IGtleSA9IGsyXG4gICAgICAgICAgICAgIDsgZGF0YSA9IGQyXG4gICAgICAgICAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gazM7IGRhdGEgPSBkMyB9XG4gICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfCBfLCBfIC0+XG4gICAgICAgICAgICBsZXQgbnIgPSBsZW4gLyAyIGluXG4gICAgICAgICAgICBsZXQgbmwgPSBsZW4gLSBuciAtIDEgaW5cbiAgICAgICAgICAgIGxldCByID0gbG9vcCBuciBpblxuICAgICAgICAgICAgKG1hdGNoICFsaXN0IHdpdGhcbiAgICAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgIHwgKGssIGQpIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgIGxpc3QgOj0gdGFpbDtcbiAgICAgICAgICAgICAgIGxldCBsID0gbG9vcCBubCBpblxuICAgICAgICAgICAgICAgY3JlYXRlIGwgayBkIHIpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgbGVuIFtAbm9udGFpbF1cbiAgICA7O1xuICBlbmRcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGxldCB7IHRyZWUgPSBidWlsZGVyOyBsZW5ndGggfSA9XG4gICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICBzZXFcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIEJ1aWxkX2luY3JlYXNpbmcuZW1wdHkgMClcbiAgICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGJ1aWxkZXI7IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgbWF0Y2ggQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IGJ1aWxkZXIgd2l0aFxuICAgICAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmVfa2V5IHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgICAgICByZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX2luY3JlYXNpbmdfc2VxdWVuY2U6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgd2l0aF9sZW5ndGhfZ2xvYmFsXG4gICAgICAgICAgICAgIChCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgYnVpbGRlciB+a2V5IH5kYXRhKVxuICAgICAgICAgICAgICAobGVuZ3RoICsgMSkpXG4gICAgICBpblxuICAgICAgT2sgKHdpdGhfbGVuZ3RoX2dsb2JhbCAoQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCBidWlsZGVyKSBsZW5ndGgpKVxuICA7O1xuXG4gICgqIExpa2UgW2JhbF0gYnV0IGFsbG93cyBhbnkgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiBbbF0gYW5kIFtyXS5cblxuICAgICBPKHxoZWlnaHQgbCAtIGhlaWdodCByfCkgKilcbiAgbGV0IHJlYyBqb2luIGwgayBkIHIgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gc2V0X21pbiBrIGQgclxuICAgIHwgXywgRW1wdHkgLT4gc2V0X21heCBsIGsgZFxuICAgIHwgTGVhZiB7IGtleSA9IGxrOyBkYXRhID0gbGQgfSwgXyAtPiBzZXRfbWluIGxrIGxkIChzZXRfbWluIGsgZCByKVxuICAgIHwgXywgTGVhZiB7IGtleSA9IHJrOyBkYXRhID0gcmQgfSAtPiBzZXRfbWF4IChzZXRfbWF4IGwgayBkKSByayByZFxuICAgIHwgKCBOb2RlIHsgbGVmdCA9IGxsOyBrZXkgPSBsazsgZGF0YSA9IGxkOyByaWdodCA9IGxyOyBoZWlnaHQgPSBsaCB9XG4gICAgICAsIE5vZGUgeyBsZWZ0ID0gcmw7IGtleSA9IHJrOyBkYXRhID0gcmQ7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IHJoIH0gKSAtPlxuICAgICAgbGV0IGwsIGssIGQsIHIgPVxuICAgICAgICAoKiBbYmFsXSByZXF1aXJlcyBoZWlnaHQgZGlmZmVyZW5jZSA8PSAzLiAqKVxuICAgICAgICBpZiBsaCA+IHJoICsgM1xuICAgICAgICAgICAoKiBbaGVpZ2h0IGxyID49IGhlaWdodCByXSxcbiAgICAgICAgICAgdGhlcmVmb3JlIFtoZWlnaHQgKGpvaW4gbHIgayBkIHIgLi4uKV0gaXMgW2hlaWdodCBybCArIDFdIG9yIFtoZWlnaHQgcmxdXG4gICAgICAgICAgIHRoZXJlZm9yZSB0aGUgaGVpZ2h0IGRpZmZlcmVuY2Ugd2l0aCBbbGxdIHdpbGwgYmUgPD0gMyAqKVxuICAgICAgICB0aGVuIGxsLCBsaywgbGQsIGpvaW4gbHIgayBkIHJcbiAgICAgICAgZWxzZSBpZiByaCA+IGxoICsgM1xuICAgICAgICB0aGVuIGpvaW4gbCBrIGQgcmwsIHJrLCByZCwgcnJcbiAgICAgICAgZWxzZSBsLCBrLCBkLCByXG4gICAgICBpblxuICAgICAgYmFsIGwgayBkIHJcbiAgOztcblxuICBsZXRbQGlubGluZV0gcmVjIHNwbGl0X2dlbiB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBkIH0gLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIEVtcHR5LCBTb21lIChrLCBkKSwgRW1wdHlcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgdFxuICAgICAgZWxzZSB0LCBOb25lLCBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIGwsIFNvbWUgKGssIGQpLCByXG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIG1heWJlLCBsciA9IHNwbGl0X2dlbiBsIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGxsLCBtYXliZSwgam9pbiBsciBrIGQgcilcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmwsIG1heWJlLCByciA9IHNwbGl0X2dlbiByIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGpvaW4gbCBrIGQgcmwsIG1heWJlLCBycilcbiAgOztcblxuICBsZXQgc3BsaXQgdCB4IH5jb21wYXJlX2tleSA9IHNwbGl0X2dlbiB0IHggfmNvbXBhcmVfa2V5OihmdW4geSAtPiBjb21wYXJlX2tleSB4IHkpXG5cbiAgKCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZWFsbHkgcmVpbnNlcnQgW3hdLCBidXQganVzdCBhcnJhbmdlcyBzbyB0aGF0IFtzcGxpdF1cbiAgICAgcHJvZHVjZXMgdGhlIGVxdWl2YWxlbnQgdHJlZSBpbiB0aGUgZmlyc3QgcGxhY2UuICopXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byB4IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGxlZnQsIGJvdW5kYXJ5X29wdCwgcmlnaHQgPVxuICAgICAgc3BsaXRfZ2VuXG4gICAgICAgIHRcbiAgICAgICAgeFxuICAgICAgICB+Y29tcGFyZV9rZXk6XG4gICAgICAgICAgKG1hdGNoIGludG8gd2l0aFxuICAgICAgICAgICB8IGBMZWZ0IC0+XG4gICAgICAgICAgICAgZnVuIHkgLT5cbiAgICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSB4IHkgd2l0aFxuICAgICAgICAgICAgICAgIHwgMCAtPiAxXG4gICAgICAgICAgICAgICAgfCByZXMgLT4gcmVzKVxuICAgICAgICAgICB8IGBSaWdodCAtPlxuICAgICAgICAgICAgIGZ1biB5IC0+XG4gICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgeCB5IHdpdGhcbiAgICAgICAgICAgICAgICB8IDAgLT4gLTFcbiAgICAgICAgICAgICAgICB8IHJlcyAtPiByZXMpKVxuICAgIGluXG4gICAgYXNzZXJ0IChPcHRpb24uaXNfbm9uZSBib3VuZGFyeV9vcHQpO1xuICAgIGxlZnQsIHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHNwbGl0X3JhbmdlXG4gICAgdFxuICAgIH4obG93ZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgIH4odXBwZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgIH5jb21wYXJlX2tleVxuICAgID1cbiAgICBpZiBNYXliZV9ib3VuZC5ib3VuZHNfY3Jvc3NlZFxuICAgICAgICAgfmNvbXBhcmU6Y29tcGFyZV9rZXlcbiAgICAgICAgIH5sb3dlcjpsb3dlcl9ib3VuZFxuICAgICAgICAgfnVwcGVyOnVwcGVyX2JvdW5kXG4gICAgdGhlbiBlbXB0eSwgZW1wdHksIGVtcHR5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVmdCwgbWlkX2FuZF9yaWdodCA9XG4gICAgICAgIG1hdGNoIGxvd2VyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gZW1wdHksIHRcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxldCBtaWQsIHJpZ2h0ID1cbiAgICAgICAgbWF0Y2ggdXBwZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBtaWRfYW5kX3JpZ2h0LCBlbXB0eVxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPlxuICAgICAgICAgIHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZWZ0LCBtaWQsIHJpZ2h0KVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBTb21lIGQgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkIGVsc2UgZmluZCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGRhdGEgPSBkYXRhIDo6IE9wdGlvbi52YWx1ZSAoZmluZCB0IGtleSB+Y29tcGFyZV9rZXkpIH5kZWZhdWx0OltdIGluXG4gICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB4IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGwgLT4gbFxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IGlmX25vdF9mb3VuZCBrZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIHJhaXNlIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJNYXAuZmluZF9leG46IG5vdCBmb3VuZFwiOyBzZXhwX29mX2tleSBrZXkgXSkpXG4gICAgaW5cbiAgICBsZXQgcmVjIGZpbmRfZXhuIHQgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIGQgZWxzZSBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBkIGVsc2UgZmluZF9leG4gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IHggfmNvbXBhcmVfa2V5ID0gT3B0aW9uLmlzX3NvbWUgKGZpbmQgdCB4IH5jb21wYXJlX2tleSlcblxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBkIH0gLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IGRhdGEgPSBkOyByaWdodCA9IF87IGhlaWdodCA9IF8gfSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfIH0gLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSBfIH0gLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgZGF0YSA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPiByXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHg7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgYmFsIChyZW1vdmVfbWluX2VsdCBsKSB4IGQgclxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBtYXhfZWx0IGxvd2VyX3BhcnQsIG1pbl9lbHQgdXBwZXJfcGFydCB3aXRoXG4gICAgfCBOb25lLCBfIC0+IGBPayB1cHBlcl9wYXJ0XG4gICAgfCBfLCBOb25lIC0+IGBPayBsb3dlcl9wYXJ0XG4gICAgfCBTb21lIChtYXhfbG93ZXIsIF8pLCBTb21lIChtaW5fdXBwZXIsIHYpIHdoZW4gY29tcGFyZV9rZXkgbWF4X2xvd2VyIG1pbl91cHBlciA8IDAgLT5cbiAgICAgIGxldCB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluID0gcmVtb3ZlX21pbl9lbHQgdXBwZXJfcGFydCBpblxuICAgICAgYE9rIChqb2luIGxvd2VyX3BhcnQgbWluX3VwcGVyIHYgdXBwZXJfcGFydF93aXRob3V0X21pbilcbiAgICB8IF8gLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgPVxuICAgICgqIFRoaXMgYXNzdW1lcyB0aGF0IG1pbiA8PSBtYXgsIHdoaWNoIGlzIGNoZWNrZWQgYnkgdGhlIG91dGVyIGZ1bmN0aW9uLiAqKVxuICAgIGxldCByZWMgZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbml0XG4gICAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgbWluIDwgMCB8fCBjb21wYXJlX2tleSBrIG1heCA+IDBcbiAgICAgICAgdGhlbiAoKiBrIDwgbWluIHx8IGsgPiBtYXggKilcbiAgICAgICAgICBpbml0XG4gICAgICAgIGVsc2UgZiB+a2V5OmsgfmRhdGE6ZCBpbml0XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gazsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGxldCBjX21pbiA9IGNvbXBhcmVfa2V5IGsgbWluIGluXG4gICAgICAgIGlmIGNfbWluIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA8IG1pbiwgdGhlbiB0aGlzIG5vZGUgYW5kIGl0cyBsZWZ0IGJyYW5jaCBhcmUgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSBpZiBjX21pbiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPSBtaW4sIHRoZW4gdGhpcyBub2RlJ3MgbGVmdCBicmFuY2ggaXMgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdDooZiB+a2V5OmsgfmRhdGE6ZCBpbml0KSB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogayA+IG1pbiAqKVxuICAgICAgICAgIGxldCB6ID0gZ28gbCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgbGV0IGNfbWF4ID0gY29tcGFyZV9rZXkgayBtYXggaW5cbiAgICAgICAgICAoKiBpZiBrID4gbWF4LCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgaWYgY19tYXggPiAwXG4gICAgICAgICAgdGhlbiB6XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgeiA9IGYgfmtleTprIH5kYXRhOmQgeiBpblxuICAgICAgICAgICAgKCogaWYgayA9IG1heCwgdGhlbiB3ZSBmb2xkIGluIHRoaXMgb25lIGxhc3QgdmFsdWUgYW5kIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICAgIGlmIGNfbWF4ID0gMCB0aGVuIHogZWxzZSBnbyByIH5taW4gfm1heCB+aW5pdDp6IH5mIH5jb21wYXJlX2tleSkpXG4gICAgaW5cbiAgICBmdW4gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSBtaW4gbWF4IDw9IDAgdGhlbiBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgZWxzZSBpbml0XG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5yZXZcbiAgICAgIChmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgICAgdFxuICAgICAgICAgfm1pblxuICAgICAgICAgfm1heFxuICAgICAgICAgfmluaXQ6W11cbiAgICAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBsIC0+IChrZXksIGRhdGEpIDo6IGwpXG4gICAgICAgICB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uczpcbiAgICAgLSBhbGwgZWxlbWVudHMgaW4gdDEgYXJlIGxlc3MgdGhhbiBlbGVtZW50cyBpbiB0MlxuICAgICAtIHxoZWlnaHQodDEpIC0gaGVpZ2h0KHQyKXwgPD0gMiAqKVxuICBsZXQgY29uY2F0X3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIHNpbWlsYXIgdG8gW2NvbmNhdF91bmNoZWNrZWRdLCBhbmQgYmFsYW5jZXMgdHJlZXMgb2YgYXJiaXRyYXJ5IGhlaWdodCBkaWZmZXJlbmNlcyAqKVxuICBsZXQgY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZSB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gXyB9IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gd2l0aF9sZW5ndGggRW1wdHkgKGxlbmd0aCAtIDEpIGVsc2Ugd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gd2l0aF9sZW5ndGggKGNvbmNhdF91bmNoZWNrZWQgbCByKSAobGVuZ3RoIC0gMSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbCwgciwgbGVuZ3RoJyA9XG4gICAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCB7IHRyZWUgPSBsOyBsZW5ndGggPSBsZW5ndGgnIH0gPSByZW1vdmUgbCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICBsLCByLCBsZW5ndGgnKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCA9IGxlbmd0aCcgfSA9IHJlbW92ZSByIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICAgIGwsIHIsIGxlbmd0aCcpXG4gICAgICAgIGluXG4gICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCdcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoJylcbiAgOztcblxuICBsZXQgcmVjIGNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgKG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoIEVtcHR5IGxlbmd0aFxuICAgICAgIHwgU29tZSBkYXRhIC0+IHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5OyBkYXRhIH0pIChsZW5ndGggKyAxKSlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGggRW1wdHkgKGxlbmd0aCAtIDEpXG4gICAgICAgIHwgU29tZSBkJyAtPiB3aXRoX2xlbmd0aCAoTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkJyB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGwnOyBsZW5ndGggfSA9IGNoYW5nZSBFbXB0eSBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBsJyB0XG4gICAgICAgIHRoZW4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICAgICAgZWxzZSB3aXRoX2xlbmd0aCAoYmFsIGwnIHYgZCBFbXB0eSkgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB7IHRyZWUgPSByJzsgbGVuZ3RoIH0gPSBjaGFuZ2UgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgcicgdFxuICAgICAgICB0aGVuIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgICAgIGVsc2Ugd2l0aF9sZW5ndGggKGJhbCBFbXB0eSB2IGQgcicpIGxlbmd0aClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGggKGNvbmNhdF91bmNoZWNrZWQgbCByKSAobGVuZ3RoIC0gMSlcbiAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXk7IGRhdGE7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGwnOyBsZW5ndGggfSA9IGNoYW5nZSBsIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIGwnIGxcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgbCcgdiBkIHIpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcic7IGxlbmd0aCB9ID0gY2hhbmdlIHIga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgcicgclxuICAgICAgICB0aGVuIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgICAgIGVsc2Ugd2l0aF9sZW5ndGggKGJhbCBsIHYgZCByJykgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCByZWMgdXBkYXRlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICBsZXQgZGF0YSA9IGYgTm9uZSBpblxuICAgICAgd2l0aF9sZW5ndGggKExlYWYgeyBrZXk7IGRhdGEgfSkgKGxlbmd0aCArIDEpXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgZCcgPSBmIChTb21lIGQpIGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQnIH0pIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPSB1cGRhdGUgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgRW1wdHkpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcjsgbGVuZ3RoIH0gPSB1cGRhdGUgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgRW1wdHkgdiBkIHIpIGxlbmd0aClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBkYXRhID0gZiAoU29tZSBkKSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXk7IGRhdGE7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID0gdXBkYXRlIGwga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggfSA9IHVwZGF0ZSByIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aClcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBjaGFuZ2UgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgfCBTb21lIChbXSB8IFsgXyBdKSAtPiBOb25lXG4gICAgICB8IFNvbWUgKF8gOjogKF8gOjogXyBhcyBub25fZW1wdHlfdGFpbCkpIC0+IFNvbWUgbm9uX2VtcHR5X3RhaWwpXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyX2tleXMgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBfIH0gLT4gZiB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaXRlcl9rZXlzIH5mIGw7XG4gICAgICBmIHY7XG4gICAgICBpdGVyX2tleXMgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlciB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gXzsgZGF0YSA9IGQgfSAtPiBmIGRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBpdGVyIH5mIGw7XG4gICAgICBmIGQ7XG4gICAgICBpdGVyIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBpdGVyaSB+ZiBsO1xuICAgICAgZiB+a2V5OnYgfmRhdGE6ZDtcbiAgICAgIGl0ZXJpIH5mIHJcbiAgOztcblxuICBsZXQgaXRlcmlfdW50aWwgPVxuICAgIGxldCByZWMgaXRlcmlfdW50aWxfbG9vcCB0IH5mIDogQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZVxuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIChtYXRjaCBpdGVyaV91bnRpbF9sb29wIH5mIGwgd2l0aFxuICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgIHwgQ29udGludWUgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgICAgIHwgQ29udGludWUgLT4gaXRlcmlfdW50aWxfbG9vcCB+ZiByKSlcbiAgICBpblxuICAgIGZ1biB0IH5mIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQub2ZfY29udGludWVfb3Jfc3RvcCAoaXRlcmlfdW50aWxfbG9vcCB0IH5mKVxuICA7O1xuXG4gIGxldCByZWMgbWFwIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZiBkIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgbCcgPSBtYXAgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICBsZXQgcicgPSBtYXAgfmYgciBpblxuICAgICAgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gdjsgZGF0YSA9IGQnOyByaWdodCA9IHInOyBoZWlnaHQgPSBoIH1cbiAgOztcblxuICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgbCcgPSBtYXBpIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IG1hcGkgfmYgciBpblxuICAgICAgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gdjsgZGF0YSA9IGQnOyByaWdodCA9IHInOyBoZWlnaHQgPSBoIH1cbiAgOztcblxuICBsZXQgcmVjIGZvbGQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGZvbGQgfmYgciB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2xvb3AgdCB+YWNjIH5mIDogKF8sIF8pIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY1xuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9sb29wIGwgfmFjYyB+ZiB3aXRoXG4gICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgYWNjIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBmb2xkX3VudGlsX2xvb3AgciB+YWNjIH5mKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfbG9vcCB0IH5hY2M6aW5pdCB+ZiB3aXRoXG4gICAgfCBDb250aW51ZSBhY2MgLT4gZmluaXNoIGFjYyBbQG5vbnRhaWxdXG4gICAgfCBTdG9wIHN0b3AgLT4gc3RvcFxuICA7O1xuXG4gIGxldCByZWMgZm9sZF9yaWdodCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJfbWFwaSB0IH5mIH5sZW4gPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgfCBTb21lIG5ld19kYXRhIC0+IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gbmV3X2RhdGEgfVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICBFbXB0eSlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBuZXdfZGF0YSA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IGZpbHRlcl9tYXBpIHIgfmYgfmxlbiBpblxuICAgICAgKG1hdGNoIG5ld19kYXRhIHdpdGhcbiAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT4gam9pbiBsJyB2IG5ld19kYXRhIHInXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBkZWNyIGxlbjtcbiAgICAgICAgIGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJpIHQgfmYgfmxlbiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICB8IHRydWUgLT4gdFxuICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgIGRlY3IgbGVuO1xuICAgICAgICAgRW1wdHkpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGwnID0gZmlsdGVyaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBrZWVwX2RhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBmaWx0ZXJpIHIgfmYgfmxlbiBpblxuICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgIHRoZW4gdFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBqb2luIGwnIHYgZCByJ1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICAgY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgOztcblxuICBsZXQgZmlsdGVyIHQgfmYgfmxlbiA9IGZpbHRlcmkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiB+bGVuID0gZmlsdGVyaSB0IH5sZW4gfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiB+bGVuID0gZmlsdGVyX21hcGkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgICBsZXQgdDEsIHQyID1cbiAgICAgIGZvbGRcbiAgICAgICAgdFxuICAgICAgICB+aW5pdDooQnVpbGRfaW5jcmVhc2luZy5lbXB0eSwgQnVpbGRfaW5jcmVhc2luZy5lbXB0eSlcbiAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICh0MSwgdDIpIC0+XG4gICAgICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgeCAtPiBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdDEgfmtleSB+ZGF0YTp4LCB0MlxuICAgICAgICB8IFNlY29uZCB5IC0+IHQxLCBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdDIgfmtleSB+ZGF0YTp5KVxuICAgIGluXG4gICAgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MSwgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICAgIGxldCByZWMgbG9vcCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgfCB0cnVlIC0+IHQsIEVtcHR5XG4gICAgICAgICB8IGZhbHNlIC0+IEVtcHR5LCB0KVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBsZXQgbCd0LCBsJ2YgPSBsb29wIGwgfmYgaW5cbiAgICAgICAgbGV0IGtlZXBfZGF0YV90ID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgICBsZXQgcid0LCByJ2YgPSBsb29wIHIgfmYgaW5cbiAgICAgICAgbGV0IG1rIGwnIGtlZXBfZGF0YSByJyA9XG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgICAgICB0aGVuIHRcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgICAgICB8IHRydWUgLT4gam9pbiBsJyB2IGQgcidcbiAgICAgICAgICAgIHwgZmFsc2UgLT4gY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgICAgICAgaW5cbiAgICAgICAgbWsgbCd0IGtlZXBfZGF0YV90IHIndCwgbWsgbCdmIChub3Qga2VlcF9kYXRhX3QpIHInZlxuICAgIGluXG4gICAgbG9vcCB0IH5mXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnaywgJ3YsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnayAqICd2ICogKCdrLCAndikgdHJlZSAqICgnaywgJ3YsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyB0IChlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGNvbnMgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCB0IChlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGNvbnNfcmlnaHQgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl90cmVlIHRyZWUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9IGNvbnMgdHJlZSBFbmRcbiAgICBsZXQgb2ZfdHJlZV9yaWdodCB0cmVlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHRyZWUgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RlcF9kZWVwZXJfZXhuIHRyZWUgZSA9XG4gICAgICBtYXRjaCB0cmVlIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IEVtcHR5LCBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT4gbCwgTW9yZSAodiwgZCwgciwgZSlcbiAgICA7O1xuXG4gICAgKCogW2Ryb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyXSBkcm9wcyB0aGUgbGFyZ2VzdCBwaHlzaWNhbGx5LWVxdWFsXG4gICAgICAgcHJlZml4IG9mIHRyZWUxIGFuZCB0cmVlMiB0aGF0IHRoZXkgc2hhcmUsIGFuZCB0aGVuIHByZXBlbmRzIHRoZSByZW1haW5pbmcgZGF0YVxuICAgICAgIGludG8gYWNjMSBhbmQgYWNjMiwgcmVzcGVjdGl2ZWx5LlxuICAgICAgIFRoaXMgY2FuIGJlIGFzeW1wdG90aWNhbGx5IGZhc3RlciB0aGFuIFtjb25zXSBldmVuIGlmIGl0IHNraXBzIGEgc21hbGwgcHJvcG9ydGlvblxuICAgICAgIG9mIHRoZSB0cmVlIGJlY2F1c2UgW2NvbnNdIGlzIGFsd2F5cyBPKGxvZyhuKSkgaW4gdGhlIHNpemUgb2YgdGhlIHRyZWUsIHdoaWxlXG4gICAgICAgdGhpcyBmdW5jdGlvbiBpcyBPKGxvZyhuL20pKSB3aGVyZSBbbV0gaXMgdGhlIHNpemUgb2YgdGhlIHBhcnQgb2YgdGhlIHRyZWUgdGhhdFxuICAgICAgIGlzIHNraXBwZWQuICopXG4gICAgbGV0IHJlYyBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICB0aGVuIGFjYzEsIGFjYzJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaDIgPSBoZWlnaHQgdHJlZTIgaW5cbiAgICAgICAgbGV0IGgxID0gaGVpZ2h0IHRyZWUxIGluXG4gICAgICAgIGlmIGgyID0gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBsZXQgdHJlZTIsIGFjYzIgPSBzdGVwX2RlZXBlcl9leG4gdHJlZTIgYWNjMiBpblxuICAgICAgICAgIGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyKVxuICAgICAgICBlbHNlIGlmIGgyID4gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUyLCBhY2MyID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUyIGFjYzIgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMikpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2RhdGEgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGUxLCBlMiA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggcjEgZTEgcjIgZTIgaW5cbiAgICAgICAgICAgICAgbG9vcCBlMSBlMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgZGF0YV9lcXVhbCB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IHRydWVcbiAgICAgICAgfCBFbmQsIF8gfCBfLCBFbmQgLT4gZmFsc2VcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGNvbXBhcmVfa2V5IHYxIHYyID0gMFxuICAgICAgICAgICYmIGRhdGFfZXF1YWwgZDEgZDJcbiAgICAgICAgICAmJlxuICAgICAgICAgIGxldCBlMSwgZTIgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHIxIGUxIHIyIGUyIGluXG4gICAgICAgICAgbG9vcCBlMSBlMlxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBmb2xkIH5pbml0IH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+IGluaXRcbiAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBsZXQgbmV4dCA9IGYgfmtleSB+ZGF0YSBpbml0IGluXG4gICAgICAgIGZvbGQgKGNvbnMgdHJlZSBlbnVtKSB+aW5pdDpuZXh0IH5mXG4gICAgOztcblxuICAgIGxldCBmb2xkMiBjb21wYXJlX2tleSB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgY3VyciA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gY3VyclxuICAgICAgICB8IEVuZCwgXyAtPlxuICAgICAgICAgIGZvbGQgdDIgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYFJpZ2h0IGRhdGEpIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgfCBfLCBFbmQgLT5cbiAgICAgICAgICBmb2xkIHQxIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBMZWZ0IGRhdGEpIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICB8IE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSwgTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgQm90aCAodjEsIHYyKSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgTGVmdCB2MSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIgbmV4dClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsyIH5kYXRhOihgUmlnaHQgdjIpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBpbml0IFtAbm9udGFpbF1cbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrZXksIGBSaWdodCBkYXRhOyBzdGF0ZSA9IEVuZCwgY29ucyB0cmVlIGVudW0gfVxuICAgICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGtleSwgYExlZnQgZGF0YTsgc3RhdGUgPSBjb25zIHRyZWUgZW51bSwgRW5kIH1cbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgZW51bTEgdHJlZTIgZW51bTIgaW5cbiAgICAgICAgICAgIGlmIGRhdGFfZXF1YWwgdjEgdjJcbiAgICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Ta2lwIHsgc3RhdGUgPSBuZXh0X3N0YXRlIH1cbiAgICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazEsIGBVbmVxdWFsICh2MSwgdjIpOyBzdGF0ZSA9IG5leHRfc3RhdGUgfSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGsxLCBgTGVmdCB2MTsgc3RhdGUgPSBjb25zIHRyZWUxIGVudW0xLCByaWdodCB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazIsIGBSaWdodCB2Mjsgc3RhdGUgPSBsZWZ0LCBjb25zIHRyZWUyIGVudW0yIH1cbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDooZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0MSBFbmQgdDIgRW5kKSB+ZjpzdGVwXG4gICAgOztcblxuICAgIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICAgIGxldCByZWMgbG9vcCBsZWZ0IHJpZ2h0IGFjYyA9XG4gICAgICAgIG1hdGNoIGxlZnQsIHJpZ2h0IHdpdGhcbiAgICAgICAgfCBFbmQsIGVudW0gLT5cbiAgICAgICAgICBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IGVudW0sIEVuZCAtPlxuICAgICAgICAgIGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGlmIGRhdGFfZXF1YWwgdjEgdjIgdGhlbiBhY2MgZWxzZSBmIGFjYyAoazEsIGBVbmVxdWFsICh2MSwgdjIpKSBpblxuICAgICAgICAgICAgbGV0IGVudW0xLCBlbnVtMiA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgZW51bTEgdHJlZTIgZW51bTIgaW5cbiAgICAgICAgICAgIGxvb3AgZW51bTEgZW51bTIgYWNjKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrMSB2MSBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgcmlnaHQgYWNjKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgazIgdjIgaW5cbiAgICAgICAgICAgIGxvb3AgbGVmdCAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgaW5cbiAgICAgIGxldCBsZWZ0LCByaWdodCA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdDEgRW5kIHQyIEVuZCBpblxuICAgICAgbG9vcCBsZWZ0IHJpZ2h0IGluaXQgW0Bub250YWlsXVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+XG4gICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGssIHY7IHN0YXRlID0gRW51bS5jb25zIHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlIHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT5cbiAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gaywgdjsgc3RhdGUgPSBFbnVtLmNvbnNfcmlnaHQgdCBlIH1cbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWVfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICBjb21wYXJhdG9yXG4gICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nX2tleSlcbiAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfa2V5IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIChrZXksIGRhdGEpIC0+IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXlcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2xlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIGxldCBlMSwgZTIgPSBFbnVtLmRyb3BfcGh5c19lcXVhbF9wcmVmaXggdDEgRW5kIHQyIEVuZCBpblxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgZTEgZTJcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBsZXQgZTEsIGUyID0gRW51bS5kcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQgaW5cbiAgICBFbnVtLmVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSBlMSBlMlxuICA7O1xuXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDJcbiAgICAgIGNvbXBhcmVfa2V5XG4gICAgICAoRW51bS5vZl90cmVlIHQxKVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MilcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKCkgLT4gZiB+a2V5IH5kYXRhKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMiBjb21wYXJlX2tleSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKSB+ZiB+aW5pdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICgqIFtFbnVtLmZvbGRfZGlmZnNdIGlzIGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgaXMgY29uc2lkZXJhYmx5XG4gICAgICAgc2xvd2VyLCBhcyB3ZSBoYXZlIHRvIGFsbG9jYXRlIHF1aXRlIGEgbG90IG9mIHN0YXRlIHRvIHRyYWNrIGVudW1lcmF0aW9uIG9mIGEgdHJlZS5cbiAgICAgICBBdm9pZCBpZiB3ZSBjYW4uXG4gICAgKilcbiAgICBsZXQgc2xvdyB4IHkgfmluaXQgPSBFbnVtLmZvbGRfc3ltbWV0cmljX2RpZmYgeCB5IH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+ZiB+aW5pdCBpblxuICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICBsZXQgZGVsdGEgYWNjIGsgdiB2JyA9IGlmIGRhdGFfZXF1YWwgdiB2JyB0aGVuIGFjYyBlbHNlIGYgYWNjIChrLCBgVW5lcXVhbCAodiwgdicpKSBpblxuICAgICgqIElmIHR3byB0cmVlcyBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBhdCB0aGUgcm9vdCAoYW5kIHRoZSBzYW1lIGtleSwgaWYgdGhleSdyZVxuICAgICAgIFtOb2RlXXMpIHdlIGNhbiB0cml2aWFsbHkgZGlmZiBlYWNoIHN1YnBhcnQgaW4gb2J2aW91cyB3YXlzLiAqKVxuICAgIGxldCByZWMgbG9vcCB0IHQnIGFjYyA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHQgdCdcbiAgICAgIHRoZW4gYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCwgdCcgd2l0aFxuICAgICAgICB8IEVtcHR5LCBuZXdfdmFscyAtPlxuICAgICAgICAgIGZvbGQgbmV3X3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IG9sZF92YWxzLCBFbXB0eSAtPlxuICAgICAgICAgIGZvbGQgb2xkX3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gdiB9LCBMZWFmIHsga2V5ID0gayc7IGRhdGEgPSB2JyB9IC0+XG4gICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IGsgaycgd2l0aFxuICAgICAgICAgICB8IHggd2hlbiB4ID0gMCAtPiBkZWx0YSBhY2MgayB2IHYnXG4gICAgICAgICAgIHwgeCB3aGVuIHggPCAwIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgayB2IGluXG4gICAgICAgICAgICAgYWRkIGFjYyBrJyB2J1xuICAgICAgICAgICB8IF8gKCogd2hlbiB4ID4gMCAqKSAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsnIHYnIGluXG4gICAgICAgICAgICAgcmVtb3ZlIGFjYyBrIHYpXG4gICAgICAgIHwgKCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF8gfVxuICAgICAgICAgICwgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gayc7IGRhdGEgPSB2JzsgcmlnaHQgPSByJzsgaGVpZ2h0ID0gXyB9IClcbiAgICAgICAgICB3aGVuIGNvbXBhcmVfa2V5IGsgaycgPSAwIC0+XG4gICAgICAgICAgbGV0IGFjYyA9IGxvb3AgbCBsJyBhY2MgaW5cbiAgICAgICAgICBsZXQgYWNjID0gZGVsdGEgYWNjIGsgdiB2JyBpblxuICAgICAgICAgIGxvb3AgciByJyBhY2NcbiAgICAgICAgKCogT3VyIHJvb3RzIGFyZW4ndCB0aGUgc2FtZSBrZXkuIEZhbGxiYWNrIHRvIHRoZSBzbG93IG1vZGUuIFRyZWVzIHdpdGggc21hbGxcbiAgICAgICAgICAgZGlmZnMgd2lsbCBvbmx5IGRvIHRoaXMgb24gdmVyeSBzbWFsbCBwYXJ0cyBvZiB0aGUgdHJlZSAoaG9wZWZ1bGx5IC0gaWYgdGhlXG4gICAgICAgICAgIG92ZXJhbGwgcm9vdCBpcyByZWJhbGFuY2VkLCB3ZSdsbCBlYXQgdGhlIHdob2xlIGNvc3QsIHVuZm9ydHVuYXRlbHkuKSAqKVxuICAgICAgICB8IE5vZGUgXywgTm9kZSBfIHwgTm9kZSBfLCBMZWFmIF8gfCBMZWFmIF8sIE5vZGUgXyAtPiBzbG93IHQgdCcgfmluaXQ6YWNjKVxuICAgIGluXG4gICAgbG9vcCB0MSB0MiBpbml0IFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgc3RhdGUgLT4gaGFzaF9mb2xkX2RhdGEgKGhhc2hfZm9sZF9rZXkgc3RhdGUga2V5KSBkYXRhKVxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpfIGxpc3QgLT4ga2V5IDo6IGxpc3QpIHQgfmluaXQ6W11cbiAgbGV0IGRhdGEgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIHQgfmluaXQ6W11cblxuICBtb2R1bGUgdHlwZSBGb2xkYWJsZSA9IHNpZ1xuICAgIHZhbCBuYW1lIDogc3RyaW5nXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSAtPiAnYWNjKSAtPiAnYWNjXG4gIGVuZFxuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gb2ZfZm9sZGFibGUnIH5mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgKGZvbGQgW0BpbmxpbmVkIGhpbnRdKVxuICAgICAgZm9sZGFibGVcbiAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgIH5mOihmdW4geyB0cmVlID0gYWNjdW07IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICBsZXQgcHJldl9kYXRhID1cbiAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGluaXRcbiAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldlxuICAgICAgaW5cbiAgICAgIGxldCBkYXRhID0gZiBwcmV2X2RhdGEgZGF0YSBpblxuICAgICAgKHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICA7O1xuXG4gIG1vZHVsZSBPZl9mb2xkYWJsZSAoTSA6IEZvbGRhYmxlKSA9IHN0cnVjdFxuICAgIGxldCBvZl9mb2xkYWJsZV9mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBvZl9mb2xkYWJsZScgfmZvbGQ6TS5mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfcmVkdWNlIGZvbGRhYmxlIH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGRcbiAgICAgICAgZm9sZGFibGVcbiAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGFjY3VtOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgbmV3X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YVxuICAgICAgICBpblxuICAgICAgICAoc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YTpuZXdfZGF0YSB+Y29tcGFyZV9rZXkgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBtYXAgPVxuICAgICAgICAgIE0uZm9sZFxuICAgICAgICAgICAgZm9sZGFibGVcbiAgICAgICAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgICAgICAgIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbGVuZ3RoJyB9IGFzIGFjYykgPVxuICAgICAgICAgICAgICBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJ1xuICAgICAgICAgICAgdGhlbiByLnJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KVxuICAgICAgICAgICAgZWxzZSBnbG9iYWxpemUgYWNjIFtAbm9udGFpbF0pXG4gICAgICAgIGluXG4gICAgICAgIGBPayBtYXApXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9vcl9lcnJvciBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgICAgICAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9vcl9lcnJvcjogZHVwbGljYXRlIGtleVwiKVxuICAgICAgICAgIGtleVxuICAgICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9leG4gZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4geFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX2V4bjogZHVwbGljYXRlIGtleVwiKSBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICA7O1xuXG4gICAgKCogUmV2ZXJzZSB0aGUgaW5wdXQsIHRoZW4gZm9sZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFRoZSByZXN1bHRpbmcgbWFwIHVzZXMgdGhlIGZpcnN0XG4gICAgICAgaW5zdGFuY2Ugb2YgZWFjaCBrZXkgZnJvbSB0aGUgaW5wdXQgbGlzdC4gVGhlIHJlbGF0aXZlIG9yZGVyaW5nIG9mIGVsZW1lbnRzIGluIGVhY2hcbiAgICAgICBvdXRwdXQgbGlzdCBpcyB0aGUgc2FtZSBhcyBpbiB0aGUgaW5wdXQgbGlzdC4gKilcbiAgICBsZXQgb2ZfZm9sZGFibGVfbXVsdGkgZm9sZGFibGUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGxldCBhbGlzdCA9IE0uZm9sZCBmb2xkYWJsZSB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIGluXG4gICAgICBvZl9mb2xkYWJsZScgYWxpc3QgfmZvbGQ6TGlzdC5mb2xkIH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgfmNvbXBhcmVfa2V5XG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2FsaXN0ID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgIGxldCBuYW1lID0gXCJhbGlzdFwiXG5cbiAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICBsZXQgZm9sZCA9IExpc3QuZm9sZFxuICBlbmQpXG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX2FsaXN0ID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX2FsaXN0X2V4biA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2V4blxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9tdWx0aVxuXG4gIG1vZHVsZSBPZl9zZXF1ZW5jZSA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICBsZXQgbmFtZSA9IFwic2VxdWVuY2VcIlxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgbGV0IGZvbGQgPSBTZXF1ZW5jZS5mb2xkXG4gIGVuZClcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2Zfc2VxdWVuY2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZVxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZXhuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX211bHRpXG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXkgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgbGV0IG1hcCA9XG4gICAgICAgIExpc3QuZm9sZFxuICAgICAgICAgIGxpc3RcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSBkYXRhIC0+XG4gICAgICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbmV3X2xlbmd0aCB9IGFzIGFjYykgPVxuICAgICAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgbGVuZ3RoID0gbmV3X2xlbmd0aFxuICAgICAgICAgIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSlcbiAgICAgICAgICBlbHNlIGdsb2JhbGl6ZSBhY2MgW0Bub250YWlsXSlcbiAgICAgIGluXG4gICAgICBgT2sgbWFwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggb2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBPcl9lcnJvci5lcnJvclxuICAgICAgICBcIk1hcC5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yOiBkdXBsaWNhdGUga2V5XCJcbiAgICAgICAga2V5XG4gICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIGxpc3QgfmdldF9rZXkgfmNvbXBhcmF0b3IgPVxuICAgIG1hdGNoIG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHggLT4geFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfbGlzdF93aXRoX2tleV9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsaXN0ID0gTGlzdC5yZXYgbGlzdCBpblxuICAgIExpc3QuZm9sZCBsaXN0IH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMCkgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSBkYXRhIC0+XG4gICAgICBsZXQga2V5ID0gZ2V0X2tleSBkYXRhIGluXG4gICAgICAodXBkYXRlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW4gb3B0aW9uIC0+XG4gICAgICAgICBsZXQgbGlzdCA9IE9wdGlvbi52YWx1ZSBvcHRpb24gfmRlZmF1bHQ6W10gaW5cbiAgICAgICAgIGRhdGEgOjogbGlzdClcbiAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIGxpc3QgfmdldF9rZXkgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgIHwgTm9uZSAtPiBmIGluaXQgZGF0YVxuICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGEpXG4gICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIGxpc3QgfmdldF9rZXkgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YSlcbiAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZm9yX2FsbCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgbm90IChmIGRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIG5vdCAoZiB+a2V5IH5kYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBmIGRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gIDs7XG5cbiAgbGV0IHN1bSAodHlwZSBhKSAobW9kdWxlIE0gOiBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6TS56ZXJvIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBNLiggKyApIChmIGRhdGEpIGFjYykgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzdW1pICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBNLiggKyApIChmIH5rZXkgfmRhdGEpIGFjYykgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCA/KGtleV9vcmRlciA9IGBJbmNyZWFzaW5nKSB0ID1cbiAgICBtYXRjaCBrZXlfb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT4gZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gICAgfCBgRGVjcmVhc2luZyAtPiBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZWx0cyA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46KGxlbmd0aCB0MSArIGxlbmd0aCB0MikgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlcjIgdDEgdDIgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YTp2YWx1ZXMgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB2YWx1ZXMgd2l0aFxuICAgICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICAgIFVuaWZvcm1fYXJyYXkuc2V0IGVsdHMgIWkgKGtleSwgdmFsdWUpO1xuICAgICAgICBpbmNyIGlcbiAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgbGV0IGxlbiA9ICFpIGluXG4gICAgbGV0IGdldCBpID0gVW5pZm9ybV9hcnJheS5nZXQgZWx0cyBpIGluXG4gICAgbGV0IHRyZWUgPSBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mOmdldCBpblxuICAgIHdpdGhfbGVuZ3RoIHRyZWUgbGVuXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCA9XG4gICAgbGV0IG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aF9sYXJnZSB0X2xhcmdlIHRfc21hbGwgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGZvbGRcbiAgICAgICAgdF9zbWFsbFxuICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIHRfbGFyZ2UgbGVuZ3RoX2xhcmdlKVxuICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6ZGF0YScgeyB0cmVlID0gdDsgbGVuZ3RoIH0gLT5cbiAgICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgfCBOb25lIC0+IGRhdGEnXG4gICAgICAgICAgIHwgU29tZSBkYXRhIC0+IGNhbGwgY29tYmluZSB+a2V5IGRhdGEgZGF0YScpXG4gICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgICBpblxuICAgIGxldCBjYWxsIGYgfmtleSB4IHkgPSBmIH5rZXkgeCB5IGluXG4gICAgbGV0IHN3YXAgZiB+a2V5IHggeSA9IGYgfmtleSB5IHggaW5cbiAgICBmdW4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfmNvbWJpbmUgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBsZW5ndGgyIDw9IGxlbmd0aDFcbiAgICAgIHRoZW4gbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMSB0MSB0MiB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMiB0MiB0MSB+Y2FsbDpzd2FwIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBtZXJnZV9za2V3ZWRcbiAgICAgIHQxXG4gICAgICB0MlxuICAgICAgfmxlbmd0aDFcbiAgICAgIH5sZW5ndGgyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+Y29tYmluZTooZnVuIH5rZXkgXyBfIC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAubWVyZ2VfZGlzam9pbnRfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZSlcbiAgOztcblxuICBtb2R1bGUgQ2xvc2VzdF9rZXlfaW1wbCA9IHN0cnVjdFxuICAgICgqIFttYXJrZXJdIGFuZCBbcmVwYWNrYWdlXSBhbGxvdyB1cyB0byBjcmVhdGUgXCJsb2dpY2FsXCIgb3B0aW9ucyB3aXRob3V0IGFjdHVhbGx5XG4gICAgICAgYWxsb2NhdGluZyBhbnkgb3B0aW9ucy4gUGFzc2luZyBbRm91bmQga2V5IHZhbHVlXSB0byBhIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICBwYXNzaW5nIFtTb21lIChrZXksIHZhbHVlKV07IHBhc3NpbmcgW01pc3NpbmcgKCkgKCldIGlzIGVxdWl2YWxlbnQgdG8gcGFzc2luZ1xuICAgICAgIFtOb25lXS4gKilcbiAgICB0eXBlICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXIgPVxuICAgICAgfCBNaXNzaW5nIDogKCdrLCAndiwgdW5pdCwgdW5pdCkgbWFya2VyXG4gICAgICB8IEZvdW5kIDogKCdrLCAndiwgJ2ssICd2KSBtYXJrZXJcblxuICAgIGxldCByZXBhY2thZ2VcbiAgICAgICh0eXBlIGsgdiBrX29wdCB2X29wdClcbiAgICAgIChtYXJrZXIgOiAoaywgdiwga19vcHQsIHZfb3B0KSBtYXJrZXIpXG4gICAgICAoayA6IGtfb3B0KVxuICAgICAgKHYgOiB2X29wdClcbiAgICAgIDogKGsgKiB2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIG1hdGNoIG1hcmtlciB3aXRoXG4gICAgICB8IE1pc3NpbmcgLT4gTm9uZVxuICAgICAgfCBGb3VuZCAtPiBTb21lIChrLCB2KVxuICAgIDs7XG5cbiAgICAoKiBUaGUgdHlwZSBzaWduYXR1cmUgaXMgZXhwbGljaXQgaGVyZSB0byBhbGxvdyBwb2x5bW9ycGhpYyByZWN1cnNpb24uICopXG4gICAgbGV0IHJlYyBsb29wIDpcbiAgICAgICAgICAgICAgJ2sgJ3YgJ2tfb3B0ICd2X29wdC5cbiAgICAgICAgICAgICAgKCdrLCAndikgdHJlZVxuICAgICAgICAgICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAgICAgICAgIC0+ICdrXG4gICAgICAgICAgICAgIC0+IGNvbXBhcmVfa2V5OignayAtPiAnayAtPiBpbnQpXG4gICAgICAgICAgICAgIC0+ICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXJcbiAgICAgICAgICAgICAgLT4gJ2tfb3B0XG4gICAgICAgICAgICAgIC0+ICd2X29wdFxuICAgICAgICAgICAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG4gICAgICA9XG4gICAgICBmdW4gdCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICB8IExlYWYgeyBrZXkgPSBrJzsgZGF0YSA9IHYnIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgIGlmIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gLT4gYyA+PSAwXG4gICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPiBjID4gMFxuICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IGMgPD0gMFxuICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT4gYyA8IDBcbiAgICAgICAgdGhlbiBTb21lIChrJywgdicpXG4gICAgICAgIGVsc2UgcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrJzsgZGF0YSA9IHYnOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogVGhpcyBpcyBhIGJhc2UgY2FzZSAobm8gcmVjdXJzaXZlIGNhbGwpLiAqKVxuICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IFNvbWUgKGsnLCB2JylcbiAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGlzX2VtcHR5IHIgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1pbl9lbHQgclxuICAgICAgICAgIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgaWYgaXNfZW1wdHkgbCB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWF4X2VsdCBsKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBXZSBhcmUgZ3VhcmFudGVlZCBoZXJlIHRoYXQgaycgPD4gay4gKilcbiAgICAgICAgICAoKiBUaGlzIGlzIHRoZSBvbmx5IHJlY3Vyc2l2ZSBjYXNlLiAqKVxuICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGMgPiAwXG4gICAgICAgICAgICB0aGVuIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgIGVsc2UgbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgICB0aGVuIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgIGVsc2UgbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIgayB+Y29tcGFyZV9rZXkgPSBsb29wIHQgZGlyIGsgfmNvbXBhcmVfa2V5IE1pc3NpbmcgKCkgKClcbiAgZW5kXG5cbiAgbGV0IGNsb3Nlc3Rfa2V5ID0gQ2xvc2VzdF9rZXlfaW1wbC5jbG9zZXN0X2tleVxuXG4gIGxldCByZWMgcmFuayB0IGsgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgZGF0YSA9IF8gfSAtPiBpZiBjb21wYXJlX2tleSBrJyBrID0gMCB0aGVuIFNvbWUgMCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gayc7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBTb21lIChsZW5ndGggbClcbiAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgIHRoZW4gcmFuayBsIGsgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIE9wdGlvbi5tYXAgKHJhbmsgciBrIH5jb21wYXJlX2tleSkgfmY6KGZ1biByYW5rIC0+IHJhbmsgKyAxICsgbGVuZ3RoIGwpXG4gIDs7XG5cbiAgKCogdGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbU2VxdWVuY2VdIGludGVyZmFjZSBidXQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICBhbGxvY2F0ZXMgb25seSAyIHdvcmRzIGFuZCBkb2Vzbid0IHJlcXVpcmUgd3JpdGUtYmFycmllciAqKVxuICBsZXQgcmVjIG50aCcgbnVtX3RvX3NlYXJjaCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IHYgfSAtPlxuICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICBlbHNlIChcbiAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICBOb25lKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIChtYXRjaCBudGgnIG51bV90b19zZWFyY2ggbCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiBzb21lXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgICAgIG50aCcgbnVtX3RvX3NlYXJjaCByKSlcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IG50aCcgKHJlZiBuKSB0XG5cbiAgbGV0IHJlYyBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IHYgfSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH0gLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDwgMCkgW0Bub250YWlsXVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPiAwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgfmtleSB+ZGF0YSA9IG5vdCAoaXNfbGVmdCB+a2V5IH5kYXRhKSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdCBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHQgW0Bub250YWlsXVxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZF0gZmluZHMgdGhlIGtleSBpbiBbdF0gd2hpY2ggc2F0aXNmaWVzIFttYXliZV9ib3VuZF1cbiAgICAgYW5kIHRoZSByZWxldmFudCBvbmUgb2YgW2lmX2V4Y2x1c2l2ZV0gb3IgW2lmX2luY2x1c2l2ZV0sIGFzIGp1ZGdlZCBieSBbY29tcGFyZV0uICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlIH5pZl9leGNsdXNpdmUgfmlmX2luY2x1c2l2ZSA9XG4gICAgbGV0IGZpbmRfYm91bmQgdCBob3cgYm91bmQgfmNvbXBhcmUgOiBfIE1heWJlX2JvdW5kLnQgb3B0aW9uID1cbiAgICAgIG1hdGNoIGJpbmFyeV9zZWFyY2ggdCBob3cgYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgfCBTb21lIChib3VuZCwgXykgLT4gU29tZSAoSW5jbCBib3VuZClcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCAobWF5YmVfYm91bmQgOiBfIE1heWJlX2JvdW5kLnQpIHdpdGhcbiAgICB8IEV4Y2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2V4Y2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgSW5jbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfaW5jbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBVbmJvdW5kZWQgLT4gU29tZSBVbmJvdW5kZWRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzXSBmaW5kcyB0aGUgKG5vdCBuZWNlc3NhcmlseSBkaXN0aW5jdCkga2V5cyBpbiBbdF1cbiAgICAgd2hpY2ggbW9zdCBjbG9zZWx5IGFwcHJvYWNoIChidXQgZG8gbm90IGNyb3NzKSBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdLCBhc1xuICAgICBqdWRnZWQgYnkgW2NvbXBhcmVdLiBJdCByZXR1cm5zIFtOb25lXSBpZiBubyBrZXlzIGluIFt0XSBhcmUgd2l0aGluIHRoYXQgcmFuZ2UuICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgZmluZF9sb3dlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbGV0IGZpbmRfdXBwZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBtYXRjaCBmaW5kX2xvd2VyX2JvdW5kIHQgbG93ZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGxvd2VyX2JvdW5kIC0+XG4gICAgICAobWF0Y2ggZmluZF91cHBlcl9ib3VuZCB0IHVwcGVyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgIHwgU29tZSB1cHBlcl9ib3VuZCAtPiBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpKVxuICA7O1xuXG4gIHR5cGUgKCdrLCAndikgYWNjID1cbiAgICB7IG11dGFibGUgYmFkX2tleSA6ICdrIG9wdGlvblxuICAgIDsgbXV0YWJsZSBtYXBfbGVuZ3RoIDogKCdrLCAndikgdCBXaXRoX2xlbmd0aC50XG4gICAgfVxuXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWNjID0geyBiYWRfa2V5ID0gTm9uZTsgbWFwX2xlbmd0aCA9IHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwIH0gaW5cbiAgICBpdGVyaSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGxldCB7IHRyZWUgPSBtYXA7IGxlbmd0aCB9ID0gYWNjLm1hcF9sZW5ndGggaW5cbiAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbGVuZ3RoJyB9IGFzIHBhaXIpID1cbiAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBtYXAgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyAmJiBPcHRpb24uaXNfbm9uZSBhY2MuYmFkX2tleVxuICAgICAgdGhlbiBhY2MuYmFkX2tleSA8LSBTb21lIGtleVxuICAgICAgZWxzZSBhY2MubWFwX2xlbmd0aCA8LSBnbG9iYWxpemUgcGFpcik7XG4gICAgbWF0Y2ggYWNjLmJhZF9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBgT2sgYWNjLm1hcF9sZW5ndGhcbiAgICB8IFNvbWUga2V5IC0+IGBEdXBsaWNhdGVfa2V5IGtleVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbWF0Y2ggb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfaXRlcmlfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHAgc2V4cCB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHApIHNleHAgaW5cbiAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBtYXRjaCBvZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkgayAtPlxuICAgICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgICBsZXQgYWxpc3Rfc2V4cHMgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBGbi5pZCBGbi5pZCkgc2V4cCBpblxuICAgICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICAgIExpc3QuaXRlcjJfb2sgYWxpc3QgYWxpc3Rfc2V4cHMgfmY6KGZ1biAoazIsIF8pIChrMl9zZXhwLCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIGsyID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJNYXAudF9vZl9zZXhwX2RpcmVjdDogZHVwbGljYXRlIGtleVwiIGsyX3NleHBcbiAgICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgICBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsdWUgdCA9XG4gICAgbGV0IGYgfmtleSB+ZGF0YSBhY2MgPSBTZXhwLkxpc3QgWyBzZXhwX29mX2tleSBrZXk7IHNleHBfb2ZfdmFsdWUgZGF0YSBdIDo6IGFjYyBpblxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB+ZiB0IH5pbml0OltdKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0IH5zZXhwX29mX2tleSA9XG4gICAgbGV0IG9rcywgZXJyb3JzID0gcGFydGl0aW9uX21hcCB0IH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgICBpZiBpc19lbXB0eSBlcnJvcnNcbiAgICB0aGVuIE9rIG9rc1xuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3JfcyAoc2V4cF9vZl90IHNleHBfb2Zfa2V5IEVycm9yLnNleHBfb2ZfdCBlcnJvcnMpXG4gIDs7XG5cbiAgbGV0IHVuemlwIHQgPSBtYXAgdCB+Zjpmc3QsIG1hcCB0IH5mOnNuZFxuXG4gIGxldCBtYXBfa2V5c1xuICAgIHQxXG4gICAgfmZcbiAgICB+Y29tcGFyYXRvcjooeyBjb21wYXJlID0gY29tcGFyZV9rZXk7IHNleHBfb2ZfdCA9IHNleHBfb2Zfa2V5IH0gOiBfIENvbXBhcmF0b3IudClcbiAgICA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBgT2tcbiAgICAgICAgKGZvbGRcbiAgICAgICAgICAgdDFcbiAgICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgeyB0cmVlID0gdDI7IGxlbmd0aCB9IC0+XG4gICAgICAgICAgIGxldCBrZXkgPSBmIGtleSBpblxuICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICBhZGRfZXhuX2ludGVybmFsIHQyIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IHw+IGdsb2JhbGl6ZVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgRHVwbGljYXRlIC0+IHJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSkpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mIH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBtYXBfa2V5cyB0IH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayByZXN1bHQgLT4gcmVzdWx0XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIGxldCBzZXhwX29mX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QgaW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIk1hcC5tYXBfa2V5c19leG46IGR1cGxpY2F0ZSBrZXlcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIGxldCB0cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciBvdXRlcl90ID1cbiAgICBmb2xkXG4gICAgICBvdXRlcl90XG4gICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICB+ZjooZnVuIH5rZXk6b3V0ZXJfa2V5IH5kYXRhOmlubmVyX3QgYWNjIC0+XG4gICAgICBmb2xkXG4gICAgICAgIGlubmVyX3RcbiAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgeyB0cmVlID0gYWNjOyBsZW5ndGggPSBhY2NfbGVuIH0gLT5cbiAgICAgICAgKHVwZGF0ZVxuICAgICAgICAgICBhY2NcbiAgICAgICAgICAgaW5uZXJfa2V5XG4gICAgICAgICAgIH5sZW5ndGg6YWNjX2xlblxuICAgICAgICAgICB+Y29tcGFyZV9rZXk6aW5uZXJfY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgICAgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgIHwgTm9uZSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgKHNpbmdsZXRvbiBvdXRlcl9rZXkgZGF0YSkgMVxuICAgICAgICAgICB8IFNvbWUgeyB0cmVlID0gZWx0OyBsZW5ndGggPSBlbHRfbGVuIH0gLT5cbiAgICAgICAgICAgICAoc2V0XG4gICAgICAgICAgICAgICAgZWx0XG4gICAgICAgICAgICAgICAgfmtleTpvdXRlcl9rZXlcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgIH5sZW5ndGg6ZWx0X2xlblxuICAgICAgICAgICAgICAgIH5jb21wYXJlX2tleTpvdXRlcl9jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pXG4gICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pKVxuICA7O1xuXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA9IHN0cnVjdFxuICAgIGxldCByZWMgbWFwaSB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBBLnJldHVybiBFbXB0eVxuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICBBLm1hcCAoZiB+a2V5OnYgfmRhdGE6ZCkgfmY6KGZ1biBuZXdfZGF0YSAtPiBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IG5ld19kYXRhIH0pXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICAgIGxldCBsJyA9IEEub2ZfdGh1bmsgKGZ1biAoKSAtPiBtYXBpIH5mIGwpIGluXG4gICAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgICAgbGV0IHInID0gQS5vZl90aHVuayAoZnVuICgpIC0+IG1hcGkgfmYgcikgaW5cbiAgICAgICAgQS5tYXAzIGwnIGQnIHInIH5mOihmdW4gbCcgZCcgcicgLT5cbiAgICAgICAgICBOb2RlIHsgbGVmdCA9IGwnOyBrZXkgPSB2OyBkYXRhID0gZCc7IHJpZ2h0ID0gcic7IGhlaWdodCA9IGggfSlcbiAgICA7O1xuXG4gICAgKCogSW4gdGhlb3J5IHRoZSBjb21wdXRhdGlvbiBvZiBsZW5ndGggb24tdGhlLWZseSBpcyBub3QgbmVjZXNzYXJ5IGhlcmUgYmVjYXVzZSBpdCBjYW5cbiAgICAgICBiZSBkb25lIGJ5IHdyYXBwaW5nIHRoZSBhcHBsaWNhdGl2ZSBbQV0gd2l0aCBsZW5ndGgtY29tcHV0aW5nIGxvZ2ljLiBIb3dldmVyLFxuICAgICAgIGludHJvZHVjaW5nIGFuIGFwcGxpY2F0aXZlIHRyYW5zZm9ybWVyIGxpa2UgdGhhdCBtYWtlcyB0aGUgbWFwIGJlbmNobWFya3MgaW5cbiAgICAgICBhc3luY19rZXJuZWwvYmVuY2gvc3JjL2JlbmNoX2RlZmVycmVkX21hcC5tbCBub3RpY2VhYmx5IHNsb3dlci4gKilcbiAgICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgICBsZXQgcmVjIHRyZWVfZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IEEucmV0dXJuICh3aXRoX2xlbmd0aF9nbG9iYWwgRW1wdHkgMClcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIEEubWFwIChmIH5rZXk6diB+ZGF0YTpkKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgIHwgU29tZSBuZXdfZGF0YSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgKExlYWYgeyBrZXkgPSB2OyBkYXRhID0gbmV3X2RhdGEgfSkgMVxuICAgICAgICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoX2dsb2JhbCBFbXB0eSAwKVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgICAgQS5tYXAzXG4gICAgICAgICAgICAoQS5vZl90aHVuayAoZnVuICgpIC0+IHRyZWVfZmlsdGVyX21hcGkgbCB+ZikpXG4gICAgICAgICAgICAoZiB+a2V5OnYgfmRhdGE6ZClcbiAgICAgICAgICAgIChBLm9mX3RodW5rIChmdW4gKCkgLT4gdHJlZV9maWx0ZXJfbWFwaSByIH5mKSlcbiAgICAgICAgICAgIH5mOlxuICAgICAgICAgICAgICAoZnVuXG4gICAgICAgICAgICAgICAgeyB0cmVlID0gbCc7IGxlbmd0aCA9IGxfbGVuIH0gbmV3X2RhdGEgeyB0cmVlID0gcic7IGxlbmd0aCA9IHJfbGVuIH0gLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbmV3X2RhdGEgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT5cbiAgICAgICAgICAgICAgICB3aXRoX2xlbmd0aF9nbG9iYWwgKGpvaW4gbCcgdiBuZXdfZGF0YSByJykgKGxfbGVuICsgcl9sZW4gKyAxKVxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICB3aXRoX2xlbmd0aF9nbG9iYWwgKGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpIChsX2xlbiArIHJfbGVuKSlcbiAgICAgIGluXG4gICAgICB0cmVlX2ZpbHRlcl9tYXBpIHQgfmZcbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2ssICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogKCdrLCAndikgVHJlZTAudFxuICA7IGxlbmd0aCA6IGludFxuICB9XG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG5cbmxldCBjb21wYXJlX2tleSB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gKHsgdHJlZTsgbGVuZ3RoIH0gOiBfIFdpdGhfbGVuZ3RoLnQpID1cbiAgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IGxpa2VfbWF5YmVfbm9fb3BcbiAgKHsgdHJlZSA9IG9sZF90cmVlOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpXG4gICh7IHRyZWU7IGxlbmd0aCB9IDogXyBXaXRoX2xlbmd0aC50KVxuICA9XG4gIGlmIHBoeXNfZXF1YWwgb2xkX3RyZWUgdHJlZSB0aGVuIG9sZF90IGVsc2UgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IHdpdGhfc2FtZV9sZW5ndGggeyB0cmVlID0gXzsgY29tcGFyYXRvcjsgbGVuZ3RoIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cbmxldCBvZl9saWtlX3RyZWUgdCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbmxldCBvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AgdCB0cmVlID1cbiAgaWYgcGh5c19lcXVhbCB0LnRyZWUgdHJlZVxuICB0aGVuIHRcbiAgZWxzZSB7IHRyZWU7IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cbjs7XG5cbmxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuKCogRXhwb3NpbmcgdGhpcyBmdW5jdGlvbiB3b3VsZCBtYWtlIGl0IHZlcnkgZWFzeSBmb3IgdGhlIGludmFyaWFudHNcbiAgIG9mIHRoaXMgbW9kdWxlIHRvIGJlIGJyb2tlbi4gKilcbmxldCBvZl90cmVlX3Vuc2FmZSB+Y29tcGFyYXRvciB+bGVuZ3RoIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5cbiAgbGV0IGludmFyaWFudHMgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSAmJiBUcmVlMC5sZW5ndGggdC50cmVlID0gdC5sZW5ndGhcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxuXG4gIGxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuc2V0IHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuX2ludGVybmFsXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCByZXN1bHQgLT4gYE9rIHJlc3VsdFxuICAgIHwgZXhjZXB0aW9uIER1cGxpY2F0ZSAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5ID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IGtleSA9IFRyZWUwLmZpbmRfbXVsdGkgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmNoYW5nZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnVwZGF0ZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdC50cmVlXG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgdCBrZXkgPSBUcmVlMC5maW5kIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCByZW1vdmUgdCBrZXkgPVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIHRcbiAgICAgIChUcmVlMC5yZW1vdmUgdC50cmVlIGtleSB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWVtIHQga2V5ID0gVHJlZTAubWVtIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdC50cmVlIH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQudHJlZSB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgdDEgdDIgfmYgPSBUcmVlMC5pdGVyMiB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgbGV0IG1hcCB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXAgdC50cmVlIH5mKVxuICBsZXQgbWFwaSB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXBpIHQudHJlZSB+ZilcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5pbml0IH5mIH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MS50cmVlIHQyLnRyZWUgfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX2tleXMgdC50cmVlIH5mIH5sZW4gaW5cbiAgICBsaWtlX21heWJlX25vX29wIHQgKHdpdGhfbGVuZ3RoIHRyZWUgIWxlbikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyaSB0IH5mID1cbiAgICBsZXQgbGVuID0gcmVmIHQubGVuZ3RoIGluXG4gICAgbGV0IHRyZWUgPSBUcmVlMC5maWx0ZXJpIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgICBsZXQgbGVuID0gcmVmIHQubGVuZ3RoIGluXG4gICAgbGV0IHRyZWUgPSBUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZSB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX21hcGkgdC50cmVlIH5mIH5sZW4gaW5cbiAgICBsaWtlIHQgKHdpdGhfbGVuZ3RoIHRyZWUgIWxlbikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9saWtlX3RyZWUyIHQgKHQxLCB0MikgPSBvZl9saWtlX3RyZWUgdCB0MSwgb2ZfbGlrZV90cmVlIHQgdDJcblxuICBsZXQgb2ZfbGlrZV90cmVlMl9tYXliZV9ub19vcCB0ICh0MSwgdDIpID1cbiAgICBvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AgdCB0MSwgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdDJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9IG9mX2xpa2VfdHJlZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcGkgdC50cmVlIH5mKVxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID0gb2ZfbGlrZV90cmVlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwIHQudHJlZSB+ZilcbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAoVHJlZTAucGFydGl0aW9uaV90ZiB0LnRyZWUgfmYpXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAoVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZilcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjoob2ZfbGlrZV90cmVlIHQpXG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnMgdC50cmVlIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCB1bnppcCB0ID0gb2ZfbGlrZV90cmVlMiB0IChUcmVlMC51bnppcCB0LnRyZWUpXG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9kYXRhIHQxIHQyID0gVHJlZTAuZXF1YWwgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHQudHJlZVxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0LnRyZWVcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdC50cmVlXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDEudHJlZVxuICAgICAgdDIudHJlZVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgPVxuICAgIGxpa2UgdDEgKFRyZWUwLm1lcmdlIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgPVxuICAgIGxpa2VcbiAgICAgIHQxXG4gICAgICAoVHJlZTAubWVyZ2VfZGlzam9pbnRfZXhuXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbXBhcmF0b3I6dDEuY29tcGFyYXRvcikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIFRoaXMgaXMgb25seSBhIG5vLW9wIGluIHRoZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgbWFwcyBpcyBlbXB0eS4gKilcbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICAoaWYgdDIubGVuZ3RoIDw9IHQxLmxlbmd0aCB0aGVuIHQxIGVsc2UgdDIpXG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdC50cmVlIH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IHN1bWkgbSB0IH5mID0gVHJlZTAuc3VtaSBtIHQudHJlZSB+ZlxuXG4gIGxldCBzcGxpdCB0IGsgPVxuICAgIGxldCBsLCBtYXliZSwgciA9IFRyZWUwLnNwbGl0IHQudHJlZSBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgaW5cbiAgICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgdCBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgYm90aF9sZW4gPSBpZiBPcHRpb24uaXNfc29tZSBtYXliZSB0aGVuIHQubGVuZ3RoIC0gMSBlbHNlIHQubGVuZ3RoIGluXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG1heWJlLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggciksIG1heWJlLCByKVxuICA7O1xuXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byBrID1cbiAgICBsZXQgbCwgciA9XG4gICAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdC50cmVlIH5pbnRvIGsgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG9mX3RyZWVfdW5zYWZlIHIgfmNvbXBhcmF0b3Igfmxlbmd0aDoodC5sZW5ndGggLSBsZW5ndGggbCkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgciA9IG9mX3RyZWUgciB+Y29tcGFyYXRvciBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbCB+Y29tcGFyYXRvciB+bGVuZ3RoOih0Lmxlbmd0aCAtIGxlbmd0aCByKSwgcilcbiAgOztcblxuICBsZXQgc3BsaXRfbGVfZ3QgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YExlZnQga1xuICBsZXQgc3BsaXRfbHRfZ2UgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YFJpZ2h0IGtcblxuICBsZXQgc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgbGVmdCwgbWlkLCByaWdodCA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZSB0LnRyZWUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IG91dGVyX2pvaW5lZF9oZWlnaHQgPVxuICAgICAgbGV0IGhfbCA9IFRyZWUwLmhlaWdodCBsZWZ0XG4gICAgICBhbmQgaF9yID0gVHJlZTAuaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpZiBoX2wgPSBoX3IgdGhlbiBoX2wgKyAxIGVsc2UgbWF4IGhfbCBoX3JcbiAgICBpblxuICAgIGlmIG91dGVyX2pvaW5lZF9oZWlnaHQgPCBUcmVlMC5oZWlnaHQgbWlkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbWlkX2xlbmd0aCA9IHQubGVuZ3RoIC0gKFRyZWUwLmxlbmd0aCBsZWZ0ICsgVHJlZTAubGVuZ3RoIHJpZ2h0KSBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpIH5sZW5ndGg6bWlkX2xlbmd0aClcbiAgICBlbHNlIG9mX3RyZWUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmFwcGVuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IGxvd2VyX3BhcnQpXG4gICAgICAgIH5sb3dlcl9wYXJ0Omxvd2VyX3BhcnQudHJlZVxuICAgICAgICB+dXBwZXJfcGFydDp1cHBlcl9wYXJ0LnRyZWVcbiAgICB3aXRoXG4gICAgfCBgT2sgdHJlZSAtPlxuICAgICAgYE9rXG4gICAgICAgIChvZl90cmVlX3Vuc2FmZVxuICAgICAgICAgICB0cmVlXG4gICAgICAgICAgIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIGxvd2VyX3BhcnQpXG4gICAgICAgICAgIH5sZW5ndGg6KGxvd2VyX3BhcnQubGVuZ3RoICsgdXBwZXJfcGFydC5sZW5ndGgpKVxuICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQudHJlZSB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdC50cmVlIH5taW4gfm1heCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdC50cmVlIGRpciBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQudHJlZSBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIHQga2V5ID0gVHJlZTAucmFuayB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdC50cmVlIH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBsaWtlX21heWJlX25vX29wIHQgKHdpdGhfbGVuZ3RoIFRyZWUwLkVtcHR5IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVHJlZV90cmF2ZXJzYWxzID0gVHJlZTAuTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBKVxuXG4gICAgbGV0IG1hcGkgdCB+ZiA9XG4gICAgICBBLm1hcCAoVHJlZV90cmF2ZXJzYWxzLm1hcGkgdC50cmVlIH5mKSB+ZjooZnVuIG5ld190cmVlIC0+XG4gICAgICAgIHdpdGhfc2FtZV9sZW5ndGggdCBuZXdfdHJlZSlcbiAgICA7O1xuXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgQS5tYXAgKFRyZWVfdHJhdmVyc2Fscy5maWx0ZXJfbWFwaSB0LnRyZWUgfmYpIH5mOihmdW4gbmV3X3RyZWVfd2l0aF9sZW5ndGggLT5cbiAgICAgICAgbGlrZSB0IG5ld190cmVlX3dpdGhfbGVuZ3RoKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbigqIFswXSBpcyB1c2VkIGFzIHRoZSBbbGVuZ3RoXSBhcmd1bWVudCBldmVyeXdoZXJlIGluIHRoaXMgbW9kdWxlLCBzaW5jZSB0cmVlcyBkbyBub3RcbiAgIGhhdmUgdGhlaXIgbGVuZ3RocyBzdG9yZWQgYXQgdGhlIHJvb3QsIHVubGlrZSBtYXBzLiBUaGUgdmFsdWVzIGFyZSBkaXNjYXJkZWQgYWx3YXlzLiAqKVxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9ICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0cmVlID0gdHJlZVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gayB2ID0gVHJlZTAuc2luZ2xldG9uIGsgdlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID0gKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcikudHJlZVxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoID0gXyB9IC0+IGBPayB0cmVlXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID0gKFRyZWUwLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6X3JlcXVpcmVkX2J5X2ludGYgfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPSAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcikudHJlZVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X2V4biBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSA9XG4gICAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGlcbiAgICAgICBsaXN0XG4gICAgICAgfmdldF9rZXlcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2ZvbGQgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZFxuICAgICAgIGxpc3RcbiAgICAgICB+Z2V0X2tleVxuICAgICAgIH5pbml0XG4gICAgICAgfmZcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5IH5mID1cbiAgICAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9yZWR1Y2VcbiAgICAgICBsaXN0XG4gICAgICAgfmdldF9rZXlcbiAgICAgICB+ZlxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgdCA9IHRcblxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG5cbiAgbGV0IHNldCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5zZXQgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgYWRkX2V4biB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgdFxuICAgICAgIH5rZXlcbiAgICAgICB+ZGF0YVxuICAgICAgIH5sZW5ndGg6MFxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgIHRcbiAgICAgICB+a2V5XG4gICAgICAgfmRhdGFcbiAgICAgICB+bGVuZ3RoOjBcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5zZXhwX29mX3QpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICB0cnkgYE9rIChhZGRfZXhuX2ludGVybmFsIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSkgd2l0aFxuICAgIHwgXyAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5hZGRfbXVsdGkgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIChUcmVlMC5yZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX211bHRpIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIChUcmVlMC5jaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCB1cGRhdGUgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHRcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAuZmluZCB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICAoVHJlZTAucmVtb3ZlIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAubWVtIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdCB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQgfmZcblxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIFRyZWUwLml0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mXG4gIGxldCBtYXBpIHQgfmYgPSBUcmVlMC5tYXBpIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmYgfmluaXQgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIH5jb21wYXJhdG9yIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9IFRyZWUwLmZpbHRlcl9rZXlzIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9IFRyZWUwLmZpbHRlcmkgdCB+ZiB+bGVuOihyZWYgMCkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX21hcCB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5sZW46KHJlZiAwKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gVHJlZTAuZmlsdGVyX21hcGkgdCB+ZiB+bGVuOihyZWYgMCkgW0Bub250YWlsXVxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQgfmZcbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXAgdCB+ZlxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID0gVHJlZTAucGFydGl0aW9uaV90ZiB0IH5mXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mXG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIH5jb21wYXJhdG9yIHQgPVxuICAgIFRyZWUwLmNvbWJpbmVfZXJyb3JzIHQgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgdW56aXAgPSBUcmVlMC51bnppcFxuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuZXF1YWwgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdFxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0XG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHRcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MVxuICAgICAgdDJcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgKFRyZWUwLm1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIChUcmVlMC5tZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgfmxlbmd0aDE6KGxlbmd0aCB0MSkgfmxlbmd0aDI6KGxlbmd0aCB0MikgfmNvbXBhcmF0b3IpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgfmNvbXBhcmF0b3IgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIExlbmd0aCBjb21wdXRhdGlvbiBtYWtlcyB0aGlzIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gW21lcmdlX3NrZXdlZF0gb24gYSBtYXBcbiAgICAgICB3aXRoIGEgW2xlbmd0aF0gZmllbGQsIGJ1dCBkb2VzIHByZXNlcnZlIGFtb3VudCBvZiBhbGxvY2F0aW9uLiAqKVxuICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICB0MVxuICAgICAgIHQyXG4gICAgICAgfmxlbmd0aDE6KGxlbmd0aCB0MSlcbiAgICAgICB+bGVuZ3RoMjoobGVuZ3RoIHQyKVxuICAgICAgIH5jb21iaW5lXG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQgfmZcbiAgbGV0IHN1bWkgbSB0IH5mID0gVHJlZTAuc3VtaSBtIHQgfmZcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgayA9IFRyZWUwLnNwbGl0IHQgayB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgc3BsaXRfbGVfZ3QgfmNvbXBhcmF0b3IgdCBrID1cbiAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnlcbiAgICAgIHRcbiAgICAgIH5pbnRvOmBMZWZ0XG4gICAgICBrXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3BsaXRfbHRfZ2UgfmNvbXBhcmF0b3IgdCBrID1cbiAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnlcbiAgICAgIHRcbiAgICAgIH5pbnRvOmBSaWdodFxuICAgICAga1xuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+Y29tcGFyYXRvciB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgVHJlZTAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBfLCByZXQsIF8gPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+bG93ZXJfYm91bmRcbiAgICAgICAgfnVwcGVyX2JvdW5kXG4gICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgcmV0XG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgdFxuICAgICAgfm1pblxuICAgICAgfm1heFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB+Y29tcGFyYXRvciB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQgZGlyIGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0IG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5yYW5rIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdFxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKS50cmVlXG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gRW1wdHlcbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVHJlZTBfdHJhdmVyc2FscyA9IFRyZWUwLk1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSlcblxuICAgIGxldCBtYXBpIHQgfmYgPSBUcmVlMF90cmF2ZXJzYWxzLm1hcGkgdCB+ZlxuXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgQS5tYXBcbiAgICAgICAgKFRyZWUwX3RyYXZlcnNhbHMuZmlsdGVyX21hcGkgdCB+ZilcbiAgICAgICAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mIHdpdGhcbiAgICB8IGBPayB7IHRyZWUgPSB0OyBsZW5ndGggPSBfIH0gLT4gYE9rIHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9IChUcmVlMC5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZikudHJlZVxuXG4gICgqIFRoaXMgY2FsbGluZyBjb252ZW50aW9uIG9mIFt+Y29tcGFyYXRvciB+Y29tcGFyYXRvcl0gaXMgY29uZnVzaW5nLiBJdCBpcyByZXF1aXJlZFxuICAgICBiZWNhdXNlIFthY2Nlc3Nfb3B0aW9uc10gYW5kIFtjcmVhdGVfb3B0aW9uc10gYm90aCBkZW1hbmQgYSBbfmNvbXBhcmF0b3JdIGFyZ3VtZW50IGluXG4gICAgIFtNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlXS5cblxuICAgICBNYWtpbmcgaXQgbGVzcyBjb25mdXNpbmcgd291bGQgcmVxdWlyZSBzb21lIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkgaW4gc2lnbmF0dXJlcy5cbiAgICAgQmV0dGVyIHRvIGp1c3QgbGl2ZSB3aXRoIGFuIHVuZGVzaXJhYmxlIGludGVyZmFjZSBpbiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9iYWJseVxuICAgICBuZXZlciBiZSBjYWxsZWQgZGlyZWN0bHkuICopXG4gIGxldCB0cmFuc3Bvc2Vfa2V5cyB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3IgdCA9XG4gICAgKFRyZWUwLnRyYW5zcG9zZV9rZXlzIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yIHQpLnRyZWVcbiAgICB8PiBtYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAndykgdCA9ICgnaywgJ3YpIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudFxuXG4gICAgbGV0IGVtcHR5ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5lbXB0eVxuXG4gICAgbGV0IGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSB0IHdpdGhcbiAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgIEVycm9yLnJhaXNlX3MgKFNleHAuQXRvbSBcIk1hcC5CdWlsZF9pbmNyZWFzaW5nLmFkZDogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICB8IF8gLT4gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZSB0ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgayB2ID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGsgdjsgbGVuZ3RoID0gMSB9XG5cbiAgbGV0IG9mX3RyZWUwIH5jb21wYXJhdG9yICh7IHRyZWU7IGxlbmd0aCB9IDogXyBXaXRoX2xlbmd0aC50KSA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICA7O1xuXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yICh3aXRoX2xlbmd0aCB0cmVlIChUcmVlMC5sZW5ndGggdHJlZSkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgdG9fdHJlZSA9IHRvX3RyZWVcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICB+ZjooZnVuIHRyZWUgLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggfSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfml0ZXJpIHdpdGhcbiAgICB8IGBPayB0cmVlX2xlbmd0aCAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWVfbGVuZ3RoKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKHdpdGhfbGVuZ3RoIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mKSBsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGZ1biB4IC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHgpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X2V4biBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2ZvbGQgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgICBsaXN0XG4gICAgICB+Z2V0X2tleVxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5IH5mID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X3JlZHVjZVxuICAgICAgbGlzdFxuICAgICAgfmdldF9rZXlcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHBhaXIgLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciBwYWlyKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAubWFwX2tleXNfZXhuIHQudHJlZSB+ZiB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvciB0ID1cbiAgICBsZXQgb3V0ZXJfY29tcGFyYXRvciA9IHQuY29tcGFyYXRvciBpblxuICAgIFRyZWUwLnRyYW5zcG9zZV9rZXlzIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yIChUcmVlMC5tYXAgdC50cmVlIH5mOnRvX3RyZWUpXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgIHw+IG1hcCB+ZjooZnVuIHggLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvciB4KVxuICA7O1xuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChLIDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvciA9IEsuY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGVuZFxuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjb21wYXJhdG9yX3MgdCA9IENvbXBhcmF0b3IudG9fbW9kdWxlIHQuY29tcGFyYXRvclxubGV0IHRvX2NvbXBhcmF0b3IgPSBDb21wYXJhdG9yLm9mX21vZHVsZVxubGV0IG9mX3RyZWUgbSB0cmVlID0gb2ZfdHJlZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0cmVlXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdF9tdWx0aSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X2ZvbGQgbSBhIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9hbGlzdF9yZWR1Y2UgbSBhIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2l0ZXJpIG0gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcblxubGV0IG9mX2l0ZXJpX2V4biBtIH5pdGVyaSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgbSBzZXEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc2VxXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2UgbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9leG4gbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2VfbXVsdGkgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZm9sZCBtIHMgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+aW5pdCB+ZlxuOztcblxubGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBtIHMgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5mXG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleSBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgbCB+Z2V0X2tleVxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbSBsIH5nZXRfa2V5ID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X2V4biBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIG0gbCB+Z2V0X2tleSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5XG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIG0gbCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXkgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSBtIGwgfmdldF9rZXkgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXkgfmZcbjs7XG5cbmxldCBtYXBfa2V5cyBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCBtYXBfa2V5c19leG4gbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxubGV0IHRyYW5zcG9zZV9rZXlzIG0gdCA9IFVzaW5nX2NvbXBhcmF0b3IudHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoSyA6IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICh0eXBlIGsgY21wKVxuICAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgdl9vZl9zZXhwXG4gIHNleHBcbiAgPVxuICBVc2luZ19jb21wYXJhdG9yLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3I6Sy5jb21wYXJhdG9yIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXJcbiAgKHR5cGUgaylcbiAgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKVxuICAodl9ncmFtbWFyIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFRhZ2dlZFxuICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY190YWdcbiAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgIExpc3RcbiAgICAgICAgICAgICAgKE1hbnlcbiAgICAgICAgICAgICAgICAgKExpc3RcbiAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgKCBUYWdnZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX2tleV90YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IGdyYW1tYXIgPSBLLnRfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoIFRhZ2dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3ZhbHVlX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBncmFtbWFyID0gdl9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSkpKVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSBjb21wYXJlX3YgdDEgdDIgPSBjb21wYXJlX2RpcmVjdCBjb21wYXJlX3YgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGspIGhhc2hfZm9sZF92IHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBLLmhhc2hfZm9sZF90IGhhc2hfZm9sZF92IHN0YXRlXG47O1xuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID0gKCdrLCAndiwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZXhuIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9mb2xkIGEgfmluaXQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYSB+aW5pdCB+ZlxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhIH5mXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvclxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvclxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxXG4gIGxldCBvZl9zZXF1ZW5jZSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCBzIH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3IgcyB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgcyB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHMgfmZcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXkgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciB+Y29tcGFyYXRvciBsIH5nZXRfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9leG4gfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvciBsIH5nZXRfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZm9sZCBsIH5nZXRfa2V5IH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCB+Y29tcGFyYXRvciBsIH5nZXRfa2V5IH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIGwgfmdldF9rZXkgfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleSB+ZlxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmZcbiAgbGV0IHRyYW5zcG9zZV9rZXlzIHQgPSBVc2luZ19jb21wYXJhdG9yLnRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yIHRcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfTWFwX2JhbCIsImNzdF9NYXBfb2YiLCJjc3Rfa2V5IiwiY3N0X29mX3NvcnRlZF9hcnJheV9kdXBsaWNhdGVkIiwiY3N0X3NyY19tYXBfbWwiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJuYW1lIiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9SZXN1bHQiLCJCYXNlX09yX2Vycm9yIiwiQmFzZV9FcnJvciIsIkJhc2VfT3B0aW9uIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0V4biIsIkJhc2VfU2V4cCIsIkJhc2VfTGlzdDAiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfVW5pZm9ybV9hcnJheSIsIkJhc2VfU2VxdWVuY2UiLCJCYXNlX01heWJlX2JvdW5kIiwiQmFzZV9NYXBfaW50ZiIsIkJhc2VfV2l0aF9yZXR1cm4iLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJTeW1tZXRyaWNfZGlmZl9lbGVtZW50IiwiaW5jbHVkZSIsImNvbXBhcmUiLCJhbGwiLCJlcXVhbCIsInNleHBfb2ZfdCIsIm9mX2NvbnRpbnVlX29yX3N0b3AiLCJ0b19jb250aW51ZV9vcl9zdG9wIiwiRmluaXNoZWRfb3JfdW5maW5pc2hlZCIsImxlZnQiLCJwYXJhbSIsInZhcmlhbnQiLCJyaWdodCIsImxlZnRfdmFsdWUiLCJ0IiwiZGVmYXVsdCQiLCJyaWdodF92YWx1ZSIsInZhbHVlcyIsImxlZnRfZGVmYXVsdCIsInJpZ2h0X2RlZmF1bHQiLCJtYXRjaCIsIk1lcmdlX2VsZW1lbnQiLCJ3aXRoX3JldHVybiIsIkR1cGxpY2F0ZSIsImNzdF9vZl9zb3J0ZWRfYXJyYXlfZWxlbWVudHNfYSIsImdsb2JhbGl6ZSIsImxlbmd0aCIsInRyZWUiLCJoZWlnaHQiLCJoIiwiaW5fcmFuZ2UiLCJsb3dlciIsInVwcGVyIiwiY29tcGFyZV9rZXkiLCJrIiwibG9vcCIsInIiLCJsIiwiaGwiLCJociIsImludmFyaWFudHMiLCJjcmVhdGVfd2l0aF9oZWlnaHRzIiwieCIsImQiLCJjcmVhdGUiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2siLCJsZW4iLCJuIiwiaSIsInYiLCJ2bCIsImtsIiwidnIiLCJrciIsImxlZnRfbGVuZ3RoIiwicmlnaHRfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCIsImFycmF5IiwiYXJyYXlfbGVuZ3RoIiwiazAiLCJrMSIsIm5leHQiLCJvZl9zb3J0ZWRfYXJyYXkiLCJpbmNyZWFzaW5nIiwiYmFsIiwibHIiLCJsZCIsImx2IiwibGwiLCJscmQiLCJscnYiLCJscnIiLCJscmwiLCJyciIsInJkIiwicnYiLCJybCIsInJsZCIsInJsdiIsInJsciIsInJsbCIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsImNzdF9NYXBfYWRkX2V4bl9nb3Rfa2V5X2FscmVhZCIsImlzX2VtcHR5IiwicmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCIsImtleSIsInNleHBfb2Zfa2V5IiwiZmluZF9hbmRfYWRkX29yX3NldCIsImRhdGEiLCJhZGRfb3Jfc2V0IiwiYyIsInNldF9taW4iLCJzZXRfbWF4IiwiYWRkX2V4biIsImFkZF9leG5faW50ZXJuYWwiLCJzZXQiLCJlbXB0eSIsImNzdF9vZl9pbmNyZWFzaW5nX3NlcXVlbmNlX25vbiIsIm1heF9rZXkiLCJhZGRfdW5jaGVja2VkIiwidG9fdHJlZV91bmNoZWNrZWQiLCJsaXN0Iiwic3dpdGNoZXIiLCJ0YWlsIiwiZDEiLCJkMiIsImsyIiwiZDMiLCJrMyIsIm5yIiwibmwiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIiwic2VxIiwiYnVpbGRlciIsInByZXZfa2V5Iiwiam9pbiIsImxoIiwibGsiLCJyayIsInJoIiwic3BsaXRfZ2VuIiwiY21wIiwibWF5YmUiLCJzcGxpdCIsInkiLCJzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkiLCJpbnRvIiwicmVzIiwiYm91bmRhcnlfb3B0Iiwic3BsaXRfcmFuZ2UiLCJsb3dlcl9ib3VuZCIsInVwcGVyX2JvdW5kIiwibWlkX2FuZF9yaWdodCIsImxiIiwibWlkIiwiZmluZCIsImFkZF9tdWx0aSIsImZpbmRfbXVsdGkiLCJpZl9ub3RfZm91bmQiLCJmaW5kX2V4biIsIm1lbSIsIm1pbl9lbHQiLCJNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIiwiTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCIsImNzdF9NYXBfcmVtb3ZlX21pbl9lbHQiLCJjc3Rfb3JfZXJyb3JfZHVwbGljYXRlX2tleSIsImNzdF9leG5fZHVwbGljYXRlX2tleSIsIm1pbl9lbHRfZXhuIiwibWF4X2VsdCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJhcHBlbmQiLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm1pbl91cHBlciIsIm1heF9sb3dlciIsInVwcGVyX3BhcnRfd2l0aG91dF9taW4iLCJnbyIsIm1pbiIsIm1heCIsImluaXQiLCJjX21pbiIsInoiLCJjX21heCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlIiwicmFuZ2VfdG9fYWxpc3QiLCJjb25jYXRfdW5jaGVja2VkIiwidDEiLCJ0MiIsImNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQiLCJyZW1vdmUiLCJjaGFuZ2UiLCJ1cGRhdGUiLCJyZW1vdmVfbXVsdGkiLCJub25fZW1wdHlfdGFpbCIsIml0ZXJfa2V5cyIsIml0ZXIiLCJpdGVyaSIsIml0ZXJpX3VudGlsX2xvb3AiLCJtYXAiLCJtYXBpIiwiZm9sZCIsImFjY3UiLCJmb2xkX3VudGlsIiwiZmluaXNoIiwiZm9sZF91bnRpbF9sb29wIiwiYWNjIiwiZmluYWwiLCJzdG9wIiwiZm9sZF9yaWdodCIsImZpbHRlcl9tYXBpIiwibmV3X2RhdGEiLCJmaWx0ZXJpIiwia2VlcF9kYXRhIiwiZmlsdGVyIiwiZmlsdGVyX2tleXMiLCJmaWx0ZXJfbWFwIiwicGFydGl0aW9uX21hcGkiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uaV90ZiIsImxfZiIsImxfdCIsImtlZXBfZGF0YV90Iiwicl9mIiwicl90IiwibWsiLCJwYXJ0aXRpb25fdGYiLCJjb25zIiwiZSIsImNvbnNfcmlnaHQiLCJvZl90cmVlIiwic3RlcF9kZWVwZXJfZXhuIiwiZHJvcF9waHlzX2VxdWFsX3ByZWZpeCIsInRyZWUxIiwiYWNjMSIsInRyZWUyIiwiYWNjMiIsImgyIiwiaDEiLCJmb2xkMiIsImN1cnIiLCJlbnVtMiIsInYyIiwiZW51bTEiLCJ2MSIsImNvbXBhcmVfcmVzdWx0IiwiZW51bSQiLCJzeW1tZXRyaWNfZGlmZiIsImRhdGFfZXF1YWwiLCJzdGVwIiwic3RhdGUiLCJuZXh0X3N0YXRlIiwiZm9sZF9zeW1tZXRyaWNfZGlmZiIsImFkZCIsInRvX3NlcXVlbmNlIiwiY29tcGFyYXRvciIsIm9wdCIsImtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byIsImtleXNfbGVzc19vcl9lcXVhbF90byIsIm9yZGVyIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsImJvdW5kIiwiY29tcGFyZV9kYXRhIiwiZTIiLCJlMSIsInIyIiwicjEiLCJpdGVyMiIsImRlbHRhIiwia2V5cyIsIm9mX2ZvbGRhYmxlIiwiZm9sZGFibGUiLCJhY2N1bSIsInByZXYiLCJwcmV2X2RhdGEiLCJPZl9mb2xkYWJsZSIsIk0iLCJvZl9mb2xkYWJsZV9mb2xkIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwib2ZfZm9sZGFibGVfb3JfZXJyb3IiLCJvZl9mb2xkYWJsZV9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsImFsaXN0IiwiT2ZfYWxpc3QiLCJvZl9hbGlzdF9mb2xkIiwib2ZfYWxpc3RfcmVkdWNlIiwib2ZfYWxpc3QiLCJvZl9hbGlzdF9vcl9lcnJvciIsIm9mX2FsaXN0X2V4biIsIm9mX2FsaXN0X211bHRpIiwiT2Zfc2VxdWVuY2UiLCJvZl9zZXF1ZW5jZV9mb2xkIiwib2Zfc2VxdWVuY2VfcmVkdWNlIiwib2Zfc2VxdWVuY2UiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciIsIm9mX3NlcXVlbmNlX2V4biIsIm9mX3NlcXVlbmNlX211bHRpIiwiY3N0X01hcF9vZl9saXN0X3dpdGhfa2V5X29yX2VyIiwiY3N0X01hcF9vZl9saXN0X3dpdGhfa2V5X2V4bl9kIiwiY3N0X01hcF9tZXJnZV9kaXNqb2ludF9leG5fZHVwIiwiY3N0X01hcF9vZl9pdGVyaV9leG5fZHVwbGljYXRlIiwiY3N0X01hcF90X29mX3NleHBfZGlyZWN0X2R1cGxpIiwiY3N0X01hcF9tYXBfa2V5c19leG5fZHVwbGljYXRlIiwiZHVtbXkiLCJvZl9saXN0X3dpdGhfa2V5IiwiZ2V0X2tleSIsIm5ld19sZW5ndGgiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIiwib2ZfbGlzdF93aXRoX2tleV9leG4iLCJvZl9saXN0X3dpdGhfa2V5X211bHRpIiwib3B0aW9uIiwib2ZfbGlzdF93aXRoX2tleV9mb2xkIiwib2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UiLCJmb3JfYWxsIiwiZm9yX2FsbGkiLCJleGlzdHMiLCJleGlzdHNpIiwiY291bnQiLCJjb3VudGkiLCJzdW0iLCJzdW1pIiwidG9fYWxpc3QiLCJrZXlfb3JkZXIiLCJtZXJnZSIsImVsdHMiLCJ2YWx1ZSIsImdldCIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJjYWxsIiwiY29tYmluZSIsInN3YXAiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsIm1lcmdlX2Rpc2pvaW50X2V4biIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZGlyIiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJyYW5rIiwibnRoIiwibnVtX3RvX3NlYXJjaCIsInNvbWUiLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmciLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJwYWlyIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmQiLCJtYXliZV9ib3VuZCIsImlmX2V4Y2x1c2l2ZSIsImlmX2luY2x1c2l2ZSIsImZpbmRfYm91bmQiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJvZl9pdGVyaSIsIm9mX2l0ZXJpX2V4biIsInRfb2Zfc2V4cF9kaXJlY3QiLCJrZXlfb2Zfc2V4cCIsInZhbHVlX29mX3NleHAiLCJzZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJjb21iaW5lX2Vycm9ycyIsImVycm9ycyIsIm9rcyIsInVuemlwIiwibWFwX2tleXMiLCJleG4iLCJtYXBfa2V5c19leG4iLCJyZXN1bHQiLCJ0cmFuc3Bvc2Vfa2V5cyIsIm91dGVyX2NvbXBhcmF0b3IiLCJpbm5lcl9jb21wYXJhdG9yIiwib3V0ZXJfdCIsIm91dGVyX2tleSIsImlubmVyX3QiLCJpbm5lcl9rZXkiLCJhY2NfbGVuIiwiZWx0X2xlbiIsImVsdCIsIk1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyIsIkEiLCJ0cmVlX2ZpbHRlcl9tYXBpIiwicl9sZW4iLCJsX2xlbiIsImxpa2UiLCJsaWtlX21heWJlX25vX29wIiwib2xkX3QiLCJvbGRfdHJlZSIsIndpdGhfc2FtZV9sZW5ndGgiLCJvZl9saWtlX3RyZWUiLCJvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AiLCJ0b190cmVlIiwiaXRlcmlfdW50aWwiLCJvZl9saWtlX3RyZWUyIiwib2ZfbGlrZV90cmVlMl9tYXliZV9ub19vcCIsImNvbXBhcmVfZGlyZWN0IiwibSIsImJvdGhfbGVuIiwic3BsaXRfbGVfZ3QiLCJzcGxpdF9sdF9nZSIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJudGhfZXhuIiwic2V4cF9vZl9rIiwic2V4cF9vZl92IiwiaGFzaF9mb2xkX2RpcmVjdCIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJUcmVlX3RyYXZlcnNhbHMiLCJuZXdfdHJlZSIsIm5ld190cmVlX3dpdGhfbGVuZ3RoIiwic2luZ2xldG9uIiwicmVxdWlyZWRfYnlfaW50ZiIsInJldCIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsImR1cCIsIkJ1aWxkX2luY3JlYXNpbmciLCJvZl90cmVlMCIsInRyZWVfbGVuZ3RoIiwiRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvIiwiSyIsImNvbXBhcmF0b3JfcyIsInRvX2NvbXBhcmF0b3IiLCJhIiwicyIsInNleHBfb2ZfbV90IiwibV90X29mX3NleHAiLCJtX3Rfc2V4cF9ncmFtbWFyIiwidl9ncmFtbWFyIiwiY29tcGFyZV9tX3QiLCJjb21wYXJlX3YiLCJlcXVhbF9tX3QiLCJlcXVhbF92IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfZm9sZF92IiwiQmFzZV9NYXAiLCJUcmVlMF90cmF2ZXJzYWxzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDNnBESTtBQUFBO0FBQUEsRUQ3cERKIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzUyNjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvbGlua2VkX3F1ZXVlMC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydDBcblxudHlwZSAnYSB0ID0gJ2EgU3RkbGliLlF1ZXVlLnRcblxubGV0IGNyZWF0ZSA9IFN0ZGxpYi5RdWV1ZS5jcmVhdGVcbmxldCBjbGVhciA9IFN0ZGxpYi5RdWV1ZS5jbGVhclxubGV0IGNvcHkgPSBTdGRsaWIuUXVldWUuY29weVxubGV0IGlzX2VtcHR5ID0gU3RkbGliLlF1ZXVlLmlzX2VtcHR5XG5sZXQgbGVuZ3RoID0gU3RkbGliLlF1ZXVlLmxlbmd0aFxubGV0IHBlZWsgPSBTdGRsaWIuUXVldWUucGVla1xubGV0IHBvcCA9IFN0ZGxpYi5RdWV1ZS5wb3BcbmxldCBwdXNoID0gU3RkbGliLlF1ZXVlLnB1c2hcbmxldCB0cmFuc2ZlciA9IFN0ZGxpYi5RdWV1ZS50cmFuc2ZlclxuXG5sZXQgaXRlciB0IH4oZiA6IF8gLT4gXykgPVxuICBsZXQgY2FtbF9pdGVyIDogKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdCA9XG4gICAgU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLlF1ZXVlLml0ZXIgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0KVxuICBpblxuICBjYW1sX2l0ZXIgZiB0XG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCBjYW1sX2ZvbGQgOiAoJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIC0+ICdhIHQgLT4gJ2IgPVxuICAgIFN0ZGxpYi5PYmoubWFnaWMgKFN0ZGxpYi5RdWV1ZS5mb2xkIDogKCdiIC0+ICdhIC0+ICdiKSAtPiAnYiAtPiAnYSB0IC0+ICdiKVxuICBpblxuICBjYW1sX2ZvbGQgZiBpbml0IHRcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiU3RkbGliX1F1ZXVlIiwiY3JlYXRlIiwiY2xlYXIiLCJjb3B5IiwiaXNfZW1wdHkiLCJsZW5ndGgiLCJwZWVrIiwicG9wIiwicHVzaCIsInRyYW5zZmVyIiwiaXRlciIsInQiLCJmIiwiY2FtbF9pdGVyIiwiZm9sZCIsImluaXQiLCJjYW1sX2ZvbGQiLCJCYXNlX0xpbmtlZF9xdWV1ZTAiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQUFBQztBQUFBQSxRQUFBQyxZQ2VFO0FBQUEsSUFHQSxzQkFBYTtBQUFBO0FBQUEsWUFBQUMsS0FBQUgsR0FBQUksTUFBQUg7QUFBQUEsUUFBQUksWUFJYjtBQUFBLElBR0EsNEJBQWtCO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EekJwQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1MzA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2xpbmtlZF9xdWV1ZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaW5rZWRfcXVldWUwXG5cbmxldCBlbnF1ZXVlIHQgeCA9IExpbmtlZF9xdWV1ZTAucHVzaCB4IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucG9wIHQpXG5sZXQgZGVxdWV1ZV9leG4gPSBMaW5rZWRfcXVldWUwLnBvcFxubGV0IGRlcXVldWVfYW5kX2lnbm9yZV9leG4gKHR5cGUgZWx0KSAodCA6IGVsdCB0KSA9IGlnbm9yZSAoZGVxdWV1ZV9leG4gdCA6IGVsdClcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbmxldCBkcmFpbiB0IH5mIH53aGlsZV8gPVxuICB3aGlsZSAobm90IChpc19lbXB0eSB0KSkgJiYgd2hpbGVfIChwZWVrX2V4biB0KSBkb1xuICAgIGYgKGRlcXVldWVfZXhuIHQpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBsZXQgZm9sZGkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG5lbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvbGRpID0gQy5mb2xkaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxubGV0IGl0ZXJpID0gQy5pdGVyaVxubGV0IHRyYW5zZmVyIH5zcmMgfmRzdCA9IExpbmtlZF9xdWV1ZTAudHJhbnNmZXIgc3JjIGRzdFxuXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gZW5xdWV1ZSByZXMgKGYgYSkpO1xuICByZXNcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gZW5xdWV1ZSByZXMgKGYgaSBhKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXIgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyaSBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsaXN0ID0gTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnJheSB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGVucXVldWUgdCAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIGxlbmd0aCB0IHdpdGhcbiAgfCAwIC0+IFt8fF1cbiAgfCBsZW4gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW4gKHBlZWtfZXhuIHQpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIgdCB+ZjooZnVuIHYgLT5cbiAgICAgIGFyci4oIWkpIDwtIHY7XG4gICAgICBpbmNyIGkpO1xuICAgIGFyclxuOztcblxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKGxpc3Rfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHNpbmdsZXRvbiBhID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IGE7XG4gIHRcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfTGlzdCIsIlNleHBsaWIwX1NleHBfZ3JhbW1hciIsIkJhc2VfSW1wb3J0IiwiQmFzZV9BcnJheSIsIkJhc2VfTGlua2VkX3F1ZXVlMCIsIkJhc2VfSW5kZXhlZF9jb250YWluZXIiLCJjcmVhdGUiLCJjbGVhciIsImNvcHkiLCJpc19lbXB0eSIsImxlbmd0aCIsIml0ZXIiLCJmb2xkIiwiZW5xdWV1ZSIsInQiLCJ4IiwiZGVxdWV1ZSIsImRlcXVldWVfZXhuIiwiZGVxdWV1ZV9hbmRfaWdub3JlX2V4biIsInBlZWsiLCJwZWVrX2V4biIsImRyYWluIiwid2hpbGUkIiwiQyIsImNvdW50IiwiZXhpc3RzIiwiZmluZCIsImZpbmRfbWFwIiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwiZm9yX2FsbCIsIm1heF9lbHQiLCJtZW0iLCJtaW5fZWx0Iiwic3VtIiwidG9fbGlzdCIsImNvdW50aSIsImV4aXN0c2kiLCJmaW5kX21hcGkiLCJmaW5kaSIsImZvbGRpIiwiZm9yX2FsbGkiLCJpdGVyaSIsInRyYW5zZmVyIiwic3JjIiwiZHN0IiwiY29uY2F0X21hcCIsInJlcyIsImEiLCJiIiwiY29uY2F0X21hcGkiLCJpIiwiZmlsdGVyX21hcCIsIm1hdGNoIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXIiLCJmaWx0ZXJpIiwibWFwIiwibWFwaSIsImZpbHRlcl9pbnBsYWNlIiwicSIsImZpbHRlcmlfaW5wbGFjZSIsImVucXVldWVfYWxsIiwibGlzdCIsIm9mX2xpc3QiLCJvZl9hcnJheSIsImFycmF5IiwiaW5pdCIsImxlbiIsInRvX2FycmF5IiwiYXJyIiwidiIsInRfb2Zfc2V4cCIsImFfb2Zfc2V4cCIsInNleHAiLCJzZXhwX29mX3QiLCJzZXhwX29mX2EiLCJ0X3NleHBfZ3JhbW1h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QXFDLElBQUE7QUFBQTtBQUFBLE1BQ2xCLFdBQVU7QUFBQSxjQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUVqQjtBQUFBLEdBQUM7QUFBQSxZQUFBa0IsU0FBQXZEO0FBQUFBLFFBQUFzRCxNQUlLO0FBQUEsSUFBUSxjQUNQO0FBQUEsWUFFdUIsYUFBQUUsTUFBbEIsbUNBQUFuQixJQUNWO0FBQUEsSUFDQTtBQUFBO0FBQUEsZUFBQW9CO0FBQUFBLFdBQUEsSUFDRTtBQUFBO0FBQUEsT0FBYTtBQUFBO0FBQUEsTUFDUDtBQUFBLElBQUM7QUFBQSxHQUNOO0FBQUEsWUFBQUMsVUFBQUMsV0FBQUM7QUFBQUEsSUFHZ0MsT0FBNkIsUUFBN0IsNkNBQTZCO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxXQUFBOUQ7QUFBQUEsUUFBQSxJQUNqQjtBQUFBLElBQVc7QUFBQTtBQUFBLFlBQUErRCxlQUFBQztBQUFBQSxRQUFBLElBSy9CO0FBQUEsSUFBNkI7QUFBQTtBQUFBLFlBQUFDLFVBQUEvQixPQUFBbEMsSUFJbEQsV0FDUixlQUFXLFNBQ1Y7QUFBQTtBQUFBLElBQUFrRTtBQUFBQSxNRC9KSCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1NTg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ludDY0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuSW50NjRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfaW50NjQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nX29wdCA9IG9mX3N0cmluZ19vcHRcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSA2NFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5cbmV4dGVybmFsIGZsb2F0X29mX2JpdHNcbiAgOiAgKGludDY0W0Bsb2NhbF9vcHRdKVxuICAtPiAoZmxvYXRbQGxvY2FsX29wdF0pXG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdFxuICA6ICAoZmxvYXRbQGxvY2FsX29wdF0pXG4gIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSlcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50NjRfcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gU3RkbGliLkludDY0Lm9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICAgICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDY0Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG4oKiBOb3QgZXRhLWV4cGFuZGluZyBoZXJlIGNhbiBsZWFkIHRvIGxlc3MgYWxsb2NhdGlvbnM6IHRoZSBmdW5jdGlvbiBjYWxsIHNpdGVzIGNhbiBhdm9pZFxuICAgYm94aW5nIHRoZSBpbnQ2NHMgbW9yZSBvZnRlbi4gKilcbmxldCAoICoqICkgPSBwb3dcblxuZXh0ZXJuYWwgYnN3YXA2NCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAxNiB4ID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgNDhcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDMyIHggPVxuICAoKiBUaGlzIGlzIHN0cmljdGx5IGJldHRlciB0aGFuIGNvZXJjaW5nIHRvIGFuIGludDMyIHRvIHBlcmZvcm0gYnl0ZXN3YXAuIENvZXJjaW5nXG4gICAgIGZyb20gYW4gaW50MzIgd2lsbCBhZGQgdW5uZWNlc3Nhcnkgc2hpZnQgb3BlcmF0aW9ucyB0byBzaWduIGV4dGVuZCB0aGUgbnVtYmVyXG4gICAgIGFwcHJvcHJpYXRlbHkuXG4gICopXG4gIFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDMyXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwNDggeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDE2XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgaW5jciByID0gciA6PSBhZGQgIXIgb25lXG5sZXQgZGVjciByID0gciA6PSBzdWIgIXIgb25lXG5cbmV4dGVybmFsIG9mX2ludDY0IDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWlkZW50aXR5XCJcblxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0XG5sZXQgdG9faW50NjQgdCA9IHRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmV4dGVybmFsIHRvX2ludF90cnVuYyA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQzMltAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludF90cnVuY1xuICA6ICAoaW50NjRbQGxvY2FsX29wdF0pXG4gIC0+IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pXG4gID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxuZXh0ZXJuYWwgb2ZfaW50IDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMiA6IChpbnQzMltAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX2ludDMyXCJcblxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252LmludDY0X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5cbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IChuYXRpdmVpbnRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG5cbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IFN0ZGxpYi5JbnQ2NC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBTdGRsaWIuSW50NjQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgU3RkbGliLkludDY0LnByZWQgeCA9IFN0ZGxpYi5JbnQ2NC56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IFN0ZGxpYi5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgaWYgU3RkbGliLkludDY0LmVxdWFsIGkgU3RkbGliLkludDY0Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKFN0ZGxpYi5JbnQ2NC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDY0X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlTHhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiVMeFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NC5IZXhcIlxuZW5kKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnQ2NF9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9fbG9jYWwgPSAoZXF1YWxfaW50NjRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0ICggbGFuZCApID0gKCBsYW5kIClcbiAgbGV0ICggbHNyICkgPSAoIGxzciApXG4gIGxldCBjbHogPSBjbHpcbiAgbGV0IG51bV9iaXRzID0gbnVtX2JpdHNcbiAgbGV0IG9uZSA9IG9uZVxuICBsZXQgdG9faW50X2V4biA9IHRvX2ludF9leG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0XCJcbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9hZGRcIlxuICBleHRlcm5hbCAoIC0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfc3ViXCJcbiAgZXh0ZXJuYWwgKCAqICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X211bFwiXG4gIGV4dGVybmFsICggLyApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9kaXZcIlxuICBleHRlcm5hbCAoIH4tICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2FuZFwiXG4gIGV4dGVybmFsICggbG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X29yXCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X3hvclwiXG5cbiAgbGV0IGxub3QgPSBiaXRfbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKVxuICAgIDogICh0W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKHRbQGxvY2FsX29wdF0pXG4gICAgPSBcIiVpbnQ2NF9sc2xcIlxuXG4gIGV4dGVybmFsICggYXNyIClcbiAgICA6ICAodFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICh0W0Bsb2NhbF9vcHRdKVxuICAgID0gXCIlaW50NjRfYXNyXCJcblxuICBleHRlcm5hbCAoIGxzciApXG4gICAgOiAgKHRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAodFtAbG9jYWxfb3B0XSlcbiAgICA9IFwiJWludDY0X2xzclwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2NF0gYW5kIFtJbnQ2NC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X0x4IiwiY3N0X2FyZ3VtZW50X211c3RfYmVfc3RyaWN0bHlfIiwiY2FtbF9lcXVhbCIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfbmVnIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJtb2R1bGVfbmFtZSIsIlN0ZGxpYl9TY2FuZiIsIkJhc2VfUHJpbnRmIiwiU3RkbGliX0ludDY0IiwiQmFzZV9JbXBvcnQiLCJCYXNlX1NleHAiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0Zsb2F0MCIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfSW50X21hdGgiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX1BvcGNvdW50IiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX0Vycm9yIiwiQmFzZV9JbnRfc3RyaW5nX2NvbnZlcnNpb25zIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJoYXNoYWJsZSIsImNvbXBhcmUiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiaW5jbHVkZSIsImNvbXBhcmF0b3IiLCJudW1fYml0cyIsImZsb2F0X2xvd2VyX2JvdW5kIiwiZmxvYXRfdXBwZXJfYm91bmQiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfcmlnaHQiLCJzaGlmdF9sZWZ0IiwiYml0X25vdCIsImJpdF94b3IiLCJiaXRfb3IiLCJiaXRfYW5kIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwiYWJzIiwicHJlZCIsInN1Y2MiLCJzeW1ib2wiLCJyZW0iLCJuZWciLCJtaW51c19vbmUiLCJvbmUiLCJ6ZXJvIiwidG9fZmxvYXQiLCJvZl9mbG9hdF91bmNoZWNrZWQiLCJvZl9mbG9hdCIsImJzd2FwMTYiLCJic3dhcDMyIiwiYnN3YXA0OCIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiY3N0X21heCIsImNzdF9taW4iLCJjc3RfY2xhbXBfcmVxdWlyZXNfbWluX21heCIsImludmFyaWFudCIsInBhcmFtIiwiYmV0d2VlbiIsInQiLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwibWluIiwibWF4IiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJpbmNyIiwiciIsImRlY3IiLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsInBvcGNvdW50Iiwib2ZfaW50X2V4biIsInRvX2ludCIsInRvX2ludF9leG4iLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnQiLCJ0b19uYXRpdmVpbnRfZXhuIiwicmFpc2VfcyIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImxzciIsImxhbmQiLCJjc3RfSW50NjRfZmxvb3JfbG9nMl9nb3RfaW52YWwiLCJjc3RfSW50NjRfY2VpbF9sb2cyX2dvdF9pbnZhbGkiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJpIiwiY2VpbF9sb2cyIiwidG9fc3RyaW5nX2h1bSIsImNvbXBhcmVfbG9jYWwiLCJhIiwiYiIsInMiLCJIZXgiLCJlcXVhbF9sb2NhbCIsImVxdWFsIiwiY2x6IiwiQmluYXJ5IiwicHAiLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiQmFzZV9JbnQ2NCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUF2QixRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUF3QixjQUFBO0FBQUEsSUFBQUEsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsWUFBQUMsS0FBQUMsR0NhYSwwQkFBTTtBQUFBO0FBQUEsSUFBQUMsWUFBZjtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxRQUFBLE1EYko7QUFBQTtBQUFBLElBQUFDLFlDYUk7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxvQkFvQm9CO0FBQUEsSUFBQUMsb0JBQ0E7QUFBQSxJQUFBQyxzQkFBbUM7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFNBQUE1RDtBQUFBQSxJQW9DekQ7QUFBQSxLQUVLLDZCQUtDO0FBQUEsWUFERjtBQUFBLElBQWMscURBQ1o7QUFBQTtBQUFBLFlBQUE2RCxRQUFBbkM7QUFBQUEsSUFTeUQsT0FBakMsK0JBQWlDLHdCQUFjO0FBQUE7QUFBQSxZQUFBb0MsUUFBQXBDO0FBQUFBLElBTzVDLE9BQWpDLCtCQUFpQyx3QkFBYztBQUFBO0FBQUEsWUFBQXFDLFFBQUFyQztBQUFBQSxJQUdnQixPQUFqQywrQkFBaUMsd0JBQWM7QUFBQTtBQUFBO0FBQUEsSUFBQVMsWUE5RHBCO0FBQUEsSUFBQTZCLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxZQUFBQyxVQUFBQyxPQTJFbkMsU0FBRTtBQUFBLFlBQUFDLFFBQUFDLEdBQUFDLEtBQUFDO0FBQUFBLFFBQUEsSUFDQyw0QkFBUSxJQUFJO0FBQUEsSUFBSjtBQUFBLEdBQWE7QUFBQSxZQUFBQyxnQkFBQUgsR0FBQUksS0FBQUM7QUFBQUEsUUFBQSxJQUNKO0FBQUEsSUFBYyw2Q0FBUTtBQUFBO0FBQUEsWUFBQUMsVUFBQU4sR0FBQUksS0FBQUM7QUFBQUEsSUFHekQsNkJBQ1AsbUNBQTJCO0FBQUEsSUFEUjtBQUFBLEdBQ1E7QUFBQSxZQUFBRSxNQUFBUCxHQUFBSSxLQUFBQztBQUFBQSxJQUl4QixpQ0FNSyx3Q0FBNkI7QUFBQTtBQUFBLFNBREc7QUFBQSxTQUF4QjtBQUFBLFNBRlo7QUFBQSxJQUVzRCxzQ0FDckI7QUFBQTtBQUFBLFlBQUFHLEtBQUFDLEdBR3JCLGtDQUFVO0FBQUEsWUFBQUMsS0FBQUQsR0FDVixrQ0FBVTtBQUFBLFlBQUFFLGFBQUEsR0RqSTVCO0FBQUEsWUFBQUMsU0FBQVosR0NzSWlCLFNBQUM7QUFBQTtBQUFBLElBQUFhLFdBcEd5QztBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsc0JBQUExQjtBQUFBQSxJQXdJdkQsa0RBQTJEO0FBQUE7QUFBQTtBQUFBLElBQUEyQixNQXhJSjtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsWUFBQUMsVUFBQTlFO0FBQUFBLElBaUpwRCx1Q0FBNEI7QUFBQTtBQUFBLEtBQUFBLE1BQ3ZCO0FBQUEsS0FBQUEsTUFDQSxtQkFBTTtBQUFBLEtBQUFBLE1BQ04sbUJBQU07QUFBQSxLQUFBQSxNQUNOLG1CQUFNO0FBQUEsS0FBQUEsTUFDTixtQkFBTTtBQUFBLEtBQUFBLE1BQ04sbUJBQU07QUFBQSxLQUFBQSxNQUNOLG1CQUFNO0FBQUEsSUFDZCxzQ0FBbUI7QUFBQTtBQUFBLFlBQUErRSxXQUFBL0U7QUFBQUEsSUFLaEIseUNBQTRCO0FBQUE7QUFBQSxLQUFBQSxJQUN2QixtQkFBTTtBQUFBLEtBQUFBLE1BQ04saUJBQU07QUFBQSxLQUFBQSxNQUNOLG1CQUFNO0FBQUEsS0FBQUEsTUFDTixtQkFBTTtBQUFBLEtBQUFBLE1BQ04sbUJBQU07QUFBQSxLQUFBQSxNQUNOLG1CQUFNO0FBQUEsSUFDSyxPQUFuQixvQkFBbUIsdUNBQVM7QUFBQTtBQUFBLFlBQUFnRixRQUFBaEY7QUFBQUEsSUFJekIsdUNBQTRCO0FBQUEsWUFDeEI7QUFBQSxXQUFQLDZCQUFPLGtDQUF1QztBQUFBO0FBQUEsWUFBQWlGLFdBQUFDO0FBQUFBLElBa0IzQztBQUFBLGFBRzREO0FBQUEsS0FEN0QsUUFDRTtBQUFBO0FBQUE7QUFBQSxTQUNXO0FBQUEsU0FBZjtBQUFBLElBQVksdUNBQVE7QUFBQTtBQUFBLFlBQUFDLFVBQUFEO0FBQUFBLElBS2pCO0FBQUEsYUFFaUU7QUFBQSxLQUFsRSxRQUFRO0FBQUE7QUFBQSxJQUNQLG9EQUNFO0FBQUEsWUFDVyxnQ0FBSTtBQUFBLElBQXFCO0FBQUE7QUFBQTtBQUFBLElBQUF6RSxZQTFNYztBQUFBLElBQUEyRSxnQkFBQTtBQUFBLElBQUFsRixjQUFBO0FBQUEsSUFBQW1GLGdCQUFBO0FBQUEsWUFBQWhGLFVBQUFpRixHQUFBQyxHQXFOL0Isc0NBQWtCO0FBQUEsT0FBQTFGLGdCQXJOYSxrQkFBQUMsU0FBQTtBQUFBLFlBQUFDLE9BQUFDLEdBNE45Qyw0QkFBTTtBQUFBO0FBQUEsSUFBQTBCLFdBQWY7QUFBQTtBQUFBO0FBQUEsWUFBQXBCLFlBQUE0RTtBQUFBQSxJQVFnQixrREFBc0I7QUFBQTtBQUFBLFlBQUEzRSxZQUFBaUY7QUFBQUEsSUFDdEI7QUFBQSwyRER2UXBCLFdDdVFxRDtBQUFBO0FBQUE7QUFBQSxJQUFBL0U7QUFBQUEsTUFUakQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBZ0YsTUFBQTtBQUFBLElBQUFKLGtCQUFBO0FBQUEsWUFBQWhGLFVBQUFpRixHQUFBQyxHQWlCd0Isd0NBQWtCO0FBQUEsT0FBQUcsY0FqQjFDO0FBQUEsWUFBQUMsTUFBQUwsR0FBQUMsR0FtQnNCLG9DQUFnQjtBQUFBLE9BQUExRixnQkFuQnRDLGtCQUFBQyxTQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0EwQlMsNEJBQU07QUFBQSxZQUFBNEYsSUFBQSxHRHhSbkI7QUFBQTtBQUFBLElBQUFuRjtBQUFBQSxNQ3dSSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFvRixTQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFyRjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBaUIsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQXFFLFFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBMUYsWUFBQTtBQUFBLElBQUEyRixZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUEvQyxNQUFBO0FBQUEsSUFBQUQsTUFBQTtBQUFBLElBQUFpRDtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkR4Uko7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0N3Ukk7QUFBQTtBQUFBLEVEeFJKIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzYwMDQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvaW50NjNfZW11bC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIEEgNjNiaXQgaW50ZWdlciBpcyBhIDY0Yml0IGludGVnZXIgd2l0aCBpdHMgYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICBhbmQgaXRzIGxvd2VzdCBiaXQgc2V0IHRvIDAuXG4gICBUaGlzIGlzIHRoZSBzYW1lIGtpbmQgb2YgZW5jb2RpbmcgYXMgT0NhbWwgaW50IG9uIDY0Yml0IGFyY2hpdGVjdHVyZS5cbiAgIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhlIGxvd2VzdCBiaXQgKGltbWVkaWF0ZSBiaXQpIHNldCB0byAxLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBUMCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0XG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDY0X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gICAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICAgIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfaW50NjQgOiB0IC0+IHQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbm1vZHVsZSBXIDogc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuICBlbmRcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIHZhbCB3cmFwX2V4biA6IFN0ZGxpYi5JbnQ2NC50IC0+IHRcbiAgdmFsIHdyYXBfbW9kdWxvIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgdW53cmFwIDogdCAtPiBTdGRsaWIuSW50NjQudFxuXG4gICgqKiBSZXR1cm5zIGEgbm9uLW5lZ2F0aXZlIGludDY0IHRoYXQgaXMgZXF1YWwgdG8gdGhlIGlucHV0IGludDYzIG1vZHVsbyAyXjYzLiAqKVxuICB2YWwgdW53cmFwX3Vuc2lnbmVkIDogdCAtPiBTdGRsaWIuSW50NjQudFxuXG4gIHZhbCBpbnZhcmlhbnQgOiB0IC0+IHVuaXRcbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdWIgOiB0IC0+IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBhYnMgOiB0IC0+IHRcbiAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgdmFsIHByZWQgOiB0IC0+IHRcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGl2IDogdCAtPiB0IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3Bjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBiaXRfbm90IDogdCAtPiB0XG4gIHZhbCBiaXRfeG9yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9vciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfYW5kIDogdCAtPiB0IC0+IHRcbiAgdmFsIHNoaWZ0X2xlZnQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBtaW5fdmFsdWUgOiB0XG4gIHZhbCBtYXhfdmFsdWUgOiB0XG4gIHZhbCB0b19pbnQ2NCA6IHQgLT4gU3RkbGliLkludDY0LnRcbiAgdmFsIG9mX2ludDY0IDogU3RkbGliLkludDY0LnQgLT4gdCBvcHRpb25cbiAgdmFsIG9mX2ludDY0X2V4biA6IFN0ZGxpYi5JbnQ2NC50IC0+IHRcbiAgdmFsIG9mX2ludDY0X3RydW5jIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWxfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGNlaWxfcG93MiA6IHQgLT4gdFxuICB2YWwgZmxvb3JfcG93MiA6IHQgLT4gdFxuICB2YWwgY2VpbF9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGZsb29yX2xvZzIgOiB0IC0+IGludFxuICB2YWwgaXNfcG93MiA6IHQgLT4gYm9vbFxuICB2YWwgY2x6IDogdCAtPiBpbnRcbiAgdmFsIGN0eiA6IHQgLT4gaW50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUMFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgbGV0IHdyYXBfZXhuIHggPVxuICAgICgqIFJhaXNlcyBpZiB0aGUgaW50NjQgdmFsdWUgZG9lcyBub3QgZml0IG9uIGludDYzLiAqKVxuICAgIENvbnYuaW50NjRfZml0X29uX2ludDYzX2V4biB4O1xuICAgIFN0ZGxpYi5JbnQ2NC5tdWwgeCAyTFxuICA7O1xuXG4gIGxldCB3cmFwIHggPVxuICAgIGlmIENvbnYuaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gU29tZSAoU3RkbGliLkludDY0Lm11bCB4IDJMKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgd3JhcF9tb2R1bG8geCA9IFN0ZGxpYi5JbnQ2NC5tdWwgeCAyTFxuICBsZXQgdW53cmFwIHggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgeCAxXG4gIGxldCB1bndyYXBfdW5zaWduZWQgeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggMVxuXG4gICgqIFRoaXMgZG9lcyBub3QgdXNlIHdyYXAgb3IgdW53cmFwIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBpbiB0aGUgY2FzZSBvZlxuICAgICBvdmVyZmxvd3MuIFRoaXMgaXMgdG8gcHJlc2VydmUgdGhlIHNlbWFudGljcyBvZiBpbnQgdHlwZSBvbiA2NCBiaXQgYXJjaGl0ZWN0dXJlLiAqKVxuICBsZXQgZjIgZiBhIGIgPVxuICAgIFN0ZGxpYi5JbnQ2NC5tdWwgKGYgKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCBhIDEpIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgYiAxKSkgMkxcbiAgOztcblxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZUxcbiAgbGV0IG0geCA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmQgeCBtYXNrXG4gIGxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAobSB0ID0gdClcbiAgbGV0IGFkZCB4IHkgPSBTdGRsaWIuSW50NjQuYWRkIHggeVxuICBsZXQgc3ViIHggeSA9IFN0ZGxpYi5JbnQ2NC5zdWIgeCB5XG4gIGxldCBuZWcgeCA9IFN0ZGxpYi5JbnQ2NC5uZWcgeFxuICBsZXQgYWJzIHggPSBTdGRsaWIuSW50NjQuYWJzIHhcbiAgbGV0IG9uZSA9IHdyYXBfZXhuIDFMXG4gIGxldCBzdWNjIGEgPSBhZGQgYSBvbmVcbiAgbGV0IHByZWQgYSA9IHN1YiBhIG9uZVxuICBsZXQgbWluX3ZhbHVlID0gbSBTdGRsaWIuSW50NjQubWluX2ludFxuICBsZXQgbWF4X3ZhbHVlID0gbSBTdGRsaWIuSW50NjQubWF4X2ludFxuICBsZXQgYml0X25vdCB4ID0gbSAoU3RkbGliLkludDY0LmxvZ25vdCB4KVxuICBsZXQgYml0X2FuZCA9IFN0ZGxpYi5JbnQ2NC5sb2dhbmRcbiAgbGV0IGJpdF94b3IgPSBTdGRsaWIuSW50NjQubG9neG9yXG4gIGxldCBiaXRfb3IgPSBTdGRsaWIuSW50NjQubG9nb3JcbiAgbGV0IHNoaWZ0X2xlZnQgeCBpID0gU3RkbGliLkludDY0LnNoaWZ0X2xlZnQgeCBpXG4gIGxldCBzaGlmdF9yaWdodCB4IGkgPSBtIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgeCBpKVxuICBsZXQgc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkgPSBtIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkpXG4gIGxldCBwb3cgPSBmMiBJbnRfbWF0aC5Qcml2YXRlLmludDYzX3Bvd19vbl9pbnQ2NFxuICBsZXQgbXVsIGEgYiA9IFN0ZGxpYi5JbnQ2NC5tdWwgYSAoU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSlcbiAgbGV0IGRpdiBhIGIgPSB3cmFwX21vZHVsbyAoU3RkbGliLkludDY0LmRpdiBhIGIpXG4gIGxldCByZW0gYSBiID0gU3RkbGliLkludDY0LnJlbSBhIGJcbiAgbGV0IHBvcGNvdW50IHggPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudCB4XG4gIGxldCB0b19pbnQ2NCB0ID0gdW53cmFwIHRcbiAgbGV0IG9mX2ludDY0IHQgPSB3cmFwIHRcbiAgbGV0IG9mX2ludDY0X2V4biB0ID0gd3JhcF9leG4gdFxuICBsZXQgb2ZfaW50NjRfdHJ1bmMgdCA9IHdyYXBfbW9kdWxvIHRcbiAgbGV0IHRfb2Zfc2V4cCB4ID0gd3JhcF9leG4gKGludDY0X29mX3NleHAgeClcbiAgbGV0IHNleHBfb2ZfdCB4ID0gc2V4cF9vZl9pbnQ2NCAodW53cmFwIHgpXG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IHQpIHkgPSBjb21wYXJlX19sb2NhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IHQpIHkgPSBlcXVhbF9fbG9jYWwgeCB5XG4gIGxldCBpc19wb3cyIHggPSBJbnQ2NC5pc19wb3cyICh1bndyYXAgeClcblxuICBsZXQgY2x6IHggPVxuICAgICgqIFdlIHJ1biBJbnQ2NC5jbHogZGlyZWN0bHkgb24gdGhlIHdyYXBwZWQgaW50NjMgdmFsdWUuIFRoaXMgaXMgY29ycmVjdCBiZWNhdXNlIHRoZVxuICAgICAgIGJpdHMgb2YgdGhlIGludDYzX2VtdWwgYXJlIGxlZnQtYWxpZ25lZCBpbiB0aGUgSW50NjQuICopXG4gICAgSW50NjQuY2x6IHhcbiAgOztcblxuICBsZXQgY3R6IHggPSBJbnQ2NC5jdHogKHVud3JhcCB4KVxuICBsZXQgZmxvb3JfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBjZWlsX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgZmxvb3JfbG9nMiB4ID0gSW50NjQuZmxvb3JfbG9nMiAodW53cmFwIHgpXG4gIGxldCBjZWlsX2xvZzIgeCA9IEludDY0LmNlaWxfbG9nMiAodW53cmFwIHgpXG5lbmRcblxub3BlbiBXXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFcudCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKFcuZ2xvYmFsaXplIDogdCAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBXLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChXLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKFcuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IFcuY29tcGFyYXRvclxuICBsZXQgY29tcGFyZSA9IFcuY29tcGFyZVxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSBXLmNvbXBhcmVfX2xvY2FsXG4gIGxldCBlcXVhbF9fbG9jYWwgPSBXLmVxdWFsX19sb2NhbFxuICBsZXQgaW52YXJpYW50ID0gVy5pbnZhcmlhbnRcblxuICAoKiBXZSBkb24ndCBleHBlY3QgW2hhc2hdIHRvIGZvbGxvdyB0aGUgYmVoYXZpb3Igb2YgaW50IGluIDY0Yml0IGFyY2hpdGVjdHVyZSAqKVxuICBsZXQgXyA9IGhhc2hcbiAgbGV0IGhhc2ggKHggOiB0KSA9IFN0ZGxpYi5IYXNodGJsLmhhc2ggeFxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBpbnZhbGlkX3N0ciB4ID0gUHJpbnRmLmZhaWx3aXRoZiBcIkludDYzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIHggKClcblxuICAoKlxuICAgICBcInNpZ25cIiByZWZlcnMgdG8gd2hldGhlciB0aGUgbnVtYmVyIHN0YXJ0cyB3aXRoIGEgJy0nXG4gICAgIFwic2lnbmVkbmVzcyA9IGZhbHNlXCIgbWVhbnMgdGhlIHJlc3Qgb2YgdGhlIG51bWJlciBpcyBwYXJzZWQgYXMgdW5zaWduZWQgYW5kIHRoZW4gY2FzdFxuICAgICB0byBzaWduZWQgd2l0aCB3cmFwLWFyb3VuZCBtb2R1bG8gMl5pXG4gICAgIFwic2lnbmVkbmVzcyA9IHRydWVcIiBtZWFucyBubyBzdWNoIGNyYXppbmVzcyBoYXBwZW5zXG5cbiAgICAgVGhlIHRlcm1pbm9sb2d5IGFuZCB0aGUgbG9naWMgaXMgZHVlIHRvIHRoZSBjb2RlIGluIGJ5dGVydW4vaW50cy5jIGluIG9jYW1sIDQuMDNcbiAgICAgKFtwYXJzZV9zaWduX2FuZF9iYXNlXSBmdW5jdGlvbikuXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgdHJ1ZSBmb3IgcGxhaW4gZGVjaW1hbCBudW1iZXIgKGUuZy4gMTIzNSwgLTY3ODkpXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgZmFsc2UgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgLSBbMHhmZmZmXSwgWy0weGZmZmZdIChoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMGIwMTAxXSwgWy0wYjAxMDFdIChiaW5hcnkgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBvMTIzN10sIFstMG8xMjM3XSAob2N0YWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzB1OTgxMl0sIFstMHU5ODEyXSAodW5zaWduZWQgZGVjaW1hbCByZXByZXNlbnRhdGlvbiAtIGF2YWlsYWJsZSBmcm9tIE9DYW1sIDQuMDMpICopXG4gIGxldCBzaWduX2FuZF9zaWduZWRuZXNzIHggPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHBvcywgc2lnbiA9XG4gICAgICBpZiAwIDwgbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggeC5bMF0gd2l0aFxuICAgICAgICB8ICctJyAtPiAxLCBgTmVnXG4gICAgICAgIHwgJysnIC0+IDEsIGBQb3NcbiAgICAgICAgfCBfIC0+IDAsIGBQb3MpXG4gICAgICBlbHNlIDAsIGBQb3NcbiAgICBpblxuICAgIGlmIHBvcyArIDIgPCBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBjMSA9IHguW3Bvc10gaW5cbiAgICAgIGxldCBjMiA9IHguW3BvcyArIDFdIGluXG4gICAgICBtYXRjaCBjMSwgYzIgd2l0aFxuICAgICAgfCAnMCcsICcwJyAuLiAnOScgLT4gc2lnbiwgdHJ1ZVxuICAgICAgfCAnMCcsIF8gLT4gc2lnbiwgZmFsc2VcbiAgICAgIHwgXyAtPiBzaWduLCB0cnVlKVxuICAgIGVsc2Ugc2lnbiwgdHJ1ZVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgeCA9IFN0ZGxpYi5JbnQ2NC50b19zdHJpbmcgKHVud3JhcCB4KVxuXG4gIGxldCBvZl9zdHJpbmdfcmF3IHN0ciA9XG4gICAgbGV0IHNpZ24sIHNpZ25lZG5lc3MgPSBzaWduX2FuZF9zaWduZWRuZXNzIHN0ciBpblxuICAgIGlmIHNpZ25lZG5lc3NcbiAgICB0aGVuIG9mX2ludDY0X2V4biAoU3RkbGliLkludDY0Lm9mX3N0cmluZyBzdHIpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcG9zX3N0ciA9XG4gICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICB8IGBOZWcgLT4gU3RyaW5nLnN1YiBzdHIgfnBvczoxIH5sZW46KFN0cmluZy5sZW5ndGggc3RyIC0gMSlcbiAgICAgICAgfCBgUG9zIC0+IHN0clxuICAgICAgaW5cbiAgICAgIGxldCBpbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9zdHJpbmcgcG9zX3N0ciBpblxuICAgICAgKCogdW5zaWduZWQgNjMtYml0IGludCBtdXN0IHBhcnNlIGFzIGEgcG9zaXRpdmUgc2lnbmVkIDY0LWJpdCBpbnQgKilcbiAgICAgIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpbnQ2NCAwTCB0aGVuIGludmFsaWRfc3RyIHN0cjtcbiAgICAgIGxldCBpbnQ2MyA9IHdyYXBfbW9kdWxvIGludDY0IGluXG4gICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgIHwgYE5lZyAtPiBuZWcgaW50NjNcbiAgICAgIHwgYFBvcyAtPiBpbnQ2MylcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgdHJ5IG9mX3N0cmluZ19yYXcgc3RyIHdpdGhcbiAgICB8IF8gLT4gaW52YWxpZF9zdHIgc3RyXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZ19vcHQgc3RyID1cbiAgICBtYXRjaCBvZl9zdHJpbmdfcmF3IHN0ciB3aXRoXG4gICAgfCB0IC0+IFNvbWUgdFxuICAgIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBic3dhcDE2IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAxNiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXAzMiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMzIgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwNDggdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDQ4ICh1bndyYXAgdCkpXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBudW1fYml0cyA9IDYzXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBiaXRfbm90XG5sZXQgYml0X3hvciA9IGJpdF94b3JcbmxldCBiaXRfb3IgPSBiaXRfb3JcbmxldCBiaXRfYW5kID0gYml0X2FuZFxubGV0IHBvcGNvdW50ID0gcG9wY291bnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWF4X3ZhbHVlID0gbWF4X3ZhbHVlXG5sZXQgbWluX3ZhbHVlID0gbWluX3ZhbHVlXG5sZXQgbWludXNfb25lID0gd3JhcF9leG4gU3RkbGliLkludDY0Lm1pbnVzX29uZVxubGV0IG9uZSA9IHdyYXBfZXhuIFN0ZGxpYi5JbnQ2NC5vbmVcbmxldCB6ZXJvID0gd3JhcF9leG4gU3RkbGliLkludDY0Lnplcm9cbmxldCBpc19wb3cyID0gaXNfcG93MlxubGV0IGZsb29yX3BvdzIgPSBmbG9vcl9wb3cyXG5sZXQgY2VpbF9wb3cyID0gY2VpbF9wb3cyXG5sZXQgZmxvb3JfbG9nMiA9IGZsb29yX2xvZzJcbmxldCBjZWlsX2xvZzIgPSBjZWlsX2xvZzJcbmxldCBjbHogPSBjbHpcbmxldCBjdHogPSBjdHpcbmxldCB0b19mbG9hdCB4ID0gU3RkbGliLkludDY0LnRvX2Zsb2F0ICh1bndyYXAgeClcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgeCA9IHdyYXBfbW9kdWxvIChTdGRsaWIuSW50NjQub2ZfZmxvYXQgeClcblxubGV0IG9mX2Zsb2F0IHQgPVxuICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgdCA+PSBmbG9hdF9sb3dlcl9ib3VuZCAmJiB0IDw9IGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gd3JhcF9tb2R1bG8gKFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdCB0KVxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2My5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IG9mX2ludDY0ID0gb2ZfaW50NjRcbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IG9mX2ludDY0X3RydW5jXG5sZXQgdG9faW50NjQgPSB0b19pbnQ2NFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5cbigqIFdlIGNhbiByZXVzZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20vdG8gaW50NjQgaGVyZS4gKilcbmxldCBvZl9pbnQgeCA9IHdyYXBfZXhuIChDb252LmludF90b19pbnQ2NCB4KVxubGV0IG9mX2ludF9leG4geCA9IG9mX2ludCB4XG5sZXQgdG9faW50IHggPSBDb252LmludDY0X3RvX2ludCAodW53cmFwIHgpXG5sZXQgdG9faW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50X3RydW5jICh1bndyYXAgeClcbmxldCBvZl9pbnQzMiB4ID0gd3JhcF9leG4gKENvbnYuaW50MzJfdG9faW50NjQgeClcbmxldCBvZl9pbnQzMl9leG4geCA9IG9mX2ludDMyIHhcbmxldCB0b19pbnQzMiB4ID0gQ29udi5pbnQ2NF90b19pbnQzMiAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfZXhuIHggPSBDb252LmludDY0X3RvX2ludDMyX2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX25hdGl2ZWludCB4ID0gb2ZfaW50NjQgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X2V4biB4ID0gd3JhcF9leG4gKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jIHggPSBvZl9pbnQ2NF90cnVuYyAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCB0b19uYXRpdmVpbnQgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50ICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfZXhuIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgKHVud3JhcCB4KVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoVC5jb21wYXJlX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSAoIH4tIClcbiAgbGV0ICggPCApID0gKCA8IClcblxuICBsZXQgdG9fc3RyaW5nIGkgPVxuICAgICgqIHRoZSB1c2Ugb2YgW3Vud3JhcF91bnNpZ25lZF0gaGVyZSBpcyBpbXBvcnRhbnQgZm9yIHRoZSBjYXNlIG9mIFttaW5fdmFsdWVdICopXG4gICAgUHJpbnRmLnNwcmludGYgXCIlTHhcIiAodW53cmFwX3Vuc2lnbmVkIGkpXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzID0gb2Zfc3RyaW5nIChcIjB4XCIgXiBzKVxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjMuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyB4ID0gdG9fc3RyaW5nIHhcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzXCJcbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgbGV0IHJlbSA9IHJlbVxuICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2JpbmFyeSAoc3RydWN0XG4gIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoVC5jb21wYXJlX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChULmVxdWFsX19sb2NhbCA6IHQgLT4gdCAtPiBib29sKVxuICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIFQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBULmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCAoIGxhbmQgKSA9ICggbGFuZCApXG4gIGxldCAoIGxzciApID0gKCBsc3IgKVxuICBsZXQgY2x6ID0gY2x6XG4gIGxldCBudW1fYml0cyA9IG51bV9iaXRzXG4gIGxldCBvbmUgPSBvbmVcbiAgbGV0IHRvX2ludF9leG4gPSB0b19pbnRfZXhuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG4oKiBbSW50NjNdIGFuZCBbSW50NjMuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIGVtdWxhdGVkID0gdFxuXG4gIHR5cGUgKCd1bmRlcmx5aW5nX3R5cGUsICdpbnRlcm1lZGlhdGVfdHlwZSkgdCA9XG4gICAgfCBJbnQgOiAoaW50LCBpbnQpIHRcbiAgICB8IEludDY0IDogKGludDY0LCBlbXVsYXRlZCkgdFxuZW5kXG5cbmxldCByZXByID0gUmVwci5JbnQ2NFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfaW50NjNfZW11bF9tbCIsImNhbWxfZXF1YWwiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ3JlYXRlcnRoYW4iLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X211bCIsImNhbWxfaW50NjRfbmVnIiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZSIsImNhbWxfaW50NjRfc3ViIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwibWFzayIsIm1vZHVsZV9uYW1lIiwiQmFzZV9JbXBvcnQiLCJCYXNlX1ByaW50ZiIsIkJhc2VfSW50X2NvbnZlcnNpb25zIiwiQmFzZV9TZXhwIiwiQmFzZV9Pcl9lcnJvciIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9GbG9hdDAiLCJCYXNlX0ludDY0IiwiQmFzZV9TdHJpbmciLCJTdGRsaWJfSW50NjQiLCJCYXNlX1BvcGNvdW50IiwiQmFzZV9Db21wYXJhdG9yIiwiQmFzZV9JbnRfbWF0aCIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfSW50X3N0cmluZ19jb252ZXJzaW9ucyIsIkJhc2VfUHJldHR5X3ByaW50ZXIiLCJpbmNsdWRlIiwibWF4IiwibWluIiwiY29tcGFyZV9sb2NhbCIsImNvbXBhcmUiLCJhIiwiYiIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90Iiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJjb21wYXJhdG9yIiwid3JhcF9leG4iLCJ4IiwidW53cmFwIiwiaW52YXJpYW50IiwidCIsInN5bWJvbCIsImFicyIsIm9uZSIsInN1Y2MiLCJwcmVkIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwiYml0X25vdCIsImJpdF9hbmQiLCJiaXRfeG9yIiwiYml0X29yIiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0IiwiaSIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwiLCJwb3ciLCJyZW0iLCJwb3Bjb3VudCIsInRvX2ludDY0Iiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4iLCJvZl9pbnQ2NF90cnVuYyIsInRfb2Zfc2V4cCIsInkiLCJlcXVhbF9sb2NhbCIsImlzX3BvdzIiLCJjbHoiLCJjdHoiLCJmbG9vcl9wb3cyIiwiY2VpbF9wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsImhhc2giLCJoYXNoYWJsZSIsImludmFsaWRfc3RyIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX3JhdyIsInN0ciIsImxlbiIsInN3aXRjaGVyIiwic2lnbiIsInBvcyIsImMxIiwiYzIiLCJtYXRjaCIsInNpZ25lZG5lc3MiLCJwb3Nfc3RyIiwiaW50NjQiLCJpbnQ2MyIsIm9mX3N0cmluZyIsImV4biIsIm9mX3N0cmluZ19vcHQiLCJic3dhcDE2IiwiYnN3YXAzMiIsImJzd2FwNDgiLCJudW1fYml0cyIsImZsb2F0X2xvd2VyX2JvdW5kIiwiZmxvYXRfdXBwZXJfYm91bmQiLCJtaW51c19vbmUiLCJ6ZXJvIiwidG9fZmxvYXQiLCJvZl9mbG9hdF91bmNoZWNrZWQiLCJvZl9mbG9hdCIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJjc3RfbWF4IiwiY3N0X21pbiIsImNzdF9jbGFtcF9yZXF1aXJlc19taW5fbWF4IiwiYmV0d2VlbiIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJjbGFtcF9leG4iLCJjbGFtcCIsImUiLCJpbmNyIiwiciIsImRlY3IiLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidG9faW50IiwidG9faW50X2V4biIsInRvX2ludF90cnVuYyIsIm9mX2ludDMyIiwib2ZfaW50MzJfZXhuIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJ0b19pbnQzMl90cnVuYyIsIm9mX25hdGl2ZWludCIsIm9mX25hdGl2ZWludF9leG4iLCJvZl9uYXRpdmVpbnRfdHJ1bmMiLCJ0b19uYXRpdmVpbnQiLCJ0b19uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50X3RydW5jIiwidG9fc3RyaW5nX2h1bSIsImNzdF8weCIsInMiLCJIZXgiLCJwcCIsInJvdW5kIiwicm91bmRfdG93YXJkc196ZXJvIiwicm91bmRfZG93biIsInJvdW5kX3VwIiwicm91bmRfbmVhcmVzdCIsImVxdWFsIiwiQmluYXJ5IiwiUmVwciIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJCYXNlX0ludDYzX2VtdWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMs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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUE0SCxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUE3SCxZQUFBO0FBQUEsSUFBQThILFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQTlILFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQThIO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCRG5kSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDbWRJO0FBQUE7QUFBQSxFRG5kSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NTkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ludDMyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuSW50MzJcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoZ2xvYmFsaXplIDogdCAtPiB0KSA9IChnbG9iYWxpemVfaW50MzIgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDMyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDMyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDMyX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbiAgbGV0IG9mX3N0cmluZ19vcHQgPSBvZl9zdHJpbmdfb3B0XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxubGV0IG51bV9iaXRzID0gMzJcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X29mX2JpdHMgPSBmbG9hdF9vZl9iaXRzXG5sZXQgYml0c19vZl9mbG9hdCA9IGJpdHNfb2ZfZmxvYXRcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCBjb21wYXJlID0gY29tcGFyZVxubGV0IGNvbXBhcmVfX2xvY2FsID0gU3RkbGliLmNvbXBhcmVcbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgICAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQzMi5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG5tb2R1bGUgSW5maXhfY29tcGFyZSA9IHN0cnVjdFxuICBvcGVuIFBvbHlcblxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IHggPj0geVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IHggPD0geVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IHggPiB5XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSB4IDwgeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IHggPD4geVxuZW5kXG5cbm1vZHVsZSBDb21wYXJlID0gc3RydWN0XG4gIGluY2x1ZGUgSW5maXhfY29tcGFyZVxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSBjb21wYXJlX19sb2NhbFxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWluIHggeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbiAgbGV0IG1heCB4IHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbjptaW5fIH5tYXg6bWF4XyA9IG1pbiB0IG1heF8gfD4gbWF4IG1pbl9cblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfaW50MzIgdCA9IHRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyIHQgPSB0XG5sZXQgdG9faW50MzJfZXhuID0gdG9faW50MzJcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDMyX3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmxldCBvZl9pbnQgPSBDb252LmludF90b19pbnQzMlxubGV0IG9mX2ludF9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnRfdHJ1bmMgPSBDb252LmludF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludCA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYuaW50MzJfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYuaW50MzJfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXAzMiA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVic3dhcF9pbnQzMlwiXG5cbmxldCBic3dhcDE2IHggPSBTdGRsaWIuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXAzMiB4KSAxNlxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBTdGRsaWIuSW50MzIubG9nb3JcbiAgbGV0ICggbHNyICkgPSBTdGRsaWIuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBTdGRsaWIuSW50MzIubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBTdGRsaWIuSW50MzIucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBTdGRsaWIuSW50MzIuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgU3RkbGliLkludDMyLnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gU3RkbGliLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIFN0ZGxpYi5JbnQzMi5wcmVkIHggPSBTdGRsaWIuSW50MzIuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludDMyIGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IFN0ZGxpYi5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBTdGRsaWIuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQzMi5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgKCogVGhlIFtpID0gMV0gY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgY2x6KDApIGlzIHVuZGVmaW5lZCAqKVxuICAgIGlmIFN0ZGxpYi5JbnQzMi5lcXVhbCBpIFN0ZGxpYi5JbnQzMi5vbmVcbiAgICB0aGVuIDBcbiAgICBlbHNlIG51bV9iaXRzIC0gY2x6IChTdGRsaWIuSW50MzIucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2UgKFQpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2hleCAoc3RydWN0XG4gIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnQzMl9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgbmVnID0gKCB+LSApXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJWx4XCIgaVxuICBsZXQgb2Zfc3RyaW5nIHMgPSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCIlbHhcIiBGbi5pZFxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzIuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfYmluYXJ5IChzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50MzJfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgZXF1YWxfX2xvY2FsID0gKGVxdWFsX2ludDMyX19sb2NhbCA6IHQgLT4gdCAtPiBib29sKVxuICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCAoIGxhbmQgKSA9ICggbGFuZCApXG4gIGxldCAoIGxzciApID0gKCBsc3IgKVxuICBsZXQgY2x6ID0gY2x6XG4gIGxldCBudW1fYml0cyA9IG51bV9iaXRzXG4gIGxldCBvbmUgPSBvbmVcbiAgbGV0IHRvX2ludF9leG4gPSB0b19pbnRfZXhuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMlwiXG5lbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChDb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDMyXSBhbmQgW0ludDMyLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2x4IiwiY3N0X2FyZ3VtZW50X211c3RfYmVfc3RyaWN0bHlfIiwiY2FtbF9lcXVhbCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9ncmVhdGVydGhhbiIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIm1vZHVsZV9uYW1lIiwiU3RkbGliX1NjYW5mIiwiQmFzZV9QcmludGYiLCJTdGRsaWJfSW50MzIiLCJCYXNlX0ltcG9ydCIsIkJhc2VfU2V4cCIsIkJhc2VfSW50X21hdGgiLCJCYXNlX09yX2Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0Zsb2F0MCIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfQ29tcGFyYWJsZSIsIkJhc2VfUG9wY291bnQiLCJCYXNlX0ludF9jb252ZXJzaW9ucyIsIkJhc2VfRXJyb3IiLCJCYXNlX0ludF9zdHJpbmdfY29udmVyc2lvbnMiLCJCYXNlX1ByZXR0eV9wcmludGVyIiwiZ2xvYmFsaXplIiwiaGFzaF9mb2xkX3QiLCJmdW5jIiwiaGFzaCIsIngiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJ0X3NleHBfZ3JhbW1hciIsImhhc2hhYmxlIiwiYXNjZW5kaW5nIiwieSIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJpbmNsdWRlIiwiY29tcGFyYXRvciIsIm51bV9iaXRzIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0Iiwic2hpZnRfcmlnaHRfbG9naWNhbCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfeG9yIiwiYml0X29yIiwiYml0X2FuZCIsIm1pbl92YWx1ZSIsIm1heF92YWx1ZSIsImFicyIsInByZWQiLCJzdWNjIiwicmVtIiwic3ltYm9sIiwibWludXNfb25lIiwib25lIiwiemVybyIsImNvbXBhcmVfbG9jYWwiLCJ0b19mbG9hdCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsIm9mX2Zsb2F0IiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iLCJkZXNjZW5kaW5nIiwibWluIiwibWF4IiwiZXF1YWwiLCJlcXVhbF9sb2NhbCIsImNzdF9tYXgiLCJjc3RfbWluIiwiY3N0X2NsYW1wX3JlcXVpcmVzX21pbl9tYXgiLCJiZXR3ZWVuIiwidCIsImxvdyIsImhpZ2giLCJjbGFtcF91bmNoZWNrZWQiLCJjbGFtcF9leG4iLCJjbGFtcCIsImludmFyaWFudCIsInBhcmFtIiwiaW5jciIsInIiLCJkZWNyIiwib2ZfaW50MzIiLCJ0b19pbnQzMiIsInBvcGNvdW50Iiwib2ZfaW50Iiwib2ZfaW50X2V4biIsIm9mX2ludF90cnVuYyIsInRvX2ludCIsInRvX2ludF9leG4iLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQ2NCIsIm9mX2ludDY0X2V4biIsIm9mX2ludDY0X3RydW5jIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwib2ZfbmF0aXZlaW50X3RydW5jIiwidG9fbmF0aXZlaW50IiwicG93IiwiYiIsImUiLCJic3dhcDE2IiwicmFpc2VfcyIsImNzdF9JbnQzMl9mbG9vcl9sb2cyX2dvdF9pbnZhbCIsImNzdF9JbnQzMl9jZWlsX2xvZzJfZ290X2ludmFsaSIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImxzciIsImxhbmQiLCJjZWlsX3BvdzIiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJpIiwiY2VpbF9sb2cyIiwidG9fc3RyaW5nX2h1bSIsImNvbXBhcmUiLCJhIiwicyIsIkhleCIsImNseiIsIkJpbmFyeSIsInBwIiwicm91bmQiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJyb3VuZF9kb3duIiwicm91bmRfdXAiLCJyb3VuZF9uZWFyZXN0IiwiQmFzZV9JbnQzMiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFkLFFBQUE7QUFBQSxJQUFBQSxNQUFBO0FBQUEsSUFBQWUsY0FBQTtBQUFBLElBQUFBLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CRGpSSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDaVJJO0FBQUE7QUFBQSxFRGpSSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3MDc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2ludDYzLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgUmVwciA9IEludDYzX2VtdWwuUmVwclxuaW5jbHVkZSBTeXMwLk1ha2VfaW1tZWRpYXRlNjQgKEludCkgKEludDYzX2VtdWwpXG5cbm1vZHVsZSBCYWNrZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgSW50X2ludGYuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgdG9faW50IDogdCAtPiBpbnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50XG4gICAgdmFsIG9mX2ludDMyIDogaW50MzIgLT4gdFxuICAgIHZhbCB0b19pbnQzMiA6IHQgLT4gSW50MzIudCBvcHRpb25cbiAgICB2YWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IEludDMyLnRcbiAgICB2YWwgb2ZfaW50NjQgOiBJbnQ2NC50IC0+IHQgb3B0aW9uXG4gICAgdmFsIG9mX2ludDY0X3RydW5jIDogSW50NjQudCAtPiB0XG4gICAgdmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiB0IG9wdGlvblxuICAgIHZhbCB0b19uYXRpdmVpbnQgOiB0IC0+IG5hdGl2ZWludCBvcHRpb25cbiAgICB2YWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHRcbiAgICB2YWwgdG9fbmF0aXZlaW50X3RydW5jIDogdCAtPiBuYXRpdmVpbnRcbiAgICB2YWwgb2ZfZmxvYXRfdW5jaGVja2VkIDogZmxvYXQgLT4gdFxuICAgIHZhbCByZXByIDogKHQsIHQpIEludDYzX2VtdWwuUmVwci50XG4gICAgdmFsIGJzd2FwMTYgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXAzMiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDQ4IDogdCAtPiB0XG4gIGVuZFxuICB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgbW9kdWxlIE5hdGl2ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdG9faW50IHggPSBTb21lIHhcbiAgICBsZXQgdG9faW50X3RydW5jIHggPSB4XG5cbiAgICAoKiBbb2ZfaW50MzJfZXhuXSBpcyBhIHNhZmUgb3BlcmF0aW9uIG9uIHBsYXRmb3JtcyB3aXRoIDY0LWJpdCB3b3JkIHNpemVzLiAqKVxuICAgIGxldCBvZl9pbnQzMiA9IG9mX2ludDMyX2V4blxuICAgIGxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IHRvX25hdGl2ZWludCB4XG4gICAgbGV0IHRvX25hdGl2ZWludCB4ID0gU29tZSAodG9fbmF0aXZlaW50IHgpXG4gICAgbGV0IHJlcHIgPSBJbnQ2M19lbXVsLlJlcHIuSW50XG4gICAgbGV0IGJzd2FwMzIgdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXAzMiAoSW50NjQub2ZfaW50IHQpKVxuICAgIGxldCBic3dhcDQ4IHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwNDggKEludDY0Lm9mX2ludCB0KSlcbiAgZW5kXG5cbiAgbGV0IGltcGwgOiAobW9kdWxlIFMpID1cbiAgICBtYXRjaCByZXByIHdpdGhcbiAgICB8IEltbWVkaWF0ZSAtPiAobW9kdWxlIE5hdGl2ZSA6IFMpXG4gICAgfCBOb25faW1tZWRpYXRlIC0+IChtb2R1bGUgSW50NjNfZW11bCA6IFMpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSAodmFsIEJhY2tlbmQuaW1wbCA6IEJhY2tlbmQuUylcblxubW9kdWxlIE92ZXJmbG93X2V4biA9IHN0cnVjdFxuICBsZXQgKCArICkgdCB1ID1cbiAgICBsZXQgc3VtID0gdCArIHUgaW5cbiAgICBpZiBiaXRfb3IgKGJpdF94b3IgdCB1KSAoYml0X3hvciB0IChiaXRfbm90IHN1bSkpIDwgemVyb1xuICAgIHRoZW4gc3VtXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCArICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInN1bVwiLCBzZXhwX29mX3Qgc3VtIF0pXG4gIDs7XG5cbiAgbGV0ICggLSApIHQgdSA9XG4gICAgbGV0IGRpZmYgPSB0IC0gdSBpblxuICAgIGxldCBwb3NfZGlmZiA9IHQgPiB1IGluXG4gICAgaWYgdCA8PiB1ICYmIEJvb2wuKCA8PiApIHBvc19kaWZmIChpc19wb3NpdGl2ZSBkaWZmKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLSApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJkaWZmXCIsIHNleHBfb2ZfdCBkaWZmIF0pXG4gICAgZWxzZSBkaWZmXG4gIDs7XG5cbiAgbGV0IG5lZ2F0aXZlX29uZSA9IG9mX2ludCAoLTEpXG4gIGxldCBkaXZfd291bGRfb3ZlcmZsb3cgdCB1ID0gdCA9IG1pbl92YWx1ZSAmJiB1ID0gbmVnYXRpdmVfb25lXG5cbiAgbGV0ICggKiApIHQgdSA9XG4gICAgbGV0IHByb2R1Y3QgPSB0ICogdSBpblxuICAgIGlmIHUgPD4gemVybyAmJiAoZGl2X3dvdWxkX292ZXJmbG93IHByb2R1Y3QgdSB8fCBwcm9kdWN0IC8gdSA8PiB0KVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKiApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCBwcm9kdWN0IF0pXG4gICAgZWxzZSBwcm9kdWN0XG4gIDs7XG5cbiAgbGV0ICggLyApIHQgdSA9XG4gICAgaWYgZGl2X3dvdWxkX292ZXJmbG93IHQgdVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCAodCAvIHUpIF0pXG4gICAgZWxzZSB0IC8gdVxuICA7O1xuXG4gIGxldCBhYnMgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcImFicyBvdmVyZmxvd1wiIGVsc2UgYWJzIHRcbiAgbGV0IG5lZyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwibmVnIG92ZXJmbG93XCIgZWxzZSBuZWcgdFxuZW5kXG5cbmxldCAoKSA9IGFzc2VydCAoSW50LiggPSApIG51bV9iaXRzIDYzKVxuXG5sZXQgcmFuZG9tX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50IHN0YXRlICh0b19pbnRfZXhuIGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb21fb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0IHN0YXRlICh0b19pbnQ2NCBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX29mX2ludDY0XG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnRfaW5jbCBzdGF0ZSAodG9faW50X2V4biBsbykgKHRvX2ludF9leG4gaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NF9pbmNsIHN0YXRlICh0b19pbnQ2NCBsbykgKHRvX2ludDY0IGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21faW5jbF9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX2luY2xfb2ZfaW50NjRcbjs7XG5cbmxldCBmbG9vcl9sb2cyIHQgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gdCB8PiB0b19pbnRfZXhuIHw+IEludC5mbG9vcl9sb2cyXG4gIHwgVzMyIC0+XG4gICAgaWYgdCA8PSB6ZXJvXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKTtcbiAgICBsZXQgZmxvb3JfbG9nMiA9IHJlZiAoSW50LiggLSApIG51bV9iaXRzIDIpIGluXG4gICAgd2hpbGUgZXF1YWwgemVybyAoYml0X2FuZCB0IChzaGlmdF9sZWZ0IG9uZSAhZmxvb3JfbG9nMikpIGRvXG4gICAgICBmbG9vcl9sb2cyIDo9IEludC4oIC0gKSAhZmxvb3JfbG9nMiAxXG4gICAgZG9uZTtcbiAgICAhZmxvb3JfbG9nMlxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFJlcHIgPSBSZXByXG5cbiAgbGV0IHJlcHIgPSByZXByXG5cbiAgbW9kdWxlIEVtdWwgPSBJbnQ2M19lbXVsXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3Byb2R1Y3QiLCJjc3RfdCIsImNzdF91IiwiY2FtbF9kaXYiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbXVsIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJCYXNlX1dvcmRfc2l6ZSIsIkJhc2VfSW50IiwiQmFzZV9TZXhwIiwiQmFzZV9SYW5kb20iLCJCYXNlX0ltcG9ydCIsIkJhc2VfQm9vbCIsIkJhc2VfSW50NjQiLCJCYXNlX0Vycm9yIiwiQmFzZV9JbnQ2M19lbXVsIiwiQmFzZV9TeXMwIiwiQXNzZXJ0X2ZhaWx1cmUiLCJyYWlzZV9zIiwiaW5jbHVkZSIsInJlcHIiLCJ0X3NleHBfZ3JhbW1hciIsIm9mX2Zsb2F0IiwidG9fZmxvYXQiLCJvZl9pbnRfZXhuIiwidG9faW50X2V4biIsImhhc2hfZm9sZF90IiwiaGFzaCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsIm9mX3N0cmluZyIsInRvX3N0cmluZyIsImVxdWFsIiwiY29tcGFyZSIsIm1pbiIsIm1heCIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJiZXR3ZWVuIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJjb21wYXJhdG9yIiwicHAiLCJoYXNoYWJsZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsX2xvY2FsIiwiaW52YXJpYW50IiwiSGV4IiwiQmluYXJ5Iiwib2Zfc3RyaW5nX29wdCIsInRvX3N0cmluZ19odW0iLCJvbmUiLCJtaW51c19vbmUiLCJyZW0iLCJyb3VuZCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX2Rvd24iLCJyb3VuZF91cCIsInJvdW5kX25lYXJlc3QiLCJzdWNjIiwicHJlZCIsInBvdyIsImJpdF9hbmQiLCJiaXRfb3IiLCJiaXRfeG9yIiwiYml0X25vdCIsInBvcGNvdW50Iiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0IiwiZGVjciIsImluY3IiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMl9leG4iLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsIm9mX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnRfZXhuIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwibnVtX2JpdHMiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwiY2VpbF9wb3cyIiwiZmxvb3JfcG93MiIsImNlaWxfbG9nMiIsImlzX3BvdzIiLCJjbHoiLCJjdHoiLCJPIiwic3ltYm9sIiwibG5vdCIsImFicyIsInplcm8iLCJvZl9pbnQiLCJ0b19pbnQzMiIsIm9mX2ludDY0Iiwib2ZfbmF0aXZlaW50IiwidG9faW50IiwieCIsInRvX2ludF90cnVuYyIsInRvX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCIsImJzd2FwMzIiLCJ0IiwiYnN3YXA0OCIsImNzdF9JbnRfZmxvb3JfbG9nMl9nb3RfaW52YWxpZCIsImNzdF9uZWdfb3ZlcmZsb3ciLCJjc3RfYWJzX292ZXJmbG93IiwiY3N0X292ZXJmbG93IiwiY3N0X2RpZmYiLCJjc3Rfc3VtIiwibmVnIiwibGFuZCIsImxvciIsImx4b3IiLCJsc2wiLCJhc3IiLCJsc3IiLCJvZl9pbnQzMiIsInRvX2ludDMyX3RydW5jIiwib2ZfaW50NjRfdHJ1bmMiLCJvZl9uYXRpdmVpbnRfdHJ1bmMiLCJic3dhcDE2IiwidSIsInN1bSIsImRpZmYiLCJwb3NfZGlmZiIsIm5lZ2F0aXZlX29uZSIsImRpdl93b3VsZF9vdmVyZmxvdyIsInByb2R1Y3QiLCJyYW5kb21fb2ZfaW50Iiwib3B0IiwiYm91bmQiLCJzdGF0ZSIsInJhbmRvbV9vZl9pbnQ2NCIsInJhbmRvbSIsInJhbmRvbV9pbmNsX29mX2ludCIsImxvIiwiaGkiLCJyYW5kb21faW5jbF9vZl9pbnQ2NCIsInJhbmRvbV9pbmNsIiwiZmxvb3JfbG9nMiIsIkJhc2VfSW50NjMiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxNQUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBRSxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURqRmhDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzc4NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJNZXJnZV9pbnRvX2FjdGlvbiIsIkRlZmluaXRpb25zIiwiQmFzZV9EaWN0aW9uYXJ5X211dGFibGVfaW50ZiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywrQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3ODYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9EaWN0aW9uYXJ5X211dGFibGUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQywwQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3ODc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiS2V5IiwiQmFzZV9IYXNodGJsX2ludGYiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLG9CQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzc4OTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYXZsdHJlZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIEEgZmV3IHNtYWxsIHRoaW5ncyBjb3BpZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBCYXNlIGJlY2F1c2UgdGhleSBkZXBlbmQgb24gdXMsIHNvIHdlXG4gICBjYW4ndCB1c2UgdGhlbS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIEl0cyBpbXBvcnRhbnQgdGhhdCBFbXB0eSBoYXZlIG5vIGFyZ3MuIEl0J3MgdGVtcHRpbmcgdG8gbWFrZSB0aGlzIHR5cGUgYSByZWNvcmRcbiAgIChlLmcuIHRvIGhvbGQgdGhlIGNvbXBhcmUgZnVuY3Rpb24pLCBidXQgYSBsb3Qgb2YgbWVtb3J5IGlzIHNhdmVkIGJ5IEVtcHR5IGJlaW5nIGFuXG4gICBpbW1lZGlhdGUsIHNpbmNlIGFsbCB1bnVzZWQgYnVja2V0cyBpbiB0aGUgaGFzaHRibCBkb24ndCB1c2UgYW55IG1lbW9yeSAoYmVzaWRlcyB0aGVcbiAgIGFycmF5IGNlbGwpICopXG50eXBlICgnaywgJ3YpIHQgPVxuICB8IEVtcHR5XG4gIHwgTm9kZSBvZlxuICAgICAgeyBtdXRhYmxlIGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICA7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgOyBtdXRhYmxlIGhlaWdodCA6IGludFxuICAgICAgOyBtdXRhYmxlIHJpZ2h0IDogKCdrLCAndikgdFxuICAgICAgfVxuICB8IExlYWYgb2ZcbiAgICAgIHsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICB9XG5cbmxldCBlbXB0eSA9IEVtcHR5XG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gdHJ1ZVxuICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuOztcblxubGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IExlYWYgXyAtPiAxXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodDsgcmlnaHQgPSBfIH0gLT4gaGVpZ2h0XG47O1xuXG5sZXQgaW52YXJpYW50IGNvbXBhcmUgPVxuICBsZXQgbGVnYWxfbGVmdF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgbGVmdF9rZXkga2V5IDwgMClcbiAgaW5cbiAgbGV0IGxlZ2FsX3JpZ2h0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIHJpZ2h0X2tleSBrZXkgPiAwKVxuICBpblxuICBsZXQgcmVjIGludiA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSB8IExlYWYgXyAtPiAoKVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGs7IHZhbHVlID0gXzsgaGVpZ2h0ID0gaDsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGhsLCBociA9IGhlaWdodCBsZWZ0LCBoZWlnaHQgcmlnaHQgaW5cbiAgICAgIGludiBsZWZ0O1xuICAgICAgaW52IHJpZ2h0O1xuICAgICAgbGVnYWxfbGVmdF9rZXkgayBsZWZ0O1xuICAgICAgbGVnYWxfcmlnaHRfa2V5IGsgcmlnaHQ7XG4gICAgICBhc3NlcnQgKGggPSBJbnQubWF4IGhsIGhyICsgMSk7XG4gICAgICBhc3NlcnQgKGFicyAoaGwgLSBocikgPD0gMilcbiAgaW5cbiAgaW52XG47O1xuXG5sZXQgaW52YXJpYW50IHQgfmNvbXBhcmUgPSBpbnZhcmlhbnQgY29tcGFyZSB0XG5cbigqIEluIHRoZSBmb2xsb3dpbmcgY29tbWVudHMsXG4gICAndCBpcyBiYWxhbmNlZCcgbWVhbnMgdGhhdCAnaW52YXJpYW50IHQnIGRvZXMgbm90XG4gICByYWlzZSBhbiBleGNlcHRpb24uICBUaGlzIGltcGxpZXMgb2YgY291cnNlIHRoYXQgZWFjaCBub2RlJ3MgaGVpZ2h0IGZpZWxkIGlzXG4gICBjb3JyZWN0LlxuICAgJ3QgaXMgYmFsYW5jZWFibGUnIG1lYW5zIHRoYXQgaGVpZ2h0IG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBvZiB0XG4gICBkaWZmZXIgYnkgYXQgbW9zdCAzLiAqKVxuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBoYXZlIGNvcnJlY3QgaGVpZ2h0c1xuICAgQHBvc3Q6IG91dHB1dCBoYXMgdGhlIGNvcnJlY3QgaGVpZ2h0ICopXG5sZXQgdXBkYXRlX2hlaWdodCA9IGZ1bmN0aW9uXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IG9sZF9oZWlnaHQ7IHJpZ2h0IH0gYXMgeCkgLT5cbiAgICBsZXQgbmV3X2hlaWdodCA9IEludC5tYXggKGhlaWdodCBsZWZ0KSAoaGVpZ2h0IHJpZ2h0KSArIDEgaW5cbiAgICBpZiBuZXdfaGVpZ2h0IDw+IG9sZF9oZWlnaHQgdGhlbiB4LmhlaWdodCA8LSBuZXdfaGVpZ2h0XG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBhcmUgYmFsYW5jZWRcbiAgIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwb3N0OiBvdXRwdXQgaXMgYmFsYW5jZWQgKGluIHBhcnRpY3VsYXIsIGhlaWdodCBpcyBjb3JyZWN0KSAqKVxubGV0IGJhbGFuY2UgdHJlZSA9XG4gIG1hdGNoIHRyZWUgd2l0aFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IHRyZWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByb290X25vZGUpIC0+XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxlZnRcbiAgICBhbmQgaHIgPSBoZWlnaHQgcmlnaHQgaW5cbiAgICAoKiArIDIgaXMgY3JpdGljYWxseSBpbXBvcnRhbnQsIGxvd2VyaW5nIGl0IHRvIDEgd2lsbCBicmVhayB0aGUgTGVhZlxuICAgICAgIGFzc3VtcHRpb25zIGluIHRoZSBjb2RlIGJlbG93LCBhbmQgd2lsbCBmb3JjZSB1cyB0byBwcm9tb3RlIGxlYWYgbm9kZXMgaW5cbiAgICAgICB0aGUgYmFsYW5jZSByb3V0aW5lLiBJdCdzIGFsc28gZmFzdGVyLCBzaW5jZSBpdCB3aWxsIGJhbGFuY2UgbGVzcyBvZnRlbi5cbiAgICAgICBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBjb2RlIGlzIGRlbGljYXRlLiAgVGhlIHVwZGF0ZV9oZWlnaHQgY2FsbHMgbXVzdFxuICAgICAgIG9jY3VyIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzaW5jZSB1cGRhdGVfaGVpZ2h0IGFzc3VtZXMgaXRzIGNoaWxkcmVuIGhhdmVcbiAgICAgICB0aGUgY29ycmVjdCBoZWlnaHRzLiAgKilcbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbGVmdCB3aXRoXG4gICAgICAoKiBJdCBjYW5ub3QgYmUgYSBsZWFmLCBiZWNhdXNlIGV2ZW4gaWYgcmlnaHQgaXMgZW1wdHksIGEgbGVhZlxuICAgICAgICAgaXMgb25seSBoZWlnaHQgMSAqKVxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSBsZWZ0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyBsZWZ0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCBsZWZ0X25vZGVfbGVmdCA+PSBoZWlnaHQgbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgIGxlZnQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGlmIHJpZ2h0IGlzIGEgbGVhZiwgdGhlbiBsZWZ0IG11c3QgYmUgZW1wdHkuIFRoYXQgbWVhbnNcbiAgICAgICAgICAgICBoZWlnaHQgaXMgMi4gRXZlbiBpZiBociBpcyBlbXB0eSB3ZSBzdGlsbCBjYW4ndCBnZXQgaGVyZS4gKilcbiAgICAgICAgICBtYXRjaCBsZWZ0X25vZGVfcmlnaHQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBscl9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gbHJfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICBscl9ub2RlKSAtPlxuICAgICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIGxyX2xlZnQ7XG4gICAgICAgICAgICByb290X25vZGUubGVmdCA8LSBscl9yaWdodDtcbiAgICAgICAgICAgIGxyX25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICAgIGxyX25vZGUubGVmdCA8LSBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgICBsZWZ0X25vZGVfcmlnaHQpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHJpZ2h0IGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgIG1hdGNoIHJpZ2h0IHdpdGhcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgICAgIDsga2V5ID0gX1xuICAgICAgICAgICA7IHZhbHVlID0gX1xuICAgICAgICAgICA7IGhlaWdodCA9IF9cbiAgICAgICAgICAgOyByaWdodCA9IHJpZ2h0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyByaWdodF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcmlnaHRfbm9kZV9yaWdodCA+PSBoZWlnaHQgcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSByaWdodF9ub2RlX2xlZnQ7XG4gICAgICAgICAgcmlnaHRfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgcmlnaHQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgICAgIG1hdGNoIHJpZ2h0X25vZGVfbGVmdCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IE5vZGVcbiAgICAgICAgICAgICAgKHsgbGVmdCA9IHJsX2xlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBybF9yaWdodCB9IGFzXG4gICAgICAgICAgICAgIHJsX25vZGUpIC0+XG4gICAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gcmxfcmlnaHQ7XG4gICAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmxfbGVmdDtcbiAgICAgICAgICAgIHJsX25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgICAgcmxfbm9kZS5yaWdodCA8LSByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0X25vZGVfbGVmdCkpXG4gICAgZWxzZSAoXG4gICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICB0cmVlKVxuOztcblxuKCogQHByZTogdCBpcyBiYWxhbmNlZC5cbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWQsIHdpdGggbmV3IG5vZGUgaW5zZXJ0ZWRcbiAgIEBwb3N0OiAhYWRkZWQgPSB0cnVlIGlmZiB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IHRyZWUgY2hhbmdlZC4gICopXG5sZXQgcmVjIGFkZCB0IH5yZXBsYWNlIH5jb21wYXJlIH5hZGRlZCB+a2V5OmsgfmRhdGE6diA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+XG4gICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBMZWFmICh7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSBhcyByKSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrJyBrIGluXG4gICAgKCogVGhpcyBjb21wYXJlIGlzIHJldmVyc2VkIG9uIHB1cnBvc2UsIHdlIGFyZSBwcmV0ZW5kaW5nXG4gICAgICAgdGhhdCB0aGUgbGVhZiB3YXMganVzdCBpbnNlcnRlZCBpbnN0ZWFkIG9mIHRoZSBvdGhlciB3YXlcbiAgICAgICByb3VuZCwgdGhhdCB3YXkgd2Ugb25seSBhbGxvY2F0ZSBvbmUgbm9kZS4gKilcbiAgICBpZiBjID0gMFxuICAgIHRoZW4gKFxuICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2O1xuICAgICAgdClcbiAgICBlbHNlIChcbiAgICAgIGFkZGVkIDo9IHRydWU7XG4gICAgICBpZiBjIDwgMFxuICAgICAgdGhlbiBOb2RlIHsgbGVmdCA9IHQ7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSBFbXB0eSB9XG4gICAgICBlbHNlIE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSB0IH0pXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICBpZiBjID0gMFxuICAgIHRoZW4gKFxuICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2O1xuICAgICAgdClcbiAgICBlbHNlIChcbiAgICAgIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxlZnQnID0gYWRkIGxlZnQgfnJlcGxhY2UgfmFkZGVkIH5jb21wYXJlIH5rZXk6ayB+ZGF0YTp2IGluXG4gICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCBsZWZ0JyBsZWZ0KSB0aGVuIHIubGVmdCA8LSBsZWZ0JylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmlnaHQnID0gYWRkIHJpZ2h0IH5yZXBsYWNlIH5hZGRlZCB+Y29tcGFyZSB+a2V5OmsgfmRhdGE6diBpblxuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgcmlnaHQnIHJpZ2h0KSB0aGVuIHIucmlnaHQgPC0gcmlnaHQnKTtcbiAgICAgIGlmICFhZGRlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHQpXG47O1xuXG5sZXQgcmVjIGZpcnN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBmaXJzdCBsXG47O1xuXG5sZXQgcmVjIGxhc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gciB9IC0+IGxhc3QgclxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSByZWMgZmluZGlfYW5kX2NhbGxfaW1wbFxuICB0XG4gIH5jb21wYXJlXG4gIGtcbiAgYXJnMVxuICBhcmcyXG4gIH5jYWxsX2lmX2ZvdW5kXG4gIH5jYWxsX2lmX25vdF9mb3VuZFxuICB+aWZfZm91bmRcbiAgfmlmX25vdF9mb3VuZFxuICA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2UgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICBpZiBjID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2VcbiAgICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgKGlmIGMgPCAwIHRoZW4gbGVmdCBlbHNlIHJpZ2h0KVxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICBrXG4gICAgICAgIGFyZzFcbiAgICAgICAgYXJnMlxuICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIGRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIGRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIGRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gPVxuICBsZXQgaWZfZm91bmQgXyA9IHRydWUgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gZmFsc2UgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IHJlYyByZW1vdmUgPVxuICBsZXQgcmVjIG1pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiBfIC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gbWluX2VsdCBsZWZ0XG4gIGluXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+IHJpZ2h0XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT5cbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIHIpIC0+XG4gICAgICByLmxlZnQgPC0gcmVtb3ZlX21pbl9lbHQgbGVmdDtcbiAgICAgIGJhbGFuY2UgdHJlZVxuICBpblxuICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgdHJlZSA9IG1pbl9lbHQgdDIgaW5cbiAgICAgIGJhbGFuY2VcbiAgICAgICAgKG1hdGNoIHRyZWUgd2l0aFxuICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgICAgICAgIGxldCB0MiA9IHJlbW92ZV9taW5fZWx0IHQyIGluXG4gICAgICAgICAgIE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSB0MVxuICAgICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgICAgIDsgdmFsdWUgPSB2XG4gICAgICAgICAgICAgOyBoZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgdDEpIChoZWlnaHQgdDIpICsgMVxuICAgICAgICAgICAgIDsgcmlnaHQgPSB0MlxuICAgICAgICAgICAgIH1cbiAgICAgICAgIHwgTm9kZSByIC0+XG4gICAgICAgICAgIHIucmlnaHQgPC0gcmVtb3ZlX21pbl9lbHQgdDI7XG4gICAgICAgICAgIHIubGVmdCA8LSB0MTtcbiAgICAgICAgICAgdHJlZSlcbiAgaW5cbiAgZnVuIHQgfnJlbW92ZWQgfmNvbXBhcmUgayAtPlxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgRW1wdHkpXG4gICAgICBlbHNlIChcbiAgICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgICAgdClcbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBtZXJnZSBsZWZ0IHJpZ2h0KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsZWZ0JyA9IHJlbW92ZSBsZWZ0IH5yZW1vdmVkIH5jb21wYXJlIGsgaW5cbiAgICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgbGVmdCcgbGVmdCkgdGhlbiByLmxlZnQgPC0gbGVmdCcpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByaWdodCcgPSByZW1vdmUgcmlnaHQgfnJlbW92ZWQgfmNvbXBhcmUgayBpblxuICAgICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCByaWdodCcgcmlnaHQpIHRoZW4gci5yaWdodCA8LSByaWdodCcpO1xuICAgICAgICBpZiAhcmVtb3ZlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHQpXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGluaXRcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGEgaW5pdFxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IEVtcHR5XG4gICAgICB9IC0+IGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH0gfVxuICAgIC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfTsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH1cbiAgICAtPiBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKSB+ZlxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSkgfmZcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBpdGVyIGxlZnQgfmY7XG4gICAgZiB+a2V5IH5kYXRhO1xuICAgIGl0ZXIgcmlnaHQgfmZcbjs7XG5cbmxldCByZWMgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgKHsga2V5OyB2YWx1ZSB9IGFzIHQpIC0+IHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXk7IHZhbHVlOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHQpIC0+XG4gICAgbWFwaV9pbnBsYWNlIH5mIGxlZnQ7XG4gICAgdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWU7XG4gICAgbWFwaV9pbnBsYWNlIH5mIHJpZ2h0XG47O1xuXG5sZXQgY2hvb3NlX2V4biA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0F2bHRyZWUuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlOyBfIH0gfCBOb2RlIHsga2V5OyB2YWx1ZTsgXyB9IC0+IGtleSwgdmFsdWVcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfYXZsdHJlZV9tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU2V4cCIsIkFzc2VydF9mYWlsdXJlIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0Vycm9yIiwicmFpc2VfcyIsIm1heCIsIngiLCJ5IiwiZHVtbXkiLCJpc19lbXB0eSIsInBhcmFtIiwiaGVpZ2h0IiwiaW52YXJpYW50IiwidCIsImNvbXBhcmUiLCJpbnYiLCJsZWZ0Iiwia2V5IiwiaCIsInJpZ2h0IiwiaHIiLCJobCIsImxlZnRfa2V5IiwicmlnaHRfa2V5IiwidXBkYXRlX2hlaWdodCIsIm9sZF9oZWlnaHQiLCJuZXdfaGVpZ2h0IiwiYmFsYW5jZSIsInJvb3Rfbm9kZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsImFkZCIsInJlcGxhY2UiLCJhZGRlZCIsImsiLCJ2IiwiYyIsImZpcnN0IiwibCIsImxhc3QiLCJyIiwiZmluZGlfYW5kX2NhbGxfaW1wbCIsImFyZzEiLCJhcmcyIiwiY2FsbF9pZl9mb3VuZCIsImNhbGxfaWZfbm90X2ZvdW5kIiwiaWZfZm91bmQiLCJpZl9ub3RfZm91bmQiLCJkYXRhIiwiZmluZF9hbmRfY2FsbCIsImZpbmRpX2FuZF9jYWxsIiwiYXJnIiwiZmluZF9hbmRfY2FsbDEiLCJhIiwiZmluZGlfYW5kX2NhbGwxIiwiZmluZF9hbmRfY2FsbDIiLCJiIiwiZmluZGlfYW5kX2NhbGwyIiwiZmluZCIsIm1lbSIsImxldHJlY19mdW5jdGlvbl9jb250ZXh0IiwicmVtb3ZlIiwicmVtb3ZlZCIsInJlbW92ZV9taW5fZWx0IiwidHJlZSIsIm1lcmdlIiwidDEiLCJ0MiIsImNzdF9Bdmx0cmVlX2Nob29zZV9leG5fb2ZfZW1wdCIsImZvbGQiLCJpbml0IiwibWF0Y2giLCJya2V5IiwicmRhdGEiLCJsa2V5IiwibGRhdGEiLCJpdGVyIiwibWFwaV9pbnBsYWNlIiwidmFsdWUiLCJjaG9vc2VfZXhuIiwiQmFzZV9Bdmx0cmVlIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFB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O0FBQUEsWUFBQWtFLFdBQUEzRTtBQUFBQSxJQUdSO0FBQUEsS0FDSSxPQUF5RDtBQUFBLGNBQXpELDREQUM0QztBQUFBLElBRmhEO0FBQUEsU0FBQTBFLFFBQUEsVUFBQW5FLE1BQUE7QUFBQTtBQUFBLFNBQUFBLFFBQUEsVUFBQW1FLFVBQUEsVUFBQUEsUUFFc0MsU0FBQW5FLE1BQUE7QUFBQTtBQUFBLEdBQVU7QUFBQTtBQUFBLElBQUFxRTtBQUFBQSxNQXZGL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHBhRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4NDc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2hhc2h0YmwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgZ3Jvd3RoX2FsbG93ZWQgOiBib29sXG4gIDsgaGFzaGFibGUgOiAnayBIYXNoYWJsZS50XG4gIDsgbXV0YWJsZSBtdXRhdGlvbl9hbGxvd2VkIDogYm9vbCAoKiBTZXQgZHVyaW5nIGFsbCBpdGVyYXRpb24gb3BlcmF0aW9ucyAqKVxuICB9XG5cbnR5cGUgJ2Ega2V5ID0gJ2FcblxubGV0IHNleHBfb2Zfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdFxubGV0IGNvbXBhcmVfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmVcblxubGV0IGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQgPVxuICBpZiBub3QgdC5tdXRhdGlvbl9hbGxvd2VkIHRoZW4gZmFpbHdpdGggXCJIYXNodGJsOiBtdXRhdGlvbiBub3QgYWxsb3dlZCBkdXJpbmcgaXRlcmF0aW9uXCJcbjs7XG5cbmxldCB3aXRob3V0X211dGF0aW5nIHQgZiA9XG4gIGlmIHQubXV0YXRpb25fYWxsb3dlZFxuICB0aGVuIChcbiAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgfCB4IC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgcmFpc2UgZXhuKVxuICBlbHNlIGYgKClcbjs7XG5cbigqKiBJbnRlcm5hbGx5IHVzZSBhIG1heGltdW0gc2l6ZSB0aGF0IGlzIGEgcG93ZXIgb2YgMi4gUmV2ZXJzZXMgdGhlIGFib3ZlIHRvIGZpbmQgdGhlXG4gICAgZmxvb3IgcG93ZXIgb2YgMiBiZWxvdyB0aGUgc3lzdGVtIG1heCBhcnJheSBsZW5ndGggKilcbmxldCBtYXhfdGFibGVfbGVuZ3RoID0gSW50LmZsb29yX3BvdzIgQXJyYXkubWF4X2xlbmd0aFxuXG4oKiBUaGUgZGVmYXVsdCBzaXplIGlzIGNob3NlbiB0byBiZSAwIChhcyBvcHBvc2VkIHRvIDEyOCBhcyBpdCB3YXMgYmVmb3JlKSBiZWNhdXNlOlxuICAgLSAxMjggY2FuIGNyZWF0ZSBzdWJzdGFudGlhbCBtZW1vcnkgb3ZlcmhlYWQgKHgxMCkgd2hlbiBjcmVhdGluZyBtYW55IHRhYmxlcywgbW9zdFxuICAgICBvZiB3aGljaCBhcmUgbm90IGJpZyAoc2F5LCBpZiB5b3UgaGF2ZSBhIGhhc2h0Ymwgb2YgaGFzaHRibCkuIEFuZCBtZW1vcnkgb3ZlcmhlYWQgaXNcbiAgICAgbm90IHRoYXQgZWFzeSB0byBwcm9maWxlLlxuICAgLSBpZiBhIGhhc2h0YmwgaXMgZ29pbmcgdG8gZ3JvdywgaXQncyBub3QgY2xlYXIgd2h5IDEyOCBpcyBtYXJrZWRseSBiZXR0ZXIgdGhhbiBvdGhlclxuICAgICBzaXplcyAoaWYgeW91IGdvaW5nIHRvIHN0aWNrIDEwMDAgZWxlbWVudHMsIHlvdSdyZSBnb2luZyB0byBncm93IHRoZSBoYXNodGFibGUgb25jZVxuICAgICBvciB0d2ljZSBhbnl3YXkpXG4gICAtIGluIG90aGVyIGxhbmd1YWdlcyAobGlrZSBydXN0LCBweXRob24sIGFuZCBhcHBhcmVudGx5IGdvKSwgdGhlIGRlZmF1bHQgaXMgYWxzbyBhXG4gICAgIHNtYWxsIHNpemUuICopXG5sZXQgY3JlYXRlID8oZ3Jvd3RoX2FsbG93ZWQgPSB0cnVlKSA/KHNpemUgPSAwKSB+aGFzaGFibGUgKCkgPVxuICBsZXQgc2l6ZSA9IEludC5taW4gKEludC5tYXggMSBzaXplKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gIGxldCBzaXplID0gSW50LmNlaWxfcG93MiBzaXplIGluXG4gIHsgdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpzaXplIEF2bHRyZWUuZW1wdHlcbiAgOyBsZW5ndGggPSAwXG4gIDsgZ3Jvd3RoX2FsbG93ZWRcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gcmVmIGZhbHNlIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgKCogVGhlIGF2bCB0cmVlIG1pZ2h0IHJlcGxhY2UgdGhlIHZhbHVlIFtyZXBsYWNlPXRydWVdIG9yIGRvIG5vdGhpbmcgW3JlcGxhY2U9ZmFsc2VdXG4gICAgICAgdG8gdGhlIGVudHJ5LCBpbiB0aGF0IGNhc2UgdGhlIHRhYmxlIGRpZCBub3QgZ2V0IGJpZ2dlciwgc28gd2Ugc2hvdWxkIG5vdFxuICAgICAgIGluY3JlbWVudCBsZW5ndGgsIHdlIHBhc3MgaW4gdGhlIGJvb2wgcmVmIHQuYWRkZWQgc28gdGhhdCBpdCBjYW4gdGVsbCB1cyB3aGV0aGVyXG4gICAgICAgaXQgYWRkZWQgb3IgcmVwbGFjZWQuIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb24uIFNpbmNlIHRoZSBib29sXG4gICAgICAgaXMgYW4gaW1tZWRpYXRlIGl0IGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIHdyaXRlIGJhcnJpZXIuICopXG4gICAgQXZsdHJlZS5hZGQgfnJlcGxhY2Ugcm9vdCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkgfmFkZGVkIH5rZXkgfmRhdGFcbiAgaW5cbiAgaWYgIWFkZGVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICAoKiBUaGlzIGxpdHRsZSBvcHRpbWl6YXRpb24gc2F2ZXMgYSBjYW1sX21vZGlmeSB3aGVuIHRoZSB0cmVlXG4gICAgIGhhc24ndCBiZWVuIHJlYmFsYW5jZWQuICopXG4gIGlmIG5vdCAocGh5c19lcXVhbCBuZXdfcm9vdCByb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICAhYWRkZWRcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gaWdub3JlIChhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIDogYm9vbCkgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2xkX3RhYmxlIC0gMSBkb1xuICAgICAgICBBdmx0cmVlLml0ZXIgb2xkX3RhYmxlLihpKSB+ZlxuICAgICAgZG9uZSkpXG47O1xuXG5sZXQgY2FwYWNpdHkgdCA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlXG5cbmxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgaWdub3JlIChhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIDogYm9vbCk7XG4gIG1heWJlX3Jlc2l6ZV90YWJsZSB0XG47O1xuXG5sZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBhZGRlZCA9IGFkZF93b3JrZXIgfnJlcGxhY2U6ZmFsc2UgdCB+a2V5IH5kYXRhIGluXG4gIGlmIGFkZGVkXG4gIHRoZW4gKFxuICAgIG1heWJlX3Jlc2l6ZV90YWJsZSB0O1xuICAgIGBPaylcbiAgZWxzZSBgRHVwbGljYXRlXG47O1xuXG5sZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgfCBgT2sgLT4gKClcbiAgfCBgRHVwbGljYXRlIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXkgdCBpblxuICAgIGxldCBlcnJvciA9IEVycm9yLmNyZWF0ZSBcIkhhc2h0YmwuYWRkX2V4biBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIGtleSBzZXhwX29mX2tleSBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICB0LnRhYmxlLihpKSA8LSBBdmx0cmVlLmVtcHR5XG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIDBcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwyIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDJcbiAgICAgIHRyZWVcbiAgICAgIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICAgICAga2V5XG4gICAgICB+YVxuICAgICAgfmJcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IGtleSAtPiBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtIHQga2V5ID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gZmFsc2VcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IF8gfSAtPiBjb21wYXJlX2tleSB0IGsga2V5ID0gMFxuICB8IHRyZWUgLT4gQXZsdHJlZS5tZW0gdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5XG47O1xuXG5sZXQgcmVtb3ZlIHQga2V5ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IHJlbW92ZWQgPSByZWYgZmFsc2UgaW5cbiAgbGV0IG5ld19yb290ID0gQXZsdHJlZS5yZW1vdmUgcm9vdCB+cmVtb3ZlZCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IGluXG4gIGlmIG5vdCAocGh5c19lcXVhbCByb290IG5ld19yb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICBpZiAhcmVtb3ZlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMVxuOztcblxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGFjYyA6PSBmIH5rZXkgfmRhdGEgIWFjY1xuICAgICAgICB8IGJ1Y2tldCAtPiBhY2MgOj0gQXZsdHJlZS5mb2xkIGJ1Y2tldCB+aW5pdDohYWNjIH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgIWFjY1xuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuICgpXG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICAgICAgICB8IGJ1Y2tldCAtPiBBdmx0cmVlLml0ZXIgYnVja2V0IH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT4gdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG1cbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgaXRlcl9rZXlzIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5cbmxldCByZWMgY2hvb3NlX25vbmVtcHR5IHRhYmxlIGkgPVxuICBsZXQgYXZsdHJlZSA9IEFycmF5LnVuc2FmZV9nZXQgdGFibGUgaSBpblxuICBpZiBBdmx0cmVlLmlzX2VtcHR5IGF2bHRyZWVcbiAgdGhlbiBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgKChpICsgMSkgbGFuZCAoQXJyYXkubGVuZ3RoIHRhYmxlIC0gMSkpXG4gIGVsc2UgQXZsdHJlZS5jaG9vc2VfZXhuIGF2bHRyZWVcbjs7XG5cbmxldCBjaG9vc2VfZXhuIHQgPVxuICBpZiB0Lmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSGFzaHRibC5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pO1xuICBjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwXG47O1xuXG5sZXQgY2hvb3NlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDApXG5cbmxldCBjaG9vc2VfcmFuZG9tbHlfbm9uZW1wdHkgfnJhbmRvbV9zdGF0ZSB0ID1cbiAgbGV0IHN0YXJ0X2lkeCA9IFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChBcnJheS5sZW5ndGggdC50YWJsZSkgaW5cbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgc3RhcnRfaWR4XG47O1xuXG5sZXQgY2hvb3NlX3JhbmRvbWx5ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9yYW5kb21seV9ub25lbXB0eSB+cmFuZG9tX3N0YXRlIHQpXG47O1xuXG5sZXQgY2hvb3NlX3JhbmRvbWx5X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX3JhbmRvbWx5X2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX3JhbmRvbWx5X25vbmVtcHR5IH5yYW5kb21fc3RhdGUgdFxuOztcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfa2V5IGludmFyaWFudF9kYXRhIHQgPVxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgQXZsdHJlZS5pbnZhcmlhbnQgdC50YWJsZS4oaSkgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gIGRvbmU7XG4gIGxldCByZWFsX2xlbiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGkgLT5cbiAgICAgIGludmFyaWFudF9rZXkga2V5O1xuICAgICAgaW52YXJpYW50X2RhdGEgZGF0YTtcbiAgICAgIGkgKyAxKVxuICBpblxuICBhc3NlcnQgKHJlYWxfbGVuID0gdC5sZW5ndGgpXG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgaWZfZm91bmQgdiBfID0gdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIGsgdCA9XG4gICAgcmFpc2VcbiAgICAgIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJIYXNodGJsLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgdC5oYXNoYWJsZS5zZXhwX29mX3QgayBdKSlcbiAgaW5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID0gZmluZF9hbmRfY2FsbDEgdCBrZXkgfmE6dCB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfZXhuXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmb3JfYWxsaSB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IG5vdCAoZiB+a2V5IH5kYXRhKSkpXG5sZXQgZm9yX2FsbCB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gbm90IChmIGRhdGEpKSlcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTooZiB+a2V5IH5kYXRhKSk7XG4gIG5ld190XG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgY29weSB0ID0gbWFwIHQgfmY6Rm4uaWRcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCBTb21lIG5ld19kYXRhIC0+IHNldCBuZXdfdCB+a2V5IH5kYXRhOm5ld19kYXRhXG4gICAgfCBOb25lIC0+ICgpKTtcbiAgbmV3X3Rcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBmaWx0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgdDAgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBsZXQgdDEgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBuZXdfZGF0YSAtPiBzZXQgdDAgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgU2Vjb25kIG5ld19kYXRhIC0+IHNldCB0MSB+a2V5IH5kYXRhOm5ld19kYXRhKTtcbiAgdDAsIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSkgXG4gIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGZpbmRfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsXG4gICAgdFxuICAgIGlkXG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgLT5cbiAgICAgIGxldCBkZWZhdWx0ID0gZGVmYXVsdCAoKSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdCkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRpX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbFxuICAgIHRcbiAgICBpZFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQga2V5IGluXG4gICAgICBzZXQgdCB+a2V5IH5kYXRhOmRlZmF1bHQ7XG4gICAgICBkZWZhdWx0KSBbQG5vbnRhaWxdXG47O1xuXG4oKiBTb21lIGhhc2h0YmwgaW1wbGVtZW50YXRpb25zIG1heSBiZSBhYmxlIHRvIHBlcmZvcm0gdGhpcyBtb3JlIGVmZmljaWVudGx5IHRoYW4gdHdvXG4gICBzZXBhcmF0ZSBsb29rdXBzICopXG5sZXQgZmluZF9hbmRfcmVtb3ZlIHQgaWQgPVxuICBsZXQgcmVzdWx0ID0gZmluZCB0IGlkIGluXG4gIGlmIE9wdGlvbi5pc19zb21lIHJlc3VsdCB0aGVuIHJlbW92ZSB0IGlkO1xuICByZXN1bHRcbjs7XG5cbmxldCBjaGFuZ2UgdCBpZCB+ZiA9XG4gIG1hdGNoIGYgKGZpbmQgdCBpZCkgd2l0aFxuICB8IE5vbmUgLT4gcmVtb3ZlIHQgaWRcbiAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleTppZCB+ZGF0YVxuOztcblxubGV0IHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgPVxuICBsZXQgZGF0YSA9IGYgKGZpbmQgdCBpZCkgaW5cbiAgc2V0IHQgfmtleTppZCB+ZGF0YTtcbiAgZGF0YVxuOztcblxubGV0IHVwZGF0ZSB0IGlkIH5mID0gaWdub3JlICh1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mIDogXylcblxubGV0IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5ID1cbiAgaWYgcmVtb3ZlX2lmX3plcm9cbiAgdGhlblxuICAgIGNoYW5nZSB0IGtleSB+ZjooZnVuIG9wdCAtPlxuICAgICAgbWF0Y2ggYnkgKyBPcHRpb24udmFsdWUgb3B0IH5kZWZhdWx0OjAgd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgbiAtPiBTb21lIG4pXG4gIGVsc2VcbiAgICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYnlcbiAgICAgIHwgU29tZSBpIC0+IGJ5ICsgaSlcbjs7XG5cbmxldCBpbmNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnlcbmxldCBkZWNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgKC1ieSlcblxubGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFsgZGF0YSBdXG4gICAgfCBTb21lIGwgLT4gZGF0YSA6OiBsKVxuOztcblxubGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIFtdIHwgU29tZSBbIF8gXSAtPiByZW1vdmUgdCBrZXlcbiAgfCBTb21lIChfIDo6IHRsKSAtPiBzZXQgdCB+a2V5IH5kYXRhOnRsXG47O1xuXG5sZXQgZmluZF9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlIH5zaXplICgpIGluXG4gIGxldCBkdXBlcyA9IHJlZiBbXSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgaWYgbWVtIHJlcyBrZXkgdGhlbiBkdXBlcyA6PSBrZXkgOjogIWR1cGVzIGVsc2Ugc2V0IHJlcyB+a2V5IH5kYXRhKTtcbiAgbWF0Y2ggIWR1cGVzIHdpdGhcbiAgfCBbXSAtPiBgT2sgcmVzXG4gIHwga2V5cyAtPiBgRHVwbGljYXRlX2tleXMgKExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6aGFzaGFibGUuSGFzaGFibGUuY29tcGFyZSBrZXlzKVxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgfmhhc2hhYmxlICgpIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBhZGRfbXVsdGkgcmVzIH5rZXkgfmRhdGEpO1xuICByZXNcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Qgd2l0aFxuICB8IGBPayB0IC0+IGBPayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGsgLT4gYER1cGxpY2F0ZV9rZXkgKExpc3QuaGRfZXhuIGspXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IGBPayB2IC0+IFJlc3VsdC5PayB2XG4gIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3IgXCJIYXNodGJsLm9mX2FsaXN0X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBzZXhwX29mX2tleVxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBSZXN1bHQuT2sgdiAtPiB2XG4gIHwgUmVzdWx0LkVycm9yIGUgLT4gRXJyb3IucmFpc2UgZVxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IHRvX2FsaXN0IHQgPSBmb2xkIH5mOihmdW4gfmtleSB+ZGF0YSBsaXN0IC0+IChrZXksIGRhdGEpIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIHRcbiAgfD4gdG9fYWxpc3RcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKGsxLCBfKSAoazIsIF8pIC0+IHQuaGFzaGFibGUuY29tcGFyZSBrMSBrMilcbiAgfD4gc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhKVxuOztcblxubGV0IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID1cbiAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCkgc2V4cCBpblxuICBtYXRjaCBvZl9hbGlzdCB+aGFzaGFibGUgYWxpc3QgfnNpemU6KExpc3QubGVuZ3RoIGFsaXN0KSB3aXRoXG4gIHwgYE9rIHYgLT4gdlxuICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgIExpc3QuaXRlcjJfZXhuIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgIGlmIGhhc2hhYmxlLmNvbXBhcmUgayBrMiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiSGFzaHRibC50X29mX3NleHA6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hclxuICAodHlwZSBrIHYpXG4gIChrX2dyYW1tYXIgOiBrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAodl9ncmFtbWFyIDogdiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiAoaywgdikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QuQXNzb2MudF9zZXhwX2dyYW1tYXIga19ncmFtbWFyIHZfZ3JhbW1hcilcbjs7XG5cbmxldCBrZXlzIHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhOl8gYWNjIC0+IGtleSA6OiBhY2MpXG5sZXQgZGF0YSB0ID0gZm9sZCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgYWRkX3RvX2dyb3VwcyBncm91cHMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzID1cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByb3cgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByb3cgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHJvdyBpblxuICAgIGxldCBkYXRhID1cbiAgICAgIG1hdGNoIGZpbmQgZ3JvdXBzIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgfCBTb21lIG9sZCAtPiBjb21iaW5lIG9sZCBkYXRhXG4gICAgaW5cbiAgICBzZXQgZ3JvdXBzIH5rZXkgfmRhdGEpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSByb3dzID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpIGluXG4gIGFkZF90b19ncm91cHMgcmVzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cztcbiAgcmVzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGE6Rm4uaWQgcm93c1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBtYXRjaCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzIHdpdGhcbiAgfCBgT2sgdCAtPiBSZXN1bHQuT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrZXlzIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJIYXNodGJsLmNyZWF0ZV93aXRoX2tleTogZHVwbGljYXRlIGtleXNcIlxuICAgICAgICAgWyBcImtleXNcIiwgc2V4cF9vZl9saXN0IHNleHBfb2Zfa2V5IGtleXMgXSlcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIE9yX2Vycm9yLm9rX2V4biAoY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cylcbjs7XG5cbmxldCBtZXJnZSA9XG4gIGxldCBtYXliZV9zZXQgdCB+a2V5IH5mIGQgPVxuICAgIG1hdGNoIGYgfmtleSBkIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgdiAtPiBzZXQgdCB+a2V5IH5kYXRhOnZcbiAgaW5cbiAgZnVuIHRfbGVmdCB0X3JpZ2h0IH5mIC0+XG4gICAgaWYgbm90IChIYXNoYWJsZS5lcXVhbCB0X2xlZnQuaGFzaGFibGUgdF9yaWdodC5oYXNoYWJsZSlcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiSGFzaHRibC5tZXJnZTogZGlmZmVyZW50ICdoYXNoYWJsZScgdmFsdWVzXCI7XG4gICAgbGV0IG5ld190ID1cbiAgICAgIGNyZWF0ZVxuICAgICAgICB+Z3Jvd3RoX2FsbG93ZWQ6dF9sZWZ0Lmdyb3d0aF9hbGxvd2VkXG4gICAgICAgIH5oYXNoYWJsZTp0X2xlZnQuaGFzaGFibGVcbiAgICAgICAgfnNpemU6dF9sZWZ0Lmxlbmd0aFxuICAgICAgICAoKVxuICAgIGluXG4gICAgd2l0aG91dF9tdXRhdGluZyB0X2xlZnQgKGZ1biAoKSAtPlxuICAgICAgd2l0aG91dF9tdXRhdGluZyB0X3JpZ2h0IChmdW4gKCkgLT5cbiAgICAgICAgaXRlcmkgdF9sZWZ0IH5mOihmdW4gfmtleSB+ZGF0YTpsZWZ0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X3JpZ2h0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgTGVmdCBsZWZ0KVxuICAgICAgICAgIHwgU29tZSByaWdodCAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYEJvdGggKGxlZnQsIHJpZ2h0KSkpO1xuICAgICAgICBpdGVyaSB0X3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpyaWdodCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9sZWZ0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgUmlnaHQgcmlnaHQpXG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgICAoKiBhbHJlYWR5IGRvbmUgYWJvdmUgKikpIFtAbm9udGFpbF0pIFtAbm9udGFpbF0pO1xuICAgIG5ld190XG47O1xuXG5sZXQgbWVyZ2VfaW50byB+c3JjIH5kc3QgfmYgPVxuICBpdGVyaSBzcmMgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IGRzdF9kYXRhID0gZmluZCBkc3Qga2V5IGluXG4gICAgbGV0IGFjdGlvbiA9IHdpdGhvdXRfbXV0YXRpbmcgZHN0IChmdW4gKCkgLT4gZiB+a2V5IGRhdGEgZHN0X2RhdGEpIGluXG4gICAgbWF0Y2ggKGFjdGlvbiA6IF8gTWVyZ2VfaW50b19hY3Rpb24udCkgd2l0aFxuICAgIHwgUmVtb3ZlIC0+IHJlbW92ZSBkc3Qga2V5XG4gICAgfCBTZXRfdG8gZGF0YSAtPlxuICAgICAgKG1hdGNoIGRzdF9kYXRhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gc2V0IGRzdCB+a2V5IH5kYXRhXG4gICAgICAgfCBTb21lIGRzdF9kYXRhIC0+IGlmIG5vdCAocGh5c19lcXVhbCBkc3RfZGF0YSBkYXRhKSB0aGVuIHNldCBkc3QgfmtleSB+ZGF0YSkpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0b19yZW1vdmUgPVxuICAgIGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWMgZWxzZSBrZXkgOjogYWMpXG4gIGluXG4gIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biBrZXkgLT4gcmVtb3ZlIHQga2V5KVxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfa2V5c19pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSkgW0Bub250YWlsXVxuXG5sZXQgZmlsdGVyX21hcGlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IG1hcF9yZXN1bHRzID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiAoa2V5LCBmIH5rZXkgfmRhdGEpIDo6IGFjKSBpblxuICBMaXN0Lml0ZXIgbWFwX3Jlc3VsdHMgfmY6KGZ1biAoa2V5LCByZXN1bHQpIC0+XG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVtb3ZlIHQga2V5XG4gICAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleSB+ZGF0YSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIHdpdGhvdXRfbXV0YXRpbmcgdCAoZnVuICgpIC0+XG4gICAgQXJyYXkuaXRlciB0LnRhYmxlIH5mOihBdmx0cmVlLm1hcGlfaW5wbGFjZSB+ZikgW0Bub250YWlsXSkgW0Bub250YWlsXVxuOztcblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPSBtYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGVxdWFsIGVxdWFsIHQgdCcgPVxuICBsZW5ndGggdCA9IGxlbmd0aCB0J1xuICAmJiAod2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICBtYXRjaCBmaW5kIHQnIGtleSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIHwgU29tZSBkYXRhJyAtPiBpZiBub3QgKGVxdWFsIGRhdGEgZGF0YScpIHRoZW4gci5yZXR1cm4gZmFsc2UpIFtAbm9udGFpbF0pO1xuICAgICAgICB0cnVlKSBbQG5vbnRhaWxdKVxuOztcblxubGV0IHNpbWlsYXIgPSBlcXVhbFxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGNob29zZSA9IGNob29zZVxuICBsZXQgY2hvb3NlX2V4biA9IGNob29zZV9leG5cbiAgbGV0IGNob29zZV9yYW5kb21seSA9IGNob29zZV9yYW5kb21seVxuICBsZXQgY2hvb3NlX3JhbmRvbWx5X2V4biA9IGNob29zZV9yYW5kb21seV9leG5cbiAgbGV0IGNsZWFyID0gY2xlYXJcbiAgbGV0IGNvcHkgPSBjb3B5XG4gIGxldCByZW1vdmUgPSByZW1vdmVcbiAgbGV0IHNldCA9IHNldFxuICBsZXQgYWRkID0gYWRkXG4gIGxldCBhZGRfZXhuID0gYWRkX2V4blxuICBsZXQgY2hhbmdlID0gY2hhbmdlXG4gIGxldCB1cGRhdGUgPSB1cGRhdGVcbiAgbGV0IHVwZGF0ZV9hbmRfcmV0dXJuID0gdXBkYXRlX2FuZF9yZXR1cm5cbiAgbGV0IGFkZF9tdWx0aSA9IGFkZF9tdWx0aVxuICBsZXQgcmVtb3ZlX211bHRpID0gcmVtb3ZlX211bHRpXG4gIGxldCBmaW5kX211bHRpID0gZmluZF9tdWx0aVxuICBsZXQgbWVtID0gbWVtXG4gIGxldCBpdGVyX2tleXMgPSBpdGVyX2tleXNcbiAgbGV0IGl0ZXIgPSBpdGVyXG4gIGxldCBpdGVyaSA9IGl0ZXJpXG4gIGxldCBleGlzdHMgPSBleGlzdHNcbiAgbGV0IGV4aXN0c2kgPSBleGlzdHNpXG4gIGxldCBmb3JfYWxsID0gZm9yX2FsbFxuICBsZXQgZm9yX2FsbGkgPSBmb3JfYWxsaVxuICBsZXQgY291bnQgPSBjb3VudFxuICBsZXQgY291bnRpID0gY291bnRpXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBpc19lbXB0eSA9IGlzX2VtcHR5XG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcGkgPSBtYXBpXG4gIGxldCBmaWx0ZXJfbWFwID0gZmlsdGVyX21hcFxuICBsZXQgZmlsdGVyX21hcGkgPSBmaWx0ZXJfbWFwaVxuICBsZXQgZmlsdGVyX2tleXMgPSBmaWx0ZXJfa2V5c1xuICBsZXQgZmlsdGVyID0gZmlsdGVyXG4gIGxldCBmaWx0ZXJpID0gZmlsdGVyaVxuICBsZXQgcGFydGl0aW9uX21hcCA9IHBhcnRpdGlvbl9tYXBcbiAgbGV0IHBhcnRpdGlvbl9tYXBpID0gcGFydGl0aW9uX21hcGlcbiAgbGV0IHBhcnRpdGlvbl90ZiA9IHBhcnRpdGlvbl90ZlxuICBsZXQgcGFydGl0aW9uaV90ZiA9IHBhcnRpdGlvbmlfdGZcbiAgbGV0IGZpbmRfb3JfYWRkID0gZmluZF9vcl9hZGRcbiAgbGV0IGZpbmRpX29yX2FkZCA9IGZpbmRpX29yX2FkZFxuICBsZXQgZmluZCA9IGZpbmRcbiAgbGV0IGZpbmRfZXhuID0gZmluZF9leG5cbiAgbGV0IGZpbmRfYW5kX2NhbGwgPSBmaW5kX2FuZF9jYWxsXG4gIGxldCBmaW5kX2FuZF9jYWxsMSA9IGZpbmRfYW5kX2NhbGwxXG4gIGxldCBmaW5kX2FuZF9jYWxsMiA9IGZpbmRfYW5kX2NhbGwyXG4gIGxldCBmaW5kaV9hbmRfY2FsbCA9IGZpbmRpX2FuZF9jYWxsXG4gIGxldCBmaW5kaV9hbmRfY2FsbDEgPSBmaW5kaV9hbmRfY2FsbDFcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMiA9IGZpbmRpX2FuZF9jYWxsMlxuICBsZXQgZmluZF9hbmRfcmVtb3ZlID0gZmluZF9hbmRfcmVtb3ZlXG4gIGxldCB0b19hbGlzdCA9IHRvX2FsaXN0XG4gIGxldCBtZXJnZSA9IG1lcmdlXG4gIGxldCBtZXJnZV9pbnRvID0gbWVyZ2VfaW50b1xuICBsZXQga2V5cyA9IGtleXNcbiAgbGV0IGRhdGEgPSBkYXRhXG4gIGxldCBmaWx0ZXJfa2V5c19pbnBsYWNlID0gZmlsdGVyX2tleXNfaW5wbGFjZVxuICBsZXQgZmlsdGVyX2lucGxhY2UgPSBmaWx0ZXJfaW5wbGFjZVxuICBsZXQgZmlsdGVyaV9pbnBsYWNlID0gZmlsdGVyaV9pbnBsYWNlXG4gIGxldCBtYXBfaW5wbGFjZSA9IG1hcF9pbnBsYWNlXG4gIGxldCBtYXBpX2lucGxhY2UgPSBtYXBpX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcGlfaW5wbGFjZSA9IGZpbHRlcl9tYXBpX2lucGxhY2VcbiAgbGV0IGVxdWFsID0gZXF1YWxcbiAgbGV0IHNpbWlsYXIgPSBzaW1pbGFyXG4gIGxldCBpbmNyID0gaW5jclxuICBsZXQgZGVjciA9IGRlY3JcbiAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXlcbmVuZFxuXG5tb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbmVuZCkgOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBLZXkudCkgLT4gKFNleHAudCAtPiAnYikgLT4gU2V4cC50IC0+ICgnYSwgJ2IpIHRfXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBLZXkuaGFzaGFibGVcblxuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKClcbiAgbGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID0gb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG5cbiAgbGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHBcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gICAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgICBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG4gIDs7XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXkgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IEhhc2hhYmxlLnBvbHlcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHlcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEhhc2hhYmxlID0gSGFzaGFibGUuSGFzaGFibGVcblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBsZXQgaGFzaGFibGUgdCA9IHQuaGFzaGFibGVcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgY3JlYXRlIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKVxuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfbXVsdGkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgY3JlYXRlX21hcHBlZCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgZ3JvdXAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG47O1xuXG5sZXQgaGFzaGFibGVfcyB0ID0gSGFzaGFibGUudG9fa2V5IHQuaGFzaGFibGVcblxubW9kdWxlIE0gKEsgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBrKSAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrKSB2X29mX3NleHAgc2V4cCA9XG4gIHRfb2Zfc2V4cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSAobW9kdWxlIEspKSBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGspIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaykgdl9ncmFtbWFyID1cbiAgdF9zZXhwX2dyYW1tYXIgSy50X3NleHBfZ3JhbW1hciB2X2dyYW1tYXJcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9zcmNfaGFzaHRibF9tbCIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwiQmFzZV9Bdmx0cmVlIiwiQmFzZV9JbXBvcnQiLCJCYXNlX0hhc2hhYmxlIiwiQmFzZV9BcnJheSIsIkJhc2VfTGlzdCIsIkJhc2VfT3JfZXJyb3IiLCJCYXNlX1NleHAiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJBc3NlcnRfZmFpbHVyZSIsIkJhc2VfRXJyb3IiLCJCYXNlX09wdGlvbiIsIkJhc2VfUmFuZG9tIiwiQmFzZV9JbnQiLCJCYXNlX1dpdGhfcmV0dXJuIiwid2l0aF9yZXR1cm4iLCJoYXNoX3BhcmFtIiwiaGFzaCIsInJhaXNlX3MiLCJjc3RfSGFzaHRibF9tdXRhdGlvbl9ub3RfYWxsb3ciLCJzZXhwX29mX2tleSIsInQiLCJjb21wYXJlX2tleSIsImVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIiwid2l0aG91dF9tdXRhdGluZyIsIngiLCJleG4iLCJtYXhfdGFibGVfbGVuZ3RoIiwiY3N0X0hhc2h0YmxfYWRkX2V4bl9nb3Rfa2V5X2FsIiwiY3N0X0hhc2h0YmxfY2hvb3NlX2V4bl9vZl9lbXB0IiwiY3N0X0hhc2h0YmxfY2hvb3NlX3JhbmRvbWx5X2V4IiwiY3N0X0hhc2h0Ymxfb2ZfYWxpc3RfZXhuX2R1cGxpIiwiY3N0X0hhc2h0YmxfdF9vZl9zZXhwX2R1cGxpY2F0IiwiY3N0X2tleXMiLCJjc3RfSGFzaHRibF9jcmVhdGVfd2l0aF9rZXlfZHUiLCJjc3RfSGFzaHRibF9tZXJnZV9kaWZmZXJlbnRfaGEiLCJjcmVhdGUiLCJvcHQiLCJoYXNoYWJsZSIsInBhcmFtIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplIiwic2xvdCIsImtleSIsImFkZF93b3JrZXIiLCJyZXBsYWNlIiwiZGF0YSIsImkiLCJyb290IiwiYWRkZWQiLCJuZXdfcm9vdCIsIm1heWJlX3Jlc2l6ZV90YWJsZSIsImxlbiIsInNob3VsZF9ncm93IiwibmV3X2FycmF5X2xlbmd0aCIsIm5ld190YWJsZSIsIm9sZF90YWJsZSIsImNhcGFjaXR5Iiwic2V0IiwiYWRkIiwiYWRkX2V4biIsImVycm9yIiwiY2xlYXIiLCJmaW5kX2FuZF9jYWxsIiwiaWZfZm91bmQiLCJpZl9ub3RfZm91bmQiLCJ0cmVlIiwiayIsInYiLCJmaW5kX2FuZF9jYWxsMSIsImEiLCJmaW5kX2FuZF9jYWxsMiIsImIiLCJmaW5kaV9hbmRfY2FsbCIsImZpbmRpX2FuZF9jYWxsMSIsImZpbmRpX2FuZF9jYWxsMiIsImZpbmQiLCJtZW0iLCJyZW1vdmUiLCJyZW1vdmVkIiwibGVuZ3RoIiwiaXNfZW1wdHkiLCJmb2xkIiwiaW5pdCIsIm4iLCJhY2MiLCJtIiwiYnVja2V0IiwiaXRlcmkiLCJpdGVyIiwiaXRlcl9rZXlzIiwiY2hvb3NlX25vbmVtcHR5IiwidGFibGUiLCJhdmx0cmVlIiwiY2hvb3NlX2V4biIsImNob29zZSIsImNob29zZV9yYW5kb21seV9ub25lbXB0eSIsInJhbmRvbV9zdGF0ZSIsInN0YXJ0X2lkeCIsImNob29zZV9yYW5kb21seSIsImNob29zZV9yYW5kb21seV9leG4iLCJpbnZhcmlhbnQiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsImZpbmRfZXhuIiwiZXhpc3RzaSIsInIiLCJleGlzdHMiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJjb3VudGkiLCJjb3VudCIsIm1hcGkiLCJuZXdfdCIsIm1hcCIsImNvcHkiLCJmaWx0ZXJfbWFwaSIsIm1hdGNoIiwibmV3X2RhdGEiLCJmaWx0ZXJfbWFwIiwiZmlsdGVyaSIsImZpbHRlciIsImZpbHRlcl9rZXlzIiwicGFydGl0aW9uX21hcGkiLCJ0MCIsInQxIiwicGFydGl0aW9uX21hcCIsInBhcnRpdGlvbmlfdGYiLCJwYXJ0aXRpb25fdGYiLCJmaW5kX29yX2FkZCIsImlkIiwiZGVmYXVsdCQiLCJmaW5kaV9vcl9hZGQiLCJmaW5kX2FuZF9yZW1vdmUiLCJyZXN1bHQiLCJjaGFuZ2UiLCJ1cGRhdGVfYW5kX3JldHVybiIsInVwZGF0ZSIsImluY3JfYnkiLCJyZW1vdmVfaWZfemVybyIsImJ5IiwiaW5jciIsImRlY3IiLCJhZGRfbXVsdGkiLCJsIiwicmVtb3ZlX211bHRpIiwidGwiLCJmaW5kX211bHRpIiwiY3JlYXRlX21hcHBlZCIsImdldF9rZXkiLCJnZXRfZGF0YSIsInJvd3MiLCJzIiwicmVzIiwiZHVwZXMiLCJrZXlzIiwib2ZfYWxpc3QiLCJsc3QiLCJ2YXJpYW50Iiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJlIiwib2ZfYWxpc3RfbXVsdGkiLCJ0b19hbGlzdCIsImxpc3QiLCJzZXhwX29mX3QiLCJzZXhwX29mX2RhdGEiLCJrMiIsImsxIiwidF9vZl9zZXhwIiwia19vZl9zZXhwIiwiZF9vZl9zZXhwIiwic2V4cCIsImFsaXN0IiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInRfc2V4cF9ncmFtbWFyIiwia19ncmFtbWFyIiwidl9ncmFtbWFyIiwiZ3JvdXAiLCJjb21iaW5lIiwiZ3JvdXBzIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsImQiLCJtZXJnZSIsInRfbGVmdCIsInRfcmlnaHQiLCJsZWZ0IiwicmlnaHQiLCJtZXJnZV9pbnRvIiwic3JjIiwiZHN0IiwiZHN0X2RhdGEiLCJhY3Rpb24iLCJmaWx0ZXJpX2lucGxhY2UiLCJ0b19yZW1vdmUiLCJhYyIsImZpbHRlcl9pbnBsYWNlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsIm1hcGlfaW5wbGFjZSIsIm1hcF9pbnBsYWNlIiwic2ltaWxhciIsImVxdWFsIiwiQ3JlYXRvcnMiLCJLZXkiLCJQcml2YXRlIiwiaGFzaGFibGVfcyIsIk0iLCJLIiwic2V4cF9vZl9tX3QiLCJzZXhwX29mX3YiLCJtX3Rfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJlcXVhbF9tX3QiLCJlcXVhbF92IiwidDIiLCJCYXNlX0hhc2h0YmwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsWUFBQUMsR0NvQm9CLGVBQTZCO0FBQUEsWUFBQUMsWUFBQUQsR0FDN0IsZUFBMkI7QUFBQSxZQUFBRSx3QkFBQUY7QUFBQUEsUUFBQSxJQUc3QztBQUFBLGVBQStCLCtEQUF5RDtBQUFBO0FBQUEsWUFBQUcsaUJBQUFILEdBQUE3QjtBQUFBQSxJQUl4RixXQVVLLHVCQUFJO0FBQUEsSUFUSjtBQUFBLElBRUgsUUFBQWlDLElBQU07QUFBQSxVQUFBQztBQUFBQSxTQUFBQSxNRC9CVjtBQUFBLEtDb0NNO0FBQUEsS0FDQTtBQUFBO0FBQUEsSUFKQTtBQUFBLElBQ0E7QUFBQSxHQUlLO0FBQUE7QUFBQSxJQUFBQyxtQkFLWTtBQUFBLElBQUFDLGlDQW9sQnJCO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxPQUFBLEdBQUFDLEtBQUFDLFVBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLGlCQXprQlM7QUFBQSxLQUFBQyxPQUFBO0FBQUEsU0FDVTtBQUFBLEtBQUFBLFNBQVI7QUFBQSxLQUFBQSxTQUNBO0FBQUEsSUFDRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBb0M7QUFBQSxHQUs3QztBQUFBLFlBQUFDLEtBQUFyQixHQUFBc0I7QUFBQUE7QUFBQUEsS0FBQTFCLE9BYVU7QUFBQSxTQUVEO0FBQUEsSUFBMEI7QUFBQTtBQUFBLFlBQUEyQixXQUFBdkIsR0FBQXdCLFNBQUFGLEtBQUFHO0FBQUFBO0FBQUFBLEtBQUFDLElBSTVCO0FBQUEsS0FBQUMsT0FDRztBQUFBLEtBQUFDLFFBQ1g7QUFBQSxTQU9xQztBQUFBLEtBQUFDLFdBQW5DO0FBQUEsSUFFRixhQUEyQjtBQUFBLElBRzNCO0FBQUEsS0FBdUM7QUFBQSxJQUN2QztBQUFBLEdBQU07QUFBQSxZQUFBQyxtQkFBQTlCO0FBQUFBO0FBQUFBLEtBQUErQixNQUlOO0FBQUEsS0FBQUMsY0FDQTtBQUFBLFNBQ0E7QUFBQTtBQUFBO0FBQUEsVUFFaUM7QUFBQSxNQUFBQyxtQkFBUjtBQUFBLFVBQ3ZCO0FBQUE7QUFBQTtBQUFBLE9BQUFDO0FBQUFBLFNBRWtCO0FBQUEsT0FBQUMsWUFDaEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsT0FBQWhFLElBQ0EsU0FBQW1ELEtBQUFHLE1BQTJCLDZCQUFxQyxTQUFRO0FBQUEsV0FDM0Q7QUFBQSxXQUEwQjtBQUFBO0FBQUEsV0FBQUMsSUFBQTtBQUFBO0FBQUEsZ0JBQ3hCO0FBQUEsUUFBYjtBQUFBLGdCQUE2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FEUTtBQUFBO0FBQUE7QUFBQSxjQVB6QztBQUFBO0FBQUE7QUFBQSxhQUhGO0FBQUE7QUFBQSxHQVlVO0FBQUEsWUFBQVUsU0FBQXBDLEdBR0ssdUJBQW9CO0FBQUEsWUFBQXFDLElBQUFyQyxHQUFBc0IsS0FBQUc7QUFBQUEsSUFHbkM7QUFBQSxJQUNRO0FBQUEsSUFDUiw0QkFBb0I7QUFBQTtBQUFBLFlBQUFhLElBQUF0QyxHQUFBc0IsS0FBQUc7QUFBQUEsSUFJcEI7QUFBQSxRQUFBRyxRQUNZO0FBQUEsSUFDWixnQkFFRSwyQ0FFYTtBQUFBO0FBQUEsWUFBQVcsUUFBQXZDLEdBQUFzQixLQUFBRztBQUFBQSxJQUlULCtCQUNHO0FBQUE7QUFBQSxLQUFBMUIsZ0JBRVc7QUFBQSxLQUFBeUM7QUFBQUEsT0FDTjtBQUFBO0FBQUEsSUFDWix1Q0FBaUI7QUFBQTtBQUFBLFlBQUFDLE1BQUF6QztBQUFBQSxJQUluQjtBQUFBLFlBQ2Esb0RBQXdCO0FBQUE7QUFBQSxTQUFBMEIsSUFBQTtBQUFBO0FBQUEsY0FDbkM7QUFBQTtBQUFBLGNBQTRCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUU5QjtBQUFBO0FBQUEsR0FBYTtBQUFBLFlBQUFnQixjQUFBMUMsR0FBQXNCLEtBQUFxQixVQUFBQztBQUFBQSxRQUFBLElBT0UsY0FBQUMsT0FBVDtBQUFBLElBQW9CLDZCQUNQLG9DQUk4RDtBQUFBLElBTHZEO0FBQUEsYUFLWTtBQUFBLEtBQWUsdUVBQTRCO0FBQUE7QUFBQSxRQUFBQyxJQUx2RCxTQUFBQyxJQUFBO0FBQUEsSUFHckI7QUFBQSxjQUE2QjtBQUFBLGNBQWdCLDZCQUUrQjtBQUFBO0FBQUEsWUFBQUMsZUFBQWhELEdBQUFzQixLQUFBMkIsR0FBQU4sVUFBQUM7QUFBQUEsUUFBQSxJQUlsRSxjQUFBQyxPQUFUO0FBQUEsSUFBb0IsNkJBQ1AsdUNBSWtFO0FBQUEsSUFMM0Q7QUFBQSxhQUthO0FBQUEsS0FBZTtBQUFBLDREQUErQjtBQUFBO0FBQUEsUUFBQUMsSUFMM0QsU0FBQUMsSUFBQTtBQUFBLElBR3JCO0FBQUEsY0FBNkI7QUFBQSxjQUFrQixnQ0FFaUM7QUFBQTtBQUFBLFlBQUFHLGVBQUFsRCxHQUFBc0IsS0FBQTJCLEdBQUFFLEdBQUFSLFVBQUFDO0FBQUFBLFFBQUEsSUFJdEUsY0FBQUMsT0FBVDtBQUFBLElBQW9CLDZCQUNQLDBDQUlxRTtBQUFBLElBTDlEO0FBQUEsYUFLYTtBQUFBLEtBQWU7QUFBQSwrREFBa0M7QUFBQTtBQUFBLFFBQUFDLElBTDlELFNBQUFDLElBQUE7QUFBQSxJQUdyQjtBQUFBLGNBQTZCO0FBQUEsY0FBb0IsbUNBRWtDO0FBQUE7QUFBQSxZQUFBSyxlQUFBcEQsR0FBQXNCLEtBQUFxQixVQUFBQztBQUFBQSxRQUFBLElBT3pFLGNBQUFDLE9BQVQ7QUFBQSxJQUFvQiw2QkFDUCxvQ0FJK0Q7QUFBQSxJQUx4RDtBQUFBLGFBS2E7QUFBQSxLQUFlLHdFQUE0QjtBQUFBO0FBQUEsUUFBQUMsSUFMeEQsU0FBQUMsSUFBQTtBQUFBLElBR3JCO0FBQUEsY0FBNkI7QUFBQSxjQUE2Qiw2QkFFbUI7QUFBQTtBQUFBLFlBQUFNLGdCQUFBckQsR0FBQXNCLEtBQUEyQixHQUFBTixVQUFBQztBQUFBQSxRQUFBLElBSW5FLGNBQUFDLE9BQVQ7QUFBQSxJQUFvQiw2QkFDUCx1Q0FJbUU7QUFBQSxJQUw1RDtBQUFBLGFBS2M7QUFBQSxLQUFlO0FBQUEsNERBQStCO0FBQUE7QUFBQSxRQUFBQyxJQUw1RCxTQUFBQyxJQUFBO0FBQUEsSUFHckI7QUFBQSxjQUE2QjtBQUFBLGNBQStCLGdDQUVxQjtBQUFBO0FBQUEsWUFBQU8sZ0JBQUF0RCxHQUFBc0IsS0FBQTJCLEdBQUFFLEdBQUFSLFVBQUFDO0FBQUFBLFFBQUEsSUFJdkUsY0FBQUMsT0FBVDtBQUFBLElBQW9CLDZCQUNQLDBDQVdGO0FBQUEsSUFaUztBQUFBLGFBT2I7QUFBQSxLQUFlO0FBQUEsK0RBS1g7QUFBQTtBQUFBLFFBQUFDLElBWlMsU0FBQUMsSUFBQTtBQUFBLElBR3JCO0FBQUEsY0FBNkI7QUFBQSxjQUFpQyxtQ0FTbEQ7QUFBQTtBQUFBLFlBQUFKLFNBQUFJLEdBSUEsY0FBTTtBQUFBLFlBQUFILGFBQUExQixPQUNGLFNBQUk7QUFBQSxZQUFBcUMsS0FBQXZELEdBQUFzQjtBQUFBQSxJQUNaLG9EQUEyQztBQUFBO0FBQUEsWUFBQWtDLElBQUF4RCxHQUFBc0I7QUFBQUEsUUFBQSxJQUl6QyxjQUFBdUIsT0FBVDtBQUFBLElBQW9CLDZCQUNQO0FBQUEsSUFETztBQUFBLGFBR1U7QUFBQSxLQUFlLGdEQUFJO0FBQUE7QUFBQSxRQUFBQyxJQUg3QjtBQUFBLElBRWUsdURBQW1CO0FBQUEsR0FDTDtBQUFBLFlBQUFXLE9BQUF6RCxHQUFBc0I7QUFBQUEsSUFJdkQ7QUFBQTtBQUFBLEtBQUFJLElBQ1E7QUFBQSxLQUFBQyxPQUNHO0FBQUEsS0FBQStCLFVBQ1g7QUFBQSxTQUNxRDtBQUFBLEtBQUE3QixXQUF0QztBQUFBLElBQ2Y7QUFBQSxLQUF1QztBQUFBO0FBQUEsU0FDdkM7QUFBQSxxQkFBNkI7QUFBQSxJQUE3QjtBQUFBLEdBQXlDO0FBQUEsWUFBQThCLE9BQUEzRCxHQUc1QixZQUFRO0FBQUEsWUFBQTRELFNBQUE1RCxHQUNFLDBCQUFJO0FBQUEsWUFBQTZELEtBQUE3RCxHQUFBOEQsTUFBQTNGO0FBQUFBLElBR2hCLGVBQ047QUFBQSxRQUFBNEYsSUFDQSxpQkFBQUMsTUFFSCxXQUFBQyxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUEsYUFFZSxzQ0FBSztBQUFBO0FBQUEsVUFBQXZDLElBQUE7QUFBQTtBQUFBLFdBQUF3QyxTQUNoQjtBQUFBO0FBQUE7QUFBQSxTQUdtQjtBQUFBO0FBQUEsYUFBQTVDLE1BSG5CLFdBQUFHLE9BQUE7QUFBQSxTQUUrQztBQUFBO0FBQUEsZUFGL0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQXBCO0FBQUFBLFNBQUFBLE1EL1BSO0FBQUEsS0N5UU07QUFBQSxLQUNBO0FBQUE7QUFBQSxJQUpBO0FBQUEsSUFDQTtBQUFBLEdBR1U7QUFBQSxZQUFBOEQsTUFBQW5FLEdBQUE3QjtBQUFBQSxJQUlkLGVBQ0s7QUFBQSxRQUFBNEYsSUFDQSxpQkFBQUUsSUFFSDtBQUFBLElBQ0E7QUFBQTtBQUFBLGFBRWUsc0NBQUs7QUFBQTtBQUFBLFVBQUF2QyxJQUFBO0FBQUE7QUFBQSxXQUFBd0MsU0FDaEI7QUFBQTtBQUFBO0FBQUEsU0FHWTtBQUFBLGlCQUFBNUMsTUFIWixXQUFBRyxPQUFBLFdBRXdDO0FBQUEsZUFGeEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFBQXBCO0FBQUFBLFNBQUFBLE1EdFJSO0FBQUEsS0M4Uk07QUFBQSxLQUNBO0FBQUE7QUFBQSxJQUhNO0FBQUE7QUFBQSxHQUdJO0FBQUEsWUFBQStELEtBQUFwRSxHQUFBN0I7QUFBQUEsSUFHQSx5QkFBQStDLE9BQUFPLE1BQWdDLDBCQUFNLEdBQUM7QUFBQTtBQUFBLFlBQUE0QyxVQUFBckUsR0FBQTdCO0FBQUFBLElBQ2xDLHlCQUFBbUQsS0FBQUosT0FBZ0MseUJBQUssR0FBQztBQUFBO0FBQUEsWUFBQW9ELGdCQUFBQyxPQUFBN0M7QUFBQUEsUUFBQUEsSUFHekQ7QUFBQTtBQUFBLFNBQUE4QyxVQUFBO0FBQUEsS0FDRztBQUFBLE1BRUUsMkNBQTBCO0FBQUE7QUFBQSxVQURVO0FBQUEsVUFBYjtBQUFBLE1BQUE5QyxNQUFEO0FBQUEsS0FBdUM7QUFBQTtBQUFBLEdBQ25DO0FBQUEsWUFBQStDLFdBQUF6RTtBQUFBQSxJQUkvQjtBQUFBLEtBQXFCLFFBQVE7QUFBQSxJQUM3QiwrQkFBeUI7QUFBQTtBQUFBLFlBQUEwRSxPQUFBMUUsR0FHVCw2QkFBK0IseUJBQTJCO0FBQUEsWUFBQTJFLHlCQUFBQyxjQUFBNUU7QUFBQUE7QUFBQUEsS0FBQTZFLFlBRzFEO0FBQUEsSUFDaEIsdUNBQWlDO0FBQUE7QUFBQSxZQUFBQyxnQkFBQTlELEtBQUFoQjtBQUFBQSxRQUFBNEUsZUFHZjtBQUFBLElBQ2YsNkJBQStCLDBDQUEwQztBQUFBO0FBQUEsWUFBQUcsb0JBQUEvRCxLQUFBaEI7QUFBQUEsUUFBQTRFLGVBR3REO0FBQUEsSUFDdEI7QUFBQSxLQUNLLFFBQVE7QUFBQSxJQUNiLGdEQUF3QztBQUFBO0FBQUEsWUFBQUksVUFBQUMsZUFBQUMsZ0JBQUFsRjtBQUFBQSxRQUFBLElBSTNCLG9EQUF3QjtBQUFBO0FBQUEsU0FBQTBCLElBQUE7QUFBQTtBQUFBLGNBQ0ksb0JBQXJCO0FBQUEsTUFBbEI7QUFBQSxjQUFzRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBeUQ7QUFBQUEsT0FHdEQ7QUFBQTtBQUFBO0FBQUEsa0JBQUE3RCxLQUFBRyxNQUFBQztBQUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQW1CLHVDQUNkO0FBQUE7QUFBQSxJQUVUO0FBQUE7QUFBQSxHQUE0QjtBQUFBLFlBQUFpQixXQUFBSSxHQUFBN0IsT0FJVCxTQUFDO0FBQUEsWUFBQTBCLGVBQUFFLEdBQUE5QztBQUFBQSxRQUFBLElBR3lDO0FBQUEsSUFBc0I7QUFBQSxHQUFJO0FBQUEsWUFBQW9GLFNBQUFwRixHQUFBc0I7QUFBQUEsSUFFbEUsNERBQWlEO0FBQUE7QUFBQSxZQUFBK0QsUUFBQXJGLEdBQUE3QjtBQUFBQSxJQU10RTtBQUFBLHNCQUFBbUg7QUFBQUEsY0FDRTtBQUFBO0FBQUEseUJBQUFoRSxLQUFBRztBQUFBQSxxQkFBQSxJQUFpQztBQUFBLGlCQUFZLFdBQU0sb0JBQWE7QUFBQTtBQUFBLGNBQUM7QUFBQSxhQUM1RCxFQUFDO0FBQUE7QUFBQSxZQUFBOEQsT0FBQXZGLEdBQUE3QjtBQUFBQSxJQUdRLDJCQUFBK0MsT0FBQU8sTUFBa0MsMEJBQU0sR0FBQztBQUFBO0FBQUEsWUFBQStELFNBQUF4RixHQUFBN0I7QUFBQUEsSUFDbkM7QUFBQTtBQUFBO0FBQUEsMEJBQUFtRCxLQUFBRyxNQUFxQyxtQ0FBYyxHQUFFO0FBQUE7QUFBQSxZQUFBZ0UsUUFBQXpGLEdBQUE3QjtBQUFBQSxJQUN0RDtBQUFBO0FBQUEsZ0NBQUErQyxPQUFBTyxNQUF1Qyw4QkFBUSxHQUFFO0FBQUE7QUFBQSxZQUFBaUUsT0FBQTFGLEdBQUE3QjtBQUFBQSxJQUd0RTtBQUFBO0FBQUE7QUFBQSxzQkFBQW1ELEtBQUFHLE1BQUF1QztBQUFBQSxjQUE0QztBQUFBLHdCQUFrQjtBQUFBLDJCQUFnQjtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUEyQixNQUFBM0YsR0FBQTdCO0FBQUFBLElBSy9FO0FBQUE7QUFBQTtBQUFBLHNCQUFBK0MsT0FBQU8sTUFBQXVDO0FBQUFBLGNBQThDO0FBQUEsd0JBQVk7QUFBQSwyQkFBZ0I7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBNEIsS0FBQTVGLEdBQUE3QjtBQUFBQSxRQUFBMEgsUUFLekU7QUFBQSxJQUVGO0FBQUE7QUFBQSxlQUFBdkUsS0FBQUcsTUFBbUQsT0FBYyxnQkFBZCx5QkFBYztBQUFBLElBQUM7QUFBQSxHQUM3RDtBQUFBLFlBQUFxRSxJQUFBOUYsR0FBQTdCO0FBQUFBLElBR1Esd0JBQUErQyxPQUFBTyxNQUErQiwwQkFBTSxHQUFDO0FBQUE7QUFBQSxZQUFBc0UsS0FBQS9GLEdBQ3hDLDBCRHRYYixXQ3NYMkI7QUFBQSxZQUFBZ0csWUFBQWhHLEdBQUE3QjtBQUFBQSxRQUFBMEgsUUFJdkI7QUFBQSxJQUVGO0FBQUE7QUFBQSxlQUFBdkUsS0FBQUc7QUFBQUEsV0FBQXdFLFFBQ1E7QUFBQSxPQUFZLFlBRVI7QUFBQSxXQUFBQyxXQUZRO0FBQUEsT0FDQyxnQ0FDUDtBQUFBO0FBQUEsSUFBQztBQUFBLEdBQ1Y7QUFBQSxZQUFBQyxXQUFBbkcsR0FBQTdCO0FBQUFBLElBR2UsK0JBQUErQyxPQUFBTyxNQUFzQywwQkFBTSxHQUFDO0FBQUE7QUFBQSxZQUFBMkUsUUFBQXBHLEdBQUE3QjtBQUFBQSxJQUdqRTtBQUFBO0FBQUEsc0JBQUFtRCxLQUFBRztBQUFBQSxjQUF1QywrQ0FBcUM7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBNEUsT0FBQXJHLEdBQUE3QjtBQUFBQSxJQUc3RCwyQkFBQStDLE9BQUFPLE1BQWtDLDBCQUFNLEdBQUM7QUFBQTtBQUFBLFlBQUE2RSxZQUFBdEcsR0FBQTdCO0FBQUFBLElBQ3BDLDJCQUFBbUQsS0FBQUosT0FBa0MseUJBQUssR0FBQztBQUFBO0FBQUEsWUFBQXFGLGVBQUF2RyxHQUFBN0I7QUFBQUE7QUFBQUEsS0FBQXFJLEtBSTNEO0FBQUEsS0FBQUMsS0FHQTtBQUFBLElBRUY7QUFBQTtBQUFBLGVBQUFuRixLQUFBRztBQUFBQSxXQUFBd0UsUUFDUztBQUFBLE9BQVk7QUFBQSxZQUFBQyxXQUFBO0FBQUEsUUFDQyw2QkFDMkI7QUFBQTtBQUFBLFdBQUFBLGFBRjVCO0FBQUEsT0FFRSwrQkFBMEI7QUFBQTtBQUFBLElBQUM7QUFBQSxHQUM1QztBQUFBLFlBQUFRLGNBQUExRyxHQUFBN0I7QUFBQUEsSUFHaUI7QUFBQSx5QkFBQStDLE9BQUFPLE1BQXlDLDBCQUFNLEdBQUM7QUFBQTtBQUFBLFlBQUFrRixjQUFBM0csR0FBQTdCO0FBQUFBLElBR3ZFO0FBQUE7QUFBQSxzQkFBQW1ELEtBQUFHO0FBQUFBLGNBQTBDLHVEQUE2QztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFtRixhQUFBNUcsR0FBQTdCO0FBQUFBLElBSWxFO0FBQUEseUJBQUErQyxPQUFBTyxNQUF3QywwQkFBTSxHQUFDO0FBQUE7QUFBQSxZQUFBb0YsWUFBQTdHLEdBQUE4RyxJQUFBQztBQUFBQSxJQUdyRTtBQUFBO0FBQUE7QUFBQSxzQkFBQXRGLE1BR3lCLFlBQUk7QUFBQSxzQkFBQUg7QUFBQUEsa0JBQUF5RixZQUVYO0FBQUEsY0FDZDtBQUFBLGNBQXdCO0FBQUEsYUFDakIsRUFBQztBQUFBO0FBQUEsWUFBQUMsYUFBQWhILEdBQUE4RyxJQUFBQztBQUFBQSxJQUlaO0FBQUE7QUFBQTtBQUFBLHNCQUFBdEYsTUFHeUIsWUFBSTtBQUFBLHNCQUFBSDtBQUFBQSxrQkFBQXlGLFlBRVg7QUFBQSxjQUNkO0FBQUEsY0FBd0I7QUFBQSxhQUNqQixFQUFDO0FBQUE7QUFBQSxZQUFBRSxnQkFBQWpILEdBQUFzQjtBQUFBQSxRQUFBNEYsU0F4TkM7QUFBQSxJQStOVix1Q0FBMkI7QUFBQSxJQUM5QjtBQUFBLEdBQU07QUFBQSxZQUFBQyxPQUFBbkgsR0FBQXNCLEtBQUFuRDtBQUFBQSxRQUFBOEgsUUFJQSxjQXBPTztBQUFBLElBb09NLFlBQ1QscUJBQ3dCO0FBQUEsUUFBQXhFLE9BRmY7QUFBQSxJQUVKLHdCQUFtQjtBQUFBO0FBQUEsWUFBQTJGLGtCQUFBcEgsR0FBQXNCLEtBQUFuRDtBQUFBQSxRQUFBc0QsT0FJdkIsY0ExT0U7QUFBQSxJQTJPYjtBQUFBLElBQW1CO0FBQUEsR0FDZjtBQUFBLFlBQUE0RixPQUFBckgsR0FBQThHLElBQUEzSSxHQUd1Qiw2QkFBeUIsU0FBSztBQUFBLFlBQUFtSixRQUFBQyxnQkFBQXZILEdBQUFzQixLQUFBa0c7QUFBQUEsSUFHekQ7QUFBQSxLQU9FO0FBQUE7QUFBQTtBQUFBLHVCQUFBdEc7QUFBQUEsZUFBZ0IsWUFDSjtBQUFBLG1CQUFBUSxJQURJO0FBQUEsZUFFRix3Q0FBTztBQUFBO0FBQUE7QUFBQSxLQUFBVixNQTNQVjtBQUFBLFNBcVBFO0FBQUEsS0FBQStDLElBQUw7QUFBQSxLQUFBa0MsUUFBZ0M7QUFBQSxJQWpCdkIsWUFDVCxxQkFzQmE7QUFBQSxRQUFBeEUsT0F2Qko7QUFBQSxJQUVKLHdCQXFCUTtBQUFBO0FBQUEsWUFBQWdHLEtBQUEsR0FBQXpHLEtBQUFoQixHQUFBc0I7QUFBQUEsUUFBQWtHLEtBR2hCLGNBQUFELGlCQUFBO0FBQUEsSUFBNEMsMENBQWdDO0FBQUE7QUFBQSxZQUFBRyxLQUFBLEdBQUExRyxLQUFBaEIsR0FBQXNCO0FBQUFBLFFBQUFrRyxLQUM1RSxjQUFBRCxpQkFBQTtBQUFBLElBQTBFLE9BQUssZ0NBQUwsZ0NBQUs7QUFBQTtBQUFBLFlBQUFJLFVBQUEzSCxHQUFBc0IsS0FBQUc7QUFBQUEsSUFHdEY7QUFBQTtBQUFBO0FBQUEsc0JBQUFQO0FBQUFBLGNBQWdCLFlBQ0o7QUFBQSxrQkFBQTBHLElBREk7QUFBQSxjQUVGO0FBQUEsYUFBVTtBQUFBO0FBQUEsWUFBQUMsYUFBQTdILEdBQUFzQjtBQUFBQSxRQUFBMkUsUUFwUVg7QUFBQSxJQXdRRyxZQUNOO0FBQUEsWUFETTtBQUFBLHNCQUFBNkIsS0FBQSxNQUdJLHNCQUFtQjtBQUFBLElBRGIscUJBQ2E7QUFBQTtBQUFBLFlBQUFDLFdBQUEvSCxHQUFBc0I7QUFBQUEsUUFBQTJFLFFBM1ExQjtBQUFBLElBK1FHLFlBQ047QUFBQSxRQUFBMkIsSUFETTtBQUFBLElBRUo7QUFBQSxHQUFDO0FBQUEsWUFBQUk7QUFBQUEsSUFBQTdHLGdCQUFBQyxNQUFBSCxVQUFBZ0gsU0FBQUMsVUFBQUM7QUFBQUEsSUFJYjtBQUFBLFNBQUFDLElBQUEsU0FBQWhILFNBRWM7QUFBQTtBQUFBLFNBQUFBLFNBQ0Y7QUFBQTtBQUFBLEtBQUFpSCxNQUVGO0FBQUEsS0FBQUMsUUFDVjtBQUFBLElBQ0E7QUFBQTtBQUFBO0FBQUEsZUFBQWhEO0FBQUFBLFdBQUFoRSxNQUNZLHdCQUFBRyxPQUNDO0FBQUEsT0FDUjtBQUFBO0FBQUEsaUJBQTZDLG1CQUFrQjtBQUFBO0FBQUEsUUFBQThHLE9BQUM7QUFBQTtBQUFBLDZCQUczQztBQUFBLDZCQUE2RDtBQUFBO0FBQUEsWUFBQUMsU0FBQXJILGdCQUFBQyxNQUFBSCxVQUFBd0g7QUFBQUE7QUFBQUEsS0FBQXhDO0FBQUFBLE9Ba0JqRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUF5QyxVQUE0RTtBQUFBO0FBQUEsU0FBQTVGLElBQUE7QUFBQSxLQUU1QyxvREFBZTtBQUFBO0FBQUEsUUFBQTlDLElBRjZCO0FBQUEsSUFDdkU7QUFBQSxHQUMwQztBQUFBLFlBQUEySSx5QkFBQXhILGdCQUFBQyxNQUFBSCxVQUFBd0g7QUFBQUEsSUFJckQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQTRFO0FBQUE7QUFBQSxZQUFBRyxrQkFBQXpILGdCQUFBQyxNQUFBSCxVQUFBd0g7QUFBQUE7QUFBQUEsS0FBQXhDLFFBSXRFO0FBQUEsS0FBQXlDLFVBQTRDO0FBQUEsNkJBQUEzRixJQUFBLFVBQ3ZDO0FBQUEsUUFBQXpCLE1BRHVDLFVBQUF2QixjQUdoRDtBQUFBLElBQ0E7QUFBQSwwRUFBb0U7QUFBQTtBQUFBLFlBQUE4SSxhQUFBMUgsZ0JBQUFDLE1BQUFILFVBQUF3SDtBQUFBQSxRQUFBeEMsUUFJaEU7QUFBQSxJQUFxRCx1QkFBQWxELElBQUEsVUFDMUM7QUFBQSxRQUFBK0YsSUFEMEM7QUFBQSxJQUV2QyxtQ0FBYTtBQUFBO0FBQUEsWUFBQUMsZUFBQTVILGdCQUFBQyxRQUFBSCxVQUFBa0g7QUFBQUEsUUFBQUQsV0FJakMsa0JBQUFELFVBQUE7QUFBQSxJQXRDQTtBQUFBLFNBQUFHLElBQUEsV0FBQWhILE9BRWM7QUFBQTtBQUFBLFNBQUFBLE9BQ0Y7QUFBQSxRQUFBaUgsTUFFRjtBQUFBLElBQ1Y7QUFBQTtBQUFBO0FBQUEsZUFBQS9DO0FBQUFBLFdBQUFoRSxNQUNZLFlBQUFHLE9BQ0M7QUFBQSxPQUNYLGdDQUF3QjtBQUFBO0FBQUEsSUFBQztBQUFBLEdBNkJ1RDtBQUFBLFlBQUF1SCxTQUFBaEo7QUFBQUEsSUFHbkU7QUFBQTtBQUFBO0FBQUEsc0JBQUFzQixLQUFBRyxNQUFBd0gsTUFBZ0MsaUNBQW1CLEVBQVk7QUFBQTtBQUFBLFlBQUFDLFVBQUFuSixhQUFBb0osY0FBQW5KO0FBQUFBO0FBQUFBLEtBQUEsSUFHOUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFBa0I7QUFBQUEsY0FBQWtJLEtBRXNCLFVBQUFDLEtBQUE7QUFBQSxVQUF3QixrQ0FBeUI7QUFBQTtBQUFBLFNBQ3ZEO0FBQUEsSUFBYjtBQUFBLCtCQUFhLDRDQUF1QztBQUFBO0FBQUEsWUFBQUMsVUFBQXJJLFVBQUFzSSxXQUFBQyxXQUFBQztBQUFBQTtBQUFBQSxLQUFBLElBSTlCO0FBQUEsS0FBQUM7QUFBQUEsT0FBYjtBQUFBLDJCQUFhO0FBQUEsS0FBQXpEO0FBQUFBLE9BQ25CLGdCQUErQjtBQUFBLEtBQUF5QyxVQUFtQjtBQUFBLDZCQUFBM0YsSUFBQSxVQUM3QztBQUFBLFFBQUFELElBRDZDO0FBQUEsa0JEeGpCMUQ7QUFBQTtBQUFBO0FBQUEsU0M2akJtQztBQUFBLEtBQUE2RztBQUFBQSxPQUFiLHdDQUFhO0FBQUEsS0FBQUMsZ0JBQy9CO0FBQUEsSUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUFBMUk7QUFBQUE7QUFBQUEsUUFBQTJJLFVBQW9DO0FBQUEsUUFBQVQsS0FBQTtBQUFBLFlBQy9CO0FBQUEsT0FBcUI7QUFBQSxRQUV0QjtBQUFBLFNBQ0s7QUFBQSxnRUFDc0I7QUFBQSxRQUF0QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUppQjtBQUFBO0FBQUEsTUFJSztBQUFBO0FBQUEsR0FDbkI7QUFBQSxZQUFBVSxlQUFBQyxXQUFBQztBQUFBQSxRQUFBLElBU2U7QUFBQSxJQUErQztBQUFBO0FBQUEsWUFBQXpCLEtBQUF2STtBQUFBQSxJQUdqRSwyQkFBQXNCLEtBQUFKLE9BQUE4QyxLQUE0QyxxQkFBVSxFQUFDO0FBQUE7QUFBQSxZQUFBdkMsS0FBQXpCO0FBQUFBLElBQ3ZELDJCQUFBa0IsT0FBQU8sTUFBQXdILE1BQWtDLHVCQUFZLEVBQVk7QUFBQTtBQUFBLFlBQUFnQjtBQUFBQSxJQUFBOUksZ0JBQUFDLE1BQUFILFVBQUFnSCxTQUFBQyxVQUFBZ0MsU0FBQS9CO0FBQUFBLFFBQUFnQyxTQWUzRDtBQUFBLElBWlY7QUFBQTtBQUFBO0FBQUEsZUFBQUM7QUFBQUE7QUFBQUEsUUFBQTlJLE1BQ1k7QUFBQSxRQUFBRyxPQUNDO0FBQUEsUUFBQXdFLFFBelhBO0FBQUEsT0EyWFk7QUFBQSxZQUFBb0UsTUFBQSxVQUFBNUksU0FFUDtBQUFBO0FBQUEsWUFBQUEsU0FGTztBQUFBLE9BSXZCLCtCQUFxQjtBQUFBO0FBQUEsSUFLNEI7QUFBQSxHQUNoRDtBQUFBLFlBQUE2SSxnQkFBQW5KLGdCQUFBQyxNQUFBSCxVQUFBZ0gsU0FBQUU7QUFBQUEsSUFJSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJEdm1CRjtBQUFBLGtCQ3VtQjZFO0FBQUE7QUFBQSxZQUFBb0M7QUFBQUEsSUFBQXBKLGdCQUFBQyxNQUFBSCxVQUFBZ0gsU0FBQUU7QUFBQUE7QUFBQUEsS0FBQWxDLFFBSXJFO0FBQUEsS0FBQXlDLFVBQTZEO0FBQUE7QUFBQTtBQUFBLE1BQUFILE9BQUE7QUFBQSxNQUFBeEksY0FHakU7QUFBQTtBQUFBLFFBSWU7QUFBQSxVQUZiO0FBQUEsS0FFNkM7QUFBQTtBQUFBLFFBQUFDLElBUGtCO0FBQUEsSUFDeEQ7QUFBQSxHQU1zQztBQUFBLFlBQUF3SyxvQkFBQXJKLGdCQUFBQyxNQUFBSCxVQUFBZ0gsU0FBQUU7QUFBQUE7QUFBQUEsS0FBQTtBQUFBLE9BSWpDO0FBQUEsSUFBd0U7QUFBQTtBQUFBLFlBQUFzQyxVQUFBekssR0FBQXNCLEtBQUFuRCxHQUFBdU07QUFBQUEsUUFBQXpFLFFBS2hGO0FBQUEsSUFBUSxZQUNKO0FBQUEsUUFBQWxELElBREk7QUFBQSxJQUVGLHFCQUFrQjtBQUFBO0FBQUEsWUFBQTRILE1BQUFDLFFBQUFDLFNBQUExTTtBQUFBQSxJQUd2QjtBQUFBLEtBQ0Y7QUFBQSxRQUFBMEgsUUFFSDtBQUFBLElBTUY7QUFBQTtBQUFBLGVBQUEzRTtBQUFBQSxPQUNFO0FBQUE7QUFBQSx5QkFBQUE7QUFBQUEsaUJBQ0U7QUFBQTtBQUFBLDRCQUFBSSxLQUFBd0o7QUFBQUE7QUFBQUEscUJBQUE3RSxRQTdhTztBQUFBLG9CQThhaUI7QUFBQSxxQkFDWixxREFDbUQ7QUFBQSx3QkFBQThFLFFBRnZDO0FBQUEsb0JBRU47QUFBQSw2RUFBNkM7QUFBQTtBQUFBLGlCQUFDO0FBQUE7QUFBQSxtQ0FBQXpKLEtBQUF5SjtBQUFBQSwyQkFoYnpEO0FBQUE7QUFBQSxxQ0FtYkssK0NBQ0k7QUFBQSw0QkFDc0I7QUFBQSxrQkFBQztBQUFBO0FBQUEsSUFBWTtBQUFBLEdBQ2xEO0FBQUEsWUFBQUMsV0FBQUMsS0FBQUMsS0FBQS9NO0FBQUFBLElBSVA7QUFBQTtBQUFBLHNCQUFBbUQsS0FBQUc7QUFBQUE7QUFBQUEsZUFBQTBKLGFBMWJhO0FBQUEsZUFBQUM7QUFBQUEsaUJBNGJFO0FBQUE7QUFBQSw0QkFBQWxLO0FBQUFBLG9CQUFnQywyQ0FBb0I7QUFBQTtBQUFBLGNBQ2pFLGFBQ1ksdUJBSW9FO0FBQUEsa0JBQUFPLFNBTGhGO0FBQUEsY0FHRSxpQkFDVyw0QkFDbUU7QUFBQTtBQUFBLGVBQUEwSixXQUY5RTtBQUFBLG1CQUVvQjtBQUFBLHlCQUF1Qyx5QkFBbUI7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBRSxnQkFBQXJMLEdBQUE3QjtBQUFBQTtBQUFBQSxLQUFBbU47QUFBQUEsT0FNakY7QUFBQTtBQUFBO0FBQUEsa0JBQUFoSyxLQUFBRyxNQUFBOEo7QUFBQUEsVUFBNEMsbURBQW1DO0FBQUE7QUFBQSxJQUVqRjtBQUFBLHVDQUFBakssS0FBbUMscUJBQVksR0FBQztBQUFBO0FBQUEsWUFBQWtLLGVBQUF4TCxHQUFBN0I7QUFBQUEsSUFHeEI7QUFBQSx5QkFBQStDLE9BQUFPLE1BQTBDLDBCQUFNLEdBQUM7QUFBQTtBQUFBLFlBQUFnSyxvQkFBQXpMLEdBQUE3QjtBQUFBQSxJQUM1QztBQUFBLHlCQUFBbUQsS0FBQUosT0FBMEMseUJBQUssR0FBQztBQUFBO0FBQUEsWUFBQXdLLG9CQUFBMUwsR0FBQTdCO0FBQUFBO0FBQUFBLEtBQUF3TjtBQUFBQSxPQUczRDtBQUFBO0FBQUE7QUFBQSxrQkFBQXJLLEtBQUFHLE1BQUE4SjtBQUFBQSxVQUErQyxrREFBWTtBQUFBLFNBQU87QUFBQSxJQUNwRjtBQUFBO0FBQUE7QUFBQSxzQkFBQXJLO0FBQUFBLGtCQUFBZ0csU0FBeUIsVUFBQTVGLE1BQUE7QUFBQSxjQUN2QixhQUNVLHFCQUNzQjtBQUFBLGtCQUFBRyxPQUZoQztBQUFBLGNBRWUsd0JBQWlCO0FBQUE7QUFBQTtBQUFBLFlBQUFtSyxtQkFBQTVMLEdBQUE3QjtBQUFBQSxJQUlsQztBQUFBLHlCQUFBK0MsT0FBQU8sTUFBOEMsMEJBQU0sR0FBQztBQUFBO0FBQUEsWUFBQW9LLGFBQUE3TCxHQUFBN0I7QUFBQUEsSUFJckQ7QUFBQSxJQUF5QjtBQUFBO0FBQUEsc0JBQUErQztBQUFBQSxrQkFBQSxJQUV2QjtBQUFBO0FBQUEsK0NEN3JCSixpQkM2ckJtRDtBQUFBLGVBQXVCO0FBQUE7QUFBQSxZQUFBNEssWUFBQTlMLEdBQUE3QjtBQUFBQSxJQUduRCxnQ0FBQStDLE9BQUFPLE1BQXVDLDBCQUFNLEdBQUM7QUFBQTtBQUFBLFlBQUFzSyxRQUFBQyxPQUFBaE0sS0FBQUE7QUFBQUEsUUFBQSxJQUczRDtBQUFBO0FBQUE7QUFBQSx3QkFBQXNGO0FBQUFBLGdCQUVGO0FBQUE7QUFBQSwyQkFBQXBFO0FBQUFBLG1CQUNFO0FBQUE7QUFBQSxxQ0FBQUksS0FBQUc7QUFBQUEsaUNBQUF3RSxRQXhlSztBQUFBLDZCQXllYyxZQUNQLHVCQUNtRDtBQUFBO0FBQUEsOEJBQUF4RSxTQUY1QztBQUFBLGtDQUVNO0FBQUEsNkJBQWtCLFdBQU0sb0JBQWM7QUFBQSw4QkFBQztBQUFBO0FBQUEsZ0JBQVk7QUFBQSxlQUMxRTtBQUFBLGVBQWE7QUFBQTtBQUFBLFlBQUF3SyxTQUFBQztBQUFBQSxRQUFBakwsV0Qxc0J6QjtBQUFBLGFBQUFGLFNBQUFJLGdCQUFBQyxNQUFBRjtBQUFBQSxLQzJ5QndDLGdEQUF5QztBQUFBO0FBQUEsYUFBQXNILFdBQUFySCxnQkFBQUMsTUFBQXdHO0FBQUFBLEtBQ3hDLGtEQUEwQztBQUFBO0FBQUEsYUFBQWUsMkJBQUF4SCxnQkFBQUMsTUFBQXdHO0FBQUFBLEtBRy9FLGtFQUEwRDtBQUFBO0FBQUEsYUFBQWdCLG9CQUFBekgsZ0JBQUFDLE1BQUF3RztBQUFBQSxLQUkxRCwyREFBbUQ7QUFBQTtBQUFBLGFBQUFpQixlQUFBMUgsZ0JBQUFDLE1BQUF3RztBQUFBQSxLQUluRCxzREFBOEM7QUFBQTtBQUFBLGFBQUEwQixZQUFBQyxXQUFBQyxXQUFBQztBQUFBQSxLQUdQLHNEQUE0QztBQUFBO0FBQUEsYUFBQVYsaUJBQUE1SCxnQkFBQUMsTUFBQXdHO0FBQUFBLEtBR25GLHdEQUFnRDtBQUFBO0FBQUEsYUFBQUksZ0JBQUE3RyxnQkFBQUMsTUFBQTZHLFNBQUFDLFVBQUFOO0FBQUFBLEtBSWhEO0FBQUEsbUVBQWtFO0FBQUE7QUFBQSxhQUFBMEMsa0JBQUFuSixnQkFBQUMsTUFBQTZHLFNBQUFMO0FBQUFBLEtBSWxFLGtFQUEwRDtBQUFBO0FBQUEsYUFBQTJDLDJCQUFBcEosZ0JBQUFDLE1BQUE2RyxTQUFBTDtBQUFBQSxLQUkxRDtBQUFBLHlEQUFtRTtBQUFBO0FBQUEsYUFBQTRDLHNCQUFBckosZ0JBQUFDLE1BQUE2RyxTQUFBTDtBQUFBQSxLQUluRSxzRUFBOEQ7QUFBQTtBQUFBLGFBQUFxQyxRQUFBOUksZ0JBQUFDLE1BQUE2RyxTQUFBQyxVQUFBZ0MsU0FBQXRDO0FBQUFBLEtBSTlEO0FBQUEsNEVBQW1FO0FBQUE7QUFBQSxJRGoxQnZFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUEzRyxXQytuQkU7QUFBQTtBQUFBLElBQUFxSSxjQUFBO0FBQUEsSUFBQXZJLFdBQUE7QUFBQSxJQUFBeUgsYUFBQTtBQUFBLElBQUFHLDZCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFFLG1CQUFBO0FBQUEsSUFBQWYsa0JBQUE7QUFBQSxJQUFBc0Msb0JBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQVAsVUFBQTtBQUFBLFlBQUFoSixXQUFBakIsR0FnUGlCLFlBQVU7QUFBQSxPQUFBbU0sVUFoUDNCO0FBQUEsWUFBQXBMLFNBQUFJLGdCQUFBQyxNQUFBNkM7QUFBQUEsSUFvUGlCLE9BQW1CLDZCQUFuQixrQ0FBNEM7QUFBQTtBQUFBLFlBQUF1RSxXQUFBckgsZ0JBQUFDLE1BQUE2QyxHQUFBMkQ7QUFBQUEsSUFJMUMsT0FBbUIsK0JBQW5CLGtDQUEyQztBQUFBO0FBQUEsWUFBQWUsMkJBQUF4SCxnQkFBQUMsTUFBQTZDLEdBQUEyRDtBQUFBQSxJQUkzQixPQUFtQjtBQUFBLG1DQUFuQixrQ0FBMkM7QUFBQTtBQUFBLFlBQUFnQixvQkFBQXpILGdCQUFBQyxNQUFBNkMsR0FBQTJEO0FBQUFBLElBSWxELE9BQW1CO0FBQUEsbUNBQW5CLGtDQUEyQztBQUFBO0FBQUEsWUFBQWlCLGVBQUExSCxnQkFBQUMsTUFBQTZDLEdBQUEyRDtBQUFBQSxJQUloRCxPQUFtQjtBQUFBLG1DQUFuQixrQ0FBMkM7QUFBQTtBQUFBLFlBQUFtQixpQkFBQTVILGdCQUFBQyxNQUFBNkMsR0FBQTJEO0FBQUFBLElBSXpDLE9BQW1CO0FBQUEsbUNBQW5CLGtDQUEyQztBQUFBO0FBQUEsWUFBQUksZ0JBQUE3RyxnQkFBQUMsTUFBQTZDLEdBQUFnRSxTQUFBQyxVQUFBTjtBQUFBQSxJQUk1QyxPQUFtQjtBQUFBO0FBQUE7QUFBQSxhQUFuQjtBQUFBO0FBQUE7QUFBQSxlQUE4RDtBQUFBO0FBQUEsWUFBQTBDLGtCQUFBbkosZ0JBQUFDLE1BQUE2QyxHQUFBZ0UsU0FBQUw7QUFBQUEsSUFJNUQsT0FBbUI7QUFBQSxtQ0FBbkIsMkNBQW9EO0FBQUE7QUFBQSxZQUFBMkMsMkJBQUFwSixnQkFBQUMsTUFBQTZDLEdBQUFnRSxTQUFBTDtBQUFBQSxJQUkzQyxPQUFtQjtBQUFBLG1DQUFuQiwyQ0FBb0Q7QUFBQTtBQUFBLFlBQUE0QyxzQkFBQXJKLGdCQUFBQyxNQUFBNkMsR0FBQWdFLFNBQUFMO0FBQUFBLElBSXpELE9BQW1CO0FBQUEsbUNBQW5CLDJDQUFvRDtBQUFBO0FBQUEsWUFBQXFDLFFBQUE5SSxnQkFBQUMsTUFBQTZDLEdBQUFnRSxTQUFBQyxVQUFBZ0MsU0FBQXRDO0FBQUFBLElBSWxFLE9BQW1CO0FBQUE7QUFBQTtBQUFBLGFBQW5CO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBdUU7QUFBQTtBQUFBLFlBQUF3RSxXQUFBcE0sR0FHdEUsd0NBQTBCO0FBQUEsWUFBQXFNLEVBQUFDLEdEOTVCN0MsV0NrNkJHO0FBQUEsWUFBQUMsWUFBQUQsR0FBQUUsV0FBQXhNO0FBQUFBLElBK0JELG9DQUFpQztBQUFBO0FBQUEsWUFBQXlNLFlBQUFILEdBQUFJLFdBQUFqRDtBQUFBQSxRQUFBLElBSWI7QUFBQSxXQUE0QjtBQUFBLGFBQTVCO0FBQUE7QUFBQTtBQUFBLGtCQUF1RDtBQUFBO0FBQUEsWUFBQWtELGlCQUFBTCxHQUFBdEM7QUFBQUEsSUFJM0Usc0NBQXlDO0FBQUE7QUFBQSxZQUFBNEMsVUFBQTFMLE9BQUEyTCxTQUFBcEcsSUFBQXFHLElBR1MsK0JBQW1CO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BN1VyRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEL25CRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5Nzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9IYXNoX3NldF9pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMscUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozOTc5NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZS9oYXNoX3NldC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBIYXNoX3NldF9pbnRmXG5cbmxldCBoYXNoYWJsZV9zID0gSGFzaHRibC5oYXNoYWJsZV9zXG5sZXQgaGFzaGFibGUgPSBIYXNodGJsLlByaXZhdGUuaGFzaGFibGVcbmxldCBwb2x5X2hhc2hhYmxlID0gSGFzaHRibC5Qb2x5Lmhhc2hhYmxlXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICdhIHQgPSAoJ2EsIHVuaXQpIEhhc2h0YmwudFxudHlwZSAnYSBoYXNoX3NldCA9ICdhIHRcbnR5cGUgJ2EgZWx0ID0gJ2FcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICBsZXQgY2xlYXIgPSBIYXNodGJsLmNsZWFyXG4gIGxldCBsZW5ndGggPSBIYXNodGJsLmxlbmd0aFxuICBsZXQgbWVtID0gSGFzaHRibC5tZW1cbiAgbGV0IGlzX2VtcHR5IHQgPSBIYXNodGJsLmlzX2VtcHR5IHRcblxuICBsZXQgZmluZF9tYXAgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBIYXNodGJsLml0ZXJfa2V5cyB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgIG1hdGNoIGYgZWx0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgIHwgU29tZSBfIGFzIG8gLT4gci5yZXR1cm4gbyk7XG4gICAgICBOb25lKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmRfbWFwIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIFNvbWUgYSBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbiAgbGV0IGFkZCB0IGsgPSBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKVxuXG4gIGxldCBzdHJpY3RfYWRkIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwiZWxlbWVudCBhbHJlYWR5IGV4aXN0c1wiXG4gICAgZWxzZSAoXG4gICAgICBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKTtcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgOztcblxuICBsZXQgc3RyaWN0X2FkZF9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfYWRkIHQgaylcbiAgbGV0IHJlbW92ZSA9IEhhc2h0YmwucmVtb3ZlXG5cbiAgbGV0IHN0cmljdF9yZW1vdmUgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmUgdCBrO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3IgXCJlbGVtZW50IG5vdCBpbiBzZXRcIiBrIChIYXNodGJsLnNleHBfb2Zfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9yZW1vdmVfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X3JlbW92ZSB0IGspXG5cbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gICAgSGFzaHRibC5mb2xkIHQgfmluaXQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIGFjYyAtPiBmIGFjYyBrZXkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgaXRlciB0IH5mID0gSGFzaHRibC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbiAgbGV0IHRvX2xpc3QgPSBIYXNodGJsLmtleXNcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZSB0ID1cbiAgICBzZXhwX29mX2xpc3Qgc2V4cF9vZl9lICh0b19saXN0IHQgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihoYXNoYWJsZSB0KS5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXQgaW5kZXggPSByZWYgKGxlbiAtIDEpIGluXG4gICAgZm9sZCB0IH5pbml0Olt8fF0gfmY6KGZ1biBhY2Mga2V5IC0+XG4gICAgICBpZiBBcnJheS5sZW5ndGggYWNjID0gMFxuICAgICAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiBrZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBpbmRleCA6PSAhaW5kZXggLSAxO1xuICAgICAgICBhY2MuKCFpbmRleCkgPC0ga2V5O1xuICAgICAgICBhY2MpKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9IEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSkgW0Bub250YWlsXVxuICBsZXQgZm9yX2FsbCB0IH5mID0gbm90IChIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gbm90IChmIGtleSkpKVxuICBsZXQgZXF1YWwgdDEgdDIgPSBIYXNodGJsLmVxdWFsIChmdW4gKCkgKCkgLT4gdHJ1ZSkgdDEgdDJcbiAgbGV0IGNvcHkgdCA9IEhhc2h0YmwuY29weSB0XG4gIGxldCBmaWx0ZXIgdCB+ZiA9IEhhc2h0YmwuZmlsdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSkgW0Bub250YWlsXVxuICBsZXQgdW5pb24gdDEgdDIgPSBIYXNodGJsLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleTpfIF8gLT4gU29tZSAoKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBmaWx0ZXIgdDEgfmY6KGZ1biBrZXkgLT4gbm90IChIYXNodGJsLm1lbSB0MiBrZXkpKVxuXG4gIGxldCBpbnRlciB0MSB0MiA9XG4gICAgbGV0IHNtYWxsZXIsIGxhcmdlciA9IGlmIGxlbmd0aCB0MSA+IGxlbmd0aCB0MiB0aGVuIHQyLCB0MSBlbHNlIHQxLCB0MiBpblxuICAgIEhhc2h0YmwuZmlsdGVyaSBzbWFsbGVyIH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBIYXNodGJsLm1lbSBsYXJnZXIga2V5KVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgICBsZXQgdG9fcmVtb3ZlID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWMgeCAtPiBpZiBmIHggdGhlbiBhYyBlbHNlIHggOjogYWMpIGluXG4gICAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIHggLT4gcmVtb3ZlIHQgeClcbiAgOztcblxuICBsZXQgb2ZfaGFzaHRibF9rZXlzIGhhc2h0YmwgPSBIYXNodGJsLm1hcCBoYXNodGJsIH5mOmlnbm9yZVxuICBsZXQgdG9faGFzaHRibCB0IH5mID0gSGFzaHRibC5tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtXG5cbmxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCBsXG4gIGluXG4gIGxldCB0ID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIG0gaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biBrIC0+IGFkZCB0IGspO1xuICB0XG47O1xuXG5sZXQgdF9vZl9zZXhwIG0gZV9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIHJlcXVpcmVzIGEgbGlzdFwiIHNleHBcbiAgfCBTZXhwLkxpc3QgbGlzdCAtPlxuICAgIGxldCB0ID0gY3JlYXRlIG0gfnNpemU6KExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biBzZXhwIC0+XG4gICAgICBsZXQgZSA9IGVfb2Zfc2V4cCBzZXhwIGluXG4gICAgICBtYXRjaCBzdHJpY3RfYWRkIHQgZSB3aXRoXG4gICAgICB8IE9rICgpIC0+ICgpXG4gICAgICB8IEVycm9yIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCBnb3QgYSBkdXBsaWNhdGUgZWxlbWVudFwiIHNleHApO1xuICAgIHRcbjs7XG5cbm1vZHVsZSBDcmVhdG9ycyAoRWx0IDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuZW5kKSA6IHNpZ1xuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBFbHQudCkgLT4gU2V4cC50IC0+ICdhIEVsdC50IHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICdhIHQgOj0gJ2EgRWx0LnQgdFxuICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBFbHQudFxuICAgICAgd2l0aCB0eXBlICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICAgKCdlbHQsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuZW5kID0gc3RydWN0XG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID1cbiAgICBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSkgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgZV9vZl9zZXhwIHNleHAgPSB0X29mX3NleHAgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGVfb2Zfc2V4cCBzZXhwXG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgaGFzaF9zZXRcbiAgdHlwZSAnYSBlbHQgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IHBvbHlfaGFzaGFibGVcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbmVuZFxuXG5tb2R1bGUgTSAoRWx0IDogVC5UKSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gRWx0LnQgdFxuZW5kXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IHRcbjs7XG5cbmxldCBtX190X29mX3NleHAgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGVsdCkgc2V4cCA9XG4gIHRfb2Zfc2V4cCAobW9kdWxlIEVsdCkgRWx0LnRfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gZWx0KSA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZV9JbXBvcnQiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiLCJCYXNlX0xpc3QiLCJCYXNlX0hhc2hhYmxlIiwiQmFzZV9IYXNodGJsIiwiQmFzZV9BcnJheSIsIkJhc2VfQ29udGFpbmVyIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfV2l0aF9yZXR1cm4iLCJoYXNoYWJsZV9zIiwiaGFzaGFibGUiLCJwb2x5X2hhc2hhYmxlIiwid2l0aF9yZXR1cm4iLCJjbGVhciIsImxlbmd0aCIsIm1lbSIsImNzdF9lbGVtZW50X2FscmVhZHlfZXhpc3RzIiwiaXNfZW1wdHkiLCJ0IiwiZmluZF9tYXAiLCJyIiwiZWx0IiwibyIsImZpbmQiLCJhIiwiYWRkIiwiayIsInN0cmljdF9hZGQiLCJzdHJpY3RfYWRkX2V4biIsInJlbW92ZSIsImNzdF9lbGVtZW50X25vdF9pbl9zZXQiLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJmb2xkIiwiaW5pdCIsImtleSIsInBhcmFtIiwiYWNjIiwiaXRlciIsImNvdW50Iiwic3VtIiwibSIsIm1pbl9lbHQiLCJjb21wYXJlIiwibWF4X2VsdCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImZpbmlzaCIsInRvX2xpc3QiLCJjc3RfSGFzaF9zZXRfdF9vZl9zZXhwX3JlcXVpcmUiLCJjc3RfSGFzaF9zZXRfdF9vZl9zZXhwX2dvdF9hX2QiLCJzZXhwX29mX3QiLCJzZXhwX29mX2UiLCJ0b19hcnJheSIsImxlbiIsImluZGV4IiwiZXhpc3RzIiwiZm9yX2FsbCIsImVxdWFsIiwidDEiLCJ0MiIsImNvcHkiLCJmaWx0ZXIiLCJ1bmlvbiIsImRpZmYiLCJpbnRlciIsImxhcmdlciIsInNtYWxsZXIiLCJmaWx0ZXJfaW5wbGFjZSIsInRvX3JlbW92ZSIsImFjIiwieCIsIm9mX2hhc2h0Ymxfa2V5cyIsImhhc2h0YmwiLCJ0b19oYXNodGJsIiwiY3JlYXRlIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplIiwib2ZfbGlzdCIsImwiLCJ0X29mX3NleHAiLCJlX29mX3NleHAiLCJzZXhwIiwibGlzdCIsImUiLCJDcmVhdG9ycyIsIkVsdCIsInRfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsIk0iLCJzZXhwX29mX21fdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImVxdWFsX21fdCIsIlByaXZhdGUiLCJCYXNlX0hhc2hfc2V0Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUE7QUFBQSxZQUFBQyxTQUFBQyxHQ2lCbUIscUNBQWtCO0FBQUEsWUFBQUMsU0FBQUQsR0FBQXZCO0FBQUFBLElBR2pDO0FBQUEsc0JBQUF5QjtBQUFBQSxjQUNFO0FBQUE7QUFBQTtBQUFBLHlCQUFBQztBQUFBQSxxQkFBQUMsSUFDUTtBQUFBLGlCQUFLLFdBRU0sb0JBQVU7QUFBQTtBQUFBLGNBQUM7QUFBQSxhQUMxQixFQUFDO0FBQUE7QUFBQSxZQUFBQyxLQUFBTCxHQUFBdkI7QUFBQUEsSUFHTyw0QkFBQTZCLEdBQTJCLG9DQUF5QixHQUFDO0FBQUE7QUFBQSxZQUFBQyxJQUFBUCxHQUFBUSxHQUN2RCwyQ0FBNkI7QUFBQSxZQUFBQyxXQUFBVCxHQUFBUTtBQUFBQSxJQUd0QztBQUFBLGNBQ0U7QUFBQSxlQUVILHdDQUNhO0FB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QjtBQUFBO0FBQUEsWUFBQUMsRUFBQUgsS0QzS3pGLFdDZ0xHO0FBQUEsWUFBQUksWUFBQUosS0FBQXBFLEdBR0QsMkJBQXlCO0FBQUEsWUFBQXlFLFlBQUFMLEtBQUFKO0FBQUFBLElBSXpCLDJEQUF5QztBQUFBO0FBQUEsWUFBQVUsaUJBQUFOO0FBQUFBLFFBQUEsSUFJWjtBQUFBLElBQXNDO0FBQUE7QUFBQSxZQUFBTyxVQUFBekQsT0FBQXVCLElBQUFDLElBR3pCLG9CQUFXO0FBQUE7QUFBQSxJQUFBbEQsYUQ5THZEO0FBQUEsSUFBQW9GLFVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDAxMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvZmxvYXQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBJbXBvcnRcbm9wZW4hIFByaW50ZlxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5pbmNsdWRlIEZsb2F0MFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfZmxvYXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Zsb2F0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9mbG9hdCA6IHQgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChmbG9hdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9mbG9hdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBmbG9hdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgdG9fZmxvYXQgeCA9IHhcbmxldCBvZl9mbG9hdCB4ID0geFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICB0cnkgZmxvYXRfb2Zfc3RyaW5nIHMgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwiRmxvYXQub2Zfc3RyaW5nICVzXCIgcyAoKVxuOztcblxubGV0IG9mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogU3RvbGVuIGZyb20gW3BlcnZhc2l2ZXMubWxdLiAgQWRkcyBhIFwiLlwiIGF0IHRoZSBlbmQgaWYgbmVlZGVkLiAgSXQgaXMgaW5cbiAgIFtwZXJ2YXNpdmVzLm1saV0sIGJ1dCBpdCBhbHNvIHNheXMgbm90IHRvIHVzZSBpdCBkaXJlY3RseSwgc28gd2UgY29weSBhbmQgcGFzdGUgdGhlXG4gICBjb2RlLiBJdCBtYWtlcyB0aGUgYXNzdW1wdGlvbiBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpbiBhcmd1bWVudCB0aGF0IGl0IHdhcyByZXR1cm5lZCBieVxuICAgW2Zvcm1hdF9mbG9hdF0uICopXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBpIGxcbiAgICB0aGVuIHMgXiBcIi5cIlxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBfIC0+IHMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxuKCogTGV0IFt5XSBiZSBhIHBvd2VyIG9mIDIuICBUaGVuIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQgaXM6XG4gICBbeiA9IHkgKiAoMSArIDIgKiogLTUyKV1cbiAgIGFuZCB0aGUgcHJldmlvdXMgb25lIGlzXG4gICBbeCA9IHkgKiAoMSAtIDIgKiogLTUzKV1cblxuICAgSW4gZ2VuZXJhbCwgZXZlcnkgdHdvIGFkamFjZW50IGZsb2F0cyBhcmUgd2l0aGluIGEgZmFjdG9yIG9mIGJldHdlZW4gWzEgKyAyKiotNTNdXG4gICBhbmQgWzEgKyAyKiotNTJdIGZyb20gZWFjaCBvdGhlciwgdGhhdCBpcyB3aXRoaW4gWzEgKyAxLjFlLTE2XSBhbmQgWzEgKyAyLjNlLTE2XS5cblxuICAgU28gaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdCBzdGFydHMgd2l0aCBcIjFcIiwgdGhlbiBpdHMgYWRqYWNlbnQgZmxvYXRzXG4gICB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb20gaXQgYnkgMSwgYW5kIHNvbWV0aW1lcyBieSAyLCBhdCB0aGUgMTd0aCBzaWduaWZpY2FudCBkaWdpdFxuICAgKGNvdW50aW5nIGZyb20gMSkuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdGFydHMgd2l0aCBcIjlcIiwgdGhlbiB0aGUgYWRqYWNlbnRcbiAgIGZsb2F0cyB3aWxsIGJlIG9mZiBieSBubyBtb3JlIHRoYW4gMjMgYXQgdGhlIDE2dGggYW5kIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRzLlxuXG4gICBFLmcuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5OVwiXG4gICB2fVxuICAgUHJpbnRpbmcgYSBjb3VwbGUgb2YgZXh0cmEgZGlnaXRzIHJldmVhbHMgdGhhdCB0aGUgZGlmZmVyZW5jZSBpbmRlZWQgaXMgcm91Z2hseSAxMSBhdFxuICAgZGlnaXRzIDE3dGggYW5kIDE4dGggKHRoYXQgaXMsIDEzdGggYW5kIDE0dGggYWZ0ZXIgXCIuXCIpOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTg4NlwiXG4gICB2fVxuXG4gICBUaGUgdWxwICh0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFkamFjZW50IGZsb2F0cykgaXMgdHdpY2UgYXMgYmlnIG9uIHRoZSBvdGhlciBzaWRlIG9mXG4gICAxMDI0LjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuICsuIDIuKiogKC01Mi4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyNC4wMDAwMDAwMDAwMDAyMjdcIlxuICAgdn1cblxuICAgTm93IHRha2UgYSBwb3dlciBvZiAyIHdoaWNoIHN0YXJ0cyB3aXRoIDk5OlxuXG4gICB7dlxuICAgICAjIDIuKio5My4gOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAxIDIzNDU2Nzg5MDEyMzQ1Njc4XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQyMmUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuICsuIDIuKiogKC01Mi4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQ0NGUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuIC0uIDIuKiogKC01My4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQxMWUrMjdcbiAgIHZ9XG5cbiAgIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMioqOTMgYW5kIGl0cyB0d28gbmVpZ2hib3JzIGlzIHNsaWdodGx5IG1vcmUgdGhhbiwgcmVzcGVjdGl2ZWx5LFxuICAgMSBhbmQgMiBhdCBzaWduaWZpY2FudCBkaWdpdCAxNi5cblxuICAgVGhvc2UgZXhhbXBsZXMgc2hvdyB0aGF0OlxuICAgLSAxNyBzaWduaWZpY2FudCBkaWdpdHMgaXMgYWx3YXlzIHN1ZmZpY2llbnQgdG8gcmVwcmVzZW50IGEgZmxvYXQgd2l0aG91dCBhbWJpZ3VpdHlcbiAgIC0gMTV0aCBzaWduaWZpY2FudCBkaWdpdCBjYW4gYWx3YXlzIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHlcbiAgIC0gY29udmVydGluZyBhIGRlY2ltYWwgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGl0cyBuZWFyZXN0IGZsb2F0IGFuZCBiYWNrXG4gICAgIGNhbiBjaGFuZ2UgdGhlIGxhc3QgZGVjaW1hbCBkaWdpdCBieSBubyBtb3JlIHRoYW4gMVxuXG4gICBUbyBtYWtlIHN1cmUgdGhhdCBmbG9hdHMgb2J0YWluZWQgYnkgY29udmVyc2lvbiBmcm9tIGRlY2ltYWwgZnJhY3Rpb25zIChlLmcuIFwiMy4xNFwiKVxuICAgYXJlIHByaW50ZWQgd2l0aG91dCB0cmFpbGluZyBub24temVybyBkaWdpdHMsIG9uZSBzaG91bGQgY2hvb3NlIHRoZSBmaXJzdCBhbW9uZyB0aGVcbiAgICclLjE1ZycsICclLjE2ZycsIGFuZCAnJS4xN2cnIHJlcHJlc2VudGF0aW9ucyB3aGljaCBkb2VzIHJvdW5kLXRyaXA6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIiAgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lICopXG5cbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjhcIiAgICAgICAgICAgICAgICAgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1kb2VzIG5vdCByb3VuZC10cmlwICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMlwiICAgICAgICAoKiBwcmVmZXIgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAxOFwiICAgICAgICgqIHRoaXMgb25lIGhhcyBvbmUgZGlnaXQgb2YganVuayBhdCB0aGUgZW5kICopXG4gICB2fVxuXG4gICBTa2lwcGluZyB0aGUgJyUuMTZnJyBpbiB0aGUgYWJvdmUgcHJvY2VkdXJlIHNhdmVzIHVzIHNvbWUgdGltZSwgYnV0IGl0IG1lYW5zIHRoYXQsIGFzXG4gICBzZWVuIGluIHRoZSBzZWNvbmQgZXhhbXBsZSBhYm92ZSwgb2NjYXNpb25hbGx5IG51bWJlcnMgd2l0aCBleGFjdGx5IDE2IHNpZ25pZmljYW50XG4gICBkaWdpdHMgd2lsbCBoYXZlIGFuIGVycm9yIGludHJvZHVjZWQgYXQgdGhlIDE3dGggZGlnaXQuICBUaGF0IGlzIHByb2JhYmx5IE9LIGZvclxuICAgdHlwaWNhbCB1c2UsIGJlY2F1c2UgYSBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaXMgXCJ1Z2x5XCIgYWxyZWFkeS4gIEFkZGluZyBvbmVcbiAgIG1vcmUgZG9lc24ndCBtYWtlIGl0IG11Y2ggd29yc2UgZm9yIGEgaHVtYW4gcmVhZGVyLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgd2UgY2Fubm90IHNraXAgJyUuMTVnJyBhbmQgb25seSBsb29rIGF0ICclLjE2ZycgYW5kICclLjE3ZycsIHNpbmNlXG4gICB0aGUgaW5hY2N1cmFjeSBhdCB0aGUgMTZ0aCBkaWdpdCBtaWdodCBpbnRyb2R1Y2UgdGhlIG5vaXNlIHdlIHdhbnQgdG8gYXZvaWQ6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MlwiICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMVwiICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tanVuayBhdCB0aGUgZW5kICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMDlcIlxuICAgdn1cbiopXG5sZXQgdG9fc3RyaW5nIHggPVxuICB2YWxpZF9mbG9hdF9sZXhlbVxuICAgIChsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVnXCIgeCBpblxuICAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN2dcIiB4KVxuOztcblxubGV0IG1heF92YWx1ZSA9IGluZmluaXR5XG5sZXQgbWluX3ZhbHVlID0gbmVnX2luZmluaXR5XG5sZXQgbWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDc0LlxubGV0IG1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTAyMi5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IHBpID0gMHgzLjI0M0Y2QTg4ODVBMzA4RDMxMzE5OEEyRTAzNzA3M1xubGV0IHNxcnRfcGkgPSAweDEuQzVCRjg5MUI0RUY2QUE3OUMzQjA1MjBENURCOTM4XG5sZXQgc3FydF8ycGkgPSAweDIuODFCMjYzRkVDNEUwQjJDQUY5NDgzRjVDRTQ1OURDXG5sZXQgZXVsZXIgPSAweDAuOTNDNDY3RTM3REIwQzdBNEQxQkUzRjgxMDE1MkNCXG5sZXQgb2ZfaW50ID0gSW50LnRvX2Zsb2F0XG5sZXQgdG9faW50ID0gSW50Lm9mX2Zsb2F0XG5sZXQgb2ZfaW50NjMgaSA9IEludDYzLnRvX2Zsb2F0IGlcbmxldCBvZl9pbnQ2NCBpID0gU3RkbGliLkludDY0LnRvX2Zsb2F0IGlcbmxldCB0b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdFxubGV0IGlyb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xubGV0IGlyb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xuXG4oKiBUaGUgcGVyZm9ybWFuY2Ugb2YgdGhlIFwiZXhuXCIgcm91bmRpbmcgZnVuY3Rpb25zIGlzIGltcG9ydGFudCwgc28gdGhleSBhcmUgd3JpdHRlblxuICAgb3V0IHNlcGFyYXRlbHksIGFuZCB0dW5lZCBpbmRpdmlkdWFsbHkuICAoV2UgY291bGQgaGF2ZSB0aGUgb3B0aW9uIHZlcnNpb25zIGNhbGxcbiAgIHRoZSBcImV4blwiIHZlcnNpb25zLCBidXQgdGhhdCBpbXBvc2VzIGFyZ3VhYmx5IGdyYXR1aXRvdXMgb3ZlcmhlYWQtLS1lc3BlY2lhbGx5XG4gICBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBvZiBiYWNrdHJhY2VzIGlzIGVuYWJsZWQgdXBvbiBcIndpdGhcIi0tLWFuZCB0aGF0IHNlZW1zXG4gICBub3Qgd29ydGggaXQgd2hlbiBjb21wYXJlZCB0byB0aGUgcmVsYXRpdmVseSBzbWFsbCBhbW91bnQgb2YgY29kZSBkdXBsaWNhdGlvbi4pICopXG5cbigqIEVycm9yIHJlcG9ydGluZyBiZWxvdyBpcyB2ZXJ5IGNhcmVmdWxseSBhcnJhbmdlZCBzbyB0aGF0LCBlLmcuLCBbaXJvdW5kX25lYXJlc3RfZXhuXVxuICAgaXRzZWxmIGNhbiBiZSBpbmxpbmVkIGludG8gY2FsbGVycyBzdWNoIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGEgYm94IGZvciB0aGVcbiAgIFtmbG9hdF0gYXJndW1lbnQuICBUaGlzIGlzIGRvbmUgd2l0aCBhIGJveCBbYm94XSBmdW5jdGlvbiBjYXJlZnVsbHkgY2hvc2VuIHRvIGFsbG93IHRoZVxuICAgY29tcGlsZXIgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm94IGZvciB0aGUgZmxvYXQgb25seSBpbiBlcnJvciBjYXNlcy4gIFNlZSwgZS5nLixcbiAgIFsuLi8uLi96ZXJvL3Rlc3QvcHJpY2VfdGVzdC5tbF0gZm9yIGEgbWVjaGFuaWNhbCB0ZXN0IG9mIHRoaXMgcHJvcGVydHkgd2hlbiBidWlsZGluZ1xuICAgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPXRydWVdLiAqKVxuXG5sZXQgaXJvdW5kX3VwIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9kb3duIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuIGlmIHQgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCkgZWxzZSBOb25lXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKCkpXG47O1xuXG5sZXQgaXJvdW5kX3Rvd2FyZHNfemVybyB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaXJvdW5kX3Rvd2FyZHNfemVyb19leG46IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoYm94IHQpXG4gICAgICAoKVxuOztcblxuKCogT3V0c2lkZSBvZiB0aGUgcmFuZ2UgKHJvdW5kX25lYXJlc3RfbGIuLnJvdW5kX25lYXJlc3RfdWIpLCBhbGwgcmVwcmVzZW50YWJsZSBkb3VibGVzXG4gICBhcmUgaW50ZWdlcnMgaW4gdGhlIG1hdGhlbWF0aWNhbCBzZW5zZSwgYW5kIFtyb3VuZF9uZWFyZXN0XSBzaG91bGQgYmUgaWRlbnRpdHkuXG5cbiAgIEhvd2V2ZXIsIGZvciBvZGQgbnVtYmVycyB3aXRoIHRoZSBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuIDIqKjUyIGFuZCAyKio1MywgdGhlIGZvcm11bGFcbiAgIFtyb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArIDAuNSldIGRvZXMgbm90IGhvbGQ6XG5cbiAgIHt2XG4gICAgICMgbGV0IG5haXZlX3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsuIDAuNSk7O1xuICAgICAjIGxldCB4ID0gMi4gKiogNTIuICsuIDEuOztcbiAgICAgdmFsIHggOiBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTcuXG4gICAgICMgbmFpdmVfcm91bmRfbmVhcmVzdCB4OztcbiAgICAgLSA6ICAgICBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTguXG4gICB2fVxuKilcblxubGV0IHJvdW5kX25lYXJlc3RfbGIgPSAtLigyLiAqKiA1Mi4pXG5sZXQgcm91bmRfbmVhcmVzdF91YiA9IDIuICoqIDUyLlxuXG4oKiBGb3IgW3ggPSBvbmVfdWxwIGBEb3duIDAuNV0sIHRoZSBmb3JtdWxhIFtmbG9vciAoeCArLiAwLjUpXSBmb3Igcm91bmRpbmcgdG8gbmVhcmVzdFxuICAgZG9lcyBub3Qgd29yaywgYmVjYXVzZSB0aGUgZXhhY3QgcmVzdWx0IGlzIGhhbGZ3YXkgYmV0d2VlbiBbb25lX3VscCBgRG93biAxLl0gYW5kIFsxLl0sXG4gICBhbmQgaXQgZ2V0cyByb3VuZGVkIHVwIHRvIFsxLl0gZHVlIHRvIHRoZSByb3VuZC10aWVzLXRvLWV2ZW4gcnVsZS4gKilcbmxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscCBgRG93biAwLjVcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0ID1cbiAgdFxuICArLlxuICBpZiB0ID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICB0aGVuIG9uZV91bHBfbGVzc190aGFuX2hhbGYgKCogc2luY2UgdCA8IDAuNSwgbWFrZSBzdXJlIHRoZSByZXN1bHQgaXMgPCAxLjAgKilcbiAgZWxzZSAwLjVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KSlcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICAgIGVsc2UgTm9uZVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF8zMlxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4bl8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX25lYXJlc3RfZXhuXzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF9leG5fNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzMyXG47O1xuXG4oKiBUaGUgZm9sbG93aW5nIFtpcm91bmRfZXhuXSBhbmQgW2lyb3VuZF0gZnVuY3Rpb25zIGFyZSBzbG93ZXIgdGhhbiB0aGUgb25lcyBhYm92ZS5cbiAgIFRoZWlyIGVxdWl2YWxlbmNlIHRvIHRob3NlIGZ1bmN0aW9ucyBpcyB0ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHMgYmVsb3cuICopXG5cbmxldFtAaW5saW5lXSBpcm91bmRfZXhuID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBaZXJvIC0+IGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHRcbiAgfCBgTmVhcmVzdCAtPiBpcm91bmRfbmVhcmVzdF9leG4gdFxuICB8IGBVcCAtPiBpcm91bmRfdXBfZXhuIHRcbiAgfCBgRG93biAtPiBpcm91bmRfZG93bl9leG4gdFxuOztcblxubGV0IGlyb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgdHJ5IFNvbWUgKGlyb3VuZF9leG4gfmRpciB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgaXNfaW5mIHQgPSAxLiAvLiB0ID0gMC5cbmxldCBpc19maW5pdGUgdCA9IHQgLS4gdCA9IDAuXG5cbmxldCBtaW5faW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgbWF4X2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IGFkZCA9ICggKy4gKVxubGV0IHN1YiA9ICggLS4gKVxubGV0IG5lZyA9ICggfi0uIClcbmxldCBhYnMgPSBhYnNfZmxvYXRcbmxldCBzY2FsZSA9ICggKi4gKVxubGV0IHNxdWFyZSB4ID0geCAqLiB4XG5cbm1vZHVsZSBQYXJ0cyA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZnJhY3Rpb25hbCA6IHQgLT4gZmxvYXRcbiAgdmFsIGludGVncmFsIDogdCAtPiBmbG9hdFxuICB2YWwgbW9kZiA6IGZsb2F0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCAqIGZsb2F0XG5cbiAgbGV0IGZyYWN0aW9uYWwgdCA9IGZzdCB0XG4gIGxldCBpbnRlZ3JhbCB0ID0gc25kIHRcbiAgbGV0IG1vZGYgPSBtb2RmXG5lbmRcblxubGV0IG1vZGYgPSBQYXJ0cy5tb2RmXG5sZXQgcm91bmRfZG93biA9IGZsb29yXG5sZXQgcm91bmRfdXAgPSBjZWlsXG5sZXQgcm91bmRfdG93YXJkc196ZXJvIHQgPSBpZiB0ID49IDAuIHRoZW4gcm91bmRfZG93biB0IGVsc2Ugcm91bmRfdXAgdFxuXG4oKiBzZWUgdGhlIGNvbW1lbnQgYWJvdmUgW3JvdW5kX25lYXJlc3RfbGJdIGFuZCBbcm91bmRfbmVhcmVzdF91Yl0gZm9yIGFuIGV4cGxhbmF0aW9uICopXG5sZXRbQG9jYW1sLmlubGluZV0gcm91bmRfbmVhcmVzdF9pbmxpbmUgdCA9XG4gIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiICYmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gZmxvb3IgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gIGVsc2UgdCArLiAwLlxuOztcblxubGV0IHJvdW5kX25lYXJlc3QgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdFxuXG5sZXQgcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gdCA9XG4gIGlmIHQgPD0gcm91bmRfbmVhcmVzdF9sYiB8fCB0ID49IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiB0ICsuIDAuXG4gIGVsc2UgKFxuICAgIGxldCBmbG9vciA9IGZsb29yIHQgaW5cbiAgICAoKiBbY2VpbF9vcl9zdWNjID0gaWYgdCBpcyBhbiBpbnRlZ2VyIHRoZW4gdCArLiAxLiBlbHNlIGNlaWwgdF0uICBGYXN0ZXIgdGhhbiBbY2VpbF0uICopXG4gICAgbGV0IGNlaWxfb3Jfc3VjYyA9IGZsb29yICsuIDEuIGluXG4gICAgbGV0IGRpZmZfZmxvb3IgPSB0IC0uIGZsb29yIGluXG4gICAgbGV0IGRpZmZfY2VpbCA9IGNlaWxfb3Jfc3VjYyAtLiB0IGluXG4gICAgaWYgZGlmZl9mbG9vciA8IGRpZmZfY2VpbFxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGlmIGRpZmZfZmxvb3IgPiBkaWZmX2NlaWxcbiAgICB0aGVuIGNlaWxfb3Jfc3VjY1xuICAgIGVsc2UgaWYgKCogZXhhY3QgdGllLCBwaWNrIHRoZSBldmVuICopXG4gICAgICAgICAgICBtb2RfZmxvYXQgZmxvb3IgMi4gPSAwLlxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGNlaWxfb3Jfc3VjYylcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5sZXQgaW50NjNfcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xuXG5sZXQgaW50NjNfcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biB0MCA9XG4gIGxldCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0MCBpblxuICBpZiB0ID4gMC5cbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChib3ggdDApXG4gICAgICAgICgpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKGJveCB0MClcbiAgICAgICgpXG47O1xuXG5sZXRbQGlubGluZV0gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gZiA9XG4gIEludDYzLm9mX2ludCAoaXJvdW5kX25lYXJlc3RfZXhuIGYpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgfCBXMzIgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbjs7XG5cbmxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IHRcbiAgfCBgRG93biAtPiByb3VuZF9kb3duIHRcbiAgfCBgVXAgLT4gcm91bmRfdXAgdFxuICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyB0XG47O1xuXG5tb2R1bGUgQ2xhc3MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEluZmluaXRlXG4gICAgfCBOYW5cbiAgICB8IE5vcm1hbFxuICAgIHwgU3Vibm9ybWFsXG4gICAgfCBaZXJvXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgSW5maW5pdGU7IE5hbjsgTm9ybWFsOyBTdWJub3JtYWw7IFplcm8gXSA6IHQgbGlzdClcblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDA3XyA9IFwiZmxvYXQubWwuQ2xhc3MudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIC0+IEluZmluaXRlXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgLT4gTm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgLT4gU3Vibm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDhfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwOF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSA6OiBfKSBhcyBzZXhwX18wMDhfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA4X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDhfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA4XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwNl9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgIHwgc2V4cF9fMDA2XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwNl9cbiAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgSW5maW5pdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5maW5pdGVcIlxuICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICB8IE5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOb3JtYWxcIlxuICAgICB8IFN1Ym5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdWJub3JtYWxcIlxuICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkluZmluaXRlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOb3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiU3Vibm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG5lbmRcblxubGV0IGNsYXNzaWZ5IHQgPVxuICBsZXQgbW9kdWxlIEMgPSBDbGFzcyBpblxuICBtYXRjaCBjbGFzc2lmeV9mbG9hdCB0IHdpdGhcbiAgfCBGUF9ub3JtYWwgLT4gQy5Ob3JtYWxcbiAgfCBGUF9zdWJub3JtYWwgLT4gQy5TdWJub3JtYWxcbiAgfCBGUF96ZXJvIC0+IEMuWmVyb1xuICB8IEZQX2luZmluaXRlIC0+IEMuSW5maW5pdGVcbiAgfCBGUF9uYW4gLT4gQy5OYW5cbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgPyhkZWxpbWl0ZXIgPSAnXycpID8oc3RyaXBfemVybyA9IGZhbHNlKSBzdHJpbmcgPVxuICBtYXRjaCBTdHJpbmcubHNwbGl0MiBzdHJpbmcgfm9uOicuJyB3aXRoXG4gIHwgTm9uZSAtPiBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgc3RyaW5nIH5kZWxpbWl0ZXJcbiAgfCBTb21lIChsZWZ0LCByaWdodCkgLT5cbiAgICBsZXQgbGVmdCA9IEludF9zdHJpbmdfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBsZWZ0IH5kZWxpbWl0ZXIgaW5cbiAgICBsZXQgcmlnaHQgPVxuICAgICAgaWYgc3RyaXBfemVybyB0aGVuIFN0cmluZy5yc3RyaXAgcmlnaHQgfmRyb3A6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnMCcpIGVsc2UgcmlnaHRcbiAgICBpblxuICAgIChtYXRjaCByaWdodCB3aXRoXG4gICAgIHwgXCJcIiAtPiBsZWZ0XG4gICAgIHwgXyAtPiBsZWZ0IF4gXCIuXCIgXiByaWdodClcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID9kZWxpbWl0ZXIgPyhkZWNpbWFscyA9IDMpID9zdHJpcF96ZXJvID8oZXhwbGljaXRfcGx1cyA9IGZhbHNlKSBmID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBkZWNpbWFscyAwXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwidG9fc3RyaW5nX2h1bTogaW52YWxpZCBhcmd1bWVudCB+ZGVjaW1hbHM9JWRcIiBkZWNpbWFscyAoKTtcbiAgbWF0Y2ggY2xhc3NpZnkgZiB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgZiA+IDAuIHRoZW4gXCJpbmZcIiBlbHNlIFwiLWluZlwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuXCJcbiAgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IHMgPVxuICAgICAgaWYgZXhwbGljaXRfcGx1cyB0aGVuIHNwcmludGYgXCIlKy4qZlwiIGRlY2ltYWxzIGYgZWxzZSBzcHJpbnRmIFwiJS4qZlwiIGRlY2ltYWxzIGZcbiAgICBpblxuICAgIGluc2VydF91bmRlcnNjb3JlcyBzID9kZWxpbWl0ZXIgP3N0cmlwX3plcm9cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGxldCBzZXhwID0gc2V4cF9vZl90IHQgaW5cbiAgbWF0Y2ggIVNleHAub2ZfZmxvYXRfc3R5bGUgd2l0aFxuICB8IGBOb191bmRlcnNjb3JlcyAtPiBzZXhwXG4gIHwgYFVuZGVyc2NvcmVzIC0+XG4gICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICB8IExpc3QgXyAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3NleHBfb2ZfZmxvYXRdIHByb2R1Y2VkIHN0cmFuZ2Ugc2V4cFwiXG4gICAgICAgICAgICBbIFwic2V4cFwiLCBTZXhwLnNleHBfb2ZfdCBzZXhwIF0pXG4gICAgIHwgQXRvbSBzdHJpbmcgLT5cbiAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgc3RyaW5nICdFJyB0aGVuIHNleHAgZWxzZSBBdG9tIChpbnNlcnRfdW5kZXJzY29yZXMgc3RyaW5nKSlcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgPyhwcmVmaXggPSBcIlwiKSB+a2lsbyB+bWVnYSB+Z2lnYSB+dGVyYSA/cGV0YSAoKSA9XG4gICgqIFJvdW5kIGEgcmF0aW8gdG93YXJkIHRoZSBuZWFyZXN0IGludGVnZXIsIHJlc29sdmluZyB0aWVzIHRvd2FyZCB0aGUgbmVhcmVzdCBldmVuXG4gICAgIG51bWJlci4gIEZvciBzYW5lIGlucHV0cyAoaW4gcGFydGljdWxhciwgd2hlbiBbZGVub21pbmF0b3JdIGlzIGFuIGludGVnZXIgYW5kXG4gICAgIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0pIHRoaXMgc2hvdWxkIGJlIGFjY3VyYXRlLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0IG1pZ2h0IGJlIGFcbiAgICAgbGl0dGxlIGJpdCBvZmYsIGJ1dCB3ZSBkb24ndCByZWFsbHkgdXNlIHRoYXQgY2FzZS4gKilcbiAgbGV0IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvciB+ZGVub21pbmF0b3IgPVxuICAgIGxldCBrID0gZmxvb3IgKG51bWVyYXRvciAvLiBkZW5vbWluYXRvcikgaW5cbiAgICAoKiBpZiBbYWJzIGsgPCAyZTUzXSwgdGhlbiBib3RoIFtrXSBhbmQgW2sgKy4gMS5dIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBhbmQgaW5cbiAgICAgICBwYXJ0aWN1bGFyIFtrICsuIDEuID4ga10uICBJZiBbZGVub21pbmF0b3JdIGlzIGFsc28gYW4gaW50ZWdlciwgYW5kXG4gICAgICAgW2FicyAoZGVub21pbmF0b3IgKi4gKGsgKy4gMSkpIDwgMmU1M10gKGFuZCBpbiBzb21lIG90aGVyIGNhc2VzLCB0b28pLCB0aGVuIFtsb3dlcl1cbiAgICAgICBhbmQgW2hpZ2hlcl0gYXJlIGFjdHVhbGx5IGJvdGggYWNjdXJhdGUuICBTaW5jZSAocm91Z2hseSlcbiAgICAgICBbbnVtZXJhdG9yID0gZGVub21pbmF0b3IgKi4ga10gdGhlbiBmb3IgW2FicyBudW1lcmF0b3IgPCAyZTUyXSB3ZSBzaG91bGQgYmVcbiAgICAgICBmaW5lLiAqKVxuICAgIGxldCBsb3dlciA9IGRlbm9taW5hdG9yICouIGsgaW5cbiAgICBsZXQgaGlnaGVyID0gZGVub21pbmF0b3IgKi4gKGsgKy4gMS4pIGluXG4gICAgKCogU3VidHJhY3RpbmcgbnVtYmVycyB3aXRoaW4gYSBmYWN0b3Igb2YgdHdvIGZyb20gZWFjaCBvdGhlciBpcyBhY2N1cmF0ZS5cbiAgICAgICBTbyBlaXRoZXIgdGhlIHR3byBzdWJ0cmFjdGlvbnMgYmVsb3cgYXJlIGFjY3VyYXRlLCBvciBrID0gMCwgb3IgayA9IC0xLlxuICAgICAgIEluIGNhc2Ugb2YgYSB0aWUsIHJvdW5kIHRvIGV2ZW4uICopXG4gICAgbGV0IGRpZmZfcmlnaHQgPSBoaWdoZXIgLS4gbnVtZXJhdG9yIGluXG4gICAgbGV0IGRpZmZfbGVmdCA9IG51bWVyYXRvciAtLiBsb3dlciBpblxuICAgIGxldCBrID0gaXJvdW5kX25lYXJlc3RfZXhuIGsgaW5cbiAgICBpZiBkaWZmX3JpZ2h0IDwgZGlmZl9sZWZ0XG4gICAgdGhlbiBrICsgMVxuICAgIGVsc2UgaWYgZGlmZl9yaWdodCA+IGRpZmZfbGVmdFxuICAgIHRoZW4ga1xuICAgIGVsc2UgaWYgKCogYSB0aWUgKilcbiAgICAgICAgICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGsgbW9kIDIpIDBcbiAgICB0aGVuIGtcbiAgICBlbHNlIGsgKyAxXG4gIGluXG4gIG1hdGNoIGNsYXNzaWZ5IHQgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIHQgPCAwLjAgdGhlbiBcIi1pbmYgIFwiIGVsc2UgXCJpbmYgIFwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuICBcIlxuICB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgZ28gdCA9XG4gICAgICBsZXQgY29udl9vbmUgdCA9XG4gICAgICAgIGFzc2VydCAoMC4gPD0gdCAmJiB0IDwgOTk5Ljk1KTtcbiAgICAgICAgbGV0IHggPSBwcmVmaXggXiBmb3JtYXRfZmxvYXQgXCIlLjFmXCIgdCBpblxuICAgICAgICAoKiBGaXggdGhlIFwiLjBcIiBzdWZmaXggKilcbiAgICAgICAgaWYgU3RyaW5nLmlzX3N1ZmZpeCB4IH5zdWZmaXg6XCIuMFwiXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB4ID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgICAgICAgICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCB4IGluXG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAxKSAnICc7XG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAyKSAnICc7XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp4KVxuICAgICAgICBlbHNlIHhcbiAgICAgIGluXG4gICAgICBsZXQgY29udiBtYWcgdCBkZW5vbWluYXRvciA9XG4gICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgKGRlbm9taW5hdG9yID0gMTAwLiAmJiB0ID49IDk5OS45NSlcbiAgICAgICAgICB8fCAoZGVub21pbmF0b3IgPj0gMTAwXzAwMC4gJiYgdCA+PSByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Ljk5OV81KSkpO1xuICAgICAgICBhc3NlcnQgKHQgPCByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Xzk5OS41KSk7XG4gICAgICAgIGxldCBpLCBkID1cbiAgICAgICAgICBsZXQgayA9IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvcjp0IH5kZW5vbWluYXRvciBpblxuICAgICAgICAgICgqIFttb2RdIGlzIG9rYXkgaGVyZSBiZWNhdXNlIHdlIGtub3cgaSA+PSAwLiAqKVxuICAgICAgICAgIGsgLyAxMCwgayBtb2QgMTBcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgICAgICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgMTAwMCk7XG4gICAgICAgIGFzc2VydCAoMCA8PSBkICYmIGQgPCAxMCk7XG4gICAgICAgIGlmIGQgPSAwXG4gICAgICAgIHRoZW4gc3ByaW50ZiBcIiVzJWQlcyBcIiBwcmVmaXggaSBtYWdcbiAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlZCVzJWRcIiBwcmVmaXggaSBtYWcgZFxuICAgICAgaW5cbiAgICAgICgqIFdoaWxlIHRoZSBzdGFuZGFyZCBtZXRyaWMgcHJlZml4ZXMgKGUuZy4gY2FwaXRhbCBcIk1cIiByYXRoZXIgdGhhbiBcIm1cIiwgWzFdKSBhcmVcbiAgICAgICAgIG5vbWluYWxseSBtb3JlIGNvcnJlY3QsIHRoaXMgaGluZGVycyByZWFkYWJpbGl0eSBpbiBvdXIgY2FzZS4gIEUuZy4sIDEwRzYgYW5kXG4gICAgICAgICAxMDY2IGxvb2sgdG9vIHNpbWlsYXIuICBUaGF0J3MgYW4gZXh0cmVtZSBleGFtcGxlLCBidXQgaW4gZ2VuZXJhbCBrLG0sZyx0LHBcbiAgICAgICAgIHByb2JhYmx5IHN0YW5kIG91dCBiZXR0ZXIgdGhhbiBLLE0sRyxULFAgd2hlbiBpbnRlcnNwZXJzZWQgd2l0aCBkaWdpdHMuXG5cbiAgICAgICAgIFsxXSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldHJpY19wcmVmaXggKilcbiAgICAgICgqIFRoZSB0cmljayBoZXJlIGlzIHRoYXQ6XG4gICAgICAgICAtIHRoZSBmaXJzdCBib3VuZGFyeSAoOTk5Ljk1KSBhcyBhIGZsb2F0IGlzIHNsaWdodGx5IG92ZXItcmVwcmVzZW50ZWQgKHNvIGl0IGlzXG4gICAgICAgICAgIGJldHRlciBhcHByb3hpbWF0ZWQgYXMgXCIxa1wiIHRoYW4gYXMgXCI5OTkuOVwiKSxcbiAgICAgICAgIC0gdGhlIG90aGVyIGJvdW5kYXJpZXMgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGJlY2F1c2UgdGhleSBhcmUgaW50ZWdlcnMuXG4gICAgICAgICAgIFRoYXQncyB3aHkgdGhlIHN0cmljdCBlcXVhbGl0aWVzIGJlbG93IGRvIGV4YWN0bHkgd2hhdCB3ZSB3YW50LiAqKVxuICAgICAgaWYgdCA8IDk5OS45NUUwXG4gICAgICB0aGVuIGNvbnZfb25lIHRcbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUzXG4gICAgICB0aGVuIGNvbnYga2lsbyB0IDEwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU2XG4gICAgICB0aGVuIGNvbnYgbWVnYSB0IDEwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFOVxuICAgICAgdGhlbiBjb252IGdpZ2EgdCAxMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUxMlxuICAgICAgdGhlbiBjb252IHRlcmEgdCAxMDBfMDAwXzAwMF8wMDAuXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcGV0YSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHRcbiAgICAgICAgfCBTb21lIHBldGEgLT5cbiAgICAgICAgICBpZiB0IDwgOTk5Ljk1RTE1XG4gICAgICAgICAgdGhlbiBjb252IHBldGEgdCAxMDBfMDAwXzAwMF8wMDBfMDAwLlxuICAgICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0KVxuICAgIGluXG4gICAgaWYgdCA+PSAwLiB0aGVuIGdvIHQgZWxzZSBcIi1cIiBeIGdvIH4tLnRcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmcgdCA9XG4gIHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCB+a2lsbzpcImtcIiB+bWVnYTpcIm1cIiB+Z2lnYTpcImdcIiB+dGVyYTpcInRcIiB+cGV0YTpcInBcIiAoKVxuOztcblxuKCogUGVyZm9ybWFuY2Ugbm90ZTogSW5pdGlhbGl6aW5nIHRoZSBhY2N1bXVsYXRvciB0byAxIHJlc3VsdHMgaW4gb25lIGV4dHJhXG4gICBtdWx0aXBseTsgZS5nLiwgdG8gY29tcHV0ZSB4ICoqIDQsIHdlIGluIHByaW5jaXBsZSBvbmx5IG5lZWQgMiBtdWx0aXBsaWVzLFxuICAgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIDMgbXVsdGlwbGllcy4gIEhvd2V2ZXIsIGF0dGVtcHRzIHRvIGF2b2lkIHRoaXNcbiAgIChsaWtlIGRlY3JlbWVudGluZyBuIGFuZCBpbml0aWFsaXppbmcgYWNjdW0gdG8gYmUgeCwgb3IgaGFuZGxpbmcgc21hbGxcbiAgIGV4cG9uZW50cyBhcyBhIHNwZWNpYWwgY2FzZSkgaGF2ZSBub3QgeWllbGRlZCBhbnl0aGluZyB0aGF0IGlzIGEgbmV0XG4gICBpbXByb3ZlbWVudC5cbiopXG5sZXQgaW50X3BvdyB4IG4gPVxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gMS5cbiAgZWxzZSAoXG4gICAgKCogVXNpbmcgW3ggKy4gKC0wLildIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBjb252aW5jZXMgdGhlIGNvbXBpbGVyIHRvIGF2b2lkIGEgY2VydGFpblxuICAgICAgIGJveGluZyAodGhhdCB3b3VsZCByZXN1bHQgaW4gYWxsb2NhdGlvbiBpbiBlYWNoIGl0ZXJhdGlvbikuICBTb29uLCB0aGUgY29tcGlsZXJcbiAgICAgICBzaG91bGRuJ3QgbmVlZCB0aGlzIFwiaGludFwiIHRvIGF2b2lkIHRoZSBib3hpbmcuICBUaGUgcmVhc29uIHdlIGFkZCAtMCByYXRoZXIgdGhhbiAwXG4gICAgICAgaXMgdGhhdCBbeCArLiAoLTAuKV0gaXMgYXBwYXJlbnRseSBhbHdheXMgdGhlIHNhbWUgYXMgW3hdLCB3aGVyZWFzIFt4ICsuIDAuXSBpc1xuICAgICAgIG5vdCwgaW4gdGhhdCBpdCBzZW5kcyBbLTAuXSB0byBbMC5dLiAgVGhpcyBtYWtlcyBhIGRpZmZlcmVuY2UgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAgW2ludF9wb3cgKC0wLikgKC0xKV0gdG8gcmV0dXJuIG5lZ19pbmZpbml0eSBqdXN0IGxpa2UgWy0wLiAqKiAtMS5dIHdvdWxkLiAgKilcbiAgICBsZXQgeCA9IHJlZiAoeCArLiAtMC4pIGluXG4gICAgbGV0IG4gPSByZWYgbiBpblxuICAgIGxldCBhY2N1bSA9IHJlZiAxLiBpblxuICAgIGlmICFuIDwgMFxuICAgIHRoZW4gKFxuICAgICAgKCogeCAqKiBuID0gKDEveCkgKiogLW4gKilcbiAgICAgIHggOj0gMS4gLy4gIXg7XG4gICAgICBuIDo9IH4tICghbik7XG4gICAgICBpZiAhbiA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBuIG11c3QgaGF2ZSBiZWVuIG1pbl9pbnQsIHNvIGl0IGlzIG5vdyBzbyBiaWcgdGhhdCBpdCBoYXMgd3JhcHBlZCBhcm91bmQuXG4gICAgICAgICAgIFdlIGRlY3JlbWVudCBpdCBzbyB0aGF0IGl0IGxvb2tzIHBvc2l0aXZlIGFnYWluLCBidXQgYWNjb3JkaW5nbHkgaGF2ZVxuICAgICAgICAgICB0byBwdXQgYW4gZXh0cmEgZmFjdG9yIG9mIHggaW4gdGhlIGFjY3VtdWxhdG9yLlxuICAgICAgICAqKVxuICAgICAgICBhY2N1bSA6PSAheDtcbiAgICAgICAgZGVjciBuKSk7XG4gICAgKCogTGV0dGluZyBbYV0gZGVub3RlICh0aGUgb3JpZ2luYWwgdmFsdWUgb2YpIFt4ICoqIG5dLCB3ZSBtYWludGFpblxuICAgICAgIHRoZSBpbnZhcmlhbnQgdGhhdCBbKHggKiogbikgKi4gYWNjdW0gPSBhXS4gKilcbiAgICB3aGlsZSAhbiA+IDEgZG9cbiAgICAgIGlmICFuIGxhbmQgMSA8PiAwIHRoZW4gYWNjdW0gOj0gIXggKi4gIWFjY3VtO1xuICAgICAgeCA6PSAheCAqLiAheDtcbiAgICAgIG4gOj0gIW4gbHNyIDFcbiAgICBkb25lO1xuICAgICgqIG4gaXMgbmVjZXNzYXJpbHkgMSBhdCB0aGlzIHBvaW50LCBzbyB0aGVyZSBpcyBvbmUgYWRkaXRpb25hbFxuICAgICAgIG11bHRpcGxpY2F0aW9uIGJ5IHguICopXG4gICAgIXggKi4gIWFjY3VtKVxuOztcblxubGV0IHJvdW5kX2dlbiB4IH5ob3cgPVxuICBpZiB4ID0gMC5cbiAgdGhlbiAwLlxuICBlbHNlIGlmIG5vdCAoaXNfZmluaXRlIHgpXG4gIHRoZW4geFxuICBlbHNlIChcbiAgICAoKiBTaWduaWZpY2FudCBkaWdpdHMgYW5kIGRlY2ltYWwgZGlnaXRzLiAqKVxuICAgIGxldCBzZCwgZGQgPVxuICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgIHwgYHNpZ25pZmljYW50X2RpZ2l0cyBzZCAtPlxuICAgICAgICBsZXQgZGQgPSBzZCAtIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICAgIHwgYGRlY2ltYWxfZGlnaXRzIGRkIC0+XG4gICAgICAgIGxldCBzZCA9IGRkICsgdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgIGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIHNkIDwgMFxuICAgIHRoZW4gMC5cbiAgICBlbHNlIGlmIHNkID49IDE3XG4gICAgdGhlbiB4XG4gICAgZWxzZSAoXG4gICAgICAoKiBDaG9vc2UgdGhlIG9yZGVyIHRoYXQgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQuIFNtYWxsIHBvc2l0aXZlXG4gICAgICAgICBpbnRlZ2VycyBhcmUsIGJ1dCB0aGVpciBpbnZlcnNlcyBpbiBtb3N0IGNhc2VzIGFyZSBub3QuICopXG4gICAgICBsZXQgYWJzX2RkID0gSW50LmFicyBkZCBpblxuICAgICAgaWYgYWJzX2RkID4gMjIgfHwgc2QgPj0gMTZcbiAgICAgICAgICgqIDEwKioyMiBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgYnV0IDEwKioyMyBpcyBub3QsIHNvIHVzZSB0aGUgc2xvd1xuICAgICAgICAgcGF0aC4gIFNpbWlsYXJseSwgaWYgd2UgbmVlZCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJlc3VsdCwgdGhlbiB0aGUgaW50ZWdlclxuICAgICAgICAgW3JvdW5kX25lYXJlc3QgKHggPG9wPiBvcmRlcildIG1pZ2h0IG5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgc2luY2VcbiAgICAgICAgIGZvciBzb21lIHJhbmdlcyB3ZSBvbmx5IGhhdmUgMTUgZGlnaXRzIG9mIHByZWNpc2lvbiBndWFyYW50ZWVkLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHdlIGFyZSBzdGlsbCByb3VuZGluZyB0d2ljZSBoZXJlOlxuXG4gICAgICAgICAxKSBmaXJzdCB0aW1lIHdoZW4gcm91bmRpbmcgW3ggKi4gb3JkZXJdIG9yIFt4IC8uIG9yZGVyXSB0byB0aGUgbmVhcmVzdCBmbG9hdFxuICAgICAgICAgKGp1c3QgdGhlIG5vcm1hbCB3YXkgZmxvYXRpbmctcG9pbnQgbXVsdGlwbGljYXRpb24gb3IgZGl2aXNpb24gd29ya3MpLFxuXG4gICAgICAgICAyKSBzZWNvbmQgdGltZSB3aGVuIGFwcGx5aW5nIFtyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbl0gdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIGFib3ZlIG9wZXJhdGlvblxuXG4gICAgICAgICBTbyBmb3IgYXJndW1lbnRzIHdpdGhpbiBhbiB1bHAgZnJvbSBhIHRpZSB3ZSBtaWdodCBzdGlsbCBwcm9kdWNlIGFuIG9mZi1ieS1vbmVcbiAgICAgICAgIHJlc3VsdC4gKilcbiAgICAgIHRoZW4gb2Zfc3RyaW5nIChzcHJpbnRmIFwiJS4qZ1wiIHNkIHgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG9yZGVyID0gaW50X3BvdyAxMC4gYWJzX2RkIGluXG4gICAgICAgIGlmIGRkID49IDBcbiAgICAgICAgdGhlbiByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAqLiBvcmRlcikgLy4gb3JkZXJcbiAgICAgICAgZWxzZSByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAvLiBvcmRlcikgKi4gb3JkZXIpKSlcbjs7XG5cbmxldCByb3VuZF9zaWduaWZpY2FudCB4IH5zaWduaWZpY2FudF9kaWdpdHMgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBzaWduaWZpY2FudF9kaWdpdHMgMFxuICB0aGVuXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LnJvdW5kX3NpZ25pZmljYW50OiBpbnZhbGlkIGFyZ3VtZW50IHNpZ25pZmljYW50X2RpZ2l0czolZFwiXG4gICAgICBzaWduaWZpY2FudF9kaWdpdHNcbiAgICAgICgpXG4gIGVsc2Ugcm91bmRfZ2VuIHggfmhvdzooYHNpZ25pZmljYW50X2RpZ2l0cyBzaWduaWZpY2FudF9kaWdpdHMpXG47O1xuXG5sZXQgcm91bmRfZGVjaW1hbCB4IH5kZWNpbWFsX2RpZ2l0cyA9IHJvdW5kX2dlbiB4IH5ob3c6KGBkZWNpbWFsX2RpZ2l0cyBkZWNpbWFsX2RpZ2l0cylcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgKCogY2xhbXBfdW5jaGVja2VkIGlzIGluIGZsb2F0MC5tbCAqKVxuICBjbGFtcF91bmNoZWNrZWRcbiAgICB+dG9fY2xhbXBfbWF5YmVfbmFuOnRcbiAgICB+bWluX3doaWNoX2lzX25vdF9uYW46bWluXG4gICAgfm1heF93aGljaF9pc19ub3RfbmFuOm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgaWYgbWluIDw9IG1heFxuICB0aGVuXG4gICAgT2tcbiAgICAgIChjbGFtcF91bmNoZWNrZWRcbiAgICAgICAgIH50b19jbGFtcF9tYXliZV9uYW46dFxuICAgICAgICAgfm1pbl93aGljaF9pc19ub3RfbmFuOm1pblxuICAgICAgICAgfm1heF93aGljaF9pc19ub3RfbmFuOm1heClcbiAgZWxzZVxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbjs7XG5cbmxldCAoICsgKSA9ICggKy4gKVxubGV0ICggLSApID0gKCAtLiApXG5sZXQgKCAqICkgPSAoICouIClcbmxldCAoICoqICkgPSAoICoqIClcbmxldCAoIC8gKSA9ICggLy4gKVxubGV0ICggJSApID0gKCAlLiApXG5sZXQgKCB+LSApID0gKCB+LS4gKVxuXG5sZXRbQGlubGluZV0gc2lnbl9leG4gdCA6IFNpZ24udCA9XG4gIGlmIHQgPiAwLlxuICB0aGVuIFBvc1xuICBlbHNlIGlmIHQgPCAwLlxuICB0aGVuIE5lZ1xuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuIFplcm9cbiAgZWxzZSBFcnJvci5yYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJGbG9hdC5zaWduX2V4biBvZiBOQU5cIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgc2lnbl9vcl9uYW4gdCA6IFNpZ25fb3JfbmFuLnQgPVxuICBpZiB0ID4gMC4gdGhlbiBQb3MgZWxzZSBpZiB0IDwgMC4gdGhlbiBOZWcgZWxzZSBpZiB0ID0gMC4gdGhlbiBaZXJvIGVsc2UgTmFuXG47O1xuXG5sZXQgaWVlZV9uZWdhdGl2ZSB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIFBvbHkuKGJpdHMgPCBTdGRsaWIuSW50NjQuemVybylcbjs7XG5cbmxldCBleHBvbmVudF9iaXRzID0gMTFcbmxldCBtYW50aXNzYV9iaXRzID0gNTJcbmxldCBleHBvbmVudF9tYXNrNjQgPSBJbnQ2NC4oc2hpZnRfbGVmdCBvbmUgZXhwb25lbnRfYml0cyAtIG9uZSlcbmxldCBleHBvbmVudF9tYXNrID0gSW50NjQudG9faW50X2V4biBleHBvbmVudF9tYXNrNjRcbmxldCBtYW50aXNzYV9tYXNrID0gSW50NjMuKHNoaWZ0X2xlZnQgb25lIG1hbnRpc3NhX2JpdHMgLSBvbmUpXG5sZXQgbWFudGlzc2FfbWFzazY0ID0gSW50NjMudG9faW50NjQgbWFudGlzc2FfbWFza1xuXG5sZXQgaWVlZV9leHBvbmVudCB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDY0LihiaXRfYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGJpdHMgbWFudGlzc2FfYml0cykgZXhwb25lbnRfbWFzazY0KVxuICB8PiBTdGRsaWIuSW50NjQudG9faW50XG47O1xuXG5sZXQgaWVlZV9tYW50aXNzYSB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gICgqIFRoaXMgaXMgc2FmZSBiZWNhdXNlIG1hbnRpc3NhX21hc2s2NCA8IEludDYzLm1heF92YWx1ZSAqKVxuICAoSW50NjMub2ZfaW50NjRfdHJ1bmMgW0BpbmxpbmVkXSkgU3RkbGliLkludDY0Lihsb2dhbmQgYml0cyBtYW50aXNzYV9tYXNrNjQpXG47O1xuXG5sZXQgY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgaWYgSW50LihiaXRfYW5kIGV4cG9uZW50IGV4cG9uZW50X21hc2sgPD4gZXhwb25lbnQpXG4gIHRoZW4gZmFpbHdpdGhmIFwiZXhwb25lbnQgJWQgb3V0IG9mIHJhbmdlIFswLCAlZF1cIiBleHBvbmVudCBleHBvbmVudF9tYXNrICgpXG4gIGVsc2UgaWYgSW50NjMuKGJpdF9hbmQgbWFudGlzc2EgbWFudGlzc2FfbWFzayA8PiBtYW50aXNzYSlcbiAgdGhlblxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJtYW50aXNzYSAlcyBvdXQgb2YgcmFuZ2UgWzAsICVzXVwiXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhKVxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYV9tYXNrKVxuICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHNpZ25fYml0cyA9IGlmIG5lZ2F0aXZlIHRoZW4gU3RkbGliLkludDY0Lm1pbl9pbnQgZWxzZSBTdGRsaWIuSW50NjQuemVybyBpblxuICAgIGxldCBleHB0X2JpdHMgPVxuICAgICAgU3RkbGliLkludDY0LnNoaWZ0X2xlZnQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgZXhwb25lbnQpIG1hbnRpc3NhX2JpdHNcbiAgICBpblxuICAgIGxldCBtYW50X2JpdHMgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYSBpblxuICAgIGxldCBiaXRzID0gU3RkbGliLkludDY0Lihsb2dvciBzaWduX2JpdHMgKGxvZ29yIGV4cHRfYml0cyBtYW50X2JpdHMpKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIGJpdHMpXG47O1xuXG5sZXQgY3JlYXRlX2llZWUgfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSlcbjs7XG5cbm1vZHVsZSBUZXJzZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0X29mX3NleHAgPSB0X29mX3NleHBcbiAgbGV0IHRvX3N0cmluZyB4ID0gUHJpbnRmLnNwcmludGYgXCIlLjhHXCIgeFxuICBsZXQgc2V4cF9vZl90IHggPSBTZXhwLkF0b20gKHRvX3N0cmluZyB4KVxuICBsZXQgb2Zfc3RyaW5nIHggPSBvZl9zdHJpbmcgeFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuKCogVGhlc2UgYXJlIHBhcnRseSBoZXJlIGFzIGEgcGVyZm9ybWFuY2UgaGFjayB0byBhdm9pZCBzb21lIGJveGluZyB3ZSdyZSBnZXR0aW5nIHdpdGhcbiAgIHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXS4gIFRoZXkgYWxzbyBtYWtlIFtGbG9hdC5pc19uZWdhdGl2ZSBuYW5dIGFuZFxuICAgW0Zsb2F0LmlzX25vbl9wb3NpdGl2ZSBuYW5dIHJldHVybiBbZmFsc2VdOyB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10gcmV0dXJuXG4gICBbdHJ1ZV0uICopXG5sZXQgaXNfcG9zaXRpdmUgdCA9IHQgPiAwLlxubGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gdCA+PSAwLlxubGV0IGlzX25lZ2F0aXZlIHQgPSB0IDwgMC5cbmxldCBpc19ub25fcG9zaXRpdmUgdCA9IHQgPD0gMC5cblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5GbG9hdFwiXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbmVuZClcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggJSApID0gKCAlIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnQgPSBvZl9pbnRcbiAgbGV0IG9mX2Zsb2F0IHggPSB4XG5lbmRcblxubW9kdWxlIE9fZG90ID0gc3RydWN0XG4gIGxldCAoICouICkgPSAoICogKVxuICBsZXQgKCArLiApID0gKCArIClcbiAgbGV0ICggLS4gKSA9ICggLSApXG4gIGxldCAoIC8uICkgPSAoIC8gKVxuICBsZXQgKCAlLiApID0gKCAlIClcbiAgbGV0ICggfi0uICkgPSAoIH4tIClcbiAgbGV0ICggKiouICkgPSAoICoqIClcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgYm94ID0gYm94XG4gIGxldCBjbGFtcF91bmNoZWNrZWQgPSBjbGFtcF91bmNoZWNrZWRcbiAgbGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgPSBsb3dlcl9ib3VuZF9mb3JfaW50XG4gIGxldCB1cHBlcl9ib3VuZF9mb3JfaW50ID0gdXBwZXJfYm91bmRfZm9yX2ludFxuICBsZXQgc3BlY2lhbGl6ZWRfaGFzaCA9IGhhc2hfZmxvYXRcbiAgbGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIGxldCBpcm91bmRfbmVhcmVzdF9leG5fNjQgPSBpcm91bmRfbmVhcmVzdF9leG5fNjRcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBzcGVjaWZpY2FsbHkgcmVwbGFjZSBkZWZhdWx0cyBpbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuXG5cbiAgIFRoZSBkZXNpcmVkIGJlaGF2aW9yIGhlcmUgaXMgdG8gcHJvcGFnYXRlIGEgbmFuIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4uIEJlY2F1c2UgdGhlXG4gICBmaXJzdCBjb21wYXJpc29uIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLCBpdCBzdWZmaWNlcyB0b1xuICAgY2hlY2sgaWYgeCBpcyBuYW4uIFRoZW4sIHdoZW4geCBpcyBuYW4gb3IgYm90aCB4IGFuZCB5IGFyZSBuYW4sIHdlIHJldHVybiB4ID0gbmFuOyBhbmRcbiAgIHdoZW4geSBpcyBuYW4gYnV0IG5vdCB4LCB3ZSByZXR1cm4geSA9IG5hbi5cblxuICAgVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyB0byBpbXBsZW1lbnQgdGhlc2UgZnVuY3Rpb25zLiAgVGhlIGJlbmNobWFyayBiZWxvdyBzaG93cyBhIGZld1xuICAgZGlmZmVyZW50IHZlcnNpb25zLiAgVGhpcyBiZW5jaG1hcmsgd2FzIHJ1biBvdmVyIGFuIGFycmF5IG9mIHJhbmRvbSBmbG9hdHMgKG5vbmUgb2ZcbiAgIHdoaWNoIGFyZSBuYW4pLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi40MnVzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMi4wMnVzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS44OHVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgIFRoZSBiZW5jaG1hcmsgYmVsb3cgd2FzIHJ1biB3aGVuIHggPiB5IGlzIGFsd2F5cyB0cnVlIChhZ2Fpbiwgbm8gbmFuIHZhbHVlcykuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjgzdXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjk3dXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjU2dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiopXG5sZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbmxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3Rfb3V0X29mX3JhbmdlXzAiLCJjc3Rfc18xZSIsImNzdF9pc190b29fbGFyZ2UiLCJjc3RfaXNfdG9vX3NtYWxsX29yX05hTiIsImNzdF9GbG9hdF9pbnQ2M19yb3VuZF9kb3duX2V4biIsImNzdF9GbG9hdF9pbnQ2M19yb3VuZF9uZWFyZXN0XyIsImNzdF9GbG9hdF9pbnQ2M19yb3VuZF91cF9leG5fYSIsImNzdF9GbG9hdF9pcm91bmRfZG93bl9leG5fYXJndSIsImNzdF9GbG9hdF9pcm91bmRfbmVhcmVzdF9leG5fYSIsImNzdF9GbG9hdF9pcm91bmRfdXBfZXhuX2FyZ3VtZSIsImNzdF9JbmZpbml0ZSIsImNzdF9OYW4iLCJjc3RfTm9ybWFsIiwiY3N0X1N1Ym5vcm1hbCIsImNzdF9aZXJvIiwiY3N0X2luZmluaXRlIiwiY3N0X25hbiIsImNzdF9ub3JtYWwiLCJjc3Rfc3JjX2Zsb2F0X21sIiwiY3N0X3N1Ym5vcm1hbCIsImNzdF96ZXJvIiwiY2FtbF9ieXRlc19zZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJhbGwiLCJlcnJvcl9zb3VyY2VfMDA3IiwidF9zZXhwX2dyYW1tYXIiLCJtb2R1bGVfbmFtZSIsIkJhc2VfUHJpbnRmIiwiQmFzZV9Pcl9lcnJvciIsIkJhc2VfSW50IiwiQmFzZV9JbnQ2MyIsIlN0ZGxpYl9JbnQ2NCIsIkJhc2VfSW50NjQiLCJCYXNlX1NleHAiLCJCYXNlX0Vycm9yIiwiQXNzZXJ0X2ZhaWx1cmUiLCJCYXNlX0ltcG9ydCIsIkJhc2VfU3RyaW5nIiwiQmFzZV9CeXRlczAiLCJCYXNlX0NoYXIiLCJCYXNlX0ludF9zdHJpbmdfY29udmVyc2lvbnMiLCJTZXhwbGliMF9TZXhwX2NvbnZfZXJyb3IiLCJCYXNlX0Zsb2F0MCIsIkJhc2VfQ29tcGFyYXRvciIsIkJhc2VfV29yZF9zaXplIiwiQmFzZV9Db21wYXJhYmxlIiwiQmFzZV9QcmV0dHlfcHJpbnRlciIsInJvdW5kX3VwIiwicm91bmRfZG93biIsIm1vZF9mbG9hdCIsIm1vZGYiLCJmbG9hdF9vZl9zdHJpbmciLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwibmFuIiwibWF4X3ZhbHVlIiwibmVnX2luZmluaXR5IiwibWF4X2Zpbml0ZV92YWx1ZSIsImVwc2lsb25fZmxvYXQiLCJjbGFzc2lmeV9mbG9hdCIsImFic19mbG9hdCIsImlzX2ludGVnZXIiLCJzeW1ib2wiLCJmcmV4cCIsImxkZXhwIiwiaXNfbmFuIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXIiLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4iLCJvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsIm9uZV91bHAiLCJ1cHBlcl9ib3VuZF9mb3JfaW50IiwibG93ZXJfYm91bmRfZm9yX2ludCIsImNsYW1wX3VuY2hlY2tlZCIsImJveCIsInJhaXNlX3MiLCJoYXNoX2ZvbGRfdCIsImZ1bmMiLCJoYXNoIiwieCIsImdsb2JhbGl6ZSIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsImhhc2hhYmxlIiwiY29tcGFyZSIsImluY2x1ZGUiLCJjb21wYXJhdG9yIiwiaW52YXJpYW50IiwicGFyYW0iLCJ0b19mbG9hdCIsIm9mX2Zsb2F0Iiwib2Zfc3RyaW5nIiwicyIsImV4biIsInRvX3N0cmluZyIsInkiLCJsIiwiaSIsIm1hdGNoIiwibWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSIsIm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUiLCJ6ZXJvIiwib2ZfaW50IiwidG9faW50Iiwib2ZfaW50NjMiLCJvZl9pbnQ2NCIsInRvX2ludDY0IiwiaXJvdW5kX2xib3VuZCIsImlyb3VuZF91Ym91bmQiLCJpcm91bmRfdXAiLCJ0IiwiaXJvdW5kX3VwX2V4biIsImlyb3VuZF9kb3duIiwiaXJvdW5kX2Rvd25fZXhuIiwiaXJvdW5kX3Rvd2FyZHNfemVybyIsImlyb3VuZF90b3dhcmRzX3plcm9fZXhuIiwicm91bmRfbmVhcmVzdF9sYiIsInJvdW5kX25lYXJlc3RfdWIiLCJvbmVfdWxwX2xlc3NfdGhhbl9oYWxmIiwiYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QiLCJpcm91bmRfbmVhcmVzdF8zMiIsImlyb3VuZF9uZWFyZXN0XzY0IiwiY3N0X0Zsb2F0X3NpZ25fZXhuX29mX05BTiIsImNzdF9tYXgiLCJjc3RfbWluIiwiY3N0X2NsYW1wX3JlcXVpcmVzX21pbl9tYXgiLCJjc3RfdCIsImNzdF9nIiwiY3N0X20iLCJjc3RfayIsImNzdF8wIiwiY3N0X2luZiIsImNzdF9zZXhwIiwiY3N0X3NleHBfb2ZfZmxvYXRfcHJvZHVjZWRfc3RyIiwib25lIiwibWludXNfb25lIiwicGkiLCJzcXJ0X3BpIiwic3FydF8ycGkiLCJldWxlciIsImlyb3VuZF9uZWFyZXN0IiwiaXJvdW5kX25lYXJlc3RfZXhuXzMyIiwiaXJvdW5kX25lYXJlc3RfZXhuXzY0IiwiaXJvdW5kX25lYXJlc3RfZXhuIiwiaXJvdW5kX2V4biIsIm9wdCIsImRpciIsImlyb3VuZCIsImlzX2luZiIsImlzX2Zpbml0ZSIsIm1pbl9pbmFuIiwibWF4X2luYW4iLCJhZGQiLCJzdWIiLCJuZWciLCJzY2FsZSIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX3Rvd2FyZHNfemVybyIsInJvdW5kX25lYXJlc3RfaW5saW5lIiwicm91bmRfbmVhcmVzdCIsInJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuIiwiZmxvb3IiLCJjZWlsX29yX3N1Y2MiLCJkaWZmX2Zsb29yIiwiZGlmZl9jZWlsIiwiaW50NjNfcm91bmRfbGJvdW5kIiwiaW50NjNfcm91bmRfdWJvdW5kIiwiaW50NjNfcm91bmRfdXBfZXhuIiwiaW50NjNfcm91bmRfZG93bl9leG4iLCJpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2EiLCJ0MCIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwicm91bmQiLCJjb21wYXJlX2xvY2FsIiwic2V4cF8wMDgiLCJjbGFzc2lmeSIsImluc2VydF91bmRlcnNjb3JlcyIsInN0cmluZyIsImRlbGltaXRlciIsInN0cmlwX3plcm8iLCJyaWdodCIsImxlZnQiLCJjIiwidG9fc3RyaW5nX2h1bSIsImRlY2ltYWxzIiwiZXhwbGljaXRfcGx1cyIsInNleHAiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG8iLCJraWxvIiwibWVnYSIsImdpZ2EiLCJ0ZXJhIiwicGV0YSIsInByZWZpeCIsImdvIiwiY29udiIsIm1hZyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiayIsImxvd2VyIiwiaGlnaGVyIiwiZGlmZl9yaWdodCIsImRpZmZfbGVmdCIsImQiLCJuIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIiwiaW50X3BvdyIsImFjY3VtIiwicm91bmRfZ2VuIiwiaG93IiwidmFyaWFudCIsInNkIiwiZGQiLCJhYnNfZGQiLCJvcmRlciIsInJvdW5kX3NpZ25pZmljYW50Iiwic2lnbmlmaWNhbnRfZGlnaXRzIiwicm91bmRfZGVjaW1hbCIsImRlY2ltYWxfZGlnaXRzIiwiYmV0d2VlbiIsImxvdyIsImhpZ2giLCJjbGFtcF9leG4iLCJtaW4iLCJtYXgiLCJjbGFtcCIsInNpZ25fZXhuIiwic2lnbl9vcl9uYW4iLCJpZWVlX25lZ2F0aXZlIiwiYml0cyIsIm1hbnRpc3NhX2JpdHMiLCJleHBvbmVudF9tYXNrNjQiLCJleHBvbmVudF9tYXNrIiwibWFudGlzc2FfbWFzayIsIm1hbnRpc3NhX21hc2s2NCIsImllZWVfZXhwb25lbnQiLCJpZWVlX21hbnRpc3NhIiwiY3JlYXRlX2llZWVfZXhuIiwibmVnYXRpdmUiLCJleHBvbmVudCIsIm1hbnRpc3NhIiwic2lnbl9iaXRzIiwiZXhwdF9iaXRzIiwibWFudF9iaXRzIiwiY3JlYXRlX2llZWUiLCJzaWduIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInBwIiwic3BlY2lhbGl6ZWRfaGFzaCIsIlByaXZhdGUiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiZXF1YWxfbG9jYWwiLCJCYXNlX0Zsb2F0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUosUUFBQTtBQUFBLElBQUFLLGlDQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFBO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR4NUJsRCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMjgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9GaWVsZHNsaWIiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMjkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2UuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9CdWZmZXJfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLG1CQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDEzMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYnVmZmVyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJ1ZmZlcl9pbnRmXG5pbmNsdWRlIFN0ZGxpYi5CdWZmZXJcblxubGV0IGNvbnRlbnRzX2J5dGVzID0gdG9fYnl0ZXNcbmxldCBhZGRfc3Vic3RyaW5nIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3Vic3RyaW5nIHQgcyBwb3MgbGVuXG5sZXQgYWRkX3N1YmJ5dGVzIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3ViYnl0ZXMgdCBzIHBvcyBsZW5cbmxldCBzZXhwX29mX3QgdCA9IHNleHBfb2Zfc3RyaW5nIChjb250ZW50cyB0KVxubGV0IGNhbWxfYnVmZmVyX2xlbmd0aCA9IChTdGRsaWIuT2JqLm1hZ2ljIChTdGRsaWIuQnVmZmVyLmxlbmd0aCA6IHQgLT4gaW50KSA6IHQgLT4gaW50KVxuXG5sZXQgY2FtbF9idWZmZXJfYmxpdCA9XG4gIChTdGRsaWIuT2JqLm1hZ2ljXG4gICAgIChTdGRsaWIuQnVmZmVyLmJsaXQgOiBTdGRsaWIuQnVmZmVyLnQgLT4gaW50IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiB1bml0KVxuICAgIDogU3RkbGliLkJ1ZmZlci50IC0+IGludCAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gdW5pdClcbjs7XG5cbm1vZHVsZSBUb19ieXRlcyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBsZW5ndGggPSBjYW1sX2J1ZmZlcl9sZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQnl0ZXMudFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBCeXRlcy5jcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoXG5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgICAgIGNhbWxfYnVmZmVyX2JsaXQgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG4gICAgICA7O1xuICAgIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFN0ZGxpYi5CdWZmZXIpIChUb19ieXRlcylcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX0J5dGVzIiwiQmFzZV9JbXBvcnQiLCJTdGRsaWJfQnVmZmVyIiwiQmFzZV9CbGl0IiwiY3JlYXRlIiwiY29udGVudHMiLCJ0b19ieXRlcyIsIm50aCIsImxlbmd0aCIsImNsZWFyIiwicmVzZXQiLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYWRkX3N1YnN0cmluZyIsInQiLCJzIiwicG9zIiwibGVuIiwiYWRkX3N1YmJ5dGVzIiwic2V4cF9vZl90IiwiY2FtbF9idWZmZXJfbGVuZ3RoIiwiY2FtbF9idWZmZXJfYmxpdCIsInVuc2FmZV9ibGl0Iiwic3JjIiwic3JjX3BvcyIsImRzdCIsImRzdF9wb3MiLCJUb19ieXRlcyIsImJsaXQiLCJibGl0byIsInN1YiIsInN1Ym8iLCJUb19zdHJpbmciLCJCYXNlX0J1ZmZlciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxjQUFBQyxHQUFBQyxHQUFBQyxLQUFBQyxLQ0trQyx3QkFBeUI7QUFBQSxZQUFBQyxhQUFBSixHQUFBQyxHQUFBQyxLQUFBQyxLQUMxQix3QkFBd0I7QUFBQSxZQUFBRSxVQUFBTDtBQUFBQSxRQUFBLElBQ3hCO0FBQUEsSUFBWTtBQUFBO0FBQUE7QUFBQSxJQUFBTSxxQkRQN0M7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLFlBQUFuQixTQUFBZSxLQzBCd0IscUNBQWdCO0FBQUEsT0FBQVgsV0QxQnhDO0FBQUEsWUFBQWdCLFlBQUFDLEtBQUFDLFNBQUFDLEtBQUFDLFNBQUFUO0FBQUFBLElDOEJRLHdEQUE0QztBQUFBO0FBQUE7QUFBQSxJQUFBVTtBQUFBQSxNRDlCcEQ7QUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQVAsZ0JBQUE7QUFBQSxJQUFBUSxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDEzODMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYmFja3RyYWNlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPSBTdGRsaWIuUHJpbnRleGMucmF3X2JhY2t0cmFjZVxuXG5sZXQgZWxpZGUgPSByZWYgZmFsc2VcbmxldCBlbGlkZWRfbWVzc2FnZSA9IFwiPGJhY2t0cmFjZSBlbGlkZWQgaW4gdGVzdD5cIlxuXG5sZXQgZ2V0ID8oYXRfbW9zdF9udW1fZnJhbWVzID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBTdGRsaWIuUHJpbnRleGMuZ2V0X2NhbGxzdGFjayBhdF9tb3N0X251bV9mcmFtZXNcbjs7XG5cbmxldCB0b19zdHJpbmcgdCA9XG4gIGlmICFlbGlkZSB0aGVuIGVsaWRlZF9tZXNzYWdlIGVsc2UgU3RkbGliLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHRcbjs7XG5cbmxldCB0b19zdHJpbmdfbGlzdCB0ID0gU3RyaW5nLnNwbGl0X2xpbmVzICh0b19zdHJpbmcgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuTGlzdCAoTGlzdC5tYXAgKHRvX3N0cmluZ19saXN0IHQpIH5mOihmdW4geCAtPiBTZXhwLkF0b20geCkpXG5cbm1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgbGV0IHNldF9yZWNvcmRpbmcgPSBTdGRsaWIuUHJpbnRleGMucmVjb3JkX2JhY2t0cmFjZVxuICBsZXQgYW1fcmVjb3JkaW5nID0gU3RkbGliLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXNcbiAgbGV0IG1vc3RfcmVjZW50ICgpID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpXG5cbiAgbGV0IG1vc3RfcmVjZW50X2Zvcl9leG4gZXhuID1cbiAgICBpZiBFeG4uaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCBleG4gdGhlbiBTb21lIChtb3N0X3JlY2VudCAoKSkgZWxzZSBOb25lXG4gIDs7XG5cbiAgKCogV2UgdHVybiBvbiBiYWNrdHJhY2VzIGJ5IGRlZmF1bHQgaWYgT0NBTUxSVU5QQVJBTSBkb2Vzbid0IGV4cGxpY2l0bHkgbWVudGlvbiB0aGVtLiAqKVxuICBsZXQgbWF5YmVfc2V0X3JlY29yZGluZyAoKSA9XG4gICAgbGV0IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyA9XG4gICAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT4gTGlzdC5leGlzdHMgKFN0cmluZy5zcGxpdCB4IH5vbjonLCcpIH5mOihTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCJiXCIpXG4gICAgaW5cbiAgICBpZiBub3Qgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzIHRoZW4gc2V0X3JlY29yZGluZyB0cnVlXG4gIDs7XG5cbiAgKCogdGhlIGNhbGxlciBzZXQgc29tZXRoaW5nLCB0aGV5IGFyZSByZXNwb25zaWJsZSAqKVxuXG4gIGxldCB3aXRoX3JlY29yZGluZyBiIH5mID1cbiAgICBsZXQgc2F2ZWQgPSBhbV9yZWNvcmRpbmcgKCkgaW5cbiAgICBzZXRfcmVjb3JkaW5nIGI7XG4gICAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBzZXRfcmVjb3JkaW5nIHNhdmVkKVxuICA7O1xuZW5kXG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IEV4bi5tYXliZV9zZXRfcmVjb3JkaW5nICgpXG4iXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiZWxpZGVkX21lc3NhZ2UiLCJCYXNlX0V4biIsIkJhc2VfU3lzMCIsIkJhc2VfU3RyaW5nIiwiQmFzZV9MaXN0IiwiU3RkbGliX1ByaW50ZXhjIiwiQmFzZV9JbnQiLCJlbGlkZSIsImdldCIsIm9wdCIsInBhcmFtIiwiYXRfbW9zdF9udW1fZnJhbWVzIiwidG9fc3RyaW5nIiwidCIsInRvX3N0cmluZ19saXN0Iiwic2V4cF9vZl90IiwieCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJjc3RfT0NBTUxSVU5QQVJBTSIsImNzdF9iIiwibW9zdF9yZWNlbnQiLCJtb3N0X3JlY2VudF9mb3JfZXhuIiwiZXhuIiwid2l0aF9yZWNvcmRpbmciLCJiIiwiZiIsInNhdmVkIiwiaW5pdGlhbGl6ZV9tb2R1bGUiLCJtYXRjaCIsIm9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYSIsIkJhc2VfQmFja3RyYWNlIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsWUFBQUMsSUFBQUMsS0FBQUM7QUFBQUEsUUFBQUMscUJDUVE7QUFBQSxJQUNOLDZEQUFnRDtBQUFBO0FBQUEsWUFBQUMsVUFBQUM7QUFBQUEsSUFJaEQsbUNBQW1DLGlDQUF5QztBQUFBO0FBQUEsWUFBQUMsZUFBQUQ7QUFBQUEsUUFBQSxJQUdwQztBQUFBLElBQWE7QUFBQTtBQUFBLFlBQUFFLFVBQUFGO0FBQUFBLFFBQUEsSUFDakI7QUFBQSxJQUFWLGdEQUFBRyxHQUEwQyxjQUFXLEdBQUU7QUFBQTtBQUFBO0FBQUEsSUFBQUMsZ0JEakJuRjtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxZQUFBQyxZQUFBWCxPQ3NCdUIsd0NBQW9DO0FBQUEsWUFBQVksb0JBQUFDO0FBQUFBLElBR3BELDBDQUE0QyxtQkFBMEI7QUFBQTtBQUFBLFlBQUFDLGVBQUFDLEdBQUFDO0FBQUFBLFFBQUFDLFFBZ0I3RDtBQUFBLElBQ1o7QUFBQSxJQUFlO0FBQUEsK0JBQUFqQixPQUNvQiwyQkFBbUIsR0FBQztBQUFBO0FBQUEsWUFBQWtCLGtCQUFBbEI7QUFBQUEsUUFBQW1CLFFBWi9DO0FBQUEsSUFBMEI7QUFBQTtBQUFBLE1BQUFiLElBQUE7QUFBQSxVQUVwQjtBQUFBLFVBQVk7QUFBQSxNQUFBYztBQUFBQSxRQUFaLHdDRGpDbEI7QUFBQTtBQUFBLFNBQUFBLGlDQ2dDZ0I7QUFBQSxZQUdaO0FBQUEsZUFBOEMsb0JBWUc7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUQvQ3JEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDE0NjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2UvYmFzZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBUaGlzIG1vZHVsZSBpcyB0aGUgdG9wbGV2ZWwgb2YgdGhlIEJhc2UgbGlicmFyeTsgaXQncyB3aGF0IHlvdSBnZXQgd2hlbiB5b3Ugd3JpdGVcbiAgICBbb3BlbiBCYXNlXS5cblxuICAgIFRoZSBnb2FsIG9mIEJhc2UgaXMgYm90aCB0byBiZSBhIG1vcmUgY29tcGxldGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCByaWNoZXIgQVBJcyxcbiAgICBhbmQgdG8gYmUgbW9yZSBjb25zaXN0ZW50IGluIGl0cyBkZXNpZ24uIEZvciBpbnN0YW5jZSwgaW4gdGhlIHN0YW5kYXJkIGxpYnJhcnlcbiAgICBzb21lIHRoaW5ncyBoYXZlIG1vZHVsZXMgYW5kIG90aGVycyBkb24ndDsgaW4gQmFzZSwgZXZlcnl0aGluZyBpcyBhIG1vZHVsZS5cblxuICAgIEJhc2UgZXh0ZW5kcyBzb21lIG1vZHVsZXMgYW5kIGRhdGEgc3RydWN0dXJlcyBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCBsaWtlIFtBcnJheV0sXG4gICAgW0J1ZmZlcl0sIFtCeXRlc10sIFtDaGFyXSwgW0hhc2h0YmxdLCBbSW50MzJdLCBbSW50NjRdLCBbTGF6eV0sIFtMaXN0XSwgW01hcF0sXG4gICAgW05hdGl2ZWludF0sIFtQcmludGZdLCBbUmFuZG9tXSwgW1NldF0sIFtTdHJpbmddLCBbU3lzXSwgYW5kIFtVY2hhcl0uIE9uZSBrZXlcbiAgICBkaWZmZXJlbmNlIGlzIHRoYXQgQmFzZSBkb2Vzbid0IHVzZSBleGNlcHRpb25zIGFzIG11Y2ggYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkgYW5kXG4gICAgaW5zdGVhZCBtYWtlcyBoZWF2eSB1c2Ugb2YgdGhlIFtSZXN1bHRdIHR5cGUsIGFzIGluOlxuXG4gICAge1sgdHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2IgXX1cblxuICAgIEJhc2UgYWxzbyBhZGRzIGVudGlyZWx5IG5ldyBtb2R1bGVzLCBtb3N0IG5vdGFibHk6XG5cbiAgICAtIFtDb21wYXJhYmxlXSwgW0NvbXBhcmF0b3JdLCBhbmQgW0NvbXBhcmlzb25zXSBpbiBsaWV1IG9mIHBvbHltb3JwaGljIGNvbXBhcmUuXG4gICAgLSBbQ29udGFpbmVyXSwgd2hpY2ggcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgY29udGFpbmVyLWxpa2UgZGF0YVxuICAgICAgc3RydWN0dXJlcyAoYXJyYXlzLCBsaXN0cywgc3RyaW5ncykuXG4gICAgLSBbUmVzdWx0XSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0sIHN1cHBvcnRpbmcgdGhlIG9yLWVycm9yIHBhdHRlcm4uXG4qKVxuXG4oKl8gV2UgaGlkZSB0aGlzIGZyb20gdGhlIHdlYiBkb2NzIGJlY2F1c2UgdGhlIGxpbmUgd3JhcHBpbmcgaXMgYmFkLCBtYWtpbmcgaXRcbiAgcHJldHR5IG11Y2ggaW5zY3J1dGFibGUuICopXG4oKiovKiopXG5cbigqIFRoZSBpbnRlbnQgaXMgdG8gc2hhZG93IGFsbCBvZiBJTlJJQSdzIHN0YW5kYXJkIGxpYnJhcnkuICBNb2R1bGVzIGJlbG93IHdvdWxkIGNhdXNlXG4gICBjb21waWxhdGlvbiBlcnJvcnMgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb20gW1NoYWRvd19zdGRsaWJdIGJlZm9yZSBpbmNsdXNpb24uICopXG5cbmluY2x1ZGUgKFxuICBTaGFkb3dfc3RkbGliIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICAgIGVuZFxuICAgICgqIE1vZHVsZXMgZGVmaW5lZCBpbiBCYXNlICopXG4gICAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICAgIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICAgIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gICAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gICAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICAgIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gICAgd2l0aCBtb2R1bGUgQ29uZGl0aW9uIDo9IFNoYWRvd19zdGRsaWIuQ29uZGl0aW9uXG4gICAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gICAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICAgIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gICAgd2l0aCBtb2R1bGUgSW5fY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLkluX2NoYW5uZWxcbiAgICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgICB3aXRoIG1vZHVsZSBJbnQzMiA6PSBTaGFkb3dfc3RkbGliLkludDMyXG4gICAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICAgIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gICAgd2l0aCBtb2R1bGUgTGlzdCA6PSBTaGFkb3dfc3RkbGliLkxpc3RcbiAgICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgICB3aXRoIG1vZHVsZSBPcHRpb24gOj0gU2hhZG93X3N0ZGxpYi5PcHRpb25cbiAgICB3aXRoIG1vZHVsZSBPdXRfY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLk91dF9jaGFubmVsXG4gICAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gICAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICAgIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICAgIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICAgIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICAgIHdpdGggbW9kdWxlIFNlbWFwaG9yZSA6PSBTaGFkb3dfc3RkbGliLlNlbWFwaG9yZVxuICAgIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gICAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXRcbiAgICAoKiBPQ2FtbCA1LXJlbGF0ZWQgbW9kdWxlcyB3ZSBkb24ndCB3YW50IHRvIHN0YXJ0IHNoYWRvd2luZyB5ZXQuICopXG4gICAgd2l0aCBtb2R1bGUgRG9tYWluIDo9IFNoYWRvd19zdGRsaWIuRG9tYWluXG4gICAgd2l0aCBtb2R1bGUgVHlwZSA6PSBTaGFkb3dfc3RkbGliLlR5cGVcbiAgICAoKiBTdXBwb3J0IGZvciBnZW5lcmF0ZWQgbGV4ZXJzICopXG4gICAgd2l0aCBtb2R1bGUgTGV4aW5nIDo9IFNoYWRvd19zdGRsaWIuTGV4aW5nXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWYpXG5bQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiovKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmVcbm1vZHVsZSBBcnJheSA9IEFycmF5XG5tb2R1bGUgQXZsdHJlZSA9IEF2bHRyZWVcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYWNrdHJhY2Vcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmluYXJ5X3NlYXJjaFxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmluYXJ5X3NlYXJjaGFibGVcbm1vZHVsZSBCbGl0ID0gQmxpdFxubW9kdWxlIEJvb2wgPSBCb29sXG5tb2R1bGUgQnVmZmVyID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgPSBCeXRlc1xubW9kdWxlIENoYXIgPSBDaGFyXG5tb2R1bGUgQ29tcGFyYWJsZSA9IENvbXBhcmFibGVcbm1vZHVsZSBDb21wYXJhdG9yID0gQ29tcGFyYXRvclxubW9kdWxlIENvbXBhcmlzb25zID0gQ29tcGFyaXNvbnNcbm1vZHVsZSBDb250YWluZXIgPSBDb250YWluZXJcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXJcbm1vZHVsZSBFcXVhbCA9IEVxdWFsXG5tb2R1bGUgRXJyb3IgPSBFcnJvclxubW9kdWxlIEV4biA9IEV4blxubW9kdWxlIEZpZWxkID0gRmllbGRcbm1vZHVsZSBGbG9hdCA9IEZsb2F0XG5tb2R1bGUgRmxvYXRhYmxlID0gRmxvYXRhYmxlXG5tb2R1bGUgRm4gPSBGblxubW9kdWxlIEZvcm1hdHRlciA9IEZvcm1hdHRlclxubW9kdWxlIEhhc2ggPSBIYXNoXG5tb2R1bGUgSGFzaF9zZXQgPSBIYXNoX3NldFxubW9kdWxlIEhhc2hhYmxlID0gSGFzaGFibGVcbm1vZHVsZSBIYXNoZXIgPSBIYXNoZXJcbm1vZHVsZSBIYXNodGJsID0gSGFzaHRibFxubW9kdWxlIElkZW50aWZpYWJsZSA9IElkZW50aWZpYWJsZVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gSW5kZXhlZF9jb250YWluZXJcbm1vZHVsZSBJbmZvID0gSW5mb1xubW9kdWxlIEludCA9IEludFxubW9kdWxlIEludDMyID0gSW50MzJcbm1vZHVsZSBJbnQ2MyA9IEludDYzXG5tb2R1bGUgSW50NjQgPSBJbnQ2NFxubW9kdWxlIEludGFibGUgPSBJbnRhYmxlXG5tb2R1bGUgSW50X21hdGggPSBJbnRfbWF0aFxubW9kdWxlIEludmFyaWFudCA9IEludmFyaWFudFxubW9kdWxlIERpY3Rpb25hcnlfaW1tdXRhYmxlID0gRGljdGlvbmFyeV9pbW11dGFibGVcbm1vZHVsZSBEaWN0aW9uYXJ5X211dGFibGUgPSBEaWN0aW9uYXJ5X211dGFibGVcbm1vZHVsZSBMYXp5ID0gTGF6eVxubW9kdWxlIExpc3QgPSBMaXN0XG5tb2R1bGUgTWFwID0gTWFwXG5tb2R1bGUgTWF5YmVfYm91bmQgPSBNYXliZV9ib3VuZFxubW9kdWxlIE1vbmFkID0gTW9uYWRcbm1vZHVsZSBOYXRpdmVpbnQgPSBOYXRpdmVpbnRcbm1vZHVsZSBOb3RoaW5nID0gTm90aGluZ1xubW9kdWxlIE9wdGlvbiA9IE9wdGlvblxubW9kdWxlIE9wdGlvbl9hcnJheSA9IE9wdGlvbl9hcnJheVxubW9kdWxlIE9yX2Vycm9yID0gT3JfZXJyb3Jcbm1vZHVsZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uID0gT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vblxubW9kdWxlIE9yZGVyaW5nID0gT3JkZXJpbmdcbm1vZHVsZSBQb2x5ID0gUG9seVxubW9kdWxlIFByZXR0eV9wcmludGVyID0gUHJldHR5X3ByaW50ZXJcbm1vZHVsZSBQcmludGYgPSBQcmludGZcbm1vZHVsZSBMaW5rZWRfcXVldWUgPSBMaW5rZWRfcXVldWVcbm1vZHVsZSBRdWV1ZSA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tID0gUmFuZG9tXG5tb2R1bGUgUmVmID0gUmVmXG5tb2R1bGUgUmVzdWx0ID0gUmVzdWx0XG5tb2R1bGUgU2VxdWVuY2UgPSBTZXF1ZW5jZVxubW9kdWxlIFNldCA9IFNldFxubW9kdWxlIFNleHBhYmxlID0gU2V4cGFibGVcbm1vZHVsZSBTaWduID0gU2lnblxubW9kdWxlIFNpZ25fb3JfbmFuID0gU2lnbl9vcl9uYW5cbm1vZHVsZSBTb3VyY2VfY29kZV9wb3NpdGlvbiA9IFNvdXJjZV9jb2RlX3Bvc2l0aW9uXG5tb2R1bGUgU3RhY2sgPSBTdGFja1xubW9kdWxlIFN0YWdlZCA9IFN0YWdlZFxubW9kdWxlIFN0cmluZyA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ2FibGUgPSBTdHJpbmdhYmxlXG5tb2R1bGUgU3lzID0gU3lzXG5tb2R1bGUgVCA9IFRcbm1vZHVsZSBUeXBlX2VxdWFsID0gVHlwZV9lcXVhbFxubW9kdWxlIFVuaWZvcm1fYXJyYXkgPSBVbmlmb3JtX2FycmF5XG5tb2R1bGUgVW5pdCA9IFVuaXRcbm1vZHVsZSBVY2hhciA9IFVjaGFyXG5tb2R1bGUgVmFyaWFudCA9IFZhcmlhbnRcbm1vZHVsZSBXaXRoX3JldHVybiA9IFdpdGhfcmV0dXJuXG5tb2R1bGUgV29yZF9zaXplID0gV29yZF9zaXplXG5cbigqIEF2b2lkIGEgbGV2ZWwgb2YgaW5kaXJlY3Rpb24gZm9yIHVzZXMgb2YgdGhlIHNpZ25hdHVyZXMgZGVmaW5lZCBpbiBbVF0uICopXG5pbmNsdWRlIFRcblxuKCogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCBvZG9jIGNyZWF0ZXMgYmV0dGVyIGRvY3VtZW50YXRpb24uICopXG5tb2R1bGUgU2V4cCA9IHN0cnVjdFxuICBpbmNsdWRlIFNleHBfd2l0aF9jb21wYXJhYmxlICgqKiBAaW5saW5lICopXG5lbmRcblxuKCogW0ludF9zdHJpbmdfY29udmVyc2lvbnNdIGlzIHNlcGFyYXRlZCBmcm9tIFtJbnRfY29udmVyc2lvbnNdIGZvciBkZXBlbmRlbmN5IHJlYXNvbnMsXG4gICBidXQgdGhpcyBzZXBhcmF0aW9uIGlzIG5vdCBpbXBvcnRhbnQgZm9yIGNsaWVudHMuICopXG5tb2R1bGUgSW50X2NvbnZlcnNpb25zID0gc3RydWN0XG4gIGluY2x1ZGUgSW50X2NvbnZlcnNpb25zXG4gIGluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9uc1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzID0gc3RydWN0XG4gIG1vZHVsZSBGaWVsZHNsaWIgPSBGaWVsZHNsaWJcbiAgbW9kdWxlIEdsb2JhbGl6ZSA9IEdsb2JhbGl6ZVxuICBtb2R1bGUgT2JqX2xvY2FsID0gT2JqX2xvY2FsXG4gIG1vZHVsZSBQcHhfY29tcGFyZV9saWIgPSBQcHhfY29tcGFyZV9saWJcbiAgbW9kdWxlIFBweF9lbnVtZXJhdGVfbGliID0gUHB4X2VudW1lcmF0ZV9saWJcbiAgbW9kdWxlIFBweF9oYXNoX2xpYiA9IFBweF9oYXNoX2xpYlxuICBtb2R1bGUgVmFyaWFudHNsaWIgPSBWYXJpYW50c2xpYlxuXG4gIGxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZ1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiBbZGVyaXZpbmcgaGFzaF0gaXMgbWlzc2luZyBmb3IgW2FycmF5XSBhbmQgW3JlZl0gc2luY2UgdGhlc2UgdHlwZXMgYXJlIG11dGFibGUuICopXG4gIHR5cGUgJ2EgYXJyYXkgPSAnYSBBcnJheS50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9hcnJheV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gaW50ID1cbiAgICBBcnJheS5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGludCA9IEFycmF5LmNvbXBhcmVcblxuICBsZXQgZXF1YWxfYXJyYXlfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBib29sID1cbiAgICBBcnJheS5lcXVhbF9fbG9jYWxcbiAgOztcblxuICBsZXQgZXF1YWxfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGJvb2wgPSBBcnJheS5lcXVhbFxuXG4gIGxldCBnbG9iYWxpemVfYXJyYXkgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9XG4gICAgZnVuICh0eXBlIGFfXzAxN18pIDogKChhX18wMTdfIC0+IGFfXzAxN18pIC0+IGFfXzAxN18gYXJyYXkgLT4gYV9fMDE3XyBhcnJheSkgLT5cbiAgICBBcnJheS5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgYXJyYXlfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgYXJyYXkgPVxuICAgIEFycmF5LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2FycmF5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGFycmF5IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgQXJyYXkuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGFycmF5X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBhcnJheSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBBcnJheS50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJvb2wgPSBCb29sLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYm9vbF9fbG9jYWwgPSAoQm9vbC5jb21wYXJlX19sb2NhbCA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2Jvb2wgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2Jvb2xfX2xvY2FsIGEgYiA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBlcXVhbF9ib29sX19sb2NhbCA9IChCb29sLmVxdWFsX19sb2NhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuICBsZXQgZXF1YWxfYm9vbCA9IChmdW4gYSBiIC0+IGVxdWFsX2Jvb2xfX2xvY2FsIGEgYiA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9ib29sIDogYm9vbCAtPiBib29sKSA9IChCb29sLmdsb2JhbGl6ZSA6IGJvb2wgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9ib29sIDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBCb29sLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Jvb2wgOiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBCb29sLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYm9vbF9vZl9zZXhwID0gKEJvb2wudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJvb2wpXG4gIGxldCBzZXhwX29mX2Jvb2wgPSAoQm9vbC5zZXhwX29mX3QgOiBib29sIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQm9vbC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjaGFyID0gQ2hhci50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2NoYXJfX2xvY2FsID0gKENoYXIuY29tcGFyZV9fbG9jYWwgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgY29tcGFyZV9jaGFyID0gKGZ1biBhIGIgLT4gY29tcGFyZV9jaGFyX19sb2NhbCBhIGIgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgZXF1YWxfY2hhcl9fbG9jYWwgPSAoQ2hhci5lcXVhbF9fbG9jYWwgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcbiAgbGV0IGVxdWFsX2NoYXIgPSAoZnVuIGEgYiAtPiBlcXVhbF9jaGFyX19sb2NhbCBhIGIgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfY2hhciA6IGNoYXIgLT4gY2hhcikgPSAoQ2hhci5nbG9iYWxpemUgOiBjaGFyIC0+IGNoYXIpXG5cbiAgbGV0IChoYXNoX2ZvbGRfY2hhciA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQ2hhci5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9jaGFyIDogY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQ2hhci5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGNoYXJfb2Zfc2V4cCA9IChDaGFyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBjaGFyKVxuICBsZXQgc2V4cF9vZl9jaGFyID0gKENoYXIuc2V4cF9vZl90IDogY2hhciAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IENoYXIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZXhuID0gRXhuLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfZXhuID0gKEV4bi5zZXhwX29mX3QgOiBleG4gLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBmbG9hdCA9IEZsb2F0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfZmxvYXRfX2xvY2FsID0gKEZsb2F0LmNvbXBhcmVfX2xvY2FsIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50KVxuICBsZXQgY29tcGFyZV9mbG9hdCA9IChmdW4gYSBiIC0+IGNvbXBhcmVfZmxvYXRfX2xvY2FsIGEgYiA6IGZsb2F0IC0+IGZsb2F0IC0+IGludClcbiAgbGV0IGVxdWFsX2Zsb2F0X19sb2NhbCA9IChGbG9hdC5lcXVhbF9fbG9jYWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBib29sKVxuICBsZXQgZXF1YWxfZmxvYXQgPSAoZnVuIGEgYiAtPiBlcXVhbF9mbG9hdF9fbG9jYWwgYSBiIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCkgPSAoRmxvYXQuZ2xvYmFsaXplIDogZmxvYXQgLT4gZmxvYXQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfZmxvYXQgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBGbG9hdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9mbG9hdCA6IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBGbG9hdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGZsb2F0X29mX3NleHAgPSAoRmxvYXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGZsb2F0KVxuICBsZXQgc2V4cF9vZl9mbG9hdCA9IChGbG9hdC5zZXhwX29mX3QgOiBmbG9hdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gRmxvYXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50ID0gSW50LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50X19sb2NhbCA9IChJbnQuY29tcGFyZV9fbG9jYWwgOiBpbnQgLT4gaW50IC0+IGludClcbiAgbGV0IGNvbXBhcmVfaW50ID0gKGZ1biBhIGIgLT4gY29tcGFyZV9pbnRfX2xvY2FsIGEgYiA6IGludCAtPiBpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50X19sb2NhbCA9IChJbnQuZXF1YWxfX2xvY2FsIDogaW50IC0+IGludCAtPiBib29sKVxuICBsZXQgZXF1YWxfaW50ID0gKGZ1biBhIGIgLT4gZXF1YWxfaW50X19sb2NhbCBhIGIgOiBpbnQgLT4gaW50IC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX2ludCA6IGludCAtPiBpbnQpID0gKEludC5nbG9iYWxpemUgOiBpbnQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgSW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludCA6IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50X29mX3NleHAgPSAoSW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQpXG4gIGxldCBzZXhwX29mX2ludCA9IChJbnQuc2V4cF9vZl90IDogaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQzMiA9IEludDMyLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50MzJfX2xvY2FsID0gKEludDMyLmNvbXBhcmVfX2xvY2FsIDogaW50MzIgLT4gaW50MzIgLT4gaW50KVxuICBsZXQgY29tcGFyZV9pbnQzMiA9IChmdW4gYSBiIC0+IGNvbXBhcmVfaW50MzJfX2xvY2FsIGEgYiA6IGludDMyIC0+IGludDMyIC0+IGludClcbiAgbGV0IGVxdWFsX2ludDMyX19sb2NhbCA9IChJbnQzMi5lcXVhbF9fbG9jYWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBib29sKVxuICBsZXQgZXF1YWxfaW50MzIgPSAoZnVuIGEgYiAtPiBlcXVhbF9pbnQzMl9fbG9jYWwgYSBiIDogaW50MzIgLT4gaW50MzIgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfaW50MzIgOiBpbnQzMiAtPiBpbnQzMikgPSAoSW50MzIuZ2xvYmFsaXplIDogaW50MzIgLT4gaW50MzIpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50MzIgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQzMi5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQzMiA6IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQzMi5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDMyX29mX3NleHAgPSAoSW50MzIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDMyKVxuICBsZXQgc2V4cF9vZl9pbnQzMiA9IChJbnQzMi5zZXhwX29mX3QgOiBpbnQzMiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50MzIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50NjQgPSBJbnQ2NC50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDY0X19sb2NhbCA9IChJbnQ2NC5jb21wYXJlX19sb2NhbCA6IGludDY0IC0+IGludDY0IC0+IGludClcbiAgbGV0IGNvbXBhcmVfaW50NjQgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2ludDY0X19sb2NhbCBhIGIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQ2NF9fbG9jYWwgPSAoSW50NjQuZXF1YWxfX2xvY2FsIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbClcbiAgbGV0IGVxdWFsX2ludDY0ID0gKGZ1biBhIGIgLT4gZXF1YWxfaW50NjRfX2xvY2FsIGEgYiA6IGludDY0IC0+IGludDY0IC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX2ludDY0IDogaW50NjQgLT4gaW50NjQpID0gKEludDY0Lmdsb2JhbGl6ZSA6IGludDY0IC0+IGludDY0KVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDY0IDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50NjQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50NjQgOiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50NjQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQ2NF9vZl9zZXhwID0gKEludDY0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQ2NClcbiAgbGV0IHNleHBfb2ZfaW50NjQgPSAoSW50NjQuc2V4cF9vZl90IDogaW50NjQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDY0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIGxpc3QgPSAnYSBMaXN0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbGlzdF9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9XG4gICAgTGlzdC5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9IExpc3QuY29tcGFyZVxuXG4gIGxldCBlcXVhbF9saXN0X19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2wgPVxuICAgIExpc3QuZXF1YWxfX2xvY2FsXG4gIDs7XG5cbiAgbGV0IGVxdWFsX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBib29sID0gTGlzdC5lcXVhbFxuXG4gIGxldCBnbG9iYWxpemVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCA9XG4gICAgZnVuICh0eXBlIGFfXzA3OF8pIDogKChhX18wNzhfIC0+IGFfXzA3OF8pIC0+IGFfXzA3OF8gbGlzdCAtPiBhX18wNzhfIGxpc3QpIC0+XG4gICAgTGlzdC5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgOlxuICAgICAgICAnYS5cbiAgICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgICAtPiAnYSBsaXN0XG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBMaXN0Lmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgbGlzdCA9XG4gICAgTGlzdC50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9saXN0IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGxpc3QgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBMaXN0LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBsaXN0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBsaXN0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IExpc3QudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBuYXRpdmVpbnQgPSBOYXRpdmVpbnQudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnRfX2xvY2FsID1cbiAgICAoTmF0aXZlaW50LmNvbXBhcmVfX2xvY2FsIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50ID1cbiAgICAoZnVuIGEgYiAtPiBjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgYSBiIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGVxdWFsX25hdGl2ZWludF9fbG9jYWwgPSAoTmF0aXZlaW50LmVxdWFsX19sb2NhbCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcblxuICBsZXQgZXF1YWxfbmF0aXZlaW50ID1cbiAgICAoZnVuIGEgYiAtPiBlcXVhbF9uYXRpdmVpbnRfX2xvY2FsIGEgYiA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcbiAgOztcblxuICBsZXQgKGdsb2JhbGl6ZV9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50KSA9XG4gICAgKE5hdGl2ZWludC5nbG9iYWxpemUgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50KVxuICA7O1xuXG4gIGxldCAoaGFzaF9mb2xkX25hdGl2ZWludCA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBOYXRpdmVpbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfb2Zfc2V4cCA9IChOYXRpdmVpbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IG5hdGl2ZWludClcbiAgbGV0IHNleHBfb2ZfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5zZXhwX29mX3QgOiBuYXRpdmVpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIGxldCAobmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIE5hdGl2ZWludC50X3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBvcHRpb24gPSAnYSBPcHRpb24udFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9vcHRpb25fX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gaW50ID1cbiAgICBPcHRpb24uY29tcGFyZV9fbG9jYWxcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbl9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsX19sb2NhbFxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsXG4gIDs7XG5cbiAgbGV0IGdsb2JhbGl6ZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uID1cbiAgICBmdW4gKHR5cGUgYV9fMTA5XykgOiAoKGFfXzEwOV8gLT4gYV9fMTA5XykgLT4gYV9fMTA5XyBvcHRpb24gLT4gYV9fMTA5XyBvcHRpb24pIC0+XG4gICAgT3B0aW9uLmdsb2JhbGl6ZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIDpcbiAgICAgICAgJ2EuXG4gICAgICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgICAgLT4gJ2Egb3B0aW9uXG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBPcHRpb24uaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIG9wdGlvbiA9XG4gICAgT3B0aW9uLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX29wdGlvbiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBvcHRpb24gLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBPcHRpb24uc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2Egb3B0aW9uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IE9wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHJlZiA9ICdhIFJlZi50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9yZWZfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gaW50ID1cbiAgICBSZWYuY29tcGFyZV9fbG9jYWxcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPSBSZWYuY29tcGFyZVxuXG4gIGxldCBlcXVhbF9yZWZfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPVxuICAgIFJlZi5lcXVhbF9fbG9jYWxcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPSBSZWYuZXF1YWxcblxuICBsZXQgZ2xvYmFsaXplX3JlZiA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHJlZiAtPiAnYSByZWYgPVxuICAgIGZ1biAodHlwZSBhX18xMzRfKSA6ICgoYV9fMTM0XyAtPiBhX18xMzRfKSAtPiBhX18xMzRfIHJlZiAtPiBhX18xMzRfIHJlZikgLT5cbiAgICBSZWYuZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IHJlZl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSByZWYgPVxuICAgIFJlZi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9yZWYgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgcmVmIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgUmVmLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCByZWZfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHJlZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVmLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgc3RyaW5nID0gU3RyaW5nLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfc3RyaW5nX19sb2NhbCA9IChTdHJpbmcuY29tcGFyZV9fbG9jYWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGludClcbiAgbGV0IGNvbXBhcmVfc3RyaW5nID0gKGZ1biBhIGIgLT4gY29tcGFyZV9zdHJpbmdfX2xvY2FsIGEgYiA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgZXF1YWxfc3RyaW5nX19sb2NhbCA9IChTdHJpbmcuZXF1YWxfX2xvY2FsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sKVxuICBsZXQgZXF1YWxfc3RyaW5nID0gKGZ1biBhIGIgLT4gZXF1YWxfc3RyaW5nX19sb2NhbCBhIGIgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX3N0cmluZyA6IHN0cmluZyAtPiBzdHJpbmcpID0gKFN0cmluZy5nbG9iYWxpemUgOiBzdHJpbmcgLT4gc3RyaW5nKVxuXG4gIGxldCAoaGFzaF9mb2xkX3N0cmluZyA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBTdHJpbmcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfc3RyaW5nIDogc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBTdHJpbmcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzdHJpbmdfb2Zfc2V4cCA9IChTdHJpbmcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0cmluZylcbiAgbGV0IHNleHBfb2Zfc3RyaW5nID0gKFN0cmluZy5zZXhwX29mX3QgOiBzdHJpbmcgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJ5dGVzID0gQnl0ZXMudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYnl0ZXNfX2xvY2FsID0gKEJ5dGVzLmNvbXBhcmVfX2xvY2FsIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50KVxuICBsZXQgY29tcGFyZV9ieXRlcyA9IChmdW4gYSBiIC0+IGNvbXBhcmVfYnl0ZXNfX2xvY2FsIGEgYiA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGludClcbiAgbGV0IGVxdWFsX2J5dGVzX19sb2NhbCA9IChCeXRlcy5lcXVhbF9fbG9jYWwgOiBieXRlcyAtPiBieXRlcyAtPiBib29sKVxuICBsZXQgZXF1YWxfYnl0ZXMgPSAoZnVuIGEgYiAtPiBlcXVhbF9ieXRlc19fbG9jYWwgYSBiIDogYnl0ZXMgLT4gYnl0ZXMgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfYnl0ZXMgOiBieXRlcyAtPiBieXRlcykgPSAoQnl0ZXMuZ2xvYmFsaXplIDogYnl0ZXMgLT4gYnl0ZXMpXG4gIGxldCBieXRlc19vZl9zZXhwID0gKEJ5dGVzLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBieXRlcylcbiAgbGV0IHNleHBfb2ZfYnl0ZXMgPSAoQnl0ZXMuc2V4cF9vZl90IDogYnl0ZXMgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJ5dGVzLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHVuaXQgPSBVbml0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfdW5pdF9fbG9jYWwgPSAoVW5pdC5jb21wYXJlX19sb2NhbCA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlX3VuaXQgPSAoZnVuIGEgYiAtPiBjb21wYXJlX3VuaXRfX2xvY2FsIGEgYiA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBlcXVhbF91bml0X19sb2NhbCA9IChVbml0LmVxdWFsX19sb2NhbCA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuICBsZXQgZXF1YWxfdW5pdCA9IChmdW4gYSBiIC0+IGVxdWFsX3VuaXRfX2xvY2FsIGEgYiA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV91bml0IDogdW5pdCAtPiB1bml0KSA9IChVbml0Lmdsb2JhbGl6ZSA6IHVuaXQgLT4gdW5pdClcblxuICBsZXQgKGhhc2hfZm9sZF91bml0IDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBVbml0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3VuaXQgOiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBVbml0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdW5pdF9vZl9zZXhwID0gKFVuaXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHVuaXQpXG4gIGxldCBzZXhwX29mX3VuaXQgPSAoVW5pdC5zZXhwX29mX3QgOiB1bml0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVW5pdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIEZvcm1hdCBzdHVmZiAqKVxuXG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG5cbiAgKCoqIExpc3Qgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBMaXN0LkluZml4XG5cbiAgKCoqIEludCBvcGVyYXRvcnMgYW5kIGNvbXBhcmlzb25zICopXG5cbiAgaW5jbHVkZSBJbnQuT1xuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAoKiogRmxvYXQgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBGbG9hdC5PX2RvdFxuXG4gICgqIFRoaXMgaXMgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gYmUgb3B0aW1pemVkIGF3YXkgaW4gbW9yZSBjb250ZXh0cy4gKilcblxuICAoKiogUmV2ZXJzZSBhcHBsaWNhdGlvbiBvcGVyYXRvci4gW3ggfD4gZyB8PiBmXSBpcyBlcXVpdmFsZW50IHRvIFtmIChnICh4KSldLiAqKVxuICBleHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoKCdhIC0+ICdiKVtAbG9jYWxfb3B0XSkgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbiAgKCoqIEFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbZyBAQCBmIEBAIHhdIGlzIGVxdWl2YWxlbnQgdG8gW2cgKGYgKHgpKV0uICopXG4gIGV4dGVybmFsICggQEAgKSA6ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuICAoKiogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbiAgKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbiAgZXh0ZXJuYWwgKCAmJiApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIGV4dGVybmFsICggfHwgKSA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIGV4dGVybmFsIG5vdCA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5cbiAgKCogVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseS4gKilcbiAgZXh0ZXJuYWwgaWdub3JlIDogKF9bQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4gICgqKiBDb21tb24gc3RyaW5nIG9wZXJhdGlvbnMgKilcbiAgbGV0ICggXiApID0gU3RyaW5nLiggXiApXG5cbiAgKCoqIFJlZmVyZW5jZSBvcGVyYXRpb25zICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlIGFuZFxuICAgICB0byBrZWVwIHJlZmVyZW5jZSB1bmJveGluZyB3b3JraW5nICopXG4gIGV4dGVybmFsICggISApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuICBleHRlcm5hbCByZWYgOiAnYSAtPiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSA9IFwiJW1ha2VtdXRhYmxlXCJcbiAgZXh0ZXJuYWwgKCA6PSApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbiAgKCoqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBmc3QgPSBmc3RcbiAgbGV0IHNuZCA9IHNuZFxuXG4gICgqKiBFeGNlcHRpb25zIHN0dWZmICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgbWF5IHJld3JpdGUgJyVyYWlzZScgYXMgJyVyZXJhaXNlJy4gKilcbiAgZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxuICBsZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuICBsZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICAoKiogTWlzYyAqKVxuXG4gIGV4dGVybmFsIHBoeXNfZXF1YWwgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxXCJcbiAgZXh0ZXJuYWwgZm9yY2UgOiAoJ2EgTGF6eS50W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbmluY2x1ZGUgQ29udGFpbmVyX2ludGYuRXhwb3J0ICgqKiBAaW5saW5lICopXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyA9IE5vdF9mb3VuZF9zXG5cbigqIFdlIHBlcmZvcm0gdGhlc2Ugc2lkZSBlZmZlY3RzIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZW0gdG8gcnVuIGZvciBhbnkgY29kZSB0aGF0IHVzZXNcbiAgIFtCYXNlXS4gIElmIHRoaXMgd2VyZSBpbiBhbm90aGVyIG1vZHVsZSBpbiBbQmFzZV0gdGhhdCB3YXMgbm90IHVzZWQgaW4gc29tZSBwcm9ncmFtLFxuICAgdGhlbiB0aGUgc2lkZSBlZmZlY3RzIG1pZ2h0IG5vdCBiZSBydW4gaW4gdGhhdCBwcm9ncmFtLiAgVGhpcyB3aWxsIHJ1biBhcyBsb25nIGFzIHRoZVxuICAgcHJvZ3JhbSByZWZlcnMgdG8gYXQgbGVhc3Qgb25lIHZhbHVlIGRpcmVjdGx5IGluIFtCYXNlXTsgcmVmZXJyaW5nIHRvIHZhbHVlcyBpblxuICAgW0Jhc2UuQm9vbF0sIGZvciBleGFtcGxlLCBpcyBub3Qgc3VmZmljaWVudC4gKilcbmxldCAoKSA9IEJhY2t0cmFjZS5pbml0aWFsaXplX21vZHVsZSAoKVxuXG5tb2R1bGUgQ2FtbCA9IHN0cnVjdCBlbmQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIzLTAxXSB1c2UgU3RkbGliIGluc3RlYWQgb2YgQ2FtbFwiXVxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1JlZiIsIkJhc2VfT3B0aW9uIiwiQmFzZV9MaXN0IiwiQmFzZV9BcnJheSIsIlNoYWRvd19zdGRsaWIiLCJCYXNlX1NleHBfd2l0aF9jb21wYXJhYmxlIiwiQmFzZV9JbnRfY29udmVyc2lvbnMiLCJCYXNlX0ludF9zdHJpbmdfY29udmVyc2lvbnMiLCJCYXNlX0ltcG9ydCIsIkJhc2VfQm9vbCIsIkJhc2VfQ2hhciIsIkJhc2VfRXhuIiwiQmFzZV9GbG9hdCIsIkJhc2VfSW50IiwiQmFzZV9JbnQzMiIsIkJhc2VfSW50NjQiLCJCYXNlX05hdGl2ZWludCIsIkJhc2VfU3RyaW5nIiwiQmFzZV9CeXRlcyIsIkJhc2VfVW5pdCIsIkJhc2VfRXJyb3IiLCJCYXNlX0NvbnRhaW5lcl9pbnRmIiwiQmFzZV9CYWNrdHJhY2UiLCJFeGl0IiwiTm90X2ZvdW5kIiwibWF4X2ludCIsIm1pbl9pbnQiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYm9vbF9vZl9zdHJpbmdfb3B0IiwiYm9vbF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50X29wdCIsInJlYWRfaW50IiwicmVhZF9mbG9hdF9vcHQiLCJyZWFkX2Zsb2F0Iiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJvcGVuX291dF9nZW4iLCJmbHVzaCIsImZsdXNoX2FsbCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X3ZhbHVlIiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dCIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJjbG9zZV9pbl9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9pbiIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJleGl0IiwiYXRfZXhpdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsImRvX2F0X2V4aXQiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImdsb2JhbGl6ZSIsImhhc2hfZm9sZF90IiwiaGFzaCIsInRfb2Zfc2V4cCIsInNleHBfb2ZfdCIsIk5vdF9mb3VuZF9zIiwiT2Zfc2V4cF9lcnJvciIsIm1lc3NhZ2UiLCJkZWZhdWx0X2luZGVudCIsInBwX2h1bSIsInBwX2h1bV9pbmRlbnQiLCJwcF9tYWNoIiwicHAiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJ0b19zdHJpbmciLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsInRfc2V4cF9ncmFtbWFyIiwiaW52YXJpYW50Iiwib2Zfc3RyaW5nIiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJjb21wYXJlX2xvY2FsIiwiZXF1YWxfbG9jYWwiLCJTZXhwIiwiaW50X3RvX2ludDMyIiwiaW50X3RvX2ludDMyX2V4biIsImludF90b19pbnQzMl90cnVuYyIsImludF90b19pbnQ2NCIsImludF90b19uYXRpdmVpbnQiLCJpbnQzMl90b19pbnQiLCJpbnQzMl90b19pbnRfZXhuIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50MzJfdG9faW50NjQiLCJpbnQzMl90b19uYXRpdmVpbnQiLCJpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCIsImludDY0X3RvX2ludCIsImludDY0X3RvX2ludF9leG4iLCJpbnQ2NF90b19pbnRfdHJ1bmMiLCJpbnQ2NF90b19pbnQzMiIsImludDY0X3RvX2ludDMyX2V4biIsImludDY0X3RvX2ludDMyX3RydW5jIiwiaW50NjRfdG9fbmF0aXZlaW50IiwiaW50NjRfdG9fbmF0aXZlaW50X2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsImludDY0X2ZpdF9vbl9pbnQ2M19leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJuYXRpdmVpbnRfdG9faW50IiwibmF0aXZlaW50X3RvX2ludF9leG4iLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsIm5hdGl2ZWludF90b19pbnQzMl90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsIm51bV9iaXRzX2ludCIsIm51bV9iaXRzX2ludDMyIiwibnVtX2JpdHNfaW50NjQiLCJudW1fYml0c19uYXRpdmVpbnQiLCJNYWtlIiwiTWFrZV9oZXgiLCJNYWtlX2JpbmFyeSIsInNleHBfb2ZfaW50X3N0eWxlIiwiaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJJbnRfY29udmVyc2lvbnMiLCJhbV90ZXN0aW5nIiwiRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMiLCJjb21wYXJlX2FycmF5X2xvY2FsIiwiY29tcGFyZV9hcnJheSIsImVxdWFsX2FycmF5X2xvY2FsIiwiZXF1YWxfYXJyYXkiLCJnbG9iYWxpemVfYXJyYXkiLCJhcnJheV9vZl9zZXhwIiwic2V4cF9vZl9hcnJheSIsImFycmF5X3NleHBfZ3JhbW1hciIsImFfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9ib29sX2xvY2FsIiwiY29tcGFyZV9ib29sIiwiYSIsImIiLCJlcXVhbF9ib29sX2xvY2FsIiwiZXF1YWxfYm9vbCIsImdsb2JhbGl6ZV9ib29sIiwiaGFzaF9mb2xkX2Jvb2wiLCJmdW5jIiwiaGFzaF9ib29sIiwieCIsImJvb2xfb2Zfc2V4cCIsInNleHBfb2ZfYm9vbCIsImJvb2xfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9jaGFyX2xvY2FsIiwiY29tcGFyZV9jaGFyIiwiZXF1YWxfY2hhcl9sb2NhbCIsImVxdWFsX2NoYXIiLCJnbG9iYWxpemVfY2hhciIsImhhc2hfZm9sZF9jaGFyIiwiaGFzaF9jaGFyIiwiY2hhcl9vZl9zZXhwIiwic2V4cF9vZl9jaGFyIiwiY2hhcl9zZXhwX2dyYW1tYXIiLCJzZXhwX29mX2V4biIsImNvbXBhcmVfZmxvYXRfbG9jYWwiLCJjb21wYXJlX2Zsb2F0IiwiZXF1YWxfZmxvYXRfbG9jYWwiLCJlcXVhbF9mbG9hdCIsImdsb2JhbGl6ZV9mbG9hdCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZmxvYXQiLCJmbG9hdF9vZl9zZXhwIiwic2V4cF9vZl9mbG9hdCIsImZsb2F0X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfaW50X2xvY2FsIiwiY29tcGFyZV9pbnQiLCJlcXVhbF9pbnRfbG9jYWwiLCJlcXVhbF9pbnQiLCJnbG9iYWxpemVfaW50IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfaW50IiwiaW50X29mX3NleHAiLCJzZXhwX29mX2ludCIsImludF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2ludDMyX2xvY2FsIiwiY29tcGFyZV9pbnQzMiIsImVxdWFsX2ludDMyX2xvY2FsIiwiZXF1YWxfaW50MzIiLCJnbG9iYWxpemVfaW50MzIiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ludDMyIiwiaW50MzJfb2Zfc2V4cCIsInNleHBfb2ZfaW50MzIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2ludDY0X2xvY2FsIiwiY29tcGFyZV9pbnQ2NCIsImVxdWFsX2ludDY0X2xvY2FsIiwiZXF1YWxfaW50NjQiLCJnbG9iYWxpemVfaW50NjQiLCJoYXNoX2ZvbGRfaW50NjQiLCJoYXNoX2ludDY0IiwiaW50NjRfb2Zfc2V4cCIsInNleHBfb2ZfaW50NjQiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2xpc3RfbG9jYWwiLCJjb21wYXJlX2xpc3QiLCJlcXVhbF9saXN0X2xvY2FsIiwiZXF1YWxfbGlzdCIsImdsb2JhbGl6ZV9saXN0IiwiaGFzaF9mb2xkX2xpc3QiLCJsaXN0X29mX3NleHAiLCJzZXhwX29mX2xpc3QiLCJsaXN0X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbmF0aXZlaW50X2xvY2FsIiwiY29tcGFyZV9uYXRpdmVpbnQiLCJlcXVhbF9uYXRpdmVpbnRfbG9jYWwiLCJlcXVhbF9uYXRpdmVpbnQiLCJnbG9iYWxpemVfbmF0aXZlaW50IiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfbmF0aXZlaW50IiwibmF0aXZlaW50X29mX3NleHAiLCJzZXhwX29mX25hdGl2ZWludCIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX29wdGlvbl9sb2NhbCIsImNvbXBhcmVfb3B0aW9uIiwiZXF1YWxfb3B0aW9uX2xvY2FsIiwiZXF1YWxfb3B0aW9uIiwiZ2xvYmFsaXplX29wdGlvbiIsImhhc2hfZm9sZF9vcHRpb24iLCJvcHRpb25fb2Zfc2V4cCIsInNleHBfb2Zfb3B0aW9uIiwib3B0aW9uX3NleHBfZ3JhbW1hciIsImNvbXBhcmVfcmVmX2xvY2FsIiwiY29tcGFyZV9yZWYiLCJlcXVhbF9yZWZfbG9jYWwiLCJlcXVhbF9yZWYiLCJnbG9iYWxpemVfcmVmIiwicmVmX29mX3NleHAiLCJzZXhwX29mX3JlZiIsInJlZl9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX3N0cmluZ19sb2NhbCIsImNvbXBhcmVfc3RyaW5nIiwiZXF1YWxfc3RyaW5nX2xvY2FsIiwiZXF1YWxfc3RyaW5nIiwiZ2xvYmFsaXplX3N0cmluZyIsImhhc2hfZm9sZF9zdHJpbmciLCJoYXNoX3N0cmluZyIsInN0cmluZ19vZl9zZXhwIiwic2V4cF9vZl9zdHJpbmciLCJzdHJpbmdfc2V4cF9ncmFtbWFyIiwiY29tcGFyZV9ieXRlc19sb2NhbCIsImNvbXBhcmVfYnl0ZXMiLCJlcXVhbF9ieXRlc19sb2NhbCIsImVxdWFsX2J5dGVzIiwiZ2xvYmFsaXplX2J5dGVzIiwiYnl0ZXNfb2Zfc2V4cCIsInNleHBfb2ZfYnl0ZXMiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjb21wYXJlX3VuaXRfbG9jYWwiLCJjb21wYXJlX3VuaXQiLCJlcXVhbF91bml0X2xvY2FsIiwiZXF1YWxfdW5pdCIsImdsb2JhbGl6ZV91bml0IiwiaGFzaF9mb2xkX3VuaXQiLCJoYXNoX3VuaXQiLCJ1bml0X29mX3NleHAiLCJzZXhwX29mX3VuaXQiLCJ1bml0X3NleHBfZ3JhbW1hciIsImxub3QiLCJhYnMiLCJ6ZXJvIiwiaW5jbHVkZSIsInN5bWJvbF9jb25jYXQiLCJmc3QiLCJzbmQiLCJmYWlsd2l0aCIsImludmFsaWRfYXJnIiwicmFpc2VfcyIsIkV4cG9ydCIsIkNvbnRpbnVlX29yX3N0b3AiLCJDYW1sIiwiQmFzZSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBM0IsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQUEsV0FBQTtBQUFBLElBQUFBLFdBQUE7QUFBQSxJQUFBQSxXQUFBO0FBQUEsSUFBQTRCLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxnQ0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtB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QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFrTyxnQkFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBUCxZQUFBO0FBQUEsSUFBQVEsbUJBQUE7QUFBQSxJQUFBN04sZ0JBQUE7QUFBQSxHQXdGSztBQUFBO0FBQUEsSUFBQThOLE9BQThCO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHJzQnZDIiwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
