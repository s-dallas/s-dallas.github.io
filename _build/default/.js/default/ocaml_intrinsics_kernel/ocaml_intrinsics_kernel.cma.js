// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Ocaml_intrinsics_kernel
//# shape: Ocaml_intrinsics_kernel:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ocaml_intrinsics_kernel = [0];
   runtime.caml_register_global
    (0, Ocaml_intrinsics_kernel, "Ocaml_intrinsics_kernel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Common
//# unitInfo: Requires: Stdlib__Sys
//# shape: Ocaml_intrinsics_kernel__Common:[N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Sys = global_data.Stdlib__Sys,
    match = Stdlib_Sys[5];
   a:
   {
    if(typeof match === "number" && ! match){var available = Stdlib_Sys[6]; break a;
    }
    var available = 0;
   }
   var Ocaml_intrinsics_kernel_Common = [0, available];
   runtime.caml_register_global
    (1, Ocaml_intrinsics_kernel_Common, "Ocaml_intrinsics_kernel__Common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Naive_ints
//# shape: Ocaml_intrinsics_kernel__Naive_ints:[F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    a = [0, "src/naive_ints.ml", 23, 9],
    Ocaml_intrinsics_kernel_Naive_ =
      [0,
       function(Int){
        function is_least_significant_bit_set(n){
         var lsb = caml_call2(Int[1], n, Int[3]);
         if(caml_call2(Int[4], lsb, Int[3])) return 1;
         if(caml_call2(Int[4], lsb, Int[2])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
        }
        function count_trailing_zeros(mask){
         if(caml_call2(Int[4], mask, Int[2])) return Int[8];
         var acc = 0, mask$0 = mask;
         for(;;){
          if(is_least_significant_bit_set(mask$0)) return acc;
          var mask$1 = caml_call2(Int[6], mask$0, 1), acc$0 = acc + 1 | 0;
          acc = acc$0;
          mask$0 = mask$1;
         }
        }
        function count_leading_zeros(mask){
         if(caml_call2(Int[4], mask, Int[2])) return Int[8];
         var acc = 0, mask$0 = mask;
         for(;;){
          var a = 0 <= caml_call2(Int[5], mask$0, Int[2]) ? 0 : 1;
          if(a) return acc;
          var mask$1 = caml_call2(Int[7], mask$0, 1), acc$0 = acc + 1 | 0;
          acc = acc$0;
          mask$0 = mask$1;
         }
        }
        function count_set_bits(mask){
         var acc = 0, mask$0 = mask;
         for(;;){
          if(caml_call2(Int[4], mask$0, Int[2])) return acc;
          var
           acc$0 = is_least_significant_bit_set(mask$0) ? acc + 1 | 0 : acc,
           mask$1 = caml_call2(Int[6], mask$0, 1);
          acc = acc$0;
          mask$0 = mask$1;
         }
        }
        return [0, count_leading_zeros, count_set_bits, count_trailing_zeros];
       }];
   runtime.caml_register_global
    (2, Ocaml_intrinsics_kernel_Naive_, "Ocaml_intrinsics_kernel__Naive_ints");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Nativeint
//# unitInfo: Requires: Ocaml_intrinsics_kernel__Common, Ocaml_intrinsics_kernel__Naive_ints, Stdlib__Nativeint, Stdlib__Sys
//# shape: Ocaml_intrinsics_kernel__Nativeint:[F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ocaml_intrinsics_kernel_Common =
      global_data.Ocaml_intrinsics_kernel__Common,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Ocaml_intrinsics_kernel_Naive_ =
      global_data.Ocaml_intrinsics_kernel__Naive_ints,
    available = Ocaml_intrinsics_kernel_Common[1],
    zero = Stdlib_Nativeint[1],
    one = Stdlib_Nativeint[2],
    compare = Stdlib_Nativeint[16],
    equal = Stdlib_Nativeint[18],
    bitwidth = Stdlib_Sys[9],
    Naive =
      Ocaml_intrinsics_kernel_Naive_[1].call
       (null,
        [0,
         function(b, a){return b & a;},
         zero,
         one,
         equal,
         compare,
         function(b, a){return b >>> a | 0;},
         function(b, a){return b << a;},
         bitwidth]);
   function count_leading_zeros(n){
    return available ? runtime.caml_nativeint_clz(n) : caml_call1(Naive[1], n);
   }
   function count_leading_zeros_nonzero_ar(n){
    return available ? runtime.caml_nativeint_clz(n) : caml_call1(Naive[1], n);
   }
   function count_trailing_zeros(n){
    return available ? runtime.caml_nativeint_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_trailing_zeros_nonzero_a(n){
    return available ? runtime.caml_nativeint_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_set_bits(n){
    return available
            ? runtime.caml_nativeint_popcnt(n)
            : caml_call1(Naive[2], n);
   }
   var
    Ocaml_intrinsics_kernel_Native =
      [0,
       count_leading_zeros,
       count_leading_zeros_nonzero_ar,
       count_trailing_zeros,
       count_trailing_zeros_nonzero_a,
       count_set_bits];
   runtime.caml_register_global
    (4, Ocaml_intrinsics_kernel_Native, "Ocaml_intrinsics_kernel__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Int64
//# unitInfo: Requires: Ocaml_intrinsics_kernel__Common, Ocaml_intrinsics_kernel__Naive_ints, Stdlib__Int64
//# shape: Ocaml_intrinsics_kernel__Int64:[F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ocaml_intrinsics_kernel_Common =
      global_data.Ocaml_intrinsics_kernel__Common,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Ocaml_intrinsics_kernel_Naive_ =
      global_data.Ocaml_intrinsics_kernel__Naive_ints,
    available = Ocaml_intrinsics_kernel_Common[1],
    zero = Stdlib_Int64[1],
    one = Stdlib_Int64[2],
    compare = Stdlib_Int64[15],
    equal = Stdlib_Int64[17],
    Naive =
      Ocaml_intrinsics_kernel_Naive_[1].call
       (null,
        [0,
         runtime.caml_int64_and,
         zero,
         one,
         equal,
         compare,
         runtime.caml_int64_shift_right_unsigned,
         runtime.caml_int64_shift_left,
         64]);
   function count_leading_zeros(n){
    return available ? runtime.caml_int64_clz(n) : caml_call1(Naive[1], n);
   }
   function count_leading_zeros_nonzero_ar(n){
    return available ? runtime.caml_int64_clz(n) : caml_call1(Naive[1], n);
   }
   function count_trailing_zeros(n){
    return available ? runtime.caml_int64_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_trailing_zeros_nonzero_a(n){
    return available ? runtime.caml_int64_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_set_bits(n){
    return available ? runtime.caml_int64_popcnt(n) : caml_call1(Naive[2], n);
   }
   var
    Ocaml_intrinsics_kernel_Int64 =
      [0,
       count_leading_zeros,
       count_leading_zeros_nonzero_ar,
       count_trailing_zeros,
       count_trailing_zeros_nonzero_a,
       count_set_bits];
   runtime.caml_register_global
    (3, Ocaml_intrinsics_kernel_Int64, "Ocaml_intrinsics_kernel__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Int32
//# unitInfo: Requires: Ocaml_intrinsics_kernel__Common, Ocaml_intrinsics_kernel__Naive_ints, Stdlib__Int32
//# shape: Ocaml_intrinsics_kernel__Int32:[F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ocaml_intrinsics_kernel_Common =
      global_data.Ocaml_intrinsics_kernel__Common,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Ocaml_intrinsics_kernel_Naive_ =
      global_data.Ocaml_intrinsics_kernel__Naive_ints,
    available = Ocaml_intrinsics_kernel_Common[1],
    zero = Stdlib_Int32[1],
    one = Stdlib_Int32[2],
    compare = Stdlib_Int32[15],
    equal = Stdlib_Int32[17],
    Naive =
      Ocaml_intrinsics_kernel_Naive_[1].call
       (null,
        [0,
         function(b, a){return b & a;},
         zero,
         one,
         equal,
         compare,
         function(b, a){return b >>> a | 0;},
         function(b, a){return b << a;},
         32]);
   function count_leading_zeros(n){
    return available ? runtime.caml_int32_clz(n) : caml_call1(Naive[1], n);
   }
   function count_leading_zeros_nonzero_ar(n){
    return available ? runtime.caml_int32_clz(n) : caml_call1(Naive[1], n);
   }
   function count_trailing_zeros(n){
    return available ? runtime.caml_int32_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_trailing_zeros_nonzero_a(n){
    return available ? runtime.caml_int32_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_set_bits(n){
    return available ? runtime.caml_int32_popcnt(n) : caml_call1(Naive[2], n);
   }
   var
    Ocaml_intrinsics_kernel_Int32 =
      [0,
       count_leading_zeros,
       count_leading_zeros_nonzero_ar,
       count_trailing_zeros,
       count_trailing_zeros_nonzero_a,
       count_set_bits];
   runtime.caml_register_global
    (3, Ocaml_intrinsics_kernel_Int32, "Ocaml_intrinsics_kernel__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Int
//# unitInfo: Requires: Ocaml_intrinsics_kernel__Common, Ocaml_intrinsics_kernel__Naive_ints, Stdlib__Int, Stdlib__Sys
//# shape: Ocaml_intrinsics_kernel__Int:[F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ocaml_intrinsics_kernel_Common =
      global_data.Ocaml_intrinsics_kernel__Common,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Ocaml_intrinsics_kernel_Naive_ =
      global_data.Ocaml_intrinsics_kernel__Naive_ints,
    available = Ocaml_intrinsics_kernel_Common[1],
    zero = Stdlib_Int[1],
    one = Stdlib_Int[2],
    equal = Stdlib_Int[8],
    compare = Stdlib_Int[9],
    bitwidth = Stdlib_Sys[10],
    Naive =
      Ocaml_intrinsics_kernel_Naive_[1].call
       (null,
        [0,
         function(b, a){return b & a;},
         zero,
         one,
         equal,
         compare,
         function(b, a){return b >>> a | 0;},
         function(b, a){return b << a;},
         bitwidth]);
   function count_leading_zeros(n){
    return available ? runtime.caml_int_clz(n) : caml_call1(Naive[1], n);
   }
   function count_leading_zeros2(n){
    return available ? runtime.caml_int_clz(n) : caml_call1(Naive[1], n);
   }
   function count_set_bits2(n){
    return available ? runtime.caml_int_popcnt(n) : caml_call1(Naive[2], n);
   }
   function count_trailing_zeros(n){
    return available ? runtime.caml_int_ctz(n) : caml_call1(Naive[3], n);
   }
   function count_set_bits(n){
    return available ? runtime.caml_int_popcnt(n) : caml_call1(Naive[2], n);
   }
   var
    Ocaml_intrinsics_kernel_Int =
      [0,
       count_leading_zeros,
       count_leading_zeros2,
       count_set_bits,
       count_set_bits2,
       count_trailing_zeros];
   runtime.caml_register_global
    (4, Ocaml_intrinsics_kernel_Int, "Ocaml_intrinsics_kernel__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Float
//# shape: Ocaml_intrinsics_kernel__Float:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ocaml_intrinsics_kernel_Float = [0];
   runtime.caml_register_global
    (0, Ocaml_intrinsics_kernel_Float, "Ocaml_intrinsics_kernel__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ocaml_intrinsics_kernel__Conditional
//# shape: Ocaml_intrinsics_kernel__Conditional:[]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ocaml_intrinsics_kernel_Condit = [0];
   runtime.caml_register_global
    (0,
     Ocaml_intrinsics_kernel_Condit,
     "Ocaml_intrinsics_kernel__Conditional");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NhbWxfaW50cmluc2ljc19rZXJuZWwuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Im9jYW1sX2ludHJpbnNpY3Nfa2VybmVsLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsMEJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJvY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL29jYW1sX2ludHJpbnNpY3Nfa2VybmVsL2NvbW1vbi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsImxldCBhdmFpbGFibGUgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBOYXRpdmUgLT5cbiAgICAoKiAobWF0Y2ggU3lzLnVuaXggd2l0aFxuICAgICAqICB8IGZhbHNlIC0+IGZhbHNlXG4gICAgICogIHwgdHJ1ZSAtPlxuICAgICAqICAgIChtYXRjaCBTeXMuYXJjaGl0ZWN0dXJlIHdpdGhcbiAgICAgKiAgICAgfCBcImFtZDY0XCIgfCBcImFybTY0XCIgLT4gdHJ1ZVxuICAgICAqICAgICB8IF8gLT4gZmFsc2UpKSAqKVxuICAgIFN5cy51bml4XG4gIHwgQnl0ZWNvZGUgfCBPdGhlciBfIC0+IGZhbHNlXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TeXMiLCJtYXRjaCIsImF2YWlsYWJsZSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX0NvbW1vbiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQTtBQUFBO0FBQUEsaURBQUFDLFlDU0k7QUFBQTtBQUFBLFFBQUFBLFlBQ3NCO0FBQUE7QUFBQSxPQUFBQyxpQ0RWMUIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJvY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL29jYW1sX2ludHJpbnNpY3Nfa2VybmVsL25haXZlX2ludHMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgdHlwZSBJbnRsaWtlID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBsb2dhbmQgOiB0IC0+IHQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIG9uZSA6IHRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfbGVmdCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIGJpdHdpZHRoIDogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEludCA6IEludGxpa2UpID0gc3RydWN0XG4gIGxldCBsZWFzdF9zaWduaWZpY2FudF9iaXQgbiA9IEludC5sb2dhbmQgbiBJbnQub25lXG5cbiAgbGV0IGlzX2xlYXN0X3NpZ25pZmljYW50X2JpdF9zZXQgbiA9XG4gICAgbGV0IGxzYiA9IGxlYXN0X3NpZ25pZmljYW50X2JpdCBuIGluXG4gICAgaWYgSW50LmVxdWFsIGxzYiBJbnQub25lXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBJbnQuZXF1YWwgbHNiIEludC56ZXJvXG4gICAgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX21vc3Rfc2lnbmlmaWNhbnRfYml0X3NldCBuID0gaWYgSW50LmNvbXBhcmUgbiBJbnQuemVybyA8IDAgdGhlbiB0cnVlIGVsc2UgZmFsc2VcblxuICBsZXQgY291bnRfdHJhaWxpbmdfemVyb3MgbiA9XG4gICAgbGV0IHJlYyBsb29wIH5hY2Mgfm1hc2sgPVxuICAgICAgaWYgaXNfbGVhc3Rfc2lnbmlmaWNhbnRfYml0X3NldCBtYXNrXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBtYXNrID0gSW50LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbWFzayAxIGluXG4gICAgICAgIGxldCBhY2MgPSBhY2MgKyAxIGluXG4gICAgICAgIGxvb3Agfm1hc2sgfmFjYylcbiAgICBpblxuICAgIGlmIEludC5lcXVhbCBuIEludC56ZXJvIHRoZW4gSW50LmJpdHdpZHRoIGVsc2UgbG9vcCB+YWNjOjAgfm1hc2s6blxuICA7O1xuXG4gIGxldCBjb3VudF9sZWFkaW5nX3plcm9zIG4gPVxuICAgIGxldCByZWMgbG9vcCB+YWNjIH5tYXNrID1cbiAgICAgIGlmIGlzX21vc3Rfc2lnbmlmaWNhbnRfYml0X3NldCBtYXNrXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBtYXNrID0gSW50LnNoaWZ0X2xlZnQgbWFzayAxIGluXG4gICAgICAgIGxldCBhY2MgPSBhY2MgKyAxIGluXG4gICAgICAgIGxvb3Agfm1hc2sgfmFjYylcbiAgICBpblxuICAgIGlmIEludC5lcXVhbCBuIEludC56ZXJvIHRoZW4gSW50LmJpdHdpZHRoIGVsc2UgbG9vcCB+YWNjOjAgfm1hc2s6blxuICA7O1xuXG4gIGxldCBjb3VudF9zZXRfYml0cyBuID1cbiAgICBsZXQgcmVjIGxvb3AgfmFjYyB+bWFzayA9XG4gICAgICBpZiBJbnQuZXF1YWwgbWFzayBJbnQuemVyb1xuICAgICAgdGhlbiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYWNjID0gaWYgaXNfbGVhc3Rfc2lnbmlmaWNhbnRfYml0X3NldCBtYXNrIHRoZW4gYWNjICsgMSBlbHNlIGFjYyBpblxuICAgICAgICBsZXQgbWFzayA9IEludC5zaGlmdF9yaWdodF9sb2dpY2FsIG1hc2sgMSBpblxuICAgICAgICBsb29wIH5tYXNrIH5hY2MpXG4gICAgaW5cbiAgICBsb29wIH5hY2M6MCB+bWFzazpuXG4gIDs7XG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX05haXZlXyIsIkludCIsImlzX2xlYXN0X3NpZ25pZmljYW50X2JpdF9zZXQiLCJuIiwibHNiIiwiY291bnRfdHJhaWxpbmdfemVyb3MiLCJtYXNrIiwiYWNjIiwiY291bnRfbGVhZGluZ196ZXJvcyIsImNvdW50X3NldF9iaXRzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLGlCQUFBQyw2QkFBQUM7QUFBQUEsYUFBQUMsTUNjZ0M7QUFBQSxTQUl6QixvQ0FDRTtBQUFBLFNBQ0csb0NBQ0g7QUFBQSxTQUNBO0FBQUEsUUFBWTtBQUFBLGlCQUFBQyxxQkFBQUM7QUFBQUEsU0FjZCxxQ0FBMEI7QUFBQSxhQUFBQyxNQUFrQixHQUFBRCxTQUFBO0FBQUE7QUFBQSxVQVAxQyx5Q0FDRTtBQUFBLGNBQUFBLFNBRVEsK0JBQUFDLFFBQ1g7QUFBQSxVQUNBO0FBQUE7QUFBQTtBQUFBLFFBRThEO0FBQUEsaUJBQUFDLG9CQUFBRjtBQUFBQSxTQVkvRCxxQ0FBMEI7QUFBQSxhQUFBQyxNQUFrQixHQUFBRCxTQUFBO0FBQUE7QUFBQSxrQkF2QlY7QUFBQSxVQWdCQSxNQUM5QjtBQUFBLGNBQUFBLFNBRVEsK0JBQUFDLFFBQ1g7QUFBQSxVQUNBO0FBQUE7QUFBQTtBQUFBLFFBRThEO0FBQUEsaUJBQUFFLGVBQUFIO0FBQUFBLGFBQUFDLE1BWWxFLEdBQUFELFNBQUE7QUFBQTtBQUFBLFVBUEssdUNBQ0U7QUFBQTtBQUFBLFdBQUFDLFFBRVU7QUFBQSxXQUFBRCxTQUNGO0FBQUEsVUFDWDtBQUFBO0FBQUE7QUFBQSxRQUVlO0FBQUEsUUQ1RHZCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTExLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Im9jYW1sX2ludHJpbnNpY3Nfa2VybmVsLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvb2NhbWxfaW50cmluc2ljc19rZXJuZWwvbmF0aXZlaW50Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIFN0dWJzID0gc3RydWN0XG4gIGxldCBhdmFpbGFibGUgPSBDb21tb24uYXZhaWxhYmxlXG5cbiAgKCoqIFtjb3VudF9sZWFkaW5nX3plcm9zIG5dIHJldHVybnMgdGhlIG51bWJlciBvZiBtb3N0LXNpZ25pZmljYW50XG4gICAgICB6ZXJvIGJpdHMgYmVmb3JlIHRoZSBtb3N0IHNpZ25pZmljYW50IHNldCBiaXQgaW4gW25dLlxuICAgICAgSWYgW25dIGlzIDAsIHRoZSByZXN1bHQgaXMgdGhlIG51bWJlciBvZiBiaXRzIGluIFtuXSxcbiAgICAgIHRoYXQgaXMgMzIgb3IgNjQsIGRlcGVuZGluZyBvbiB0aGUgdGFyZ2V0LiAqKVxuICBleHRlcm5hbCBjb3VudF9sZWFkaW5nX3plcm9zXG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX25hdGl2ZWludF9jbHpcIiBcImNhbWxfbmF0aXZlaW50X2Nsel91bmJveGVkX3RvX3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXSBbQEBidWlsdGluXSBbQEBub19lZmZlY3RzXSBbQEBub19jb2VmZmVjdHNdXG5cbiAgKCoqIFNhbWUgYXMgW2NvdW50X2xlYWRpbmdfemVyb3NdIGV4Y2VwdCBpZiB0aGUgYXJndW1lbnQgaXMgemVybyxcbiAgICAgIHRoZW4gdGhlIHJlc3VsdCBpcyB1bmRlZmluZWQuIEVtaXRzIG1vcmUgZWZmaWNpZW50IGNvZGUuICopXG4gIGV4dGVybmFsIGNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hcmdcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfbmF0aXZlaW50X2NselwiIFwiY2FtbF9uYXRpdmVpbnRfY2x6X25vbnplcm9fdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBbY291bnRfdHJhaWxpbmdfemVyb3Mgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGxlYXN0LXNpZ25pZmljYW50XG4gICAgICB6ZXJvIGJpdHMgYmVmb3JlIHRoZSBsZWFzdCBzaWduaWZpY2FudCBzZXQgYml0IGluIFtuXS5cbiAgICAgIElmIFtuXSBpcyAwLCB0aGUgcmVzdWx0IGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiBbbl0sXG4gICAgICB0aGF0IGlzIDMyIG9yIDY0LCBkZXBlbmRpbmcgb24gdGhlIHRhcmdldC4gKilcbiAgZXh0ZXJuYWwgY291bnRfdHJhaWxpbmdfemVyb3NcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfbmF0aXZlaW50X2N0elwiIFwiY2FtbF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICAoKiogU2FtZSBhcyBbY291bnRfdHJhaWxpbmdfemVyb3NdIGV4Y2VwdCBpZiB0aGUgYXJndW1lbnQgaXMgemVybyxcbiAgICAgIHRoZW4gdGhlIHJlc3VsdCBpcyB1bmRlZmluZWQuIEVtaXRzIG1vcmUgZWZmaWNpZW50IGNvZGUuICopXG4gIGV4dGVybmFsIGNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYXJnXG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX25hdGl2ZWludF9jdHpcIiBcImNhbWxfbmF0aXZlaW50X2N0el9ub256ZXJvX3VuYm94ZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICAoKiogW2NvdW50X3NldF9iaXRzIG5dIHJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgYXJlIDEgaW4gW25dLiAqKVxuICBleHRlcm5hbCBjb3VudF9zZXRfYml0c1xuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiY2FtbF9uYXRpdmVpbnRfcG9wY250XCIgXCJjYW1sX25hdGl2ZWludF9wb3BjbnRfdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuZW5kXG5cbm1vZHVsZSBOYWl2ZSA9IE5haXZlX2ludHMuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgU3RkbGliLk5hdGl2ZWludFxuXG4gIGxldCBiaXR3aWR0aCA9IFN5cy53b3JkX3NpemVcbmVuZClcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF9sZWFkaW5nX3plcm9zIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfbGVhZGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfbGVhZGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hcmcgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF9sZWFkaW5nX3plcm9zX25vbnplcm9fYXJnIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF9sZWFkaW5nX3plcm9zIG5cbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gY291bnRfdHJhaWxpbmdfemVyb3MgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF90cmFpbGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfdHJhaWxpbmdfemVyb3MgblxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF90cmFpbGluZ196ZXJvc19ub256ZXJvX2FyZyBuID1cbiAgbWF0Y2ggU3R1YnMuYXZhaWxhYmxlIHdpdGhcbiAgfCB0cnVlIC0+IFN0dWJzLmNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYXJnIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF90cmFpbGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X3NldF9iaXRzIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfc2V0X2JpdHMgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X3NldF9iaXRzIG5cbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX0NvbW1vbiIsIlN0ZGxpYl9OYXRpdmVpbnQiLCJTdGRsaWJfU3lzIiwiT2NhbWxfaW50cmluc2ljc19rZXJuZWxfTmFpdmVfIiwiYXZhaWxhYmxlIiwiemVybyIsIm9uZSIsImNvbXBhcmUiLCJlcXVhbCIsImJpdHdpZHRoIiwiTmFpdmUiLCJjb3VudF9sZWFkaW5nX3plcm9zIiwibiIsImNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hciIsImNvdW50X3RyYWlsaW5nX3plcm9zIiwiY291bnRfdHJhaWxpbmdfemVyb3Nfbm9uemVyb19hIiwiY291bnRfc2V0X2JpdHMiLCJPY2FtbF9pbnRyaW5zaWNzX2tlcm5lbF9OYXRpdmUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsb0JBQUFDO0FBQUFBLElDc0RFLG1CQUNVLGdDQUNDLHVCQUEyQjtBQUFBO0FBQUEsWUFBQUMsK0JBQUFEO0FBQUFBLElBSXRDLG1CQUNVLGdDQUNDLHVCQUEyQjtBQUFBO0FBQUEsWUFBQUUscUJBQUFGO0FBQUFBLElBSXRDLG1CQUNVLGdDQUNDLHVCQUE0QjtBQUFBO0FBQUEsWUFBQUcsK0JBQUFIO0FBQUFBLElBSXZDLG1CQUNVLGdDQUNDLHVCQUE0QjtBQUFBO0FBQUEsWUFBQUksZUFBQUo7QUFBQUEsSUFJdkM7QUFBQSxjQUNVO0FBQUEsY0FDQyx1QkFBc0I7QUFBQTtBQUFBO0FBQUEsSUFBQUs7QUFBQUEsTURoRm5DIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Im9jYW1sX2ludHJpbnNpY3Nfa2VybmVsLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvb2NhbWxfaW50cmluc2ljc19rZXJuZWwvaW50NjQubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgU3R1YnMgPSBzdHJ1Y3RcbiAgbGV0IGF2YWlsYWJsZSA9IENvbW1vbi5hdmFpbGFibGVcblxuICAoKiogW2NvdW50X2xlYWRpbmdfemVyb3Mgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG1vc3Qtc2lnbmlmaWNhbnRcbiAgICAgIHplcm8gYml0cyBiZWZvcmUgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgc2V0IGJpdCBpbiBbbl0uXG4gICAgICBJZiBbbl0gaXMgMCwgdGhlIHJlc3VsdCBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gW25dLFxuICAgICAgdGhhdCBpcyA2NC4gKilcbiAgZXh0ZXJuYWwgY291bnRfbGVhZGluZ196ZXJvc1xuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX2ludDY0X2NselwiIFwiY2FtbF9pbnQ2NF9jbHpfdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBTYW1lIGFzIFtjb3VudF9sZWFkaW5nX3plcm9zXSBleGNlcHQgaWYgdGhlIGFyZ3VtZW50IGlzIHplcm8sXG4gICAgICB0aGVuIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkLiBFbWl0cyBtb3JlIGVmZmljaWVudCBjb2RlLiAqKVxuICBleHRlcm5hbCBjb3VudF9sZWFkaW5nX3plcm9zX25vbnplcm9fYXJnXG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfaW50NjRfY2x6XCIgXCJjYW1sX2ludDY0X2Nsel9ub256ZXJvX3VuYm94ZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICAoKiogW2NvdW50X3RyYWlsaW5nX3plcm9zIG5dIHJldHVybnMgdGhlIG51bWJlciBvZiBsZWFzdC1zaWduaWZpY2FudFxuICAgICAgemVybyBiaXRzIGJlZm9yZSB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgc2V0IGJpdCBpbiBbbl0uXG4gICAgICBJZiBbbl0gaXMgMCwgdGhlIHJlc3VsdCBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gW25dLFxuICAgICAgdGhhdCBpcyA2NC4gKilcbiAgZXh0ZXJuYWwgY291bnRfdHJhaWxpbmdfemVyb3NcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiY2FtbF9pbnQ2NF9jdHpcIiBcImNhbWxfaW50NjRfY3R6X3VuYm94ZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICAoKiogU2FtZSBhcyBbY291bnRfdHJhaWxpbmdfemVyb3NdIGV4Y2VwdCBpZiB0aGUgYXJndW1lbnQgaXMgemVybyxcbiAgICAgIHRoZW4gdGhlIHJlc3VsdCBpcyB1bmRlZmluZWQuIEVtaXRzIG1vcmUgZWZmaWNpZW50IGNvZGUuICopXG4gIGV4dGVybmFsIGNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYXJnXG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfaW50NjRfY3R6XCIgXCJjYW1sX2ludDY0X2N0el9ub256ZXJvX3VuYm94ZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICAoKiogW2NvdW50X3NldF9iaXRzIG5dIHJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgYXJlIDEgaW4gW25dLiAqKVxuICBleHRlcm5hbCBjb3VudF9zZXRfYml0c1xuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX2ludDY0X3BvcGNudFwiIFwiY2FtbF9pbnQ2NF9wb3BjbnRfdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuZW5kXG5cbm1vZHVsZSBOYWl2ZSA9IE5haXZlX2ludHMuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgU3RkbGliLkludDY0XG5cbiAgbGV0IGJpdHdpZHRoID0gNjRcbmVuZClcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF9sZWFkaW5nX3plcm9zIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfbGVhZGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfbGVhZGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hcmcgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF9sZWFkaW5nX3plcm9zX25vbnplcm9fYXJnIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF9sZWFkaW5nX3plcm9zIG5cbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gY291bnRfdHJhaWxpbmdfemVyb3MgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF90cmFpbGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfdHJhaWxpbmdfemVyb3MgblxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF90cmFpbGluZ196ZXJvc19ub256ZXJvX2FyZyBuID1cbiAgbWF0Y2ggU3R1YnMuYXZhaWxhYmxlIHdpdGhcbiAgfCB0cnVlIC0+IFN0dWJzLmNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYXJnIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF90cmFpbGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X3NldF9iaXRzIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfc2V0X2JpdHMgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X3NldF9iaXRzIG5cbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJnbG9iYWxfZGF0YSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX0NvbW1vbiIsIlN0ZGxpYl9JbnQ2NCIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX05haXZlXyIsImF2YWlsYWJsZSIsInplcm8iLCJvbmUiLCJjb21wYXJlIiwiZXF1YWwiLCJOYWl2ZSIsImNvdW50X2xlYWRpbmdfemVyb3MiLCJuIiwiY291bnRfbGVhZGluZ196ZXJvc19ub256ZXJvX2FyIiwiY291bnRfdHJhaWxpbmdfemVyb3MiLCJjb3VudF90cmFpbGluZ196ZXJvc19ub256ZXJvX2EiLCJjb3VudF9zZXRfYml0cyIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX0ludDY0Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLG9CQUFBQztBQUFBQSxJQ3NERSxtQkFDVSw0QkFDQyx1QkFBMkI7QUFBQTtBQUFBLFlBQUFDLCtCQUFBRDtBQUFBQSxJQUl0QyxtQkFDVSw0QkFDQyx1QkFBMkI7QUFBQTtBQUFBLFlBQUFFLHFCQUFBRjtBQUFBQSxJQUl0QyxtQkFDVSw0QkFDQyx1QkFBNEI7QUFBQTtBQUFBLFlBQUFHLCtCQUFBSDtBQUFBQSxJQUl2QyxtQkFDVSw0QkFDQyx1QkFBNEI7QUFBQTtBQUFBLFlBQUFJLGVBQUFKO0FBQUFBLElBSXZDLG1CQUNVLCtCQUNDLHVCQUFzQjtBQUFBO0FBQUE7QUFBQSxJQUFBSztBQUFBQSxNRGhGbkMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NhbWxfaW50cmluc2ljc19rZXJuZWwuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9vY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC9pbnQzMi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBTdHVicyA9IHN0cnVjdFxuICBsZXQgYXZhaWxhYmxlID0gQ29tbW9uLmF2YWlsYWJsZVxuXG4gICgqKiBbY291bnRfbGVhZGluZ196ZXJvcyBuXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbW9zdC1zaWduaWZpY2FudFxuICAgICAgemVybyBiaXRzIGJlZm9yZSB0aGUgbW9zdCBzaWduaWZpY2FudCBzZXQgYml0IGluIFtuXS5cbiAgICAgIElmIFtuXSBpcyAwLCB0aGUgcmVzdWx0IGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiBbbl0sXG4gICAgICB0aGF0IGlzIDMyLiAqKVxuICBleHRlcm5hbCBjb3VudF9sZWFkaW5nX3plcm9zXG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfaW50MzJfY2x6XCIgXCJjYW1sX2ludDMyX2Nsel91bmJveGVkX3RvX3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXSBbQEBidWlsdGluXSBbQEBub19lZmZlY3RzXSBbQEBub19jb2VmZmVjdHNdXG5cbiAgKCoqIFNhbWUgYXMgW2NvdW50X2xlYWRpbmdfemVyb3NdIGV4Y2VwdCBpZiB0aGUgYXJndW1lbnQgaXMgemVybyxcbiAgICAgIHRoZW4gdGhlIHJlc3VsdCBpcyB1bmRlZmluZWQuIEVtaXRzIG1vcmUgZWZmaWNpZW50IGNvZGUuICopXG4gIGV4dGVybmFsIGNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hcmdcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiY2FtbF9pbnQzMl9jbHpcIiBcImNhbWxfaW50MzJfY2x6X25vbnplcm9fdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBbY291bnRfdHJhaWxpbmdfemVyb3Mgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGxlYXN0LXNpZ25pZmljYW50XG4gICAgICB6ZXJvIGJpdHMgYmVmb3JlIHRoZSBsZWFzdCBzaWduaWZpY2FudCBzZXQgYml0IGluIFtuXS5cbiAgICAgIElmIFtuXSBpcyAwLCB0aGUgcmVzdWx0IGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiBbbl0sXG4gICAgICB0aGF0IGlzIDMyLiAqKVxuICBleHRlcm5hbCBjb3VudF90cmFpbGluZ196ZXJvc1xuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX2ludDMyX2N0elwiIFwiY2FtbF9pbnQzMl9jdHpfdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBTYW1lIGFzIFtjb3VudF90cmFpbGluZ196ZXJvc10gZXhjZXB0IGlmIHRoZSBhcmd1bWVudCBpcyB6ZXJvLFxuICAgICAgdGhlbiB0aGUgcmVzdWx0IGlzIHVuZGVmaW5lZC4gRW1pdHMgbW9yZSBlZmZpY2llbnQgY29kZS4gKilcbiAgZXh0ZXJuYWwgY291bnRfdHJhaWxpbmdfemVyb3Nfbm9uemVyb19hcmdcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiY2FtbF9pbnQzMl9jdHpcIiBcImNhbWxfaW50MzJfY3R6X25vbnplcm9fdW5ib3hlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBbY291bnRfc2V0X2JpdHMgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgdGhhdCBhcmUgMSBpbiBbbl0uICopXG4gIGV4dGVybmFsIGNvdW50X3NldF9iaXRzXG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfaW50MzJfcG9wY250XCIgXCJjYW1sX2ludDMyX3BvcGNudF91bmJveGVkX3RvX3VudGFnZ2VkXCJcbiAgICBbQEBub2FsbG9jXSBbQEBidWlsdGluXSBbQEBub19lZmZlY3RzXSBbQEBub19jb2VmZmVjdHNdXG5lbmRcblxubW9kdWxlIE5haXZlID0gTmFpdmVfaW50cy5NYWtlIChzdHJ1Y3RcbiAgaW5jbHVkZSBTdGRsaWIuSW50MzJcblxuICBsZXQgYml0d2lkdGggPSAzMlxuZW5kKVxuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X2xlYWRpbmdfemVyb3MgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF9sZWFkaW5nX3plcm9zIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF9sZWFkaW5nX3plcm9zIG5cbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gY291bnRfbGVhZGluZ196ZXJvc19ub256ZXJvX2FyZyBuID1cbiAgbWF0Y2ggU3R1YnMuYXZhaWxhYmxlIHdpdGhcbiAgfCB0cnVlIC0+IFN0dWJzLmNvdW50X2xlYWRpbmdfemVyb3Nfbm9uemVyb19hcmcgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X2xlYWRpbmdfemVyb3MgblxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF90cmFpbGluZ196ZXJvcyBuID1cbiAgbWF0Y2ggU3R1YnMuYXZhaWxhYmxlIHdpdGhcbiAgfCB0cnVlIC0+IFN0dWJzLmNvdW50X3RyYWlsaW5nX3plcm9zIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF90cmFpbGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYXJnIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfdHJhaWxpbmdfemVyb3Nfbm9uemVyb19hcmcgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X3RyYWlsaW5nX3plcm9zIG5cbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gY291bnRfc2V0X2JpdHMgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF9zZXRfYml0cyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfc2V0X2JpdHMgblxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiT2NhbWxfaW50cmluc2ljc19rZXJuZWxfQ29tbW9uIiwiU3RkbGliX0ludDMyIiwiT2NhbWxfaW50cmluc2ljc19rZXJuZWxfTmFpdmVfIiwiYXZhaWxhYmxlIiwiemVybyIsIm9uZSIsImNvbXBhcmUiLCJlcXVhbCIsIk5haXZlIiwiY291bnRfbGVhZGluZ196ZXJvcyIsIm4iLCJjb3VudF9sZWFkaW5nX3plcm9zX25vbnplcm9fYXIiLCJjb3VudF90cmFpbGluZ196ZXJvcyIsImNvdW50X3RyYWlsaW5nX3plcm9zX25vbnplcm9fYSIsImNvdW50X3NldF9iaXRzIiwiT2NhbWxfaW50cmluc2ljc19rZXJuZWxfSW50MzIiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsb0JBQUFDO0FBQUFBLElDc0RFLG1CQUNVLDRCQUNDLHVCQUEyQjtBQUFBO0FBQUEsWUFBQUMsK0JBQUFEO0FBQUFBLElBSXRDLG1CQUNVLDRCQUNDLHVCQUEyQjtBQUFBO0FBQUEsWUFBQUUscUJBQUFGO0FBQUFBLElBSXRDLG1CQUNVLDRCQUNDLHVCQUE0QjtBQUFBO0FBQUEsWUFBQUcsK0JBQUFIO0FBQUFBLElBSXZDLG1CQUNVLDRCQUNDLHVCQUE0QjtBQUFBO0FBQUEsWUFBQUksZUFBQUo7QUFBQUEsSUFJdkMsbUJBQ1UsK0JBQ0MsdUJBQXNCO0FBQUE7QUFBQTtBQUFBLElBQUFLO0FBQUFBLE1EaEZuQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJvY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL29jYW1sX2ludHJpbnNpY3Nfa2VybmVsL2ludC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBUaGUgYXJlIHR3byB2ZXJzaW9uIG9mIFtjb3VudF9sZWFkaW5nX3plcm9zXSwgW2NvdW50X3NldF9iaXRzXSBlYWNoLCB3aGljaCBkaWZmZXIgaW5cbiAgICB0aGVpciBuYXRpdmUgY29kZSBpbXBsZW1lbnRhdGlvbi4gIFRoZSBmaXJzdCB2ZXJzaW9uIHRha2VzIGFzIGlucHV0IGEgdGFnZ2VkIGludGVnZXJcbiAgICBhbmQgdGhlIHNlY29uZCB2ZXJzaW9uIHRha2VzIGFzIGlucHV0IGFuIHVudGFnZ2VkIGludGVnZXIuICBHZW5lcmFsbHksIHRoZSBmaXJzdFxuICAgIHZlcnNpb24gKHRoYXQgb3BlcmF0ZXMgb24gYSB0YWdnZWQgaW50ZWdlcikgaXMgZmFzdGVyLCBidXQgaWYgdGhlIGludGVnZXIgaXMgYWxyZWFkeVxuICAgIHVudGFnZ2VkLCBpdCBtYXkgYmUgZmFzdGVyIHRvIHVzZSB0aGUgc2Vjb25kIHZlcnNpb24uXG4qKVxuXG5tb2R1bGUgU3R1YnMgPSBzdHJ1Y3RcbiAgbGV0IGF2YWlsYWJsZSA9IENvbW1vbi5hdmFpbGFibGVcblxuICAoKiogW2NvdW50X2xlYWRpbmdfemVyb3Mgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG1vc3Qtc2lnbmlmaWNhbnRcbiAgICAgIHplcm8gYml0cyBiZWZvcmUgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgc2V0IGJpdCBpbiBbbl0uXG4gICAgICBJZiBbbl0gaXMgMCwgdGhlIHJlc3VsdCBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gW25dLFxuICAgICAgdGhhdCBpcyAzMSBvciA2MywgZGVwZW5kaW5nIG9uIHRoZSB0YXJnZXQuICopXG4gIGV4dGVybmFsIGNvdW50X2xlYWRpbmdfemVyb3NcbiAgICA6ICBpbnRcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcImNhbWxfaW50X2NselwiIFwiY2FtbF9pbnRfY2x6X3RhZ2dlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gIGV4dGVybmFsIGNvdW50X2xlYWRpbmdfemVyb3MyXG4gICAgOiAgaW50XG4gICAgLT4gaW50XG4gICAgPSBcImNhbWxfaW50X2NselwiIFwiY2FtbF9pbnRfY2x6X3VudGFnZ2VkX3RvX3VudGFnZ2VkXCJcbiAgICBbQEB1bnRhZ2dlZF0gW0BAbm9hbGxvY10gW0BAYnVpbHRpbl0gW0BAbm9fZWZmZWN0c10gW0BAbm9fY29lZmZlY3RzXVxuXG4gICgqKiBbY291bnRfc2V0X2JpdHMgbl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgdGhhdCBhcmUgMSBpbiBbbl0uICopXG4gIGV4dGVybmFsIGNvdW50X3NldF9iaXRzXG4gICAgOiAgaW50XG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJjYW1sX2ludF9wb3BjbnRcIiBcImNhbWxfaW50X3BvcGNudF90YWdnZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cblxuICBleHRlcm5hbCBjb3VudF9zZXRfYml0czJcbiAgICA6ICBpbnRcbiAgICAtPiBpbnRcbiAgICA9IFwiY2FtbF9pbnRfcG9wY250XCIgXCJjYW1sX2ludF9wb3BjbnRfdW50YWdnZWRfdG9fdW50YWdnZWRcIlxuICAgIFtAQHVudGFnZ2VkXSBbQEBub2FsbG9jXSBbQEBidWlsdGluXSBbQEBub19lZmZlY3RzXSBbQEBub19jb2VmZmVjdHNdXG5cbiAgKCoqIFtjb3VudF90cmFpbGluZ196ZXJvcyBuXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbGVhc3Qtc2lnbmlmaWNhbnRcbiAgICAgIHplcm8gYml0cyBiZWZvcmUgdGhlIGxlYXN0IHNpZ25pZmljYW50IHNldCBiaXQgaW4gW25dLlxuICAgICAgSWYgW25dIGlzIDAsIHRoZSByZXN1bHQgaXMgdGhlIG51bWJlciBvZiBiaXRzIGluIFtuXSxcbiAgICAgIHRoYXQgaXMgMzEgb3IgNjMsIGRlcGVuZGluZyBvbiB0aGUgdGFyZ2V0LiAqKVxuICBleHRlcm5hbCBjb3VudF90cmFpbGluZ196ZXJvc1xuICAgIDogIGludFxuICAgIC0+IGludFxuICAgID0gXCJjYW1sX2ludF9jdHpcIiBcImNhbWxfaW50X2N0el91bnRhZ2dlZF90b191bnRhZ2dlZFwiXG4gICAgW0BAdW50YWdnZWRdIFtAQG5vYWxsb2NdIFtAQGJ1aWx0aW5dIFtAQG5vX2VmZmVjdHNdIFtAQG5vX2NvZWZmZWN0c11cbmVuZFxuXG5tb2R1bGUgTmFpdmUgPSBOYWl2ZV9pbnRzLk1ha2UgKHN0cnVjdFxuICBpbmNsdWRlIFN0ZGxpYi5JbnRcblxuICBsZXQgYml0d2lkdGggPSBTeXMuaW50X3NpemVcbmVuZClcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF9sZWFkaW5nX3plcm9zIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfbGVhZGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfbGVhZGluZ196ZXJvcyBuXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGNvdW50X2xlYWRpbmdfemVyb3MyIG4gPVxuICBtYXRjaCBTdHVicy5hdmFpbGFibGUgd2l0aFxuICB8IHRydWUgLT4gU3R1YnMuY291bnRfbGVhZGluZ196ZXJvczIgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X2xlYWRpbmdfemVyb3MgblxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF9zZXRfYml0czIgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF9zZXRfYml0czIgblxuICB8IGZhbHNlIC0+IE5haXZlLmNvdW50X3NldF9iaXRzIG5cbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gY291bnRfdHJhaWxpbmdfemVyb3MgbiA9XG4gIG1hdGNoIFN0dWJzLmF2YWlsYWJsZSB3aXRoXG4gIHwgdHJ1ZSAtPiBTdHVicy5jb3VudF90cmFpbGluZ196ZXJvcyBuXG4gIHwgZmFsc2UgLT4gTmFpdmUuY291bnRfdHJhaWxpbmdfemVyb3MgblxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBjb3VudF9zZXRfYml0cyBuID1cbiAgbWF0Y2ggU3R1YnMuYXZhaWxhYmxlIHdpdGhcbiAgfCB0cnVlIC0+IFN0dWJzLmNvdW50X3NldF9iaXRzIG5cbiAgfCBmYWxzZSAtPiBOYWl2ZS5jb3VudF9zZXRfYml0cyBuXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJPY2FtbF9pbnRyaW5zaWNzX2tlcm5lbF9Db21tb24iLCJTdGRsaWJfSW50IiwiU3RkbGliX1N5cyIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX05haXZlXyIsImF2YWlsYWJsZSIsInplcm8iLCJvbmUiLCJlcXVhbCIsImNvbXBhcmUiLCJiaXR3aWR0aCIsIk5haXZlIiwiY291bnRfbGVhZGluZ196ZXJvcyIsIm4iLCJjb3VudF9sZWFkaW5nX3plcm9zMiIsImNvdW50X3NldF9iaXRzMiIsImNvdW50X3RyYWlsaW5nX3plcm9zIiwiY291bnRfc2V0X2JpdHMiLCJPY2FtbF9pbnRyaW5zaWNzX2tlcm5lbF9JbnQiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxvQkFBQUM7QUFBQUEsSUN5REUsbUJBQ1UsMEJBQ0MsdUJBQTJCO0FBQUE7QUFBQSxZQUFBQyxxQkFBQUQ7QUFBQUEsSUFJdEMsbUJBQ1UsMEJBQ0MsdUJBQTJCO0FBQUE7QUFBQSxZQUFBRSxnQkFBQUY7QUFBQUEsSUFJdEMsbUJBQ1UsNkJBQ0MsdUJBQXNCO0FBQUE7QUFBQSxZQUFBRyxxQkFBQUg7QUFBQUEsSUFJakMsbUJBQ1UsMEJBQ0MsdUJBQTRCO0FBQUE7QUFBQSxZQUFBSSxlQUFBSjtBQUFBQSxJQUl2QyxtQkFDVSw2QkFDQyx1QkFBc0I7QUFBQTtBQUFBO0FBQUEsSUFBQUs7QUFBQUEsTURuRm5DIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Im9jYW1sX2ludHJpbnNpY3Nfa2VybmVsLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIk9jYW1sX2ludHJpbnNpY3Nfa2VybmVsX0Zsb2F0Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0NBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NhbWxfaW50cmluc2ljc19rZXJuZWwuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiT2NhbWxfaW50cmluc2ljc19rZXJuZWxfQ29uZGl0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBIiwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
