// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Ppx_inline_test_lib
//# unitInfo: Requires: Base, Base__Exn, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
//# shape: Ppx_inline_test_lib:[N,N,N,F(1),N,F(2),F(1),F(8),F(8),F(8),F(1),F(1),F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib$0 = "Ppx_inline_test_lib",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    initial = [0, 0, [0, "disabled", 0]],
    cst = cst$13,
    am_running_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error";
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return Stdlib_List[26].call(null, combine, 0, ts);
   }
   var
    already_initialized = [0, 0],
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0];
   function drop(t, tag){
    var a = [0, tag, t[2]];
    return [0,
            Stdlib_List[44].call
             (null, function(a){return tag !== a ? 1 : 0;}, t[1]),
            a];
   }
   function require(t, tag){
    var
     a =
       Stdlib_List[44].call
        (null, function(a){return tag !== a ? 1 : 0;}, t[2]);
    return [0, [0, tag, t[1]], a];
   }
   var
    action = [0, -950194894],
    cst_source_tree_root$0 = "source_tree_root",
    cst_diff_path_prefix$0 = "diff_path_prefix",
    cst_diff_command = "diff_command",
    cst_in_place$0 = "in_place",
    cst_use_color = "use_color",
    K =
      [0,
       [11,
        "ppx_inline_test error: attempted to access the [",
        [2, 0, [11, "] config before [init] was called", 0]]],
       "ppx_inline_test error: attempted to access the [%s] config before [init] was called"],
    J = [0, [2, 0, [12, 10, 0]], "%s\n"],
    I = [0, 1, [0, 7, 0]],
    B = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    C = [0, [12, 32, [2, 0, 0]], " %s"],
    x =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    y =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    z =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    A =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    D = [0, [11, cst$12, [10, 0]], ".\n%!"],
    E =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    G = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    H = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    F =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    v =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    w = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    p = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    q = [0, [2, 0, [10, 0]], cst_s],
    r = [0, 1],
    s =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    t =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    u =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    o = [0, [2, 0, [10, 0]], cst_s],
    n = [0, [2, 0, [10, 0]], cst_s],
    m = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib = cst_Ppx_inline_test_lib$0,
    k = [0, 0],
    i = [0, 0],
    cst_inline_tests_log = cst_inline_tests_log$0,
    h =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    g =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    cst_The_inline_test_runner_can =
      "The inline test runner can only be initialized once, and has already been initialized.",
    cst_inline_test_runner = cst_inline_test_runner$0,
    f =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Prefix_to_prepend_to_filep =
      " Prefix to prepend to filepaths in test output",
    cst_diff_path_prefix = "-diff-path-prefix",
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module into FILE",
    cst_list_partitions_into_file = "-list-partitions-into-file",
    cst_Lists_all_the_partitions_t$0 =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    e =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    d =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    c = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    b =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    j = [0, [2, 0, 0], cst_s$0],
    M = [0, [2, 0, 0], cst_s$0],
    l = [0, 187165616, 545942154],
    L = [0, 187165616, -863538453];
   try{caml_sys_getenv("FORCE_DROP_INLINE_TEST"); var O = 1, force_drop = O;}
   catch(exn$0){
    var exn = caml_wrap_exception(exn$0);
    if(exn !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var a = Stdlib_Hashtbl[1].call(null, 0, 23), current = [0, cst];
   function found_test(param){
    var
     b = current[1] !== cst$13 ? 1 : 0,
     c = b ? 1 - Stdlib_Hashtbl[9].call(null, a, current[1]) : b;
    return c ? Stdlib_Hashtbl[5].call(null, a, current[1], 0) : c;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return p === current[1] ? 1 : 0;
   }
   function all(param){
    var
     b =
       Stdlib_Hashtbl[14].call
        (null, function(k, param, acc){return [0, k, acc];}, a, 0);
    return Stdlib_List[59].call(null, Stdlib_String[10], b);
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var
     t = current$0[1],
     a = Stdlib_List[20].call(null, function(m){return m[2];}, t);
    return Stdlib_List[14].call(null, a);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    diff_path_prefix = [0, 0];
   function displayed_descr(descr, filename, line, start_pos, end_pos){
    var a = caml_obj_tag(descr);
    a:
    if(250 === a)
     var descr$0 = descr[1];
    else{
     if(246 !== a && 244 !== a){var descr$0 = descr; break a;}
     var descr$0 = CamlinternalLazy[2].call(null, descr);
    }
    var
     c = descr$0 === cst$13 ? cst$0 : Stdlib[28].call(null, cst$1, descr$0);
    return caml_call5
            (Stdlib_Printf[4].call(null, b),
             filename,
             line,
             start_pos,
             end_pos,
             c);
   }
   function parse_descr(str){
    try{
     var
      f =
        [0,
         caml_call1
          (Stdlib_Scanf[5].call(null, str, e),
           function(file, line, start_pos, end_pos){return [0, file, [0, line]];
           })];
     return f;
    }
    catch(exn){
     try{
      var
       b =
         [0,
          caml_call1
           (Stdlib_Scanf[5].call(null, str, d),
            function(file, line){return [0, file, [0, line]];})];
      return b;
     }
     catch(exn){
      try{
       var
        a =
          [0,
           caml_call1
            (Stdlib_Scanf[5].call(null, str, c),
             function(file){return [0, file, 0];})];
       return a;
      }
      catch(exn){return 0;}
     }
    }
   }
   function parse_argv(current, args){
    if(args){
     var a = args[2];
     if(a){
      var name = args[1];
      if(a[1] === cst_inline_test_runner$0){
       var match = a[2];
       if(match){
        var rest = match[2], lib = match[1];
        if(already_initialized[1])
         throw caml_maybe_attach_backtrace
                ([0, Stdlib_Arg[8], cst_The_inline_test_runner_can], 1);
        already_initialized[1] = 1;
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, initial],
         name_filter = [0, 0],
         c =
           caml_call3
            (Stdlib_Printf[4].call(null, f),
             name,
             cst_inline_test_runner,
             lib),
         d =
           Stdlib_Arg[11].call
            (null,
             0,
             [0,
              [0,
               cst_list_test_names,
               [0,
                function(param){
                 list_test_names[1] = 1;
                 verbose[1] = 1;
                 return 0;
                }],
               cst_Do_not_run_tests_but_show_],
              [0,
               [0,
                cst_list_partitions,
                [0, function(param){list_partitions[1] = i; return 0;}],
                cst_Lists_all_the_partitions_t$0],
               [0,
                [0,
                 cst_list_partitions_into_file,
                 [4,
                  function(file){
                   list_partitions[1] = [0, [0, file]];
                   return 0;
                  }],
                 cst_Lists_all_the_partitions_t],
                [0,
                 [0,
                  cst_partition,
                  [4, function(i){partition[1] = [0, i]; return 0;}],
                  cst_Only_run_the_tests_in_the_],
                 [0,
                  [0,
                   cst_verbose,
                   [2, verbose],
                   cst_Show_the_tests_as_they_run],
                  [0,
                   [0,
                    cst_stop_on_error,
                    [2, stop_on_error],
                    cst_Run_tests_only_up_to_the_f],
                   [0,
                    [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
                    [0,
                     [0,
                      cst_show_counts,
                      [2, show_counts],
                      cst_Show_the_number_of_tests_r],
                     [0,
                      [0,
                       cst_log,
                       [0,
                        function(param){
                         try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                         catch(exn){}
                         log[1] = [0, Stdlib[60].call(null, cst_inline_tests_log)];
                         return 0;
                        }],
                       cst_Log_the_tests_run_in_inlin],
                      [0,
                       [0,
                        cst_drop_tag,
                        [4,
                         function(s){
                          tag_predicate[1] = drop(tag_predicate[1], s);
                          return 0;
                         }],
                        cst_tag_Only_run_tests_not_tag],
                       [0,
                        [0,
                         cst_require_tag,
                         [4,
                          function(s){
                           tag_predicate[1] = require(tag_predicate[1], s);
                           return 0;
                          }],
                         cst_tag_Only_run_tests_tagged_],
                        [0,
                         [0,
                          cst_matching,
                          [4,
                           function(s){
                            name_filter[1] = [0, s, name_filter[1]];
                            return 0;
                           }],
                          cst_substring_Only_run_tests_w],
                         [0,
                          [0,
                           cst_only_test,
                           [4,
                            function(s){
                             var match = parse_descr(s);
                             if(match)
                              var
                               match$0 = match[1],
                               index = match$0[2],
                               file = match$0[1],
                               index$0 = index,
                               filename = file;
                             else if(Stdlib_String[15].call(null, s, 58)){
                              var
                               i = Stdlib_String[36].call(null, s, 58),
                               filename$0 = Stdlib_String[16].call(null, s, 0, i),
                               index_string =
                                 Stdlib_String[16].call
                                  (null,
                                   s,
                                   i + 1 | 0,
                                   (caml_ml_string_length(s) - i | 0) - 1 | 0);
                              try{var index$1 = runtime.caml_int_of_string(index_string);}
                              catch(exn$0){
                               var exn = caml_wrap_exception(exn$0), tag = exn[1];
                               if(tag !== Stdlib[7])
                                throw caml_maybe_attach_backtrace(exn, 0);
                               var a = caml_call1(Stdlib_Printf[4].call(null, h), s);
                               throw caml_maybe_attach_backtrace([0, Stdlib_Arg[8], a], 1);
                              }
                              var index$0 = [0, index$1], filename = filename$0;
                             }
                             else
                              var index$0 = 0, filename = s;
                             tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
                             return 0;
                            }],
                           cst_location_Run_only_the_test],
                          [0,
                           [0,
                            cst_no_color,
                            [3, use_color],
                            cst_Summarize_tests_without_us],
                           [0,
                            [0,
                             cst_in_place,
                             [2, in_place],
                             cst_Update_expect_tests_in_pla],
                            [0,
                             [0,
                              cst_diff_cmd,
                              [4, function(s){diff_command[1] = [0, s]; return 0;}],
                              cst_Diff_command_for_tests_tha],
                             [0,
                              [0,
                               cst_source_tree_root,
                               [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
                               cst_Path_to_the_root_of_the_so],
                              [0,
                               [0,
                                cst_diff_path_prefix,
                                [4, function(s){diff_path_prefix[1] = [0, s]; return 0;}],
                                cst_Prefix_to_prepend_to_filep],
                               0]]]]]]]]]]]]]]]]]]),
         e = Stdlib_Array[11].call(null, [0, name, rest]);
        Stdlib_Arg[3].call
         (null,
          current,
          e,
          d,
          function(anon){
           var a = caml_call2(Stdlib_Printf[4].call(null, g), name, anon);
           throw caml_maybe_attach_backtrace([0, Stdlib_Arg[8], a], 1);
          },
          c);
        var match$0 = list_partitions[1];
        if(match$0)
         var where_to_list = match$0[1], b = [0, -260537174, where_to_list];
        else
         var b = [0, 1025081494, partition[1]];
        var
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], b]];
        action[1] = v;
        return;
       }
      }
     }
    }
   }
   if(Base[87][1])
    try{
     var N = caml_sys_argv(0);
     parse_argv(0, Stdlib_Array[10].call(null, N));
    }
    catch(exn){
     var exn$0 = caml_wrap_exception(exn), tag = exn$0[1];
     if(tag === Stdlib_Arg[8]){
      var msg = exn$0[2];
      caml_call1(Stdlib_Printf[3].call(null, j), msg);
      Stdlib[99].call(null, 1);
     }
     else{
      var tag$0 = exn$0[1];
      if(tag$0 !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn$0, 0);
      var msg$0 = exn$0[2];
      caml_call1(Stdlib_Printf[2].call(null, M), msg$0);
      Stdlib[99].call(null, 0);
     }
    }
   function init(args){
    var current = [0, 0];
    try{parse_argv([0, current], args); return k;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib_Arg[8]){var msg = exn[2]; return [1, msg];}
     var tag$0 = exn[1];
     if(tag$0 !== Stdlib_Arg[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$0 = exn[2];
     return [0, [0, msg$0]];
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(exn){
     var exn$1 = caml_wrap_exception(exn);
     if(exn$1 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$1, 0);
     try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
     catch(exn){
      var exn$2 = caml_wrap_exception(exn);
      if(exn$2 !== Stdlib[8]) throw caml_maybe_attach_backtrace(exn$2, 0);
      var am_running = 0;
      break a;
     }
     if(val !== "inline-test"){var am_running = 0; break a;}
     var am_running = 1;
     break a;
    }
    var am_running = 1;
   }
   var testing = am_test_runner ? l : am_running ? L : 822171972;
   function timestamp_ns(param){return Time_now[2].call(null, 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         a = Stdlib[28].call(null, cst$2, cst_time_without_resetting_ran),
         b = Stdlib[28].call(null, cst_Ppx_inline_test_lib, a);
        return caml_call2(Base_String[86][2], 0, b);
       }];
   function time_without_resetting_random_(f){
    var before_ns = timestamp_ns(0);
    try{var c = [0, caml_call1(f, 0)], res = c;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, Stdlib_Printexc[6].call(null, 0)]];
    }
    var a = timestamp_ns(0), b = Base_Int63[46].call(null, a, before_ns);
    time_sec[1] = Base_Int63[3].call(null, b) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(a){
        return caml_call1(Stdlib_Random[19][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(a){return caml_call1(Base_Random[19][2], [0, 111, 222, 333]);}];
   function string_of_module_descr(param){
    var
     t = current$0[1],
     a = Stdlib_List[20].call(null, function(m){return m[1];}, t),
     b =
       Stdlib_List[20].call
        (null,
         function(s){
          var
           a = Stdlib_String[29].call(null, s),
           b = Stdlib[28].call(null, a, cst$3),
           c = Stdlib[28].call(null, cst_T_MODULE_at, b);
          return Stdlib[28].call(null, cst_in_TES, c);
         },
         a);
    return Stdlib_String[7].call(null, cst$4, b);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = Stdlib_List[10].call(null, delayed_errors[1]);
    if(! delayed_errors$0) return;
    var a = Stdlib_String[1].call(null, 70, 61);
    caml_call1(Stdlib_Printf[3].call(null, m), a);
    return Stdlib_List[18].call
            (null,
             function(message){
              return caml_call1(Stdlib_Printf[3].call(null, n), message);
             },
             delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    return Stdlib_Printf[10].call
            (null,
             function(s){
              if(verbose[1])
               delayed_errors[1] = [0, s, delayed_errors[1]];
              else
               caml_call1(Stdlib_Printf[3].call(null, o), s);
              var a = stop_on_error[1];
              return a
                      ? (print_delayed_errors(0), Stdlib[99].call(null, 2))
                      : a;
             },
             fmt);
   }
   function add_hooks(C, f, param){
    caml_call1(C[1], 0);
    return caml_call1(f, 0);
   }
   function hum_backtrace(backtrace){
    var
     a = Base_String[104].call(null, backtrace),
     b =
       Base_List[141].call
        (null,
         a,
         function(str){
          var a = caml_obj_tag(where_to_cut_backtrace);
          a:
          if(250 === a)
           var b = where_to_cut_backtrace[1];
          else{
           if(246 !== a && 244 !== a){
            var b = where_to_cut_backtrace;
            break a;
           }
           var b = CamlinternalLazy[2].call(null, where_to_cut_backtrace);
          }
          return 1 - caml_call2(Base_String[86][5], b, str);
         }),
     c =
       Base_List[53].call
        (null,
         b,
         function(str){
          var a = Base[241].call(null, str, cst$5);
          return Base[241].call(null, cst$6, a);
         });
    return Base_String[68].call(null, 0, c);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     h = match[2],
     what_to_do = h[2],
     match$0 = h[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1];
    function f$0(a){return add_hooks(config, f, a);}
    var
     descr$0 =
       [246,
        function(a){
         return displayed_descr
                 (descr, def_filename, def_line_number, start_pos, end_pos);
        }],
     n = current_tags(0),
     complete_tags = Stdlib[37].call(null, tags, n),
     i = caml_equal([0, libname], dynamic_lib[1]);
    if(i){
     var
      j =
        only_test_location
         ? Stdlib_List
            [34].call
           (null,
            function(param){
             var
              used = param[3],
              line_number_opt = param[2],
              filename = param[1],
              position_start =
                caml_ml_string_length(def_filename)
                - caml_ml_string_length(filename)
                | 0,
              a = 0 <= position_start ? 1 : 0;
             if(a){
              var
               end_of_def_filename =
                 Stdlib_String[16].call
                  (null,
                   def_filename,
                   position_start,
                   caml_ml_string_length(filename)),
               b = end_of_def_filename === filename ? 1 : 0;
              if(b){
               var
                d = 0 === position_start ? 1 : 0,
                c =
                  d
                  ||
                   (47
                     ===
                      runtime.caml_string_get
                       (def_filename, position_start - 1 | 0)
                     ? 1
                     : 0);
               if(c)
                if(line_number_opt)
                 var
                  line_number = line_number_opt[1],
                  found = caml_equal(def_line_number, line_number);
                else
                 var found = 1;
               else
                var found = c;
              }
              else
               var found = b;
             }
             else
              var found = a;
             if(found) used[1] = 1;
             return found;
            },
            only_test_location)
         : 1;
     if(j){
      var
       m =
         Stdlib_List[34].call
          (null,
           function(req){
            return 1 - Stdlib_List[37].call(null, req, complete_tags);
           },
           which_tags[1]),
       o =
         m
         ||
          Stdlib_List[34].call
           (null,
            function(dropped){
             return Stdlib_List[37].call(null, dropped, complete_tags);
            },
            which_tags[2]),
       k = 1 - o;
      if(k){
       var e = caml_obj_tag(descr$0);
       a:
       if(250 === e)
        var descr$1 = descr$0[1];
       else{
        if(246 !== e && 244 !== e){var descr$1 = descr$0; break a;}
        var descr$1 = CamlinternalLazy[2].call(null, descr$0);
       }
       var
        should_run =
          name_filter
           ? Stdlib_List
              [34].call
             (null,
              function(substring){
               return Base_String[92].call(null, descr$1, substring);
              },
              name_filter)
           : 1;
      }
      else
       var should_run = k;
     }
     else
      var should_run = j;
    }
    else
     var should_run = i;
    if(! should_run) return should_run;
    var variant = what_to_do[1];
    if(1025081494 > variant) return found_test(0);
    var partition = what_to_do[2], l = is_current(partition);
    if(! l) return l;
    var g = caml_obj_tag(descr$0);
    a:
    if(250 === g)
     var descr$2 = descr$0[1];
    else{
     if(246 !== g && 244 !== g){var descr$2 = descr$0; break a;}
     var descr$2 = CamlinternalLazy[2].call(null, descr$0);
    }
    tests_ran[1]++;
    var match$1 = log[1];
    if(match$1){
     var ch = match$1[1], v = string_of_module_descr(0);
     caml_call2(Stdlib_Printf[1].call(null, ch, p), descr$2, v);
    }
    if(verbose[1]) caml_call1(Stdlib_Printf[2].call(null, q), descr$2);
    if(list_test_names[1])
     var result$0 = r;
    else{
     var
      caml_random_state = Stdlib_Random[20].call(null, 0),
      base_random_state = caml_call1(Base_Random[19][4], Base_Random[19][1]),
      a = caml_obj_tag(saved_caml_random_state);
     a:
     if(250 === a)
      var b = saved_caml_random_state[1];
     else{
      if(246 !== a && 244 !== a){var b = saved_caml_random_state; break a;}
      var b = CamlinternalLazy[2].call(null, saved_caml_random_state);
     }
     Stdlib_Random[21].call(null, b);
     var c = caml_obj_tag(saved_base_random_state);
     a:
     if(250 === c)
      var d = saved_base_random_state[1];
     else{
      if(246 !== c && 244 !== c){var d = saved_base_random_state; break a;}
      var d = CamlinternalLazy[2].call(null, saved_base_random_state);
     }
     Base_Random[20].call(null, d);
     var result = time_without_resetting_random_(f$0);
     Stdlib_Random[21].call(null, caml_random_state);
     Base_Random[20].call(null, base_random_state);
     var result$0 = Stdlib_Result[8].call(null, bool_of_f, result);
    }
    if(verbose[1]){
     var w = time_sec[1];
     caml_call1(Stdlib_Printf[2].call(null, s), w);
    }
    if(0 !== result$0[0]){
     var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
     tests_failed[1]++;
     var
      backtrace$0 = hum_backtrace(backtrace),
      exn_str = Sexplib0_Sexp_conv[70].call(null, exn),
      sep = Stdlib_String[15].call(null, exn_str, 10) ? cst$7 : cst$8,
      y = string_of_module_descr(0);
     return caml_call5
             (eprintf_or_delay(u), descr$2, sep, exn_str, backtrace$0, y);
    }
    if(result$0[1]) return 0;
    tests_failed[1]++;
    var x = string_of_module_descr(0);
    return caml_call2(eprintf_or_delay(t), descr$2, x);
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     a = which_tests[1] === static_lib ? 1 : 0;
    if(! a) return a;
    var variant = what_to_do[1];
    a:
    {
     if(1025081494 <= variant && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(partition === cst$13 && requires_partition)
     return Stdlib[2].call(null, cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     a = lib === static_lib ? 1 : 0,
     b = a ? (dynamic_lib[1] = 0, 0) : a;
    return b;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     a = match[2],
     what_to_do = a[2],
     match$0 = a[1],
     which_tags = match$0[4],
     libname = match$0[1];
    function f$0(a){return add_hooks(config, f, a);}
    var
     d = current_tags(0),
     partial_tags = Stdlib[37].call(null, tags, d),
     b = caml_equal([0, libname], dynamic_lib[1]),
     should_run =
       b
        ? 1
         -
          Stdlib_List[34].call
           (null,
            function(dropped){
             return Stdlib_List[37].call(null, dropped, partial_tags);
            },
            which_tags[2])
        : b;
    if(! should_run) return should_run;
    var variant = what_to_do[1];
    if(1025081494 > variant) return found_test(0);
    var partition = what_to_do[2], c = is_current(partition);
    if(! c) return c;
    test_modules_ran[1]++;
    var
     descr$0 =
       displayed_descr
        (descr, def_filename, def_line_number, start_pos, end_pos),
     prev = current$0[1];
    current$0[1] = [0, [0, descr$0, tags], prev];
    try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     current$0[1] = prev;
     throw caml_maybe_attach_backtrace(e, 0);
    }
    if(0 === x[0]) return 0;
    var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
    test_modules_failed[1]++;
    var
     backtrace$0 = hum_backtrace(backtrace),
     exn_str = Sexplib0_Sexp_conv[70].call(null, exn),
     sep = Stdlib_String[15].call(null, exn_str, 10) ? cst$9 : cst$10,
     g = string_of_module_descr(0),
     h = Stdlib_String[29].call(null, descr$0);
    return caml_call5
            (eprintf_or_delay(Stdlib[98].call(null, w, v)),
             h,
             sep,
             exn_str,
             backtrace$0,
             g);
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var
      a = match[2],
      match$0 = a[2],
      variant = match$0[1],
      which_tests = a[1];
     if(1025081494 > variant){
      var
       where_to_list = match$0[2],
       f =
         function(fout){
          var a = all(0), b = Stdlib_Printf[1].call(null, fout, J);
          return Stdlib_List[18].call(null, b, a);
         };
      if(where_to_list){
       var file = where_to_list[1], i = Stdlib[62].call(null, I, 0, file);
       Base_Exn[12].call(null, f, i, Stdlib[76]);
      }
      else
       f(Stdlib[39]);
      return 0;
     }
     var match$1 = log[1];
     if(match$1){var ch = match$1[1]; Stdlib[76].call(null, ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], match$2 = test_modules_failed[1];
     if(0 === count && 0 === match$2){
      if(show_counts[1]){
       var d = test_modules_ran[1], e = tests_ran[1];
       caml_call2(Stdlib_Printf[3].call(null, z), e, d);
      }
      var
       unused_tests =
         Stdlib_List[44].call
          (null,
           function(param){var used = param[3]; return 1 - used[1];},
           which_tests[2]),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       Stdlib_Printf[3].call(null, A);
       Stdlib_List[18].call
        (null,
         function(param){
          var line_number_opt = param[2], filename = param[1];
          if(! line_number_opt)
           return caml_call1(Stdlib_Printf[3].call(null, C), filename);
          var line_number = line_number_opt[1];
          return caml_call2
                  (Stdlib_Printf[3].call(null, B), filename, line_number);
         },
         tests);
       Stdlib_Printf[3].call(null, D);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       Stdlib_Printf[3].call(null, E);
       return 2;
      }
      return 0;
     }
     if(0 === match$2)
      var b = cst$11;
     else
      var
       h = Stdlib[98].call(null, H, G),
       b = caml_call1(Stdlib_Printf[4].call(null, h), match$2);
     var g = tests_ran[1];
     caml_call3(Stdlib_Printf[3].call(null, F), count, g, b);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var c = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if(Stdlib_Filename[13].call(null, c) === "inline_tests_runner.exe"){Stdlib_Printf[3].call(null, x); break a;}
     }
     Stdlib_Printf[3].call(null, y);
    }
    return 2;
   }
   function assert_test_configs_initialize(config){
    var a = 1 - already_initialized[1];
    if(! a) return a;
    var b = caml_call1(Stdlib_Printf[4].call(null, K), config);
    return Stdlib[2].call(null, b);
   }
   function use_color$0(param){
    assert_test_configs_initialize(cst_use_color);
    return use_color[1];
   }
   function in_place$0(param){
    assert_test_configs_initialize(cst_in_place$0);
    return in_place[1];
   }
   function diff_command$0(param){
    assert_test_configs_initialize(cst_diff_command);
    return diff_command[1];
   }
   function diff_path_prefix$0(param){
    assert_test_configs_initialize(cst_diff_path_prefix$0);
    return diff_path_prefix[1];
   }
   function source_tree_root$0(param){
    assert_test_configs_initialize(cst_source_tree_root$0);
    return source_tree_root[1];
   }
   var evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var b = Stdlib_List[10].call(null, evaluators[1]);
    switch
     (combine_all
       (Stdlib_List[20].call(null, function(f){return caml_call1(f, 0);}, b))){
      case 0:
       var a = 0; break;
      case 1:
       var a = 2; break;
      default: var a = 1;
    }
    return Stdlib[99].call(null, a);
   }
   var
    Ppx_inline_test_lib =
      [0,
       am_running,
       am_running_env_var,
       testing,
       init,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       use_color$0,
       in_place$0,
       diff_command$0,
       diff_path_prefix$0,
       source_tree_root$0,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (137, Ppx_inline_test_lib, cst_Ppx_inline_test_lib$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2lubGluZV90ZXN0X2xpYi5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InBweF9pbmxpbmVfdGVzdF9saWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfaW5saW5lX3Rlc3QvcnVudGltZS1saWIvcHB4X2lubGluZV90ZXN0X2xpYi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBUZXN0X3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU3VjY2Vzc1xuICAgIHwgRmFpbHVyZVxuICAgIHwgRXJyb3JcblxuICBsZXQgdG9fZXhpdF9jb2RlID0gZnVuY3Rpb25cbiAgICB8IFN1Y2Nlc3MgLT4gMFxuICAgIHwgRmFpbHVyZSAtPiAyXG4gICAgfCBFcnJvciAtPiAxXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IFwic3VjY2Vzc1wiXG4gICAgfCBGYWlsdXJlIC0+IFwiZmFpbHVyZVwiXG4gICAgfCBFcnJvciAtPiBcImVycm9yXCJcbiAgOztcblxuICBsZXQgY29tYmluZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFN1Y2Nlc3MsIFN1Y2Nlc3MgLT4gU3VjY2Vzc1xuICAgIHwgRXJyb3IsIF8gfCBfLCBFcnJvciAtPiBFcnJvclxuICAgIHwgRmFpbHVyZSwgXyB8IF8sIEZhaWx1cmUgLT4gRmFpbHVyZVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbCB0cyA9IExpc3QuZm9sZF9sZWZ0IGNvbWJpbmUgU3VjY2VzcyB0c1xuZW5kXG5cbnR5cGUgZGVzY3IgPSBzdHJpbmdcblxubGV0IGFscmVhZHlfaW5pdGlhbGl6ZWQgPSByZWYgZmFsc2VcbmxldCB0ZXN0X21vZHVsZXNfcmFuID0gcmVmIDBcbmxldCB0ZXN0X21vZHVsZXNfZmFpbGVkID0gcmVmIDBcbmxldCB0ZXN0c19yYW4gPSByZWYgMFxubGV0IHRlc3RzX2ZhaWxlZCA9IHJlZiAwXG5sZXQgZHluYW1pY19saWIgOiBzdHJpbmcgb3B0aW9uIHJlZiA9IHJlZiBOb25lXG5cbnR5cGUgZmlsZW5hbWUgPSBzdHJpbmdcbnR5cGUgbGluZV9udW1iZXIgPSBpbnRcbnR5cGUgc3RhcnRfcG9zID0gaW50XG50eXBlIGVuZF9wb3MgPSBpbnRcbnR5cGUgY29uZmlnID0gKG1vZHVsZSBJbmxpbmVfdGVzdF9jb25maWcuUylcblxudHlwZSAnYSB0ZXN0X2Z1bmN0aW9uX2FyZ3MgPVxuICBjb25maWc6Y29uZmlnXG4gIC0+IGRlc2NyOmRlc2NyIExhenkudFxuICAtPiB0YWdzOnN0cmluZyBsaXN0XG4gIC0+IGZpbGVuYW1lOmZpbGVuYW1lXG4gIC0+IGxpbmVfbnVtYmVyOmxpbmVfbnVtYmVyXG4gIC0+IHN0YXJ0X3BvczpzdGFydF9wb3NcbiAgLT4gZW5kX3BvczplbmRfcG9zXG4gIC0+ICdhXG5cbm1vZHVsZSBUYWdfcHJlZGljYXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyByZXF1aXJlZF90YWdzIDogc3RyaW5nIGxpc3RcbiAgICA7IGRyb3BwZWRfdGFncyA6IHN0cmluZyBsaXN0XG4gICAgfVxuXG4gIGxldCBpbml0aWFsID0geyByZXF1aXJlZF90YWdzID0gW107IGRyb3BwZWRfdGFncyA9IFsgXCJkaXNhYmxlZFwiIF0gfVxuXG4gIGxldCBkcm9wIHQgdGFnID1cbiAgICB7IGRyb3BwZWRfdGFncyA9IHRhZyA6OiB0LmRyb3BwZWRfdGFnc1xuICAgIDsgcmVxdWlyZWRfdGFncyA9IExpc3QuZmlsdGVyICgoIDw+ICkgdGFnKSB0LnJlcXVpcmVkX3RhZ3NcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHJlcXVpcmUgdCB0YWcgPVxuICAgIHsgZHJvcHBlZF90YWdzID0gTGlzdC5maWx0ZXIgKCggPD4gKSB0YWcpIHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gdGFnIDo6IHQucmVxdWlyZWRfdGFnc1xuICAgIH1cbiAgOztcblxuICBsZXQgZW50aXJlX21vZHVsZV9kaXNhYmxlZCB0IH5wYXJ0aWFsX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbiAgOztcblxuICBsZXQgZGlzYWJsZWQgdCB+Y29tcGxldGVfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHJlcSAtPiBub3QgKExpc3QubWVtIHJlcSB0YWdzKSkgdC5yZXF1aXJlZF90YWdzXG4gICAgfHwgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbiAgOztcbmVuZFxuXG5tb2R1bGUgV2hlcmVfdG9fbGlzdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU3Rkb3V0XG4gICAgfCBGaWxlIG9mIHN0cmluZ1xuZW5kXG5cbnR5cGUgd2hpY2hfdGVzdHMgPVxuICB7IGxpYm5hbWUgOiBzdHJpbmdcbiAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gOiAoZmlsZW5hbWUgKiBsaW5lX251bWJlciBvcHRpb24gKiBib29sIHJlZikgbGlzdFxuICA7IG5hbWVfZmlsdGVyIDogc3RyaW5nIGxpc3RcbiAgOyB3aGljaF90YWdzIDogVGFnX3ByZWRpY2F0ZS50XG4gIH1cblxudHlwZSB0ZXN0X21vZGUgPVxuICB7IHdoaWNoX3Rlc3RzIDogd2hpY2hfdGVzdHNcbiAgOyB3aGF0X3RvX2RvIDogWyBgUnVuX3BhcnRpdGlvbiBvZiBzdHJpbmcgb3B0aW9uIHwgYExpc3RfcGFydGl0aW9ucyBvZiBXaGVyZV90b19saXN0LnQgXVxuICB9XG5cbm1vZHVsZSBBY3Rpb24gOiBzaWdcbiAgdHlwZSB0ID1cbiAgICBbIGBJZ25vcmVcbiAgICB8IGBUZXN0X21vZGUgb2YgdGVzdF9tb2RlXG4gICAgXVxuXG4gIHZhbCBnZXQgOiB1bml0IC0+IHRcbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICAgIF1cblxuICBsZXQgYWN0aW9uIDogdCByZWYgPSByZWYgYElnbm9yZVxuXG4gIGxldCBmb3JjZV9kcm9wID1cbiAgICB0cnlcbiAgICAgIGlnbm9yZSAoU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIiA6IHN0cmluZyk7XG4gICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGdldCAoKSA9XG4gICAgKCogVGhpcyBpcyB1c2VmdWwgd2hlbiBjb21waWxpbmcgdG8gamF2YXNjcmlwdC5cbiAgICAgICBKc19vZl9vY2FtbCBjYW4gc3RhdGljYWxseSBldmFsdWF0ZSBbU3lzLmdldGVudiBcIkZPUkNFX0RST1BfSU5MSU5FX1RFU1RcIl1cbiAgICAgICBhbmQgaW5saW5lIHRoZSByZXN1bHQgKFtgSWdub3JlXSkgd2hlbmV2ZXIgW2dldCAoKV0gaXMgY2FsbGVkLlxuICAgICAgIFVuaXQgdGVzdHMgY2FuIHRoZW4gYmUgdHJlYXRlZCBhcyBkZWFkY29kZSBzaW5jZSB0aGUgYXJndW1lbnQgW2ZdIG9mIHRoZSBbdGVzdF1cbiAgICAgICBmdW5jdGlvbiBiZWxvdyBpcyBuZXZlciB1c2VkLiAqKVxuICAgIGlmIGZvcmNlX2Ryb3AgdGhlbiBgSWdub3JlIGVsc2UgIWFjdGlvblxuICA7O1xuXG4gIGxldCBzZXQgdiA9IGFjdGlvbiA6PSB2XG5lbmRcblxubW9kdWxlIFBhcnRpdGlvbiA6IHNpZ1xuICB2YWwgZm91bmRfdGVzdCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgc2V0X2N1cnJlbnQgOiBzdHJpbmcgLT4gdW5pdFxuICB2YWwgaXNfY3VycmVudCA6IHN0cmluZyBvcHRpb24gLT4gYm9vbFxuICB2YWwgYWxsIDogdW5pdCAtPiBzdHJpbmcgbGlzdFxuZW5kID0gc3RydWN0XG4gIGxldCBhbGwgPSBIYXNodGJsLmNyZWF0ZSAyM1xuICBsZXQgY3VycmVudCA9IHJlZiBcIlwiXG4gIGxldCBzZXRfY3VycmVudCB4ID0gY3VycmVudCA6PSB4XG5cbiAgbGV0IGZvdW5kX3Rlc3QgKCkgPVxuICAgIGlmICFjdXJyZW50IDw+IFwiXCIgJiYgbm90IChIYXNodGJsLm1lbSBhbGwgIWN1cnJlbnQpIHRoZW4gSGFzaHRibC5hZGQgYWxsICFjdXJyZW50ICgpXG4gIDs7XG5cbiAgbGV0IGlzX2N1cnJlbnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIHAgLT4gcCA9ICFjdXJyZW50XG4gIDs7XG5cbiAgbGV0IGFsbCAoKSA9IExpc3Quc29ydCBTdHJpbmcuY29tcGFyZSAoSGFzaHRibC5mb2xkIChmdW4gayAoKSBhY2MgLT4gayA6OiBhY2MpIGFsbCBbXSlcbmVuZFxuXG5tb2R1bGUgTW9kdWxlX2NvbnRleHQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIG9uZV9tb2R1bGUgPVxuICAgICAgeyBkZXNjciA6IHN0cmluZ1xuICAgICAgOyB0YWdzIDogc3RyaW5nIGxpc3RcbiAgICAgIH1cblxuICAgIHR5cGUgdCA9IG9uZV9tb2R1bGUgbGlzdFxuXG4gICAgbGV0IGRlc2NyIHQgPSBMaXN0Lm1hcCAoZnVuIG0gLT4gbS5kZXNjcikgdFxuICAgIGxldCB0YWdzIHQgPSBMaXN0LmNvbmNhdCAoTGlzdC5tYXAgKGZ1biBtIC0+IG0udGFncykgdClcbiAgZW5kXG5cbiAgbGV0IGN1cnJlbnQgOiBULnQgcmVmID0gcmVmIFtdXG5cbiAgbGV0IHdpdGhfIH5kZXNjciB+dGFncyBmID1cbiAgICBsZXQgcHJldiA9ICFjdXJyZW50IGluXG4gICAgY3VycmVudCA6PSB7IFQuZGVzY3I7IHRhZ3MgfSA6OiBwcmV2O1xuICAgIHRyeVxuICAgICAgbGV0IHggPSBmICgpIGluXG4gICAgICBjdXJyZW50IDo9IHByZXY7XG4gICAgICB4XG4gICAgd2l0aFxuICAgIHwgZSAtPlxuICAgICAgY3VycmVudCA6PSBwcmV2O1xuICAgICAgcmFpc2UgZVxuICA7O1xuXG4gIGxldCBjdXJyZW50X2Rlc2NyICgpID0gVC5kZXNjciAhY3VycmVudFxuICBsZXQgY3VycmVudF90YWdzICgpID0gVC50YWdzICFjdXJyZW50XG5lbmRcblxubGV0IHZlcmJvc2UgPSByZWYgZmFsc2VcbmxldCBzdHJpY3QgPSByZWYgZmFsc2VcbmxldCBzaG93X2NvdW50cyA9IHJlZiBmYWxzZVxubGV0IGxpc3RfdGVzdF9uYW1lcyA9IHJlZiBmYWxzZVxubGV0IGRlbGF5ZWRfZXJyb3JzID0gcmVmIFtdXG5sZXQgc3RvcF9vbl9lcnJvciA9IHJlZiBmYWxzZVxubGV0IGxvZyA9IHJlZiBOb25lXG5sZXQgdGltZV9zZWMgPSByZWYgMC5cbmxldCB1c2VfY29sb3IgPSByZWYgdHJ1ZVxubGV0IGluX3BsYWNlID0gcmVmIGZhbHNlXG5sZXQgZGlmZl9jb21tYW5kID0gcmVmIE5vbmVcbmxldCBzb3VyY2VfdHJlZV9yb290ID0gcmVmIE5vbmVcbmxldCBkaWZmX3BhdGhfcHJlZml4ID0gcmVmIE5vbmVcblxubGV0IGRpc3BsYXllZF9kZXNjciBkZXNjciBmaWxlbmFtZSBsaW5lIHN0YXJ0X3BvcyBlbmRfcG9zID1cbiAgbGV0IChsYXp5IGRlc2NyKSA9IGRlc2NyIGluXG4gIFByaW50Zi5zcHJpbnRmXG4gICAgXCJGaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkJXNcIlxuICAgIGZpbGVuYW1lXG4gICAgbGluZVxuICAgIHN0YXJ0X3Bvc1xuICAgIGVuZF9wb3NcbiAgICAoaWYgZGVzY3IgPSBcIlwiIHRoZW4gXCJcIiBlbHNlIFwiOiBcIiBeIGRlc2NyKVxuOztcblxubGV0IHBhcnNlX2Rlc2NyIHN0ciA9XG4gIHRyeVxuICAgIFNvbWVcbiAgICAgIChTY2FuZi5zc2NhbmZcbiAgICAgICAgIHN0clxuICAgICAgICAgXCIgRmlsZSAlUyAsIGxpbmUgJWQgLCBjaGFyYWN0ZXJzICVkIC0gJWQgJSFcIlxuICAgICAgICAgKGZ1biBmaWxlIGxpbmUgX3N0YXJ0X3BvcyBfZW5kX3BvcyAtPiBmaWxlLCBTb21lIGxpbmUpKVxuICB3aXRoXG4gIHwgXyAtPlxuICAgICh0cnlcbiAgICAgICBTb21lIChTY2FuZi5zc2NhbmYgc3RyIFwiIEZpbGUgJVMgLCBsaW5lICVkICUhXCIgKGZ1biBmaWxlIGxpbmUgLT4gZmlsZSwgU29tZSBsaW5lKSlcbiAgICAgd2l0aFxuICAgICB8IF8gLT5cbiAgICAgICAodHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAlIVwiIChmdW4gZmlsZSAtPiBmaWxlLCBOb25lKSkgd2l0aFxuICAgICAgICB8IF8gLT4gTm9uZSkpXG47O1xuXG5sZXQgcGFyc2VfYXJndiA/Y3VycmVudCBhcmdzID1cbiAgbWF0Y2ggYXJncyB3aXRoXG4gIHwgbmFtZVxuICAgIDo6IFwiaW5saW5lLXRlc3QtcnVubmVyXCIgKCogd2hlbiB3ZSBzZWUgdGhpcyBhcmd1bWVudCwgd2Ugc3dpdGNoIHRvIHRlc3QgbW9kZSAqKVxuICAgIDo6IGxpYlxuICAgIDo6IHJlc3QgLT5cbiAgICAoKiBpbml0aWFsaXphdGlvbiBzaG91bGQgb25seSBvY2N1ciBvbmNlICopXG4gICAgaWYgIWFscmVhZHlfaW5pdGlhbGl6ZWRcbiAgICB0aGVuXG4gICAgICByYWlzZVxuICAgICAgICAoQXJnLkJhZFxuICAgICAgICAgICBcIlRoZSBpbmxpbmUgdGVzdCBydW5uZXIgY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgb25jZSwgYW5kIGhhcyBhbHJlYWR5IGJlZW4gXFxcbiAgICAgICAgICAgIGluaXRpYWxpemVkLlwiKTtcbiAgICBhbHJlYWR5X2luaXRpYWxpemVkIDo9IHRydWU7XG4gICAgbGV0IHRlc3RzID0gcmVmIFtdIGluXG4gICAgbGV0IGxpc3RfcGFydGl0aW9ucyA9IChyZWYgTm9uZSA6IFdoZXJlX3RvX2xpc3QudCBvcHRpb24gcmVmKSBpblxuICAgIGxldCBwYXJ0aXRpb24gPSByZWYgTm9uZSBpblxuICAgIGxldCB0YWdfcHJlZGljYXRlID0gcmVmIFRhZ19wcmVkaWNhdGUuaW5pdGlhbCBpblxuICAgIGxldCBuYW1lX2ZpbHRlciA9IHJlZiBbXSBpblxuICAgIEFyZy5wYXJzZV9hcmd2XG4gICAgICA/Y3VycmVudFxuICAgICAgKEFycmF5Lm9mX2xpc3QgKG5hbWUgOjogcmVzdCkpXG4gICAgICAoQXJnLmFsaWduXG4gICAgICAgICBbICggXCItbGlzdC10ZXN0LW5hbWVzXCJcbiAgICAgICAgICAgLCBBcmcuVW5pdFxuICAgICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICBsaXN0X3Rlc3RfbmFtZXMgOj0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgdmVyYm9zZSA6PSB0cnVlKVxuICAgICAgICAgICAsIFwiIERvIG5vdCBydW4gdGVzdHMgYnV0IHNob3cgd2hhdCB3b3VsZCBoYXZlIGJlZW4gcnVuXCIgKVxuICAgICAgICAgOyAoIFwiLWxpc3QtcGFydGl0aW9uc1wiXG4gICAgICAgICAgICwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gU29tZSBTdGRvdXQpXG4gICAgICAgICAgICwgXCIgTGlzdHMgYWxsIHRoZSBwYXJ0aXRpb25zIHRoYXQgY29udGFpbiBhdCBsZWFzdCBvbmUgdGVzdCBvciB0ZXN0X21vZHVsZVwiIClcbiAgICAgICAgIDsgKCBcIi1saXN0LXBhcnRpdGlvbnMtaW50by1maWxlXCJcbiAgICAgICAgICAgLCBBcmcuU3RyaW5nIChmdW4gZmlsZSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gU29tZSAoRmlsZSBmaWxlKSlcbiAgICAgICAgICAgLCBcIiBMaXN0cyBhbGwgdGhlIHBhcnRpdGlvbnMgdGhhdCBjb250YWluIGF0IGxlYXN0IG9uZSB0ZXN0IG9yIHRlc3RfbW9kdWxlIFxcXG4gICAgICAgICAgICAgIGludG8gRklMRVwiIClcbiAgICAgICAgIDsgKCBcIi1wYXJ0aXRpb25cIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBpIC0+IHBhcnRpdGlvbiA6PSBTb21lIGkpXG4gICAgICAgICAgICwgXCIgT25seSBydW4gdGhlIHRlc3RzIGluIHRoZSBnaXZlbiBwYXJ0aXRpb25cIiApXG4gICAgICAgICA7IFwiLXZlcmJvc2VcIiwgQXJnLlNldCB2ZXJib3NlLCBcIiBTaG93IHRoZSB0ZXN0cyBhcyB0aGV5IHJ1blwiXG4gICAgICAgICA7ICggXCItc3RvcC1vbi1lcnJvclwiXG4gICAgICAgICAgICwgQXJnLlNldCBzdG9wX29uX2Vycm9yXG4gICAgICAgICAgICwgXCIgUnVuIHRlc3RzIG9ubHkgdXAgdG8gdGhlIGZpcnN0IGVycm9yIChkb2Vzbid0IHdvcmsgZm9yIGV4cGVjdCB0ZXN0cylcIiApXG4gICAgICAgICA7IFwiLXN0cmljdFwiLCBBcmcuU2V0IHN0cmljdCwgXCIgRW5kIHdpdGggYW4gZXJyb3IgaWYgbm8gdGVzdHMgd2VyZSBydW5cIlxuICAgICAgICAgOyBcIi1zaG93LWNvdW50c1wiLCBBcmcuU2V0IHNob3dfY291bnRzLCBcIiBTaG93IHRoZSBudW1iZXIgb2YgdGVzdHMgcmFuXCJcbiAgICAgICAgIDsgKCBcIi1sb2dcIlxuICAgICAgICAgICAsIEFyZy5Vbml0XG4gICAgICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICh0cnkgU3lzLnJlbW92ZSBcImlubGluZV90ZXN0cy5sb2dcIiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IF8gLT4gKCkpO1xuICAgICAgICAgICAgICAgICBsb2cgOj0gU29tZSAob3Blbl9vdXQgXCJpbmxpbmVfdGVzdHMubG9nXCIpKVxuICAgICAgICAgICAsIFwiIExvZyB0aGUgdGVzdHMgcnVuIGluIGlubGluZV90ZXN0cy5sb2dcIiApXG4gICAgICAgICA7ICggXCItZHJvcC10YWdcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5kcm9wICF0YWdfcHJlZGljYXRlIHMpXG4gICAgICAgICAgICwgXCJ0YWcgT25seSBydW4gdGVzdHMgbm90IHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLXJlcXVpcmUtdGFnKVwiXG4gICAgICAgICAgIClcbiAgICAgICAgIDsgKCBcIi1yZXF1aXJlLXRhZ1wiXG4gICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gdGFnX3ByZWRpY2F0ZSA6PSBUYWdfcHJlZGljYXRlLnJlcXVpcmUgIXRhZ19wcmVkaWNhdGUgcylcbiAgICAgICAgICAgLCBcInRhZyBPbmx5IHJ1biB0ZXN0cyB0YWdnZWQgd2l0aCBbdGFnXSAob3ZlcnJpZGVzIHByZXZpb3VzIC1kcm9wLXRhZylcIiApXG4gICAgICAgICA7ICggXCItbWF0Y2hpbmdcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IG5hbWVfZmlsdGVyIDo9IHMgOjogIW5hbWVfZmlsdGVyKVxuICAgICAgICAgICAsIFwic3Vic3RyaW5nIE9ubHkgcnVuIHRlc3RzIHdob3NlIG5hbWVzIGNvbnRhaW4gdGhlIGdpdmVuIHN1YnN0cmluZ1wiIClcbiAgICAgICAgIDsgKCBcIi1vbmx5LXRlc3RcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmdcbiAgICAgICAgICAgICAgIChmdW4gcyAtPlxuICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUsIGluZGV4ID1cbiAgICAgICAgICAgICAgICAgICBtYXRjaCBwYXJzZV9kZXNjciBzIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IFNvbWUgKGZpbGUsIGluZGV4KSAtPiBmaWxlLCBpbmRleFxuICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHMgJzonXG4gICAgICAgICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnOicgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gU3RyaW5nLnN1YiBzIDAgaSBpblxuICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXhfc3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuc3ViIHMgKGkgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gaSAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgaW5kZXhfc3RyaW5nIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICB8IEZhaWx1cmUgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFyZy5CYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXJndW1lbnQgJXMgZG9lc24ndCBmaXQgdGhlIGZvcm1hdCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWVbOmxpbmVfbnVtYmVyXVxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlIVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMpKVxuICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSwgU29tZSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgIGVsc2UgcywgTm9uZVxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICB0ZXN0cyA6PSAoZmlsZW5hbWUsIGluZGV4LCByZWYgZmFsc2UpIDo6ICF0ZXN0cylcbiAgICAgICAgICAgLCBcImxvY2F0aW9uIFJ1biBvbmx5IHRoZSB0ZXN0cyBzcGVjaWZpZWQgYnkgYWxsIHRoZSAtb25seS10ZXN0IG9wdGlvbnMuXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICBMb2NhdGlvbnMgY2FuIGJlIG9uZSBvZiB0aGVzZSBmb3JtczpcXG5cXFxuICAgICAgICAgICAgIFxcICAgICAgICAgICAgICAgICAgICAgIC0gZmlsZS5tbFxcblxcXG4gICAgICAgICAgICAgXFwgICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sOmxpbmVfbnVtYmVyXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzXFxuXFxcbiAgICAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzLCBjaGFyYWN0ZXJzIDItM1wiIClcbiAgICAgICAgIDsgXCItbm8tY29sb3JcIiwgQXJnLkNsZWFyIHVzZV9jb2xvciwgXCIgU3VtbWFyaXplIHRlc3RzIHdpdGhvdXQgdXNpbmcgY29sb3JcIlxuICAgICAgICAgOyBcIi1pbi1wbGFjZVwiLCBBcmcuU2V0IGluX3BsYWNlLCBcIiBVcGRhdGUgZXhwZWN0IHRlc3RzIGluIHBsYWNlXCJcbiAgICAgICAgIDsgKCBcIi1kaWZmLWNtZFwiXG4gICAgICAgICAgICwgQXJnLlN0cmluZyAoZnVuIHMgLT4gZGlmZl9jb21tYW5kIDo9IFNvbWUgcylcbiAgICAgICAgICAgLCBcIiBEaWZmIGNvbW1hbmQgZm9yIHRlc3RzIHRoYXQgcmVxdWlyZSBkaWZmaW5nICh1c2UgLSB0byBkaXNhYmxlIGRpZmZpbmcpXCIgKVxuICAgICAgICAgOyAoIFwiLXNvdXJjZS10cmVlLXJvb3RcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHNvdXJjZV90cmVlX3Jvb3QgOj0gU29tZSBzKVxuICAgICAgICAgICAsIFwiIFBhdGggdG8gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZSB0cmVlXCIgKVxuICAgICAgICAgOyAoIFwiLWRpZmYtcGF0aC1wcmVmaXhcIlxuICAgICAgICAgICAsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IGRpZmZfcGF0aF9wcmVmaXggOj0gU29tZSBzKVxuICAgICAgICAgICAsIFwiIFByZWZpeCB0byBwcmVwZW5kIHRvIGZpbGVwYXRocyBpbiB0ZXN0IG91dHB1dFwiIClcbiAgICAgICAgIF0pXG4gICAgICAoZnVuIGFub24gLT5cbiAgICAgICAgcmFpc2VcbiAgICAgICAgICAoQXJnLkJhZCAoUHJpbnRmLnNwcmludGYgXCIlczogdW5leHBlY3RlZCBhbm9ueW1vdXMgYXJndW1lbnQgJXNcXG4lIVwiIG5hbWUgYW5vbikpKVxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiJXMgJXMgJXMgW2FyZ3NdXCIgbmFtZSBcImlubGluZS10ZXN0LXJ1bm5lclwiIGxpYik7XG4gICAgQWN0aW9uLnNldFxuICAgICAgKGBUZXN0X21vZGVcbiAgICAgICAgeyB3aGljaF90ZXN0cyA9XG4gICAgICAgICAgICB7IGxpYm5hbWUgPSBsaWJcbiAgICAgICAgICAgIDsgb25seV90ZXN0X2xvY2F0aW9uID0gIXRlc3RzXG4gICAgICAgICAgICA7IHdoaWNoX3RhZ3MgPSAhdGFnX3ByZWRpY2F0ZVxuICAgICAgICAgICAgOyBuYW1lX2ZpbHRlciA9ICFuYW1lX2ZpbHRlclxuICAgICAgICAgICAgfVxuICAgICAgICA7IHdoYXRfdG9fZG8gPVxuICAgICAgICAgICAgKG1hdGNoICFsaXN0X3BhcnRpdGlvbnMgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSB3aGVyZV90b19saXN0IC0+IGBMaXN0X3BhcnRpdGlvbnMgd2hlcmVfdG9fbGlzdFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBgUnVuX3BhcnRpdGlvbiAhcGFydGl0aW9uKVxuICAgICAgICB9KVxuICB8IF8gLT4gKClcbjs7XG5cbmxldCAoKSA9XG4gIGlmIEJhc2UuRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMuYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICB0cnkgcGFyc2VfYXJndiAoQXJyYXkudG9fbGlzdCBTeXMuYXJndikgd2l0aFxuICAgIHwgQXJnLkJhZCBtc2cgLT5cbiAgICAgIFByaW50Zi5lcHJpbnRmIFwiJXNcIiBtc2c7XG4gICAgICBleGl0IDFcbiAgICB8IEFyZy5IZWxwIG1zZyAtPlxuICAgICAgUHJpbnRmLnByaW50ZiBcIiVzXCIgbXNnO1xuICAgICAgZXhpdCAwKVxuOztcblxubGV0IGluaXQgYXJncyA9XG4gIGxldCBjdXJyZW50ID0gcmVmIDAgaW5cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiB+Y3VycmVudCBhcmdzO1xuICAgIE9rIE5vbmVcbiAgd2l0aFxuICB8IEFyZy5CYWQgbXNnIC0+IEVycm9yIG1zZ1xuICB8IEFyZy5IZWxwIG1zZyAtPiBPayAoU29tZSBtc2cpXG47O1xuXG5sZXQgYW1fdGVzdF9ydW5uZXIgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgVGVzdF9tb2RlIF8gLT4gdHJ1ZVxuICB8IGBJZ25vcmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBhbV9ydW5uaW5nX2Vudl92YXIgPVxuICAoKiBmb3IgYXBwcm94aW1hdGUgY29tcGF0aWJpbGl0eSwgZ2l2ZW4gdGhhdCB0aGUgdmFyaWFibGUgaXMgbm90IGV4YWN0bHkgZXF1aXZhbGVudFxuICAgICB0byB3aGF0IFBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVCB1c2VkIHRvIGJlICopXG4gIFwiVEVTVElOR19GUkFNRVdPUktcIlxuOztcblxuKCogVGhpcyB2YWx1ZSBpcyBkZXByZWNhdGVkIGluIHByaW5jaXBsZSwgaW4gZmF2b3Igb2YgQ29yZS5hbV9ydW5uaW5nX3Rlc3QsIHNvXG4gICB3ZSdyZSBnb2luZyB0byBsaXZlIHdpdGggdGhlIHVnbHkgcGF0dGVybiBtYXRjaC4gKilcbmxldCBhbV9ydW5uaW5nID1cbiAgbWF0Y2ggU3lzLmdldGVudiBcIlBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVFwiIHdpdGhcbiAgfCAoXyA6IHN0cmluZykgLT5cbiAgICB0cnVlICgqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggcGVvcGxlIHNldHRpbmcgdGhpcyB2YXJpYWJsZSBkaXJlY3RseSAqKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAobWF0Y2ggU3lzLmdldGVudiBhbV9ydW5uaW5nX2Vudl92YXIgd2l0aFxuICAgICB8IFwiaW5saW5lLXRlc3RcIiAtPiB0cnVlXG4gICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBmYWxzZVxuICAgICB8IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgdGVzdGluZyA9XG4gIGlmIGFtX3Rlc3RfcnVubmVyXG4gIHRoZW4gYFRlc3RpbmcgYEFtX3Rlc3RfcnVubmVyXG4gIGVsc2UgaWYgYW1fcnVubmluZ1xuICB0aGVuIGBUZXN0aW5nIGBBbV9jaGlsZF9vZl90ZXN0X3J1bm5lclxuICBlbHNlIGBOb3RfdGVzdGluZ1xuOztcblxuKCogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGludDYzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIG5hbm9zIHNpbmNlXG4gICBzb21lIChmaXhlZCkgYmFzZWxpbmUuICBPbiB1bml4LCB0aGlzIGJhc2VsaW5lIHdpbGwgYmUgdGhlIHVuaXggZXBvY2gsXG4gICBhbmQgaW4gamF2YXNjcmlwdCwgdGhlIGJhc2VsaW5lIHdpbGwgYmUgXCJwcm9ncmFtIGluaXRpYWxpemF0aW9uIHRpbWUuXCJcbiAgIFJlZ2FyZGxlc3MsIGl0J3MgYWx3YXlzIHNhZmUgdG8gc3VidHJhY3QgdHdvIHZhbHVlcyBhbmQgdXNlIHRoZSBkaWZmLFxuICAgd2hpY2ggaXMgYWxsIHRoYXQgcHB4X2lubGluZV90ZXN0X2xpYiB1c2VzIGl0IGZvci4gKilcbmxldCB0aW1lc3RhbXBfbnMgKCkgPSBUaW1lX25vdy5uYW5vc2Vjb25kX2NvdW50ZXJfZm9yX3RpbWluZyAoKVxuXG5sZXQgd2hlcmVfdG9fY3V0X2JhY2t0cmFjZSA9XG4gIGxhenlcbiAgICAoQmFzZS5TdHJpbmcuU2VhcmNoX3BhdHRlcm4uY3JlYXRlXG4gICAgICAgKF9fTU9EVUxFX18gXiBcIi5cIiBeIFwidGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNcIikpXG47O1xuXG5sZXQgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBiZWZvcmVfbnMgPSB0aW1lc3RhbXBfbnMgKCkgaW5cbiAgbGV0IHJlcyA9XG4gICAgKCogVG8gYXZvaWQgbm9pc2UgaW4gYmFja3RyYWNlcywgd2UgZG8gdHdvIHRoaW5ncy5cblxuICAgICAgIFdlIHVzZSBbd2hlcmVfdG9fY3V0X2JhY2t0cmFjZV0gYWJvdmUgdG8gcmVtb3ZlIHRoZSBzdGFjayBmcmFtZXMgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgZnVuY3Rpb24gYW5kIGFueSBmdW5jdGlvbiBpdCBnZXRzIGlubGluZWQgaW50bywgYXMgaXQncyBub3Qgb2YgYW55IGludGVyZXN0IHRvIHRoZVxuICAgICAgIHVzZXIsIHNpbmNlIGl0J3Mgbm90IHRhbGtpbmcgYWJvdXQgdGhlaXIgdGVzdCBidXQgaW5zdGVhZCB0YWxraW5nIGFib3V0IHRoZVxuICAgICAgIHBweF9pbmxpbmVfdGVzdCBtYWNoaW5lcnkuXG5cbiAgICAgICBXZSBhbHNvIGF2b2lkIGluc2VydGluZyBhbnkgY29kZSBiZXR3ZWVuIHRoZSBbZl0gdGhhdCBjb21lcyBmcm9tIHRoZSB1c2VyJ3MgZmlsZVxuICAgICAgIGFuZCBncmFiYmluZyB0aGUgYmFja3RyYWNlIGZyb20gaXRzIGV4Y2VwdGlvbnMgKG5vIHdyYXBwaW5nIG9mIFtmXSB3aXRoIGhpZ2ggb3JkZXJcbiAgICAgICBmdW5jdGlvbnMgbGlrZSBFeG4ucHJvdGVjdCwgb3IgKGZ1biAoKSAtPiBmICgpOyB0cnVlKSkuICopXG4gICAgdHJ5IE9rIChmICgpKSB3aXRoXG4gICAgfCBleG4gLT4gRXJyb3IgKGV4biwgUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgaW5cbiAgdGltZV9zZWMgOj0gQmFzZS5JbnQ2My4odGltZXN0YW1wX25zICgpIC0gYmVmb3JlX25zIHw+IHRvX2Zsb2F0KSAvLiAxZTk7XG4gIHJlc1xuOztcblxubGV0IHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlID0gbGF6eSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDEwMDsgMjAwOyAzMDAgfF0pXG5sZXQgc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUgPSBsYXp5IChCYXNlLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDExMTsgMjIyOyAzMzMgfF0pXG5cbmxldCB0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBjYW1sX3JhbmRvbV9zdGF0ZSA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gIGxldCBiYXNlX3JhbmRvbV9zdGF0ZSA9IEJhc2UuUmFuZG9tLlN0YXRlLmNvcHkgQmFzZS5SYW5kb20uU3RhdGUuZGVmYXVsdCBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSk7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSk7XG4gIGxldCByZXN1bHQgPSB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmIGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIGNhbWxfcmFuZG9tX3N0YXRlO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgYmFzZV9yYW5kb21fc3RhdGU7XG4gIHJlc3VsdFxuOztcblxubGV0IHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgXCJcIlxuICAgIChMaXN0Lm1hcFxuICAgICAgIChmdW4gcyAtPiBcIiAgaW4gVEVTXCIgXiBcIlRfTU9EVUxFIGF0IFwiIF4gU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBzIF4gXCJcXG5cIilcbiAgICAgICAoTW9kdWxlX2NvbnRleHQuY3VycmVudF9kZXNjciAoKSkpXG47O1xuXG5sZXQgcG9zaXRpb25fbWF0Y2ggZGVmX2ZpbGVuYW1lIGRlZl9saW5lX251bWJlciBsID1cbiAgTGlzdC5leGlzdHNcbiAgICAoZnVuIChmaWxlbmFtZSwgbGluZV9udW1iZXJfb3B0LCB1c2VkKSAtPlxuICAgICAgbGV0IHBvc2l0aW9uX3N0YXJ0ID0gU3RyaW5nLmxlbmd0aCBkZWZfZmlsZW5hbWUgLSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgICBsZXQgZm91bmQgPVxuICAgICAgICBwb3NpdGlvbl9zdGFydCA+PSAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBlbmRfb2ZfZGVmX2ZpbGVuYW1lID1cbiAgICAgICAgICBTdHJpbmcuc3ViIGRlZl9maWxlbmFtZSBwb3NpdGlvbl9zdGFydCAoU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSlcbiAgICAgICAgaW5cbiAgICAgICAgZW5kX29mX2RlZl9maWxlbmFtZSA9IGZpbGVuYW1lXG4gICAgICAgICYmIChwb3NpdGlvbl9zdGFydCA9IDAgfHwgZGVmX2ZpbGVuYW1lLltwb3NpdGlvbl9zdGFydCAtIDFdID0gJy8nKVxuICAgICAgICAmJlxuICAgICAgICBtYXRjaCBsaW5lX251bWJlcl9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgbGluZV9udW1iZXIgLT4gZGVmX2xpbmVfbnVtYmVyID0gbGluZV9udW1iZXJcbiAgICAgIGluXG4gICAgICBpZiBmb3VuZCB0aGVuIHVzZWQgOj0gdHJ1ZTtcbiAgICAgIGZvdW5kKVxuICAgIGxcbjs7XG5cbmxldCBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgZGVzY3IgPVxuICBtYXRjaCBuYW1lX2ZpbHRlciB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gOjogXyAtPlxuICAgIExpc3QuZXhpc3RzIChmdW4gc3Vic3RyaW5nIC0+IEJhc2UuU3RyaW5nLmlzX3N1YnN0cmluZyB+c3Vic3RyaW5nIGRlc2NyKSBuYW1lX2ZpbHRlclxuOztcblxubGV0IHByaW50X2RlbGF5ZWRfZXJyb3JzICgpID1cbiAgbWF0Y2ggTGlzdC5yZXYgIWRlbGF5ZWRfZXJyb3JzIHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IF8gOjogXyBhcyBkZWxheWVkX2Vycm9ycyAtPlxuICAgIFByaW50Zi5lcHJpbnRmIFwiXFxuJXNcXG4lIVwiIChTdHJpbmcubWFrZSA3MCAnPScpO1xuICAgIExpc3QuaXRlciAoZnVuIG1lc3NhZ2UgLT4gUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgbWVzc2FnZSkgZGVsYXllZF9lcnJvcnNcbjs7XG5cbmxldCBlcHJpbnRmX29yX2RlbGF5IGZtdCA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIChmdW4gcyAtPlxuICAgICAgaWYgIXZlcmJvc2UgdGhlbiBkZWxheWVkX2Vycm9ycyA6PSBzIDo6ICFkZWxheWVkX2Vycm9ycyBlbHNlIFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIHM7XG4gICAgICBpZiAhc3RvcF9vbl9lcnJvclxuICAgICAgdGhlbiAoXG4gICAgICAgIHByaW50X2RlbGF5ZWRfZXJyb3JzICgpO1xuICAgICAgICBleGl0IDIpKVxuICAgIGZtdFxuOztcblxubGV0IGFkZF9ob29rcyAoKG1vZHVsZSBDKSA6IGNvbmZpZykgZiAoKSA9XG4gIEMucHJlX3Rlc3RfaG9vayAoKTtcbiAgZiAoKVxuOztcblxubGV0IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlID1cbiAgbGV0IG9wZW4gQmFzZSBpblxuICBiYWNrdHJhY2VcbiAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gIHw+IExpc3QudGFrZV93aGlsZSB+ZjooZnVuIHN0ciAtPlxuICAgICAgIG5vdCAoU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLm1hdGNoZXMgKGZvcmNlIHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UpIHN0cikpXG4gIHw+IExpc3QubWFwIH5mOihmdW4gc3RyIC0+IFwiICBcIiBeIHN0ciBeIFwiXFxuXCIpXG4gIHw+IFN0cmluZy5jb25jYXRcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X2lubmVyXG4gIH5jb25maWdcbiAgfmRlc2NyXG4gIH50YWdzXG4gIH5maWxlbmFtZTpkZWZfZmlsZW5hbWVcbiAgfmxpbmVfbnVtYmVyOmRlZl9saW5lX251bWJlclxuICB+c3RhcnRfcG9zXG4gIH5lbmRfcG9zXG4gIGZcbiAgYm9vbF9vZl9mXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbjsgd2hpY2hfdGFnczsgbmFtZV9maWx0ZXIgfVxuICAgICAgOyB3aGF0X3RvX2RvXG4gICAgICB9IC0+XG4gICAgbGV0IGYgPSBhZGRfaG9va3MgY29uZmlnIGYgaW5cbiAgICBsZXQgZGVzY3IgPVxuICAgICAgbGF6eSAoZGlzcGxheWVkX2Rlc2NyIGRlc2NyIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgc3RhcnRfcG9zIGVuZF9wb3MpXG4gICAgaW5cbiAgICBsZXQgY29tcGxldGVfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICYmIChtYXRjaCBvbmx5X3Rlc3RfbG9jYXRpb24gd2l0aFxuICAgICAgICAgIHwgW10gLT4gdHJ1ZVxuICAgICAgICAgIHwgXyA6OiBfIC0+IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgb25seV90ZXN0X2xvY2F0aW9uKVxuICAgICAgJiYgKG5vdCAoVGFnX3ByZWRpY2F0ZS5kaXNhYmxlZCB3aGljaF90YWdzIH5jb21wbGV0ZV90YWdzKSlcbiAgICAgICYmIG5hbWVfZmlsdGVyX21hdGNoIH5uYW1lX2ZpbHRlciAoTGF6eS5mb3JjZSBkZXNjcilcbiAgICBpblxuICAgIGlmIHNob3VsZF9ydW5cbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHdoYXRfdG9fZG8gd2l0aFxuICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIF8gLT4gUGFydGl0aW9uLmZvdW5kX3Rlc3QgKClcbiAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gcGFydGl0aW9uIC0+XG4gICAgICAgIGlmIFBhcnRpdGlvbi5pc19jdXJyZW50IHBhcnRpdGlvblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZGVzY3IgPSBMYXp5LmZvcmNlIGRlc2NyIGluXG4gICAgICAgICAgaW5jciB0ZXN0c19yYW47XG4gICAgICAgICAgKG1hdGNoICFsb2cgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgfCBTb21lIGNoIC0+IFByaW50Zi5mcHJpbnRmIGNoIFwiJXNcXG4lc1wiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSk7XG4gICAgICAgICAgaWYgIXZlcmJvc2UgdGhlbiBQcmludGYucHJpbnRmIFwiJXMlIVwiIGRlc2NyO1xuICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgaWYgIWxpc3RfdGVzdF9uYW1lc1xuICAgICAgICAgICAgdGhlbiBPayB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIFNlZSBbdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNdIGZvciB3aHkgd2UgdXNlIFtib29sX29mX2ZdXG4gICAgICAgICAgICAgICAgIHJhdGhlciBoYXZlIHRoZSBjYWxsZXIgd3JhcCBbZl0gdG8gYWRqdXN0IGl0cyByZXR1cm4gdmFsdWUuICopXG4gICAgICAgICAgICAgIFJlc3VsdC5tYXAgYm9vbF9vZl9mICh0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIElmICFsaXN0X3Rlc3RfbmFtZXMsIHRoaXMgaXMgaXMgYSBoYXJtbGVzcyB6ZXJvLiAqKVxuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiAoJS4zZiBzZWMpXFxuJSFcIiAhdGltZV9zZWM7XG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIHRydWUgLT4gKClcbiAgICAgICAgICB8IE9rIGZhbHNlIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyBpcyBmYWxzZS5cXG4lc1xcbiUhXCIgZGVzY3IgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXlcbiAgICAgICAgICAgICAgXCIlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCJcbiAgICAgICAgICAgICAgZGVzY3JcbiAgICAgICAgICAgICAgc2VwXG4gICAgICAgICAgICAgIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlXG4gICAgICAgICAgICAgIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKSkpXG47O1xuXG5sZXQgc2V0X2xpYl9hbmRfcGFydGl0aW9uIHN0YXRpY19saWIgcGFydGl0aW9uID1cbiAgbWF0Y2ggIWR5bmFtaWNfbGliIHdpdGhcbiAgfCBTb21lIF8gLT5cbiAgICAoKiBwb3NzaWJsZSBpZiB0aGUgaW50ZXJmYWNlIGlzIHVzZWQgZXhwbGljaXRseSBvciBpZiB3ZSBoYXBwZW4gdG8gZHlubGluayBzb21ldGhpbmdcbiAgICAgICB0aGF0IGNvbnRhaW4gdGVzdHMgKilcbiAgICAoKVxuICB8IE5vbmUgLT5cbiAgICBkeW5hbWljX2xpYiA6PSBTb21lIHN0YXRpY19saWI7XG4gICAgKG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICAgICB8IGBJZ25vcmUgLT4gKClcbiAgICAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHM7IHdoYXRfdG9fZG8gfSAtPlxuICAgICAgIGlmIHdoaWNoX3Rlc3RzLmxpYm5hbWUgPSBzdGF0aWNfbGliXG4gICAgICAgdGhlbiAoXG4gICAgICAgICBsZXQgcmVxdWlyZXNfcGFydGl0aW9uID1cbiAgICAgICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICAgICAgIHwgYExpc3RfcGFydGl0aW9ucyBfIHwgYFJ1bl9wYXJ0aXRpb24gKFNvbWUgXykgLT4gdHJ1ZVxuICAgICAgICAgICB8IGBSdW5fcGFydGl0aW9uIE5vbmUgLT4gZmFsc2VcbiAgICAgICAgIGluXG4gICAgICAgICBpZiBwYXJ0aXRpb24gPSBcIlwiICYmIHJlcXVpcmVzX3BhcnRpdGlvblxuICAgICAgICAgdGhlblxuICAgICAgICAgICBmYWlsd2l0aFxuICAgICAgICAgICAgIFwicHB4X2lubGluZV90ZXN0OiBjYW5ub3QgdXNlIC1saXN0LXBhcnRpdGlvbiBvciAtcGFydGl0aW9uIHdpdGhvdXQgXFxcbiAgICAgICAgICAgICAgc3BlY2lmeWluZyBhIHBhcnRpdGlvbiBhdCBwcmVwcm9jZXNzaW5nIHRpbWVcIlxuICAgICAgICAgZWxzZSBQYXJ0aXRpb24uc2V0X2N1cnJlbnQgcGFydGl0aW9uKSlcbjs7XG5cbmxldCB1bnNldF9saWIgc3RhdGljX2xpYiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIG5vdCBnaXZpbmcgYW4gZXJyb3IsIGJlY2F1c2Ugd2hlbiBzb21lIGFubm95aW5nIHBlb3BsZSBwdXQgcGFfb3VuaXQgaW4gdGhlaXIgbGlzdFxuICAgICAgIG9mIHByZXByb2Nlc3NvcnMsIHBhX291bml0IGlzIHNldCB1cCB0d2ljZSBhbmQgd2UgaGF2ZSB0d28gY2FsbHMgdG8gdW5zZXRfbGliIGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgZmlsZSwgYW5kIHRoZSBzZWNvbmQgb25lIGNvbWVzIGluIHRoaXMgYnJhbmNoICopXG4gICAgKClcbiAgfCBTb21lIGxpYiAtPiBpZiBsaWIgPSBzdGF0aWNfbGliIHRoZW4gZHluYW1pY19saWIgOj0gTm9uZVxuOztcblxubGV0IHRlc3QgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgPVxuICB0ZXN0X2lubmVyIH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmIChmdW4gYiAtPlxuICAgIGIpXG47O1xuXG5sZXQgdGVzdF91bml0IH5jb25maWcgfmRlc2NyIH50YWdzIH5maWxlbmFtZSB+bGluZV9udW1iZXIgfnN0YXJ0X3BvcyB+ZW5kX3BvcyBmID1cbiAgdGVzdF9pbm5lciB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiAoZnVuICgpIC0+XG4gICAgdHJ1ZSlcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X21vZHVsZVxuICB+Y29uZmlnXG4gIH5kZXNjclxuICB+dGFnc1xuICB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lXG4gIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgfnN0YXJ0X3Bvc1xuICB+ZW5kX3Bvc1xuICBmXG4gID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGVcbiAgICAgIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbiA9IF87IG5hbWVfZmlsdGVyID0gXzsgd2hpY2hfdGFncyB9XG4gICAgICA7IHdoYXRfdG9fZG9cbiAgICAgIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciAoKSA9IGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zIGluXG4gICAgbGV0IHBhcnRpYWxfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICgqIElmLCBubyBtYXR0ZXIgd2hhdCB0YWdzIGEgdGVzdCBkZWZpbmVzLCB3ZSBjZXJ0YWlubHkgd2lsbCBkcm9wIGFsbCB0ZXN0cyB3aXRoaW5cbiAgICAgICAgIHRoaXMgbW9kdWxlLCB0aGVuIGRvbid0IHJ1biB0aGUgbW9kdWxlIGF0IGFsbC4gVGhpcyBtZWFucyBwZW9wbGUgY2FuIHdyaXRlXG4gICAgICAgICB0aGluZ3MgbGlrZSB0aGUgZm9sbG93aW5nIHdpdGhvdXQgYnJlYWtpbmcgdGhlIDMyLWJpdCBidWlsZDpcbiAgICAgICAgIGxldCV0ZXN0X21vZHVsZSBbQHRhZ3MgXCI2NC1iaXRzLW9ubHlcIl0gPSAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgbGV0IGkgPSBJbnQ2NC50b19pbnRfZXhuIC4uLi5cbiAgICAgICAgIGVuZClcbiAgICAgICAgIFdlIGRvbid0IHNob3J0Y3V0IGJhc2VkIG9uIHBvc2l0aW9uLCBhcyB3ZSBjYW4ndCB0ZWxsIHdoYXQgcG9zaXRpb25zIHRoZVxuICAgICAgICAgaW5uZXIgdGVzdHMgd2lsbCBoYXZlLiAqKVxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmVudGlyZV9tb2R1bGVfZGlzYWJsZWQgd2hpY2hfdGFncyB+cGFydGlhbF90YWdzKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1blxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICB8IGBMaXN0X3BhcnRpdGlvbnMgXyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICAgICBsZXQgZGVzY3IgPSBkZXNjciAoKSBpblxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBNb2R1bGVfY29udGV4dC53aXRoXyB+ZGVzY3IgfnRhZ3MgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAoKiBXZSBkbyBub3QgcmVzZXQgcmFuZG9tIHN0YXRlcyB1cG9uIGVudGVyaW5nIFtsZXQldGVzdF9tb2R1bGVdLlxuXG4gICAgICAgICAgICAgICAgIENvbjogQ29kZSBpbiB0ZXN0IG1vZHVsZXMgY2FuIGFjY2lkZW50YWxseSBkZXBlbmQgb24gdG9wLWxldmVsIHJhbmRvbVxuICAgICAgICAgICAgICAgICBzdGF0ZSBlZmZlY3RzLlxuXG4gICAgICAgICAgICAgICAgIFByb3M6ICgxKSBXZSBkb24ndCByZXNldCB0byB0aGUgc2FtZSBzZWVkIG9uIGVudGVyaW5nIGEgW2xldCV0ZXN0X21vZHVsZV1cbiAgICAgICAgICAgICAgICAgYW5kIHRoZW4gYSBbbGV0JXRlc3RdIGluc2lkZSB0aGF0IG1vZHVsZSwgd2hpY2ggY291bGQgbGVhZCB0b1xuICAgICAgICAgICAgICAgICBhY2NpZGVudGFsbHkgcmFuZG9tbHkgZ2VuZXJhdGluZyB0aGUgc2FtZSB2YWx1ZXMgaW4gc29tZSB0ZXN0LiAoMikgTW92aW5nXG4gICAgICAgICAgICAgICAgIGNvZGUgaW50byBhbmQgb3V0IG9mIFtsZXQldGVzdF9tb2R1bGVdIGRvZXMgbm90IGNoYW5nZSBpdHMgcmFuZG9tIHNlZWQuXG4gICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgIHRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzIGYpXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgICAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgICAgICAgIGluY3IgdGVzdF9tb2R1bGVzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXlcbiAgICAgICAgICAgICAgKFwiVEVTXCIgXl4gXCJUX01PRFVMRSBhdCAlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIpXG4gICAgICAgICAgICAgIChTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIGRlc2NyKVxuICAgICAgICAgICAgICBzZXBcbiAgICAgICAgICAgICAgZXhuX3N0clxuICAgICAgICAgICAgICBiYWNrdHJhY2VcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpKSlcbjs7XG5cbmxldCBzdW1tYXJpemUgKCkgPVxuICBtYXRjaCBBY3Rpb24uZ2V0ICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+XG4gICAgaWYgU3lzLmFyZ3YgPD4gW3x8XSAmJiBGaWxlbmFtZS5iYXNlbmFtZSBTeXMuYXJndi4oMCkgPSBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlXCJcbiAgICB0aGVuXG4gICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBydW4gYnkgaGFuZCwgeW91IFxcblxcXG4gICAgICAgICBzaG91bGQgcnVuIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCBpbnN0ZWFkLlxcblxcXG4gICAgICAgICAlIVwiXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgXCJZb3UgYXJlIGRvaW5nIHNvbWV0aGluZyB1bmV4cGVjdGVkIHdpdGggdGhlIHRlc3RzLiBObyB0ZXN0cyBoYXZlIFxcblxcXG4gICAgICAgICBiZWVuIHJ1bi4gWW91IHNob3VsZCB1c2UgdGhlIGlubGluZV90ZXN0c19ydW5uZXIgc2NyaXB0IHRvIHJ1biBcXG5cXFxuICAgICAgICAgdGVzdHMuXFxuXFxcbiAgICAgICAgICUhXCI7XG4gICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSBfOyB3aGF0X3RvX2RvID0gYExpc3RfcGFydGl0aW9ucyB3aGVyZV90b19saXN0IH0gLT5cbiAgICBsZXQgd2l0aF9vdXRfY2hhbm5lbCBmID1cbiAgICAgIG1hdGNoIHdoZXJlX3RvX2xpc3Qgd2l0aFxuICAgICAgfCBTdGRvdXQgLT4gZiBzdGRvdXRcbiAgICAgIHwgRmlsZSBmaWxlIC0+XG4gICAgICAgICgqIE5vdCBwYXNzaW5nIE9wZW5fY3JlYXQgZW5zdXJlcyB0aGF0IHRoZSBmaWxlIHdlIGFyZSBzdXBwb3NlZCB0byB3cml0ZSB0byBleGlzdHMgKilcbiAgICAgICAgb3Blbl9vdXRfZ2VuIFsgT3Blbl93cm9ubHk7IE9wZW5fdGV4dCBdIDAgZmlsZVxuICAgICAgICB8PiBCYXNlLkV4bi5wcm90ZWN0eCB+ZiB+ZmluYWxseTpjbG9zZV9vdXRcbiAgICBpblxuICAgIHdpdGhfb3V0X2NoYW5uZWwgKGZ1biBmb3V0IC0+XG4gICAgICBMaXN0Lml0ZXIgKFByaW50Zi5mcHJpbnRmIGZvdXQgXCIlc1xcblwiKSAoUGFydGl0aW9uLmFsbCAoKSkpO1xuICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgfCBgVGVzdF9tb2RlIHsgd2hhdF90b19kbyA9IGBSdW5fcGFydGl0aW9uIF87IHdoaWNoX3Rlc3RzIH0gLT5cbiAgICAobWF0Y2ggIWxvZyB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKVxuICAgICB8IFNvbWUgY2ggLT4gY2xvc2Vfb3V0IGNoKTtcbiAgICBwcmludF9kZWxheWVkX2Vycm9ycyAoKTtcbiAgICAobWF0Y2ggIXRlc3RzX2ZhaWxlZCwgIXRlc3RfbW9kdWxlc19mYWlsZWQgd2l0aFxuICAgICB8IDAsIDAgLT5cbiAgICAgICBpZiAhc2hvd19jb3VudHNcbiAgICAgICB0aGVuXG4gICAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgICBcIiVkIHRlc3RzIHJhbiwgJWQgdGVzdF9tb2R1bGVzIHJhblxcbiUhXCJcbiAgICAgICAgICAgIXRlc3RzX3JhblxuICAgICAgICAgICAhdGVzdF9tb2R1bGVzX3JhbjtcbiAgICAgICBsZXQgZXJyb3JzID1cbiAgICAgICAgIGxldCB1bnVzZWRfdGVzdHMgPVxuICAgICAgICAgICBMaXN0LmZpbHRlciAoZnVuIChfLCBfLCB1c2VkKSAtPiBub3QgIXVzZWQpIHdoaWNoX3Rlc3RzLm9ubHlfdGVzdF9sb2NhdGlvblxuICAgICAgICAgaW5cbiAgICAgICAgIG1hdGNoIHVudXNlZF90ZXN0cyB3aXRoXG4gICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgIHwgXyA6OiBfIC0+IFNvbWUgdW51c2VkX3Rlc3RzXG4gICAgICAgaW5cbiAgICAgICAobWF0Y2ggZXJyb3JzIHdpdGhcbiAgICAgICAgfCBTb21lIHRlc3RzIC0+XG4gICAgICAgICAgUHJpbnRmLmVwcmludGZcbiAgICAgICAgICAgIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiB0aGUgZm9sbG93aW5nIC1vbmx5LXRlc3QgZmxhZ3MgbWF0Y2hlZCBub3RoaW5nOlwiO1xuICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgKGZ1biAoZmlsZW5hbWUsIGxpbmVfbnVtYmVyX29wdCwgXykgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzXCIgZmlsZW5hbWVcbiAgICAgICAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IFByaW50Zi5lcHJpbnRmIFwiICVzOiVkXCIgZmlsZW5hbWUgbGluZV9udW1iZXIpXG4gICAgICAgICAgICB0ZXN0cztcbiAgICAgICAgICBQcmludGYuZXByaW50ZiBcIi5cXG4lIVwiO1xuICAgICAgICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGlmICF0ZXN0c19yYW4gPSAwICYmICFzdHJpY3RcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiBubyB0ZXN0cyBoYXZlIGJlZW4gcnVuLlxcbiUhXCI7XG4gICAgICAgICAgICBUZXN0X3Jlc3VsdC5FcnJvcilcbiAgICAgICAgICBlbHNlIFRlc3RfcmVzdWx0LlN1Y2Nlc3MpXG4gICAgIHwgY291bnQsIGNvdW50X3Rlc3RfbW9kdWxlcyAtPlxuICAgICAgIFByaW50Zi5lcHJpbnRmXG4gICAgICAgICBcIkZBSUxFRCAlZCAvICVkIHRlc3RzJXNcXG4lIVwiXG4gICAgICAgICBjb3VudFxuICAgICAgICAgIXRlc3RzX3JhblxuICAgICAgICAgKGlmIGNvdW50X3Rlc3RfbW9kdWxlcyA9IDBcbiAgICAgICAgICB0aGVuIFwiXCJcbiAgICAgICAgICBlbHNlIFByaW50Zi5zcHJpbnRmIChcIiwgJWQgVEVTXCIgXl4gXCJUX01PRFVMRVNcIikgY291bnRfdGVzdF9tb2R1bGVzKTtcbiAgICAgICBUZXN0X3Jlc3VsdC5GYWlsdXJlKVxuOztcblxubGV0IGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgY29uZmlnID1cbiAgaWYgbm90ICFhbHJlYWR5X2luaXRpYWxpemVkXG4gIHRoZW5cbiAgICBQcmludGYuc3ByaW50ZlxuICAgICAgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IGF0dGVtcHRlZCB0byBhY2Nlc3MgdGhlIFslc10gY29uZmlnIGJlZm9yZSBbaW5pdF0gd2FzIFxcXG4gICAgICAgY2FsbGVkXCJcbiAgICAgIGNvbmZpZ1xuICAgIHw+IGZhaWx3aXRoXG47O1xuXG5sZXQgdXNlX2NvbG9yICgpID1cbiAgYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplZCBcInVzZV9jb2xvclwiO1xuICAhdXNlX2NvbG9yXG47O1xuXG5sZXQgaW5fcGxhY2UgKCkgPVxuICBhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemVkIFwiaW5fcGxhY2VcIjtcbiAgIWluX3BsYWNlXG47O1xuXG5sZXQgZGlmZl9jb21tYW5kICgpID1cbiAgYXNzZXJ0X3Rlc3RfY29uZmlnc19pbml0aWFsaXplZCBcImRpZmZfY29tbWFuZFwiO1xuICAhZGlmZl9jb21tYW5kXG47O1xuXG5sZXQgZGlmZl9wYXRoX3ByZWZpeCAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJkaWZmX3BhdGhfcHJlZml4XCI7XG4gICFkaWZmX3BhdGhfcHJlZml4XG47O1xuXG5sZXQgc291cmNlX3RyZWVfcm9vdCAoKSA9XG4gIGFzc2VydF90ZXN0X2NvbmZpZ3NfaW5pdGlhbGl6ZWQgXCJzb3VyY2VfdHJlZV9yb290XCI7XG4gICFzb3VyY2VfdHJlZV9yb290XG47O1xuXG5sZXQgZXZhbHVhdG9ycyA9IHJlZiBbIHN1bW1hcml6ZSBdXG5sZXQgYWRkX2V2YWx1YXRvciB+ZiA9IGV2YWx1YXRvcnMgOj0gZiA6OiAhZXZhbHVhdG9yc1xuXG5sZXQgZXhpdCAoKSA9XG4gIExpc3QubWFwIChmdW4gZiAtPiBmICgpKSAoTGlzdC5yZXYgIWV2YWx1YXRvcnMpXG4gIHw+IFRlc3RfcmVzdWx0LmNvbWJpbmVfYWxsXG4gIHw+IFRlc3RfcmVzdWx0LnRvX2V4aXRfY29kZVxuICB8PiBleGl0XG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjc3RfbGluZSIsImNzdF9GaWxlIiwiY3N0X3RocmV3IiwiY3N0X3MiLCJjc3RfUHB4X2lubGluZV90ZXN0X2xpYiIsImNzdF9URVMiLCJjc3RfVEVTVElOR19GUkFNRVdPUksiLCJjc3RfVF9NT0RVTEVfYXQiLCJjc3RfVF9NT0RVTEVTIiwiY3N0X2lubGluZV90ZXN0X3J1bm5lciIsImNzdF9pbmxpbmVfdGVzdHNfbG9nIiwiY3N0X3BweF9pbmxpbmVfdGVzdF9lcnJvcl90aGVfIiwiY2FtbF9lcXVhbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfb2JqX3RhZyIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX3N5c19nZXRlbnYiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsImluaXRpYWwiLCJhbV9ydW5uaW5nX2Vudl92YXIiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYiIsIlN0ZGxpYl9QcmludGYiLCJCYXNlX0V4biIsIlN0ZGxpYl9GaWxlbmFtZSIsIlNleHBsaWIwX1NleHBfY29udiIsIlN0ZGxpYl9TdHJpbmciLCJDYW1saW50ZXJuYWxMYXp5IiwiU3RkbGliX1Jlc3VsdCIsIkJhc2UiLCJCYXNlX1N0cmluZyIsIkJhc2VfTGlzdCIsIlN0ZGxpYl9SYW5kb20iLCJCYXNlX1JhbmRvbSIsIlN0ZGxpYl9QcmludGV4YyIsIkJhc2VfSW50NjMiLCJUaW1lX25vdyIsIlN0ZGxpYl9BcmciLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfU2NhbmYiLCJTdGRsaWJfSGFzaHRibCIsImNzdF9zdWNjZXNzIiwiY3N0X2ZhaWx1cmUiLCJjc3RfZXJyb3IiLCJ0b19zdHJpbmciLCJwYXJhbSIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsImFscmVhZHlfaW5pdGlhbGl6ZWQiLCJ0ZXN0X21vZHVsZXNfcmFuIiwidGVzdF9tb2R1bGVzX2ZhaWxlZCIsInRlc3RzX3JhbiIsInRlc3RzX2ZhaWxlZCIsImR5bmFtaWNfbGliIiwiZHJvcCIsInQiLCJ0YWciLCJyZXF1aXJlIiwiYWN0aW9uIiwiY3N0X3NvdXJjZV90cmVlX3Jvb3QiLCJjc3RfZGlmZl9wYXRoX3ByZWZpeCIsImNzdF9kaWZmX2NvbW1hbmQiLCJjc3RfaW5fcGxhY2UiLCJjc3RfdXNlX2NvbG9yIiwiY3N0X3BweF9pbmxpbmVfdGVzdF9jYW5ub3RfdXNlIiwiY3N0X2luX1RFUyIsImNzdF90aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbiIsImNzdF9UaGVfaW5saW5lX3Rlc3RfcnVubmVyX2NhbiIsImNzdF9QcmVmaXhfdG9fcHJlcGVuZF90b19maWxlcCIsImNzdF9QYXRoX3RvX3RoZV9yb290X29mX3RoZV9zbyIsImNzdF9EaWZmX2NvbW1hbmRfZm9yX3Rlc3RzX3RoYSIsImNzdF9kaWZmX2NtZCIsImNzdF9VcGRhdGVfZXhwZWN0X3Rlc3RzX2luX3BsYSIsImNzdF9TdW1tYXJpemVfdGVzdHNfd2l0aG91dF91cyIsImNzdF9ub19jb2xvciIsImNzdF9sb2NhdGlvbl9SdW5fb25seV90aGVfdGVzdCIsImNzdF9vbmx5X3Rlc3QiLCJjc3Rfc3Vic3RyaW5nX09ubHlfcnVuX3Rlc3RzX3ciLCJjc3RfbWF0Y2hpbmciLCJjc3RfdGFnX09ubHlfcnVuX3Rlc3RzX3RhZ2dlZF8iLCJjc3RfcmVxdWlyZV90YWciLCJjc3RfdGFnX09ubHlfcnVuX3Rlc3RzX25vdF90YWciLCJjc3RfZHJvcF90YWciLCJjc3RfTG9nX3RoZV90ZXN0c19ydW5faW5faW5saW4iLCJjc3RfbG9nIiwiY3N0X1Nob3dfdGhlX251bWJlcl9vZl90ZXN0c19yIiwiY3N0X3Nob3dfY291bnRzIiwiY3N0X0VuZF93aXRoX2FuX2Vycm9yX2lmX25vX3RlIiwiY3N0X3N0cmljdCIsImNzdF9SdW5fdGVzdHNfb25seV91cF90b190aGVfZiIsImNzdF9zdG9wX29uX2Vycm9yIiwiY3N0X1Nob3dfdGhlX3Rlc3RzX2FzX3RoZXlfcnVuIiwiY3N0X3ZlcmJvc2UiLCJjc3RfT25seV9ydW5fdGhlX3Rlc3RzX2luX3RoZV8iLCJjc3RfcGFydGl0aW9uIiwiY3N0X0xpc3RzX2FsbF90aGVfcGFydGl0aW9uc190IiwiY3N0X2xpc3RfcGFydGl0aW9uc19pbnRvX2ZpbGUiLCJjc3RfbGlzdF9wYXJ0aXRpb25zIiwiY3N0X0RvX25vdF9ydW5fdGVzdHNfYnV0X3Nob3dfIiwiY3N0X2xpc3RfdGVzdF9uYW1lcyIsImZvcmNlX2Ryb3AiLCJleG4iLCJnZXQiLCJjdXJyZW50IiwiZm91bmRfdGVzdCIsImlzX2N1cnJlbnQiLCJwIiwiYWxsIiwiayIsImFjYyIsImN1cnJlbnRfdGFncyIsIm0iLCJ2ZXJib3NlIiwic3RyaWN0Iiwic2hvd19jb3VudHMiLCJsaXN0X3Rlc3RfbmFtZXMiLCJkZWxheWVkX2Vycm9ycyIsInN0b3Bfb25fZXJyb3IiLCJsb2ciLCJ0aW1lX3NlYyIsInVzZV9jb2xvciIsImluX3BsYWNlIiwiZGlmZl9jb21tYW5kIiwic291cmNlX3RyZWVfcm9vdCIsImRpZmZfcGF0aF9wcmVmaXgiLCJkaXNwbGF5ZWRfZGVzY3IiLCJkZXNjciIsImZpbGVuYW1lIiwibGluZSIsInN0YXJ0X3BvcyIsImVuZF9wb3MiLCJwYXJzZV9kZXNjciIsInN0ciIsImZpbGUiLCJwYXJzZV9hcmd2IiwiYXJncyIsIm5hbWUiLCJtYXRjaCIsInJlc3QiLCJsaWIiLCJ0ZXN0cyIsImxpc3RfcGFydGl0aW9ucyIsInBhcnRpdGlvbiIsInRhZ19wcmVkaWNhdGUiLCJuYW1lX2ZpbHRlciIsImkiLCJzIiwiaW5kZXgiLCJpbmRleF9zdHJpbmciLCJhbm9uIiwid2hlcmVfdG9fbGlzdCIsInYiLCJtc2ciLCJpbml0IiwiYW1fdGVzdF9ydW5uZXIiLCJ2YWwiLCJhbV9ydW5uaW5nIiwidGVzdGluZyIsInRpbWVzdGFtcF9ucyIsIndoZXJlX3RvX2N1dF9iYWNrdHJhY2UiLCJ0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV8iLCJiZWZvcmVfbnMiLCJyZXMiLCJzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSIsInNhdmVkX2Jhc2VfcmFuZG9tX3N0YXRlIiwic3RyaW5nX29mX21vZHVsZV9kZXNjciIsInByaW50X2RlbGF5ZWRfZXJyb3JzIiwibWVzc2FnZSIsImVwcmludGZfb3JfZGVsYXkiLCJmbXQiLCJhZGRfaG9va3MiLCJDIiwiaHVtX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInRlc3RfaW5uZXIiLCJjb25maWciLCJ0YWdzIiwiZGVmX2ZpbGVuYW1lIiwiZGVmX2xpbmVfbnVtYmVyIiwiYm9vbF9vZl9mIiwid2hhdF90b19kbyIsIndoaWNoX3RhZ3MiLCJvbmx5X3Rlc3RfbG9jYXRpb24iLCJsaWJuYW1lIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsInNob3VsZF9ydW4iLCJzdWJzdHJpbmciLCJ2YXJpYW50IiwiY2giLCJyZXN1bHQiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwiZXhuX3N0ciIsInNlcCIsInNldF9saWJfYW5kX3BhcnRpdGlvbiIsInN0YXRpY19saWIiLCJ3aGljaF90ZXN0cyIsInJlcXVpcmVzX3BhcnRpdGlvbiIsInVuc2V0X2xpYiIsInRlc3QiLCJiIiwidGVzdF91bml0IiwidGVzdF9tb2R1bGUiLCJwYXJ0aWFsX3RhZ3MiLCJwcmV2IiwieCIsImUiLCJzdW1tYXJpemUiLCJmb3V0IiwiY291bnQiLCJ1bnVzZWRfdGVzdHMiLCJlcnJvcnMiLCJhc3NlcnRfdGVzdF9jb25maWdzX2luaXRpYWxpemUiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiLCJQcHhfaW5saW5lX3Rlc3RfbGliIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUosU0FBQTtBQUFBLElBQUFLLDRCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUs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
