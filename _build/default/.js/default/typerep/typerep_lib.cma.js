// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Typerep_lib
//# shape: Typerep_lib:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
//# shape: Typerep_lib__Named_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
//# shape: Typerep_lib__Type_equal:[F(2)*,N,F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, 0, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
//# shape: Typerep_lib__Typename:[F(2),N,F(2),F(2),F(2),N,F(1)*,N,F(1)*,F(1)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1)*,F(2),F(2),F(2),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return Stdlib_Hashtbl[28].call(null, a[1]);}
   function name(a){return a[2];}
   var static$ = next("static");
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     a = xs;
     b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var
    hash$0 = Stdlib_Hashtbl[28],
    static$0 = [0, static$, 0],
    cst_Typename_create = "Typename.create",
    cst_Typename_same_witness_exn = "Typename.same_witness_exn";
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){var a = t[1]; return a[2];}
   function create(opt, param){
    var name = opt ? opt[1] : cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : Stdlib[2].call(null, cst_Typename_same_witness_exn);
   }
   var
    Key_table = Stdlib_Hashtbl[26].call(null, [0, equal$0, hash$0]),
    a =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"];
   function Table(X){
    function create(int){return caml_call1(Key_table[1], int);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var a = [0, caml_call2(Key_table[7], table, name)], data = a;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== Base[248] && exn !== Stdlib[8])
       throw caml_maybe_attach_backtrace(exn, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var
     c = uid_b[2],
     b = uid_a[2],
     msg = caml_call2(Stdlib_Printf[4].call(null, a), b, c);
    return Stdlib[2].call(null, msg);
   }
   function Same_witness_exn_1(A, B){
    var
     t = caml_call1(A[1], static$0),
     uid_a = t[1],
     t$0 = caml_call1(B[1], static$0),
     uid_b = t$0[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     t = caml_call2(A[1], static$0, static$0),
     uid_a = t[1],
     t$0 = caml_call2(B[1], static$0, static$0),
     uid_b = t$0[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     t = caml_call3(A[1], static$0, static$0, static$0),
     uid_a = t[1],
     t$0 = caml_call3(B[1], static$0, static$0, static$0),
     uid_b = t$0[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     t = caml_call4(A[1], static$0, static$0, static$0, static$0),
     uid_a = t[1],
     t$0 = caml_call4(B[1], static$0, static$0, static$0, static$0),
     uid_b = t$0[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     t = caml_call5(A[1], static$0, static$0, static$0, static$0, static$0),
     uid_a = t[1],
     t$0 = caml_call5(B[1], static$0, static$0, static$0, static$0, static$0),
     uid_b = t$0[1],
     eq = Typerep_lib_Type_equal[2],
     witness = equal(uid_a, uid_b) ? [0, eq] : fail(uid_a, uid_b);
    return [0, witness];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$0,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a){return [0, uid, [0, a, 0]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c){
         return [0, uid, [0, a, [0, b, [0, c, 0]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d, e){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
        }
        return [0, typename_of_t];
       },
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (10, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
//# shape: Typerep_lib__Variant_and_record_intf:[F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[index + 1];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return Stdlib_Array[18].call(null, f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[index + 1];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return Stdlib_Array[18].call(null, f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
//# shape: Typerep_lib__Std_internal:[N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,N,F(2)*,F(3)*,F(4)*,F(5)*,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = Typerep_lib_Typename[11].call(null, [0, name])[1],
    typename_of_int32 = Typerep_lib_Typename[11].call(null, [0, name$0])[1],
    typename_of_int64 = Typerep_lib_Typename[11].call(null, [0, name$1])[1],
    typename_of_nativeint =
      Typerep_lib_Typename[11].call(null, [0, name$2])[1],
    typename_of_char = Typerep_lib_Typename[11].call(null, [0, name$3])[1],
    typename_of_float = Typerep_lib_Typename[11].call(null, [0, name$4])[1],
    typename_of_string = Typerep_lib_Typename[11].call(null, [0, name$5])[1],
    typename_of_bytes = Typerep_lib_Typename[11].call(null, [0, name$6])[1],
    typename_of_bool = Typerep_lib_Typename[11].call(null, [0, name$7])[1],
    typename_of_unit = Typerep_lib_Typename[11].call(null, [0, name$8])[1],
    M_option = Typerep_lib_Typename[12].call(null, [0, name$9]),
    typename_of_option = M_option[1],
    M_list = Typerep_lib_Typename[12].call(null, [0, name$10]),
    typename_of_list = M_list[1],
    M_array = Typerep_lib_Typename[12].call(null, [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = Typerep_lib_Typename[12].call(null, [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = Typerep_lib_Typename[12].call(null, [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = Typerep_lib_Typename[13].call(null, [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = Typerep_lib_Typename[11].call(null, [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = Typerep_lib_Typename[13].call(null, [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = Typerep_lib_Typename[14].call(null, [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = Typerep_lib_Typename[15].call(null, [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = Typerep_lib_Typename[16].call(null, [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      CamlinternalMod[1].call
       (null,
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]);
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var a = typename_of_t(rep), b = Typerep_lib_Typename[9].call(null, a);
    return caml_call1(Typerep_lib_Typename[8][4], b);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        f = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), f);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        g = caml_call1(Typerep[14], c),
        h = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), h, g);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        i = caml_call1(Typerep[14], d),
        j = caml_call1(Typerep[14], c$0),
        k = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4, caml_call1(Typerep[14], a$1), k, j, i);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        l = caml_call1(Typerep[14], e),
        m = caml_call1(Typerep[14], d$0),
        n = caml_call1(Typerep[14], c$1),
        o = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5, caml_call1(Typerep[14], a$2), o, n, m, l);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = Typerep_lib_Variant_and_record[1].call(null, [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8],
    a = [0, 0],
    b = [0, 0],
    c = [0, 0],
    d = [0, 0],
    e = [0, 0],
    f = [0, 0],
    g = [0, 0],
    h = [0, 0],
    i = [0, 0],
    j = [0, 0],
    k = [0, 0],
    l = [0, 0],
    m = [0, 0],
    n = [0, 0],
    o = [0, 0],
    p = [0, cst_lib_std_internal_ml, 802, 14];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        a = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), a);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return typename_of_t(name);
    }
   }
   function same_witness(t1$2, t2$1){
    var t1 = t1$2, t2 = t2$1;
    a:
    for(;;){
     b:
     {
      if(typeof t1 === "number")
       switch(t1){
         case 0:
          if(typeof t2 === "number"){if(0 === t2) return a; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 1:
          if(typeof t2 === "number"){if(1 === t2) return b; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 2:
          if(typeof t2 === "number"){if(2 === t2) return c; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 3:
          if(typeof t2 === "number"){if(3 === t2) return d; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 4:
          if(typeof t2 === "number"){if(4 === t2) return e; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 5:
          if(typeof t2 === "number"){if(5 === t2) return f; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 6:
          if(typeof t2 === "number"){if(6 === t2) return g; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 7:
          if(typeof t2 === "number"){if(7 === t2) return h; break b;}
          if(9 !== t2[0]) break b;
          break;
         case 8:
          if(typeof t2 === "number"){if(8 === t2) return i; break b;}
          if(9 !== t2[0]) break b;
          break;
         default:
          if(typeof t2 === "number"){if(9 === t2) return j; break b;}
          if(9 !== t2[0]) break b;
       }
      else
       switch(t1[0]){
         case 0:
          var r1 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 0:
             var r2$0 = t2[1], x = same_witness(r1, r2$0); return x ? x : x;
            case 9: break;
            default: break b;
          }
          break;
         case 1:
          var r1$0 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 1:
             var r2$1 = t2[1], x$0 = same_witness(r1$0, r2$1);
             return x$0 ? x$0 : x$0;
            case 9: break;
            default: break b;
          }
          break;
         case 2:
          var r1$1 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 2:
             var r2$2 = t2[1], x$1 = same_witness(r1$1, r2$2);
             return x$1 ? x$1 : x$1;
            case 9: break;
            default: break b;
          }
          break;
         case 3:
          var r1$2 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 3:
             var r2$3 = t2[1], x$2 = same_witness(r1$2, r2$3);
             return x$2 ? x$2 : x$2;
            case 9: break;
            default: break b;
          }
          break;
         case 4:
          var r1$3 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 4:
             var r2$4 = t2[1], x$3 = same_witness(r1$3, r2$4);
             return x$3 ? x$3 : x$3;
            case 9: break;
            default: break b;
          }
          break;
         case 5:
          var D = t1[1], rng1 = D[2], dom1 = D[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 5:
             var
              match = t2[1],
              rng2 = match[2],
              dom2 = match[1],
              match$0 = same_witness(dom1, dom2),
              match$1 = same_witness(rng1, rng2);
             if(match$0 && match$1) return k;
             return 0;
            case 9: break;
            default: break b;
          }
          break;
         case 6:
          var t1$0 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){case 6: break a;case 9: break;default: break b;
          }
          break;
         case 7:
          var r1$4 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 7:
             var
              r2$5 = t2[1],
              F = caml_call1(Typerep[10][1], r2$5),
              G = caml_call1(Typerep[10][1], r1$4);
             return Typerep_lib_Typename[4].call(null, G, F);
            case 9: break;
            default: break b;
          }
          break;
         case 8:
          var r1$5 = t1[1];
          if(typeof t2 === "number") break b;
          switch(t2[0]){
            case 8:
             var
              r2$6 = t2[1],
              H = caml_call1(Typerep[6][1], r2$6),
              I = caml_call1(Typerep[6][1], r1$5);
             return Typerep_lib_Typename[4].call(null, I, H);
            case 9: break;
            default: break b;
          }
          break;
         default:
          var match$20 = t1[1], name1 = match$20[1];
          if(typeof t2 !== "number" && 9 === t2[0]){
           var
            match$21 = t2[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            J = typename_of_t(name2),
            K = typename_of_t(name1),
            x$4 = Typerep_lib_Typename[4].call(null, K, J);
           if(x$4) return x$4;
           if(! r1$7){
            if(! r2$7) return 0;
            var v = r2$7[1], C = caml_obj_tag(v);
            if(250 === C){t2 = v[1]; continue;}
            if(246 !== C && 244 !== C){t2 = v; continue;}
            t2 = CamlinternalLazy[2].call(null, v);
            continue;
           }
           var t = r1$7[1], A = caml_obj_tag(t);
           c:
           if(250 === A)
            var t1$1 = t[1];
           else{
            if(246 !== A && 244 !== A){var t1$1 = t; break c;}
            var t1$1 = CamlinternalLazy[2].call(null, t);
           }
           if(! r2$7){t1 = t1$1; continue;}
           var u = r2$7[1], B = caml_obj_tag(u);
           if(250 === B){t1 = t1$1; t2 = u[1]; continue;}
           if(246 !== B && 244 !== B){t1 = t1$1; t2 = u; continue;}
           t1 = t1$1;
           t2 = CamlinternalLazy[2].call(null, u);
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var s = r1$6[1], z = caml_obj_tag(s);
          if(250 === z){t1 = s[1]; continue;}
          if(246 !== z && 244 !== z){t1 = s; continue;}
          t1 = CamlinternalLazy[2].call(null, s);
          continue;
       }
      var r2 = t2[1][2];
      if(! r2) return 0;
      var q = r2[1], w = caml_obj_tag(q);
      if(250 === w){t2 = q[1]; continue;}
      if(246 !== w && 244 !== w){t2 = q; continue;}
      t2 = CamlinternalLazy[2].call(null, q);
      continue;
     }
     if(typeof t1 === "number"){if(0 !== t1) return 0;}
     else if(9 !== t1[0]) return 0;
     return 0;
    }
    var t2$0 = t2[1];
    switch(t1$0[0]){
      case 0:
       var E = t1$0[1];
       if(0 !== t2$0[0]) return 0;
       var
        match$2 = t2$0[1],
        b2 = match$2[2],
        a2 = match$2[1],
        b1 = E[2],
        a1 = E[1],
        match$3 = same_witness(a1, a2),
        match$4 = same_witness(b1, b2);
       if(match$3 && match$4) return l;
       return 0;
      case 1:
       var y = t1$0[1];
       if(1 !== t2$0[0]) return 0;
       var
        match$5 = t2$0[1],
        c2 = match$5[3],
        b2$0 = match$5[2],
        a2$0 = match$5[1],
        c1 = y[3],
        b1$0 = y[2],
        a1$0 = y[1],
        match$6 = same_witness(a1$0, a2$0),
        match$7 = same_witness(b1$0, b2$0),
        match$8 = same_witness(c1, c2);
       if(match$6 && match$7 && match$8) return m;
       return 0;
      case 2:
       var r = t1$0[1];
       if(2 !== t2$0[0]) return 0;
       var
        match$9 = t2$0[1],
        d2 = match$9[4],
        c2$0 = match$9[3],
        b2$1 = match$9[2],
        a2$1 = match$9[1],
        d1 = r[4],
        c1$0 = r[3],
        b1$1 = r[2],
        a1$1 = r[1],
        match$10 = same_witness(a1$1, a2$1),
        match$11 = same_witness(b1$1, b2$1),
        match$12 = same_witness(c1$0, c2$0),
        match$13 = same_witness(d1, d2);
       if(match$10 && match$11 && match$12 && match$13) return n;
       return 0;
      default:
       var p = t1$0[1];
       if(3 !== t2$0[0]) return 0;
       var
        match$14 = t2$0[1],
        e2 = match$14[5],
        d2$0 = match$14[4],
        c2$1 = match$14[3],
        b2$2 = match$14[2],
        a2$2 = match$14[1],
        e1 = p[5],
        d1$0 = p[4],
        c1$1 = p[3],
        b1$2 = p[2],
        a1$2 = p[1],
        match$15 = same_witness(a1$2, a2$2),
        match$16 = same_witness(b1$2, b2$2),
        match$17 = same_witness(c1$1, c2$1),
        match$18 = same_witness(d1$0, d2$0),
        match$19 = same_witness(e1, e2);
       if(match$15 && match$16 && match$17 && match$18 && match$19) return o;
       return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match) throw caml_maybe_attach_backtrace([0, Assert_failure, p], 1);
    var proof = match[1];
    return proof;
   }
   function head(t$0){
    var t = t$0;
    for(;;){
     if(typeof t !== "number" && 9 === t[0]){
      var c = t[1][2];
      if(c){
       var a = c[1], b = caml_obj_tag(a);
       if(250 === b){t = a[1]; continue;}
       if(246 !== b && 244 !== b){t = a; continue;}
       t = CamlinternalLazy[2].call(null, a);
       continue;
      }
     }
     return t;
    }
   }
   CamlinternalMod[2].call
    (null,
     [0,
      [0,
       [0, [0, 0, 0, 0]],
       [0, [0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       0,
       0,
       0,
       0,
       0]],
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var typerep_of_int = 0, typerep_of_int64 = 2;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    typerep_of_int32 = 1,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9,
    typerep_of_tuple0 = 9,
    value_tuple0 = 0,
    match =
      Base_Int63[118][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
//# shape: Typerep_lib__Typerepable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Stdlib__Obj
//# shape: Typerep_lib__Typerep_obj:[F(1),F(1),F(1)*,F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    a = [0, cst_lib_typerep_obj_ml, 11, 4],
    b = [0, cst_lib_typerep_obj_ml, 9, 4];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
   }
   function hash_variant(s){
    var accu = [0, 0], a = runtime.caml_ml_string_length(s) - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      var c = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + c | 0;
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var
    c = hash_variant("Latency_stats"),
    h = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    g = [0, cst_lib_typerep_obj_ml, 29, 9],
    f = [0, cst_lib_typerep_obj_ml, 49, 2],
    e = [0, cst_lib_typerep_obj_ml, 50, 2];
   if(repr_of_poly_variant(-894644482) !== c)
    throw caml_maybe_attach_backtrace([0, Assert_failure, h], 1);
   var d = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== d)
    throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
   function double_array_value(param){return 0.;}
   function has_double_array_tag(a){
    var b = runtime.caml_obj_tag(a);
    return Stdlib_Obj[17] === b ? 1 : 0;
   }
   var double = [254, 0., 0.], simple = [0, 0., 0.];
   if(! has_double_array_tag(double))
    throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
//# shape: Typerep_lib__Type_generic_intf:[F(1)*]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Base, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
//# shape: Typerep_lib__Type_generic:[[F(1)*],F(2)*,F(1)*,N,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib;
   global_data.Typerep_lib__Type_generic_intf;
   var
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf;
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant),
      a = caml_call1(A[4][2], variant),
      tags =
        Stdlib_Array[1].call
         (null,
          a,
          function(index$0){
           var
            tag$0 = caml_call2(A[4][3], variant, index$0),
            tag = tag$0[1],
            label = caml_call1(A[2][1], tag),
            rep = caml_call1(map, caml_call1(A[2][8], tag)),
            arity = caml_call1(A[2][2], tag),
            args_labels = caml_call1(A[2][3], tag),
            index = caml_call1(A[2][4], tag),
            ocaml_repr = caml_call1(A[2][5], tag),
            tyid = caml_call1(A[2][7], tag),
            param = caml_call1(A[2][6], tag);
           if(0 === param[0])
            var fct = param[1], create = [0, fct];
           else
            var k = param[1], create = [1, k];
           return [0,
                   caml_call1
                    (B[2][9],
                     [0,
                      label,
                      rep,
                      arity,
                      args_labels,
                      index,
                      ocaml_repr,
                      tyid,
                      create])];
          });
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       b = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, b)[b + 1][1],
       c = caml_call1(B[2][7], btag),
       d = caml_call1(A[2][7], atag);
      Typerep_lib_Typename[5].call(null, d, c);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record),
      a = caml_call1(A[8][2], record),
      fields =
        Stdlib_Array[1].call
         (null,
          a,
          function(index$0){
           var
            field$0 = caml_call2(A[8][3], record, index$0),
            field = field$0[1],
            label = caml_call1(A[6][1], field),
            rep = caml_call1(map, caml_call1(A[6][6], field)),
            index = caml_call1(A[6][2], field),
            is_mutable = caml_call1(A[6][4], field),
            tyid = caml_call1(A[6][5], field),
            get = caml_call1(A[6][3], field);
           return [0,
                   caml_call1
                    (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
          });
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        a = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, a)[a + 1][1],
        b = caml_call1(B[6][5], bfield),
        c = caml_call1(A[6][5], afield);
       Typerep_lib_Typename[5].call(null, c, b);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248,
       "Typerep_lib.Type_generic.Ident.Broken_dependency",
       caml_fresh_oo_id(0)],
    c =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    dummy = 0,
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    a = [0, cst_lib_type_generic_ml, 185, 16],
    b = [0, cst_lib_type_generic_ml, 187, 69],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(X){
        function create(a){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          a = Typerep_lib_Typename[9].call(null, name),
          path = caml_call1(Typerep_lib_Typename[8][4], a),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }];
         return [0,
                 function(input){return caml_call1(r[1], input);},
                 r,
                 [0, 0]];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
         if(shared[1] === computation)
          throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       [0],
       function(X){
        var
         required = X[2],
         name = X[1],
         b = Typerep_lib_Typename[8],
         include = Stdlib_Hashtbl[26].call(null, [0, b[2], b[3]]),
         create = include[1],
         replace = include[10],
         mem = include[11],
         d = include[7];
        function find(table, key){
         if(! Stdlib_Lazy[3].call(null, table)) return 0;
         var a = caml_obj_tag(table);
         a:
         if(250 === a)
          var table$0 = table[1];
         else{
          if(246 !== a && 244 !== a){var table$0 = table; break a;}
          var table$0 = CamlinternalLazy[2].call(null, table);
         }
         try{var b = [0, caml_call2(d, table$0, key)]; return b;}
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          if(exn[1] !== Base[248] && exn !== Stdlib[8])
           throw caml_maybe_attach_backtrace(exn, 0);
          return 0;
         }
        }
        var
         check_dependencies =
           required
            ? function
             (uid){
              return Stdlib_List[18].call
                      (null,
                       function(param){
                        var
                         implements$ = param[2],
                         name$0 = param[1],
                         a = 1 - caml_call1(implements$, uid);
                        if(! a) return a;
                        var
                         b = caml_call1(Typerep_lib_Typename[8][4], uid),
                         message =
                           caml_call3(Stdlib_Printf[4].call(null, c), name, name$0, b);
                        Stdlib[53].call(null, message);
                        throw caml_maybe_attach_backtrace
                               ([0, Broken_dependency, message], 1);
                       },
                       required);
             }
            : function(param){};
        function replace$0(table, key, value){
         check_dependencies(key);
         var a = caml_obj_tag(table);
         a:
         if(250 === a)
          var b = table[1];
         else{
          if(246 !== a && 244 !== a){var b = table; break a;}
          var b = CamlinternalLazy[2].call(null, table);
         }
         return caml_call3(replace, b, key, value);
        }
        function mem$0(table, key){
         if(! Stdlib_Lazy[3].call(null, table)) return 0;
         var a = caml_obj_tag(table);
         a:
         if(250 === a)
          var table$0 = table[1];
         else{
          if(246 !== a && 244 !== a){var table$0 = table; break a;}
          var table$0 = CamlinternalLazy[2].call(null, table);
         }
         return caml_call2(mem, table$0, key);
        }
        var
         size = 256,
         table0 = [246, function(a){return caml_call1(create, size);}],
         table1 = [246, function(a){return caml_call1(create, size);}],
         table2 = [246, function(a){return caml_call1(create, size);}],
         table3 = [246, function(a){return caml_call1(create, size);}],
         table4 = [246, function(a){return caml_call1(create, size);}],
         table5 = [246, function(a){return caml_call1(create, size);}];
        function is_registered(uid){
         var b = mem$0(table0, uid);
         if(b)
          var a = b;
         else{
          var c = mem$0(table1, uid);
          if(c)
           var a = c;
          else{
           var d = mem$0(table2, uid);
           if(d)
            var a = d;
           else{
            var e = mem$0(table3, uid);
            if(e)
             var a = e;
            else{
             var f = mem$0(table4, uid);
             if(! f) return mem$0(table5, uid);
             var a = f;
            }
           }
          }
         }
         return a;
        }
        var ident = [0, name, is_registered];
        function Find0(T){
         function compute(param){
          var match = find(table0, Typerep_lib_Typename[9].call(null, T[2]));
          if(! match) return 0;
          var
           rep = match[1],
           witness = Typerep_lib_Typename[5].call(null, rep[2], T[1]),
           L = Typerep_lib_Type_equal[3].call(null, [0]),
           a = rep[3],
           b = caml_call1(L[1], witness);
          return [0, Typerep_lib_Type_equal[1].call(null, b, a)];
         }
         return [0, compute];
        }
        function Find1(T){
         function compute(param){
          var match = find(table1, Typerep_lib_Typename[9].call(null, T[3]));
          if(! match) return 0;
          var
           rep = match[1],
           typename_of_t = T[2],
           Conv =
             Typerep_lib_Typename[18].call
              (null, [0, rep[2]], [0, typename_of_t]),
           L = Typerep_lib_Type_equal[3].call(null, [0]),
           a = rep[3],
           b = caml_call1(L[1], Conv[1][1]);
          return [0, Typerep_lib_Type_equal[1].call(null, b, a)];
         }
         return [0, compute];
        }
        function Find2(T){
         function compute(param){
          var match = find(table2, Typerep_lib_Typename[9].call(null, T[4]));
          if(! match) return 0;
          var
           rep = match[1],
           typename_of_t = T[3],
           Conv =
             Typerep_lib_Typename[19].call
              (null, [0, rep[2]], [0, typename_of_t]),
           L = Typerep_lib_Type_equal[3].call(null, [0]),
           a = rep[3],
           b = caml_call1(L[1], Conv[1][1]);
          return [0, Typerep_lib_Type_equal[1].call(null, b, a)];
         }
         return [0, compute];
        }
        function Find3(T){
         function compute(param){
          var match = find(table3, Typerep_lib_Typename[9].call(null, T[5]));
          if(! match) return 0;
          var
           rep = match[1],
           typename_of_t = T[4],
           Conv =
             Typerep_lib_Typename[20].call
              (null, [0, rep[2]], [0, typename_of_t]),
           L = Typerep_lib_Type_equal[3].call(null, [0]),
           a = rep[3],
           b = caml_call1(L[1], Conv[1][1]);
          return [0, Typerep_lib_Type_equal[1].call(null, b, a)];
         }
         return [0, compute];
        }
        function Find4(T){
         function compute(param){
          var match = find(table4, Typerep_lib_Typename[9].call(null, T[6]));
          if(! match) return 0;
          var
           rep = match[1],
           typename_of_t = T[5],
           Conv =
             Typerep_lib_Typename[21].call
              (null, [0, rep[2]], [0, typename_of_t]),
           L = Typerep_lib_Type_equal[3].call(null, [0]),
           a = rep[3],
           b = caml_call1(L[1], Conv[1][1]);
          return [0, Typerep_lib_Type_equal[1].call(null, b, a)];
         }
         return [0, compute];
        }
        var unit = Typerep_lib_Typename[2];
        function register0(compute){
         var uid = Typerep_lib_Typename[9].call(null, compute[2]);
         return replace$0(table0, uid, compute);
        }
        function register1(compute){
         var
          a = caml_call1(compute[2], unit),
          uid = Typerep_lib_Typename[9].call(null, a);
         return replace$0(table1, uid, compute);
        }
        function register2(compute){
         var
          a = caml_call2(compute[2], unit, unit),
          uid = Typerep_lib_Typename[9].call(null, a);
         return replace$0(table2, uid, compute);
        }
        function register3(compute){
         var
          a = caml_call3(compute[2], unit, unit, unit),
          uid = Typerep_lib_Typename[9].call(null, a);
         return replace$0(table3, uid, compute);
        }
        function register4(compute){
         var
          a = caml_call4(compute[2], unit, unit, unit, unit),
          uid = Typerep_lib_Typename[9].call(null, a);
         return replace$0(table4, uid, compute);
        }
        function register5(compute){
         var
          a = caml_call5(compute[2], unit, unit, unit, unit, unit),
          uid = Typerep_lib_Typename[9].call(null, a);
         return replace$0(table5, uid, compute);
        }
        function register(typerep_of_a, compute){
         var
          typename_of_t =
            caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
         return register0([0, typerep_of_a, typename_of_t, compute]);
        }
        var
         Not_implemented =
           [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
         Memo = Typerep_lib_Typename[17].call(null, [0]),
         a = Typerep_lib_Std_internal[1],
         Helper$0 =
           Helper
            ([0, a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10]],
             [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
        function of_typerep(rep){
         var
          context = caml_call1(X[33][1][1], 0),
          memo_table = caml_call1(Memo[1], 32);
         function of_typerep(param$0){
          var param = param$0;
          a:
          for(;;){
           if(typeof param === "number")
            switch(param){
              case 0:
               return X[11];
              case 1:
               return X[12];
              case 2:
               return X[13];
              case 3:
               return X[14];
              case 4:
               return X[15];
              case 5:
               return X[16];
              case 6:
               return X[17];
              case 7:
               return X[18];
              case 8:
               return X[19];
              default: return X[20];
            }
           switch(param[0]){
             case 0:
              var rep$6 = param[1], t = of_typerep(rep$6);
              return caml_call1(X[21], t);
             case 1:
              var rep$7 = param[1], u = of_typerep(rep$7);
              return caml_call1(X[22], u);
             case 2:
              var rep$8 = param[1], v = of_typerep(rep$8);
              return caml_call1(X[23], v);
             case 3:
              var rep$9 = param[1], w = of_typerep(rep$9);
              return caml_call1(X[24], w);
             case 4:
              var rep$10 = param[1], x = of_typerep(rep$10);
              return caml_call1(X[25], x);
             case 5:
              var
               match$6 = param[1],
               rng = match$6[2],
               dom = match$6[1],
               y = of_typerep(rng),
               z = of_typerep(dom);
              return caml_call2(X[26], z, y);
             case 6:
              break a;
             case 7:
              var
               record = param[1],
               A = caml_call2(Helper$0[2], [0, of_typerep], record);
              return caml_call1(X[31], A);
             case 8:
              var
               variant = param[1],
               B = caml_call2(Helper$0[1], [0, of_typerep], variant);
              return caml_call1(X[32], B);
             default:
              var
               match$11 = param[1],
               content = match$11[2],
               named = match$11[1],
               typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
               match$12 = caml_call2(Memo[4], memo_table, typename);
              if(match$12){
               var shared = match$12[1];
               return caml_call1(X[33][3], shared);
              }
              switch(named[0]){
                case 0:
                 var
                  rep$0 = named[1],
                  Custom = Find0(rep$0),
                  match$0 = Custom[1].call(null, 0);
                 if(match$0)
                  var custom = match$0[1], match$13 = [0, custom];
                 else
                  var match$13 = 0;
                 break;
                case 1:
                 var
                  rep$1 = named[1],
                  Custom$0 = Find1(rep$1),
                  match$1 = Custom$0[1].call(null, 0);
                 if(match$1)
                  var
                   custom$0 = match$1[1],
                   custom$1 = caml_call1(custom$0, of_typerep(rep$1[1])),
                   match$13 = [0, custom$1];
                 else
                  var match$13 = 0;
                 break;
                case 2:
                 var
                  rep$2 = named[1],
                  Custom$1 = Find2(rep$2),
                  match$2 = Custom$1[1].call(null, 0);
                 if(match$2)
                  var
                   custom$2 = match$2[1],
                   j = of_typerep(rep$2[2]),
                   custom$3 = caml_call2(custom$2, of_typerep(rep$2[1]), j),
                   match$13 = [0, custom$3];
                 else
                  var match$13 = 0;
                 break;
                case 3:
                 var
                  rep$3 = named[1],
                  Custom$2 = Find3(rep$3),
                  match$3 = Custom$2[1].call(null, 0);
                 if(match$3)
                  var
                   custom$4 = match$3[1],
                   k = of_typerep(rep$3[3]),
                   l = of_typerep(rep$3[2]),
                   custom$5 = caml_call3(custom$4, of_typerep(rep$3[1]), l, k),
                   match$13 = [0, custom$5];
                 else
                  var match$13 = 0;
                 break;
                case 4:
                 var
                  rep$4 = named[1],
                  Custom$3 = Find4(rep$4),
                  match$4 = Custom$3[1].call(null, 0);
                 if(match$4)
                  var
                   custom$6 = match$4[1],
                   m = of_typerep(rep$4[4]),
                   n = of_typerep(rep$4[3]),
                   o = of_typerep(rep$4[2]),
                   custom$7 =
                     caml_call4(custom$6, of_typerep(rep$4[1]), o, n, m),
                   match$13 = [0, custom$7];
                 else
                  var match$13 = 0;
                 break;
                default:
                 var
                  rep$5 = named[1],
                  match =
                    find(table5, Typerep_lib_Typename[9].call(null, rep$5[7]));
                 if(match)
                  var
                   rep = match[1],
                   typename_of_t = rep$5[6],
                   Conv =
                     Typerep_lib_Typename[22].call
                      (null, [0, rep[2]], [0, typename_of_t]),
                   L = Typerep_lib_Type_equal[3].call(null, [0]),
                   h = rep[3],
                   i = caml_call1(L[1], Conv[1][1]),
                   match$5 = [0, Typerep_lib_Type_equal[1].call(null, i, h)];
                 else
                  var match$5 = 0;
                 if(match$5)
                  var
                   custom$8 = match$5[1],
                   p = of_typerep(rep$5[5]),
                   q = of_typerep(rep$5[4]),
                   r = of_typerep(rep$5[3]),
                   s = of_typerep(rep$5[2]),
                   custom$9 =
                     caml_call5(custom$8, of_typerep(rep$5[1]), s, r, q, p),
                   match$13 = [0, custom$9];
                 else
                  var match$13 = 0;
              }
              if(match$13){var computation = match$13[1]; return computation;}
              if(! content){
               var
                C = Typerep_lib_Typename[9].call(null, typename),
                string = caml_call1(Typerep_lib_Typename[8][4], C);
               throw caml_maybe_attach_backtrace
                      ([0, Not_implemented, name, string], 1);
              }
              var f = content[1], g = caml_obj_tag(f);
              b:
              if(250 === g)
               var content$0 = f[1];
              else{
               if(246 !== g && 244 !== g){var content$0 = f; break b;}
               var content$0 = CamlinternalLazy[2].call(null, f);
              }
              if(caml_call1(X[33][5], content$0)){
               var shared$0 = caml_call2(X[33][2], context, typename);
               caml_call3(Memo[3], memo_table, typename, shared$0);
               var computation$0 = of_typerep(content$0);
               return caml_call2(X[33][4], shared$0, computation$0);
              }
              param = content$0;
           }
          }
          var tuple = param[1];
          switch(tuple[0]){
            case 0:
             var
              match$7 = tuple[1],
              b = match$7[2],
              a = match$7[1],
              ra = of_typerep(a),
              rb = of_typerep(b);
             return caml_call2(X[27], ra, rb);
            case 1:
             var
              match$8 = tuple[1],
              c = match$8[3],
              b$0 = match$8[2],
              a$0 = match$8[1],
              ra$0 = of_typerep(a$0),
              rb$0 = of_typerep(b$0),
              rc = of_typerep(c);
             return caml_call3(X[28], ra$0, rb$0, rc);
            case 2:
             var
              match$9 = tuple[1],
              d = match$9[4],
              c$0 = match$9[3],
              b$1 = match$9[2],
              a$1 = match$9[1],
              ra$1 = of_typerep(a$1),
              rb$1 = of_typerep(b$1),
              rc$0 = of_typerep(c$0),
              rd = of_typerep(d);
             return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
            default:
             var
              match$10 = tuple[1],
              e = match$10[5],
              d$0 = match$10[4],
              c$1 = match$10[3],
              b$2 = match$10[2],
              a$2 = match$10[1],
              ra$2 = of_typerep(a$2),
              rb$2 = of_typerep(b$2),
              rc$1 = of_typerep(c$1),
              rd$0 = of_typerep(d$0),
              re = of_typerep(e);
             return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
          }
         }
         var computation = of_typerep(rep);
         return [0, 911962647, computation];
        }
        return [0,
                ident,
                Not_implemented,
                register0,
                register1,
                register2,
                register3,
                register4,
                register5,
                register,
                of_typerep,
                [0,
                 X[3],
                 X[4],
                 X[5],
                 X[6],
                 X[7],
                 X[8],
                 X[9],
                 X[10],
                 X[11],
                 X[12],
                 X[13],
                 X[14],
                 X[15],
                 X[16],
                 X[17],
                 X[18],
                 X[19],
                 X[20],
                 X[21],
                 X[22],
                 X[23],
                 X[24],
                 X[25],
                 X[26],
                 X[27],
                 X[28],
                 X[29],
                 X[30],
                 X[31],
                 X[32],
                 X[33]]];
       }];
   runtime.caml_register_global
    (20, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
//# shape: Typerep_lib__Make_typename:[F(1),F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[11].call(null, X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[12].call(null, X),
         typename_of_t = Name_of_x[1];
        function named(of_p1){
         var
          a = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call1(Name_of_x[1], a),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[13].call(null, X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2){
         var
          a = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          b = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call2(Name_of_x[1], b, a),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [2,
                 [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[14].call(null, X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3){
         var
          a = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          b = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          c = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call3(Name_of_x[1], c, b, a),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [3,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[15].call(null, X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4){
         var
          a = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          b = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          c = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          d = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call4(Name_of_x[1], d, c, b, a),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [4,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = Typerep_lib_Typename[16].call(null, X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4, of_p5){
         var
          a = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
          b = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          c = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          d = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          e = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call5(Name_of_x[1], e, d, c, b, a),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [5,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  of_p5,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       }];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
//# shape: Typerep_lib__Type_abstract:[F(1),F(1),F(1),F(1),F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = Typerep_lib_Make_typename[1].call(null, X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = Typerep_lib_Make_typename[2].call(null, X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = Typerep_lib_Make_typename[3].call(null, X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = Typerep_lib_Make_typename[4].call(null, X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = Typerep_lib_Make_typename[5].call(null, X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = Typerep_lib_Make_typename[6].call(null, X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
//# shape: Typerep_lib__Std:[N,N,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,N,F(2)*,F(3)*,F(4)*,F(5)*,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIlR5cGVyZXBfbGliIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsY0FBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIlR5cGVyZXBfbGliX05hbWVkX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyx5QkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdHlwZXJlcC90eXBlX2VxdWFsLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwidHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgQmFzZS5UeXBlX2VxdWFsLnQgPSBUIDogKCdhLCAnYSkgdFxudHlwZSAoJ2EsICdiKSBlcXVhbCA9ICgnYSwgJ2IpIHRcblxubGV0IHJlZmwgPSBUXG5sZXQgY29udiA6IHR5cGUgYSBiLiAoYSwgYikgdCAtPiBhIC0+IGIgPSBmdW4gVCB4IC0+IHhcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjb252IiwicGFyYW0iLCJ4IiwiTGlmdCIsIlgiLCJsaWZ0IiwiVHlwZXJlcF9saWJfVHlwZV9lcXVhbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxLQUFBQyxPQUFBQyxHQ0lxRCxTQUFDO0FBQUEsWUFBQUMsS0FBQUMsWUFBQUMsS0FBQUosT0FNSSxTQUFDLEVEVjNEO0FBQUEsT0FBQUsseUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL3R5cGVyZXAvdHlwZW5hbWUubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiB0aGlzIGxpYiBzaG91bGQgbm90IGRlcGVuZCBvbiBjb3JlICopXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgY29tcGFyZSBjbXAgYSBiID1cbiAgICBsZXQgcmVjIGxvb3AgYSBiID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gMFxuICAgICAgfCBbXSwgXyAtPiAtMVxuICAgICAgfCBfLCBbXSAtPiAxXG4gICAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgICAgbGV0IG4gPSBjbXAgeCB5IGluXG4gICAgICAgIGlmIG4gPSAwIHRoZW4gbG9vcCB4cyB5cyBlbHNlIG5cbiAgICBpblxuICAgIGxvb3AgYSBiXG4gIDs7XG5lbmRcblxubW9kdWxlIFVpZCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIG5leHQgOiBzdHJpbmcgLT4gdFxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIHZhbCBuYW1lIDogdCAtPiBzdHJpbmdcbiAgdmFsIHN0YXRpYyA6IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgY29kZSA6IGludFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIH1cblxuICBsZXQgY29tcGFyZSBhIGIgPSBjb21wYXJlIChhLmNvZGUgOiBpbnQpIGIuY29kZVxuICBsZXQgZXF1YWwgYSBiID0gKGEuY29kZSA6IGludCkgPSBiLmNvZGVcbiAgbGV0IHVpZCA9IHJlZiAwXG5cbiAgbGV0IG5leHQgbmFtZSA9XG4gICAgbGV0IGNvZGUgPSAhdWlkIGluXG4gICAgaW5jciB1aWQ7XG4gICAgeyBjb2RlOyBuYW1lIH1cbiAgOztcblxuICBsZXQgaGFzaCBhID0gSGFzaHRibC5oYXNoIGEuY29kZVxuICBsZXQgbmFtZSBhID0gYS5uYW1lXG4gIGxldCBzdGF0aWMgPSBuZXh0IFwic3RhdGljXCJcbmVuZFxuXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyB1aWQgOiBVaWQudFxuICAgIDsgcGFyYW1zIDogdCBsaXN0XG4gICAgfVxuXG4gIGxldCByZWMgY29tcGFyZSBrMSBrMiA9XG4gICAgaWYgazEgPT0gazJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbXAgPSBVaWQuY29tcGFyZSBrMS51aWQgazIudWlkIGluXG4gICAgICBpZiBjbXAgPD4gMCB0aGVuIGNtcCBlbHNlIExpc3QuY29tcGFyZSBjb21wYXJlIGsxLnBhcmFtcyBrMi5wYXJhbXMpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuICBsZXQgaGFzaCA9IChIYXNodGJsLmhhc2ggOiB0IC0+IGludClcbiAgbGV0IHN0YXRpYyA9IHsgdWlkID0gVWlkLnN0YXRpYzsgcGFyYW1zID0gW10gfVxuZW5kXG5cbnR5cGUgJ2EgdCA9IEtleS50XG50eXBlICdhIHR5cGVuYW1lID0gJ2EgdFxuXG5sZXQga2V5IHQgPSB0XG5sZXQgdWlkIHQgPSB0LktleS51aWRcbmxldCBuYW1lIHQgPSBVaWQubmFtZSB0LktleS51aWRcbmxldCBzdGF0aWMgPSBLZXkuc3RhdGljXG5sZXQgY3JlYXRlID8obmFtZSA9IFwiVHlwZW5hbWUuY3JlYXRlXCIpICgpID0geyBLZXkudWlkID0gVWlkLm5leHQgbmFtZTsgcGFyYW1zID0gW10gfVxuXG5pbmNsdWRlIHN0cnVjdFxuICAoKiBUaGUgYXJndW1lbnQgZm9yIE9iai5tYWdpYyBoZXJlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gY29yZS90eXBlX2VxdWFsICopXG5cbiAgbGV0IHNhbWUgKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9IEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG5cbiAgbGV0IHNhbWVfd2l0bmVzcyAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gU29tZSAoT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCA6IChhLCBiKSBUeXBlX2VxdWFsLnQpXG4gICAgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHNhbWVfd2l0bmVzc19leG4gKHR5cGUgYSBiKSAobm0xIDogYSB0KSAobm0yIDogYiB0KSA9XG4gICAgaWYgS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcbiAgICB0aGVuIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIGZhaWx3aXRoIFwiVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4blwiXG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAoJ2EsICdiKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdHlwZW5hbWUgLT4gJ2IgdHlwZW5hbWUgLT4gJ2MgdHlwZW5hbWUgLT4gKCdhLCAnYiwgJ2MpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdFxuICAgIDogICdhIHR5cGVuYW1lXG4gICAgLT4gJ2IgdHlwZW5hbWVcbiAgICAtPiAnYyB0eXBlbmFtZVxuICAgIC0+ICdkIHR5cGVuYW1lXG4gICAgLT4gJ2UgdHlwZW5hbWVcbiAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IHR5cGVuYW1lXG5lbmRcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gW10gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGIgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCA9IHsgS2V5LnVpZDsgcGFyYW1zID0gWyBhOyBiOyBjOyBkIF0gfVxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIGxldCB1aWQgPSBVaWQubmV4dCBYLm5hbWVcbiAgbGV0IHR5cGVuYW1lX29mX3QgYSBiIGMgZCBlID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQ7IGUgXSB9XG5lbmRcblxubW9kdWxlIEtleV90YWJsZSA9IEhhc2h0YmwuTWFrZSAoS2V5KVxuXG5tb2R1bGUgVGFibGUgKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICB0eXBlIGRhdGEgPSBEYXRhIDogJ2EgdCAqICdhIFgudCAtPiBkYXRhXG4gIHR5cGUgdCA9IGRhdGEgS2V5X3RhYmxlLnRcblxuICBsZXQgY3JlYXRlIGludCA9IEtleV90YWJsZS5jcmVhdGUgaW50XG4gIGxldCBtZW0gdGFibGUgbmFtZSA9IEtleV90YWJsZS5tZW0gdGFibGUgKGtleSBuYW1lKVxuICBsZXQgc2V0IHRhYmxlIG5hbWUgZGF0YSA9IEtleV90YWJsZS5yZXBsYWNlIHRhYmxlIChrZXkgbmFtZSkgKERhdGEgKG5hbWUsIGRhdGEpKVxuXG4gIGxldCBmaW5kICh0eXBlIGEpIHRhYmxlIChuYW1lIDogYSB0eXBlbmFtZSkgPVxuICAgIGxldCBkYXRhID1cbiAgICAgIHRyeSBTb21lIChLZXlfdGFibGUuZmluZCB0YWJsZSAoa2V5IG5hbWUpKSB3aXRoXG4gICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggZGF0YSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKERhdGEgKG5hbWUnLCBkYXRhKSkgLT5cbiAgICAgIChmdW4gKHR5cGUgYikgKG5hbWUnIDogYiB0eXBlbmFtZSkgKGRhdGEgOiBiIFgudCkgLT5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSAoc2FtZV93aXRuZXNzX2V4biBuYW1lJyBuYW1lIDogKGIsIGEpIFR5cGVfZXF1YWwudCkgaW5cbiAgICAgICAgIFNvbWUgKGRhdGEgOiBhIFgudCkpXG4gICAgICAgIG5hbWUnXG4gICAgICAgIGRhdGFcbiAgOztcbmVuZFxuXG5sZXQgZmFpbCB1aWRfYSB1aWRfYiA9XG4gIGxldCBtc2cgPVxuICAgIFByaW50Zi5zcHJpbnRmIFwiVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4biAlUyAlU1wiIChVaWQubmFtZSB1aWRfYSkgKFVpZC5uYW1lIHVpZF9iKVxuICBpblxuICBmYWlsd2l0aCBtc2dcbjs7XG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzEgKEEgOiBTMSkgKEIgOiBTMSkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhLiAoJ2EgQS50LCAnYSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8yIChBIDogUzIpIChCIDogUzIpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYi4gKCgnYSwgJ2IpIEEudCwgKCdhLCAnYikgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8zIChBIDogUzMpIChCIDogUzMpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYSAnYiAnYy4gKCgnYSwgJ2IsICdjKSBBLnQsICgnYSwgJ2IsICdjKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCB1aWRfYiA9IHVpZCAoQi50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fNCAoQSA6IFM0KSAoQiA6IFM0KSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IgJ2MgJ2QuICgoJ2EsICdiLCAnYywgJ2QpIEEudCwgKCdhLCAnYiwgJ2MsICdkKSBCLnQpIFR5cGVfZXF1YWwudCB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgfSBlbHNlIGZhaWwgdWlkX2EgdWlkX2JcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl81IChBIDogUzUpIChCIDogUzUpID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBlcSA6XG4gICAgICAgICdhICdiICdjICdkICdlLiAoKCdhLCAnYiwgJ2MsICdkLCAnZSkgQS50LCAoJ2EsICdiLCAnYywgJ2QsICdlKSBCLnQpIFR5cGVfZXF1YWwudFxuICAgIH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGxldCBlcSA9IE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIlR5cGVyZXBfbGliX1R5cGVfZXF1YWwiLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliIiwiQmFzZSIsIlN0ZGxpYl9IYXNodGJsIiwiY29tcGFyZSIsImEiLCJiIiwiZXF1YWwiLCJ1aWQiLCJuZXh0IiwibmFtZSIsImNvZGUiLCJoYXNoIiwic3RhdGljJCIsImsxIiwiazIiLCJjbXAiLCJ5cyIsInkiLCJ4cyIsIngiLCJuIiwiY3N0X1R5cGVuYW1lX2NyZWF0ZSIsImNzdF9UeXBlbmFtZV9zYW1lX3dpdG5lc3NfZXhuIiwia2V5IiwidCIsImNyZWF0ZSIsIm9wdCIsInBhcmFtIiwic2FtZSIsIm5tMSIsIm5tMiIsInNhbWVfd2l0bmVzcyIsInNhbWVfd2l0bmVzc19leG4iLCJLZXlfdGFibGUiLCJUYWJsZSIsIlgiLCJpbnQiLCJtZW0iLCJ0YWJsZSIsInNldCIsImRhdGEiLCJmaW5kIiwiZXhuIiwibWF0Y2giLCJmYWlsIiwidWlkX2EiLCJ1aWRfYiIsIm1zZyIsIlNhbWVfd2l0bmVzc19leG5fMSIsIkEiLCJCIiwiZXEiLCJ3aXRuZXNzIiwiU2FtZV93aXRuZXNzX2V4bl8yIiwiU2FtZV93aXRuZXNzX2V4bl8zIiwiU2FtZV93aXRuZXNzX2V4bl80IiwiU2FtZV93aXRuZXNzX2V4bl81IiwiVHlwZXJlcF9saWJfVHlwZW5hbWUiLCJ0eXBlbmFtZV9vZl90IiwiYyIsImQiLCJlIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUE7QUFBQSxZQUFBQyxRQUFBQyxHQUFBQyxHQ2lDb0IsMkNBQTZCO0FBQUEsWUFBQUMsTUFBQUYsR0FBQUMsR0FDL0IsNkJBQXVCO0FBQUEsT0FBQUUsTURsQ3pDO0FBQUEsWUFBQUMsS0FBQUMsVUFBQUMsT0NzQ0ksUUFDQSxVQUNBLHVCQUFjO0FBQUEsWUFBQUMsS0FBQVAsR0FHSCwwQ0FBbUI7QUFBQSxZQUFBSyxLQUFBTCxHQUNuQixZQUFNO0FBQUEsT0FBQVEsVUFDTjtBQUFBLFlBQUFULFVBQUFVLElBQUFDO0FBQUFBLElBVVgsY0FDSztBQUFBLFFBQUFDLE1BRU87QUFBQSxJQUNWLGNBQWlCO0FBQUEsUUFBQVYsTUFBUyxPQUFBRCxNQUFBLE9BQUFBLElBN0M1QixL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QUEsS0FBQXNCLFFBNUxSO0FBQUEsS0FBQUssS0E0TDREO0FBQUEsS0FBQUMsVUFFakUsZ0NBQXVDO0FBQUEsSUFBbEI7QUFBQTtBQUFBO0FBQUEsSUFBQUs7QUFBQUEsTUF4TkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBdEI7QUFBQUEsWUFBQTVCLE1BaUdoQixZQUFBbUQsZ0JBQWU7QUFBQTtBQUFBO0FBQUEsZ0JBQUF2QjtBQUFBQSxZQUFBNUIsTUFLZjtBQUFBLGlCQUFBbUQsY0FBQXRELEdBQ1ksMkJBQTJCO0FBQUEsUUFEeEI7QUFBQTtBQUFBLGdCQUFBK0I7QUFBQUEsWUFBQTVCLE1BS2Y7QUFBQSxpQkFBQW1ELGNBQUF0RCxHQUFBQyxHQUNjLG1DQUE4QjtBQUFBLFFBRDdCO0FBQUE7QUFBQSxnQkFBQThCO0FBQUFBLFlBQUE1QixNQUtmO0FBQUEsaUJBQUFtRCxjQUFBdEQsR0FBQUMsR0FBQXNEO0FBQUFBLFNBQ2dCO0FBQUEsUUFBaUM7QUFBQSxRQURsQztBQUFBO0FBQUEsZ0JBQUF4QjtBQUFBQSxZQUFBNUIsTUFLZjtBQUFBLGlCQUFBbUQsY0FBQXRELEdBQUFDLEdBQUFzRCxHQUFBQztBQUFBQSxTQUNrQjtBQUFBLFFBQW9DO0FBQUEsUUFEdkM7QUFBQTtBQUFBLGdCQUFBekI7QUFBQUEsWUFBQTVCLE1BS2Y7QUFBQSxpQkFBQW1ELGNBQUF0RCxHQUFBQyxHQUFBc0QsR0FBQUMsR0FBQUM7QUFBQUEsU0FDb0I7QUFBQSxRQUF1QztBQUFBLFFBRDVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQTFIQztBQUFBO0FBQUE7QUFBQSxFRDdDNUIiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi90eXBlcmVwL3ZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqXG4gICBQbGFjZSBob2xkZXIgZm9yIGNvbW1vbiBWYXJpYW50cyBhbmQgRmllbGRzIGludGVyZmFjZVxuKilcblxubW9kdWxlIE0gKFggOiBzaWdcbiAgKCoqXG4gICAgICAgVGhpcyBmdW5jdG9yIGlzIGVzc2VudGlhbGx5IHRoZXJlIGJlY2F1c2Ugd2UgdXNlIHRoaXMgc2FtZSBpbnRlcmZhY2UgaW4gZGlmZmVyZW50XG4gICAgICAgY29udGV4dHMsIHdpdGggZGlmZmVyZW50IHR5cGVzIGZvciBbJ2EgdF0uXG5cbiAgICAgICAxKSBPbmUgdXNlIGNhc2UgZm9yIGl0IGlzIHdoZXJlIFsnYSBYLnQgPSAnYSBUeXBlcmVwLnRdLiAgVGhlc2UgaW50ZXJmYWNlcyBhcmUgdGhlblxuICAgICAgIHBhcnQgb2YgdGhlIHR5cGUgd2l0bmVzcyBidWlsdCBmb3IgYSB0eXBlIGNvbnRhaW5pbmcgYSByZWNvcmQgb3IgYSB2YXJpYW50IGluIGl0c1xuICAgICAgIHN0cnVjdHVyZS4gW3RyYXZlcnNlXSB3aWxsIGdpdmUgYSB3YXkgb2YgYWNjZXNzaW5nIHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIGZvciB0aGVcbiAgICAgICBhcmd1bWVudHMgb2YgYSB2YXJpYW50IG9yIHJlY29yZCB0eXBlLlxuXG4gICAgICAgMikgQW5vdGhlciB1c2UgY2FzZSBpcyBmb3IgYnVpbGRpbmcgXCJzdGFnZWQgZ2VuZXJpYyBjb21wdXRhdGlvbnNcIi4gSW4gdGhhdCBjYXNlLCB0aGVcbiAgICAgICB0eXBlIFsnYSBYLnRdIGlzIHRoZSB0eXBlIG9mIHRoZSBjb21wdXRhdGlvbiB0aGF0IGlzIGJlaW5nIGJ1aWx0LiAgW3RyYXZlcnNlXVxuICAgICAgIHJldHVybnMgdGhlIGNvbXB1dGF0aW9uIGJ1aWx0IGZvciB0aGUgYXJndW1lbnQuIFRoZSBpbnRlcmZhY2Ugbm8gbG9uZ2VyIGV4cG9ydHNcbiAgICAgICB0aGUgdHlwZXJlcCBvZiB0aGUgYXJndW1lbnRzIGluIGhvcGVzIG9mIGVuZm9yY2luZyB0aGF0IG5vIHR5cGVyZXAgdHJhdmVyc2FsXG4gICAgICAgaGFwcGVucyBhdCBydW50aW1lIGlmIHRoZSBjb21wdXRhdGlvbiBoYXBwZW4gdG8gYmUgYSBmdW5jdGlvbi5cbiAgICAqKVxuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gICgqIFRoZSBmdW5jdGlvbnMgcHJlZml4ZWQgYnkgW2ludGVybmFsXSBhcyB3ZWxsIGFzIHRoZSBtb2R1bGUgc3VmZml4ZWQgYnkgW19pbnRlcm5hbF1cbiAgICAgYXJlIHVzZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIFt3aXRoIHR5cGVyZXBdIGFzIHdlbGwgYXMgc29tZVxuICAgICBpbnRlcm5hbHMgb2YgdGhlIHR5cGVyZXAgbGlicmFyeS4gRG8gbm90IGNvbnNpZGVyIHVzaW5nIHRoZXNlIHNvbWV3aGVyZSBlbHNlLiAgVGhleVxuICAgICBzaG91bGQgaWRlYWxseSBub3QgYmUgZXhwb3J0ZWQgb3V0c2lkZSB0aGUgdHlwZXJlcCBsaWJyYXJ5LCBidXQgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgIG5lZWRzIHNvbWVob3cgdG8gYWNjZXNzIHRoaXMsIGV2ZW4gb3V0c2lkZS4gKilcblxuICBtb2R1bGUgVGFnX2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGUgPVxuICAgICAgfCBBcmdzIG9mICgnYXJncyAtPiAndmFyaWFudClcbiAgICAgIHwgQ29uc3Qgb2YgJ3ZhcmlhbnRcblxuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdhcmdzIFgudFxuICAgICAgOyBhcml0eSA6IGludFxuICAgICAgOyBhcmdzX2xhYmVscyA6IHN0cmluZyBsaXN0XG4gICAgICA7IGluZGV4IDogaW50XG4gICAgICA7IG9jYW1sX3JlcHIgOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdhcmdzIFR5cGVuYW1lLnRcbiAgICAgIDsgY3JlYXRlIDogKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgdGFnLCB0aGF0IGlzIGFuIGl0ZW0gaW4gYSB2YXJpYW50IHR5cGUsIGFsc28gY2FsbGVkIGFuIFwiYXBwbGllZFxuICAgICB2YXJpYW50IENvbnN0cnVjdG9yXCJcblxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSB2YXJpYW50IHR5cGUsIHRoZSBzZWNvbmQgaXMgdGhlIHR5cGUgb2YgdGhlIHRhZ1xuICAgICBwYXJhbWV0ZXJzLiAgRXhhbXBsZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9XG4gICAgICAgICB8IEEgb2YgKGludCAqIHN0cmluZylcbiAgICAgICAgIHwgQiBvZiBzdHJpbmdcbiAgICAgICAgIHwgQyBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICBdfVxuXG4gICAgIHRoaXMgdHlwZSBoYXMgdGhyZWUgY29uc3RydWN0b3JzLiBGb3IgZWFjaCBvZiB0aGVtIHdlJ2xsIGhhdmUgYSBjb3JyZXNwb25kaW5nXG4gICAgIFtUYWcudF06XG5cbiAgICAge1tcbiAgICAgICB2YWwgdGFnX0EgOiAodCwgKGludCAqIHN0cmluZykpIFRhZy50XG4gICAgICAgdmFsIHRhZ19CIDogKHQsIHN0cmluZyAgICAgICAgKSBUYWcudFxuICAgICAgIHZhbCB0YWdfQyA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgXX1cblxuICAgICBOb3RlLCBpbmxpbmUgcmVjb3JkIGluIHZhcmlhbnQgYXJlIHR5cGVkIGFzIGlmIHRoZWlyIGRlZmluaXRpb24gd2FzIHVzaW5nIHR1cGxlcyxcbiAgICAgd2l0aG91dCB0aGUgcGFyZW50aGVzaXMuICBUaGlzIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGVpciBydW50aW1lIHJlcHJlc2VudGF0aW9uLiAgQnV0XG4gICAgIHRoZSBkaXN0aW5jdGlvbiBpcyBjYXJyaWVkIGFuZCBhdmFpbGFibGUgZm9yIGludHJvc3BlY3Rpb24gYXMgcGFydCBvZiB0aGUgW1RhZy50XS5cbiAgICAgU2VlIFthcmdzX2xhYmVsc10uICopXG4gIG1vZHVsZSBUYWcgOiBzaWdcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0XG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29uc3RydWN0b3IgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuXG4gICAgICAge3ZcbiAgICAgICAgIENvbnN0cnVjdG9yICAgICAgICB8IGxhYmVsXG4gICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgYGEgb2YgaW50ICAgICAgICB8ICBcImFcIlxuICAgICAgICAgfCBgQSBvZiBpbnQgICAgICAgIHwgIFwiQVwiXG4gICAgICAgICB8IEEgb2YgeyB4IDogaW50IH0gfCAgXCJBXCJcbiAgICAgICB2fVxuXG4gICAgICAgZm9yIHN0YW5kYXJkIHZhcmlhbnQsIHRoZSBvY2FtbCBzeW50YXggaW1wbGllcyB0aGF0IHRoaXMgbGFiZWwgd2lsbCBhbHdheXMgc3RhcnRzXG4gICAgICAgd2l0aCBhIGNhcGl0YWwgbGV0dGVyLiBGb3IgcG9seW1vcnBoaWMgdmFyaWFudHMsIHRoaXMgbWlnaHQgYmUgYSBsb3dlcmNhc2UgY2hhci5cbiAgICAgICBGb3IgcG9seW1vcnBoaWMgdmFyaWFudCwgdGhpcyBsYWJlbCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBbYF0gY2hhcmFjdGVyLlxuICAgICopXG4gICAgdmFsIGxhYmVsIDogKF8sIF8pIHQgLT4gc3RyaW5nXG5cbiAgICAoKipcbiAgICAgICBUaGUgc2l6ZSBvZiB0aGUgb2NhbWwgaGVhcCBibG9jayBjb250YWluaW5nIHRoZSBhcmd1bWVudHNcblxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHt2XG4gICAgICAgICAgMDogfCBBIHwgJ0FcbiAgICAgICAgICAxOiB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgICAgfCBgQSBvZiBpbnQgKiBpbnRcbiAgICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50fVxuICAgICAgICAgIDI6IHwgQSBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICAgICAgIGV0Yy5cbiAgICAgICB2fVxuICAgICopXG4gICAgdmFsIGFyaXR5IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKiogVGhlIGxhYmVsIG9mIHRoZSBmaWVsZHMgZm9yIGlubGluZSByZWNvcmRzLiAgRm9yIG90aGVyIGZvcm1zIG9mIHRhZ3MsIHRoaXMgaXMgdGhlXG4gICAgICAgIGVtcHR5IGxpc3QuICBXaGVuIHRoaXMgcmV0dXJucyBhIG5vbiBlbXB0eSBsaXN0LCB0aGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBsaXN0XG4gICAgICAgIGlzIGVxdWFsIHRvIHRoZSBhcml0eS5cblxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIHt2XG4gICAgICAgICAoMSkgRW1wdHk6XG5cbiAgICAgICAgICAgfCBBIHwgJ0FcbiAgICAgICAgICAgfCBBIG9mIGludCB8IGBBIG9mIGludCB8IEEgb2YgKGludCAqIGludCkgfCBgQSBvZiAoaW50ICogaW50KVxuICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICB8IEEgb2YgaW50ICogZmxvYXRcblxuICAgICAgICAgKDIpIE5vbiBlbXB0eTpcblxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAtPiBbIFwieFwiIF1cbiAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9ICAgLT4gWyBcInhcIiA7IFwieVwiIF1cbiAgICAgICB2fVxuICAgICopXG4gICAgdmFsIGFyZ3NfbGFiZWxzIDogKF8sIF8pIHQgLT4gc3RyaW5nIGxpc3RcblxuICAgICgqKlxuICAgICAgIFRoZSBpbmRleCBvZiB0aGUgY29uc3RydWN0b3IgaW4gdGhlIGxpc3Qgb2YgYWxsIHRoZSB2YXJpYW50IHR5cGUncyBjb25zdHJ1Y3RvcnNcbiAgICAgICBFeGFtcGxlczpcbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIGludCAgICAgICAgICAoKiAwICopXG4gICAgICAgICAgIHwgQiAgICAgICAgICAgICAgICAgKCogMSAqKVxuICAgICAgICAgICB8IEMgb2YgaW50ICAgICAgICAgICgqIDIgKilcbiAgICAgICAgICAgfCBEIG9mIGNoYXIgICAgICAgICAoKiAzICopXG4gICAgICAgICAgIHwgRSBvZiB7IHggOiBpbnQgfSAgKCogNCAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgaW5kZXggOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIG9jYW1sX3JlcHIgaXMgcmVsYXRlZCB0byB0aGUgcnVudGltZSBvZiBvYmplY3RzLiB0aGlzIGlzIGVzc2VudGlhbGx5IGEgd2F5IG9mXG4gICAgICAgZ2l2aW5nIG9uZSB0aGUgYWJpbGl0eSB0byByZWJ1aWxkIGR5bmFtaWNhbGx5IGFuIFtPYmoudF0gcmVwcmVzZW50aW5nIGEgdGFnLlxuXG4gICAgICAgUG9seW1vcnBoaWMgdmFyaWFudHM6XG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICBbb2NhbWxfcmVwcl0gaXMgdGhlIGhhc2ggb2YgdGhlIGxhYmVsLCBhcyBkb25lIGJ5IHRoZSBjb21waWxlci5cbiAgICAgICBFeGFtcGxlOlxuICAgICAgIHByaW50X2ludCAoT2JqLm1hZ2ljIGBiYXIpICAoKiA0ODk1MTg3ICopXG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgJ2ZvbykgICgqIDUwOTcyMjIgKilcblxuICAgICAgIFN0YW5kYXJkcyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICBbb2NhbWxfcmVwcl0gaXMgdGhlIHRhZyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjb25zdHJ1Y3RvciB3aXRoaW4gdGhlIHR5cGUuXG4gICAgICAgdGhlIHdheSBpdCB3b3JrcyBpbiB0aGUgb2NhbWwgcnVudGltZSBpcyBieSBwYXJ0aXRpb25pbmcgdGhlIGNvbnN0cnVjdG9ycyByZWdhcmRpbmdcbiAgICAgICBpZiB0aGV5IGhhdmUgc29tZSBhcmd1bWVudHMgb3Igbm90LCBwcmVzZXJ2aW5nIHRoZSBvcmRlciwgdGhlbiBhc3NpZ24gaW5jcmVhc2luZ1xuICAgICAgIGluZGV4IHdpdGhpbmcgZWFjaCBwYXJ0aXRpb24uXG4gICAgICAgRXhhbXBsZTpcblxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPSAgICAgICAgICAgICAgICAgICgqIG5vIGFyZyAqKSAgKCogYXJncyAqKVxuICAgICAgICAgICB8IEEgICAgICAgICAgICAgICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCIG9mIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBDICAgICAgICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgRCBvZiAoZmxvYXQgKiBzdHJpbmcpICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgRSAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEYgICAgICAgICAgICAgICAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBHIG9mIHN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIDIgKilcbiAgICAgICAgICAgfCBIIG9mIHsgeCA6IGludCB9ICAgICAgICAgICAgICAgICAgICAgICgqIDMgKilcbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIG9jYW1sX3JlcHIgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIEdpdmUgYmFjayBhIHdheSBvZiBjb25zdHJ1Y3RpbmcgYSB2YWx1ZSBvZiB0aGF0IGNvbnN0cnVjdG9yIGZyb20gaXRzIGFyZ3VtZW50cy5cblxuICAgICAgIEV4YW1wbGVzOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9XG4gICAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgICB8IEIgb2YgaW50ICogZmxvYXRcbiAgICAgICAgICAgfCBDXG4gICAgICAgICAgIHwgRCBvZiB7IHggOiBpbnQ7IHkgOiBzdHJpbmcgfVxuICAgICAgIF19XG5cbiAgICAgICBbY3JlYXRlXSB3aWxsIHJldHVybiBzb21ldGhpbmcgZXF1aXZhbGVudCB0bzpcbiAgICAgICB0YWdfQSA6IFtBcmdzIChmdW4gKGQgOiAoaW50ICogc3RyaW5nKSAtPiBBIGQpXVxuICAgICAgIHRhZ19CIDogW0FyZ3MgKGZ1biAoaSwgZikgLT4gQiAoaSwgZikpXVxuICAgICAgIHRhZ19DIDogW0NvbnN0IENdXG4gICAgICAgdGFnX0QgOiBbQXJncyAoZnVuICh4LCB5KSAtPiBEIHsgeDsgeSB9KV1cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSB0IC0+ICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZVxuXG4gICAgKCoqIHJldHVybiB0aGUgdHlwZV9uYW1lIG9mIHRoZSBhcmd1bWVudHMuIG1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCB3aGlsZSBidWlsZGluZyBhIGNvbXB1dGF0aW9uIGZvciBleGFtcGxlICopXG4gICAgdmFsIHR5aWQgOiAoXywgJ2FyZ3MpIHQgLT4gJ2FyZ3MgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgcmVwcmVzZW50YXRpb24vY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnYXJncykgdCAtPiAnYXJncyBYLnRcblxuICAgICgqIHVzZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gdG8gYnVpbGQgdHlwZSB3aXRuZXNzZXMsIG9yIGJ5IHNvbWUgaW50ZXJuYWwgcGFydHMgb2ZcbiAgICAgICB0eXBlcmVwLiB5b3Ugc2hvdWxkIGZlZWwgYmFkIGlmIHlvdSBuZWVkIHRvIHVzZSBpdCBpbiBzb21lIHVzZXIgY29kZSAqKVxuICAgIHZhbCBpbnRlcm5hbF91c2Vfb25seSA6ICgnYSwgJ2IpIFRhZ19pbnRlcm5hbC50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBUYWdfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBhcml0eSB0ID0gdC5hcml0eVxuICAgIGxldCBhcmdzX2xhYmVscyB0ID0gdC5hcmdzX2xhYmVsc1xuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBvY2FtbF9yZXByIHQgPSB0Lm9jYW1sX3JlcHJcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBWYXJpYW50X2ludGVybmFsID0gc3RydWN0XG4gICAgdHlwZSBfIHRhZyA9IFRhZyA6ICgndmFyaWFudCwgJ2EpIFRhZy50IC0+ICd2YXJpYW50IHRhZ1xuICAgIHR5cGUgXyB2YWx1ZSA9IFZhbHVlIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgKiAnYSAtPiAndmFyaWFudCB2YWx1ZVxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgdHlwZW5hbWUgOiAnYSBUeXBlbmFtZS50XG4gICAgICA7IHRhZ3MgOiAnYSB0YWcgYXJyYXlcbiAgICAgIDsgcG9seW1vcnBoaWMgOiBib29sXG4gICAgICA7IHZhbHVlIDogJ2EgLT4gJ2EgdmFsdWVcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnQgOiBzaWdcbiAgICAoKipcbiAgICAgICBBbiBleGlzdGVudGlhbCB0eXBlIHVzZWQgdG8gZ2F0aGVyIGFsbCB0aGUgdGFncyBjb25zdGl0dWluZyBhIHZhcmlhbnRcbiAgICAgICB0eXBlLiB0aGUgWyd2YXJpYW50XSBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGVcbiAgICAgICBjb25zdHJ1Y3RvcnMgb2YgdGhhdCB2YXJpYW50IHR5cGUuIFRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIG1pZ2h0IGJlIGRpZmZlcmVudFxuICAgICAgIGZvciBlYWNoIGNvbnN0cnVjdG9yIGFuZCBpcyB0aHVzIGV4aXN0ZW50aWFsXG4gICAgKilcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYXJncykgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG5cbiAgICAoKipcbiAgICAgICBBIHNpbWlsYXIgZXhpc3RlbnRpYWwgY29uc3RydWN0b3IgdG8gW18gdGFnXSBidXQgdGhpcyBvbmUgaG9sZHMgYSB2YWx1ZSB3aG9zZSB0eXBlXG4gICAgICAgaXMgdGhlIGFyZ3VtZW50cyBvZiB0aGUgdGFnIGNvbnN0cnVjdG9yLiAgQSB2YWx1ZSBvZiB0eXBlIFsnYSB2YWx1ZV0gaXMgYSBwYWlyIG9mXG4gICAgICAgKDEpIGEgdmFsdWUgb2YgdmFyaWFudCB0eXBlIFsnYV0gYWxvbmcgd2l0aCAoMikgc29tZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICAgICBjb25zdHJ1Y3RvciB3aXRoaW4gdGhlIHR5cGUgWydhXVxuICAgICopXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAqICdhcmdzIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgdmFyaWFudCB0eXBlLiBUaGUgcGFyYW1ldGVyIGlzIHRoZSB0eXBlIG9mIHRoZSB2YXJpYW50IHR5cGUgd2l0bmVzc2VkLlxuICAgICopXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuXG4gICAgKCoqXG4gICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRhZ3Mgb2YgdGhpcyB2YXJpYW50IHR5cGUgZGVmaW5pdGlvbi5cbiAgICAqKVxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2V0IHRoZSBudGggdGFnIG9mIHRoaXMgdmFyaWFudCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCB0YWcgOiAnYSB0IC0+IGludCAtPiAnYSB0YWdcblxuICAgICgqKlxuICAgICAgIERpc3Rpbmd1aXNoIHBvbHltb3JwaGljIHZhcmlhbnRzIGFuZCBzdGFuZGFyZCB2YXJpYW50cy4gVHlwaWNhbGx5LCBwb2x5bW9ycGhpY1xuICAgICAgIHZhcmlhbnRzIHRhZ3Mgc3RhcnRzIHdpdGggdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgICAgRXhhbXBsZVxuICAgICAgIHBvbHltb3JwaGljIHZhcmlhbnQ6IHR5cGUgdCA9IFsgYEEgfCBgQiBdXG4gICAgICAgc3RhbmRhcmQgdmFyaWFudDogICAgdHlwZSB0ID0gQSB8IEJcbiAgICAqKVxuICAgIHZhbCBpc19wb2x5bW9ycGhpYyA6IF8gdCAtPiBib29sXG5cbiAgICAoKipcbiAgICAgICBQYXR0ZXJuIG1hdGNoaW5nIG9uIGEgdmFsdWUgb2YgdGhpcyB2YXJpYW50IHR5cGUuXG4gICAgKilcbiAgICB2YWwgdmFsdWUgOiAnYSB0IC0+ICdhIC0+ICdhIHZhbHVlXG5cbiAgICAoKipcbiAgICAgICBmb2xkaW5nIGFsb25nIHRoZSB0YWdzIG9mIHRoZSB2YXJpYW50IHR5cGVcbiAgICAqKVxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSB0YWcgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgVmFyaWFudF9pbnRlcm5hbC50IC0+ICdhIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBWYXJpYW50X2ludGVybmFsXG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCB0ID0gdC50eXBlbmFtZVxuICAgIGxldCBsZW5ndGggdCA9IEFycmF5Lmxlbmd0aCB0LnRhZ3NcbiAgICBsZXQgdGFnIHQgaW5kZXggPSB0LnRhZ3MuKGluZGV4KVxuICAgIGxldCBpc19wb2x5bW9ycGhpYyB0ID0gdC5wb2x5bW9ycGhpY1xuICAgIGxldCB2YWx1ZSB0ID0gdC52YWx1ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQudGFnc1xuICAgIGxldCBpbnRlcm5hbF91c2Vfb25seSB0ID0gdFxuICBlbmRcblxuICBtb2R1bGUgRmllbGRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgncmVjb3JkLCAnZmllbGQpIHQgPVxuICAgICAgeyBsYWJlbCA6IHN0cmluZ1xuICAgICAgOyByZXAgOiAnZmllbGQgWC50XG4gICAgICA7IGluZGV4IDogaW50XG4gICAgICA7IHR5aWQgOiAnZmllbGQgVHlwZW5hbWUudFxuICAgICAgOyBnZXQgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgICAgOyAoKiBzZXQgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uOyAoXFwqIG11dGFibGUgZmllbGQgKlxcKSAqKVxuICAgICAgICBpc19tdXRhYmxlIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICAoKipcbiAgICAgV2l0bmVzcyBvZiBhIGZpZWxkLCB0aGF0IGlzIGFuIGl0ZW0gaW4gYSByZWNvcmQgdHlwZS5cbiAgICAgVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmVjb3JkIHR5cGUsIHRoZSBzZWNvbmQgaXMgdGhlIHR5cGUgb2YgdGhlIGZpZWxkLlxuICAgICBFeGFtcGxlOlxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludCA7IHkgOiBzdHJpbmcgfVxuICAgICBdfVxuICAgICBUaGlzIHR5cGUgaGFzIHR3byBmaWVsZHMuIGZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgW0ZpZWxkLnRdXG5cbiAgICAgdmFsIGZpZWxkX3ggOiAodCwgaW50KSBGaWVsZC50XG4gICAgIHZhbCBmaWVsZF95IDogKHQsIHN0cmluZykgRmllbGQudFxuICAqKVxuICBtb2R1bGUgRmllbGQgOiBzaWdcbiAgICB0eXBlICgncmVjb3JkLCAnZmllbGQpIHRcblxuICAgICgqKlxuICAgICAgIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCBhcyBpdCBpcyBnaXZlbiBpbiB0aGUgY29uY3JldGUgc3ludGF4XG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge1tcbiAgICAgICAgIHsgeCAgIDogaW50OyAgICAgKCogXCJ4XCIgKilcbiAgICAgICAgICAgZm9vIDogc3RyaW5nOyAgKCogXCJmb29cIiAqKVxuICAgICAgICAgICBiYXIgOiBmbG9hdDsgICAoKiBcImJhclwiICopXG4gICAgICAgICB9XG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBsYWJlbCA6IChfLCBfKSB0IC0+IHN0cmluZ1xuXG4gICAgKCoqXG4gICAgICAgVGhlIDAtYmFzZWQgaW5kZXggb2YgdGhlIGZpZWxkIGluIHRoZSBsaXN0IG9mIGFsbCBmaWVsZHMgZm9yIHRoaXMgcmVjb3JkIHR5cGUuXG4gICAgICAgRXhhbXBsZTpcbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID0ge1xuICAgICAgICAgICB4ICAgOiBpbnQ7ICAgICAoKiAwICopXG4gICAgICAgICAgIGZvbyA6IHN0cmluZzsgICgqIDEgKilcbiAgICAgICAgICAgYmFyIDogc3RyaW5nOyAgKCogMiAqKVxuICAgICAgICAgfVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgaW5kZXggOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIEZpZWxkIGFjY2Vzc29ycy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgZG90IG9wZXJhdGlvbi5cbiAgICAgICBbRmllbGQuZ2V0IGJhcl9maWVsZCB0XSByZXR1cm5zIHRoZSBmaWVsZCBbYmFyXSBvZiB0aGUgcmVjb3JkIHZhbHVlIFt0XSwganVzdCB0aGVcbiAgICAgICBzYW1lIGFzIFt0LmJhcl1cbiAgICAqKVxuICAgIHZhbCBnZXQgOiAoJ3JlY29yZCwgJ2ZpZWxkKSB0IC0+ICdyZWNvcmQgLT4gJ2ZpZWxkXG5cbiAgICAoKiogcmV0dXJuIHdoZXRoZXIgdGhlIGZpZWxkIGlzIG11dGFibGUsIGkuZS4gd2hldGhlciBpdHMgZGVjbGFyYXRpb24gaXMgcHJlZml4ZWQgd2l0aFxuICAgICAgICB0aGUga2V5d29yZCBbbXV0YWJsZV0gKilcbiAgICB2YWwgaXNfbXV0YWJsZSA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAgICgqKiByZXR1cm4gdGhlIHR5cGVfbmFtZSBvZiB0aGUgYXJndW1lbnRzLiAgTWlnaHQgYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgbG9va3VwIGJhc2VkXG4gICAgICAgIG9uIGl0ICopXG4gICAgdmFsIHR5aWQgOiAoXywgJ2ZpZWxkKSB0IC0+ICdmaWVsZCBUeXBlbmFtZS50XG5cbiAgICAoKiogZ2V0IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgYXJndW1lbnRzICopXG4gICAgdmFsIHRyYXZlcnNlIDogKF8sICdmaWVsZCkgdCAtPiAnZmllbGQgWC50XG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAoJ2EsICdiKSBGaWVsZF9pbnRlcm5hbC50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kID0gc3RydWN0XG4gICAgaW5jbHVkZSBGaWVsZF9pbnRlcm5hbFxuXG4gICAgbGV0IGxhYmVsIHQgPSB0LmxhYmVsXG4gICAgbGV0IGluZGV4IHQgPSB0LmluZGV4XG4gICAgbGV0IGdldCB0ID0gdC5nZXRcbiAgICBsZXQgaXNfbXV0YWJsZSB0ID0gdC5pc19tdXRhYmxlXG4gICAgbGV0IHR5aWQgdCA9IHQudHlpZFxuICAgIGxldCB0cmF2ZXJzZSB0ID0gdC5yZXBcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIFJlY29yZF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgXyBmaWVsZCA9IEZpZWxkIDogKCdyZWNvcmQsICdhKSBGaWVsZC50IC0+ICdyZWNvcmQgZmllbGRcbiAgICB0eXBlICdyZWNvcmQgZmllbGRzID0geyBnZXQgOiAnZmllbGQuICgncmVjb3JkLCAnZmllbGQpIEZpZWxkLnQgLT4gJ2ZpZWxkIH1cblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IHR5cGVuYW1lIDogJ2EgVHlwZW5hbWUudFxuICAgICAgOyBmaWVsZHMgOiAnYSBmaWVsZCBhcnJheVxuICAgICAgOyBoYXNfZG91YmxlX2FycmF5X3RhZyA6IGJvb2xcbiAgICAgIDsgY3JlYXRlIDogJ2EgZmllbGRzIC0+ICdhXG4gICAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBSZWNvcmQgOiBzaWdcbiAgICAoKipcbiAgICAgICBBbiBleGlzdGVudGlhbCB0eXBlIHVzZWQgdG8gZ2F0aGVyIGFsbCB0aGUgZmllbGRzIGNvbnN0aXR1aW5nIGEgcmVjb3JkIHR5cGUuIHRoZVxuICAgICAgIFsncmVjb3JkXSBwYXJhbWV0ZXIgaXMgdGhlIHJlY29yZCB0eXBlLCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHRoZSBmaWVsZCBvZiB0aGF0XG4gICAgICAgcmVjb3JkIHR5cGUuIFRoZSB0eXBlIG9mIHRoZSBmaWVsZHMgbWlnaHQgYmUgZGlmZmVyZW50IGZvciBlYWNoIGZpZWxkIGFuZCBpcyB0aHVzXG4gICAgICAgZXhpc3RlbnRpYWwuXG4gICAgKilcbiAgICB0eXBlIF8gZmllbGQgPSBGaWVsZCA6ICgncmVjb3JkLCAnYSkgRmllbGQudCAtPiAncmVjb3JkIGZpZWxkXG5cbiAgICAoKipcbiAgICAgICBbJ3JlY29yZCBmaWVsZHNdIGlzIGEgdHlwZSBpc29tb3JwaGljIHRvIFsncmVjb3JkXS4gIFRoaXMgZ2l2ZXMgYSB3YXkgdG8gZ2V0IHRoZVxuICAgICAgIGZpZWxkIHZhbHVlIGZvciBlYWNoIGZpZWxkIG9mIHRoZSByZWNvcmQuICBUaGUgYWR2YW50YWdlIG9mIHRoaXMgcmVwcmVzZW50YXRpb24gaXNcbiAgICAgICB0aGF0IGl0IGlzIGNvbnZlbmllbnQgZm9yIHdyaXRpbmcgZ2VuZXJpYyBjb21wdXRhdGlvbnMuXG4gICAgKilcbiAgICB0eXBlICdyZWNvcmQgZmllbGRzID0geyBnZXQgOiAnZmllbGQuICgncmVjb3JkLCAnZmllbGQpIEZpZWxkLnQgLT4gJ2ZpZWxkIH1cblxuICAgICgqKlxuICAgICAgIFdpdG5lc3Mgb2YgYSByZWNvcmQgdHlwZS4gVGhlIHBhcmFtZXRlciBpcyB0aGUgdHlwZSBvZiB0aGUgcmVjb3JkIHR5cGUgd2l0bmVzc2VkLlxuICAgICopXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuXG4gICAgKCoqXG4gICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZpZWxkcyBvZiB0aGlzIHJlY29yZCB0eXBlIGRlZmluaXRpb24uXG4gICAgKilcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcblxuICAgICgqKlxuICAgICAgIEdldCB0aGUgbnRoIGZpZWxkIG9mIHRoaXMgcmVjb3JkIHR5cGUsIGluZGV4ZWQgZnJvbSAwLlxuICAgICopXG4gICAgdmFsIGZpZWxkIDogJ2EgdCAtPiBpbnQgLT4gJ2EgZmllbGRcblxuICAgICgqKlxuICAgICAgIFRoaXMgaXMgYSBsb3cgbGV2ZWwgbWV0YWRhdGEgcmVnYXJkaW5nIHRoZSB3YXkgdGhlIG9jYW1sIGNvbXBpbGVyIHJlcHJlc2VudCB0aGVcbiAgICAgICBhcnJheSB1bmRlcm5lYXRoIHRoYXQgaXMgdGhlIHJ1bnRpbWUgdmFsdWUgb2YgYSByZWNvcmQgb2YgdHlwZSBbJ2FdIGdpdmVuIGEgd2l0bmVzc1xuICAgICAgIG9mIHR5cGUgWydhIHRdLiBbaGFzX2RvdWJsZV9hcnJheV90YWcgd10gcmV0dXJucyBbdHJ1ZV0gaWYgdGhlIGFycmF5IHRoYXRcbiAgICAgICByZXByZXNlbnRzIHJ1bnRpbWUgdmFsdWVzIG9mIHRoaXMgdHlwZSBpcyBhbiBvcHRpbWl6ZWQgb2NhbWwgZmxvYXQgYXJyYXkuXG4gICAgICAgVHlwaWNhbGx5LCB0aGlzIHdpbGwgYmUgdHJ1ZSBmb3IgcmVjb3JkIHdoZXJlIGFsbCBmaWVsZHMgYXJlIHN0YXRpY2FsbHkga25vd24gYXMgdG9cbiAgICAgICBiZSBbZmxvYXRzXS5cblxuICAgICAgIE5vdGUgdGhhdCB5b3UgY2FuJ3QgZ2V0IHRoaXMgaW5mb3JtYXRpb24gZHluYW1pY2FsbHkgYnkgaW5zcGVjdGluZyB0aGUgdHlwZXJlcCBvbmNlXG4gICAgICAgaXQgaXMgYXBwbGllZCwgYmVjYXVzZSB0aGVyZSBpcyBhdCB0aGlzIHBvaW50IG5vIHdheSB0byB0ZWxsIHdoZXRoZXIgb25lIG9mIHRoZVxuICAgICAgIGZpZWxkIGlzIHBvbHltb3JwaGljIGluIHRoZSB0eXBlIGRlZmluaXRpb24uXG4gICAgKilcbiAgICB2YWwgaGFzX2RvdWJsZV9hcnJheV90YWcgOiBfIHQgLT4gYm9vbFxuXG4gICAgKCoqXG4gICAgICAgRXhwb3NlIG9uZSBkaXJlY3Rpb24gb2YgdGhlIGlzb21vcnBoaXNtIGJldHdlZW4gYSB2YWx1ZSBvZiB0eXBlIFsnYV0gYW5kIGEgdmFsdWUgb2ZcbiAgICAgICB0eXBlIFsnYSBmaWVsZHNdLiBCYXNpY2FsbHksIGdpdmVuIGFuIGVuY29kaW5nIHdheSBvZiBhY2Nlc3NpbmcgdGhlIHZhbHVlIG9mIGFsbFxuICAgICAgIHRoZSBmaWVsZHMgb2YgYSByZWNvcmQsIGNyZWF0ZSB0aGF0IHJlY29yZCBhbmQgcmV0dXJuIGl0LlxuICAgICopXG4gICAgdmFsIGNyZWF0ZSA6ICdhIHQgLT4gJ2EgZmllbGRzIC0+ICdhXG5cbiAgICAoKipcbiAgICAgICBmb2xkaW5nIGFsb25nIHRoZSB0YWdzIG9mIHRoZSB2YXJpYW50IHR5cGVcbiAgICAqKVxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSBmaWVsZCAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAnYSBSZWNvcmRfaW50ZXJuYWwudCAtPiAnYSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgUmVjb3JkX2ludGVybmFsXG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCB0ID0gdC50eXBlbmFtZVxuICAgIGxldCBsZW5ndGggdCA9IEFycmF5Lmxlbmd0aCB0LmZpZWxkc1xuICAgIGxldCBmaWVsZCB0IGluZGV4ID0gdC5maWVsZHMuKGluZGV4KVxuICAgIGxldCBoYXNfZG91YmxlX2FycmF5X3RhZyB0ID0gdC5oYXNfZG91YmxlX2FycmF5X3RhZ1xuICAgIGxldCBjcmVhdGUgdCA9IHQuY3JlYXRlXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEFycmF5LmZvbGRfbGVmdCBmIGluaXQgdC5maWVsZHNcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIE0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIHJlcFxuICBlbmQpXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jaGVja19ib3VuZCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0FycmF5IiwiTSIsIlgiLCJUYWdfaW50ZXJuYWwiLCJsYWJlbCIsInQiLCJhcml0eSIsImFyZ3NfbGFiZWxzIiwiaW5kZXgiLCJvY2FtbF9yZXByIiwiY3JlYXRlIiwidHlpZCIsInRyYXZlcnNlIiwiaW50ZXJuYWxfdXNlX29ubHkiLCJUYWciLCJWYXJpYW50X2ludGVybmFsIiwidHlwZW5hbWVfb2ZfdCIsImxlbmd0aCIsInRhZyIsImlzX3BvbHltb3JwaGljIiwidmFsdWUiLCJmb2xkIiwiaW5pdCIsImYiLCJWYXJpYW50IiwiRmllbGRfaW50ZXJuYWwiLCJnZXQiLCJpc19tdXRhYmxlIiwiRmllbGQiLCJSZWNvcmRfaW50ZXJuYWwiLCJmaWVsZCIsImhhc19kb3VibGVfYXJyYXlfdGFnIiwiUmVjb3JkIiwiVHlwZXJlcF9saWJfVmFyaWFudF9hbmRfcmVjb3JkIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxFQUFBQztBQUFBQSxRQUFBQyxlQUFBO0FBQUEsYUFBQUMsTUFBQUMsR0M0TmtCLFlBQU87QUFBQSxhQUFBQyxNQUFBRCxHQUNQLFlBQU87QUFBQSxhQUFBRSxZQUFBRixHQUNELFlBQWE7QUFBQSxhQUFBRyxNQUFBSCxHQUNuQixZQUFPO0FBQUEsYUFBQUksV0FBQUosR0FDRixZQUFZO0FBQUEsYUFBQUssT0FBQUwsR0FDaEIsWUFBUTtBQUFBLGFBQUFNLEtBQUFOLEdBQ1YsWUFBTTtBQUFBLGFBQUFPLFNBQUFQLEdBQ0YsWUFBSztBQUFBLGFBQUFRLGtCQUFBUixHQUNJLFNBQUM7QUFBQTtBQUFBLEtBQUFTO0FBQUFBLE9EcE8vQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDLG1CQUFBO0FBQUEsYUFBQUMsY0FBQVgsR0M4UzBCLFlBQVU7QUFBQSxhQUFBWSxPQUFBWixHQUNqQix1QkFBbUI7QUFBQSxhQUFBYSxJQUFBYixHQUFBRyxPQUNoQiwrQ0FBYztBQUFBLGFBQUFXLGVBQUFkLEdBQ1QsWUFBYTtBQUFBLGFBQUFlLE1BQUFmLEdBQ3RCLFlBQU87QUFBQSxhQUFBZ0IsS0FBQWhCLEdBQUFpQixNQUFBQztBQUFBQSxLQUNDLGlEQUE2QjtBQUFBO0FBQUEsYUFBQVYsb0JBQUFSLEdBQ3pCLFNBQUM7QUFBQTtBQUFBLEtBQUFtQjtBQUFBQSxPRHBUL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQUFDLGlCQUFBO0FBQUEsYUFBQXJCLFFBQUFDLEdDbVlrQixZQUFPO0FBQUEsYUFBQUcsUUFBQUgsR0FDUCxZQUFPO0FBQUEsYUFBQXFCLElBQUFyQixHQUNULFlBQUs7QUFBQSxhQUFBc0IsV0FBQXRCLEdBQ0UsWUFBWTtBQUFBLGFBQUFNLE9BQUFOLEdBQ2xCLFlBQU07QUFBQSxhQUFBTyxXQUFBUCxHQUNGLFlBQUs7QUFBQSxhQUFBUSxvQkFBQVIsR0FDSSxTQUFDO0FBQUE7QUFBQSxLQUFBdUI7QUFBQUEsT0R6WS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBQyxrQkFBQTtBQUFBLGFBQUFiLGdCQUFBWCxHQ3lkMEIsWUFBVTtBQUFBLGFBQUFZLFNBQUFaLEdBQ2pCLHVCQUFxQjtBQUFBLGFBQUF5QixNQUFBekIsR0FBQUcsT0FDaEIsK0NBQWdCO0FBQUEsYUFBQXVCLHFCQUFBMUIsR0FDUCxZQUFzQjtBQUFBLGFBQUFLLFNBQUFMLEdBQ3BDLFlBQVE7QUFBQSxhQUFBZ0IsT0FBQWhCLEdBQUFpQixNQUFBQztBQUFBQSxLQUNELGlEQUErQjtBQUFBO0FBQUEsYUFBQVYsb0JBQUFSLEdBQzNCLFNBQUM7QUFBQTtBQUFBLEtBQUEyQjtBQUFBQSxPRC9kL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdDNENLO0FBQUEsT0FBQUMsaUNENUNMIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzg5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdHlwZXJlcC9zdGRfaW50ZXJuYWwubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgTmFtZV9vZiA9IHN0cnVjdFxuICBsZXQgdHlwZW5hbWVfb2ZfaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQzMiA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50MzJcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50MzJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2ludDY0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnQ2NFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJpbnQ2NFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfbmF0aXZlaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBuYXRpdmVpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwibmF0aXZlaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9jaGFyID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBjaGFyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImNoYXJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Zsb2F0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBmbG9hdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJmbG9hdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2Zfc3RyaW5nID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICBsZXQgbmFtZSA9IFwic3RyaW5nXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ieXRlcyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYnl0ZXNcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Jvb2wgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJvb2xcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYm9vbFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdW5pdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJ1bml0XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIG1vZHVsZSBNX29wdGlvbiA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICAgIGxldCBuYW1lID0gXCJvcHRpb25cIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX29wdGlvbiA9IE1fb3B0aW9uLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9saXN0ID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgIGxldCBuYW1lID0gXCJsaXN0XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9saXN0ID0gTV9saXN0LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9hcnJheSA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBhcnJheVxuXG4gICAgbGV0IG5hbWUgPSBcImFycmF5XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9hcnJheSA9IE1fYXJyYXkudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2xhenlfdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuICAgIGxldCBuYW1lID0gXCJsYXp5X3RcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2xhenlfdCA9IE1fbGF6eV90LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9yZWYgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgcmVmXG5cbiAgICBsZXQgbmFtZSA9IFwicmVmXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9yZWYgPSBNX3JlZi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fZnVuY3Rpb24gPSBUeXBlbmFtZS5NYWtlMiAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgLT4gJ2JcblxuICAgIGxldCBuYW1lID0gXCJmdW5jdGlvblwiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfZnVuY3Rpb24gPSBNX2Z1bmN0aW9uLnR5cGVuYW1lX29mX3RcblxuICB0eXBlIHR1cGxlMCA9IHVuaXRcblxuICBtb2R1bGUgTV90dXBsZTAgPSBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgdHlwZSB0ID0gdHVwbGUwXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGUwXCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTAgPSBNX3R1cGxlMC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUyID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhICogJ2JcblxuICAgIGxldCBuYW1lID0gXCJ0dXBsZTJcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMiA9IE1fdHVwbGUyLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTMgPSBUeXBlbmFtZS5NYWtlMyAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdhICogJ2IgKiAnY1xuXG4gICAgbGV0IG5hbWUgPSBcInR1cGxlM1wiXG4gIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUzID0gTV90dXBsZTMudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNCA9IFR5cGVuYW1lLk1ha2U0IChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA9ICdhICogJ2IgKiAnYyAqICdkXG5cbiAgICBsZXQgbmFtZSA9IFwidHVwbGU0XCJcbiAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTQgPSBNX3R1cGxlNC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGU1ID0gVHlwZW5hbWUuTWFrZTUgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA9ICdhICogJ2IgKiAnYyAqICdkICogJ2VcblxuICAgIGxldCBuYW1lID0gXCJ0dXBsZTVcIlxuICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlNSA9IE1fdHVwbGU1LnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgcmVjIFR5cGVyZXAgOiBzaWdcbiAgdHlwZSBfIHQgPVxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEludDMyIDogaW50MzIgdFxuICAgIHwgSW50NjQgOiBpbnQ2NCB0XG4gICAgfCBOYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICAgIHwgQ2hhciA6IGNoYXIgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgQnl0ZXMgOiBieXRlcyB0XG4gICAgfCBCb29sIDogYm9vbCB0XG4gICAgfCBVbml0IDogdW5pdCB0XG4gICAgfCBPcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgfCBMaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB8IEFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gICAgfCBMYXp5IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICAgIHwgUmVmIDogJ2EgdCAtPiAnYSByZWYgdFxuICAgIHwgRnVuY3Rpb24gOiAoJ2RvbSB0ICogJ3JuZyB0KSAtPiAoJ2RvbSAtPiAncm5nKSB0XG4gICAgfCBUdXBsZSA6ICdhIFR5cGVyZXAuVHVwbGUudCAtPiAnYSB0XG4gICAgfCBSZWNvcmQgOiAnYSBUeXBlcmVwLlJlY29yZC50IC0+ICdhIHRcbiAgICB8IFZhcmlhbnQgOiAnYSBUeXBlcmVwLlZhcmlhbnQudCAtPiAnYSB0XG4gICAgfCBOYW1lZCA6ICgnYSBUeXBlcmVwLk5hbWVkLnQgKiAnYSB0IGxhenlfdCBvcHRpb24pIC0+ICdhIHRcblxuICB0eXBlIHBhY2tlZCA9IFQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFQwID0gc2lnXG4gICAgICB0eXBlIG5hbWVkXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQxID0gc2lnXG4gICAgICB0eXBlICdhIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgYSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMiA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2IgVHlwZW5hbWUudCAtPiAoJ2EsICdiKSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQzID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYykgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ0ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNSA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBlXG5cbiAgICAgIHZhbCBlIDogZSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdlIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQsIGUpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgICgqIHRoZXJlIHRoZSBtb2R1bGUgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggYSB0eXBlIFt0XSB3aXRoXG4gICAgICAgcGFyYW1ldGVycyB3aG9zZSBraW5kIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgdHlwZSB2YXJpYWJsZTogWydhICd0XSwgZXZlbiB3aXRoXG4gICAgICAgYSBnYWR0LiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFQwIG9mIChtb2R1bGUgVDAgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDEgb2YgKG1vZHVsZSBUMSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMiBvZiAobW9kdWxlIFQyIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQzIG9mIChtb2R1bGUgVDMgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDQgb2YgKG1vZHVsZSBUNCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNSBvZiAobW9kdWxlIFQ1IHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIFR1cGxlIDogc2lnXG4gICAgKCogdGhlc2UgY29uc3RydWN0b3JzIGNvdWxkIGJlIHBsdW5nZWQgYXQgdG9wbGV2ZWwgb2YgVHlwZXJlcC50LCBob3dldmVyIGl0IGlzIGxlc3NcbiAgICAgICB2ZXJib3NlIHRoYXQgd2F5ICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBUMiA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQpIC0+ICgnYSAqICdiKSB0XG4gICAgICB8IFQzIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCkgLT4gKCdhICogJ2IgKiAnYykgdFxuICAgICAgfCBUNCA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgICAgIHwgVDUgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQgKiAnZSBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkICogJ2UpIHRcblxuICAgIHZhbCBhcml0eSA6IF8gdCAtPiBpbnRcbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVHlwZXJlcC50XG5cbiAgdmFsIHNhbWUgOiBfIHQgLT4gXyB0IC0+IGJvb2xcbiAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG4gIHZhbCBzYW1lX3dpdG5lc3NfZXhuIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSwgJ2IpIFR5cGVfZXF1YWwudFxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICB2YWwgaGVhZCA6ICdhIHQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IGFyaXR5ID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgXyAtPiAwXG4gICAgICB8IFQxIF8gLT4gMVxuICAgICAgfCBUMiBfIC0+IDJcbiAgICAgIHwgVDMgXyAtPiAzXG4gICAgICB8IFQ0IF8gLT4gNFxuICAgICAgfCBUNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgKHR5cGUgYSkgPSBmdW5jdGlvblxuICAgICAgfCBUMCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMiByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMiB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMyByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgbmFtZSByZXAgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkICh0eXBlbmFtZV9vZl90IHJlcCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA9IHN0cnVjdFxuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGlzIHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICBsZXQgYXJpdHkgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIF8gLT4gMlxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIF8gLT4gM1xuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IF8gLT4gNFxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IF8gLT4gNVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgICB8IFQyIChhLCBiKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlMiAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgIHwgVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGUzXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICB8IFQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNFxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgIHwgVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGU1XG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBkKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLk0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIHJlcFxuICBlbmQpXG5cbiAgbGV0IHJlYyB0eXBlbmFtZV9vZl90IDogdHlwZSBhLiBhIHQgLT4gYSBUeXBlbmFtZS50ID0gZnVuY3Rpb25cbiAgICB8IEludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2ludFxuICAgIHwgSW50MzIgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQzMlxuICAgIHwgSW50NjQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQ2NFxuICAgIHwgTmF0aXZlaW50IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbmF0aXZlaW50XG4gICAgfCBDaGFyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfY2hhclxuICAgIHwgRmxvYXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9mbG9hdFxuICAgIHwgU3RyaW5nIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfc3RyaW5nXG4gICAgfCBCeXRlcyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2J5dGVzXG4gICAgfCBCb29sIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfYm9vbFxuICAgIHwgVW5pdCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3VuaXRcbiAgICB8IE9wdGlvbiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9vcHRpb24gKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgTGlzdCByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9saXN0ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEFycmF5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2FycmF5ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExhenkgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGF6eV90ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IFJlZiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9yZWYgKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgRnVuY3Rpb24gKGRvbSwgcm5nKSAtPlxuICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl9mdW5jdGlvbiAodHlwZW5hbWVfb2ZfdCBkb20pICh0eXBlbmFtZV9vZl90IHJuZylcbiAgICB8IFR1cGxlIHJlcCAtPiBUeXBlcmVwLlR1cGxlLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBSZWNvcmQgcmVwIC0+IFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBWYXJpYW50IHJlcCAtPiBUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByZXBcbiAgICB8IE5hbWVkIChuYW1lLCBfKSAtPiBOYW1lZC50eXBlbmFtZV9vZl90IG5hbWVcbiAgOztcblxuICBsZXQgcmVjIHNhbWVfd2l0bmVzcyA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBUeXBlX2VxdWFsLnQgb3B0aW9uID1cbiAgICBmdW4gdDEgdDIgLT5cbiAgICBsZXQgbW9kdWxlIEUgPSBUeXBlX2VxdWFsIGluXG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IE5hbWVkIChuYW1lMSwgcjEpLCBOYW1lZCAobmFtZTIsIHIyKSAtPlxuICAgICAgKG1hdGNoXG4gICAgICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3MgKE5hbWVkLnR5cGVuYW1lX29mX3QgbmFtZTEpIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUyKVxuICAgICAgIHdpdGhcbiAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgKG1hdGNoIHIxLCByMiB3aXRoXG4gICAgICAgICAgfCBTb21lIChsYXp5IHQxKSwgU29tZSAobGF6eSB0MikgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgfCBTb21lIChsYXp5IHQxKSwgTm9uZSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lKSlcbiAgICB8IE5hbWVkIChfLCByMSksIHQyIC0+XG4gICAgICAobWF0Y2ggcjEgd2l0aFxuICAgICAgIHwgU29tZSAobGF6eSB0MSkgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCB0MSwgTmFtZWQgKF8sIHIyKSAtPlxuICAgICAgKG1hdGNoIHIyIHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgSW50LCBJbnQgLT4gU29tZSBFLlRcbiAgICB8IEludDMyLCBJbnQzMiAtPiBTb21lIEUuVFxuICAgIHwgSW50NjQsIEludDY0IC0+IFNvbWUgRS5UXG4gICAgfCBOYXRpdmVpbnQsIE5hdGl2ZWludCAtPiBTb21lIEUuVFxuICAgIHwgQ2hhciwgQ2hhciAtPiBTb21lIEUuVFxuICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRS5UXG4gICAgfCBTdHJpbmcsIFN0cmluZyAtPiBTb21lIEUuVFxuICAgIHwgQnl0ZXMsIEJ5dGVzIC0+IFNvbWUgRS5UXG4gICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRS5UXG4gICAgfCBVbml0LCBVbml0IC0+IFNvbWUgRS5UXG4gICAgfCBPcHRpb24gcjEsIE9wdGlvbiByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgTGlzdCByMSwgTGlzdCByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgQXJyYXkgcjEsIEFycmF5IHIyIC0+XG4gICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgfCBMYXp5IHIxLCBMYXp5IHIyIC0+XG4gICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgfCBTb21lIEUuVCBhcyB4IC0+IHgpXG4gICAgfCBSZWYgcjEsIFJlZiByMiAtPlxuICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgfCBOb25lIGFzIHggLT4geFxuICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgIHwgRnVuY3Rpb24gKGRvbTEsIHJuZzEpLCBGdW5jdGlvbiAoZG9tMiwgcm5nMikgLT5cbiAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgZG9tMSBkb20yLCBzYW1lX3dpdG5lc3Mgcm5nMSBybmcyIHdpdGhcbiAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICB8IFR1cGxlIHQxLCBUdXBsZSB0MiAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gVHlwZXJlcC5UdXBsZSBpblxuICAgICAgKG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgfCBULlQyIChhMSwgYjEpLCBULlQyIChhMiwgYjIpIC0+XG4gICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIgd2l0aFxuICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgIHwgVC5UMyAoYTEsIGIxLCBjMSksIFQuVDMgKGEyLCBiMiwgYzIpIC0+XG4gICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIsIHNhbWVfd2l0bmVzcyBjMSBjMiB3aXRoXG4gICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICB8IFQuVDQgKGExLCBiMSwgYzEsIGQxKSwgVC5UNCAoYTIsIGIyLCBjMiwgZDIpIC0+XG4gICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfLCBfIHwgXywgTm9uZSwgXywgXyB8IF8sIF8sIE5vbmUsIF8gfCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgfCBULlQ1IChhMSwgYjEsIGMxLCBkMSwgZTEpLCBULlQ1IChhMiwgYjIsIGMyLCBkMiwgZTIpIC0+XG4gICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICggc2FtZV93aXRuZXNzIGExIGEyXG4gICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBiMSBiMlxuICAgICAgICAgICAgLCBzYW1lX3dpdG5lc3MgYzEgYzJcbiAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGQxIGQyXG4gICAgICAgICAgICAsIHNhbWVfd2l0bmVzcyBlMSBlMiApXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgfCBOb25lLCBfLCBfLCBfLCBfXG4gICAgICAgICAgfCBfLCBOb25lLCBfLCBfLCBfXG4gICAgICAgICAgfCBfLCBfLCBOb25lLCBfLCBfXG4gICAgICAgICAgfCBfLCBfLCBfLCBOb25lLCBfXG4gICAgICAgICAgfCBfLCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgfCBULlQyIF8sIF8gLT4gTm9uZVxuICAgICAgIHwgVC5UMyBfLCBfIC0+IE5vbmVcbiAgICAgICB8IFQuVDQgXywgXyAtPiBOb25lXG4gICAgICAgfCBULlQ1IF8sIF8gLT4gTm9uZSlcbiAgICB8IFJlY29yZCByMSwgUmVjb3JkIHIyIC0+XG4gICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3NcbiAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgIChUeXBlcmVwLlJlY29yZC50eXBlbmFtZV9vZl90IHIyKVxuICAgIHwgVmFyaWFudCByMSwgVmFyaWFudCByMiAtPlxuICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMSlcbiAgICAgICAgKFR5cGVyZXAuVmFyaWFudC50eXBlbmFtZV9vZl90IHIyKVxuICAgIHwgSW50LCBfIC0+IE5vbmVcbiAgICB8IEludDMyLCBfIC0+IE5vbmVcbiAgICB8IEludDY0LCBfIC0+IE5vbmVcbiAgICB8IE5hdGl2ZWludCwgXyAtPiBOb25lXG4gICAgfCBDaGFyLCBfIC0+IE5vbmVcbiAgICB8IEZsb2F0LCBfIC0+IE5vbmVcbiAgICB8IFN0cmluZywgXyAtPiBOb25lXG4gICAgfCBCeXRlcywgXyAtPiBOb25lXG4gICAgfCBCb29sLCBfIC0+IE5vbmVcbiAgICB8IFVuaXQsIF8gLT4gTm9uZVxuICAgIHwgT3B0aW9uIF8sIF8gLT4gTm9uZVxuICAgIHwgTGlzdCBfLCBfIC0+IE5vbmVcbiAgICB8IEFycmF5IF8sIF8gLT4gTm9uZVxuICAgIHwgTGF6eSBfLCBfIC0+IE5vbmVcbiAgICB8IFJlZiBfLCBfIC0+IE5vbmVcbiAgICB8IEZ1bmN0aW9uIF8sIF8gLT4gTm9uZVxuICAgIHwgVHVwbGUgXywgXyAtPiBOb25lXG4gICAgfCBSZWNvcmQgXywgXyAtPiBOb25lXG4gICAgfCBWYXJpYW50IF8sIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lIGEgYiA9IHNhbWVfd2l0bmVzcyBhIGIgPD4gTm9uZVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIGEgYiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIGEgYiB3aXRoXG4gICAgfCBTb21lIHByb29mIC0+IHByb29mXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgaGVhZCA9IGZ1bmN0aW9uXG4gICAgfCBUeXBlcmVwLk5hbWVkIChfLCBTb21lIChsYXp5IHQpKSAtPiBoZWFkIHRcbiAgICB8IHQgLT4gdFxuICA7O1xuZW5kXG5cbmxldCB0eXBlcmVwX29mX2ludCA9IFR5cGVyZXAuSW50XG5sZXQgdHlwZXJlcF9vZl9pbnQzMiA9IFR5cGVyZXAuSW50MzJcbmxldCB0eXBlcmVwX29mX2ludDY0ID0gVHlwZXJlcC5JbnQ2NFxubGV0IHR5cGVyZXBfb2ZfbmF0aXZlaW50ID0gVHlwZXJlcC5OYXRpdmVpbnRcbmxldCB0eXBlcmVwX29mX2NoYXIgPSBUeXBlcmVwLkNoYXJcbmxldCB0eXBlcmVwX29mX2Zsb2F0ID0gVHlwZXJlcC5GbG9hdFxubGV0IHR5cGVyZXBfb2Zfc3RyaW5nID0gVHlwZXJlcC5TdHJpbmdcbmxldCB0eXBlcmVwX29mX2J5dGVzID0gVHlwZXJlcC5CeXRlc1xubGV0IHR5cGVyZXBfb2ZfYm9vbCA9IFR5cGVyZXAuQm9vbFxubGV0IHR5cGVyZXBfb2ZfdW5pdCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2Zfb3B0aW9uIHJlcCA9IFR5cGVyZXAuT3B0aW9uIHJlcFxubGV0IHR5cGVyZXBfb2ZfbGlzdCByZXAgPSBUeXBlcmVwLkxpc3QgcmVwXG5sZXQgdHlwZXJlcF9vZl9hcnJheSByZXAgPSBUeXBlcmVwLkFycmF5IHJlcFxubGV0IHR5cGVyZXBfb2ZfbGF6eV90IHJlcCA9IFR5cGVyZXAuTGF6eSByZXBcbmxldCB0eXBlcmVwX29mX3JlZiByZXAgPSBUeXBlcmVwLlJlZiByZXBcbmxldCB0eXBlcmVwX29mX2Z1bmN0aW9uIGRvbSBybmcgPSBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZylcbmxldCB0eXBlcmVwX29mX3R1cGxlMCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2ZfdHVwbGUyIGEgYiA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGUzIGEgYiBjID0gVHlwZXJlcC5UdXBsZSAoVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTQgYSBiIGMgZCA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU1IGEgYiBjIGQgZSA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpKVxuXG5pbmNsdWRlIE5hbWVfb2ZcblxubGV0IHZhbHVlX3R1cGxlMCA9ICgpXG5cbmxldCB0eXBlcmVwX29mX2ludDYzLCB0eXBlbmFtZV9vZl9pbnQ2MyA9XG4gIGxldCB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByXG4gICAgOiB0eXBlIGEgYi4gKGEsIGIpIEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLnQgLT4gYSBUeXBlcmVwLnQgKiBhIFR5cGVuYW1lLnRcbiAgICA9IGZ1bmN0aW9uXG4gICAgfCBCYXNlLkludDYzLlByaXZhdGUuUmVwci5JbnQgLT4gdHlwZXJlcF9vZl9pbnQsIHR5cGVuYW1lX29mX2ludFxuICAgIHwgQmFzZS5JbnQ2My5Qcml2YXRlLlJlcHIuSW50NjQgLT4gdHlwZXJlcF9vZl9pbnQ2NCwgdHlwZW5hbWVfb2ZfaW50NjRcbiAgaW5cbiAgdHlwZXJlcF9hbmRfdHlwZW5hbWVfb2ZfaW50NjNfcmVwciBCYXNlLkludDYzLlByaXZhdGUucmVwclxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2xpYl9zdGRfaW50ZXJuYWxfbWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJuYW1lIiwiVHlwZXJlcF9saWJfVHlwZW5hbWUiLCJDYW1saW50ZXJuYWxMYXp5IiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxNb2QiLCJUeXBlcmVwX2xpYl9WYXJpYW50X2FuZF9yZWNvcmQiLCJCYXNlX0ludDYzIiwidHlwZW5hbWVfb2ZfaW50IiwidHlwZW5hbWVfb2ZfaW50MzIiLCJ0eXBlbmFtZV9vZl9pbnQ2NCIsInR5cGVuYW1lX29mX25hdGl2ZWludCIsInR5cGVuYW1lX29mX2NoYXIiLCJ0eXBlbmFtZV9vZl9mbG9hdCIsInR5cGVuYW1lX29mX3N0cmluZyIsInR5cGVuYW1lX29mX2J5dGVzIiwidHlwZW5hbWVfb2ZfYm9vbCIsInR5cGVuYW1lX29mX3VuaXQiLCJNX29wdGlvbiIsInR5cGVuYW1lX29mX29wdGlvbiIsIk1fbGlzdCIsInR5cGVuYW1lX29mX2xpc3QiLCJNX2FycmF5IiwidHlwZW5hbWVfb2ZfYXJyYXkiLCJNX2xhenlfdCIsInR5cGVuYW1lX29mX2xhenlfdCIsIk1fcmVmIiwidHlwZW5hbWVfb2ZfcmVmIiwiTV9mdW5jdGlvbiIsInR5cGVuYW1lX29mX2Z1bmN0aW9uIiwiTV90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJNX3R1cGxlMiIsInR5cGVuYW1lX29mX3R1cGxlMiIsIk1fdHVwbGUzIiwidHlwZW5hbWVfb2ZfdHVwbGUzIiwiTV90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJNX3R1cGxlNSIsInR5cGVuYW1lX29mX3R1cGxlNSIsIlR5cGVyZXAiLCJhcml0eSIsInBhcmFtIiwidHlwZW5hbWVfb2ZfdCIsInJlcCIsIk5hbWVkIiwibWF0Y2giLCJiIiwiYSIsImMiLCJkIiwiZSIsIlR1cGxlIiwiaW5jbHVkZSIsIlRhZ19pbnRlcm5hbCIsIlRhZyIsIlZhcmlhbnRfaW50ZXJuYWwiLCJWYXJpYW50IiwiRmllbGRfaW50ZXJuYWwiLCJGaWVsZCIsIlJlY29yZF9pbnRlcm5hbCIsIlJlY29yZCIsInJuZyIsImRvbSIsInNhbWVfd2l0bmVzcyIsInQxIiwidDIiLCJyMSIsInIyIiwieCIsInJuZzEiLCJkb20xIiwicm5nMiIsImRvbTIiLCJuYW1lMSIsIm5hbWUyIiwiYjIiLCJiMSIsImMyIiwiYzEiLCJkMiIsImQxIiwiZTIiLCJlMSIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwicHJvb2YiLCJoZWFkIiwidCIsInR5cGVyZXBfb2ZfaW50IiwidHlwZXJlcF9vZl9pbnQ2NCIsInR5cGVyZXBfb2Zfb3B0aW9uIiwidHlwZXJlcF9vZl9saXN0IiwidHlwZXJlcF9vZl9hcnJheSIsInR5cGVyZXBfb2ZfbGF6eV90IiwidHlwZXJlcF9vZl9yZWYiLCJ0eXBlcmVwX29mX2Z1bmN0aW9uIiwidHlwZXJlcF9vZl90dXBsZTIiLCJ0eXBlcmVwX29mX3R1cGxlMyIsInR5cGVyZXBfb2ZfdHVwbGU0IiwidHlwZXJlcF9vZl90dXBsZTUiLCJ0eXBlcmVwX29mX2ludDMyIiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2NoYXIiLCJ0eXBlcmVwX29mX2Zsb2F0IiwidHlwZXJlcF9vZl9zdHJpbmciLCJ0eXBlcmVwX29mX2J5dGVzIiwidHlwZXJlcF9vZl9ib29sIiwidHlwZXJlcF9vZl91bml0IiwidHlwZXJlcF9vZl90dXBsZTAiLCJ2YWx1ZV90dXBsZTAiLCJ0eXBlbmFtZV9vZl9pbnQ2MyIsInR5cGVyZXBfb2ZfaW50NjMiLCJUeXBlcmVwX2xpYl9TdGRfaW50ZXJuYWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFBLFVBQUE7QUFBQSxJQUFBQSxVQUFBO0FBQUEsSUFBQUEsVUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUM7QUFB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MTEwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJUeXBlcmVwX2xpYl9UeXBlcmVwYWJsZSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLDBCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTEyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL3R5cGVyZXAvdHlwZXJlcF9vYmoubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiB1c2luZyB0aGUgaGFzaF92YXJpYW50IG9mIHBhX3R5cGVfY29udiBhdCBjb21waWxlIHRpbWUgKilcbmxldCByZXByX29mX3BvbHlfdmFyaWFudCA6IFs+IF0gLT4gaW50ID1cbiAgZnVuIHZhcmlhbnQgLT5cbiAgbGV0IG9iaiA9IE9iai5yZXByIHZhcmlhbnQgaW5cbiAgaWYgT2JqLmlzX2ludCBvYmpcbiAgdGhlbiBPYmoub2JqIG9ialxuICBlbHNlIChcbiAgICBsZXQgc2l6ZSA9IE9iai5zaXplIG9iaiBpblxuICAgIGFzc2VydCAoc2l6ZSA9IDIpO1xuICAgIGxldCByZXByID0gT2JqLmZpZWxkIG9iaiAwIGluXG4gICAgYXNzZXJ0IChPYmouaXNfaW50IHJlcHIpO1xuICAgIE9iai5vYmogcmVwcilcbjs7XG5cbmxldCBoYXNoX3ZhcmlhbnQgcyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9ICgyMjMgKiAhYWNjdSkgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgoMSBsc2wgMzEpIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3Vcbjs7XG5cbigqIGEgZmV3IHVuaXQgdGVzdHMgb2YgY2FzZXMgdGhhdCBoYXZlIHRyaWdnZXJlZCBkaWZmcyBpbiB0aGUgcGFzdCBvZiB0aGlzXG4gICBsaWIgKilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYExhdGVuY3lfc3RhdHMgPSBoYXNoX3ZhcmlhbnQgXCJMYXRlbmN5X3N0YXRzXCIpXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGB6ZXJvID0gaGFzaF92YXJpYW50IFwiemVyb1wiKVxubGV0W0BpbmxpbmUgbmV2ZXJdIGRvdWJsZV9hcnJheV92YWx1ZSAoKSA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9iai5tYWdpYyAwLilcbmxldCBoYXNfZG91YmxlX2FycmF5X3RhZyBhID0gT2JqLmRvdWJsZV9hcnJheV90YWcgPSBPYmoudGFnIChPYmoucmVwciBhKVxuXG5sZXQgKCkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIGRvdWJsZSA9XG4gICAgICB7IGEgOiBmbG9hdFxuICAgICAgOyBiIDogZmxvYXRcbiAgICAgIH1cblxuICAgIHR5cGUgc2ltcGxlID1cbiAgICAgIHsgYyA6IGZsb2F0XG4gICAgICA7IGQgOiBpbnRcbiAgICAgIH1cblxuICAgIGxldCBkb3VibGUgPSB7IGEgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCk7IGIgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCkgfVxuICAgIGxldCBzaW1wbGUgPSB7IGMgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCk7IGQgPSBkb3VibGVfYXJyYXlfdmFsdWUgKCkgfVxuICBlbmRcbiAgaW5cbiAgYXNzZXJ0IChoYXNfZG91YmxlX2FycmF5X3RhZyBNLmRvdWJsZSk7XG4gIGFzc2VydCAobm90IChoYXNfZG91YmxlX2FycmF5X3RhZyBNLnNpbXBsZSkpXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbGliX3R5cGVyZXBfb2JqX21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfT2JqIiwiQXNzZXJ0X2ZhaWx1cmUiLCJyZXByX29mX3BvbHlfdmFyaWFudCIsInZhcmlhbnQiLCJzaXplIiwicmVwciIsImhhc2hfdmFyaWFudCIsInMiLCJhY2N1IiwiaSIsImNzdF96ZXJvIiwiZG91YmxlX2FycmF5X3ZhbHVlIiwicGFyYW0iLCJoYXNfZG91YmxlX2FycmF5X3RhZyIsImEiLCJkb3VibGUiLCJzaW1wbGUiLCJUeXBlcmVwX2xpYl9UeXBlcmVwX29iaiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxxQkFBQUM7QUFBQUEsSUNJRSxnQ0FDSztBQUFBLFFBQUFDLE9BQ0E7QUFBQSxJQUVIO0FBQUE7QUFBQSxRQUFBQyxPQUNXO0FBQUEsSUFDWCw2QkFDQTtBQUFBLElBREE7QUFBQSxHQUNhO0FBQUEsWUFBQUMsYUFBQUM7QUFBQUEsUUFBQUMsT0FJZixZQUNBO0FBQUE7QUFBQSxTQUFBQyxJQUFBO0FBQUE7QUFBQSxjQUNvQztBQUFBLE1BQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFHekM7QUFBQSxJQUVBLGdFQUF3RDtBQUFBO0FBQUE7QUFBQSxRQUtIO0FBQUEsUUFBdEM7QUFBQSxJQUFBQyxXQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFtQztBQUFBLFdBQ047QUFBQSxHQUE3QjtBQUFBLElBQTBCO0FBQUEsWUFBQUMsbUJBQUFDLE9BQ0EsVUFBa0M7QUFBQSxZQUFBQyxxQkFBQUM7QUFBQUEsUUFBQSxJQUN6QjtBQUFBLElBQW9CO0FBQUE7QUFBQSxPQUFBQyxTQWM1QixlQUFBQyxTQUNBO0FBQUEsR0FHbkM7QUFBQSxJQUErQjtBQUFBLEdBQzFCO0FBQUEsSUFBK0I7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEakQ3QyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjExOTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXJlcF9saWIuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi90eXBlcmVwL3R5cGVfZ2VuZXJpY19pbnRmLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIE0gKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIGNvbXB1dGUgOiB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gKCdhLCAnYikgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAoJ2EsICdiLCAnYykgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAnZCBYLnQgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgWC50XG4gICAgICAtPiAnYiBYLnRcbiAgICAgIC0+ICdjIFgudFxuICAgICAgLT4gJ2QgWC50XG4gICAgICAtPiAnZSBYLnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgWC50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gIGVuZClcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJNIiwiWCIsIlR5cGVyZXBfbGliX1R5cGVfZ2VuZXJpY19pbnRmIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLEVBQUFDLEdBQUEsV0N5REc7QUFBQSxPQUFBQyxnQ0R6REgiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMjExLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdHlwZXJlcC90eXBlX2dlbmVyaWMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIFN0ZF9pbnRlcm5hbFxubW9kdWxlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmID0gVmFyaWFudF9hbmRfcmVjb3JkX2ludGZcblxubW9kdWxlIEhlbHBlciAoQSA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpIChCIDogVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUykgPSBzdHJ1Y3RcbiAgdHlwZSBtYXAgPSB7IG1hcCA6ICdhLiAnYSBBLnQgLT4gJ2EgQi50IH1cblxuICBsZXQgbWFwX3ZhcmlhbnQgKHR5cGUgdmFyaWFudCkgeyBtYXAgfSAodmFyaWFudCA6IHZhcmlhbnQgQS5WYXJpYW50LnQpID1cbiAgICBsZXQgbWFwX2NyZWF0ZSA9IGZ1bmN0aW9uXG4gICAgICB8IEEuVGFnLkFyZ3MgZmN0IC0+IEIuVGFnX2ludGVybmFsLkFyZ3MgZmN0XG4gICAgICB8IEEuVGFnLkNvbnN0IGsgLT4gQi5UYWdfaW50ZXJuYWwuQ29uc3Qga1xuICAgIGluXG4gICAgbGV0IG1hcF90YWcgdGFnID1cbiAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICB8IEEuVmFyaWFudC5UYWcgdGFnIC0+XG4gICAgICAgIGxldCBsYWJlbCA9IEEuVGFnLmxhYmVsIHRhZyBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLlRhZy50cmF2ZXJzZSB0YWcpIGluXG4gICAgICAgIGxldCBhcml0eSA9IEEuVGFnLmFyaXR5IHRhZyBpblxuICAgICAgICBsZXQgYXJnc19sYWJlbHMgPSBBLlRhZy5hcmdzX2xhYmVscyB0YWcgaW5cbiAgICAgICAgbGV0IGluZGV4ID0gQS5UYWcuaW5kZXggdGFnIGluXG4gICAgICAgIGxldCBvY2FtbF9yZXByID0gQS5UYWcub2NhbWxfcmVwciB0YWcgaW5cbiAgICAgICAgbGV0IHR5aWQgPSBBLlRhZy50eWlkIHRhZyBpblxuICAgICAgICBsZXQgY3JlYXRlID0gbWFwX2NyZWF0ZSAoQS5UYWcuY3JlYXRlIHRhZykgaW5cbiAgICAgICAgQi5WYXJpYW50X2ludGVybmFsLlRhZ1xuICAgICAgICAgIChCLlRhZy5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgICAgICAgIHsgQi5UYWdfaW50ZXJuYWwubGFiZWxcbiAgICAgICAgICAgICA7IHJlcFxuICAgICAgICAgICAgIDsgYXJpdHlcbiAgICAgICAgICAgICA7IGFyZ3NfbGFiZWxzXG4gICAgICAgICAgICAgOyBpbmRleFxuICAgICAgICAgICAgIDsgb2NhbWxfcmVwclxuICAgICAgICAgICAgIDsgdHlpZFxuICAgICAgICAgICAgIDsgY3JlYXRlXG4gICAgICAgICAgICAgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuVmFyaWFudC50eXBlbmFtZV9vZl90IHZhcmlhbnQgaW5cbiAgICBsZXQgcG9seW1vcnBoaWMgPSBBLlZhcmlhbnQuaXNfcG9seW1vcnBoaWMgdmFyaWFudCBpblxuICAgIGxldCB0YWdzID1cbiAgICAgIEFycmF5LmluaXQgKEEuVmFyaWFudC5sZW5ndGggdmFyaWFudCkgKGZ1biBpbmRleCAtPlxuICAgICAgICBtYXBfdGFnIChBLlZhcmlhbnQudGFnIHZhcmlhbnQgaW5kZXgpKVxuICAgIGluXG4gICAgbGV0IHZhbHVlIChhIDogdmFyaWFudCkgPVxuICAgICAgbWF0Y2ggQS5WYXJpYW50LnZhbHVlIHZhcmlhbnQgYSB3aXRoXG4gICAgICB8IEEuVmFyaWFudC5WYWx1ZSAoYXRhZywgYSkgLT5cbiAgICAgICAgKGZ1biAodHlwZSBhcmdzKSAoYXRhZyA6ICh2YXJpYW50LCBhcmdzKSBBLlRhZy50KSAoYSA6IGFyZ3MpIC0+XG4gICAgICAgICAgbGV0IChCLlZhcmlhbnRfaW50ZXJuYWwuVGFnIGJ0YWcpID0gdGFncy4oQS5UYWcuaW5kZXggYXRhZykgaW5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPVxuICAgICAgICAgICAgICBUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuIChBLlRhZy50eWlkIGF0YWcpIChCLlRhZy50eWlkIGJ0YWcpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IGJ0YWcgPSAoYnRhZyA6ICh2YXJpYW50LCBhcmdzKSBCLlRhZy50KSBpblxuICAgICAgICAgICAgQi5WYXJpYW50X2ludGVybmFsLlZhbHVlIChidGFnLCBhKSlcbiAgICAgICAgICAgIGJ0YWcpXG4gICAgICAgICAgYXRhZ1xuICAgICAgICAgIGFcbiAgICBpblxuICAgIEIuVmFyaWFudC5pbnRlcm5hbF91c2Vfb25seSB7IEIuVmFyaWFudF9pbnRlcm5hbC50eXBlbmFtZTsgdGFnczsgcG9seW1vcnBoaWM7IHZhbHVlIH1cbiAgOztcblxuICBsZXQgbWFwX3JlY29yZCAodHlwZSByZWNvcmQpIHsgbWFwIH0gKHJlY29yZCA6IHJlY29yZCBBLlJlY29yZC50KSA9XG4gICAgbGV0IG1hcF9maWVsZCBmaWVsZCA9XG4gICAgICBtYXRjaCBmaWVsZCB3aXRoXG4gICAgICB8IEEuUmVjb3JkLkZpZWxkIGZpZWxkIC0+XG4gICAgICAgIGxldCBsYWJlbCA9IEEuRmllbGQubGFiZWwgZmllbGQgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5GaWVsZC50cmF2ZXJzZSBmaWVsZCkgaW5cbiAgICAgICAgbGV0IGluZGV4ID0gQS5GaWVsZC5pbmRleCBmaWVsZCBpblxuICAgICAgICBsZXQgaXNfbXV0YWJsZSA9IEEuRmllbGQuaXNfbXV0YWJsZSBmaWVsZCBpblxuICAgICAgICBsZXQgdHlpZCA9IEEuRmllbGQudHlpZCBmaWVsZCBpblxuICAgICAgICBsZXQgZ2V0ID0gQS5GaWVsZC5nZXQgZmllbGQgaW5cbiAgICAgICAgQi5SZWNvcmRfaW50ZXJuYWwuRmllbGRcbiAgICAgICAgICAoQi5GaWVsZC5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgICAgICAgIHsgQi5GaWVsZF9pbnRlcm5hbC5sYWJlbDsgcmVwOyBpbmRleDsgaXNfbXV0YWJsZTsgdHlpZDsgZ2V0IH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlJlY29yZC50eXBlbmFtZV9vZl90IHJlY29yZCBpblxuICAgIGxldCBoYXNfZG91YmxlX2FycmF5X3RhZyA9IEEuUmVjb3JkLmhhc19kb3VibGVfYXJyYXlfdGFnIHJlY29yZCBpblxuICAgIGxldCBmaWVsZHMgPVxuICAgICAgQXJyYXkuaW5pdCAoQS5SZWNvcmQubGVuZ3RoIHJlY29yZCkgKGZ1biBpbmRleCAtPlxuICAgICAgICBtYXBfZmllbGQgKEEuUmVjb3JkLmZpZWxkIHJlY29yZCBpbmRleCkpXG4gICAgaW5cbiAgICBsZXQgY3JlYXRlIHsgQi5SZWNvcmRfaW50ZXJuYWwuZ2V0IH0gPVxuICAgICAgbGV0IGdldCAodHlwZSBhKSAoYWZpZWxkIDogKF8sIGEpIEEuRmllbGQudCkgPVxuICAgICAgICBtYXRjaCBmaWVsZHMuKEEuRmllbGQuaW5kZXggYWZpZWxkKSB3aXRoXG4gICAgICAgIHwgQi5SZWNvcmRfaW50ZXJuYWwuRmllbGQgYmZpZWxkIC0+XG4gICAgICAgICAgKGZ1biAodHlwZSBleCkgKGJmaWVsZCA6IChyZWNvcmQsIGV4KSBCLkZpZWxkLnQpIC0+XG4gICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5GaWVsZC50eWlkIGFmaWVsZCkgKEIuRmllbGQudHlpZCBiZmllbGQpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICBnZXQgYmZpZWxkKVxuICAgICAgICAgICAgYmZpZWxkXG4gICAgICBpblxuICAgICAgQS5SZWNvcmQuY3JlYXRlIHJlY29yZCB7IEEuUmVjb3JkLmdldCB9XG4gICAgaW5cbiAgICBCLlJlY29yZC5pbnRlcm5hbF91c2Vfb25seVxuICAgICAgeyBCLlJlY29yZF9pbnRlcm5hbC50eXBlbmFtZTsgZmllbGRzOyBoYXNfZG91YmxlX2FycmF5X3RhZzsgY3JlYXRlIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBOYW1lZCA9IHNpZ1xuICB0eXBlICdhIGNvbXB1dGF0aW9uXG5cbiAgbW9kdWxlIENvbnRleHQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbiAgZW5kXG5cbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGluaXQgOiBDb250ZXh0LnQgLT4gJ2EgVHlwZW5hbWUudCAtPiAnYSB0XG4gIHZhbCBnZXRfd2lwX2NvbXB1dGF0aW9uIDogJ2EgdCAtPiAnYSBjb21wdXRhdGlvblxuICB2YWwgc2V0X2ZpbmFsX2NvbXB1dGF0aW9uIDogJ2EgdCAtPiAnYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICB2YWwgc2hhcmUgOiBfIFR5cGVyZXAudCAtPiBib29sXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcHV0YXRpb24gPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgaW50IDogaW50IHRcbiAgdmFsIGludDMyIDogaW50MzIgdFxuICB2YWwgaW50NjQgOiBpbnQ2NCB0XG4gIHZhbCBuYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICB2YWwgY2hhciA6IGNoYXIgdFxuICB2YWwgZmxvYXQgOiBmbG9hdCB0XG4gIHZhbCBzdHJpbmcgOiBzdHJpbmcgdFxuICB2YWwgYnl0ZXMgOiBieXRlcyB0XG4gIHZhbCBib29sIDogYm9vbCB0XG4gIHZhbCB1bml0IDogdW5pdCB0XG4gIHZhbCBvcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gIHZhbCBsaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgdmFsIGFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gIHZhbCBsYXp5X3QgOiAnYSB0IC0+ICdhIGxhenlfdCB0XG4gIHZhbCByZWZfIDogJ2EgdCAtPiAnYSByZWYgdFxuICB2YWwgZnVuY3Rpb25fIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAtPiAnYikgdFxuICB2YWwgdHVwbGUyIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAqICdiKSB0XG4gIHZhbCB0dXBsZTMgOiAnYSB0IC0+ICdiIHQgLT4gJ2MgdCAtPiAoJ2EgKiAnYiAqICdjKSB0XG4gIHZhbCB0dXBsZTQgOiAnYSB0IC0+ICdiIHQgLT4gJ2MgdCAtPiAnZCB0IC0+ICgnYSAqICdiICogJ2MgKiAnZCkgdFxuICB2YWwgdHVwbGU1IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAnZSB0IC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG4gIHZhbCByZWNvcmQgOiAnYSBSZWNvcmQudCAtPiAnYSB0XG4gIHZhbCB2YXJpYW50IDogJ2EgVmFyaWFudC50IC0+ICdhIHRcblxuICBtb2R1bGUgTmFtZWQgOiBOYW1lZCB3aXRoIHR5cGUgJ2EgY29tcHV0YXRpb24gOj0gJ2EgdFxuZW5kXG5cbigqIHNwZWNpYWwgZnVuY3RvciBhcHBsaWNhdGlvbiBmb3IgY29tcHV0YXRpb24gYXMgY2xvc3VyZSBvZiB0aGUgZm9ybSBbYSAtPiBiXSAqKVxubW9kdWxlIE1ha2VfbmFtZWRfZm9yX2Nsb3N1cmUgKFggOiBzaWdcbiAgdHlwZSAnYSBpbnB1dFxuICB0eXBlICdhIG91dHB1dFxuICB0eXBlICdhIHQgPSAnYSBpbnB1dCAtPiAnYSBvdXRwdXRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgaWYgbm90IChpbXBsZW1lbnRzIHVpZClcbiAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgbmFtZSdcbiAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIHByZXJyX2VuZGxpbmUgbWVzc2FnZTtcbiAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5lbmQpIDogU19pbXBsZW1lbnRhdGlvbiB3aXRoIHR5cGUgJ2EgdCA9ICdhIFgudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBYLnRcbiAgdHlwZSAnYSBjb21wdXRhdGlvbiA9ICdhIHRcblxuICBpbmNsdWRlIFR5cGVfZ2VuZXJpY19pbnRmLk0gKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lKVxuICAgICAgZWxzZSBOb25lXG4gICAgOztcblxuICAgIGxldCBjaGVja19kZXBlbmRlbmNpZXMgPSBJZGVudC5jaGVja19kZXBlbmRlbmNpZXMgWC5uYW1lIFgucmVxdWlyZWRcblxuICAgIGxldCByZXBsYWNlIHRhYmxlIGtleSB2YWx1ZSA9XG4gICAgICBjaGVja19kZXBlbmRlbmNpZXMga2V5O1xuICAgICAgcmVwbGFjZSAoTGF6eS5mb3JjZSB0YWJsZSkga2V5IHZhbHVlXG4gICAgOztcblxuICAgIGxldCBtZW0gdGFibGUga2V5ID1cbiAgICAgIGlmIExhenkuaXNfdmFsIHRhYmxlXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHRhYmxlID0gTGF6eS5mb3JjZSB0YWJsZSBpblxuICAgICAgICBtZW0gdGFibGUga2V5KVxuICAgICAgZWxzZSBmYWxzZVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBzaXplID0gMjU2XG4gIGxldCB0YWJsZTAgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTEgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTIgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTMgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTQgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG4gIGxldCB0YWJsZTUgPSBsYXp5IChVaWRfdGFibGUuY3JlYXRlIHNpemUpXG5cbiAgbGV0IGlzX3JlZ2lzdGVyZWQgdWlkID1cbiAgICBVaWRfdGFibGUubWVtIHRhYmxlMCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMSB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMiB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlMyB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNCB1aWRcbiAgICB8fCBVaWRfdGFibGUubWVtIHRhYmxlNSB1aWRcbiAgOztcblxuICBsZXQgaWRlbnQgPSB7IElkZW50Lm5hbWUgPSBYLm5hbWU7IGltcGxlbWVudHMgPSBpc19yZWdpc3RlcmVkIH1cblxuICBtb2R1bGUgRmluZDAgKFQgOiBUeXBlcmVwLk5hbWVkLlQwKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlIDogdW5pdCAtPiBULm5hbWVkIGNvbXB1dGF0aW9uIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTAgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUyA9ICh2YWwgcmVwIDogUykgaW5cbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuIFMudHlwZW5hbWVfb2ZfdCBULnR5cGVuYW1lX29mX25hbWVkIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCB3aXRuZXNzKSBTLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQxIChUIDogVHlwZXJlcC5OYW1lZC5UMSkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlMSAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgcmVwIDogUzEpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl8xXG4gICAgICAgICAgICAoUzEpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID0gVC5hIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzEuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDIgKFQgOiBUeXBlcmVwLk5hbWVkLlQyKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTIgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIHJlcCA6IFMyKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMlxuICAgICAgICAgICAgKFMyKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMi5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMyAoVCA6IFR5cGVyZXAuTmFtZWQuVDMpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYykgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTMgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIHJlcCA6IFMzKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fM1xuICAgICAgICAgICAgKFMzKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiBULmMgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNCAoVCA6IFR5cGVyZXAuTmFtZWQuVDQpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgb3B0aW9uXG4gIGVuZCA9IHN0cnVjdFxuICAgIGxldCBjb21wdXRlICgpID1cbiAgICAgIG1hdGNoIFVpZF90YWJsZS5maW5kIHRhYmxlNCAoVHlwZW5hbWUudWlkIFQudHlwZW5hbWVfb2ZfdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgcmVwIDogUzQpIGluXG4gICAgICAgIGxldCBtb2R1bGUgQ29udiA9XG4gICAgICAgICAgVHlwZW5hbWUuU2FtZV93aXRuZXNzX2V4bl80XG4gICAgICAgICAgICAoUzQpXG4gICAgICAgICAgICAoc3RydWN0XG4gICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0ID0gKCdhLCAnYiwgJ2MsICdkKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFM0LmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQ1IChUIDogVHlwZXJlcC5OYW1lZC5UNSkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IFQuZSBjb21wdXRhdGlvblxuICAgICAgICAgIC0+IChULmEsIFQuYiwgVC5jLCBULmQsIFQuZSkgVC5uYW1lZCBjb21wdXRhdGlvbilcbiAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTUgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIHJlcCA6IFM1KSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fNVxuICAgICAgICAgICAgKFM1KVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgPSAoJ2EsICdiLCAnYywgJ2QsICdlKSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgICAgICAgIFQuYSBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuZCBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmUgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTNS5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB1bml0ID0gVHlwZW5hbWUuc3RhdGljXG5cbiAgbGV0IHJlZ2lzdGVyMCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMgPSAodmFsIGNvbXB1dGUgOiBTKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgUy50eXBlbmFtZV9vZl90IGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUwIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyMSBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFMxID0gKHZhbCBjb21wdXRlIDogUzEpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzEudHlwZW5hbWVfb2ZfdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjIgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMiA9ICh2YWwgY29tcHV0ZSA6IFMyKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMyLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMiB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjMgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMyA9ICh2YWwgY29tcHV0ZSA6IFMzKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMzLnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQpIGluXG4gICAgVWlkX3RhYmxlLnJlcGxhY2UgdGFibGUzIHVpZCBjb21wdXRlXG4gIDs7XG5cbiAgbGV0IHJlZ2lzdGVyNCBjb21wdXRlID1cbiAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCBjb21wdXRlIDogUzQpIGluXG4gICAgbGV0IHVpZCA9IFR5cGVuYW1lLnVpZCAoUzQudHlwZW5hbWVfb2ZfdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjUgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNSA9ICh2YWwgY29tcHV0ZSA6IFM1KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM1LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlNSB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlciAodHlwZSBhKSB0eXBlcmVwX29mX2EgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBhXG5cbiAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVHlwZXJlcC50eXBlbmFtZV9vZl90IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IHR5cGVyZXBfb2ZfdCA9IHR5cGVyZXBfb2ZfYVxuICAgICAgbGV0IGNvbXB1dGUgPSBjb21wdXRlXG4gICAgZW5kXG4gICAgaW5cbiAgICByZWdpc3RlcjAgKG1vZHVsZSBTIDogUylcbiAgOztcblxuICAoKiBJTVBMRU1FTlRBVElPTiAqKVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICBsZXQgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiAodHlwZSBhKSBhdXggPSBmdW5jdGlvblxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMCByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQwIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gVC53aXRuZXNzIGluXG4gICAgICAgICBTb21lIChjdXN0b20gOiBhIGNvbXB1dGF0aW9uKVxuICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgIHwgVHlwZXJlcC5OYW1lZC5UMSByZXAgLT5cbiAgICAgIGxldCBtb2R1bGUgVCA9ICh2YWwgcmVwIDogVHlwZXJlcC5OYW1lZC5UMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICBsZXQgbW9kdWxlIEN1c3RvbSA9IEZpbmQxIChUKSBpblxuICAgICAgKG1hdGNoIEN1c3RvbS5jb21wdXRlICgpIHdpdGhcbiAgICAgICB8IFNvbWUgY3VzdG9tIC0+XG4gICAgICAgICBsZXQgY3VzdG9tID0gKGN1c3RvbSAoYXV4LmdlbmVyaWMgVC5hKSA6IFQuYSBULm5hbWVkIGNvbXB1dGF0aW9uKSBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDIgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDIgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMiAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgOiAoVC5hLCBULmIpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDMgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMyAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgKGF1eC5nZW5lcmljIFQuYikgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ0IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ0IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDQgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ1IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ1IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDUgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmEpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmIpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICAgIChhdXguZ2VuZXJpYyBULmUpXG4gICAgICAgICAgICAgOiAoVC5hLCBULmIsIFQuYywgVC5kLCBULmUpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgOztcblxuICBleGNlcHRpb24gTm90X2ltcGxlbWVudGVkIG9mIHN0cmluZyAqIHN0cmluZ1xuXG4gIGxldCByYWlzZV9ub3RfaW1wbGVtZW50ZWQgc3RyaW5nID0gcmFpc2UgKE5vdF9pbXBsZW1lbnRlZCAoWC5uYW1lLCBzdHJpbmcpKVxuXG4gIGxldCBfdXNpbmdfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gYXV4IHJlcCBjb250ZW50ID1cbiAgICBtYXRjaCBmaW5kX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgd2l0aFxuICAgIHwgU29tZSBjb21wdXRhdGlvbiAtPiBjb21wdXRhdGlvblxuICAgIHwgTm9uZSAtPlxuICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPiBhdXguZ2VuZXJpYyBjb250ZW50XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBsZXQgdHlwZW5hbWUgPSBUeXBlcmVwLk5hbWVkLnR5cGVuYW1lX29mX3QgcmVwIGluXG4gICAgICAgICBsZXQgbmFtZSA9IFR5cGVuYW1lLlVpZC5uYW1lIChUeXBlbmFtZS51aWQgdHlwZW5hbWUpIGluXG4gICAgICAgICByYWlzZV9ub3RfaW1wbGVtZW50ZWQgbmFtZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgXyA9IEhhc2h0YmwuTWFrZSAoVHlwZW5hbWUuS2V5KVxuXG5tb2R1bGUgTWFrZSAoWCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbmFtZSA6IHN0cmluZ1xuICB2YWwgcmVxdWlyZWQgOiBJZGVudC50IGxpc3RcblxuICBpbmNsdWRlIENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb21wdXRhdGlvbiA9IFhcbiAgaW5jbHVkZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFgpXG5cbiAgbW9kdWxlIE1lbW8gPSBUeXBlbmFtZS5UYWJsZSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgWC5OYW1lZC50XG4gIGVuZClcblxuICBtb2R1bGUgSGVscGVyID0gSGVscGVyIChUeXBlcmVwKSAoQ29tcHV0YXRpb24pXG5cbiAgbGV0IG9mX3R5cGVyZXAgcmVwID1cbiAgICBsZXQgY29udGV4dCA9IFguTmFtZWQuQ29udGV4dC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgbWVtb190YWJsZSA9IE1lbW8uY3JlYXRlIDMyIGluXG4gICAgbGV0IHJlYyBvZl90eXBlcmVwIDogdHlwZSBhLiBhIFR5cGVyZXAudCAtPiBhIHQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLkludCAtPiBYLmludFxuICAgICAgfCBUeXBlcmVwLkludDMyIC0+IFguaW50MzJcbiAgICAgIHwgVHlwZXJlcC5JbnQ2NCAtPiBYLmludDY0XG4gICAgICB8IFR5cGVyZXAuTmF0aXZlaW50IC0+IFgubmF0aXZlaW50XG4gICAgICB8IFR5cGVyZXAuQ2hhciAtPiBYLmNoYXJcbiAgICAgIHwgVHlwZXJlcC5GbG9hdCAtPiBYLmZsb2F0XG4gICAgICB8IFR5cGVyZXAuU3RyaW5nIC0+IFguc3RyaW5nXG4gICAgICB8IFR5cGVyZXAuQnl0ZXMgLT4gWC5ieXRlc1xuICAgICAgfCBUeXBlcmVwLkJvb2wgLT4gWC5ib29sXG4gICAgICB8IFR5cGVyZXAuVW5pdCAtPiBYLnVuaXRcbiAgICAgIHwgVHlwZXJlcC5PcHRpb24gcmVwIC0+IFgub3B0aW9uIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MaXN0IHJlcCAtPiBYLmxpc3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkFycmF5IHJlcCAtPiBYLmFycmF5IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MYXp5IHJlcCAtPiBYLmxhenlfdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuUmVmIHJlcCAtPiBYLnJlZl8gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZykgLT4gWC5mdW5jdGlvbl8gKG9mX3R5cGVyZXAgZG9tKSAob2ZfdHlwZXJlcCBybmcpXG4gICAgICB8IFR5cGVyZXAuVHVwbGUgdHVwbGUgLT5cbiAgICAgICAgKCogZG8gTk9UIHdyaXRlIFtYLnR1cGxlMiAob2ZfdHlwZXJlcCBhKSAob2ZfdHlwZXJlcCBiKV1cbiAgICAgICAgICAgYmVjYXVzZSBvZl90eXBlcmVwIGNhbiBjb250YWluIGEgc2lkZSBlZmZlY3QgYW5kIFthXSBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgYmVmb3JlIFtiXSAqKVxuICAgICAgICAobWF0Y2ggdHVwbGUgd2l0aFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIFgudHVwbGUyIHJhIHJiXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIFgudHVwbGUzIHJhIHJiIHJjXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBYLnR1cGxlNCByYSByYiByYyByZFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgbGV0IHJlID0gb2ZfdHlwZXJlcCBlIGluXG4gICAgICAgICAgIFgudHVwbGU1IHJhIHJiIHJjIHJkIHJlKVxuICAgICAgfCBUeXBlcmVwLlJlY29yZCByZWNvcmQgLT5cbiAgICAgICAgWC5yZWNvcmQgKEhlbHBlci5tYXBfcmVjb3JkIHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSByZWNvcmQpXG4gICAgICB8IFR5cGVyZXAuVmFyaWFudCB2YXJpYW50IC0+XG4gICAgICAgIFgudmFyaWFudCAoSGVscGVyLm1hcF92YXJpYW50IHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSB2YXJpYW50KVxuICAgICAgfCBUeXBlcmVwLk5hbWVkIChuYW1lZCwgY29udGVudCkgLT5cbiAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IG5hbWVkIGluXG4gICAgICAgIChtYXRjaCBNZW1vLmZpbmQgbWVtb190YWJsZSB0eXBlbmFtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgc2hhcmVkIC0+IFguTmFtZWQuZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWRcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiB7IGdlbmVyaWMgPSBvZl90eXBlcmVwIH0gbmFtZWQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGNvbXB1dGF0aW9uIC0+IGNvbXB1dGF0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCB0eXBlbmFtZSkgaW5cbiAgICAgICAgICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPlxuICAgICAgICAgICAgICAgICBpZiBYLk5hbWVkLnNoYXJlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IHNoYXJlZCA9IFguTmFtZWQuaW5pdCBjb250ZXh0IHR5cGVuYW1lIGluXG4gICAgICAgICAgICAgICAgICAgTWVtby5zZXQgbWVtb190YWJsZSB0eXBlbmFtZSBzaGFyZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCBjb250ZW50IGluXG4gICAgICAgICAgICAgICAgICAgWC5OYW1lZC5zZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICAgICAgICBlbHNlIG9mX3R5cGVyZXAgY29udGVudCkpKVxuICAgIGluXG4gICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCByZXAgaW5cbiAgICBgZ2VuZXJpYyBjb21wdXRhdGlvblxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdF9saWJfdHlwZV9nZW5lcmljX21sIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29ial90YWciLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiVHlwZXJlcF9saWJfU3RkX2ludGVybmFsIiwiQ2FtbGludGVybmFsTGF6eSIsIlR5cGVyZXBfbGliX1R5cGVuYW1lIiwiVHlwZXJlcF9saWJfVHlwZV9lcXVhbCIsIlN0ZGxpYl9MYXp5IiwiQmFzZSIsIlN0ZGxpYiIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9MaXN0IiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfQXJyYXkiLCJUeXBlcmVwX2xpYl9WYXJpYW50X2FuZF9yZWNvcmQiLCJIZWxwZXIiLCJBIiwiQiIsIm1hcF92YXJpYW50IiwicGFyYW0iLCJ2YXJpYW50IiwibWFwIiwidHlwZW5hbWUiLCJwb2x5bW9ycGhpYyIsInRhZ3MiLCJpbmRleCIsInRhZyIsImxhYmVsIiwicmVwIiwiYXJpdHkiLCJhcmdzX2xhYmVscyIsIm9jYW1sX3JlcHIiLCJ0eWlkIiwiZmN0IiwiY3JlYXRlIiwiayIsInZhbHVlIiwiYSIsIm1hdGNoIiwiYXRhZyIsImJ0YWciLCJtYXBfcmVjb3JkIiwicmVjb3JkIiwiaGFzX2RvdWJsZV9hcnJheV90YWciLCJmaWVsZHMiLCJmaWVsZCIsImlzX211dGFibGUiLCJnZXQiLCJhZmllbGQiLCJiZmllbGQiLCJCcm9rZW5fZGVwZW5kZW5jeSIsImNzdF9UeXBlcmVwX2xpYl9UeXBlX2dlbmVyaWNfTSIsImR1bW15IiwiVHlwZXJlcF9saWJfVHlwZV9nZW5lcmljIiwiWCIsIkNvbnRleHQiLCJVbmRlZmluZWQiLCJpbml0IiwibmFtZSIsInBhdGgiLCJyIiwiaW5wdXQiLCJnZXRfd2lwX2NvbXB1dGF0aW9uIiwic2hhcmVkIiwiY2xvcyIsInNldF9maW5hbF9jb21wdXRhdGlvbiIsImNvbXB1dGF0aW9uIiwiY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UiLCJzaGFyZSIsInJlcXVpcmVkIiwiaW5jbHVkZSIsInJlcGxhY2UiLCJtZW0iLCJmaW5kIiwidGFibGUiLCJrZXkiLCJleG4iLCJjaGVja19kZXBlbmRlbmNpZXMiLCJ1aWQiLCJpbXBsZW1lbnRzJCIsIm1lc3NhZ2UiLCJzaXplIiwidGFibGUwIiwidGFibGUxIiwidGFibGUyIiwidGFibGUzIiwidGFibGU0IiwidGFibGU1IiwiaXNfcmVnaXN0ZXJlZCIsImlkZW50IiwiRmluZDAiLCJUIiwiY29tcHV0ZSIsIndpdG5lc3MiLCJMIiwiRmluZDEiLCJ0eXBlbmFtZV9vZl90IiwiQ29udiIsIkZpbmQyIiwiRmluZDMiLCJGaW5kNCIsInVuaXQiLCJyZWdpc3RlcjAiLCJyZWdpc3RlcjEiLCJyZWdpc3RlcjIiLCJyZWdpc3RlcjMiLCJyZWdpc3RlcjQiLCJyZWdpc3RlcjUiLCJyZWdpc3RlciIsInR5cGVyZXBfb2ZfYSIsIk5vdF9pbXBsZW1lbnRlZCIsIk1lbW8iLCJvZl90eXBlcmVwIiwiY29udGV4dCIsIm1lbW9fdGFibGUiLCJybmciLCJkb20iLCJjb250ZW50IiwibmFtZWQiLCJDdXN0b20iLCJjdXN0b20iLCJzdHJpbmciLCJ0dXBsZSIsImIiLCJyYSIsInJiIiwiYyIsInJjIiwiZCIsInJkIiwiZSIsInJlIl0sIm1h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QUFBO0FBQUE7QUFBQSxHRDNYdkUiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxOTc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdHlwZXJlcC9tYWtlX3R5cGVuYW1lLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdGRfaW50ZXJuYWxcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UwIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgPVxuICAgIFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgbmFtZWQgPSBYLnRcbiAgICAgICAgdHlwZSB0ID0gWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQwXG4gICAgICAgIHdpdGggdHlwZSB0ID0gWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMSAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxKSBvZl9wMSA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgbmFtZWQgPSAnYSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSB0ID0gcDEgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQxXG4gICAgICAgIHdpdGggdHlwZSB0ID0gcDEgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMiAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyKSBvZl9wMSBvZl9wMiA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3QgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSkgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWQgPSAoJ2EsICdiKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMikgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQyXG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMikgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlMyAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzKSBvZl9wMSBvZl9wMiBvZl9wMyA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIG5hbWVkID0gKCdhLCAnYiwgJ2MpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQzXG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMpIFgudClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZTQgKFggOiBOYW1lZF9pbnRmLlM0KSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTQgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCAodHlwZSBwMSBwMiBwMyBwNCkgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgPVxuICAgIGxldCB0eXBlbmFtZV9vZl90ID1cbiAgICAgIE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDIpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDMpXG4gICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDQpXG4gICAgaW5cbiAgICBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWQgPSAoJ2EsICdiLCAnYywgJ2QpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQpIFgudFxuXG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl9uYW1lZCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gdHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgd2l0bmVzcyA9IFR5cGVfZXF1YWwucmVmbFxuICAgICAgZW5kIDogVHlwZXJlcC5OYW1lZC5UNFxuICAgICAgICB3aXRoIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNSAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0IHA1KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCBvZl9wNSA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNSlcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgPSAoJ2EsICdiLCAnYywgJ2QsICdlKSBYLnRcbiAgICAgICAgdHlwZSBhID0gcDFcblxuICAgICAgICBsZXQgYSA9IG9mX3AxXG5cbiAgICAgICAgdHlwZSBiID0gcDJcblxuICAgICAgICBsZXQgYiA9IG9mX3AyXG5cbiAgICAgICAgdHlwZSBjID0gcDNcblxuICAgICAgICBsZXQgYyA9IG9mX3AzXG5cbiAgICAgICAgdHlwZSBkID0gcDRcblxuICAgICAgICBsZXQgZCA9IG9mX3A0XG5cbiAgICAgICAgdHlwZSBlID0gcDVcblxuICAgICAgICBsZXQgZSA9IG9mX3A1XG5cbiAgICAgICAgdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0LCBwNSkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ1XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0LCBwNSkgWC50KVxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIlR5cGVyZXBfbGliX1N0ZF9pbnRlcm5hbCIsIlR5cGVyZXBfbGliX1R5cGVfZXF1YWwiLCJUeXBlcmVwX2xpYl9UeXBlbmFtZSIsIlR5cGVyZXBfbGliX01ha2VfdHlwZW5hbWUiLCJYIiwiTmFtZV9vZl94IiwidHlwZW5hbWVfb2ZfdCIsInR5cGVuYW1lX29mX25hbWVkIiwid2l0bmVzcyIsIm5hbWVkIiwib2ZfcDEiLCJvZl9wMiIsIm9mX3AzIiwib2ZfcDQiLCJvZl9wNSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxnQkFBQUM7QUFBQUE7QUFBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGdCQUFBO0FBQUEsU0FBQUMsb0JBQUE7QUFBQSxTQUFBQyxVQUFBO0FBQUEsU0FBQUMsUUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUw7QUFBQUE7QUFBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGdCQUFBO0FBQUEsaUJBQUFHLE1BQUFDO0FBQUFBO0FBQUFBLFVBQUEsSUMyQmdEO0FBQUEsVUFBQUosZ0JBQXhCO0FBQUEsVUFBQUMsb0JBQ3BCO0FBQUEsVUFBQUMsVUFBQTtBQUFBO0FBQUEsUUFheUI7QUFBQSxRRHpDN0I7QUFBQTtBQUFBLGdCQUFBSjtBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxpQkFBQUcsTUFBQUMsT0FBQUM7QUFBQUE7QUFBQUEsVUFBQSxJQ29ENEQ7QUFBQSxjQUE5QjtBQUFBLFVBQUFMLGdCQUF4QjtBQUFBLFVBQUFDLG9CQUVGO0FBQUEsVUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQSxRQWlCK0I7QUFBQSxRRHZFbkM7QUFBQTtBQUFBLGdCQUFBSjtBQUFBQTtBQUFBQSxTQUFBQyxZQUFBO0FBQUEsU0FBQUMsZ0JBQUE7QUFBQSxpQkFBQUcsTUFBQUMsT0FBQUMsT0FBQUM7QUFBQUE7QUFBQUEsVUFBQSxJQ3FGUTtBQUFBLGNBREE7QUFBQSxjQURBO0FBQUEsVUFBQU4sZ0JBREY7QUFBQSxVQUFBQyxvQkFLRjtBQUFBLFVBQUFDLFVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFxQm1DO0FBQUEsUUQ1R3ZDO0FBQUE7QUFBQSxnQkFBQUo7QUFBQUE7QUFBQUEsU0FBQUMsWUFBQTtBQUFBLFNBQUFDLGdCQUFBO0FBQUEsaUJBQUFHLE1BQUFDLE9BQUFDLE9BQUFDLE9BQUFDO0FBQUFBO0FBQUFBLFVBQUEsSUMySFE7QUFBQSxjQURBO0FBQUEsY0FEQTtBQUFBLGNBREE7QUFBQSxVQUFBUCxnQkFERjtBQUFBLFVBQUFDLG9CQU1GO0FBQUEsVUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBeUJ1QztBQUFBLFFEdEozQztBQUFBO0FBQUEsZ0JBQUFKO0FBQUFBO0FBQUFBLFNBQUFDLFlBQUE7QUFBQSxTQUFBQyxnQkFBQTtBQUFBLGlCQUFBRyxNQUFBQyxPQUFBQyxPQUFBQyxPQUFBQyxPQUFBQztBQUFBQTtBQUFBQSxVQUFBLElDc0tRO0FBQUEsY0FEQTtBQUFBLGNBREE7QUFBQSxjQURBO0FBQUEsY0FEQTtBQUFBLFVBQUFSLGdCQURGO0FBQUEsVUFBQUMsb0JBT0Y7QUFBQSxVQUFBQyxVQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQTZCMkM7QUFBQSxRRHJNL0MiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTM4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InR5cGVyZXBfbGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdHlwZXJlcC90eXBlX2Fic3RyYWN0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdGRfaW50ZXJuYWxcblxubW9kdWxlIE1ha2UwIChYIDogTmFtZWRfaW50Zi5TMCkgOiBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgOiBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IE5hbWVkX2ludGYuUzIpIDogVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgWC50ID1cbnN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTIgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgOlxuICBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTMgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyA9IFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMsIE5vbmUpXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2U0IChYIDogTmFtZWRfaW50Zi5TNCkgOlxuICBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0ID1cbiAgICBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0LCBOb25lKVxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgOlxuICBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgb2ZfcDUgPVxuICAgIFR5cGVyZXAuTmFtZWQgKE0ubmFtZWQgb2ZfcDEgb2ZfcDIgb2ZfcDMgb2ZfcDQgb2ZfcDUsIE5vbmUpXG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJUeXBlcmVwX2xpYl9NYWtlX3R5cGVuYW1lIiwiTWFrZTAiLCJYIiwiTSIsInR5cGVyZXBfb2ZfdCIsInR5cGVuYW1lX29mX3QiLCJNYWtlMSIsIm9mX3AxIiwiTWFrZTIiLCJvZl9wMiIsIk1ha2UzIiwib2ZfcDMiLCJNYWtlNCIsIm9mX3A0IiwiTWFrZTUiLCJvZl9wNSIsIlR5cGVyZXBfbGliX1R5cGVfYWJzdHJhY3QiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLFlBQUFDLE1BQUFDO0FBQUFBO0FBQUFBLEtBQUFDLElBQUE7QUFBQSxLQUFBQyxlQUFBO0FBQUEsS0FBQUMsZ0JBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsTUFBQUo7QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9DWTBDLDJDQUFhLENBQU87QUFBQSxRQUFBRixnQkRaOUQ7QUFBQTtBQUFBO0FBQUEsWUFBQUcsTUFBQU47QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9BQUFFO0FBQUFBLEtDb0JnRCxrREFBbUI7QUFBQSxJQUFPO0FBQUEsUUFBQUosZ0JEcEIxRTtBQUFBO0FBQUE7QUFBQSxZQUFBSyxNQUFBUjtBQUFBQSxRQUFBQyxJQUFBO0FBQUEsYUFBQUMsYUFBQUcsT0FBQUUsT0FBQUU7QUFBQUEsS0M0QnNELHlEQUF5QjtBQUFBLElBQU87QUFBQSxRQUFBTixnQkQ1QnRGO0FBQUE7QUFBQTtBQUFBLFlBQUFPLE1BQUFWO0FBQUFBLFFBQUFDLElBQUE7QUFBQSxhQUFBQyxhQUFBRyxPQUFBRSxPQUFBRSxPQUFBRTtBQUFBQSxLQ3FDbUIsZ0VBQStCO0FBQUEsSUFBTztBQUFBLFFBQUFSLGdCRHJDekQ7QUFBQTtBQUFBO0FBQUEsWUFBQVMsTUFBQVo7QUFBQUEsUUFBQUMsSUFBQTtBQUFBLGFBQUFDLGFBQUFHLE9BQUFFLE9BQUFFLE9BQUFFLE9BQUFFO0FBQUFBLEtDZ0RtQix1RUFBcUM7QUFBQSxJQUFPO0FBQUEsUUFBQVYsZ0JEaEQvRDtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFXLDRCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjIyNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJnbG9iYWxfZGF0YSIsIlR5cGVyZXBfbGliX1N0ZF9pbnRlcm5hbCIsIlR5cGVyZXAiLCJ0eXBlcmVwX29mX2ludCIsInR5cGVyZXBfb2ZfaW50MzIiLCJ0eXBlcmVwX29mX2ludDY0IiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2ludDYzIiwidHlwZXJlcF9vZl9jaGFyIiwidHlwZXJlcF9vZl9mbG9hdCIsInR5cGVyZXBfb2Zfc3RyaW5nIiwidHlwZXJlcF9vZl9ieXRlcyIsInR5cGVyZXBfb2ZfYm9vbCIsInR5cGVyZXBfb2ZfdW5pdCIsInZhbHVlX3R1cGxlMCIsInR5cGVyZXBfb2Zfb3B0aW9uIiwidHlwZXJlcF9vZl9saXN0IiwidHlwZXJlcF9vZl9hcnJheSIsInR5cGVyZXBfb2ZfbGF6eV90IiwidHlwZXJlcF9vZl9yZWYiLCJ0eXBlcmVwX29mX2Z1bmN0aW9uIiwidHlwZXJlcF9vZl90dXBsZTAiLCJ0eXBlcmVwX29mX3R1cGxlMiIsInR5cGVyZXBfb2ZfdHVwbGUzIiwidHlwZXJlcF9vZl90dXBsZTQiLCJ0eXBlcmVwX29mX3R1cGxlNSIsInR5cGVuYW1lX29mX2ludCIsInR5cGVuYW1lX29mX2ludDMyIiwidHlwZW5hbWVfb2ZfaW50NjQiLCJ0eXBlbmFtZV9vZl9uYXRpdmVpbnQiLCJ0eXBlbmFtZV9vZl9pbnQ2MyIsInR5cGVuYW1lX29mX2NoYXIiLCJ0eXBlbmFtZV9vZl9mbG9hdCIsInR5cGVuYW1lX29mX3N0cmluZyIsInR5cGVuYW1lX29mX2J5dGVzIiwidHlwZW5hbWVfb2ZfYm9vbCIsInR5cGVuYW1lX29mX3VuaXQiLCJ0eXBlbmFtZV9vZl9vcHRpb24iLCJ0eXBlbmFtZV9vZl9saXN0IiwidHlwZW5hbWVfb2ZfYXJyYXkiLCJ0eXBlbmFtZV9vZl9sYXp5X3QiLCJ0eXBlbmFtZV9vZl9yZWYiLCJ0eXBlbmFtZV9vZl9mdW5jdGlvbiIsInR5cGVuYW1lX29mX3R1cGxlMCIsInR5cGVuYW1lX29mX3R1cGxlMiIsInR5cGVuYW1lX29mX3R1cGxlMyIsInR5cGVuYW1lX29mX3R1cGxlNCIsInR5cGVuYW1lX29mX3R1cGxlNSIsIlR5cGVyZXBfbGliX1N0ZCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
