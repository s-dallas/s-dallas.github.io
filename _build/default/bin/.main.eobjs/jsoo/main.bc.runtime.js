// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=runtime, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Assert_failure, Division_by_zero, End_of_file, Failure, Invalid_argument, Match_failure, Not_found, Out_of_memory, Stack_overflow, Sys_blocked_io, Sys_error, Undefined_recursive_module
//# unitInfo: Primitives: Base_am_testing, Base_caml_exn_is_most_recent_exn, Base_clear_caml_backtrace_pos, Base_hash_double, Base_hash_string, Base_int_math_int32_clz, Base_int_math_int32_ctz, Base_int_math_int64_clz, Base_int_math_int64_ctz, Base_int_math_int64_pow_stub, Base_int_math_int_clz, Base_int_math_int_ctz, Base_int_math_int_popcount, Base_int_math_int_pow_stub, Base_int_math_nativeint_clz, Base_int_math_nativeint_ctz, Base_internalhash_fold_float, Base_internalhash_fold_int, Base_internalhash_fold_int64, Base_internalhash_fold_string, Base_internalhash_get_hash_value, Base_unsafe_create_local_bytes, JsStringReader, MlBytes, MlChanid, MlFakeDevice, MlFakeFd, MlFakeFd_out, MlFakeFile, MlFile, MlInt64, MlMutex, MlNat, MlNodeDevice, MlNodeFd, MlObjectTable, Ml_Bigarray, Ml_Bigarray_c_1_1, UInt8ArrayReader, add_nat, bigstring_alloc_v2, bigstring_blit_bigstring_bytes_stub, bigstring_blit_bytes_bigstring_stub, bigstring_blit_string_bigstring_stub, bigstring_blit_stub, bigstring_destroy_stub, bigstring_find, bigstring_is_mmapped_stub, bigstring_memcmp_bytes_stub, bigstring_memcmp_stub, bigstring_memmem_bytecode, bigstring_memset_stub, bigstring_of_array_buffer, bigstring_of_typed_array, bigstring_realloc, bigstring_to_array_buffer, bigstring_to_typed_array, bin_prot_blit_buf_bytes_stub, bin_prot_blit_buf_float_array_stub, bin_prot_blit_buf_stub, bin_prot_blit_bytes_buf_stub, bin_prot_blit_float_array_buf_stub, bin_prot_blit_string_buf_stub, blake2b, blit_nat, caml_MD5Final, caml_MD5Init, caml_MD5Transform, caml_MD5Update, caml_acosh_float, caml_alloc_dummy_infix, caml_alloc_stack, caml_argv, caml_array_append, caml_array_blit, caml_array_bound_error, caml_array_concat, caml_array_fill, caml_array_get, caml_array_make, caml_array_of_bytes, caml_array_of_string, caml_array_set, caml_array_sub, caml_asinh_float, caml_atanh_float, caml_atomic_cas, caml_atomic_exchange, caml_atomic_fetch_add, caml_atomic_load, caml_atomic_make_contended, caml_ba_blit, caml_ba_change_layout, caml_ba_compare, caml_ba_create, caml_ba_create_buffer, caml_ba_create_from, caml_ba_create_unsafe, caml_ba_custom_name, caml_ba_deserialize, caml_ba_dim, caml_ba_dim_1, caml_ba_dim_2, caml_ba_dim_3, caml_ba_fill, caml_ba_from_typed_array, caml_ba_get_1, caml_ba_get_2, caml_ba_get_3, caml_ba_get_generic, caml_ba_get_size, caml_ba_get_size_per_element, caml_ba_hash, caml_ba_init, caml_ba_kind, caml_ba_kind_of_typed_array, caml_ba_layout, caml_ba_map_file, caml_ba_map_file_bytecode, caml_ba_num_dims, caml_ba_reshape, caml_ba_serialize, caml_ba_set_1, caml_ba_set_2, caml_ba_set_3, caml_ba_set_generic, caml_ba_slice, caml_ba_sub, caml_ba_to_typed_array, caml_ba_uint8_get16, caml_ba_uint8_get32, caml_ba_uint8_get64, caml_ba_uint8_set16, caml_ba_uint8_set32, caml_ba_uint8_set64, caml_backtrace_status, caml_bigstring_blit_ba_to_ba, caml_bigstring_blit_ba_to_bytes, caml_bigstring_blit_bytes_to_ba, caml_bigstring_blit_string_to_ba, caml_bigstring_memcmp, caml_blake2_create, caml_blake2_final, caml_blake2_string, caml_blake2_update, caml_blit_bytes, caml_blit_string, caml_bswap16, caml_build_symbols, caml_bytes_bound_error, caml_bytes_compare, caml_bytes_equal, caml_bytes_get, caml_bytes_get16, caml_bytes_get32, caml_bytes_get64, caml_bytes_greaterequal, caml_bytes_greaterthan, caml_bytes_lessequal, caml_bytes_lessthan, caml_bytes_notequal, caml_bytes_of_array, caml_bytes_of_jsbytes, caml_bytes_of_string, caml_bytes_of_uint8_array, caml_bytes_of_utf16_jsstring, caml_bytes_set, caml_bytes_set16, caml_bytes_set32, caml_bytes_set64, caml_bytes_unsafe_get, caml_bytes_unsafe_set, caml_call_gen, caml_callback, caml_cbrt_float, caml_channel_descriptor, caml_check_bound, caml_check_bound_bigstring, caml_classify_float, caml_compare, caml_compare_val, caml_compare_val_get_custom, caml_compare_val_number_custom, caml_compare_val_tag, caml_continuation_use_and_update_handler_noexc, caml_continuation_use_noexc, caml_convert_bytes_to_array, caml_convert_raw_backtrace, caml_convert_raw_backtrace_slot, caml_convert_string_to_bytes, caml_copysign_float, caml_cosh_float, caml_create_bytes, caml_create_file, caml_create_string, caml_csel_value, caml_current_dir, caml_custom_event_index, caml_custom_identifier, caml_custom_ops, caml_decompress_input, caml_div, caml_domain_dls, caml_domain_dls_compare_and_set, caml_domain_dls_get, caml_domain_dls_set, caml_domain_id, caml_domain_spawn, caml_dummy_obj_is_stack, caml_ephe_blit_data, caml_ephe_blit_key, caml_ephe_check_data, caml_ephe_check_key, caml_ephe_create, caml_ephe_data_offset, caml_ephe_get_data, caml_ephe_get_data_copy, caml_ephe_get_key, caml_ephe_get_key_copy, caml_ephe_key_offset, caml_ephe_none, caml_ephe_set_data, caml_ephe_set_data_opt, caml_ephe_set_key, caml_ephe_unset_data, caml_ephe_unset_key, caml_equal, caml_erf_float, caml_erfc_float, caml_executable_name, caml_exn_with_js_backtrace, caml_exp2_float, caml_expm1_float, caml_failwith, caml_fatal_uncaught_exception, caml_fill_bytes, caml_final_register, caml_final_register_called_without_value, caml_final_release, caml_finish_formatting, caml_float_compare, caml_float_of_bytes, caml_float_of_string, caml_floatarray_blit, caml_floatarray_create, caml_fma_float, caml_format_exception, caml_format_float, caml_format_int, caml_fresh_oo_id, caml_frexp_float, caml_fs_init, caml_gc_compaction, caml_gc_counters, caml_gc_full_major, caml_gc_get, caml_gc_major, caml_gc_major_slice, caml_gc_minor, caml_gc_minor_words, caml_gc_quick_stat, caml_gc_set, caml_gc_stat, caml_get_cached_method, caml_get_continuation_callstack, caml_get_current_callstack, caml_get_exception_backtrace, caml_get_exception_raw_backtrace, caml_get_global_data, caml_get_minor_free, caml_get_public_method, caml_get_root, caml_global_data, caml_gr_arc_aux, caml_gr_blit_image, caml_gr_clear_graph, caml_gr_close_graph, caml_gr_close_subwindow, caml_gr_create_image, caml_gr_current_x, caml_gr_current_y, caml_gr_display_mode, caml_gr_doc_of_state, caml_gr_draw_arc, caml_gr_draw_char, caml_gr_draw_image, caml_gr_draw_rect, caml_gr_draw_str, caml_gr_draw_string, caml_gr_dump_image, caml_gr_fill_arc, caml_gr_fill_poly, caml_gr_fill_rect, caml_gr_lineto, caml_gr_make_image, caml_gr_moveto, caml_gr_open_graph, caml_gr_open_subwindow, caml_gr_plot, caml_gr_point_color, caml_gr_remember_mode, caml_gr_resize_window, caml_gr_set_color, caml_gr_set_font, caml_gr_set_line_width, caml_gr_set_text_size, caml_gr_set_window_title, caml_gr_sigio_handler, caml_gr_sigio_signal, caml_gr_size_x, caml_gr_size_y, caml_gr_state, caml_gr_state_create, caml_gr_state_get, caml_gr_state_init, caml_gr_state_set, caml_gr_synchronize, caml_gr_text_size, caml_gr_wait_event, caml_gr_window_id, caml_greaterequal, caml_greaterthan, caml_hash, caml_hash_mix_bigstring, caml_hash_mix_bytes, caml_hash_mix_bytes_arr, caml_hash_mix_final, caml_hash_mix_float, caml_hash_mix_float16, caml_hash_mix_float32, caml_hash_mix_int, caml_hash_mix_int64, caml_hash_mix_jsbytes, caml_hash_mix_string, caml_hash_nat, caml_hexstring_of_float, caml_hypot_float, caml_input_value, caml_input_value_from_bytes, caml_input_value_from_reader, caml_input_value_to_outside_heap, caml_install_signal_handler, caml_int32_bits_of_float, caml_int32_bswap, caml_int32_float_of_bits, caml_int32_unmarshal, caml_int64_add, caml_int64_and, caml_int64_bits_of_float, caml_int64_bswap, caml_int64_compare, caml_int64_create_lo_hi, caml_int64_create_lo_mi_hi, caml_int64_div, caml_int64_float_of_bits, caml_int64_format, caml_int64_hash, caml_int64_hi32, caml_int64_is_negative, caml_int64_is_zero, caml_int64_lo32, caml_int64_marshal, caml_int64_mod, caml_int64_mul, caml_int64_neg, caml_int64_of_bytes, caml_int64_of_float, caml_int64_of_int32, caml_int64_of_string, caml_int64_offset, caml_int64_or, caml_int64_shift_left, caml_int64_shift_right, caml_int64_shift_right_unsigned, caml_int64_sub, caml_int64_to_bytes, caml_int64_to_float, caml_int64_to_int32, caml_int64_ult, caml_int64_unmarshal, caml_int64_xor, caml_int_compare, caml_int_of_string, caml_invalid_argument, caml_io_buffer_size, caml_is_continuation_tag, caml_is_js, caml_is_ml_bytes, caml_is_ml_string, caml_is_printable, caml_is_special_exception, caml_js_call, caml_js_delete, caml_js_equals, caml_js_error_of_exception, caml_js_error_option_of_exception, caml_js_eval_string, caml_js_expr, caml_js_from_array, caml_js_from_bool, caml_js_from_float, caml_js_from_string, caml_js_fun_call, caml_js_function_arity, caml_js_get, caml_js_get_console, caml_js_html_entities, caml_js_html_escape, caml_js_instanceof, caml_js_meth_call, caml_js_new, caml_js_object, caml_js_pure_expr, caml_js_set, caml_js_strict_equals, caml_js_to_array, caml_js_to_bool, caml_js_to_byte_string, caml_js_to_float, caml_js_to_int32, caml_js_to_string, caml_js_typeof, caml_js_var, caml_js_wrap_callback, caml_js_wrap_callback_arguments, caml_js_wrap_callback_strict, caml_js_wrap_callback_unsafe, caml_js_wrap_meth_callback, caml_js_wrap_meth_callback_arguments, caml_js_wrap_meth_callback_strict, caml_js_wrap_meth_callback_unsafe, caml_jsbytes_of_string, caml_jsoo_flags_effects, caml_jsoo_flags_use_js_string, caml_jsstring_of_string, caml_lazy_make_forward, caml_lazy_read_result, caml_lazy_reset_to_lazy, caml_lazy_update_to_forcing, caml_lazy_update_to_forward, caml_ldexp_float, caml_lessequal, caml_lessthan, caml_lex_array, caml_lex_engine, caml_list_mount_point, caml_list_of_js_array, caml_list_to_js_array, caml_log10_float, caml_log1p_float, caml_log2_float, caml_lxm_M, caml_lxm_daba, caml_lxm_next, caml_make_float_vect, caml_make_local_vect, caml_make_path, caml_make_vect, caml_marshal_constants, caml_marshal_data_size, caml_marshal_header_size, caml_maybe_attach_backtrace, caml_maybe_print_stats, caml_md5_bytes, caml_md5_chan, caml_md5_string, caml_memprof_discard, caml_memprof_start, caml_memprof_stop, caml_method_cache, caml_ml_bytes_content, caml_ml_bytes_length, caml_ml_channel_get, caml_ml_channel_redirect, caml_ml_channel_restore, caml_ml_channel_size, caml_ml_channel_size_64, caml_ml_channels, caml_ml_close_channel, caml_ml_condition_broadcast, caml_ml_condition_new, caml_ml_condition_signal, caml_ml_condition_wait, caml_ml_debug_info_status, caml_ml_domain_cpu_relax, caml_ml_domain_id, caml_ml_enable_runtime_warnings, caml_ml_flush, caml_ml_input, caml_ml_input_bigarray, caml_ml_input_block, caml_ml_input_char, caml_ml_input_int, caml_ml_input_scan_line, caml_ml_is_binary_mode, caml_ml_is_buffered, caml_ml_mutex_lock, caml_ml_mutex_new, caml_ml_mutex_try_lock, caml_ml_mutex_unlock, caml_ml_open_descriptor_in, caml_ml_open_descriptor_in_with_flags, caml_ml_open_descriptor_out, caml_ml_open_descriptor_out_with_flags, caml_ml_out_channels_list, caml_ml_output, caml_ml_output_bigarray, caml_ml_output_bytes, caml_ml_output_char, caml_ml_output_int, caml_ml_output_ta, caml_ml_pos_in, caml_ml_pos_in_64, caml_ml_pos_out, caml_ml_pos_out_64, caml_ml_runtime_events_are_active, caml_ml_runtime_events_pause, caml_ml_runtime_events_resume, caml_ml_runtime_events_start, caml_ml_runtime_warnings_enabled, caml_ml_seek_in, caml_ml_seek_in_64, caml_ml_seek_out, caml_ml_seek_out_64, caml_ml_set_binary_mode, caml_ml_set_buffered, caml_ml_set_channel_name, caml_ml_set_channel_output, caml_ml_set_channel_refill, caml_ml_string_length, caml_mod, caml_modf_float, caml_mount_autoload, caml_mul, caml_named_value, caml_named_values, caml_nativeint_unmarshal, caml_new_lex_engine, caml_new_string, caml_nextafter_float, caml_notequal, caml_obj_add_offset, caml_obj_block, caml_obj_compare_and_swap, caml_obj_dup, caml_obj_is_shared, caml_obj_raw_field, caml_obj_reachable_words, caml_obj_set_raw_field, caml_obj_tag, caml_obj_update_tag, caml_obj_with_tag, caml_ojs_new_arr, caml_oo_cache_id, caml_oo_last_id, caml_output_val, caml_output_value, caml_output_value_to_buffer, caml_output_value_to_bytes, caml_output_value_to_string, caml_packFloat16, caml_parse_digit, caml_parse_engine, caml_parse_format, caml_parse_sign_and_base, caml_parser_trace, caml_pos_in, caml_pos_out, caml_pure_js_expr, caml_raise_constant, caml_raise_end_of_file, caml_raise_no_such_file, caml_raise_nodejs_error, caml_raise_not_found, caml_raise_sys_error, caml_raise_system_error, caml_raise_with_arg, caml_raise_with_args, caml_raise_with_string, caml_raise_zero_divide, caml_raw_backtrace_length, caml_raw_backtrace_next_slot, caml_raw_backtrace_slot, caml_read_file_content, caml_recommended_domain_count, caml_record_backtrace, caml_record_backtrace_env_flag, caml_record_backtrace_runtime_flag, caml_refill, caml_register_global, caml_register_named_value, caml_restore_raw_backtrace, caml_root, caml_round_float, caml_runtime_events_create_cursor, caml_runtime_events_free_cursor, caml_runtime_events_read_poll, caml_runtime_events_user_register, caml_runtime_events_user_resolve, caml_runtime_events_user_write, caml_runtime_parameters, caml_runtime_variant, caml_runtime_warnings, caml_seek_in, caml_seek_out, caml_set_oo_id, caml_set_parser_trace, caml_set_static_env, caml_signbit_float, caml_sinh_float, caml_sse2_float64_max_bytecode, caml_sse2_float64_min_bytecode, caml_str_repeat, caml_strerror, caml_string_bound_error, caml_string_compare, caml_string_concat, caml_string_equal, caml_string_get, caml_string_get16, caml_string_get32, caml_string_get64, caml_string_greaterequal, caml_string_greaterthan, caml_string_hash, caml_string_lessequal, caml_string_lessthan, caml_string_notequal, caml_string_of_array, caml_string_of_bytes, caml_string_of_jsbytes, caml_string_of_jsstring, caml_string_of_uint8_array, caml_string_set, caml_string_unsafe_get, caml_sub_uint8_array_to_jsbytes, caml_subarray_to_jsbytes, caml_sys_argv, caml_sys_chdir, caml_sys_close, caml_sys_const_backend_type, caml_sys_const_big_endian, caml_sys_const_int_size, caml_sys_const_max_wosize, caml_sys_const_naked_pointers_checked, caml_sys_const_ostype_cygwin, caml_sys_const_ostype_unix, caml_sys_const_ostype_win32, caml_sys_const_word_size, caml_sys_executable_name, caml_sys_exit, caml_sys_fds, caml_sys_file_exists, caml_sys_get_argv, caml_sys_get_config, caml_sys_getcwd, caml_sys_getenv, caml_sys_is_directory, caml_sys_is_regular_file, caml_sys_isatty, caml_sys_mkdir, caml_sys_modify_argv, caml_sys_open, caml_sys_open_for_node, caml_sys_random_seed, caml_sys_read_directory, caml_sys_remove, caml_sys_rename, caml_sys_rmdir, caml_sys_system_command, caml_sys_time, caml_sys_time_include_children, caml_sys_unsafe_getenv, caml_tanh_float, caml_throw_js_exception, caml_to_js_string, caml_trailing_slash, caml_trampoline, caml_trampoline_return, caml_trunc_float, caml_uint8_array_of_bytes, caml_uint8_array_of_string, caml_unix_access, caml_unix_chdir, caml_unix_chmod, caml_unix_cleanup, caml_unix_close, caml_unix_closedir, caml_unix_fchmod, caml_unix_filedescr_of_fd, caml_unix_findclose, caml_unix_findfirst, caml_unix_findnext, caml_unix_fstat, caml_unix_fstat_64, caml_unix_fsync, caml_unix_ftruncate, caml_unix_ftruncate_64, caml_unix_getegid, caml_unix_geteuid, caml_unix_getgid, caml_unix_getpwnam, caml_unix_gettimeofday, caml_unix_getuid, caml_unix_gmtime, caml_unix_has_symlink, caml_unix_inchannel_of_filedescr, caml_unix_inet_addr_of_string, caml_unix_isatty, caml_unix_link, caml_unix_localtime, caml_unix_lookup_file, caml_unix_lseek, caml_unix_lseek_64, caml_unix_lstat, caml_unix_lstat_64, caml_unix_mkdir, caml_unix_mktime, caml_unix_open, caml_unix_opendir, caml_unix_outchannel_of_filedescr, caml_unix_read, caml_unix_read_bigarray, caml_unix_readdir, caml_unix_readlink, caml_unix_rename, caml_unix_rewinddir, caml_unix_rmdir, caml_unix_single_write, caml_unix_startup, caml_unix_stat, caml_unix_stat_64, caml_unix_symlink, caml_unix_time, caml_unix_times, caml_unix_truncate, caml_unix_truncate_64, caml_unix_unlink, caml_unix_utimes, caml_unix_write, caml_unix_write_bigarray, caml_unmount, caml_unpackFloat16, caml_update_dummy, caml_weak_create, caml_weak_set, caml_wrap_exception, caml_xdg_defaults, caml_xmlhttprequest_create, caml_zstd_initialize, compare_digits_nat, compare_nat, complement_nat, core_array_unsafe_float_blit, core_array_unsafe_int_blit, core_gc_compactions, core_gc_heap_chunks, core_gc_heap_words, core_gc_major_collections, core_gc_major_plus_minor_words, core_gc_major_words, core_gc_minor_collections, core_gc_minor_words, core_gc_promoted_words, core_gc_run_memprof_callbacks, core_gc_top_heap_words, core_heap_block_is_heap_block, core_md5_digest_subbigstring, core_md5_fd, core_time_ns_format, create_nat, decr_nat, deserialize_nat, div_digit_nat, div_helper, div_nat, fs_node_stats_from_js, fs_node_supported, incr_nat, initialize_nat, internalhash_fold_bigstring, is_digit_int, is_digit_normalized, is_digit_odd, is_digit_zero, jsoo_create_file, jsoo_create_file_extern, jsoo_dataview, jsoo_effect_not_supported, jsoo_is_ascii, jsoo_mount_point, jsoo_static_env, jsoo_sys_getenv, jsoo_text_decoder, jsoo_text_decoder_buff, jsoo_text_encoder, jsoo_toplevel_reloc, land_digit_nat, length_nat, lor_digit_nat, lxor_digit_nat, make_unix_err_args, ms_float_to_ns_int64, mult_digit_nat, mult_nat, nat_of_array, nth_digit_nat, nth_digit_nat_native, num_digits_nat, num_leading_zero_bits_in_digit, os_type, path_is_absolute, ppx_expect_runtime_after_test, ppx_expect_runtime_before_test, ppx_expect_runtime_flush_stubs_streams, ppx_expect_runtime_out_channel_position, ppx_expect_runtime_saved_stderr, ppx_expect_runtime_saved_stdout, re_match, re_partial_match, re_replacement_text, re_search_backward, re_search_forward, re_string_match, resolve_fs_device, serialize_nat, set_digit_nat, set_digit_nat_native, set_to_zero_nat, shift_left_nat, shift_right_nat, should_use_timezone_js_loader, square_nat, sub_nat, time_now_nanosecond_counter_for_timing, time_now_nanoseconds_since_unix_epoch_or_zero, timezone_js_loader_compare_instants, timezone_js_loader_create_zone, timezone_js_loader_disable_for_testing, timezone_js_loader_enable_for_testing, timezone_js_loader_epoch_seconds, timezone_js_loader_from_epoch_seconds, timezone_js_loader_get_next_transition_or_this_time_if_none, timezone_js_loader_get_offset_nanos_for, timezone_js_loader_instant_plus_hours, timezone_js_loader_now, unix_error, unix_error_message, zstd_decompress
//# unitInfo: Aliases: caml_unix_error_message=unix_error_message, caml_unix_lookup_file=caml_unix_write_bigarray, unix_write=caml_unix_write, unix_utimes=caml_unix_utimes, unix_unlink=caml_unix_unlink, unix_truncate_64=caml_unix_truncate_64, unix_truncate=caml_unix_truncate, unix_times=caml_unix_times, unix_time=caml_unix_time, unix_symlink=caml_unix_symlink, unix_stat_64=caml_unix_stat_64, unix_stat=caml_unix_stat, win_startup=caml_unix_startup, unix_single_write=caml_unix_single_write, unix_rmdir=caml_unix_rmdir, unix_rewinddir=caml_unix_rewinddir, unix_rename=caml_unix_rename, unix_readlink=caml_unix_readlink, unix_readdir=caml_unix_readdir, unix_read_bigarray=caml_unix_read_bigarray, unix_read=caml_unix_read, unix_outchannel_of_filedescr=caml_unix_outchannel_of_filedescr, win_outchannel_of_filedescr=caml_unix_outchannel_of_filedescr, unix_opendir=caml_unix_opendir, unix_open=caml_unix_open, unix_mktime=caml_unix_mktime, unix_mkdir=caml_unix_mkdir, unix_lstat_64=caml_unix_lstat_64, unix_lstat=caml_unix_lstat, unix_lseek_64=caml_unix_lseek_64, unix_lseek=caml_unix_lseek, unix_localtime=caml_unix_localtime, unix_link=caml_unix_link, unix_isatty=caml_unix_isatty, unix_inet_addr_of_string=caml_unix_inet_addr_of_string, unix_inchannel_of_filedescr=caml_unix_inchannel_of_filedescr, win_inchannel_of_filedescr=caml_unix_inchannel_of_filedescr, unix_has_symlink=caml_unix_has_symlink, unix_gmtime=caml_unix_gmtime, unix_getuid=caml_unix_getuid, unix_gettimeofday=caml_unix_gettimeofday, caml_unix_getgrgid=caml_unix_getpwnam, caml_unix_getgrnam=caml_unix_getpwnam, caml_unix_getpwuid=caml_unix_getpwnam, unix_getgrgid=caml_unix_getpwnam, unix_getgrnam=caml_unix_getpwnam, unix_getpwnam=caml_unix_getpwnam, unix_getpwuid=caml_unix_getpwnam, unix_getgid=caml_unix_getgid, unix_geteuid=caml_unix_geteuid, unix_getegid=caml_unix_getegid, unix_ftruncate_64=caml_unix_ftruncate_64, unix_ftruncate=caml_unix_ftruncate, unix_fsync=caml_unix_fsync, unix_fstat_64=caml_unix_fstat_64, unix_fstat=caml_unix_fstat, win_findnext=caml_unix_findnext, win_findfirst=caml_unix_findfirst, win_findclose=caml_unix_findclose, win_handle_fd=caml_unix_filedescr_of_fd, unix_fchmod=caml_unix_fchmod, unix_closedir=caml_unix_closedir, unix_close=caml_unix_close, win_cleanup=caml_unix_cleanup, unix_chmod=caml_unix_chmod, unix_chdir=caml_unix_chdir, unix_access=caml_unix_access, caml_unix_getcwd=caml_sys_getcwd, unix_getcwd=caml_sys_getcwd, caml_unix_exit=caml_sys_exit, unix_exit=caml_sys_exit, caml_signbit=caml_signbit_float, %int_mul=caml_mul, caml_int32_mul=caml_mul, caml_nativeint_mul=caml_mul, %int_mod=caml_mod, caml_int32_mod=caml_mod, caml_nativeint_mod=caml_mod, caml_js_to_nativeint=caml_js_to_int32, caml_js_from_int32=caml_js_from_float, caml_js_from_nativeint=caml_js_from_float, caml_int32_of_string=caml_int_of_string, caml_nativeint_of_string=caml_int_of_string, caml_int32_compare=caml_int_compare, caml_nativeint_compare=caml_int_compare, caml_int64_to_int=caml_int64_to_int32, caml_int64_to_nativeint=caml_int64_to_int32, caml_int64_of_int=caml_int64_of_int32, caml_int64_of_nativeint=caml_int64_of_int32, caml_nativeint_bswap=caml_int32_bswap, caml_int32_format=caml_format_int, caml_nativeint_format=caml_format_int, caml_fill_string=caml_fill_bytes, caml_weak_get_copy=caml_ephe_get_key_copy, caml_weak_get=caml_ephe_get_key, caml_weak_check=caml_ephe_check_key, caml_weak_blit=caml_ephe_blit_key, %int_div=caml_div, caml_int32_div=caml_div, caml_nativeint_div=caml_div, caml_check_bound_float=caml_check_bound, caml_check_bound_gen=caml_check_bound, win_filedescr_of_channel=caml_channel_descriptor, caml_array_set_addr=caml_array_set, caml_array_set_float=caml_array_set, caml_floatarray_set=caml_array_set, caml_array_get_addr=caml_array_get, caml_array_get_float=caml_array_get, caml_floatarray_get=caml_array_get
//# unitInfo: Force_link: true
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   var joo_global_object = globalThis;
   (function(){
      var
       DefaultLocale =
         {days:
          ["Sunday",
           "Monday",
           "Tuesday",
           "Wednesday",
           "Thursday",
           "Friday",
           "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months:
          ["January",
           "February",
           "March",
           "April",
           "May",
           "June",
           "July",
           "August",
           "September",
           "October",
           "November",
           "December"],
          shortMonths:
          ["Jan",
           "Feb",
           "Mar",
           "Apr",
           "May",
           "Jun",
           "Jul",
           "Aug",
           "Sep",
           "Oct",
           "Nov",
           "Dec"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats:
          {D: "%m/%d/%y",
           F: "%Y-%m-%d",
           R: "%H:%M",
           T: "%H:%M:%S",
           X: "%T",
           c: "%a %b %d %X %Y",
           r: "%I:%M:%S %p",
           v: "%e-%b-%Y",
           x: "%D"}},
       defaultStrftime = new Strftime(DefaultLocale, 0, false),
       isCommonJS = typeof module !== "undefined",
       namespace;
      if(isCommonJS){
       namespace = module.exports = adaptedStrftime;
       namespace.strftime = deprecatedStrftime;
       if(joo_global_object) joo_global_object.strftime = adaptedStrftime;
      }
      else{
       namespace =
        joo_global_object || function(){return this || (1, eval)("this");}();
       namespace.strftime = adaptedStrftime;
      }
      var
       _require = isCommonJS ? "require('strftime')" : "strftime",
       _deprecationWarnings = {};
      function deprecationWarning(name, instead){
       if(! _deprecationWarnings[name]){
        if
         (typeof console !== "undefined" && typeof console.warn == "function")
         console.warn
          ("[WARNING] " + name
           +
            " is deprecated and will be removed in version 1.0. Instead, use `"
           + instead
           + "`.");
        _deprecationWarnings[name] = true;
       }
      }
      namespace.strftimeTZ = deprecatedStrftimeTZ;
      namespace.strftimeUTC = deprecatedStrftimeUTC;
      namespace.localizedStrftime = deprecatedStrftimeLocalized;
      function adaptForwards(fn){
       fn.localize = defaultStrftime.localize.bind(defaultStrftime);
       fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
       fn.utc = defaultStrftime.utc.bind(defaultStrftime);
      }
      adaptForwards(adaptedStrftime);
      function adaptedStrftime(fmt, d, locale){
       if(d && d.days){locale = d; d = undefined;}
       if(locale)
        deprecationWarning
         ("`" + _require + "(format, [date], [locale])`",
          "var s = " + _require + ".localize(locale); s(format, [date])");
       var
        strftime = locale ? defaultStrftime.localize(locale) : defaultStrftime;
       return strftime(fmt, d);
      }
      adaptForwards(deprecatedStrftime);
      function deprecatedStrftime(fmt, d, locale){
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftime(format, [date], [locale])`",
          "var s = " + _require + ".localize(locale); s(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftime(format, [date])`",
          _require + "(format, [date])");
       var
        strftime = locale ? defaultStrftime.localize(locale) : defaultStrftime;
       return strftime(fmt, d);
      }
      function deprecatedStrftimeTZ(fmt, d, locale, timezone){
       if
        ((typeof locale == "number" || typeof locale == "string")
         && timezone == null){
        timezone = locale;
        locale = undefined;
       }
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
          "var s = " + _require
          + ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
          + _require
          + ".localize(locale); s.timezone(tz)(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftimeTZ(format, date, tz)`",
          "var s = " + _require + ".timezone(tz); s(format, [date])` or `"
          + _require
          + ".timezone(tz)(format, [date])");
       var
        strftime =
          (locale ? defaultStrftime.localize(locale) : defaultStrftime).timezone
           (timezone);
       return strftime(fmt, d);
      }
      var utcStrftime = defaultStrftime.utc();
      function deprecatedStrftimeUTC(fmt, d, locale){
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftimeUTC(format, date, locale)`",
          "var s = " + _require + ".localize(locale).utc(); s(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftimeUTC(format, [date])`",
          "var s = " + _require + ".utc(); s(format, [date])");
       var strftime = locale ? utcStrftime.localize(locale) : utcStrftime;
       return strftime(fmt, d);
      }
      function deprecatedStrftimeLocalized(locale){
       deprecationWarning
        ("`" + _require + ".localizedStrftime(locale)`",
         _require + ".localize(locale)");
       return defaultStrftime.localize(locale);
      }
      if(typeof Date.now !== "function")
       Date.now = function(){return + new Date();};
      function Strftime(locale, customTimezoneOffset, useUtcTimezone){
       var
        _locale = locale || DefaultLocale,
        _customTimezoneOffset = customTimezoneOffset || 0,
        _useUtcBasedDate = useUtcTimezone || false,
        _cachedDateTimestamp = 0,
        _cachedDate;
       function _strftime(format, date){
        var timestamp;
        if(! date){
         var currentTimestamp = Date.now();
         if(currentTimestamp > _cachedDateTimestamp){
          _cachedDateTimestamp = currentTimestamp;
          _cachedDate = new Date(_cachedDateTimestamp);
          timestamp = _cachedDateTimestamp;
          if(_useUtcBasedDate)
           _cachedDate =
            new
             Date
             (_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate)
              + _customTimezoneOffset);
         }
         date = _cachedDate;
        }
        else{
         timestamp = date.getTime();
         if(_useUtcBasedDate)
          date =
           new
            Date
            (date.getTime() + getTimestampToUtcOffsetFor(date)
             + _customTimezoneOffset);
        }
        return _processFormat(format, date, _locale, timestamp);
       }
       function _processFormat(format, date, locale, timestamp){
        var
         resultString = "",
         padding = null,
         isInScope = false,
         length = format.length,
         extendedTZ = false;
        for(var i = 0; i < length; i++){
         var currentCharCode = format.charCodeAt(i);
         if(isInScope === true){
          if(currentCharCode === 45){padding = ""; continue;}
          else if(currentCharCode === 95){padding = " "; continue;}
          else if(currentCharCode === 48){padding = "0"; continue;}
          else if(currentCharCode === 58){
           if(extendedTZ)
            if
             (typeof console !== "undefined"
              && typeof console.warn == "function")
             console.warn
              ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
           extendedTZ = true;
           continue;
          }
          switch(currentCharCode){
            case 65:
             resultString += locale.days[date.getDay()]; break;
            case 66:
             resultString += locale.months[date.getMonth()]; break;
            case 67:
             resultString +=
              padTill2(Math.floor(date.getFullYear() / 100), padding);
             break;
            case 68:
             resultString +=
              _processFormat(locale.formats.D, date, locale, timestamp);
             break;
            case 70:
             resultString +=
              _processFormat(locale.formats.F, date, locale, timestamp);
             break;
            case 72:
             resultString += padTill2(date.getHours(), padding); break;
            case 73:
             resultString += padTill2(hours12(date.getHours()), padding);
             break;
            case 76:
             resultString += padTill3(Math.floor(timestamp % 1000)); break;
            case 77:
             resultString += padTill2(date.getMinutes(), padding); break;
            case 80:
             resultString += date.getHours() < 12 ? locale.am : locale.pm;
             break;
            case 82:
             resultString +=
              _processFormat(locale.formats.R, date, locale, timestamp);
             break;
            case 83:
             resultString += padTill2(date.getSeconds(), padding); break;
            case 84:
             resultString +=
              _processFormat(locale.formats.T, date, locale, timestamp);
             break;
            case 85:
             resultString += padTill2(weekNumber(date, "sunday"), padding);
             break;
            case 87:
             resultString += padTill2(weekNumber(date, "monday"), padding);
             break;
            case 88:
             resultString +=
              _processFormat(locale.formats.X, date, locale, timestamp);
             break;
            case 89:
             resultString += date.getFullYear(); break;
            case 90:
             if(_useUtcBasedDate && _customTimezoneOffset === 0)
              resultString += "GMT";
             else{
              var tzString = date.toString().match(/\(([\w\s]+)\)/);
              resultString += tzString && tzString[1] || "";
             }
             break;
            case 97:
             resultString += locale.shortDays[date.getDay()]; break;
            case 98:
             resultString += locale.shortMonths[date.getMonth()]; break;
            case 99:
             resultString +=
              _processFormat(locale.formats.c, date, locale, timestamp);
             break;
            case 100:
             resultString += padTill2(date.getDate(), padding); break;
            case 101:
             resultString +=
              padTill2(date.getDate(), padding == null ? " " : padding);
             break;
            case 104:
             resultString += locale.shortMonths[date.getMonth()]; break;
            case 106:
             var
              y = new Date(date.getFullYear(), 0, 1),
              day =
                Math.ceil
                 ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
             resultString += padTill3(day);
             break;
            case 107:
             resultString +=
              padTill2(date.getHours(), padding == null ? " " : padding);
             break;
            case 108:
             resultString +=
              padTill2
               (hours12(date.getHours()), padding == null ? " " : padding);
             break;
            case 109:
             resultString += padTill2(date.getMonth() + 1, padding); break;
            case 110:
             resultString += "\n"; break;
            case 111:
             resultString += String(date.getDate()) + ordinal(date.getDate());
             break;
            case 112:
             resultString += date.getHours() < 12 ? locale.AM : locale.PM;
             break;
            case 114:
             resultString +=
              _processFormat(locale.formats.r, date, locale, timestamp);
             break;
            case 115:
             resultString += Math.floor(timestamp / 1000); break;
            case 116:
             resultString += "\t"; break;
            case 117:
             var day = date.getDay();
             resultString += day === 0 ? 7 : day;
             break;
            case 118:
             resultString +=
              _processFormat(locale.formats.v, date, locale, timestamp);
             break;
            case 119:
             resultString += date.getDay(); break;
            case 120:
             resultString +=
              _processFormat(locale.formats.x, date, locale, timestamp);
             break;
            case 121:
             resultString += ("" + date.getFullYear()).slice(2); break;
            case 122:
             if(_useUtcBasedDate && _customTimezoneOffset === 0)
              resultString += extendedTZ ? "+00:00" : "+0000";
             else{
              var off;
              if(_customTimezoneOffset !== 0)
               off = _customTimezoneOffset / (60 * 1000);
              else
               off = - date.getTimezoneOffset();
              var
               sign = off < 0 ? "-" : "+",
               sep = extendedTZ ? ":" : "",
               hours = Math.floor(Math.abs(off / 60)),
               mins = Math.abs(off % 60);
              resultString += sign + padTill2(hours) + sep + padTill2(mins);
             }
             break;
            default: resultString += format[i]; break;
          }
          padding = null;
          isInScope = false;
          continue;
         }
         if(currentCharCode === 37){isInScope = true; continue;}
         resultString += format[i];
        }
        return resultString;
       }
       var strftime = _strftime;
       strftime.localize =
        function(locale){
         return new
                 Strftime
                 (locale || _locale, _customTimezoneOffset, _useUtcBasedDate);
        };
       strftime.timezone =
        function(timezone){
         var
          customTimezoneOffset = _customTimezoneOffset,
          useUtcBasedDate = _useUtcBasedDate,
          timezoneType = typeof timezone;
         if(timezoneType === "number" || timezoneType === "string"){
          useUtcBasedDate = true;
          if(timezoneType === "string"){
           var
            sign = timezone[0] === "-" ? - 1 : 1,
            hours = parseInt(timezone.slice(1, 3), 10),
            minutes = parseInt(timezone.slice(3, 5), 10);
           customTimezoneOffset = sign * (60 * hours + minutes) * 60 * 1000;
          }
          else if(timezoneType === "number")
           customTimezoneOffset = timezone * 60 * 1000;
         }
         return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);
        };
       strftime.utc =
        function(){return new Strftime(_locale, _customTimezoneOffset, true);};
       return strftime;
      }
      function padTill2(numberToPad, paddingChar){
       if(paddingChar === "" || numberToPad > 9) return numberToPad;
       if(paddingChar == null) paddingChar = "0";
       return paddingChar + numberToPad;
      }
      function padTill3(numberToPad){
       if(numberToPad > 99) return numberToPad;
       if(numberToPad > 9) return "0" + numberToPad;
       return "00" + numberToPad;
      }
      function hours12(hour){
       if(hour === 0) return 12; else if(hour > 12) return hour - 12;
       return hour;
      }
      function weekNumber(date, firstWeekday){
       firstWeekday = firstWeekday || "sunday";
       var weekday = date.getDay();
       if(firstWeekday === "monday")
        if(weekday === 0) weekday = 6; else weekday--;
       var
        firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),
        dateUtc =
          Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
        yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
        weekNum = (yday + 7 - weekday) / 7;
       return Math.floor(weekNum);
      }
      function ordinal(number){
       var i = number % 10, ii = number % 100;
       if(ii >= 11 && ii <= 13 || i === 0 || i >= 4) return "th";
       switch(i){case 1: return "st";case 2: return "nd";case 3: return "rd";
       }
      }
      function getTimestampToUtcOffsetFor(date){
       return (date.getTimezoneOffset() || 0) * 60000;
      }
     }
     ());
  }
  (globalThis));
(function(globalThis){
   function _iterableToArrayLimit(r, l){
    var
     t =
       null == r
        ? null
        : "undefined"
         != typeof Symbol
         && r[Symbol.iterator]
         || r["@@iterator"];
    if(null != t){
     var e, n, i, u, a = [], f = ! 0, o = ! 1;
     try{
      if(i = (t = t.call(r)).next, 0 === l){if(Object(t) !== t) return; f = ! 1;
      }
      else
       for
       (;
        ! (f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l);
        f = ! 0)
        ;
     }
     catch(r){o = ! 0, n = r;}
     finally{
      try{
       if(! f && null != t.return && (u = t.return(), Object(u) !== u))
        return;
      }
      finally{if(o) throw n;}
     }
     return a;
    }
   }
   function ownKeys(e, r){
    var t = Object.keys(e);
    if(Object.getOwnPropertySymbols){
     var o = Object.getOwnPropertySymbols(e);
     r
     &&
      (o =
       o.filter
        (function(r){return Object.getOwnPropertyDescriptor(e, r).enumerable;})),
     t.push.apply(t, o);
    }
    return t;
   }
   function _objectSpread2(e){
    for(var r = 1; r < arguments.length; r++){
     var t = null != arguments[r] ? arguments[r] : {};
     r % 2
      ? ownKeys
         (Object(t), ! 0).forEach
        (function(r){_defineProperty(e, r, t[r]);})
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
        : ownKeys
           (Object(t)).forEach
          (function(r){
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
           });
    }
    return e;
   }
   function _toPrimitive(t, r){
    if("object" != typeof t || ! t) return t;
    var e = t[Symbol.toPrimitive];
    if(void 0 !== e){
     var i = e.call(t, r || "default");
     if("object" != typeof i) return i;
     throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
   }
   function _toPropertyKey(t){
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
   }
   function _typeof(o){
    "@babel/helpers - typeof";
    return _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
             ? function(o){return typeof o;}
             : function
              (o){
               return o && "function" == typeof Symbol
                       && o.constructor === Symbol
                       && o !== Symbol.prototype
                       ? "symbol"
                       : typeof o;
              },
           _typeof(o);
   }
   function _classCallCheck(instance, Constructor){
    if(! (instance instanceof Constructor))
     throw new TypeError("Cannot call a class as a function");
   }
   function _defineProperties(target, props){
    for(var i = 0; i < props.length; i++){
     var descriptor = props[i];
     descriptor.enumerable = descriptor.enumerable || false;
     descriptor.configurable = true;
     if("value" in descriptor) descriptor.writable = true;
     Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
   }
   function _createClass(Constructor, protoProps, staticProps){
    if(protoProps) _defineProperties(Constructor.prototype, protoProps);
    if(staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {writable: false});
    return Constructor;
   }
   function _defineProperty(obj, key, value){
    key = _toPropertyKey(key);
    if(key in obj)
     Object.defineProperty
      (obj,
       key,
       {value: value, enumerable: true, configurable: true, writable: true});
    else
     obj[key] = value;
    return obj;
   }
   function _inherits(subClass, superClass){
    if(typeof superClass !== "function" && superClass !== null)
     throw new TypeError("Super expression must either be null or a function");
    subClass.prototype =
     Object.create
      (superClass && superClass.prototype,
       {constructor: {value: subClass, writable: true, configurable: true}});
    Object.defineProperty(subClass, "prototype", {writable: false});
    if(superClass) _setPrototypeOf(subClass, superClass);
   }
   function _getPrototypeOf(o){
    _getPrototypeOf =
     Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function(o){return o.__proto__ || Object.getPrototypeOf(o);};
    return _getPrototypeOf(o);
   }
   function _setPrototypeOf(o, p){
    _setPrototypeOf =
     Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function(o, p){o.__proto__ = p; return o;};
    return _setPrototypeOf(o, p);
   }
   function _isNativeReflectConstruct(){
    if(typeof Reflect === "undefined" || ! Reflect.construct) return false;
    if(Reflect.construct.sham) return false;
    if(typeof Proxy === "function") return true;
    try{
     Boolean.prototype.valueOf.call
      (Reflect.construct(Boolean, [], function(){}));
     return true;
    }
    catch(e){return false;}
   }
   function _assertThisInitialized(self){
    if(self === void 0)
     throw new
            ReferenceError
            ("this hasn't been initialised - super() hasn't been called");
    return self;
   }
   function _possibleConstructorReturn(self, call){
    if(call && (typeof call === "object" || typeof call === "function"))
     return call;
    else if(call !== void 0)
     throw new
            TypeError
            ("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
   }
   function _createSuper(Derived){
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function(){
     var Super = _getPrototypeOf(Derived), result;
     if(hasNativeReflectConstruct){
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
     }
     else
      result = Super.apply(this, arguments);
     return _possibleConstructorReturn(this, result);};
   }
   function _superPropBase(object, property){
    while(! Object.prototype.hasOwnProperty.call(object, property)){object = _getPrototypeOf(object); if(object === null) break;}
    return object;
   }
   function _get(){
    if(typeof Reflect !== "undefined" && Reflect.get)
     _get = Reflect.get.bind();
    else
     _get =
      function(target, property, receiver){
       var base = _superPropBase(target, property);
       if(! base) return;
       var desc = Object.getOwnPropertyDescriptor(base, property);
       if(desc.get)
        return desc.get.call(arguments.length < 3 ? target : receiver);
       return desc.value;
      };
    return _get.apply(this, arguments);
   }
   function _slicedToArray(arr, i){
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i)
           || _unsupportedIterableToArray(arr, i)
           || _nonIterableRest();
   }
   function _toConsumableArray(arr){
    return _arrayWithoutHoles(arr) || _iterableToArray(arr)
           || _unsupportedIterableToArray(arr)
           || _nonIterableSpread();
   }
   function _arrayWithoutHoles(arr){
    if(Array.isArray(arr)) return _arrayLikeToArray(arr);
   }
   function _arrayWithHoles(arr){if(Array.isArray(arr)) return arr;}
   function _iterableToArray(iter){
    if
     (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null
      || iter["@@iterator"] != null)
     return Array.from(iter);
   }
   function _unsupportedIterableToArray(o, minLen){
    if(! o) return;
    if(typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, - 1);
    if(n === "Object" && o.constructor) n = o.constructor.name;
    if(n === "Map" || n === "Set") return Array.from(o);
    if
     (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
     return _arrayLikeToArray(o, minLen);
   }
   function _arrayLikeToArray(arr, len){
    if(len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
   }
   function _nonIterableSpread(){
    throw new
           TypeError
           ("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
   }
   function _nonIterableRest(){
    throw new
           TypeError
           ("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
   }
   function _createForOfIteratorHelper(o, allowArrayLike){
    var
     it =
       typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if(! it){
     if
      (Array.isArray(o) || (it = _unsupportedIterableToArray(o))
       || allowArrayLike && o && typeof o.length === "number"){
      if(it) o = it;
      var i = 0, F = function(){};
      return {s: F,
              n:
              function(){
               if(i >= o.length) return {done: true};
               return {done: false, value: o[i++]};
              },
              e: function(e){throw e;},
              f: F};
     }
     throw new
            TypeError
            ("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function(){it = it.call(o);},
            n:
            function(){
             var step = it.next();
             normalCompletion = step.done;
             return step;
            },
            e: function(e){didErr = true; err = e;},
            f:
            function(){
             try{if(! normalCompletion && it.return != null) it.return();}
             finally{if(didErr) throw err;}
            }};
   }
   var t = {};
   function MakeIntrinsicClass(e, t){
    Object.defineProperty
     (e.prototype,
      Symbol.toStringTag,
      {value: t, writable: ! 1, enumerable: ! 1, configurable: ! 0});
    var
     _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(e)),
     _step;
    try{
     for(_iterator.s(); ! (_step = _iterator.n()).done;){
      var _t = _step.value, _r = Object.getOwnPropertyDescriptor(e, _t);
      _r.configurable && _r.enumerable
      && (_r.enumerable = ! 1, Object.defineProperty(e, _t, _r));
     }
    }
    catch(err){_iterator.e(err);}
    finally{_iterator.f();}
    var
     _iterator2 =
       _createForOfIteratorHelper(Object.getOwnPropertyNames(e.prototype)),
     _step2;
    try{
     for(_iterator2.s(); ! (_step2 = _iterator2.n()).done;){
      var
       _t2 = _step2.value,
       _r2 = Object.getOwnPropertyDescriptor(e.prototype, _t2);
      _r2.configurable && _r2.enumerable
      && (_r2.enumerable = ! 1, Object.defineProperty(e.prototype, _t2, _r2));
     }
    }
    catch(err){_iterator2.e(err);}
    finally{_iterator2.f();}
    DefineIntrinsic(t, e),
    DefineIntrinsic("".concat(t, ".prototype"), e.prototype);
   }
   function DefineIntrinsic(e, r){
    var o = "%".concat(e, "%");
    if(void 0 !== t[o])
     throw new Error("intrinsic ".concat(e, " already exists"));
    t[o] = r;
   }
   function GetIntrinsic(e){return t[e];}
   var
    r,
    o,
    n = "slot-epochNanoSeconds",
    a = "slot-timezone-identifier",
    i = "slot-year",
    s = "slot-month",
    l = "slot-day",
    d = "slot-hour",
    m = "slot-minute",
    c = "slot-second",
    h = "slot-millisecond",
    u = "slot-microsecond",
    T = "slot-nanosecond",
    p = "slot-calendar",
    f = "slot-date-brand",
    y = "slot-year-month-brand",
    I = "slot-month-day-brand",
    S = "slot-cached-instant",
    g = "slot-time-zone",
    w = "slot-years",
    D = "slot-months",
    G = "slot-weeks",
    v = "slot-days",
    C = "slot-hours",
    O = "slot-minutes",
    b = "slot-seconds",
    E = "slot-milliseconds",
    M = "slot-microseconds",
    R = "slot-nanoseconds",
    F = "slot-calendar-identifier",
    Y = new WeakMap(),
    P = Symbol["for"]("@@Temporal__GetSlots");
   (r = globalThis)[P] || (r[P] = function(e){return Y.get(e);});
   var Z = globalThis[P], B = Symbol["for"]("@@Temporal__CreateSlots");
   (o = globalThis)[B] || (o[B] = function(e){Y.set(e, Object.create(null));});
   var N = globalThis[B];
   function HasSlot(e){
    if(! e || "object" != _typeof(e)) return ! 1;
    var r = Z(e);
    for
    (var
      _len = arguments.length,
      t = new Array(_len > 1 ? _len - 1 : 0),
      _key = 1;
     _key < _len;
     _key++)
     t[_key - 1] = arguments[_key];
    return ! ! r && t.every(function(e){return e in r;});
   }
   function GetSlot(e, t){
    var _Z, r = (_Z = Z(e)) === null || _Z === void 0 ? void 0 : _Z[t];
    if(void 0 === r) throw new TypeError("Missing internal slot ".concat(t));
    return r;
   }
   function SetSlot(e, t, r){
    var o = Z(e);
    if(void 0 === o)
     throw new TypeError("Missing slots for the given container");
    if(o[t]) throw new TypeError("".concat(t, " already has set"));
    o[t] = r;
   }
   var
    j =
      /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,
    $ =
      new
       RegExp
       ("(?:"
        +
         ["(?:".concat(j.source, ")(?:\\/(?:").concat(j.source, "))*"),
           "Etc/GMT(?:0|[-+]\\d{1,2})",
           "GMT[-+]?0",
           "EST5EDT",
           "CST6CDT",
           "MST7MDT",
           "PST8PDT",
           /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join
          ("|")
        + ")"),
    k = /(?:[+\u2212-]\d{6}|\d{4})/,
    U = /(?:0[1-9]|1[0-2])/,
    A = /(?:0[1-9]|[12]\d|3[01])/,
    L =
      new
       RegExp
       ("(".concat(k.source, ")(?:-(").concat(U.source, ")-(").concat
           (A.source, ")|(").concat
          (U.source, ")(").concat
         (A.source, "))")),
    x =
      /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,
    W =
      /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,
    q = new RegExp("([zZ])|".concat(W.source, "?")),
    H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g,
    V =
      new
       RegExp
       (["^".concat(L.source),
          "(?:(?:T|\\s+)".concat(x.source, "(?:").concat(q.source, ")?)?"),
          "(?:\\[!?(".concat($.source, ")\\])?"),
          "((?:".concat(H.source, ")*)$")].join
         (""),
        "i"),
    z =
      new
       RegExp
       (["^T?".concat(x.source),
          "(?:".concat(q.source, ")?"),
          "(?:\\[!?".concat($.source, "\\])?"),
          "((?:".concat(H.source, ")*)$")].join
         (""),
        "i"),
    _ =
      new
       RegExp
       ("^(".concat(k.source, ")-?(").concat(U.source, ")(?:\\[!?").concat
          ($.source, "\\])?((?:").concat
         (H.source, ")*)$")),
    J =
      new
       RegExp
       ("^(?:--)?(".concat(U.source, ")-?(").concat(A.source, ")(?:\\[!?").concat
          ($.source, "\\])?((?:").concat
         (H.source, ")*)$")),
    K = /(\d+)(?:[.,](\d{1,9}))?/,
    X =
      new
       RegExp
       ("(?:".concat(K.source, "H)?(?:").concat(K.source, "M)?(?:").concat
         (K.source, "S)?")),
    Q =
      new
       RegExp
       ("^([+\u2212-])?P".concat
          (/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source, "(?:T(?!$)").concat
         (X.source, ")?$"),
        "i"),
    ee = Array.prototype.includes,
    te = Array.prototype.push,
    re = globalThis.Intl.DateTimeFormat,
    oe = Math.min,
    ne = Math.max,
    ae = Math.abs,
    ie = Math.floor,
    se = Math.sign,
    le = Math.trunc,
    de = Number.isNaN,
    me = Number.isFinite,
    ce = Number,
    he = String,
    ue = Number.MAX_SAFE_INTEGER,
    Te = Object.create,
    pe = Object.getOwnPropertyDescriptor,
    fe = Reflect.apply,
    ye = Reflect.ownKeys,
    Ie = 0n,
    Se = 1n,
    ge = 60n,
    we = 24n,
    De = 1000n,
    Ge = 1000000n,
    ve = 1000000000n,
    Ce = BigInt(- 1),
    Oe = 3600n * ve,
    be = ge * ve,
    Ee = Oe * we,
    Me = BigInt(- 86400) * 100000000000000000n,
    Re = 86400n * 100000000000000000n,
    Fe = - 271821,
    Ye = 275760,
    Pe = BigInt(- 388152) * 10000000000000n,
    Ze = Ee * 3660n,
    Be = Ee * 366n,
    Ne = Ee * 14n,
    je =
      ["iso8601",
       "hebrew",
       "islamic",
       "islamic-umalqura",
       "islamic-tbla",
       "islamic-civil",
       "islamic-rgsa",
       "islamicc",
       "persian",
       "ethiopic",
       "ethioaa",
       "coptic",
       "chinese",
       "dangi",
       "roc",
       "indian",
       "buddhist",
       "japanese",
       "gregory"];
   function isZero(t){return t === Ie;}
   function GetMethod(e, t){var r = e[t]; if(void 0 !== r) return r;}
   function Call(e, t, r){
    var o = arguments.length > 2 ? r : [];
    return fe(e, t, o);
   }
   function IsObject(e){
    return "object" == _typeof(e) && null !== e || "function" == typeof e;
   }
   function ToNumber(e){
    if("bigint" == typeof e)
     throw new TypeError("Cannot convert BigInt to number");
    return ce(e);
   }
   function ToIntegerOrInfinity(e){
    var t = ToNumber(e);
    if(de(t) || 0 === t) return 0;
    if(! me(t)) return t;
    var r = ie(ae(t));
    return 0 === r ? 0 : se(t) * r;
   }
   function IsIntegralNumber(e){
    if("number" != typeof e || de(e) || ! me(e)) return ! 1;
    var t = ae(e);
    return ie(t) === t;
   }
   function ToString(e){
    if("symbol" == _typeof(e))
     throw new TypeError("Cannot convert a Symbol value to a String");
    return he(e);
   }
   function ToIntegerWithTruncation(e){
    var t = ToNumber(e);
    if(0 === t) return 0;
    if(de(t) || ! me(t)) throw new RangeError("invalid number value");
    var r = le(t);
    return 0 === r ? 0 : r;
   }
   function ToPositiveIntegerWithTruncation(e, t){
    var r = ToIntegerWithTruncation(e);
    if(r <= 0){
     if(void 0 !== t)
      throw new
             RangeError
             ("property '".concat(t, "' cannot be a a number less than one"));
     throw new
            RangeError
            ("Cannot convert a number less than one to a positive integer");
    }
    return r;
   }
   function ToIntegerIfIntegral(e){
    var t = ToNumber(e);
    if(! me(t)) throw new RangeError("infinity is out of range");
    if(! IsIntegralNumber(t))
     throw new RangeError("unsupported fractional value ".concat(e));
    return 0 === t ? 0 : t;
   }
   function divmod(t, r){return {quotient: t / r, remainder: t % r};}
   function isNegativeJSBI(t){return t < Ie;}
   function signJSBI(e){return isZero(e) ? 0 : isNegativeJSBI(e) ? - 1 : 1;}
   function abs(t){return t < Ie ? t * Ce : t;}
   var
    $e =
      new
       Map
       ([["year", ToIntegerWithTruncation],
         ["month", ToPositiveIntegerWithTruncation],
         ["monthCode", ToString],
         ["day", ToPositiveIntegerWithTruncation],
         ["hour", ToIntegerWithTruncation],
         ["minute", ToIntegerWithTruncation],
         ["second", ToIntegerWithTruncation],
         ["millisecond", ToIntegerWithTruncation],
         ["microsecond", ToIntegerWithTruncation],
         ["nanosecond", ToIntegerWithTruncation],
         ["years", ToIntegerIfIntegral],
         ["months", ToIntegerIfIntegral],
         ["weeks", ToIntegerIfIntegral],
         ["days", ToIntegerIfIntegral],
         ["hours", ToIntegerIfIntegral],
         ["minutes", ToIntegerIfIntegral],
         ["seconds", ToIntegerIfIntegral],
         ["milliseconds", ToIntegerIfIntegral],
         ["microseconds", ToIntegerIfIntegral],
         ["nanoseconds", ToIntegerIfIntegral],
         ["era", ToString],
         ["eraYear", ToIntegerOrInfinity],
         ["offset", ToString]]),
    ke =
      new
       Map
       ([["hour", 0],
         ["minute", 0],
         ["second", 0],
         ["millisecond", 0],
         ["microsecond", 0],
         ["nanosecond", 0]]),
    Ue =
      [["years", "year", "date"],
       ["months", "month", "date"],
       ["weeks", "week", "date"],
       ["days", "day", "date"],
       ["hours", "hour", "time"],
       ["minutes", "minute", "time"],
       ["seconds", "second", "time"],
       ["milliseconds", "millisecond", "time"],
       ["microseconds", "microsecond", "time"],
       ["nanoseconds", "nanosecond", "time"]],
    Ae = new Map(Ue.map(function(e){return [e[0], e[1]];})),
    Le =
      new
       Map
       (Ue.map
         (function(_ref){
           var _ref2 = _slicedToArray(_ref, 2), e = _ref2[0], t = _ref2[1];
           return [t, e];
          })),
    xe =
      Ue.map
       (function(_ref3){
         var _ref4 = _slicedToArray(_ref3, 2), e = _ref4[1];
         return e;
        }),
    We = Array.from(Ae.keys()).sort(),
    qe = new Map();
   function getIntlDateTimeFormatEnUsForTimeZone(e){
    var t = qe.get(e);
    return void 0 === t
           &&
            (t =
              new
               re
               ("en-us",
                {timeZone: he(e),
                 hour12: ! 1,
                 era: "short",
                 year: "numeric",
                 month: "numeric",
                 day: "numeric",
                 hour: "numeric",
                 minute: "numeric",
                 second: "numeric"}),
             qe.set(e, t)),
           t;
   }
   function ToObject(e){
    if(null == e) throw new TypeError("Expected object not ".concat(e));
    return Object(e);
   }
   function CopyDataProperties(e, t, r, o){
    if(null == t) return;
    var n = ye(t), _iterator3 = _createForOfIteratorHelper(n), _step3;
    try{
     var
      _loop =
        function(){
         var a = _step3.value;
         if
          (!
           r.some(function(e){return Object.is(e, a);})
           && Object.prototype.propertyIsEnumerable.call(t, a)){
          var _r3 = t[a];
          if(o && o.some(function(e){return Object.is(e, _r3);})) return 1;
          e[a] = _r3;
         }
        };
     for(_iterator3.s(); ! (_step3 = _iterator3.n()).done;)
      if(_loop()) continue;
    }
    catch(err){_iterator3.e(err);}
    finally{_iterator3.f();}
   }
   function IsTemporalInstant(e){return HasSlot(e, n) && ! HasSlot(e, g, p);}
   function IsTemporalTimeZone(e){return HasSlot(e, a);}
   function IsTemporalCalendar(e){return HasSlot(e, F);}
   function IsTemporalDuration(e){
    return HasSlot(e, w, D, v, C, O, b, E, M, R);
   }
   function IsTemporalDate(e){return HasSlot(e, f);}
   function IsTemporalTime(e){
    return HasSlot(e, d, m, c, h, u, T) && ! HasSlot(e, i, s, l);
   }
   function IsTemporalDateTime(e){
    return HasSlot(e, i, s, l, d, m, c, h, u, T);
   }
   function IsTemporalYearMonth(e){return HasSlot(e, y);}
   function IsTemporalMonthDay(e){return HasSlot(e, I);}
   function IsTemporalZonedDateTime(e){return HasSlot(e, n, g, p);}
   function RejectTemporalLikeObject(e){
    if(HasSlot(e, p) || HasSlot(e, g))
     throw new
            TypeError
            ("with() does not support a calendar or timeZone property");
    if(IsTemporalTime(e))
     throw new
            TypeError
            ("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
    if(void 0 !== e.calendar)
     throw new TypeError("with() does not support a calendar property");
    if(void 0 !== e.timeZone)
     throw new TypeError("with() does not support a timeZone property");
   }
   function ParseTemporalTimeZone(e){
    var
     _ParseTemporalTimeZon =
       function(e){
         if(new RegExp("^".concat($.source, "$"), "i").test(e))
          return {ianaName: e};
         try{
          var _t3 = ParseISODateTime(e);
          if(_t3.z || _t3.offset || _t3.ianaName) return _t3;
         }
         catch(_unused){}
         throw new RangeError("Invalid time zone: ".concat(e));
        }
        (e),
     t = _ParseTemporalTimeZon.ianaName,
     r = _ParseTemporalTimeZon.offset,
     o = _ParseTemporalTimeZon.z;
    if(t) return GetCanonicalTimeZoneIdentifier(t);
    if(o) return "UTC";
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r));
   }
   function MaybeFormatCalendarAnnotation(e, t){
    return "never" === t
            ? ""
            : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e), t);
   }
   function FormatCalendarAnnotation(e, t){
    if("never" === t) return "";
    if("auto" === t && "iso8601" === e) return "";
    return "[".concat("critical" === t ? "!" : "", "u-ca=").concat(e, "]");
   }
   function ParseISODateTime(e){
    var t = V.exec(e);
    if(! t) throw new RangeError("invalid ISO 8601 string: ".concat(e));
    var r = t[1];
    if("" === r[0] && (r = "-".concat(r.slice(1))), "-000000" === r)
     throw new RangeError("invalid ISO 8601 string: ".concat(e));
    var
     o = ToIntegerOrInfinity(r),
     n = ToIntegerOrInfinity(t[2] || t[4]),
     a = ToIntegerOrInfinity(t[3] || t[5]),
     i = ToIntegerOrInfinity(t[6]),
     s = void 0 !== t[6],
     l = ToIntegerOrInfinity(t[7] || t[10]),
     d = ToIntegerOrInfinity(t[8] || t[11]);
    60 === d && (d = 59);
    var
     m = (t[9] || t[12]) + "000000000",
     c = ToIntegerOrInfinity(m.slice(0, 3)),
     h = ToIntegerOrInfinity(m.slice(3, 6)),
     u = ToIntegerOrInfinity(m.slice(6, 9)),
     T,
     p = ! 1;
    if(t[13])
     T = void 0, p = ! 0;
    else if(t[14] && t[15]){
     var
      _e2 = "-" === t[14] || "" === t[14] ? "-" : "+",
      _r4 = t[15] || "00",
      _o = t[16] || "00",
      _n = t[17] || "00",
      _a = t[18] || "0";
     if(T = "".concat(_e2).concat(_r4, ":").concat(_o), + _a){
      for(; _a.endsWith("0");) _a = _a.slice(0, - 1);
      T += ":".concat(_n, ".").concat(_a);
     }
     else
      + _n && (T += ":".concat(_n));
     "-00:00" === T && (T = "+00:00");
    }
    var
     f = t[19],
     y = t[20],
     I,
     _iterator4 = _createForOfIteratorHelper(y.matchAll(H)),
     _step4;
    try{
     for(_iterator4.s(); ! (_step4 = _iterator4.n()).done;){
      var
       _step4$value = _slicedToArray(_step4.value, 4),
       _e3 = _step4$value[1],
       _t4 = _step4$value[2],
       _r5 = _step4$value[3];
      if("u-ca" === _t4)
       void 0 === I && (I = _r5);
      else if("!" === _e3)
       throw new
              RangeError
              ("Unrecognized annotation: !".concat(_t4, "=").concat(_r5));
     }
    }
    catch(err){_iterator4.e(err);}
    finally{_iterator4.f();}
    return RejectDateTime(o, n, a, i, l, d, c, h, u),
           {year: o,
            month: n,
            day: a,
            hasTime: s,
            hour: i,
            minute: l,
            second: d,
            millisecond: c,
            microsecond: h,
            nanosecond: u,
            ianaName: f,
            offset: T,
            z: p,
            calendar: I};
   }
   function ParseTemporalYearMonthString(e){
    var t = _.exec(e), r, o, n, a;
    if(t){
     var _a2 = t[1];
     if
      ("" === _a2[0] && (_a2 = "-".concat(_a2.slice(1))),
       "-000000" === _a2)
      throw new RangeError("invalid ISO 8601 string: ".concat(e));
     r = ToIntegerOrInfinity(_a2), o = ToIntegerOrInfinity(t[2]);
     var
      _i = t[3],
      _iterator5 = _createForOfIteratorHelper(_i.matchAll(H)),
      _step5;
     try{
      for(_iterator5.s(); ! (_step5 = _iterator5.n()).done;){
       var
        _step5$value = _slicedToArray(_step5.value, 4),
        _e4 = _step5$value[1],
        _t5 = _step5$value[2],
        _r6 = _step5$value[3];
       if("u-ca" === _t5)
        void 0 === n && (n = _r6);
       else if("!" === _e4)
        throw new
               RangeError
               ("Unrecognized annotation: !".concat(_t5, "=").concat(_r6));
      }
     }
     catch(err){_iterator5.e(err);}
     finally{_iterator5.f();}
     if(void 0 !== n && "iso8601" !== n)
      throw new
             RangeError
             ("YYYY-MM format is only valid with iso8601 calendar");
    }
    else{
     var _ParseISODateTime, _t6;
     if
      (_ParseISODateTime = ParseISODateTime(e),
       r = _ParseISODateTime.year,
       o = _ParseISODateTime.month,
       n = _ParseISODateTime.calendar,
       a = _ParseISODateTime.day,
       _t6 = _ParseISODateTime.z,
       _t6)
      throw new RangeError("Z designator not supported for PlainYearMonth");
    }
    return {year: r, month: o, calendar: n, referenceISODay: a};
   }
   function ParseTemporalMonthDayString(e){
    var t = J.exec(e), r, o, n, a;
    if(t){
     r = ToIntegerOrInfinity(t[1]), o = ToIntegerOrInfinity(t[2]);
     var
      _e5 = t[3],
      _iterator6 = _createForOfIteratorHelper(_e5.matchAll(H)),
      _step6;
     try{
      for(_iterator6.s(); ! (_step6 = _iterator6.n()).done;){
       var
        _step6$value = _slicedToArray(_step6.value, 4),
        _t7 = _step6$value[1],
        _r7 = _step6$value[2],
        _o2 = _step6$value[3];
       if("u-ca" === _r7)
        void 0 === n && (n = _o2);
       else if("!" === _t7)
        throw new
               RangeError
               ("Unrecognized annotation: !".concat(_r7, "=").concat(_o2));
      }
     }
     catch(err){_iterator6.e(err);}
     finally{_iterator6.f();}
     if(void 0 !== n && "iso8601" !== n)
      throw new RangeError("MM-DD format is only valid with iso8601 calendar");
    }
    else{
     var _ParseISODateTime2, _t8;
     if
      (_ParseISODateTime2 = ParseISODateTime(e),
       r = _ParseISODateTime2.month,
       o = _ParseISODateTime2.day,
       n = _ParseISODateTime2.calendar,
       a = _ParseISODateTime2.year,
       _t8 = _ParseISODateTime2.z,
       _t8)
      throw new RangeError("Z designator not supported for PlainMonthDay");
    }
    return {month: r, day: o, calendar: n, referenceISOYear: a};
   }
   function ParseTemporalInstant(e){
    var
     _ParseTemporalInstant =
       function(e){
         var t = ParseISODateTime(e);
         if(! t.z && ! t.offset)
          throw new RangeError("Temporal.Instant requires a time zone offset");
         return t;
        }
        (e),
     t = _ParseTemporalInstant.year,
     r = _ParseTemporalInstant.month,
     o = _ParseTemporalInstant.day,
     n = _ParseTemporalInstant.hour,
     a = _ParseTemporalInstant.minute,
     i = _ParseTemporalInstant.second,
     s = _ParseTemporalInstant.millisecond,
     l = _ParseTemporalInstant.microsecond,
     d = _ParseTemporalInstant.nanosecond,
     m = _ParseTemporalInstant.offset,
     c = _ParseTemporalInstant.z;
    if(! c && ! m)
     throw new RangeError("Temporal.Instant requires a time zone offset");
    var
     h = c ? 0 : ParseTimeZoneOffsetString(m),
     _BalanceISODateTime = BalanceISODateTime(t, r, o, n, a, i, s, l, d - h);
    t = _BalanceISODateTime.year;
    r = _BalanceISODateTime.month;
    o = _BalanceISODateTime.day;
    n = _BalanceISODateTime.hour;
    a = _BalanceISODateTime.minute;
    i = _BalanceISODateTime.second;
    s = _BalanceISODateTime.millisecond;
    l = _BalanceISODateTime.microsecond;
    d = _BalanceISODateTime.nanosecond;
    var u = GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d);
    if(null === u)
     throw new RangeError("DateTime outside of supported range");
    return u;
   }
   function RegulateISODate(e, t, r, o){
    var n = e, a = t, i = r;
    switch(o){
      case "reject":
       RejectISODate(n, a, i); break;
      case "constrain":
       var _ConstrainISODate = ConstrainISODate(n, a, i);
       n = _ConstrainISODate.year;
       a = _ConstrainISODate.month;
       i = _ConstrainISODate.day;
    }
    return {year: n, month: a, day: i};
   }
   function RegulateTime(e, t, r, o, n, a, i){
    var s = e, l = t, d = r, m = o, c = n, h = a;
    switch(i){
      case "reject":
       RejectTime(s, l, d, m, c, h); break;
      case "constrain":
       var
        _ConstrainTime =
          function(e, t, r, o, n, a){
            var
             i = ConstrainToRange(e, 0, 23),
             s = ConstrainToRange(t, 0, 59),
             l = ConstrainToRange(r, 0, 59),
             d = ConstrainToRange(o, 0, 999),
             m = ConstrainToRange(n, 0, 999),
             c = ConstrainToRange(a, 0, 999);
            return {hour: i,
                    minute: s,
                    second: l,
                    millisecond: d,
                    microsecond: m,
                    nanosecond: c};
           }
           (s, l, d, m, c, h);
       s = _ConstrainTime.hour;
       l = _ConstrainTime.minute;
       d = _ConstrainTime.second;
       m = _ConstrainTime.millisecond;
       c = _ConstrainTime.microsecond;
       h = _ConstrainTime.nanosecond;
    }
    return {hour: s,
            minute: l,
            second: d,
            millisecond: m,
            microsecond: c,
            nanosecond: h};
   }
   function ToTemporalDurationRecord(e){
    if(! IsObject(e))
     return function(e){
              var t = Q.exec(e);
              if(! t) throw new RangeError("invalid duration: ".concat(e));
              if(t.slice(2).every(function(e){return void 0 === e;}))
               throw new RangeError("invalid duration: ".concat(e));
              var
               r = "-" === t[1] || "" === t[1] ? - 1 : 1,
               o = void 0 === t[2] ? 0 : ToIntegerWithTruncation(t[2]) * r,
               n = void 0 === t[3] ? 0 : ToIntegerWithTruncation(t[3]) * r,
               a = void 0 === t[4] ? 0 : ToIntegerWithTruncation(t[4]) * r,
               i = void 0 === t[5] ? 0 : ToIntegerWithTruncation(t[5]) * r,
               s = void 0 === t[6] ? 0 : ToIntegerWithTruncation(t[6]) * r,
               l = t[7],
               d = t[8],
               m = t[9],
               c = t[10],
               h = t[11],
               u = 0,
               T = 0,
               p = 0;
              if(void 0 !== l){
               var _ref5, _ref6;
               if
                ((_ref5 =
                   (_ref6 = d !== null && d !== void 0 ? d : m) !== null
                    && _ref6 !== void 0
                    ? _ref6
                    : c)
                  !== null
                  && _ref5 !== void 0
                  ? _ref5
                  : h)
                throw new
                       RangeError
                       ("only the smallest unit can be fractional");
               p =
                3600 * ToIntegerOrInfinity((l + "000000000").slice(0, 9)) * r;
              }
              else if
               (u = void 0 === d ? 0 : ToIntegerWithTruncation(d) * r,
                void 0 !== m){
               if(c !== null && c !== void 0 ? c : h)
                throw new
                       RangeError
                       ("only the smallest unit can be fractional");
               p = 60 * ToIntegerOrInfinity((m + "000000000").slice(0, 9)) * r;
              }
              else
               T = void 0 === c ? 0 : ToIntegerWithTruncation(c) * r,
               void 0 !== h
               && (p = ToIntegerOrInfinity((h + "000000000").slice(0, 9)) * r);
              var f = p % 1e3, y = le(p / 1e3) % 1e3, I = le(p / 1e6) % 1e3;
              return T += le(p / 1e9) % 60,
                     u += le(p / 6e10),
                     RejectDuration(o, n, a, i, s, u, T, I, y, f),
                     {years: o,
                      months: n,
                      weeks: a,
                      days: i,
                      hours: s,
                      minutes: u,
                      seconds: T,
                      milliseconds: I,
                      microseconds: y,
                      nanoseconds: f};
             }
             (ToString(e));
    if(IsTemporalDuration(e))
     return {years: GetSlot(e, w),
             months: GetSlot(e, D),
             weeks: GetSlot(e, G),
             days: GetSlot(e, v),
             hours: GetSlot(e, C),
             minutes: GetSlot(e, O),
             seconds: GetSlot(e, b),
             milliseconds: GetSlot(e, E),
             microseconds: GetSlot(e, M),
             nanoseconds: GetSlot(e, R)};
    var
     t =
       {years: 0,
        months: 0,
        weeks: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0,
        microseconds: 0,
        nanoseconds: 0},
     r =
       function(e){
         if(! IsObject(e)) throw new TypeError("invalid duration-like");
         var
          t =
            {years: void 0,
             months: void 0,
             weeks: void 0,
             days: void 0,
             hours: void 0,
             minutes: void 0,
             seconds: void 0,
             milliseconds: void 0,
             microseconds: void 0,
             nanoseconds: void 0},
          r = ! 1,
          _iterator7 = _createForOfIteratorHelper(We),
          _step7;
         try{
          for(_iterator7.s(); ! (_step7 = _iterator7.n()).done;){
           var _o3 = _step7.value, _n2 = e[_o3];
           void 0 !== _n2 && (r = ! 0, t[_o3] = ToIntegerIfIntegral(_n2));
          }
         }
         catch(err){_iterator7.e(err);}
         finally{_iterator7.f();}
         if(! r) throw new TypeError("invalid duration-like");
         return t;
        }
        (e),
     _iterator8 = _createForOfIteratorHelper(We),
     _step8;
    try{
     for(_iterator8.s(); ! (_step8 = _iterator8.n()).done;){
      var _e6 = _step8.value, _o4 = r[_e6];
      void 0 !== _o4 && (t[_e6] = _o4);
     }
    }
    catch(err){_iterator8.e(err);}
    finally{_iterator8.f();}
    var
     o = t.years,
     n = t.months,
     a = t.weeks,
     i = t.days,
     s = t.hours,
     l = t.minutes,
     d = t.seconds,
     m = t.milliseconds,
     c = t.microseconds,
     h = t.nanoseconds;
    return RejectDuration(o, n, a, i, s, l, d, m, c, h),
           {years: o,
            months: n,
            weeks: a,
            days: i,
            hours: s,
            minutes: l,
            seconds: d,
            milliseconds: m,
            microseconds: c,
            nanoseconds: h};
   }
   function ToTemporalOverflow(e){
    return void 0 === e
            ? "constrain"
            : GetOption(e, "overflow", ["constrain", "reject"], "constrain");
   }
   function ToTemporalDisambiguation(e){
    return void 0 === e
            ? "compatible"
            : GetOption
              (e,
               "disambiguation",
               ["compatible", "earlier", "later", "reject"],
               "compatible");
   }
   function ToTemporalRoundingMode(e, t){
    return GetOption
            (e,
             "roundingMode",
             ["ceil",
              "floor",
              "expand",
              "trunc",
              "halfCeil",
              "halfFloor",
              "halfExpand",
              "halfTrunc",
              "halfEven"],
             t);
   }
   function ToTemporalOffset(e, t){
    return void 0 === e
            ? t
            : GetOption(e, "offset", ["prefer", "use", "ignore", "reject"], t);
   }
   function ToCalendarNameOption(e){
    return GetOption
            (e,
             "calendarName",
             ["auto", "always", "never", "critical"],
             "auto");
   }
   function ToTemporalRoundingIncrement(e){
    var t = e.roundingIncrement;
    if(void 0 === t) return 1;
    if(t = ToNumber(t), ! me(t))
     throw new RangeError("roundingIncrement must be finite");
    var r = le(t);
    if(r < 1 || r > 1e9)
     throw new
            RangeError
            ("roundingIncrement must be at least 1 and at most 1e9, not ".concat
              (t));
    return r;
   }
   function ValidateTemporalRoundingIncrement(e, t, r){
    var o = r ? t : t - 1;
    if(e > o)
     throw new
            RangeError
            ("roundingIncrement must be at least 1 and less than ".concat
               (o, ", not ").concat
              (e));
    if(t % e != 0)
     throw new
            RangeError
            ("Rounding increment must divide evenly into ".concat(t));
   }
   function ToFractionalSecondDigits(e){
    var t = e.fractionalSecondDigits;
    if(void 0 === t) return "auto";
    if("number" != typeof t){
     if("auto" !== ToString(t))
      throw new
             RangeError
             ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
               (t));
     return "auto";
    }
    var r = ie(t);
    if(! me(r) || r < 0 || r > 9)
     throw new
            RangeError
            ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
              (t));
    return r;
   }
   function ToSecondsStringPrecisionRecord(e, t){
    switch(e){
      case "minute":
       return {precision: "minute", unit: "minute", increment: 1};
      case "second":
       return {precision: 0, unit: "second", increment: 1};
      case "millisecond":
       return {precision: 3, unit: "millisecond", increment: 1};
      case "microsecond":
       return {precision: 6, unit: "microsecond", increment: 1};
      case "nanosecond":
       return {precision: 9, unit: "nanosecond", increment: 1};
    }
    switch(t){
      case "auto":
       return {precision: t, unit: "nanosecond", increment: 1};
      case 0:
       return {precision: t, unit: "second", increment: 1};
      case 1:
      case 2:
      case 3:
       return {precision: t,
               unit: "millisecond",
               increment: Math.pow(10, 3 - t)};
      case 4:
      case 5:
      case 6:
       return {precision: t,
               unit: "microsecond",
               increment: Math.pow(10, 6 - t)};
      case 7:
      case 8:
      case 9:
       return {precision: t,
               unit: "nanosecond",
               increment: Math.pow(10, 9 - t)};
      default:
       throw new
              RangeError
              ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
                (t));
    }
   }
   var He = Symbol("~required~");
   function GetTemporalUnit(e, t, r, o){
    var
     n =
       arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [],
     a = [];
    for(var _i2 = 0, _Ue = Ue; _i2 < _Ue.length; _i2++){
     var
      _Ue$_i = _slicedToArray(_Ue[_i2], 3),
      _e7 = _Ue$_i[1],
      _t9 = _Ue$_i[2];
     "datetime" !== r && r !== _t9 || a.push(_e7);
    }
    a.push.apply(a, _toConsumableArray(n));
    var i = o;
    i === He ? i = void 0 : void 0 !== i && a.push(i);
    var s = [].concat(a);
    for(var _i3 = 0, _a3 = a; _i3 < _a3.length; _i3++){
     var _e8 = _a3[_i3], _t10 = Le.get(_e8);
     void 0 !== _t10 && s.push(_t10);
    }
    var l = GetOption(e, t, s, i);
    if(void 0 === l && o === He)
     throw new RangeError("".concat(t, " is required"));
    return Ae.has(l) ? Ae.get(l) : l;
   }
   function ToRelativeTemporalObject(e){
    var t = e.relativeTo;
    if(void 0 === t) return t;
    var r, o, n, a, i, s, l, d, m, c, h, u, T = "option", p = ! 1;
    if(IsObject(t)){
     var _InterpretTemporalDat;
     if(IsTemporalZonedDateTime(t) || IsTemporalDate(t)) return t;
     if(IsTemporalDateTime(t)) return TemporalDateTimeToDate(t);
     c = GetTemporalCalendarSlotValueWithISODefault(t);
     var
      _e9 =
        CalendarFields
         (c,
          ["day",
           "hour",
           "microsecond",
           "millisecond",
           "minute",
           "month",
           "monthCode",
           "nanosecond",
           "second",
           "year"]);
     _e9.push("timeZone", "offset");
     var _p = PrepareTemporalFields(t, _e9, []), _f = Te(null);
     _f.overflow = "constrain",
     _InterpretTemporalDat = InterpretTemporalDateTimeFields(c, _p, _f),
     r = _InterpretTemporalDat.year,
     o = _InterpretTemporalDat.month,
     n = _InterpretTemporalDat.day,
     a = _InterpretTemporalDat.hour,
     i = _InterpretTemporalDat.minute,
     s = _InterpretTemporalDat.second,
     l = _InterpretTemporalDat.millisecond,
     d = _InterpretTemporalDat.microsecond,
     m = _InterpretTemporalDat.nanosecond,
     u = _p.offset,
     void 0 === u && (T = "wall"),
     h = _p.timeZone,
     void 0 !== h && (h = ToTemporalTimeZoneSlotValue(h));
    }
    else{
     var _ParseISODateTime3, _e10, _f2;
     if
      (_ParseISODateTime3 = ParseISODateTime(ToString(t)),
       r = _ParseISODateTime3.year,
       o = _ParseISODateTime3.month,
       n = _ParseISODateTime3.day,
       a = _ParseISODateTime3.hour,
       i = _ParseISODateTime3.minute,
       s = _ParseISODateTime3.second,
       l = _ParseISODateTime3.millisecond,
       d = _ParseISODateTime3.microsecond,
       m = _ParseISODateTime3.nanosecond,
       c = _ParseISODateTime3.calendar,
       _e10 = _ParseISODateTime3.ianaName,
       u = _ParseISODateTime3.offset,
       _f2 = _ParseISODateTime3.z,
       _e10)
      h = ToTemporalTimeZoneSlotValue(_e10),
      _f2 ? T = "exact" : u || (T = "wall"),
      p = ! 0;
     else if(_f2)
      throw new
             RangeError
             ("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
     if(c || (c = "iso8601"), ! IsBuiltinCalendar(c))
      throw new RangeError("invalid calendar identifier ".concat(c));
     c = ASCIILowercase(c);
    }
    if(void 0 === h) return CreateTemporalDate(r, o, n, c);
    return CreateTemporalZonedDateTime
            (InterpretISODateTimeOffset
              (r,
               o,
               n,
               a,
               i,
               s,
               l,
               d,
               m,
               T,
               "option" === T ? ParseTimeZoneOffsetString(u) : 0,
               h,
               "compatible",
               "reject",
               p),
             h,
             c);
   }
   function DefaultTemporalLargestUnit(e, t, r, o, n, a, i, s, l, d){
    for
    (var
      _i4 = 0,
      _arr =
        [["years", e],
         ["months", t],
         ["weeks", r],
         ["days", o],
         ["hours", n],
         ["minutes", a],
         ["seconds", i],
         ["milliseconds", s],
         ["microseconds", l],
         ["nanoseconds", d]];
     _i4 < _arr.length;
     _i4++){
     var
      _arr$_i = _slicedToArray(_arr[_i4], 2),
      _m = _arr$_i[0],
      _c = _arr$_i[1];
     if(0 !== _c) return Ae.get(_m);
    }
    return "nanosecond";
   }
   function LargerOfTwoTemporalUnits(e, t){
    return xe.indexOf(e) > xe.indexOf(t) ? t : e;
   }
   function PrepareTemporalFields(e, t, r){
    var
     _ref7 =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : {emptySourceErrorMessage: "no supported properties found"},
     o = _ref7.emptySourceErrorMessage,
     n = Te(null),
     a = ! 1;
    t.sort();
    var _iterator9 = _createForOfIteratorHelper(t), _step9;
    try{
     for(_iterator9.s(); ! (_step9 = _iterator9.n()).done;){
      var _o5 = _step9.value, _t11 = e[_o5];
      if(void 0 !== _t11)
       a = ! 0, $e.has(_o5) && (_t11 = $e.get(_o5)(_t11)), n[_o5] = _t11;
      else if("partial" !== r){
       if(ee.call(r, _o5))
        throw new
               TypeError
               ("required property '".concat(_o5, "' missing or undefined"));
       _t11 = ke.get(_o5), n[_o5] = _t11;
      }
     }
    }
    catch(err){_iterator9.e(err);}
    finally{_iterator9.f();}
    if("partial" === r && ! a) throw new TypeError(o);
    return n;
   }
   function ToTemporalTimeRecord(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "complete",
     r =
       ["hour",
        "microsecond",
        "millisecond",
        "minute",
        "nanosecond",
        "second"],
     o =
       PrepareTemporalFields
        (e, r, "partial", {emptySourceErrorMessage: "invalid time-like"}),
     n = {};
    for(var _i5 = 0, _r8 = r; _i5 < _r8.length; _i5++){
     var _e11 = _r8[_i5], _r9 = pe(o, _e11);
     void 0 !== _r9 ? n[_e11] = _r9.value : "complete" === t && (n[_e11] = 0);
    }
    return n;
   }
   function ToTemporalDate(e, t){
    var r = e;
    if(IsObject(r)){
     if(IsTemporalDate(r)) return r;
     if
      (IsTemporalZonedDateTime(r)
       &&
        (ToTemporalOverflow(t),
         r = GetPlainDateTimeFor(GetSlot(r, g), GetSlot(r, S), GetSlot(r, p))),
       IsTemporalDateTime(r))
      return ToTemporalOverflow(t),
             CreateTemporalDate
              (GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, p));
     var _e12 = GetTemporalCalendarSlotValueWithISODefault(r);
     return CalendarDateFromFields
             (_e12,
              PrepareTemporalFields
               (r,
                CalendarFields(_e12, ["day", "month", "monthCode", "year"]),
                []),
              t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalDateStr =
       function(e){return ParseISODateTime(e);}(ToString(r)),
     o = _ParseTemporalDateStr.year,
     n = _ParseTemporalDateStr.month,
     a = _ParseTemporalDateStr.day,
     d = _ParseTemporalDateStr.calendar,
     m = _ParseTemporalDateStr.z;
    if(m) throw new RangeError("Z designator not supported for PlainDate");
    if(d || (d = "iso8601"), ! IsBuiltinCalendar(d))
     throw new RangeError("invalid calendar identifier ".concat(d));
    return d = ASCIILowercase(d), CreateTemporalDate(o, n, a, d);
   }
   function InterpretTemporalDateTimeFields(e, t, r){
    var
     _RegulateTime,
     _ToTemporalTimeRecord = ToTemporalTimeRecord(t),
     o = _ToTemporalTimeRecord.hour,
     n = _ToTemporalTimeRecord.minute,
     a = _ToTemporalTimeRecord.second,
     d = _ToTemporalTimeRecord.millisecond,
     m = _ToTemporalTimeRecord.microsecond,
     c = _ToTemporalTimeRecord.nanosecond,
     h = ToTemporalOverflow(r),
     u = CalendarDateFromFields(e, t, r),
     T = GetSlot(u, i),
     p = GetSlot(u, s),
     f = GetSlot(u, l);
    return _RegulateTime = RegulateTime(o, n, a, d, m, c, h),
           o = _RegulateTime.hour,
           n = _RegulateTime.minute,
           a = _RegulateTime.second,
           d = _RegulateTime.millisecond,
           m = _RegulateTime.microsecond,
           c = _RegulateTime.nanosecond,
           {year: T,
            month: p,
            day: f,
            hour: o,
            minute: n,
            second: a,
            millisecond: d,
            microsecond: m,
            nanosecond: c};
   }
   function ToTemporalDateTime(e, t){
    var r, o, n, a, d, m, c, h, u, T;
    if(IsObject(e)){
     if(IsTemporalDateTime(e)) return e;
     if(IsTemporalZonedDateTime(e))
      return ToTemporalOverflow(t),
             GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
     if(IsTemporalDate(e))
      return ToTemporalOverflow(t),
             CreateTemporalDateTime
              (GetSlot(e, i),
               GetSlot(e, s),
               GetSlot(e, l),
               0,
               0,
               0,
               0,
               0,
               0,
               GetSlot(e, p));
     T = GetTemporalCalendarSlotValueWithISODefault(e);
     var
      _f3 =
        PrepareTemporalFields
         (e,
          CalendarFields
           (T,
            ["day",
             "hour",
             "microsecond",
             "millisecond",
             "minute",
             "month",
             "monthCode",
             "nanosecond",
             "second",
             "year"]),
          []),
      _InterpretTemporalDat2 = InterpretTemporalDateTimeFields(T, _f3, t);
     r = _InterpretTemporalDat2.year;
     o = _InterpretTemporalDat2.month;
     n = _InterpretTemporalDat2.day;
     a = _InterpretTemporalDat2.hour;
     d = _InterpretTemporalDat2.minute;
     m = _InterpretTemporalDat2.second;
     c = _InterpretTemporalDat2.millisecond;
     h = _InterpretTemporalDat2.microsecond;
     u = _InterpretTemporalDat2.nanosecond;
    }
    else{
     var _ParseTemporalDateTim, _i6;
     if
      (ToTemporalOverflow(t),
       _ParseTemporalDateTim =
        function(e){return ParseISODateTime(e);}(ToString(e)),
       r = _ParseTemporalDateTim.year,
       o = _ParseTemporalDateTim.month,
       n = _ParseTemporalDateTim.day,
       a = _ParseTemporalDateTim.hour,
       d = _ParseTemporalDateTim.minute,
       m = _ParseTemporalDateTim.second,
       c = _ParseTemporalDateTim.millisecond,
       h = _ParseTemporalDateTim.microsecond,
       u = _ParseTemporalDateTim.nanosecond,
       T = _ParseTemporalDateTim.calendar,
       _i6 = _ParseTemporalDateTim.z,
       _i6)
      throw new RangeError("Z designator not supported for PlainDateTime");
     if
      (RejectDateTime(r, o, n, a, d, m, c, h, u),
       T || (T = "iso8601"),
       !
       IsBuiltinCalendar(T))
      throw new RangeError("invalid calendar identifier ".concat(T));
     T = ASCIILowercase(T);
    }
    return CreateTemporalDateTime(r, o, n, a, d, m, c, h, u, T);
   }
   function ToTemporalDuration(e){
    if(IsTemporalDuration(e)) return e;
    var
     _ToTemporalDurationRe = ToTemporalDurationRecord(e),
     t = _ToTemporalDurationRe.years,
     r = _ToTemporalDurationRe.months,
     o = _ToTemporalDurationRe.weeks,
     n = _ToTemporalDurationRe.days,
     a = _ToTemporalDurationRe.hours,
     i = _ToTemporalDurationRe.minutes,
     s = _ToTemporalDurationRe.seconds,
     l = _ToTemporalDurationRe.milliseconds,
     d = _ToTemporalDurationRe.microseconds,
     m = _ToTemporalDurationRe.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (t, r, o, n, a, i, s, l, d, m);
   }
   function ToTemporalInstant(e){
    if(IsTemporalInstant(e)) return e;
    if(IsTemporalZonedDateTime(e))
     return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
    var t = ParseTemporalInstant(ToString(e));
    return new (GetIntrinsic("%Temporal.Instant%"))(t);
   }
   function ToTemporalMonthDay(e, t){
    var r = e;
    if(IsObject(r)){
     if(IsTemporalMonthDay(r)) return r;
     var _e13, _o6;
     if(HasSlot(r, p))
      _e13 = GetSlot(r, p), _o6 = ! 1;
     else{
      var _t12 = r.calendar;
      _o6 = void 0 === _t12,
      void 0 === _t12 && (_t12 = "iso8601"),
      _e13 = ToTemporalCalendarSlotValue(_t12);
     }
     var
      _n3 =
        PrepareTemporalFields
         (r, CalendarFields(_e13, ["day", "month", "monthCode", "year"]), []);
     return _o6 && void 0 !== _n3.month && void 0 === _n3.monthCode
            && void 0 === _n3.year
            && (_n3.year = 1972),
            CalendarMonthDayFromFields(_e13, _n3, t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalMonthDa = ParseTemporalMonthDayString(ToString(r)),
     o = _ParseTemporalMonthDa.month,
     n = _ParseTemporalMonthDa.day,
     a = _ParseTemporalMonthDa.referenceISOYear,
     i = _ParseTemporalMonthDa.calendar;
    if(void 0 === i && (i = "iso8601"), ! IsBuiltinCalendar(i))
     throw new RangeError("invalid calendar identifier ".concat(i));
    if(i = ASCIILowercase(i), void 0 === a)
     return RejectISODate(1972, o, n), CreateTemporalMonthDay(o, n, i);
    return CalendarMonthDayFromFields(i, CreateTemporalMonthDay(o, n, i, a));
   }
   function ToTemporalTime(e){
    var
     _ParseTemporalTimeStr,
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "constrain",
     r,
     o,
     n,
     a,
     i,
     s,
     l = e;
    if(IsObject(l)){
     var _ToTemporalTimeRecord2, _RegulateTime2;
     if(IsTemporalTime(l)) return l;
     if
      (IsTemporalZonedDateTime(l)
       &&
        (l = GetPlainDateTimeFor(GetSlot(l, g), GetSlot(l, S), GetSlot(l, p))),
       IsTemporalDateTime(l))
      return new
              (GetIntrinsic("%Temporal.PlainTime%"))
              (GetSlot(l, d),
               GetSlot(l, m),
               GetSlot(l, c),
               GetSlot(l, h),
               GetSlot(l, u),
               GetSlot(l, T));
     _ToTemporalTimeRecord2 = ToTemporalTimeRecord(l),
     r = _ToTemporalTimeRecord2.hour,
     o = _ToTemporalTimeRecord2.minute,
     n = _ToTemporalTimeRecord2.second,
     a = _ToTemporalTimeRecord2.millisecond,
     i = _ToTemporalTimeRecord2.microsecond,
     s = _ToTemporalTimeRecord2.nanosecond,
     _RegulateTime2 = RegulateTime(r, o, n, a, i, s, t),
     r = _RegulateTime2.hour,
     o = _RegulateTime2.minute,
     n = _RegulateTime2.second,
     a = _RegulateTime2.millisecond,
     i = _RegulateTime2.microsecond,
     s = _RegulateTime2.nanosecond;
    }
    else
     _ParseTemporalTimeStr =
      function(e){
        var t = z.exec(e), r, o, n, a, i, s, l;
        if(t){
         r = ToIntegerOrInfinity(t[1]),
         o = ToIntegerOrInfinity(t[2] || t[5]),
         n = ToIntegerOrInfinity(t[3] || t[6]),
         60 === n && (n = 59);
         var _e14 = (t[4] || t[7]) + "000000000";
         a = ToIntegerOrInfinity(_e14.slice(0, 3)),
         i = ToIntegerOrInfinity(_e14.slice(3, 6)),
         s = ToIntegerOrInfinity(_e14.slice(6, 9)),
         l = t[14];
         var _iterator10 = _createForOfIteratorHelper(l.matchAll(H)), _step10;
         try{
          for(_iterator10.s(); ! (_step10 = _iterator10.n()).done;){
           var
            _step10$value = _slicedToArray(_step10.value, 4),
            _e15 = _step10$value[1],
            _t13 = _step10$value[2],
            _r10 = _step10$value[3];
           if("u-ca" !== _t13 && "!" === _e15)
            throw new
                   RangeError
                   ("Unrecognized annotation: !".concat(_t13, "=").concat(_r10));
          }
         }
         catch(err){_iterator10.e(err);}
         finally{_iterator10.f();}
         if(t[8])
          throw new RangeError("Z designator not supported for PlainTime");
        }
        else{
         var _ParseISODateTime4, _t14, _l;
         if
          (_ParseISODateTime4 = ParseISODateTime(e),
           _l = _ParseISODateTime4.hasTime,
           r = _ParseISODateTime4.hour,
           o = _ParseISODateTime4.minute,
           n = _ParseISODateTime4.second,
           a = _ParseISODateTime4.millisecond,
           i = _ParseISODateTime4.microsecond,
           s = _ParseISODateTime4.nanosecond,
           _t14 = _ParseISODateTime4.z,
           !
           _l)
          throw new RangeError("time is missing in string: ".concat(e));
         if(_t14)
          throw new RangeError("Z designator not supported for PlainTime");
        }
        if(/[tT ][0-9][0-9]/.test(e))
         return {hour: r,
                 minute: o,
                 second: n,
                 millisecond: a,
                 microsecond: i,
                 nanosecond: s};
        try{
         var
          _ParseTemporalMonthDa2 = ParseTemporalMonthDayString(e),
          _t15 = _ParseTemporalMonthDa2.month,
          _r11 = _ParseTemporalMonthDa2.day;
         RejectISODate(1972, _t15, _r11);
        }
        catch(_unused2){
         try{
          var
           _ParseTemporalYearMon = ParseTemporalYearMonthString(e),
           _t16 = _ParseTemporalYearMon.year,
           _r12 = _ParseTemporalYearMon.month;
          RejectISODate(_t16, _r12, 1);
         }
         catch(_unused3){
          return {hour: r,
                  minute: o,
                  second: n,
                  millisecond: a,
                  microsecond: i,
                  nanosecond: s};
         }
        }
        throw new
               RangeError
               ("invalid ISO 8601 time-only string ".concat
                 (e, "; may need a T prefix"));
       }
       (ToString(l)),
     r = _ParseTemporalTimeStr.hour,
     o = _ParseTemporalTimeStr.minute,
     n = _ParseTemporalTimeStr.second,
     a = _ParseTemporalTimeStr.millisecond,
     i = _ParseTemporalTimeStr.microsecond,
     s = _ParseTemporalTimeStr.nanosecond,
     RejectTime(r, o, n, a, i, s);
    return new (GetIntrinsic("%Temporal.PlainTime%"))(r, o, n, a, i, s);
   }
   function ToTemporalYearMonth(e, t){
    if(IsObject(e)){
     if(IsTemporalYearMonth(e)) return e;
     var _r13 = GetTemporalCalendarSlotValueWithISODefault(e);
     return CalendarYearMonthFromFields
             (_r13,
              PrepareTemporalFields
               (e, CalendarFields(_r13, ["month", "monthCode", "year"]), []),
              t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalYearMon2 = ParseTemporalYearMonthString(ToString(e)),
     r = _ParseTemporalYearMon2.year,
     o = _ParseTemporalYearMon2.month,
     n = _ParseTemporalYearMon2.referenceISODay,
     a = _ParseTemporalYearMon2.calendar;
    if(void 0 === a && (a = "iso8601"), ! IsBuiltinCalendar(a))
     throw new RangeError("invalid calendar identifier ".concat(a));
    if(a = ASCIILowercase(a), void 0 === n)
     return RejectISODate(r, o, 1), CreateTemporalYearMonth(r, o, a);
    return CalendarYearMonthFromFields(a, CreateTemporalYearMonth(r, o, a, n));
   }
   function InterpretISODateTimeOffset
   (t, r, o, i, s, l, d, m, c, h, u, T, p, f, y){
    var
     I =
       new
        (GetIntrinsic("%Temporal.PlainDateTime%"))
        (t, r, o, i, s, l, d, m, c);
    if("wall" === h || "ignore" === f)
     return GetSlot(GetInstantFor(T, I, p), n);
    if("exact" === h || "use" === f){
     var _n4 = GetUTCEpochNanoseconds(t, r, o, i, s, l, d, m, c);
     if(null === _n4)
      throw new RangeError("ZonedDateTime outside of supported range");
     return _n4 - BigInt(u);
    }
    var
     S = GetPossibleInstantsFor(T, I),
     _iterator11 = _createForOfIteratorHelper(S),
     _step11;
    try{
     for(_iterator11.s(); ! (_step11 = _iterator11.n()).done;){
      var
       _t18 = _step11.value,
       _r14 = GetOffsetNanosecondsFor(T, _t18),
       _o7 = Number(RoundNumberToIncrement(BigInt(_r14), be, "halfExpand"));
      if(_r14 === u || y && _o7 === u) return GetSlot(_t18, n);
     }
    }
    catch(err){_iterator11.e(err);}
    finally{_iterator11.f();}
    if("reject" === f){
     var
      _e16 = FormatTimeZoneOffsetString(u),
      _t17 = IsTemporalTimeZone(T) ? GetSlot(T, a) : "time zone";
     throw new
            RangeError
            ("Offset ".concat(_e16, " is invalid for ").concat
               (I.toString(), " in ").concat
              (_t17));
    }
    return GetSlot(DisambiguatePossibleInstants(S, T, I, p), n);
   }
   function ToTemporalZonedDateTime(e, t){
    var r, o, n, a, i, s, l, d, m, c, h, u, T, p, f = ! 1, y = "option";
    if(IsObject(e)){
     var _InterpretTemporalDat3;
     if(IsTemporalZonedDateTime(e)) return e;
     u = GetTemporalCalendarSlotValueWithISODefault(e);
     var
      _f4 =
        CalendarFields
         (u,
          ["day",
           "hour",
           "microsecond",
           "millisecond",
           "minute",
           "month",
           "monthCode",
           "nanosecond",
           "second",
           "year"]);
     _f4.push("timeZone", "offset");
     var _I = PrepareTemporalFields(e, _f4, ["timeZone"]);
     c = ToTemporalTimeZoneSlotValue(_I.timeZone),
     h = _I.offset,
     void 0 === h && (y = "wall"),
     T = ToTemporalDisambiguation(t),
     p = ToTemporalOffset(t, "reject"),
     _InterpretTemporalDat3 = InterpretTemporalDateTimeFields(u, _I, t),
     r = _InterpretTemporalDat3.year,
     o = _InterpretTemporalDat3.month,
     n = _InterpretTemporalDat3.day,
     a = _InterpretTemporalDat3.hour,
     i = _InterpretTemporalDat3.minute,
     s = _InterpretTemporalDat3.second,
     l = _InterpretTemporalDat3.millisecond,
     d = _InterpretTemporalDat3.microsecond,
     m = _InterpretTemporalDat3.nanosecond;
    }
    else{
     var _ParseTemporalZonedDa, _I2, _S;
     if
      (_ParseTemporalZonedDa =
        function(e){
          var t = ParseISODateTime(e);
          if(! t.ianaName)
           throw new
                  RangeError
                  ("Temporal.ZonedDateTime requires a time zone ID in brackets");
          return t;
         }
         (ToString(e)),
       r = _ParseTemporalZonedDa.year,
       o = _ParseTemporalZonedDa.month,
       n = _ParseTemporalZonedDa.day,
       a = _ParseTemporalZonedDa.hour,
       i = _ParseTemporalZonedDa.minute,
       s = _ParseTemporalZonedDa.second,
       l = _ParseTemporalZonedDa.millisecond,
       d = _ParseTemporalZonedDa.microsecond,
       m = _ParseTemporalZonedDa.nanosecond,
       _I2 = _ParseTemporalZonedDa.ianaName,
       h = _ParseTemporalZonedDa.offset,
       _S = _ParseTemporalZonedDa.z,
       u = _ParseTemporalZonedDa.calendar,
       c = ToTemporalTimeZoneSlotValue(_I2),
       _S ? y = "exact" : h || (y = "wall"),
       u || (u = "iso8601"),
       !
       IsBuiltinCalendar(u))
      throw new RangeError("invalid calendar identifier ".concat(u));
     u = ASCIILowercase(u),
     f = ! 0,
     T = ToTemporalDisambiguation(t),
     p = ToTemporalOffset(t, "reject"),
     ToTemporalOverflow(t);
    }
    var I = 0;
    "option" === y && (I = ParseTimeZoneOffsetString(h));
    return CreateTemporalZonedDateTime
            (InterpretISODateTimeOffset
              (r, o, n, a, i, s, l, d, m, y, I, c, T, p, f),
             c,
             u);
   }
   function CreateTemporalDateSlots(e, t, r, o, n){
    RejectISODate(t, r, o),
    RejectDateRange(t, r, o),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, o),
    SetSlot(e, p, n),
    SetSlot(e, f, ! 0);
   }
   function CreateTemporalDate(e, t, r){
    var
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : "iso8601",
     n = GetIntrinsic("%Temporal.PlainDate%"),
     a = Te(n.prototype);
    return CreateTemporalDateSlots(a, e, t, r, o), a;
   }
   function CreateTemporalDateTimeSlots(e, t, r, o, n, a, f, y, I, S, g){
    RejectDateTime(t, r, o, n, a, f, y, I, S),
    RejectDateTimeRange(t, r, o, n, a, f, y, I, S),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, o),
    SetSlot(e, d, n),
    SetSlot(e, m, a),
    SetSlot(e, c, f),
    SetSlot(e, h, y),
    SetSlot(e, u, I),
    SetSlot(e, T, S),
    SetSlot(e, p, g);
   }
   function CreateTemporalDateTime(e, t, r, o, n, a, i, s, l){
    var
     d =
       arguments.length > 9 && arguments[9] !== undefined
        ? arguments[9]
        : "iso8601",
     m = GetIntrinsic("%Temporal.PlainDateTime%"),
     c = Te(m.prototype);
    return CreateTemporalDateTimeSlots(c, e, t, r, o, n, a, i, s, l, d), c;
   }
   function CreateTemporalMonthDaySlots(e, t, r, o, n){
    RejectISODate(n, t, r),
    RejectDateRange(n, t, r),
    N(e),
    SetSlot(e, s, t),
    SetSlot(e, l, r),
    SetSlot(e, i, n),
    SetSlot(e, p, o),
    SetSlot(e, I, ! 0);
   }
   function CreateTemporalMonthDay(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : 1972,
     n = GetIntrinsic("%Temporal.PlainMonthDay%"),
     a = Te(n.prototype);
    return CreateTemporalMonthDaySlots(a, e, t, r, o), a;
   }
   function CreateTemporalYearMonthSlots(e, t, r, o, n){
    RejectISODate(t, r, n),
    function(e, t){
      RejectToRange(e, Fe, Ye),
      e === Fe ? RejectToRange(t, 4, 12) : e === Ye && RejectToRange(t, 1, 9);
     }
     (t, r),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, n),
    SetSlot(e, p, o),
    SetSlot(e, y, ! 0);
   }
   function CreateTemporalYearMonth(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1,
     n = GetIntrinsic("%Temporal.PlainYearMonth%"),
     a = Te(n.prototype);
    return CreateTemporalYearMonthSlots(a, e, t, r, o), a;
   }
   function CreateTemporalZonedDateTimeSlots(e, t, r, o){
    ValidateEpochNanoseconds(t),
    N(e),
    SetSlot(e, n, t),
    SetSlot(e, g, r),
    SetSlot(e, p, o);
    var a = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
    SetSlot(e, S, a);
   }
   function CreateTemporalZonedDateTime(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o = GetIntrinsic("%Temporal.ZonedDateTime%"),
     n = Te(o.prototype);
    return CreateTemporalZonedDateTimeSlots(n, e, t, r), n;
   }
   function CalendarFields(e, t){
    if("string" == typeof e){
     var _r15 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.fields%"), _r15, [t]);
    }
    var
     r = Call(GetMethod(e, "fields"), e, [t]),
     o = [],
     _iterator12 = _createForOfIteratorHelper(r),
     _step12;
    try{
     for(_iterator12.s(); ! (_step12 = _iterator12.n()).done;){
      var _e17 = _step12.value;
      if("string" != typeof _e17)
       throw new TypeError("bad return from calendar.fields()");
      te.call(o, _e17);
     }
    }
    catch(err){_iterator12.e(err);}
    finally{_iterator12.f();}
    return o;
   }
   function CalendarMergeFields(e, t, r){
    if("string" == typeof e){
     var _o8 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"),
              _o8,
              [t, r]);
    }
    var o = Call(GetMethod(e, "mergeFields"), e, [t, r]);
    if(! IsObject(o))
     throw new TypeError("bad return from calendar.mergeFields()");
    return o;
   }
   function CalendarDateAdd(e, t, r, o, n){
    var a = n;
    if("string" == typeof e){
     var _n5 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"),
              _n5,
              [t, r, o]);
    }
    void 0 === a && (a = GetMethod(e, "dateAdd"));
    var i = fe(a, e, [t, r, o]);
    if(! IsTemporalDate(i)) throw new TypeError("invalid result");
    return i;
   }
   function CalendarDateUntil(e, t, r, o, n){
    var a = n;
    if("string" == typeof e){
     var _n6 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"),
              _n6,
              [t, r, o]);
    }
    void 0 === a && (a = GetMethod(e, "dateUntil"));
    var i = fe(a, e, [t, r, o]);
    if(! IsTemporalDuration(i)) throw new TypeError("invalid result");
    return i;
   }
   function CalendarYear(e, t){
    if("string" == typeof e){
     var _r16 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.year%"), _r16, [t]);
    }
    var r = Call(GetMethod(e, "year"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar year result must be an integer");
    if(! IsIntegralNumber(r))
     throw new RangeError("calendar year result must be an integer");
    return r;
   }
   function CalendarMonth(e, t){
    if("string" == typeof e){
     var _r17 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.month%"), _r17, [t]);
    }
    var r = Call(GetMethod(e, "month"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar month result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new RangeError("calendar month result must be a positive integer");
    return r;
   }
   function CalendarMonthCode(e, t){
    if("string" == typeof e){
     var _r18 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"),
              _r18,
              [t]);
    }
    var r = Call(GetMethod(e, "monthCode"), e, [t]);
    if("string" != typeof r)
     throw new TypeError("calendar monthCode result must be a string");
    return r;
   }
   function CalendarDay(e, t){
    if("string" == typeof e){
     var _r19 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), _r19, [t]);
    }
    var r = Call(GetMethod(e, "day"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar day result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new RangeError("calendar day result must be a positive integer");
    return r;
   }
   function CalendarEra(e, t){
    if("string" == typeof e){
     var _r20 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), _r20, [t]);
    }
    var r = Call(GetMethod(e, "era"), e, [t]);
    if(void 0 === r) return r;
    if("string" != typeof r)
     throw new TypeError("calendar era result must be a string or undefined");
    return r;
   }
   function CalendarEraYear(e, t){
    if("string" == typeof e){
     var _r21 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"),
              _r21,
              [t]);
    }
    var r = Call(GetMethod(e, "eraYear"), e, [t]);
    if(void 0 === r) return r;
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar eraYear result must be an integer or undefined");
    if(! IsIntegralNumber(r))
     throw new
            RangeError
            ("calendar eraYear result must be an integer or undefined");
    return r;
   }
   function CalendarDayOfWeek(e, t){
    if("string" == typeof e){
     var _r22 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"),
              _r22,
              [t]);
    }
    var r = Call(GetMethod(e, "dayOfWeek"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar dayOfWeek result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar dayOfWeek result must be a positive integer");
    return r;
   }
   function CalendarDayOfYear(e, t){
    if("string" == typeof e){
     var _r23 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"),
              _r23,
              [t]);
    }
    var r = Call(GetMethod(e, "dayOfYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar dayOfYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar dayOfYear result must be a positive integer");
    return r;
   }
   function CalendarWeekOfYear(e, t){
    if("string" == typeof e){
     var _r24 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"),
              _r24,
              [t]);
    }
    var r = Call(GetMethod(e, "weekOfYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar weekOfYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar weekOfYear result must be a positive integer");
    return r;
   }
   function CalendarYearOfWeek(e, t){
    if("string" == typeof e){
     var _r25 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"),
              _r25,
              [t]);
    }
    var r = Call(GetMethod(e, "yearOfWeek"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar yearOfWeek result must be an integer");
    if(! IsIntegralNumber(r))
     throw new RangeError("calendar yearOfWeek result must be an integer");
    return r;
   }
   function CalendarDaysInWeek(e, t){
    if("string" == typeof e){
     var _r26 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"),
              _r26,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInWeek"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInWeek result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInWeek result must be a positive integer");
    return r;
   }
   function CalendarDaysInMonth(e, t){
    if("string" == typeof e){
     var _r27 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"),
              _r27,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInMonth"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInMonth result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInMonth result must be a positive integer");
    return r;
   }
   function CalendarDaysInYear(e, t){
    if("string" == typeof e){
     var _r28 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"),
              _r28,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInYear result must be a positive integer");
    return r;
   }
   function CalendarMonthsInYear(e, t){
    if("string" == typeof e){
     var _r29 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"),
              _r29,
              [t]);
    }
    var r = Call(GetMethod(e, "monthsInYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar monthsInYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar monthsInYear result must be a positive integer");
    return r;
   }
   function CalendarInLeapYear(e, t){
    if("string" == typeof e){
     var _r30 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"),
              _r30,
              [t]);
    }
    var r = Call(GetMethod(e, "inLeapYear"), e, [t]);
    if("boolean" != typeof r)
     throw new TypeError("calendar inLeapYear result must be a boolean");
    return r;
   }
   function ToTemporalCalendarSlotValue(e){
    if(IsObject(e)){
     if(HasSlot(e, p)) return GetSlot(e, p);
     if
      (!
       function(e){
         return !
                !
                IsTemporalCalendar(e)
                ||
                 "dateAdd" in e && "dateFromFields" in e && "dateUntil" in e
                 && "day" in e
                 && "dayOfWeek" in e
                 && "dayOfYear" in e
                 && "daysInMonth" in e
                 && "daysInWeek" in e
                 && "daysInYear" in e
                 && "fields" in e
                 && "id" in e
                 && "inLeapYear" in e
                 && "mergeFields" in e
                 && "month" in e
                 && "monthCode" in e
                 && "monthDayFromFields" in e
                 && "monthsInYear" in e
                 && "weekOfYear" in e
                 && "year" in e
                 && "yearMonthFromFields" in e
                 && "yearOfWeek" in e;
        }
        (e))
      throw new
             TypeError
             ("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
     return e;
    }
    var t = ToString(e);
    if(IsBuiltinCalendar(t)) return ASCIILowercase(t);
    var r;
    try{
     var _ParseISODateTime5 = ParseISODateTime(t);
     r = _ParseISODateTime5.calendar;
    }
    catch(_unused4){
     try{
      var _ParseTemporalYearMon3 = ParseTemporalYearMonthString(t);
      r = _ParseTemporalYearMon3.calendar;
     }
     catch(_unused5){
      var _ParseTemporalMonthDa3 = ParseTemporalMonthDayString(t);
      r = _ParseTemporalMonthDa3.calendar;
     }
    }
    if(r || (r = "iso8601"), ! IsBuiltinCalendar(r))
     throw new RangeError("invalid calendar identifier ".concat(r));
    return ASCIILowercase(r);
   }
   function GetTemporalCalendarSlotValueWithISODefault(e){
    if(HasSlot(e, p)) return GetSlot(e, p);
    var t = e.calendar;
    return void 0 === t ? "iso8601" : ToTemporalCalendarSlotValue(t);
   }
   function ToTemporalCalendarIdentifier(e){
    if("string" == typeof e) return e;
    var t = e.id;
    if("string" != typeof t)
     throw new TypeError("calendar.id should be a string");
    return t;
   }
   function ToTemporalCalendarObject(e){
    if(IsObject(e)) return e;
    return new (GetIntrinsic("%Temporal.Calendar%"))(e);
   }
   function CalendarEquals(e, t){
    if(e === t) return ! 0;
    return ToTemporalCalendarIdentifier(e) === ToTemporalCalendarIdentifier(t);
   }
   function ThrowIfCalendarsNotEqual(e, t, r){
    if(e === t) return;
    var
     o = ToTemporalCalendarIdentifier(e),
     n = ToTemporalCalendarIdentifier(t);
    if(o !== n)
     throw new
            RangeError
            ("cannot ".concat(r, " of ").concat(o, " and ").concat
              (n, " calendars"));
   }
   function ConsolidateCalendars(e, t){
    if(e === t) return t;
    var
     r = ToTemporalCalendarIdentifier(e),
     o = ToTemporalCalendarIdentifier(t);
    if(r === o || "iso8601" === r) return t;
    if("iso8601" === o) return e;
    throw new RangeError("irreconcilable calendars");
   }
   function CalendarDateFromFields(e, t, r, o){
    if("string" == typeof e){
     var _o9 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"),
              _o9,
              [t, r]);
    }
    var
     n =
       Call
        (o !== null && o !== void 0 ? o : GetMethod(e, "dateFromFields"),
         e,
         [t, r]);
    if(! IsTemporalDate(n)) throw new TypeError("invalid result");
    return n;
   }
   function CalendarYearMonthFromFields(e, t, r){
    if("string" == typeof e){
     var _o10 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.Calendar.prototype.yearMonthFromFields%"),
              _o10,
              [t, r]);
    }
    var o = Call(GetMethod(e, "yearMonthFromFields"), e, [t, r]);
    if(! IsTemporalYearMonth(o)) throw new TypeError("invalid result");
    return o;
   }
   function CalendarMonthDayFromFields(e, t, r){
    if("string" == typeof e){
     var _o11 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"),
              _o11,
              [t, r]);
    }
    var o = Call(GetMethod(e, "monthDayFromFields"), e, [t, r]);
    if(! IsTemporalMonthDay(o)) throw new TypeError("invalid result");
    return o;
   }
   function ToTemporalTimeZoneSlotValue(e){
    if(IsObject(e)){
     if(IsTemporalZonedDateTime(e)) return GetSlot(e, g);
     if
      (!
       function(e){
         return !
                !
                IsTemporalTimeZone(e)
                ||
                 "getOffsetNanosecondsFor" in e
                 && "getPossibleInstantsFor" in e
                 && "id" in e;
        }
        (e))
      throw new
             TypeError
             ("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
     return e;
    }
    return ParseTemporalTimeZone(ToString(e));
   }
   function ToTemporalTimeZoneIdentifier(e){
    if("string" == typeof e) return e;
    var t = e.id;
    if("string" != typeof t)
     throw new TypeError("timeZone.id should be a string");
    return t;
   }
   function ToTemporalTimeZoneObject(e){
    if(IsObject(e)) return e;
    return new (GetIntrinsic("%Temporal.TimeZone%"))(e);
   }
   function TimeZoneEquals(e, t){
    if(e === t) return ! 0;
    return ToTemporalTimeZoneIdentifier(e) === ToTemporalTimeZoneIdentifier(t);
   }
   function TemporalDateTimeToDate(e){
    return CreateTemporalDate
            (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p));
   }
   function TemporalDateTimeToTime(e){
    return new
            (GetIntrinsic("%Temporal.PlainTime%"))
            (GetSlot(e, d),
             GetSlot(e, m),
             GetSlot(e, c),
             GetSlot(e, h),
             GetSlot(e, u),
             GetSlot(e, T));
   }
   function GetOffsetNanosecondsFor(e, t, r){
    if("string" == typeof e){
     var _r31 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"),
              _r31,
              [t]);
    }
    var
     o =
       Call
        (r !== null && r !== void 0
          ? r
          : GetMethod(e, "getOffsetNanosecondsFor"),
         e,
         [t]);
    if("number" != typeof o)
     throw new TypeError("bad return from getOffsetNanosecondsFor");
    if(! IsIntegralNumber(o) || ae(o) >= 864e11)
     throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
    return o;
   }
   function GetOffsetStringFor(e, t){
    return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e, t));
   }
   function GetPlainDateTimeFor(e, t, r){
    var
     _BalanceISODateTime2,
     o = GetSlot(t, n),
     a = GetOffsetNanosecondsFor(e, t),
     _GetISOPartsFromEpoch = GetISOPartsFromEpoch(o),
     i = _GetISOPartsFromEpoch.year,
     s = _GetISOPartsFromEpoch.month,
     l = _GetISOPartsFromEpoch.day,
     d = _GetISOPartsFromEpoch.hour,
     m = _GetISOPartsFromEpoch.minute,
     c = _GetISOPartsFromEpoch.second,
     h = _GetISOPartsFromEpoch.millisecond,
     u = _GetISOPartsFromEpoch.microsecond,
     T = _GetISOPartsFromEpoch.nanosecond;
    return _BalanceISODateTime2 =
            BalanceISODateTime(i, s, l, d, m, c, h, u, T + a),
           i = _BalanceISODateTime2.year,
           s = _BalanceISODateTime2.month,
           l = _BalanceISODateTime2.day,
           d = _BalanceISODateTime2.hour,
           m = _BalanceISODateTime2.minute,
           c = _BalanceISODateTime2.second,
           h = _BalanceISODateTime2.millisecond,
           u = _BalanceISODateTime2.microsecond,
           T = _BalanceISODateTime2.nanosecond,
           CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, r);
   }
   function GetInstantFor(e, t, r){
    return DisambiguatePossibleInstants(GetPossibleInstantsFor(e, t), e, t, r);
   }
   function DisambiguatePossibleInstants(t, r, o, n){
    var a = GetIntrinsic("%Temporal.Instant%"), f = t.length;
    if(1 === f) return t[0];
    if(f)
     switch(n){
       case "compatible":
       case "earlier": return t[0];
       case "later":
        return t[f - 1];
       case "reject":
        throw new RangeError("multiple instants found");
     }
    var
     y = GetSlot(o, i),
     I = GetSlot(o, s),
     S = GetSlot(o, l),
     g = GetSlot(o, d),
     w = GetSlot(o, m),
     D = GetSlot(o, c),
     G = GetSlot(o, h),
     v = GetSlot(o, u),
     C = GetSlot(o, T),
     O = GetUTCEpochNanoseconds(y, I, S, g, w, D, G, v, C);
    if(null === O)
     throw new RangeError("DateTime outside of supported range");
    var
     b = new a(O - Ee),
     E = new a(O + Ee),
     M = GetOffsetNanosecondsFor(r, b),
     R = GetOffsetNanosecondsFor(r, E) - M;
    switch(n){
      case "earlier":
       {
        var
         _e18 = GetSlot(o, p),
         _t19 = GetIntrinsic("%Temporal.PlainDateTime%"),
         _n7 =
           AddDateTime
            (y,
             I,
             S,
             g,
             w,
             D,
             G,
             v,
             C,
             _e18,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             - R,
             void 0);
        return GetPossibleInstantsFor
                 (r,
                  new
                   _t19
                   (_n7.year,
                    _n7.month,
                    _n7.day,
                    _n7.hour,
                    _n7.minute,
                    _n7.second,
                    _n7.millisecond,
                    _n7.microsecond,
                    _n7.nanosecond,
                    _e18))
                [0];
       }
      case "compatible":
      case "later":
       {
        var
         _e19 = GetSlot(o, p),
         _t20 = GetIntrinsic("%Temporal.PlainDateTime%"),
         _n8 =
           AddDateTime
            (y,
             I,
             S,
             g,
             w,
             D,
             G,
             v,
             C,
             _e19,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             R,
             void 0),
         _a4 =
           GetPossibleInstantsFor
            (r,
             new
              _t20
              (_n8.year,
               _n8.month,
               _n8.day,
               _n8.hour,
               _n8.minute,
               _n8.second,
               _n8.millisecond,
               _n8.microsecond,
               _n8.nanosecond,
               _e19));
        return _a4[_a4.length - 1];
       }
      case "reject":
       throw new RangeError("no such instant found");
    }
   }
   function GetPossibleInstantsFor(e, t, r){
    if("string" == typeof e){
     var _r32 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"),
              _r32,
              [t]);
    }
    var
     o =
       Call
        (r !== null && r !== void 0
          ? r
          : GetMethod(e, "getPossibleInstantsFor"),
         e,
         [t]),
     n = [],
     _iterator13 = _createForOfIteratorHelper(o),
     _step13;
    try{
     for(_iterator13.s(); ! (_step13 = _iterator13.n()).done;){
      var _e20 = _step13.value;
      if(! IsTemporalInstant(_e20))
       throw new TypeError("bad return from getPossibleInstantsFor");
      te.call(n, _e20);
     }
    }
    catch(err){_iterator13.e(err);}
    finally{_iterator13.f();}
    return n;
   }
   function ISOYearString(e){
    var t;
    if(e < 0 || e > 9999)
     t = (e < 0 ? "-" : "+") + "000000".concat(ae(e)).slice(- 6);
    else
     t = "0000".concat(e).slice(- 4);
    return t;
   }
   function ISODateTimePartString(e){return "00".concat(e).slice(- 2);}
   function FormatSecondsStringPart(e, t, r, o, n){
    if("minute" === n) return "";
    var
     a = ":".concat(ISODateTimePartString(e)),
     i,
     s = 1e6 * t + 1e3 * r + o;
    if("auto" === n){
     if(0 === s) return a;
     for(i = "".concat(s).padStart(9, "0"); "0" === i[i.length - 1];)
      i = i.slice(0, - 1);
    }
    else{if(0 === n) return a; i = "".concat(s).padStart(9, "0").slice(0, n);}
    return "".concat(a, ".").concat(i);
   }
   function TemporalInstantToString(e, t, r){
    var o = t;
    void 0 === o && (o = "UTC");
    var
     n = GetPlainDateTimeFor(o, e, "iso8601"),
     a = ISOYearString(GetSlot(n, i)),
     p = ISODateTimePartString(GetSlot(n, s)),
     f = ISODateTimePartString(GetSlot(n, l)),
     y = ISODateTimePartString(GetSlot(n, d)),
     I = ISODateTimePartString(GetSlot(n, m)),
     S =
       FormatSecondsStringPart
        (GetSlot(n, c), GetSlot(n, h), GetSlot(n, u), GetSlot(n, T), r),
     g = "Z";
    if(void 0 !== t)
     g = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o, e));
    return "".concat(a, "-").concat(p, "-").concat(f, "T").concat(y, ":").concat
              (I).concat
             (S).concat
            (g);
   }
   function TemporalDurationToString(t){
    var
     _divmod,
     _divmod2,
     _divmod3,
     r =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     o = arguments.length > 2 ? arguments[2] : undefined;
    function formatNumber(t){
     return t <= ue ? t.toString(10) : BigInt(t).toString(10);
    }
    var
     n = GetSlot(t, w),
     a = GetSlot(t, D),
     i = GetSlot(t, G),
     s = GetSlot(t, v),
     l = GetSlot(t, C),
     d = GetSlot(t, O),
     m = GetSlot(t, b),
     c = GetSlot(t, E),
     h = GetSlot(t, M),
     u = GetSlot(t, R),
     T = DurationSign(n, a, i, s, l, d, m, c, h, u);
    if(o){
     var
      _e21 = o.unit,
      _t21 = o.increment,
      _r33 = o.roundingMode,
      _RoundDuration =
        RoundDuration(0, 0, 0, 0, 0, 0, m, c, h, u, _t21, _e21, _r33);
     m = _RoundDuration.seconds;
     c = _RoundDuration.milliseconds;
     h = _RoundDuration.microseconds;
     u = _RoundDuration.nanoseconds;
    }
    var p = [];
    n && p.push("".concat(formatNumber(ae(n)), "Y")),
    a && p.push("".concat(formatNumber(ae(a)), "M")),
    i && p.push("".concat(formatNumber(ae(i)), "W")),
    s && p.push("".concat(formatNumber(ae(s)), "D"));
    var f = [];
    l && f.push("".concat(formatNumber(ae(l)), "H")),
    d && f.push("".concat(formatNumber(ae(d)), "M"));
    var
     y = [],
     I,
     S,
     g,
     F,
     Y = TotalDurationNanoseconds(0, 0, 0, m, c, h, u, 0);
    _divmod = divmod(Y, De),
    Y = _divmod.quotient,
    I = _divmod.remainder,
    _divmod2 = divmod(Y, De),
    Y = _divmod2.quotient,
    S = _divmod2.remainder,
    _divmod3 = divmod(Y, De),
    F = _divmod3.quotient,
    g = _divmod3.remainder;
    var P = 1e6 * ae(Number(g)) + 1e3 * ae(Number(S)) + ae(Number(I)), Z;
    if("auto" === r){
     if(0 !== P)
      for(Z = "".concat(P).padStart(9, "0"); "0" === Z[Z.length - 1];)
       Z = Z.slice(0, - 1);
    }
    else
     0 !== r && (Z = "".concat(P).padStart(9, "0").slice(0, r));
    return Z && y.unshift(".", Z),
           F === Ie && ! y.length && "auto" === r
           || y.unshift(abs(F).toString()),
           y.length && f.push("".concat(y.join(""), "S")),
           f.length && f.unshift("T"),
           p.length || f.length
            ? "".concat
                (T < 0 ? "-" : "", "P").concat
               (p.join("")).concat
              (f.join(""))
            : "PT0S";
   }
   function TemporalDateToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto";
    return "".concat(ISOYearString(GetSlot(e, i)), "-").concat
              (ISODateTimePartString(GetSlot(e, s)), "-").concat
             (ISODateTimePartString(GetSlot(e, l))).concat
            (MaybeFormatCalendarAnnotation(GetSlot(e, p), t));
   }
   function TemporalDateTimeToString(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "auto",
     o = arguments.length > 3 ? arguments[3] : undefined,
     n = GetSlot(e, i),
     a = GetSlot(e, s),
     f = GetSlot(e, l),
     y = GetSlot(e, d),
     I = GetSlot(e, m),
     S = GetSlot(e, c),
     g = GetSlot(e, h),
     w = GetSlot(e, u),
     D = GetSlot(e, T);
    if(o){
     var
      _e22 = o.unit,
      _t22 = o.increment,
      _r34 = o.roundingMode,
      _RoundISODateTime =
        RoundISODateTime(n, a, f, y, I, S, g, w, D, _t22, _e22, _r34);
     n = _RoundISODateTime.year;
     a = _RoundISODateTime.month;
     f = _RoundISODateTime.day;
     y = _RoundISODateTime.hour;
     I = _RoundISODateTime.minute;
     S = _RoundISODateTime.second;
     g = _RoundISODateTime.millisecond;
     w = _RoundISODateTime.microsecond;
     D = _RoundISODateTime.nanosecond;
    }
    return "".concat(ISOYearString(n), "-").concat
                 (ISODateTimePartString(a), "-").concat
                (ISODateTimePartString(f), "T").concat
               (ISODateTimePartString(y), ":").concat
              (ISODateTimePartString(I)).concat
             (FormatSecondsStringPart(S, g, w, D, t)).concat
            (MaybeFormatCalendarAnnotation(GetSlot(e, p), r));
   }
   function TemporalMonthDayToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     r =
       "".concat(ISODateTimePartString(GetSlot(e, s)), "-").concat
        (ISODateTimePartString(GetSlot(e, l))),
     o = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if("always" === t || "critical" === t || "iso8601" !== o)
     r = "".concat(ISOYearString(GetSlot(e, i)), "-").concat(r);
    var n = FormatCalendarAnnotation(o, t);
    return n && (r += n), r;
   }
   function TemporalYearMonthToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     r =
       "".concat(ISOYearString(GetSlot(e, i)), "-").concat
        (ISODateTimePartString(GetSlot(e, s))),
     o = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if("always" === t || "critical" === t || "iso8601" !== o)
     r += "-".concat(ISODateTimePartString(GetSlot(e, l)));
    var n = FormatCalendarAnnotation(o, t);
    return n && (r += n), r;
   }
   function TemporalZonedDateTimeToString(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "auto",
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : "auto",
     a =
       arguments.length > 4 && arguments[4] !== undefined
        ? arguments[4]
        : "auto",
     f = arguments.length > 5 ? arguments[5] : undefined,
     y = GetSlot(e, S);
    if(f){
     var
      _t23 = f.unit,
      _r35 = f.increment,
      _o12 = f.roundingMode,
      _a5 = RoundInstant(GetSlot(e, n), _r35, _t23, _o12);
     y = new (GetIntrinsic("%Temporal.Instant%"))(_a5);
    }
    var
     I = GetSlot(e, g),
     w = GetPlainDateTimeFor(I, y, "iso8601"),
     D =
       "".concat(ISOYearString(GetSlot(w, i)), "-").concat
            (ISODateTimePartString(GetSlot(w, s)), "-").concat
           (ISODateTimePartString(GetSlot(w, l)), "T").concat
          (ISODateTimePartString(GetSlot(w, d)), ":").concat
         (ISODateTimePartString(GetSlot(w, m))).concat
        (FormatSecondsStringPart
          (GetSlot(w, c), GetSlot(w, h), GetSlot(w, u), GetSlot(w, T), t));
    if("never" !== a)
     D += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I, y));
    if("never" !== o)
     D +=
      "[".concat("critical" === o ? "!" : "").concat
       (ToTemporalTimeZoneIdentifier(I), "]");
    return D += MaybeFormatCalendarAnnotation(GetSlot(e, p), r), D;
   }
   function IsTimeZoneOffsetString(e){return ze.test(he(e));}
   function ParseTimeZoneOffsetString(e){
    var t = ze.exec(he(e));
    if(! t) throw new RangeError("invalid time zone offset: ".concat(e));
    return ("-" === t[1] || "" === t[1] ? - 1 : 1)
           *
            (1e9 * (60 * (60 * + t[2] + + (t[3] || 0)) + + (t[4] || 0))
            + + ((t[5] || 0) + "000000000").slice(0, 9));
   }
   function GetCanonicalTimeZoneIdentifier(e){
    if(IsTimeZoneOffsetString(e))
     return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e));
    return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone;
   }
   function GetNamedTimeZoneOffsetNanoseconds(t, r){
    var
     _GetNamedTimeZoneDate = GetNamedTimeZoneDateTimeParts(t, r),
     o = _GetNamedTimeZoneDate.year,
     n = _GetNamedTimeZoneDate.month,
     a = _GetNamedTimeZoneDate.day,
     i = _GetNamedTimeZoneDate.hour,
     s = _GetNamedTimeZoneDate.minute,
     l = _GetNamedTimeZoneDate.second,
     d = _GetNamedTimeZoneDate.millisecond,
     m = _GetNamedTimeZoneDate.microsecond,
     c = _GetNamedTimeZoneDate.nanosecond,
     h = o % 400,
     u = (o - h) / 400,
     T = 146097n * Ee,
     p = GetUTCEpochNanoseconds(h, n, a, i, s, l, d, m, c),
     f = p + T * BigInt(u);
    return Number(f - r);
   }
   function FormatTimeZoneOffsetString(e){
    var
     t = e < 0 ? "-" : "+",
     r = ae(e),
     o = r % 1e9,
     n = ie(r / 1e9) % 60,
     a = ie(r / 6e10) % 60,
     i = ISODateTimePartString(ie(r / 36e11)),
     s = ISODateTimePartString(a),
     l = ISODateTimePartString(n),
     d = "";
    if(o){
     var _e23 = "".concat(o).padStart(9, "0");
     for(; "0" === _e23[_e23.length - 1];) _e23 = _e23.slice(0, - 1);
     d = ":".concat(l, ".").concat(_e23);
    }
    else
     n && (d = ":".concat(l));
    return "".concat(t).concat(i, ":").concat(s).concat(d);
   }
   function FormatISOTimeZoneOffsetString(t){
    var
     r = Number(RoundNumberToIncrement(BigInt(t), be, "halfExpand")),
     o = r < 0 ? "-" : "+";
    r = ae(r);
    var n = r / 6e10 % 60;
    return "".concat(o).concat(ISODateTimePartString(ie(r / 36e11)), ":").concat
            (ISODateTimePartString(n));
   }
   function GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d){
    var m = new Date();
    m.setUTCHours(n, a, i, s), m.setUTCFullYear(t, r - 1, o);
    var c = m.getTime();
    if(de(c)) return null;
    var h = BigInt(c) * Ge;
    return h = h + BigInt(l) * De,
           h = h + BigInt(d),
           h < Me || h > Re ? null : h;
   }
   function GetISOPartsFromEpoch(t){
    var
     _divmod4 = divmod(t, Ge),
     r = _divmod4.quotient,
     o = _divmod4.remainder,
     n = Number(r),
     a = Number(o);
    a < 0 && (a += 1e6, n -= 1);
    var i = ie(a / 1e3) % 1e3, s = a % 1e3, l = new Date(n);
    return {epochMilliseconds: n,
            year: l.getUTCFullYear(),
            month: l.getUTCMonth() + 1,
            day: l.getUTCDate(),
            hour: l.getUTCHours(),
            minute: l.getUTCMinutes(),
            second: l.getUTCSeconds(),
            millisecond: l.getUTCMilliseconds(),
            microsecond: i,
            nanosecond: s};
   }
   function GetNamedTimeZoneDateTimeParts(e, t){
    var
     _GetISOPartsFromEpoch2 = GetISOPartsFromEpoch(t),
     r = _GetISOPartsFromEpoch2.epochMilliseconds,
     o = _GetISOPartsFromEpoch2.millisecond,
     n = _GetISOPartsFromEpoch2.microsecond,
     a = _GetISOPartsFromEpoch2.nanosecond,
     _GetFormatterParts =
       function(e, t){
         var r = getIntlDateTimeFormatEnUsForTimeZone(e).format(new Date(t));
         return function(e){
                  var t = e.split(/[^\w]+/);
                  if(7 !== t.length)
                   throw new RangeError('expected 7 parts in "'.concat(e));
                  var
                   r = + t[0],
                   o = + t[1],
                   n = + t[2],
                   a = t[3].toUpperCase();
                  if("B" === a || "BC" === a)
                   n = 1 - n;
                  else if("A" !== a && "AD" !== a)
                   throw new
                          RangeError
                          ("Unknown era ".concat(a, ' in "').concat(e));
                  var i = + t[4];
                  24 === i && (i = 0);
                  var s = + t[5], l = + t[6];
                  if(! (me(n) && me(r) && me(o) && me(i) && me(s) && me(l)))
                   throw new RangeError('Invalid number in "'.concat(e));
                  return {year: n,
                          month: r,
                          day: o,
                          hour: i,
                          minute: s,
                          second: l};
                 }
                 (r);
        }
        (e, r),
     i = _GetFormatterParts.year,
     s = _GetFormatterParts.month,
     l = _GetFormatterParts.day,
     d = _GetFormatterParts.hour,
     m = _GetFormatterParts.minute,
     c = _GetFormatterParts.second;
    return BalanceISODateTime(i, s, l, d, m, c, o, n, a);
   }
   function maxJSBI(t, r){return t < r ? r : t;}
   function afterLatestPossibleTzdbRuleChange(){return Ve() + Ze;}
   function GetNamedTimeZoneNextTransition(t, r){
    if(r < Pe) return GetNamedTimeZoneNextTransition(t, Pe);
    var
     o = r + Be,
     n = maxJSBI(afterLatestPossibleTzdbRuleChange(), o),
     a = maxJSBI(Pe, r),
     i = GetNamedTimeZoneOffsetNanoseconds(t, a),
     s = a,
     l = i;
    for(; i === l && BigInt(a) < n;){
     if(s = a + Ne, s > Re) return null;
     l = GetNamedTimeZoneOffsetNanoseconds(t, s), i === l && (a = s);
    }
    if(i === l) return null;
    return bisect
            (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
             a,
             s,
             i,
             l);
   }
   function GetNamedTimeZonePreviousTransition(t, r){
    var
     o = afterLatestPossibleTzdbRuleChange(),
     a = r > o,
     i = a ? r - Be : Pe;
    if("Africa/Casablanca" === t || "Africa/El_Aaiun" === t){
     var _o13 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
     if(_o13 < r) return GetNamedTimeZonePreviousTransition(t, _o13);
    }
    var s = r - Se;
    if(s < Pe) return null;
    var l = GetNamedTimeZoneOffsetNanoseconds(t, s), d = s, m = l;
    for(; l === m && s > i;){
     if(d = s - Ne, d < Pe) return null;
     m = GetNamedTimeZoneOffsetNanoseconds(t, d), l === m && (s = d);
    }
    if(l === m){
     if(a){
      var _r36 = o - Ee;
      return GetNamedTimeZonePreviousTransition(t, _r36);
     }
     return null;
    }
    return bisect
            (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
             d,
             s,
             m,
             l);
   }
   function LeapYear(e){
    if(void 0 === e) return ! 1;
    return e % 4 == 0 && (! (e % 100 == 0) || e % 400 == 0);
   }
   function ISODaysInMonth(e, t){
    return {standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
              leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]}
             [LeapYear(e) ? "leapyear" : "standard"]
            [t - 1];
   }
   function DayOfWeek(e, t, r){
    var
     o = t + (t < 3 ? 10 : - 2),
     n = e - (t < 3 ? 1 : 0),
     a = ie(n / 100),
     i = n - 100 * a,
     s = (r + ie(2.6 * o - .2) + (i + ie(i / 4)) + (ie(a / 4) - 2 * a)) % 7;
    return s + (s <= 0 ? 7 : 0);
   }
   function DayOfYear(e, t, r){
    var o = r;
    for(var _r37 = t - 1; _r37 > 0; _r37--) o += ISODaysInMonth(e, _r37);
    return o;
   }
   function WeekOfYear(e, t, r){
    var
     o = DayOfYear(e, t, r),
     n = DayOfWeek(e, t, r) || 7,
     a = DayOfWeek(e, 1, 1),
     i = ie((o - n + 10) / 7);
    return i < 1
            ? 5
              === a
              || 6 === a && LeapYear(e - 1)
              ? {week: 53, year: e - 1}
              : {week: 52, year: e - 1}
            : 53
              === i
              && (LeapYear(e) ? 366 : 365) - o < 4 - n
              ? {week: 1, year: e + 1}
              : {week: i, year: e};
   }
   function DurationSign(e, t, r, o, n, a, i, s, l, d){
    for
    (var _i7 = 0, _arr2 = [e, t, r, o, n, a, i, s, l, d];
     _i7 < _arr2.length;
     _i7++){var _m2 = _arr2[_i7]; if(0 !== _m2) return _m2 < 0 ? - 1 : 1;}
    return 0;
   }
   function BalanceISOYearMonth(e, t){
    var r = e, o = t;
    if(! me(r) || ! me(o)) throw new RangeError("infinity is out of range");
    return o -= 1,
           r += ie(o / 12),
           o %= 12,
           o < 0 && (o += 12),
           o += 1,
           {year: r, month: o};
   }
   function BalanceISODate(e, t, r){
    var o = e, n = t, a = r;
    if(! me(a)) throw new RangeError("infinity is out of range");
    var _BalanceISOYearMonth = BalanceISOYearMonth(o, n);
    o = _BalanceISOYearMonth.year;
    n = _BalanceISOYearMonth.month;
    var i = 146097;
    if(ae(a) > i){var _e24 = le(a / i); o += 400 * _e24, a -= _e24 * i;}
    var s = 0, l = n > 2 ? o : o - 1;
    for(; s = LeapYear(l) ? 366 : 365, a < - s;) o -= 1, l -= 1, a += s;
    for(l += 1; s = LeapYear(l) ? 366 : 365, a > s;) o += 1, l += 1, a -= s;
    for(; a < 1;){
     var _BalanceISOYearMonth2;
     _BalanceISOYearMonth2 = BalanceISOYearMonth(o, n - 1),
     o = _BalanceISOYearMonth2.year,
     n = _BalanceISOYearMonth2.month,
     a += ISODaysInMonth(o, n);
    }
    for(; a > ISODaysInMonth(o, n);){
     var _BalanceISOYearMonth3;
     a -= ISODaysInMonth(o, n),
     _BalanceISOYearMonth3 = BalanceISOYearMonth(o, n + 1),
     o = _BalanceISOYearMonth3.year,
     n = _BalanceISOYearMonth3.month;
    }
    return {year: o, month: n, day: a};
   }
   function BalanceISODateTime(e, t, r, o, n, a, i, s, l){
    var
     _BalanceTime = BalanceTime(o, n, a, i, s, l),
     d = _BalanceTime.deltaDays,
     m = _BalanceTime.hour,
     c = _BalanceTime.minute,
     h = _BalanceTime.second,
     u = _BalanceTime.millisecond,
     T = _BalanceTime.microsecond,
     p = _BalanceTime.nanosecond,
     _BalanceISODate = BalanceISODate(e, t, r + d),
     f = _BalanceISODate.year,
     y = _BalanceISODate.month,
     I = _BalanceISODate.day;
    return {year: f,
            month: y,
            day: I,
            hour: m,
            minute: c,
            second: h,
            millisecond: u,
            microsecond: T,
            nanosecond: p};
   }
   function BalanceTime(t, r, o, n, a, i){
    var
     _NonNegativeBigIntDiv,
     _NonNegativeBigIntDiv2,
     _NonNegativeBigIntDiv3,
     _NonNegativeBigIntDiv4,
     _NonNegativeBigIntDiv5,
     _NonNegativeBigIntDiv6,
     s,
     l = BigInt(t),
     d = BigInt(r),
     m = BigInt(o),
     c = BigInt(n),
     h = BigInt(a),
     u = BigInt(i);
    return _NonNegativeBigIntDiv = NonNegativeBigIntDivmod(u, De),
           s = _NonNegativeBigIntDiv.quotient,
           u = _NonNegativeBigIntDiv.remainder,
           h = h + s,
           _NonNegativeBigIntDiv2 = NonNegativeBigIntDivmod(h, De),
           s = _NonNegativeBigIntDiv2.quotient,
           h = _NonNegativeBigIntDiv2.remainder,
           c = c + s,
           _NonNegativeBigIntDiv3 = NonNegativeBigIntDivmod(c, De),
           s = _NonNegativeBigIntDiv3.quotient,
           c = _NonNegativeBigIntDiv3.remainder,
           m = m + s,
           _NonNegativeBigIntDiv4 = NonNegativeBigIntDivmod(m, ge),
           s = _NonNegativeBigIntDiv4.quotient,
           m = _NonNegativeBigIntDiv4.remainder,
           d = d + s,
           _NonNegativeBigIntDiv5 = NonNegativeBigIntDivmod(d, ge),
           s = _NonNegativeBigIntDiv5.quotient,
           d = _NonNegativeBigIntDiv5.remainder,
           l = l + s,
           _NonNegativeBigIntDiv6 = NonNegativeBigIntDivmod(l, we),
           s = _NonNegativeBigIntDiv6.quotient,
           l = _NonNegativeBigIntDiv6.remainder,
           {deltaDays: Number(s),
            hour: Number(l),
            minute: Number(d),
            second: Number(m),
            millisecond: Number(c),
            microsecond: Number(h),
            nanosecond: Number(u)};
   }
   function TotalDurationNanoseconds(t, r, o, n, a, i, s, l){
    var d = BigInt(t), m = BigInt(s);
    0 !== t && (m = BigInt(s) - BigInt(l));
    var
     c = BigInt(r) + d * 24n,
     h = BigInt(o) + c * ge,
     u = BigInt(n) + h * ge,
     T = BigInt(a) + u * De,
     p = BigInt(i) + T * De;
    return BigInt(m) + p * De;
   }
   function NanosecondsToDays(t, r){
    var
     o = GetIntrinsic("%Temporal.Instant%"),
     a = se(Number(t)),
     f = BigInt(t),
     y = 864e11;
    if(0 === a) return {days: 0, nanoseconds: Ie, dayLengthNs: y};
    if(! IsTemporalZonedDateTime(r)){
     var _divmod5, _t24;
     return _divmod5 = divmod(f, BigInt(y)),
            _t24 = _divmod5.quotient,
            f = _divmod5.remainder,
            {days: Number(_t24), nanoseconds: f, dayLengthNs: y};
    }
    var
     I = GetSlot(r, n),
     w = GetSlot(r, S),
     D = I + f,
     G = new o(D),
     v = GetSlot(r, g),
     C = GetSlot(r, p),
     O = GetPlainDateTimeFor(v, w, C),
     b = GetPlainDateTimeFor(v, G, C),
     _DifferenceISODateTim =
       DifferenceISODateTime
        (GetSlot(O, i),
         GetSlot(O, s),
         GetSlot(O, l),
         GetSlot(O, d),
         GetSlot(O, m),
         GetSlot(O, c),
         GetSlot(O, h),
         GetSlot(O, u),
         GetSlot(O, T),
         GetSlot(b, i),
         GetSlot(b, s),
         GetSlot(b, l),
         GetSlot(b, d),
         GetSlot(b, m),
         GetSlot(b, c),
         GetSlot(b, h),
         GetSlot(b, u),
         GetSlot(b, T),
         C,
         "day",
         Te(null)),
     E = _DifferenceISODateTim.days,
     M = AddZonedDateTime(w, v, C, 0, 0, 0, E, 0, 0, 0, 0, 0, 0),
     R = BigInt(E);
    if(1 === a)
     for(; R > Ie && M > D;)
      R = R - Se,
      M = AddZonedDateTime(w, v, C, 0, 0, 0, Number(R), 0, 0, 0, 0, 0, 0);
    f = D - M;
    var F = ! 1, Y = new o(M);
    do{
     var
      _t25 = AddZonedDateTime(Y, v, C, 0, 0, 0, a, 0, 0, 0, 0, 0, 0),
      _r38 = GetSlot(Y, n);
     y = Number(_t25 - _r38),
     F = (f - BigInt(y)) * BigInt(a) >= Ie,
     F && (f = f - BigInt(y), Y = new o(_t25), R = R + BigInt(a));
    }
    while
     (F);
    if(! isZero(R) && signJSBI(R) !== a)
     throw new
            RangeError
            ("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
    if(! isZero(f) && signJSBI(f) !== a){
     if(isNegativeJSBI(f) && 1 === a) throw new Error("assert not reached");
     throw new
            RangeError
            ("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
    }
    if(abs(f) >= abs(BigInt(y))) throw new Error("assert not reached");
    return {days: Number(R), nanoseconds: f, dayLengthNs: ae(y)};
   }
   function BalanceDuration(e, t, r, o, n, a, i, s, l){
    var d = BalancePossiblyInfiniteDuration(e, t, r, o, n, a, i, s, l);
    if("positive overflow" === d || "negative overflow" === d)
     throw new RangeError("Duration out of range");
    return d;
   }
   function BalancePossiblyInfiniteDuration(t, r, o, a, i, s, l, d, m){
    var
     _NanosecondsToDays,
     _divmod6,
     _divmod7,
     _divmod8,
     _divmod9,
     _divmod10,
     _divmod11,
     _divmod12,
     _divmod13,
     _divmod14,
     _divmod15,
     _divmod16,
     _divmod17,
     _divmod18,
     _divmod19,
     c,
     h,
     u,
     T,
     f,
     y,
     I = t;
    if(IsTemporalZonedDateTime(m)){
     var
      _t26 =
        AddZonedDateTime
         (GetSlot(m, S),
          GetSlot(m, g),
          GetSlot(m, p),
          0,
          0,
          0,
          I,
          r,
          o,
          a,
          i,
          s,
          l),
      _d = GetSlot(m, n);
     c = _t26 - _d;
    }
    else
     c = TotalDurationNanoseconds(I, r, o, a, i, s, l, 0);
    "year" === d || "month" === d || "week" === d || "day" === d
     ? (_NanosecondsToDays
       = NanosecondsToDays(c, m),
       I = _NanosecondsToDays.days,
       c = _NanosecondsToDays.nanoseconds,
       _NanosecondsToDays)
     : I = 0;
    var w = c < Ie ? - 1 : 1;
    switch(c = abs(c), h = u = T = f = y = Ie, d){
      case "year":
      case "month":
      case "week":
      case "day":
      case "hour":
       _divmod6 = divmod(c, De),
       h = _divmod6.quotient,
       c = _divmod6.remainder,
       _divmod7 = divmod(h, De),
       u = _divmod7.quotient,
       h = _divmod7.remainder,
       _divmod8 = divmod(u, De),
       T = _divmod8.quotient,
       u = _divmod8.remainder,
       _divmod9 = divmod(T, ge),
       f = _divmod9.quotient,
       T = _divmod9.remainder,
       _divmod10 = divmod(f, ge),
       y = _divmod10.quotient,
       f = _divmod10.remainder;
       break;
      case "minute":
       _divmod11 = divmod(c, De),
       h = _divmod11.quotient,
       c = _divmod11.remainder,
       _divmod12 = divmod(h, De),
       u = _divmod12.quotient,
       h = _divmod12.remainder,
       _divmod13 = divmod(u, De),
       T = _divmod13.quotient,
       u = _divmod13.remainder,
       _divmod14 = divmod(T, ge),
       f = _divmod14.quotient,
       T = _divmod14.remainder;
       break;
      case "second":
       _divmod15 = divmod(c, De),
       h = _divmod15.quotient,
       c = _divmod15.remainder,
       _divmod16 = divmod(h, De),
       u = _divmod16.quotient,
       h = _divmod16.remainder,
       _divmod17 = divmod(u, De),
       T = _divmod17.quotient,
       u = _divmod17.remainder;
       break;
      case "millisecond":
       _divmod18 = divmod(c, De),
       h = _divmod18.quotient,
       c = _divmod18.remainder,
       _divmod19 = divmod(h, De),
       u = _divmod19.quotient,
       h = _divmod19.remainder;
       break;
      case "microsecond":
       var _divmod20 = divmod(c, De);
       h = _divmod20.quotient;
       c = _divmod20.remainder;
       break;
      case "nanosecond": break;
      default: throw new Error("assert not reached");
    }
    var
     D = Number(y) * w,
     G = Number(f) * w,
     v = Number(T) * w,
     C = Number(u) * w,
     O = Number(h) * w,
     b = Number(c) * w;
    for(var _i8 = 0, _arr3 = [I, D, G, v, C, O, b]; _i8 < _arr3.length; _i8++){
     var _e25 = _arr3[_i8];
     if(! me(_e25))
      return 1 === w ? "positive overflow" : "negative overflow";
    }
    return {days: I,
            hours: D,
            minutes: G,
            seconds: v,
            milliseconds: C,
            microseconds: O,
            nanoseconds: b};
   }
   function UnbalanceDurationRelative(t, r, o, n, a, i){
    var
     s = GetIntrinsic("%Temporal.Duration%"),
     l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
    if(0 === l) return {years: t, months: r, weeks: o, days: n};
    var
     d = BigInt(l),
     m,
     c,
     h = BigInt(t),
     u = BigInt(r),
     T = BigInt(o),
     f = BigInt(n);
    i && (c = ToTemporalDate(i), m = GetSlot(c, p));
    var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
    switch(a){
      case "year": break;
      case "month":
       {
        if(! m)
         throw new
                RangeError
                ("a starting point is required for months balancing");
        var _t27, _r39;
        for
        ("string" != typeof m
         && (_t27 = GetMethod(m, "dateAdd"), _r39 = GetMethod(m, "dateUntil"));
         !
         isZero(h);){
         var _o14 = CalendarDateAdd(m, c, y, void 0, _t27), _n9 = Te(null);
         _n9.largestUnit = "month";
         var
          _a6 = CalendarDateUntil(m, c, _o14, _n9, _r39),
          _i9 = BigInt(GetSlot(_a6, D));
         c = _o14, u = u + _i9, h = h - d;
        }
       }
       break;
      case "week":
       {
        if(! m)
         throw new
                RangeError
                ("a starting point is required for weeks balancing");
        var _t28 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
        for(; ! isZero(h);){
         var _MoveRelativeDate, _r40 = void 0;
         _MoveRelativeDate = MoveRelativeDate(m, c, y, _t28),
         c = _MoveRelativeDate.relativeTo,
         _r40 = _MoveRelativeDate.days,
         f = f + BigInt(_r40),
         h = h - d;
        }
        for(; ! isZero(u);){
         var _MoveRelativeDate2, _r41 = void 0;
         _MoveRelativeDate2 = MoveRelativeDate(m, c, I, _t28),
         c = _MoveRelativeDate2.relativeTo,
         _r41 = _MoveRelativeDate2.days,
         f = f + BigInt(_r41),
         u = u - d;
        }
        break;
       }
      default:
       {
        if(isZero(h) && isZero(u) && isZero(T)) break;
        if(! m)
         throw new
                RangeError
                ("a starting point is required for balancing calendar units");
        var _t29 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
        for(; ! isZero(h);){
         var _MoveRelativeDate3, _r42 = void 0;
         _MoveRelativeDate3 = MoveRelativeDate(m, c, y, _t29),
         c = _MoveRelativeDate3.relativeTo,
         _r42 = _MoveRelativeDate3.days,
         f = f + BigInt(_r42),
         h = h - d;
        }
        for(; ! isZero(u);){
         var _MoveRelativeDate4, _r43 = void 0;
         _MoveRelativeDate4 = MoveRelativeDate(m, c, I, _t29),
         c = _MoveRelativeDate4.relativeTo,
         _r43 = _MoveRelativeDate4.days,
         f = f + BigInt(_r43),
         u = u - d;
        }
        for(; ! isZero(T);){
         var _MoveRelativeDate5, _r44 = void 0;
         _MoveRelativeDate5 = MoveRelativeDate(m, c, S, _t29),
         c = _MoveRelativeDate5.relativeTo,
         _r44 = _MoveRelativeDate5.days,
         f = f + BigInt(_r44),
         T = T - d;
        }
        break;
       }
    }
    return {years: Number(h),
            months: Number(u),
            weeks: Number(T),
            days: Number(f)};
   }
   function CalculateOffsetShift(e, t, r, o, n){
    if(IsTemporalZonedDateTime(e)){
     var
      _a7 = GetSlot(e, S),
      _i10 = GetSlot(e, g),
      _s = GetSlot(e, p),
      _l2 = GetOffsetNanosecondsFor(_i10, _a7),
      _d2 = AddZonedDateTime(_a7, _i10, _s, t, r, o, n, 0, 0, 0, 0, 0, 0);
     return GetOffsetNanosecondsFor
             (_i10, new (GetIntrinsic("%Temporal.Instant%"))(_d2))
            - _l2;
    }
    return 0;
   }
   function CreateNegatedTemporalDuration(e){
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (- GetSlot(e, w),
             - GetSlot(e, D),
             - GetSlot(e, G),
             - GetSlot(e, v),
             - GetSlot(e, C),
             - GetSlot(e, O),
             - GetSlot(e, b),
             - GetSlot(e, E),
             - GetSlot(e, M),
             - GetSlot(e, R));
   }
   function ConstrainToRange(e, t, r){return oe(r, ne(t, e));}
   function ConstrainISODate(e, t, r){
    var o = ConstrainToRange(t, 1, 12);
    return {year: e,
            month: o,
            day: ConstrainToRange(r, 1, ISODaysInMonth(e, o))};
   }
   function RejectToRange(e, t, r){
    if(e < t || e > r)
     throw new
            RangeError
            ("value out of range: ".concat(t, " <= ").concat(e, " <= ").concat
              (r));
   }
   function RejectISODate(e, t, r){
    RejectToRange(t, 1, 12), RejectToRange(r, 1, ISODaysInMonth(e, t));
   }
   function RejectDateRange(e, t, r){
    RejectDateTimeRange(e, t, r, 12, 0, 0, 0, 0, 0);
   }
   function RejectTime(e, t, r, o, n, a){
    RejectToRange(e, 0, 23),
    RejectToRange(t, 0, 59),
    RejectToRange(r, 0, 59),
    RejectToRange(o, 0, 999),
    RejectToRange(n, 0, 999),
    RejectToRange(a, 0, 999);
   }
   function RejectDateTime(e, t, r, o, n, a, i, s, l){
    RejectISODate(e, t, r), RejectTime(o, n, a, i, s, l);
   }
   function RejectDateTimeRange(e, t, r, o, n, a, i, s, l){
    if
     (RejectToRange(e, Fe, Ye),
      e === Fe
      && null == GetUTCEpochNanoseconds(e, t, r + 1, o, n, a, i, s, l - 1)
      ||
       e === Ye
       && null == GetUTCEpochNanoseconds(e, t, r - 1, o, n, a, i, s, l + 1))
     throw new RangeError("DateTime outside of supported range");
   }
   function ValidateEpochNanoseconds(t){
    if(t < Me || t > Re)
     throw new RangeError("Instant outside of supported range");
   }
   function RejectDuration(e, t, r, o, n, a, i, s, l, d){
    var m = DurationSign(e, t, r, o, n, a, i, s, l, d);
    for
    (var _i11 = 0, _arr4 = [e, t, r, o, n, a, i, s, l, d];
     _i11 < _arr4.length;
     _i11++){
     var _c2 = _arr4[_i11];
     if(! me(_c2))
      throw new RangeError("infinite values not allowed as duration fields");
     var _e26 = se(_c2);
     if(0 !== _e26 && _e26 !== m)
      throw new RangeError("mixed-sign values not allowed as duration fields");
    }
   }
   function DifferenceISODate(e, t, r, o, n, a, i){
    switch(i){
      case "year":
      case "month":
       {
        var _s2 = - CompareISODate(e, t, r, o, n, a);
        if(0 === _s2) return {years: 0, months: 0, weeks: 0, days: 0};
        var
         _l3 = {year: e, month: t, day: r},
         _d3 = {year: o, month: n, day: a},
         _m3 = _d3.year - _l3.year,
         _c3 = AddISODate(e, t, r, _m3, 0, 0, 0, "constrain"),
         _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a);
        if(0 === _h)
         return "year" === i
                 ? {years: _m3, months: 0, weeks: 0, days: 0}
                 : {years: 0, months: 12 * _m3, weeks: 0, days: 0};
        var _u = _d3.month - _l3.month;
        if
         (_h !== _s2 && (_m3 -= _s2, _u += 12 * _s2),
          _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"),
          _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a),
          0 === _h)
         return "year" === i
                 ? {years: _m3, months: _u, weeks: 0, days: 0}
                 : {years: 0, months: _u + 12 * _m3, weeks: 0, days: 0};
        _h !== _s2
        &&
         (_u -= _s2,
          _u === - _s2 && (_m3 -= _s2, _u = 11 * _s2),
          _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"));
        var _T = 0;
        return _T =
                _c3.month === _d3.month
                 ? _d3.day - _c3.day
                 : _s2
                   < 0
                   ? -
                    _c3.day
                    - (ISODaysInMonth(_d3.year, _d3.month) - _d3.day)
                   : _d3.day + (ISODaysInMonth(_c3.year, _c3.month) - _c3.day),
               "month" === i && (_u += 12 * _m3, _m3 = 0),
               {years: _m3, months: _u, weeks: 0, days: _T};
       }
      case "week":
      case "day":
       {
        var _s3, _l4, _d4;
        CompareISODate(e, t, r, o, n, a) < 0
         ? (_l4
           = {year: e, month: t, day: r},
           _s3 = {year: o, month: n, day: a},
           _d4 = 1)
         : (_l4
           = {year: o, month: n, day: a},
           _s3 = {year: e, month: t, day: r},
           _d4 = - 1);
        var
         _m4 =
           DayOfYear(_s3.year, _s3.month, _s3.day)
           - DayOfYear(_l4.year, _l4.month, _l4.day);
        for(var _e27 = _l4.year; _e27 < _s3.year; ++_e27)
         _m4 += LeapYear(_e27) ? 366 : 365;
        var _c4 = 0;
        return "week" === i && (_c4 = ie(_m4 / 7), _m4 %= 7),
               _c4 *= _d4,
               _m4 *= _d4,
               {years: 0, months: 0, weeks: _c4, days: _m4};
       }
      default: throw new Error("assert not reached");
    }
   }
   function DifferenceTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var
     _BalanceTime2,
     h = i - e,
     u = s - t,
     T = l - r,
     p = d - o,
     f = m - n,
     y = c - a,
     I = DurationSign(0, 0, 0, 0, h, u, T, p, f, y);
    h *= I, u *= I, T *= I, p *= I, f *= I, y *= I;
    var S = 0;
    if
     (_BalanceTime2 = BalanceTime(h, u, T, p, f, y),
      S = _BalanceTime2.deltaDays,
      h = _BalanceTime2.hour,
      u = _BalanceTime2.minute,
      T = _BalanceTime2.second,
      p = _BalanceTime2.millisecond,
      f = _BalanceTime2.microsecond,
      y = _BalanceTime2.nanosecond,
      0 != S)
     throw new
            Error
            ("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
    return h *= I,
           u *= I,
           T *= I,
           p *= I,
           f *= I,
           y *= I,
           {hours: h,
            minutes: u,
            seconds: T,
            milliseconds: p,
            microseconds: f,
            nanoseconds: y};
   }
   function DifferenceInstant(t, r, o, n, a, i){
    var
     _RoundDuration2,
     s = r - t,
     l = 0,
     d = 0,
     m = Number(s % De),
     c = Number(s / De % De),
     h = Number(s / Ge % De),
     u = Number(s / ve);
    return _RoundDuration2 =
            RoundDuration(0, 0, 0, 0, 0, 0, u, h, c, m, o, n, i),
           l = _RoundDuration2.hours,
           d = _RoundDuration2.minutes,
           u = _RoundDuration2.seconds,
           h = _RoundDuration2.milliseconds,
           c = _RoundDuration2.microseconds,
           m = _RoundDuration2.nanoseconds,
           BalanceDuration(0, l, d, u, h, c, m, a);
   }
   function DifferenceISODateTime
   (e, t, r, o, n, a, i, s, l, d, m, c, h, u, T, p, f, y, I, S, g){
    var
     _BalanceISODate2,
     _BalanceDuration,
     _BalanceDuration2,
     w = e,
     D = t,
     G = r,
     _DifferenceTime = DifferenceTime(o, n, a, i, s, l, h, u, T, p, f, y),
     v = _DifferenceTime.hours,
     C = _DifferenceTime.minutes,
     O = _DifferenceTime.seconds,
     b = _DifferenceTime.milliseconds,
     E = _DifferenceTime.microseconds,
     M = _DifferenceTime.nanoseconds,
     R = DurationSign(0, 0, 0, 0, v, C, O, b, E, M);
    CompareISODate(d, m, c, w, D, G) === - R
    &&
     (_BalanceISODate2 = BalanceISODate(w, D, G - R),
      w = _BalanceISODate2.year,
      D = _BalanceISODate2.month,
      G = _BalanceISODate2.day,
      _BalanceDuration = BalanceDuration(- R, v, C, O, b, E, M, S),
      v = _BalanceDuration.hours,
      C = _BalanceDuration.minutes,
      O = _BalanceDuration.seconds,
      b = _BalanceDuration.milliseconds,
      E = _BalanceDuration.microseconds,
      M = _BalanceDuration.nanoseconds);
    var
     F = CreateTemporalDate(w, D, G, I),
     Y = CreateTemporalDate(d, m, c, I),
     P = LargerOfTwoTemporalUnits("day", S),
     Z = CopyOptions(g);
    Z.largestUnit = P;
    var
     _CalendarDateUntil = CalendarDateUntil(I, F, Y, Z),
     B = _CalendarDateUntil.years,
     N = _CalendarDateUntil.months,
     j = _CalendarDateUntil.weeks,
     $ = _CalendarDateUntil.days;
    return _BalanceDuration2 = BalanceDuration($, v, C, O, b, E, M, S),
           $ = _BalanceDuration2.days,
           v = _BalanceDuration2.hours,
           C = _BalanceDuration2.minutes,
           O = _BalanceDuration2.seconds,
           b = _BalanceDuration2.milliseconds,
           E = _BalanceDuration2.microseconds,
           M = _BalanceDuration2.nanoseconds,
           {years: B,
            months: N,
            weeks: j,
            days: $,
            hours: v,
            minutes: C,
            seconds: O,
            milliseconds: b,
            microseconds: E,
            nanoseconds: M};
   }
   function DifferenceZonedDateTime(t, r, o, n, a, p){
    var f = r - t;
    if(f === Ie)
     return {years: 0,
             months: 0,
             weeks: 0,
             days: 0,
             hours: 0,
             minutes: 0,
             seconds: 0,
             milliseconds: 0,
             microseconds: 0,
             nanoseconds: 0};
    var
     y = GetIntrinsic("%Temporal.Instant%"),
     I = new y(t),
     S = new y(r),
     g = GetPlainDateTimeFor(o, I, n),
     w = GetPlainDateTimeFor(o, S, n),
     _DifferenceISODateTim2 =
       DifferenceISODateTime
        (GetSlot(g, i),
         GetSlot(g, s),
         GetSlot(g, l),
         GetSlot(g, d),
         GetSlot(g, m),
         GetSlot(g, c),
         GetSlot(g, h),
         GetSlot(g, u),
         GetSlot(g, T),
         GetSlot(w, i),
         GetSlot(w, s),
         GetSlot(w, l),
         GetSlot(w, d),
         GetSlot(w, m),
         GetSlot(w, c),
         GetSlot(w, h),
         GetSlot(w, u),
         GetSlot(w, T),
         n,
         a,
         p),
     D = _DifferenceISODateTim2.years,
     G = _DifferenceISODateTim2.months,
     v = _DifferenceISODateTim2.weeks,
     C = _DifferenceISODateTim2.days,
     O = AddZonedDateTime(I, o, n, D, G, v, 0, 0, 0, 0, 0, 0, 0),
     b = r - O,
     E = CreateTemporalZonedDateTime(O, o, n),
     _NanosecondsToDays2 = NanosecondsToDays(b, E);
    b = _NanosecondsToDays2.nanoseconds;
    C = _NanosecondsToDays2.days;
    var
     _BalanceDuration3 = BalanceDuration(0, 0, 0, 0, 0, 0, Number(b), "hour"),
     M = _BalanceDuration3.hours,
     R = _BalanceDuration3.minutes,
     F = _BalanceDuration3.seconds,
     Y = _BalanceDuration3.milliseconds,
     P = _BalanceDuration3.microseconds,
     Z = _BalanceDuration3.nanoseconds;
    return {years: D,
            months: G,
            weeks: v,
            days: C,
            hours: M,
            minutes: R,
            seconds: F,
            milliseconds: Y,
            microseconds: P,
            nanoseconds: Z};
   }
   function GetDifferenceSettings(e, t, r, o, n, a){
    var
     i =
       Ue.reduce
        (function(e, t){
          var n = t[0], a = t[1], i = t[2];
          return "datetime" !== r && i !== r || o.includes(a) || e.push(a, n),
                 e;
         },
         []),
     s = GetTemporalUnit(t, "largestUnit", r, "auto");
    if(o.includes(s))
     throw new
            RangeError
            ("largestUnit must be one of ".concat(i.join(", "), ", not ").concat
              (s));
    var
     l = ToTemporalRoundingIncrement(t),
     d = ToTemporalRoundingMode(t, "trunc");
    "since" === e
    &&
     (d =
      function(e){
        switch(e){
          case "ceil":
           return "floor";
          case "floor":
           return "ceil";
          case "halfCeil":
           return "halfFloor";
          case "halfFloor":
           return "halfCeil";
          default: return e;
        }
       }
       (d));
    var m = GetTemporalUnit(t, "smallestUnit", r, n);
    if(o.includes(m))
     throw new
            RangeError
            ("smallestUnit must be one of ".concat(i.join(", "), ", not ").concat
              (m));
    var c = LargerOfTwoTemporalUnits(a, m);
    if("auto" === s && (s = c), LargerOfTwoTemporalUnits(s, m) !== s)
     throw new
            RangeError
            ("largestUnit ".concat(s, " cannot be smaller than smallestUnit ").concat
              (m));
    var
     h =
       {hour: 24,
         minute: 60,
         second: 60,
         millisecond: 1e3,
         microsecond: 1e3,
         nanosecond: 1e3}
        [m];
    return void 0 !== h && ValidateTemporalRoundingIncrement(l, h, ! 1),
           {largestUnit: s,
            roundingIncrement: l,
            roundingMode: d,
            smallestUnit: m};
   }
   function DifferenceTemporalInstant(e, t, r, o){
    var
     a = "since" === e ? - 1 : 1,
     i = ToTemporalInstant(r),
     s =
       GetDifferenceSettings
        (e, CopyOptions(o), "time", [], "nanosecond", "second"),
     l = GetSlot(t, n),
     d = GetSlot(i, n),
     _DifferenceInstant =
       DifferenceInstant
        (l,
         d,
         s.roundingIncrement,
         s.smallestUnit,
         s.largestUnit,
         s.roundingMode),
     m = _DifferenceInstant.hours,
     c = _DifferenceInstant.minutes,
     h = _DifferenceInstant.seconds,
     u = _DifferenceInstant.milliseconds,
     T = _DifferenceInstant.microseconds,
     p = _DifferenceInstant.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (0, 0, 0, 0, a * m, a * c, a * h, a * u, a * T, a * p);
   }
   function DifferenceTemporalPlainDate(e, t, r, o){
    var
     _RoundDuration3,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalDate(r),
     i = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (i, GetSlot(a, p), "compute difference between dates");
    var
     s = CopyOptions(o),
     l = GetDifferenceSettings(e, s, "date", [], "day", "day");
    s.largestUnit = l.largestUnit;
    var
     _CalendarDateUntil2 = CalendarDateUntil(i, t, a, s),
     d = _CalendarDateUntil2.years,
     m = _CalendarDateUntil2.months,
     c = _CalendarDateUntil2.weeks,
     h = _CalendarDateUntil2.days;
    "day" === l.smallestUnit && 1 === l.roundingIncrement
    ||
     (_RoundDuration3 =
       RoundDuration
        (d,
         m,
         c,
         h,
         0,
         0,
         0,
         0,
         0,
         0,
         l.roundingIncrement,
         l.smallestUnit,
         l.roundingMode,
         t),
      d = _RoundDuration3.years,
      m = _RoundDuration3.months,
      c = _RoundDuration3.weeks,
      h = _RoundDuration3.days,
      _RoundDuration3);
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * d, n * m, n * c, n * h, 0, 0, 0, 0, 0, 0);
   }
   function DifferenceTemporalPlainDateTime(e, t, r, o){
    var
     _RoundDuration4,
     _BalanceDuration4,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalDateTime(r),
     f = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (f, GetSlot(a, p), "compute difference between dates");
    var
     y = CopyOptions(o),
     I = GetDifferenceSettings(e, y, "datetime", [], "nanosecond", "day"),
     _DifferenceISODateTim3 =
       DifferenceISODateTime
        (GetSlot(t, i),
         GetSlot(t, s),
         GetSlot(t, l),
         GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         GetSlot(a, i),
         GetSlot(a, s),
         GetSlot(a, l),
         GetSlot(a, d),
         GetSlot(a, m),
         GetSlot(a, c),
         GetSlot(a, h),
         GetSlot(a, u),
         GetSlot(a, T),
         f,
         I.largestUnit,
         y),
     S = _DifferenceISODateTim3.years,
     g = _DifferenceISODateTim3.months,
     w = _DifferenceISODateTim3.weeks,
     D = _DifferenceISODateTim3.days,
     G = _DifferenceISODateTim3.hours,
     v = _DifferenceISODateTim3.minutes,
     C = _DifferenceISODateTim3.seconds,
     O = _DifferenceISODateTim3.milliseconds,
     b = _DifferenceISODateTim3.microseconds,
     E = _DifferenceISODateTim3.nanoseconds,
     M = TemporalDateTimeToDate(t);
    _RoundDuration4 =
     RoundDuration
      (S,
       g,
       w,
       D,
       G,
       v,
       C,
       O,
       b,
       E,
       I.roundingIncrement,
       I.smallestUnit,
       I.roundingMode,
       M),
    S = _RoundDuration4.years,
    g = _RoundDuration4.months,
    w = _RoundDuration4.weeks,
    D = _RoundDuration4.days,
    G = _RoundDuration4.hours,
    v = _RoundDuration4.minutes,
    C = _RoundDuration4.seconds,
    O = _RoundDuration4.milliseconds,
    b = _RoundDuration4.microseconds,
    E = _RoundDuration4.nanoseconds,
    _BalanceDuration4 = BalanceDuration(D, G, v, C, O, b, E, I.largestUnit),
    D = _BalanceDuration4.days,
    G = _BalanceDuration4.hours,
    v = _BalanceDuration4.minutes,
    C = _BalanceDuration4.seconds,
    O = _BalanceDuration4.milliseconds,
    b = _BalanceDuration4.microseconds,
    E = _BalanceDuration4.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * S,
             n * g,
             n * w,
             n * D,
             n * G,
             n * v,
             n * C,
             n * O,
             n * b,
             n * E);
   }
   function DifferenceTemporalPlainTime(e, t, r, o){
    var
     _RoundDuration5,
     _BalanceDuration5,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalTime(r),
     i =
       GetDifferenceSettings
        (e, CopyOptions(o), "time", [], "nanosecond", "hour"),
     _DifferenceTime2 =
       DifferenceTime
        (GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         GetSlot(a, d),
         GetSlot(a, m),
         GetSlot(a, c),
         GetSlot(a, h),
         GetSlot(a, u),
         GetSlot(a, T)),
     s = _DifferenceTime2.hours,
     l = _DifferenceTime2.minutes,
     p = _DifferenceTime2.seconds,
     f = _DifferenceTime2.milliseconds,
     y = _DifferenceTime2.microseconds,
     I = _DifferenceTime2.nanoseconds;
    _RoundDuration5 =
     RoundDuration
      (0,
       0,
       0,
       0,
       s,
       l,
       p,
       f,
       y,
       I,
       i.roundingIncrement,
       i.smallestUnit,
       i.roundingMode),
    s = _RoundDuration5.hours,
    l = _RoundDuration5.minutes,
    p = _RoundDuration5.seconds,
    f = _RoundDuration5.milliseconds,
    y = _RoundDuration5.microseconds,
    I = _RoundDuration5.nanoseconds,
    _BalanceDuration5 = BalanceDuration(0, s, l, p, f, y, I, i.largestUnit),
    s = _BalanceDuration5.hours,
    l = _BalanceDuration5.minutes,
    p = _BalanceDuration5.seconds,
    f = _BalanceDuration5.milliseconds,
    y = _BalanceDuration5.microseconds,
    I = _BalanceDuration5.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (0, 0, 0, 0, n * s, n * l, n * p, n * f, n * y, n * I);
   }
   function DifferenceTemporalPlainYearMonth(e, t, r, o){
    var
     _RoundDuration6,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalYearMonth(r),
     i = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (i, GetSlot(a, p), "compute difference between months");
    var
     s = CopyOptions(o),
     l = GetDifferenceSettings(e, s, "date", ["week", "day"], "month", "year");
    s.largestUnit = l.largestUnit;
    var
     d = CalendarFields(i, ["monthCode", "year"]),
     m = PrepareTemporalFields(t, d, []);
    m.day = 1;
    var c = CalendarDateFromFields(i, m), h = PrepareTemporalFields(a, d, []);
    h.day = 1;
    var
     u = CalendarDateFromFields(i, h),
     _CalendarDateUntil3 = CalendarDateUntil(i, c, u, s),
     T = _CalendarDateUntil3.years,
     f = _CalendarDateUntil3.months;
    "month" === l.smallestUnit && 1 === l.roundingIncrement
    ||
     (_RoundDuration6 =
       RoundDuration
        (T,
         f,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         l.roundingIncrement,
         l.smallestUnit,
         l.roundingMode,
         c),
      T = _RoundDuration6.years,
      f = _RoundDuration6.months,
      _RoundDuration6);
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * T, n * f, 0, 0, 0, 0, 0, 0, 0, 0);
   }
   function DifferenceTemporalZonedDateTime(e, t, r, o){
    var
     _DifferenceInstant2,
     a = "since" === e ? - 1 : 1,
     i = ToTemporalZonedDateTime(r),
     s = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (s, GetSlot(i, p), "compute difference between dates");
    var
     l = CopyOptions(o),
     d = GetDifferenceSettings(e, l, "datetime", [], "nanosecond", "hour");
    l.largestUnit = d.largestUnit;
    var m = GetSlot(t, n), c = GetSlot(i, n), h, u, T, f, y, I, S, w, D, G;
    if
     ("year" !== d.largestUnit && "month" !== d.largestUnit
      && "week" !== d.largestUnit
      && "day" !== d.largestUnit)
     h = 0,
     u = 0,
     T = 0,
     f = 0,
     _DifferenceInstant2 =
      DifferenceInstant
       (m,
        c,
        d.roundingIncrement,
        d.smallestUnit,
        d.largestUnit,
        d.roundingMode),
     y = _DifferenceInstant2.hours,
     I = _DifferenceInstant2.minutes,
     S = _DifferenceInstant2.seconds,
     w = _DifferenceInstant2.milliseconds,
     D = _DifferenceInstant2.microseconds,
     G = _DifferenceInstant2.nanoseconds;
    else{
     var
      _DifferenceZonedDateT,
      _RoundDuration7,
      _AdjustRoundedDuratio,
      _e28 = GetSlot(t, g);
     if(! TimeZoneEquals(_e28, GetSlot(i, g)))
      throw new
             RangeError
             ("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
     _DifferenceZonedDateT =
      DifferenceZonedDateTime(m, c, _e28, s, d.largestUnit, l),
     h = _DifferenceZonedDateT.years,
     u = _DifferenceZonedDateT.months,
     T = _DifferenceZonedDateT.weeks,
     f = _DifferenceZonedDateT.days,
     y = _DifferenceZonedDateT.hours,
     I = _DifferenceZonedDateT.minutes,
     S = _DifferenceZonedDateT.seconds,
     w = _DifferenceZonedDateT.milliseconds,
     D = _DifferenceZonedDateT.microseconds,
     G = _DifferenceZonedDateT.nanoseconds,
     _RoundDuration7 =
      RoundDuration
       (h,
        u,
        T,
        f,
        y,
        I,
        S,
        w,
        D,
        G,
        d.roundingIncrement,
        d.smallestUnit,
        d.roundingMode,
        t),
     h = _RoundDuration7.years,
     u = _RoundDuration7.months,
     T = _RoundDuration7.weeks,
     f = _RoundDuration7.days,
     y = _RoundDuration7.hours,
     I = _RoundDuration7.minutes,
     S = _RoundDuration7.seconds,
     w = _RoundDuration7.milliseconds,
     D = _RoundDuration7.microseconds,
     G = _RoundDuration7.nanoseconds,
     _AdjustRoundedDuratio =
      AdjustRoundedDurationDays
       (h,
        u,
        T,
        f,
        y,
        I,
        S,
        w,
        D,
        G,
        d.roundingIncrement,
        d.smallestUnit,
        d.roundingMode,
        t),
     h = _AdjustRoundedDuratio.years,
     u = _AdjustRoundedDuratio.months,
     T = _AdjustRoundedDuratio.weeks,
     f = _AdjustRoundedDuratio.days,
     y = _AdjustRoundedDuratio.hours,
     I = _AdjustRoundedDuratio.minutes,
     S = _AdjustRoundedDuratio.seconds,
     w = _AdjustRoundedDuratio.milliseconds,
     D = _AdjustRoundedDuratio.microseconds,
     G = _AdjustRoundedDuratio.nanoseconds;
    }
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (a * h,
             a * u,
             a * T,
             a * f,
             a * y,
             a * I,
             a * S,
             a * w,
             a * D,
             a * G);
   }
   function AddISODate(e, t, r, o, n, a, i, s){
    var
     _BalanceISOYearMonth4,
     _RegulateISODate,
     _BalanceISODate3,
     l = e,
     d = t,
     m = r,
     c = a,
     h = i;
    return l += o,
           d += n,
           _BalanceISOYearMonth4 = BalanceISOYearMonth(l, d),
           l = _BalanceISOYearMonth4.year,
           d = _BalanceISOYearMonth4.month,
           _RegulateISODate = RegulateISODate(l, d, m, s),
           l = _RegulateISODate.year,
           d = _RegulateISODate.month,
           m = _RegulateISODate.day,
           h += 7 * c,
           m += h,
           _BalanceISODate3 = BalanceISODate(l, d, m),
           l = _BalanceISODate3.year,
           d = _BalanceISODate3.month,
           m = _BalanceISODate3.day,
           {year: l, month: d, day: m};
   }
   function AddTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var _BalanceTime3, h = e, u = t, T = r, p = o, f = n, y = a;
    h += i, u += s, T += l, p += d, f += m, y += c;
    var I = 0;
    return _BalanceTime3 = BalanceTime(h, u, T, p, f, y),
           I = _BalanceTime3.deltaDays,
           h = _BalanceTime3.hour,
           u = _BalanceTime3.minute,
           T = _BalanceTime3.second,
           p = _BalanceTime3.millisecond,
           f = _BalanceTime3.microsecond,
           y = _BalanceTime3.nanosecond,
           {deltaDays: I,
            hour: h,
            minute: u,
            second: T,
            millisecond: p,
            microsecond: f,
            nanosecond: y};
   }
   function AddDuration
   (t, r, o, a, i, s, l, d, m, c, h, u, T, f, y, I, w, D, G, v, C){
    var
     O =
       LargerOfTwoTemporalUnits
        (DefaultTemporalLargestUnit(t, r, o, a, i, s, l, d, m, c),
         DefaultTemporalLargestUnit(h, u, T, f, y, I, w, D, G, v)),
     b,
     E,
     M,
     R,
     F,
     Y,
     P,
     Z,
     B,
     N;
    if(C)
     if(IsTemporalDate(C)){
      var
       _CalendarDateUntil4,
       _BalanceDuration6,
       _n10 = GetIntrinsic("%Temporal.Duration%"),
       _S2 = GetSlot(C, p),
       _g = new _n10(t, r, o, a, 0, 0, 0, 0, 0, 0),
       _j = new _n10(h, u, T, f, 0, 0, 0, 0, 0, 0),
       _$ = "string" != typeof _S2 ? GetMethod(_S2, "dateAdd") : void 0,
       _k = CalendarDateAdd(_S2, C, _g, void 0, _$),
       _U = CalendarDateAdd(_S2, _k, _j, void 0, _$),
       _A = LargerOfTwoTemporalUnits("day", O),
       _L = Te(null);
      _L.largestUnit = _A,
      _CalendarDateUntil4 = CalendarDateUntil(_S2, C, _U, _L),
      b = _CalendarDateUntil4.years,
      E = _CalendarDateUntil4.months,
      M = _CalendarDateUntil4.weeks,
      R = _CalendarDateUntil4.days,
      _BalanceDuration6 =
       BalanceDuration
        (R,
         BigInt(i) + BigInt(y),
         BigInt(s) + BigInt(I),
         BigInt(l) + BigInt(w),
         BigInt(d) + BigInt(D),
         BigInt(m) + BigInt(G),
         BigInt(c) + BigInt(v),
         O),
      R = _BalanceDuration6.days,
      F = _BalanceDuration6.hours,
      Y = _BalanceDuration6.minutes,
      P = _BalanceDuration6.seconds,
      Z = _BalanceDuration6.milliseconds,
      B = _BalanceDuration6.microseconds,
      N = _BalanceDuration6.nanoseconds;
     }
     else{
      var
       _DifferenceInstant3,
       _DifferenceZonedDateT2,
       _e29 = GetIntrinsic("%Temporal.Instant%"),
       _j2 = GetSlot(C, g),
       _$2 = GetSlot(C, p),
       _k2 =
         AddZonedDateTime
          (GetSlot(C, S), _j2, _$2, t, r, o, a, i, s, l, d, m, c),
       _U2 =
         AddZonedDateTime
          (new _e29(_k2), _j2, _$2, h, u, T, f, y, I, w, D, G, v);
      "year" !== O && "month" !== O && "week" !== O && "day" !== O
       ? (b
         = 0,
         E = 0,
         M = 0,
         R = 0,
         _DifferenceInstant3 =
          DifferenceInstant
           (GetSlot(C, n), _U2, 1, "nanosecond", O, "halfExpand"),
         F = _DifferenceInstant3.hours,
         Y = _DifferenceInstant3.minutes,
         P = _DifferenceInstant3.seconds,
         Z = _DifferenceInstant3.milliseconds,
         B = _DifferenceInstant3.microseconds,
         N = _DifferenceInstant3.nanoseconds)
       : (_DifferenceZonedDateT2
         = DifferenceZonedDateTime(GetSlot(C, n), _U2, _j2, _$2, O, Te(null)),
         b = _DifferenceZonedDateT2.years,
         E = _DifferenceZonedDateT2.months,
         M = _DifferenceZonedDateT2.weeks,
         R = _DifferenceZonedDateT2.days,
         F = _DifferenceZonedDateT2.hours,
         Y = _DifferenceZonedDateT2.minutes,
         P = _DifferenceZonedDateT2.seconds,
         Z = _DifferenceZonedDateT2.milliseconds,
         B = _DifferenceZonedDateT2.microseconds,
         N = _DifferenceZonedDateT2.nanoseconds,
         _DifferenceZonedDateT2);
     }
    else{
     var _BalanceDuration7;
     if("year" === O || "month" === O || "week" === O)
      throw new
             RangeError
             ("relativeTo is required for years, months, or weeks arithmetic");
     b = E = M = 0,
     _BalanceDuration7 =
      BalanceDuration
       (a + f,
        BigInt(i) + BigInt(y),
        BigInt(s) + BigInt(I),
        BigInt(l) + BigInt(w),
        BigInt(d) + BigInt(D),
        BigInt(m) + BigInt(G),
        BigInt(c) + BigInt(v),
        O),
     R = _BalanceDuration7.days,
     F = _BalanceDuration7.hours,
     Y = _BalanceDuration7.minutes,
     P = _BalanceDuration7.seconds,
     Z = _BalanceDuration7.milliseconds,
     B = _BalanceDuration7.microseconds,
     N = _BalanceDuration7.nanoseconds;
    }
    return RejectDuration(b, E, M, R, F, Y, P, Z, B, N),
           {years: b,
            months: E,
            weeks: M,
            days: R,
            hours: F,
            minutes: Y,
            seconds: P,
            milliseconds: Z,
            microseconds: B,
            nanoseconds: N};
   }
   function AddInstant(t, r, o, n, a, i, s){
    var l = Ie;
    l = l + BigInt(s),
    l = l + BigInt(i) * De,
    l = l + BigInt(a) * Ge,
    l = l + BigInt(n) * ve,
    l = l + BigInt(o) * 60000000000n,
    l = l + BigInt(r) * 3600000000000n;
    var d = t + l;
    return ValidateEpochNanoseconds(d), d;
   }
   function AddDateTime
   (e, t, r, o, n, a, d, m, c, h, u, T, p, f, y, I, S, g, w, D, G){
    var
     v = f,
     _AddTime = AddTime(o, n, a, d, m, c, y, I, S, g, w, D),
     C = _AddTime.deltaDays,
     O = _AddTime.hour,
     b = _AddTime.minute,
     E = _AddTime.second,
     M = _AddTime.millisecond,
     R = _AddTime.microsecond,
     F = _AddTime.nanosecond;
    v += C;
    var
     Y = GetIntrinsic("%Temporal.Duration%"),
     P =
       CalendarDateAdd
        (h,
         CreateTemporalDate(e, t, r, h),
         new Y(u, T, p, v, 0, 0, 0, 0, 0, 0),
         G);
    return {year: GetSlot(P, i),
            month: GetSlot(P, s),
            day: GetSlot(P, l),
            hour: O,
            minute: b,
            second: E,
            millisecond: M,
            microsecond: R,
            nanosecond: F};
   }
   function AddZonedDateTime(e, t, r, o, a, p, f, y, I, S, g, w, D, G){
    var v = GetIntrinsic("%Temporal.Duration%");
    if(0 === DurationSign(o, a, p, f, 0, 0, 0, 0, 0, 0))
     return AddInstant(GetSlot(e, n), y, I, S, g, w, D);
    var
     C = GetPlainDateTimeFor(t, e, r),
     O =
       CalendarDateAdd
        (r,
         CreateTemporalDate(GetSlot(C, i), GetSlot(C, s), GetSlot(C, l), r),
         new v(o, a, p, f, 0, 0, 0, 0, 0, 0),
         G),
     b =
       CreateTemporalDateTime
        (GetSlot(O, i),
         GetSlot(O, s),
         GetSlot(O, l),
         GetSlot(C, d),
         GetSlot(C, m),
         GetSlot(C, c),
         GetSlot(C, h),
         GetSlot(C, u),
         GetSlot(C, T),
         r);
    return AddInstant
            (GetSlot(GetInstantFor(t, b, "compatible"), n), y, I, S, g, w, D);
   }
   function AddDurationToOrSubtractDurationFromDuration(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe2 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe2.years,
     i = _ToTemporalDurationRe2.months,
     s = _ToTemporalDurationRe2.weeks,
     l = _ToTemporalDurationRe2.days,
     d = _ToTemporalDurationRe2.hours,
     m = _ToTemporalDurationRe2.minutes,
     c = _ToTemporalDurationRe2.seconds,
     h = _ToTemporalDurationRe2.milliseconds,
     u = _ToTemporalDurationRe2.microseconds,
     T = _ToTemporalDurationRe2.nanoseconds,
     p = ToRelativeTemporalObject(GetOptionsObject(o)),
     _AddDuration =
       AddDuration
        (GetSlot(t, w),
         GetSlot(t, D),
         GetSlot(t, G),
         GetSlot(t, v),
         GetSlot(t, C),
         GetSlot(t, O),
         GetSlot(t, b),
         GetSlot(t, E),
         GetSlot(t, M),
         GetSlot(t, R),
         n * a,
         n * i,
         n * s,
         n * l,
         n * d,
         n * m,
         n * c,
         n * h,
         n * u,
         n * T,
         p);
    a = _AddDuration.years;
    i = _AddDuration.months;
    s = _AddDuration.weeks;
    l = _AddDuration.days;
    d = _AddDuration.hours;
    m = _AddDuration.minutes;
    c = _AddDuration.seconds;
    h = _AddDuration.milliseconds;
    u = _AddDuration.microseconds;
    T = _AddDuration.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (a, i, s, l, d, m, c, h, u, T);
   }
   function AddDurationToOrSubtractDurationFromInstant(e, t, r){
    var
     o = "subtract" === e ? - 1 : 1,
     _ToLimitedTemporalDur =
       function(e, t){
         var
          r = ToTemporalDurationRecord(e),
          _iterator14 = _createForOfIteratorHelper(t),
          _step14;
         try{
          for(_iterator14.s(); ! (_step14 = _iterator14.n()).done;){
           var _e30 = _step14.value;
           if(0 !== r[_e30])
            throw new
                   RangeError
                   ("Duration field ".concat
                     (_e30,
                      " not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead."));
          }
         }
         catch(err){_iterator14.e(err);}
         finally{_iterator14.f();}
         return r;
        }
        (r, ["years", "months", "weeks", "days"]),
     a = _ToLimitedTemporalDur.hours,
     i = _ToLimitedTemporalDur.minutes,
     s = _ToLimitedTemporalDur.seconds,
     l = _ToLimitedTemporalDur.milliseconds,
     d = _ToLimitedTemporalDur.microseconds,
     m = _ToLimitedTemporalDur.nanoseconds,
     c = AddInstant(GetSlot(t, n), o * a, o * i, o * s, o * l, o * d, o * m);
    return new (GetIntrinsic("%Temporal.Instant%"))(c);
   }
   function AddDurationToOrSubtractDurationFromPlainDateTime(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe3 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe3.years,
     f = _ToTemporalDurationRe3.months,
     y = _ToTemporalDurationRe3.weeks,
     I = _ToTemporalDurationRe3.days,
     S = _ToTemporalDurationRe3.hours,
     g = _ToTemporalDurationRe3.minutes,
     w = _ToTemporalDurationRe3.seconds,
     D = _ToTemporalDurationRe3.milliseconds,
     G = _ToTemporalDurationRe3.microseconds,
     v = _ToTemporalDurationRe3.nanoseconds,
     C = GetOptionsObject(o),
     O = GetSlot(t, p),
     _AddDateTime =
       AddDateTime
        (GetSlot(t, i),
         GetSlot(t, s),
         GetSlot(t, l),
         GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         O,
         n * a,
         n * f,
         n * y,
         n * I,
         n * S,
         n * g,
         n * w,
         n * D,
         n * G,
         n * v,
         C),
     b = _AddDateTime.year,
     E = _AddDateTime.month,
     M = _AddDateTime.day,
     R = _AddDateTime.hour,
     F = _AddDateTime.minute,
     Y = _AddDateTime.second,
     P = _AddDateTime.millisecond,
     Z = _AddDateTime.microsecond,
     B = _AddDateTime.nanosecond;
    return CreateTemporalDateTime(b, E, M, R, F, Y, P, Z, B, O);
   }
   function AddDurationToOrSubtractDurationFromPlainTime(e, t, r){
    var
     o = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe4 = ToTemporalDurationRecord(r),
     n = _ToTemporalDurationRe4.hours,
     a = _ToTemporalDurationRe4.minutes,
     i = _ToTemporalDurationRe4.seconds,
     s = _ToTemporalDurationRe4.milliseconds,
     l = _ToTemporalDurationRe4.microseconds,
     p = _ToTemporalDurationRe4.nanoseconds,
     _AddTime2 =
       AddTime
        (GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         o * n,
         o * a,
         o * i,
         o * s,
         o * l,
         o * p),
     f = _AddTime2.hour,
     y = _AddTime2.minute,
     I = _AddTime2.second,
     S = _AddTime2.millisecond,
     g = _AddTime2.microsecond,
     w = _AddTime2.nanosecond,
     _RegulateTime3 = RegulateTime(f, y, I, S, g, w, "reject");
    f = _RegulateTime3.hour;
    y = _RegulateTime3.minute;
    I = _RegulateTime3.second;
    S = _RegulateTime3.millisecond;
    g = _RegulateTime3.microsecond;
    w = _RegulateTime3.nanosecond;
    return new (GetIntrinsic("%Temporal.PlainTime%"))(f, y, I, S, g, w);
   }
   function AddDurationToOrSubtractDurationFromPlainYearMonth(e, t, r, o){
    var n = ToTemporalDurationRecord(r);
    "subtract" === e
    &&
     (n =
      {years: - n.years,
       months: - n.months,
       weeks: - n.weeks,
       days: - n.days,
       hours: - n.hours,
       minutes: - n.minutes,
       seconds: - n.seconds,
       milliseconds: - n.milliseconds,
       microseconds: - n.microseconds,
       nanoseconds: - n.nanoseconds});
    var
     _n11 = n,
     a = _n11.years,
     i = _n11.months,
     s = _n11.weeks,
     l = _n11.days,
     d = _n11.hours,
     m = _n11.minutes,
     c = _n11.seconds,
     h = _n11.milliseconds,
     u = _n11.microseconds,
     T = _n11.nanoseconds,
     _BalanceDuration8 = BalanceDuration(l, d, m, c, h, u, T, "day");
    l = _BalanceDuration8.days;
    var
     f = GetOptionsObject(o),
     y = GetSlot(t, p),
     I = CalendarFields(y, ["monthCode", "year"]),
     S = PrepareTemporalFields(t, I, []),
     g = Te(null);
    CopyDataProperties(g, S, []), S.day = 1;
    var
     w = CalendarDateFromFields(y, S),
     D = DurationSign(a, i, s, l, 0, 0, 0, 0, 0, 0),
     G = GetMethod(y, "dateAdd"),
     v = GetIntrinsic("%Temporal.Duration%");
    if(D < 0){
     var
      _e31 =
        CalendarDateAdd(y, w, new v(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G),
      _t30 =
        CalendarDateAdd
         (y, _e31, new v(0, 0, 0, - 1, 0, 0, 0, 0, 0, 0), void 0, G);
     g.day = CalendarDay(y, _t30), w = CalendarDateFromFields(y, g);
    }
    var C = new v(a, i, s, l, 0, 0, 0, 0, 0, 0), O = CopyOptions(f);
    return CalendarYearMonthFromFields
            (y,
             PrepareTemporalFields(CalendarDateAdd(y, w, C, f, G), I, []),
             O);
   }
   function AddDurationToOrSubtractDurationFromZonedDateTime(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe5 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe5.years,
     i = _ToTemporalDurationRe5.months,
     s = _ToTemporalDurationRe5.weeks,
     l = _ToTemporalDurationRe5.days,
     d = _ToTemporalDurationRe5.hours,
     m = _ToTemporalDurationRe5.minutes,
     c = _ToTemporalDurationRe5.seconds,
     h = _ToTemporalDurationRe5.milliseconds,
     u = _ToTemporalDurationRe5.microseconds,
     T = _ToTemporalDurationRe5.nanoseconds,
     f = GetOptionsObject(o),
     y = GetSlot(t, g),
     I = GetSlot(t, p);
    return CreateTemporalZonedDateTime
            (AddZonedDateTime
              (GetSlot(t, S),
               y,
               I,
               n * a,
               n * i,
               n * s,
               n * l,
               n * d,
               n * m,
               n * c,
               n * h,
               n * u,
               n * T,
               f),
             y,
             I);
   }
   function RoundNumberToIncrement(t, r, o){
    if(r === Se) return t;
    var
     _divmod21 = divmod(t, r),
     n = _divmod21.quotient,
     a = _divmod21.remainder;
    if(a === Ie) return t;
    var i = a < Ie ? - 1 : 1, s = abs(a * 2n), l = s === r, d = s > r;
    switch(o){
      case "ceil":
       i > 0 && (n = n + BigInt(i)); break;
      case "floor":
       i < 0 && (n = n + BigInt(i)); break;
      case "expand":
       n = n + BigInt(i); break;
      case "trunc": break;
      case "halfCeil":
       (d || l && i > 0) && (n = n + BigInt(i)); break;
      case "halfFloor":
       (d || l && i < 0) && (n = n + BigInt(i)); break;
      case "halfExpand":
       (d || l) && (n = n + BigInt(i)); break;
      case "halfTrunc":
       d && (n = n + BigInt(i)); break;
      case "halfEven":
       (d || l && 1 === Number(abs(n) % 2n)) && (n = n + BigInt(i));
    }
    return n * r;
   }
   function RoundInstant(t, r, o, n){
    var
     _NonNegativeBigIntDiv7 = NonNegativeBigIntDivmod(t, Ee),
     a = _NonNegativeBigIntDiv7.remainder,
     i = t - a,
     s = RoundNumberToIncrement(a, BigInt(_e[o] * r), n);
    return i + s;
   }
   function RoundISODateTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var
     h =
       arguments.length > 12 && arguments[12] !== undefined
        ? arguments[12]
        : 864e11,
     _RoundTime = RoundTime(o, n, a, i, s, l, d, m, c, h),
     u = _RoundTime.deltaDays,
     T = _RoundTime.hour,
     p = _RoundTime.minute,
     f = _RoundTime.second,
     y = _RoundTime.millisecond,
     I = _RoundTime.microsecond,
     S = _RoundTime.nanosecond,
     _BalanceISODate4 = BalanceISODate(e, t, r + u),
     g = _BalanceISODate4.year,
     w = _BalanceISODate4.month,
     D = _BalanceISODate4.day;
    return {year: g,
            month: w,
            day: D,
            hour: T,
            minute: p,
            second: f,
            millisecond: y,
            microsecond: I,
            nanosecond: S};
   }
   function RoundTime(t, r, o, n, a, i, s, l, d){
    var
     m =
       arguments.length > 9 && arguments[9] !== undefined
        ? arguments[9]
        : 864e11,
     c = Ie;
    switch(l){
      case "day":
      case "hour":
       c = BigInt(t);
      case "minute":
       c = c * ge + BigInt(r);
      case "second":
       c = c * ge + BigInt(o);
      case "millisecond":
       c = c * De + BigInt(n);
      case "microsecond":
       c = c * De + BigInt(a);
      case "nanosecond":
       c = c * De + BigInt(i);
    }
    var
     h = "day" === l ? m : _e[l],
     u = RoundNumberToIncrement(c, BigInt(h * s), d),
     T = Number(u / BigInt(h));
    switch(l){
      case "day":
       return {deltaDays: T,
               hour: 0,
               minute: 0,
               second: 0,
               millisecond: 0,
               microsecond: 0,
               nanosecond: 0};
      case "hour":
       return BalanceTime(T, 0, 0, 0, 0, 0);
      case "minute":
       return BalanceTime(t, T, 0, 0, 0, 0);
      case "second":
       return BalanceTime(t, r, T, 0, 0, 0);
      case "millisecond":
       return BalanceTime(t, r, o, T, 0, 0);
      case "microsecond":
       return BalanceTime(t, r, o, n, T, 0);
      case "nanosecond":
       return BalanceTime(t, r, o, n, a, T);
      default: throw new Error("Invalid unit ".concat(l));
    }
   }
   function DaysUntil(e, t){
    return DifferenceISODate
            (GetSlot(e, i),
             GetSlot(e, s),
             GetSlot(e, l),
             GetSlot(t, i),
             GetSlot(t, s),
             GetSlot(t, l),
             "day").days;
   }
   function MoveRelativeDate(e, t, r, o){
    var n = CalendarDateAdd(e, t, r, void 0, o);
    return {relativeTo: n, days: DaysUntil(t, n)};
   }
   function MoveRelativeZonedDateTime(e, t, r, o, n){
    var a = GetSlot(e, g), i = GetSlot(e, p);
    return CreateTemporalZonedDateTime
            (AddZonedDateTime
              (GetSlot(e, S), a, i, t, r, o, n, 0, 0, 0, 0, 0, 0),
             a,
             i);
   }
   function AdjustRoundedDurationDays
   (t, r, o, n, a, i, s, l, d, m, c, h, u, T){
    var
     _AddDuration2,
     _BalanceDuration9,
     f = t,
     y = r,
     I = o,
     w = n,
     D = a,
     G = i,
     v = s,
     C = l,
     O = d,
     b = m;
    if
     (! IsTemporalZonedDateTime(T) || "year" === h || "month" === h
      || "week" === h
      || "day" === h
      || "nanosecond" === h && 1 === c)
     return {years: f,
             months: y,
             weeks: I,
             days: w,
             hours: D,
             minutes: G,
             seconds: v,
             milliseconds: C,
             microseconds: O,
             nanoseconds: b};
    var
     E = TotalDurationNanoseconds(0, D, G, v, C, O, b, 0),
     M = se(Number(E)),
     R = GetSlot(T, g),
     F = GetSlot(T, p),
     Y = AddZonedDateTime(GetSlot(T, S), R, F, f, y, I, w, 0, 0, 0, 0, 0, 0),
     P =
       AddZonedDateTime
        (new (GetIntrinsic("%Temporal.Instant%"))(Y),
         R,
         F,
         0,
         0,
         0,
         M,
         0,
         0,
         0,
         0,
         0,
         0),
     Z = P - Y;
    return (E - Z) * BigInt(M) >= Ie
           &&
            (_AddDuration2 =
              AddDuration
               (f, y, I, w, 0, 0, 0, 0, 0, 0, 0, 0, 0, M, 0, 0, 0, 0, 0, 0, T),
             f = _AddDuration2.years,
             y = _AddDuration2.months,
             I = _AddDuration2.weeks,
             w = _AddDuration2.days,
             E = RoundInstant(E - Z, c, h, u),
             _BalanceDuration9 =
              BalanceDuration(0, 0, 0, 0, 0, 0, Number(E), "hour"),
             D = _BalanceDuration9.hours,
             G = _BalanceDuration9.minutes,
             v = _BalanceDuration9.seconds,
             C = _BalanceDuration9.milliseconds,
             O = _BalanceDuration9.microseconds,
             b = _BalanceDuration9.nanoseconds),
           {years: f,
            months: y,
            weeks: I,
            days: w,
            hours: D,
            minutes: G,
            seconds: v,
            milliseconds: C,
            microseconds: O,
            nanoseconds: b};
   }
   function RoundDuration(t, r, o, n, a, i, s, l, d, m, c, h, u, T){
    var
     f = t,
     y = r,
     I = o,
     S = n,
     g = a,
     w = i,
     D = s,
     G = l,
     v = d,
     C = BigInt(m),
     O = GetIntrinsic("%Temporal.Duration%"),
     b,
     E,
     M,
     R,
     F = T;
    if(F){
     if(IsTemporalZonedDateTime(F))
      E = F, F = ToTemporalDate(F);
     else if(! IsTemporalDate(F))
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
     b = GetSlot(F, p);
    }
    if("year" === h || "month" === h || "week" === h || "day" === h){
     var _NanosecondsToDays3, _t31, _r45, _o15;
     C = TotalDurationNanoseconds(0, g, w, D, G, v, m, 0),
     E && (_t31 = MoveRelativeZonedDateTime(E, f, y, I, S)),
     _NanosecondsToDays3 = NanosecondsToDays(C, _t31),
     _r45 = _NanosecondsToDays3.days,
     C = _NanosecondsToDays3.nanoseconds,
     _o15 = _NanosecondsToDays3.dayLengthNs,
     M = BigInt(_o15),
     S += _r45,
     g = w = D = G = v = 0;
    }
    switch(h){
      case "year":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for years rounding");
        var
         _t32 = new O(f),
         _r46 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _o16 = CalendarDateAdd(b, F, _t32, void 0, _r46),
         _n12 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r46);
        F = _o16, S += DaysUntil(_o16, _n12);
        var
         _a8 = CalendarDateAdd(b, F, new O(0, 0, 0, S), void 0, _r46),
         _i12 = Te(null);
        _i12.largestUnit = "year";
        var _s4 = CalendarDateUntil(b, F, _a8, _i12).years;
        f += _s4;
        var _l5 = F;
        F = CalendarDateAdd(b, F, new O(_s4), void 0, _r46);
        S -= DaysUntil(_l5, F);
        var
         _d5 = new O(S < 0 ? - 1 : 1),
         _MoveRelativeDate6 = MoveRelativeDate(b, F, _d5, _r46),
         _m5 = _MoveRelativeDate6.days;
        _m5 = ae(_m5);
        var _h2 = BigInt(_m5) * M;
        C = _h2 * BigInt(f) + BigInt(S) * M + C;
        var _T2 = RoundNumberToIncrement(C, _h2 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _h2),
        f = Number(_T2 / _h2),
        C = Ie,
        y = I = S = 0;
        break;
       }
      case "month":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for months rounding");
        var
         _t33 = new O(f, y),
         _r47 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _o17 = CalendarDateAdd(b, F, _t33, void 0, _r47),
         _n13 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r47);
        F = _o17, S += DaysUntil(_o17, _n13);
        var _a9 = se(S), _i13 = new O(0, S < 0 ? - 1 : 1), _s5;
        for
        (_MoveRelativeDate7 = MoveRelativeDate(b, F, _i13, _r47),
         F = _MoveRelativeDate7.relativeTo,
         _s5 = _MoveRelativeDate7.days,
         _MoveRelativeDate7;
         ae(S) >= ae(_s5);){
         var _MoveRelativeDate7, _MoveRelativeDate8;
         y += _a9,
         S -= _s5,
         _MoveRelativeDate8 = MoveRelativeDate(b, F, _i13, _r47),
         F = _MoveRelativeDate8.relativeTo,
         _s5 = _MoveRelativeDate8.days;
        }
        _s5 = ae(_s5);
        var _l6 = BigInt(_s5) * M;
        C = _l6 * BigInt(y) + BigInt(S) * M + C;
        var _d6 = RoundNumberToIncrement(C, _l6 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _l6),
        y = Number(_d6 / _l6),
        C = Ie,
        I = S = 0;
        break;
       }
      case "week":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for weeks rounding");
        var
         _t34 = se(S),
         _r48 = new O(0, 0, S < 0 ? - 1 : 1),
         _o18 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _n14;
        for
        (_MoveRelativeDate9 = MoveRelativeDate(b, F, _r48, _o18),
         F = _MoveRelativeDate9.relativeTo,
         _n14 = _MoveRelativeDate9.days,
         _MoveRelativeDate9;
         ae(S) >= ae(_n14);){
         var _MoveRelativeDate9, _MoveRelativeDate10;
         I += _t34,
         S -= _n14,
         _MoveRelativeDate10 = MoveRelativeDate(b, F, _r48, _o18),
         F = _MoveRelativeDate10.relativeTo,
         _n14 = _MoveRelativeDate10.days;
        }
        _n14 = ae(_n14);
        var _a10 = BigInt(_n14) * M;
        C = _a10 * BigInt(I) + BigInt(S) * M + C;
        var _i14 = RoundNumberToIncrement(C, _a10 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _a10),
        I = Number(_i14 / _a10),
        C = Ie,
        S = 0;
        break;
       }
      case "day":
       {
        var _t35 = M;
        C = _t35 * BigInt(S) + C;
        var _r49 = RoundNumberToIncrement(C, _t35 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _t35), S = Number(_r49 / _t35), C = Ie;
        break;
       }
      case "hour":
       {
        var _t36 = 36e11, _r50 = BigInt(g) * 3600000000000n;
        _r50 = _r50 + BigInt(w) * 60000000000n,
        _r50 = _r50 + BigInt(D) * ve,
        _r50 = _r50 + BigInt(G) * Ge,
        _r50 = _r50 + BigInt(v) * De,
        _r50 = _r50 + C,
        R = BigIntDivideToNumber(_r50, BigInt(_t36));
        var _o19 = RoundNumberToIncrement(_r50, BigInt(_t36 * c), u);
        g = Number(_o19 / BigInt(_t36)), C = Ie, w = D = G = v = 0;
        break;
       }
      case "minute":
       {
        var _t37 = 6e10, _r51 = BigInt(w) * 60000000000n;
        _r51 = _r51 + BigInt(D) * ve,
        _r51 = _r51 + BigInt(G) * Ge,
        _r51 = _r51 + BigInt(v) * De,
        _r51 = _r51 + C,
        R = BigIntDivideToNumber(_r51, BigInt(_t37));
        var _o20 = RoundNumberToIncrement(_r51, BigInt(_t37 * c), u);
        w = Number(_o20 / BigInt(_t37)), C = Ie, D = G = v = 0;
        break;
       }
      case "second":
       {
        var _t38 = 1e9, _r52 = BigInt(D) * ve;
        _r52 = _r52 + BigInt(G) * Ge,
        _r52 = _r52 + BigInt(v) * De,
        _r52 = _r52 + C,
        R = BigIntDivideToNumber(_r52, BigInt(_t38));
        var _o21 = RoundNumberToIncrement(_r52, BigInt(_t38 * c), u);
        D = Number(_o21 / BigInt(_t38)), C = Ie, G = v = 0;
        break;
       }
      case "millisecond":
       {
        var _t39 = 1e6, _r53 = BigInt(G) * Ge;
        _r53 = _r53 + BigInt(v) * De,
        _r53 = _r53 + C,
        R = BigIntDivideToNumber(_r53, BigInt(_t39));
        var _o22 = RoundNumberToIncrement(_r53, BigInt(_t39 * c), u);
        G = Number(_o22 / BigInt(_t39)), C = Ie, v = 0;
        break;
       }
      case "microsecond":
       {
        var _t40 = 1e3, _r54 = BigInt(v) * De;
        _r54 = _r54 + C, R = BigIntDivideToNumber(_r54, BigInt(_t40));
        var _o23 = RoundNumberToIncrement(_r54, BigInt(_t40 * c), u);
        v = Number(_o23 / BigInt(_t40)), C = Ie;
        break;
       }
      case "nanosecond":
       R = Number(C), C = RoundNumberToIncrement(BigInt(C), BigInt(c), u);
    }
    return {years: f,
            months: y,
            weeks: I,
            days: S,
            hours: g,
            minutes: w,
            seconds: D,
            milliseconds: G,
            microseconds: v,
            nanoseconds: Number(C),
            total: R};
   }
   function CompareISODate(e, t, r, o, n, a){
    for
    (var _i15 = 0, _arr5 = [[e, o], [t, n], [r, a]];
     _i15 < _arr5.length;
     _i15++){
     var
      _arr5$_i = _slicedToArray(_arr5[_i15], 2),
      _i16 = _arr5$_i[0],
      _s6 = _arr5$_i[1];
     if(_i16 !== _s6) return ComparisonResult(_i16 - _s6);
    }
    return 0;
   }
   function NonNegativeBigIntDivmod(t, r){
    var
     _divmod22 = divmod(t, r),
     o = _divmod22.quotient,
     n = _divmod22.remainder;
    return n < Ie && (o = o - Se, n = n + r), {quotient: o, remainder: n};
   }
   function BigIntFloorDiv(t, r){
    var
     _divmod23 = divmod(t, r),
     o = _divmod23.quotient,
     n = _divmod23.remainder;
    return isZero(n) || ! isNegativeJSBI(t) == ! isNegativeJSBI(r)
            ? o
            : o - Se;
   }
   function BigIntDivideToNumber(t, r){
    var
     _divmod24 = divmod(t, r),
     o = _divmod24.quotient,
     n = _divmod24.remainder;
    return Number(o) + Number(n) / Number(r);
   }
   function ToBigIntExternal(e){
    var t = ToBigInt(e);
    return void 0 !== globalThis.BigInt
            ? globalThis.BigInt(t.toString(10))
            : t;
   }
   function ToBigInt(t){
    var r = t;
    if("object" == _typeof(t)){
     var _e32 = t[Symbol.toPrimitive];
     _e32 && "function" == typeof _e32 && (r = fe(_e32, t, ["number"]));
    }
    if("number" == typeof r)
     throw new TypeError("cannot convert number to bigint");
    return "bigint" == typeof r ? BigInt(r.toString(10)) : BigInt(r);
   }
   var
    Ve =
      function(){
        var t = BigInt(Date.now() % 1e6);
        return function(){
         var r = BigInt(Date.now()), o = r * Ge + t;
         return t = r % Ge, o > Re ? Re : o < Me ? Me : o;};
       }
       ();
   function DefaultTimeZone(){return new re().resolvedOptions().timeZone;}
   function ComparisonResult(e){return e < 0 ? - 1 : e > 0 ? 1 : e;}
   function GetOptionsObject(e){
    if(void 0 === e) return Te(null);
    if(IsObject(e) && null !== e) return e;
    throw new
           TypeError
           ("Options parameter must be an object, not "
            + (null === e ? "null" : "" + _typeof(e)));
   }
   function CreateOnePropObject(e, t){var r = Te(null); return r[e] = t, r;}
   function CopyOptions(e){
    var t = Te(null);
    return CopyDataProperties(t, GetOptionsObject(e), []), t;
   }
   function GetOption(e, t, r, o){
    var n = e[t];
    if(void 0 !== n){
     if(n = ToString(n), ! r.includes(n))
      throw new
             RangeError
             ("".concat(t, " must be one of ").concat(r.join(", "), ", not ").concat
               (n));
     return n;
    }
    return o;
   }
   function IsBuiltinCalendar(e){return je.includes(ASCIILowercase(e));}
   function ASCIILowercase(e){
    return e.replace
            (/[A-Z]/g,
             function(e){
              var t = e.charCodeAt(0);
              return String.fromCharCode(t + 32);
             });
   }
   var ze = new RegExp("^".concat(W.source, "$"));
   function bisect(t, r, o){
    var
     n =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : t(r),
     a =
       arguments.length > 4 && arguments[4] !== undefined
        ? arguments[4]
        : t(o),
     i = BigInt(r),
     s = BigInt(o),
     l = n,
     d = a;
    for(; s - i > Se;){
     var _r55 = (i + s) / 2n, _o24 = t(_r55);
     if(_o24 === l)
      i = _r55, l = _o24;
     else{
      if(_o24 !== d)
       throw new
              Error
              ("invalid state in bisection ".concat(l, " - ").concat
                 (_o24, " - ").concat
                (d));
      s = _r55, d = _o24;
     }
    }
    return s;
   }
   var
    _e =
      {hour: 36e11,
       minute: 6e10,
       second: 1e9,
       millisecond: 1e6,
       microsecond: 1e3,
       nanosecond: 1},
    Je = Symbol("date"),
    Ke = Symbol("ym"),
    Xe = Symbol("md"),
    Qe = Symbol("time"),
    et = Symbol("datetime"),
    tt = Symbol("instant"),
    rt = Symbol("original"),
    ot = Symbol("timezone"),
    nt = Symbol("calendar-id"),
    at = Symbol("locale"),
    it = Symbol("options"),
    descriptor =
      function(e){
       return {value: e, enumerable: ! 0, writable: ! 1, configurable: ! 0};
      },
    st = globalThis.Intl.DateTimeFormat,
    lt = Object.assign,
    dt = Object.prototype.hasOwnProperty,
    mt = Reflect.apply;
   function getPropLazy(e, t){
    var r = e[t];
    return "function" == typeof r && (r = new st(e[at], r(e[it])), e[t] = r),
           r;
   }
   function DateTimeFormatImpl(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if(! (this instanceof DateTimeFormatImpl))
     return new DateTimeFormatImpl(e, t);
    var
     r = void 0 !== t,
     o = r ? lt({}, t) : {},
     n = new st(e, o),
     a = n.resolvedOptions();
    if(r){
     var _e33 = lt({}, a);
     for(var _t41 in _e33) mt(dt, o, [_t41]) || delete _e33[_t41];
     this[it] = _e33;
    }
    else
     this[it] = o;
    this[at] = a.locale,
    this[rt] = n,
    this[ot] = a.timeZone,
    this[nt] = a.calendar,
    this[Je] = dateAmend,
    this[Ke] = yearMonthAmend,
    this[Xe] = monthDayAmend,
    this[Qe] = timeAmend,
    this[et] = datetimeAmend,
    this[tt] = instantAmend;
   }
   Object.defineProperty
    (DateTimeFormatImpl, "name", {writable: ! 0, value: "DateTimeFormat"}),
   DateTimeFormatImpl.supportedLocalesOf =
    function(e, t){return st.supportedLocalesOf(e, t);};
   var
    ct =
      {resolvedOptions:
       descriptor(function(){return this[rt].resolvedOptions();}),
       format:
       descriptor
        (function(e){
          var
           _this$rt,
           _extractOverrides = extractOverrides(e, this),
           r = _extractOverrides.instant,
           o = _extractOverrides.formatter;
          if(r && o) return o.format(r.epochMilliseconds);
          for
          (var
            _len2 = arguments.length,
            t = new Array(_len2 > 1 ? _len2 - 1 : 0),
            _key2 = 1;
           _key2 < _len2;
           _key2++)
           t[_key2 - 1] = arguments[_key2];
          return (_this$rt = this[rt]).format.apply(_this$rt, [e].concat(t));
         }),
       formatRange:
       descriptor
        (function(e, t){
          if(isTemporalObject(e) || isTemporalObject(t)){
           if(! sameTemporalType(e, t))
            throw new
                   TypeError
                   ("Intl.DateTimeFormat.formatRange accepts two values of the same type");
           var
            _extractOverrides2 = extractOverrides(e, this),
            _r56 = _extractOverrides2.instant,
            _o25 = _extractOverrides2.formatter,
            _extractOverrides3 = extractOverrides(t, this),
            _n15 = _extractOverrides3.instant,
            _a11 = _extractOverrides3.formatter;
           if(_r56 && _n15 && _o25 && _a11 && _o25 === _a11)
            return _o25.formatRange
                    (_r56.epochMilliseconds, _n15.epochMilliseconds);
          }
          return this[rt].formatRange(e, t);
         })};
   "formatToParts" in st.prototype
   &&
    (ct.formatToParts =
     descriptor
      (function(e){
        var
         _this$rt2,
         _extractOverrides4 = extractOverrides(e, this),
         r = _extractOverrides4.instant,
         o = _extractOverrides4.formatter;
        if(r && o) return o.formatToParts(r.epochMilliseconds);
        for
        (var
          _len3 = arguments.length,
          t = new Array(_len3 > 1 ? _len3 - 1 : 0),
          _key3 = 1;
         _key3 < _len3;
         _key3++)
         t[_key3 - 1] = arguments[_key3];
        return (_this$rt2 = this[rt]).formatToParts.apply
                (_this$rt2, [e].concat(t));
       })),
   "formatRangeToParts" in st.prototype
   &&
    (ct.formatRangeToParts =
     descriptor
      (function(e, t){
        if(isTemporalObject(e) || isTemporalObject(t)){
         if(! sameTemporalType(e, t))
          throw new
                 TypeError
                 ("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
         var
          _extractOverrides5 = extractOverrides(e, this),
          _r57 = _extractOverrides5.instant,
          _o26 = _extractOverrides5.formatter,
          _extractOverrides6 = extractOverrides(t, this),
          _n16 = _extractOverrides6.instant,
          _a12 = _extractOverrides6.formatter;
         if(_r57 && _n16 && _o26 && _a12 && _o26 === _a12)
          return _o26.formatRangeToParts
                  (_r57.epochMilliseconds, _n16.epochMilliseconds);
        }
        return this[rt].formatRangeToParts(e, t);
       })),
   DateTimeFormatImpl.prototype = Object.create(st.prototype, ct),
   Object.defineProperty
    (DateTimeFormatImpl,
     "prototype",
     {writable: ! 1, enumerable: ! 1, configurable: ! 1});
   var ht = DateTimeFormatImpl;
   function amend(){
    var
     e =
       arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
     r = lt({}, e);
    for
    (var
      _i17 = 0,
      _arr6 =
        ["year",
         "month",
         "day",
         "hour",
         "minute",
         "second",
         "weekday",
         "dayPeriod",
         "timeZoneName",
         "dateStyle",
         "timeStyle"];
     _i17 < _arr6.length;
     _i17++){
     var _e34 = _arr6[_i17];
     r[_e34] = _e34 in t ? t[_e34] : r[_e34],
     ! 1 !== r[_e34] && void 0 !== r[_e34] || delete r[_e34];
    }
    return r;
   }
   function timeAmend(e){
    var
     t =
       amend
        (e,
         {year: ! 1,
          month: ! 1,
          day: ! 1,
          weekday: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1});
    return hasTimeOptions(t)
           ||
            (t =
             lt
              ({}, t, {hour: "numeric", minute: "numeric", second: "numeric"})),
           t;
   }
   function yearMonthAmend(e){
    var
     t =
       amend
        (e,
         {day: ! 1,
          hour: ! 1,
          minute: ! 1,
          second: ! 1,
          weekday: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1,
          timeStyle: ! 1});
    return "year" in t || "month" in t
           || (t = lt(t, {year: "numeric", month: "numeric"})),
           t;
   }
   function monthDayAmend(e){
    var
     t =
       amend
        (e,
         {year: ! 1,
          hour: ! 1,
          minute: ! 1,
          second: ! 1,
          weekday: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1,
          timeStyle: ! 1});
    return "month" in t || "day" in t
           || (t = lt({}, t, {month: "numeric", day: "numeric"})),
           t;
   }
   function dateAmend(e){
    var
     t =
       amend
        (e,
         {hour: ! 1,
          minute: ! 1,
          second: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          timeStyle: ! 1});
    return hasDateOptions(t)
           ||
            (t =
             lt({}, t, {year: "numeric", month: "numeric", day: "numeric"})),
           t;
   }
   function datetimeAmend(e){
    var t = amend(e, {timeZoneName: ! 1});
    return hasTimeOptions(t) || hasDateOptions(t)
           ||
            (t =
             lt
              ({},
               t,
               {year: "numeric",
                month: "numeric",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric"})),
           t;
   }
   function instantAmend(e){
    var t = e;
    return hasTimeOptions(t) || hasDateOptions(t)
           ||
            (t =
             lt
              ({},
               t,
               {year: "numeric",
                month: "numeric",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric"})),
           t;
   }
   function hasDateOptions(e){
    return "year" in e || "month" in e || "day" in e || "weekday" in e
           || "dateStyle" in e;
   }
   function hasTimeOptions(e){
    return "hour" in e || "minute" in e || "second" in e || "timeStyle" in e
           || "dayPeriod" in e;
   }
   function isTemporalObject(e){
    return IsTemporalDate(e) || IsTemporalTime(e) || IsTemporalDateTime(e)
           || IsTemporalZonedDateTime(e)
           || IsTemporalYearMonth(e)
           || IsTemporalMonthDay(e)
           || IsTemporalInstant(e);
   }
   function sameTemporalType(e, t){
    return !
           (! isTemporalObject(e) || ! isTemporalObject(t))
           && ! (IsTemporalTime(e) && ! IsTemporalTime(t))
           && ! (IsTemporalDate(e) && ! IsTemporalDate(t))
           && ! (IsTemporalDateTime(e) && ! IsTemporalDateTime(t))
           && ! (IsTemporalZonedDateTime(e) && ! IsTemporalZonedDateTime(t))
           && ! (IsTemporalYearMonth(e) && ! IsTemporalYearMonth(t))
           && ! (IsTemporalMonthDay(e) && ! IsTemporalMonthDay(t))
           && ! (IsTemporalInstant(e) && ! IsTemporalInstant(t));
   }
   function extractOverrides(e, t){
    var r = GetIntrinsic("%Temporal.PlainDateTime%");
    if(IsTemporalTime(e)){
     var
      _o27 =
        new
         r
         (1970,
          1,
          1,
          GetSlot(e, d),
          GetSlot(e, m),
          GetSlot(e, c),
          GetSlot(e, h),
          GetSlot(e, u),
          GetSlot(e, T),
          t[nt]);
     return {instant: GetInstantFor(t[ot], _o27, "compatible"),
             formatter: getPropLazy(t, Qe)};
    }
    if(IsTemporalYearMonth(e)){
     var
      _o28 = GetSlot(e, i),
      _n17 = GetSlot(e, s),
      _a13 = GetSlot(e, l),
      _d7 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if(_d7 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainYearMonth with calendar ".concat
                (_d7, " in locale with calendar ").concat
               (t[nt]));
     var _m6 = new r(_o28, _n17, _a13, 12, 0, 0, 0, 0, 0, _d7);
     return {instant: GetInstantFor(t[ot], _m6, "compatible"),
             formatter: getPropLazy(t, Ke)};
    }
    if(IsTemporalMonthDay(e)){
     var
      _o29 = GetSlot(e, i),
      _n18 = GetSlot(e, s),
      _a14 = GetSlot(e, l),
      _d8 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if(_d8 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainMonthDay with calendar ".concat
                (_d8, " in locale with calendar ").concat
               (t[nt]));
     var _m7 = new r(_o29, _n18, _a14, 12, 0, 0, 0, 0, 0, _d8);
     return {instant: GetInstantFor(t[ot], _m7, "compatible"),
             formatter: getPropLazy(t, Xe)};
    }
    if(IsTemporalDate(e)){
     var
      _o30 = GetSlot(e, i),
      _n19 = GetSlot(e, s),
      _a15 = GetSlot(e, l),
      _d9 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if("iso8601" !== _d9 && _d9 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainDate with calendar ".concat
                (_d9, " in locale with calendar ").concat
               (t[nt]));
     var _m8 = new r(_o30, _n19, _a15, 12, 0, 0, 0, 0, 0, t[nt]);
     return {instant: GetInstantFor(t[ot], _m8, "compatible"),
             formatter: getPropLazy(t, Je)};
    }
    if(IsTemporalDateTime(e)){
     var
      _o31 = GetSlot(e, i),
      _n20 = GetSlot(e, s),
      _a16 = GetSlot(e, l),
      _f5 = GetSlot(e, d),
      _y = GetSlot(e, m),
      _I3 = GetSlot(e, c),
      _S3 = GetSlot(e, h),
      _g2 = GetSlot(e, u),
      _w = GetSlot(e, T),
      _D = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if("iso8601" !== _D && _D !== t[nt])
      throw new
             RangeError
             ("cannot format PlainDateTime with calendar ".concat
                (_D, " in locale with calendar ").concat
               (t[nt]));
     var _G = e;
     return "iso8601" === _D
            &&
             (_G = new r(_o31, _n20, _a16, _f5, _y, _I3, _S3, _g2, _w, t[nt])),
            {instant: GetInstantFor(t[ot], _G, "compatible"),
             formatter: getPropLazy(t, et)};
    }
    if(IsTemporalZonedDateTime(e))
     throw new
            TypeError
            ("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
    return IsTemporalInstant(e)
            ? {instant: e, formatter: getPropLazy(t, tt)}
            : {};
   }
   var
    ut = Object.freeze({__proto__: null, DateTimeFormat: ht}),
    Instant =
      function(){
        function Instant(e){
         _classCallCheck(this, Instant);
         if(arguments.length < 1)
          throw new
                 TypeError
                 ("missing argument: epochNanoseconds is required");
         var t = ToBigInt(e);
         ValidateEpochNanoseconds(t), N(this), SetSlot(this, n, t);
        }
        _createClass
         (Instant,
          [{key: "epochSeconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, ve));
            }},
           {key: "epochMilliseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = BigInt(GetSlot(this, n));
             return Number(BigIntFloorDiv(t, Ge));
            }},
           {key: "epochMicroseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal
                     (BigIntFloorDiv(BigInt(GetSlot(this, n)), De));
            }},
           {key: "epochNanoseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(BigInt(GetSlot(this, n)));
            }},
           {key: "add",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromInstant("add", this, e);
            }},
           {key: "subtract",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromInstant
                     ("subtract", this, e);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalInstant("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalInstant("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              a = GetTemporalUnit(t, "smallestUnit", "time", He);
             ValidateTemporalRoundingIncrement
              (r,
               {hour: 24,
                 minute: 1440,
                 second: 86400,
                 millisecond: 864e5,
                 microsecond: 864e8,
                 nanosecond: 864e11}
                [a],
               ! 0);
             var i = RoundInstant(GetSlot(this, n), r, a, o);
             return new Instant(i);
            }},
           {key: "equals",
            value:
            function(t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalInstant(t),
              o = GetSlot(this, n),
              a = GetSlot(r, n);
             return BigInt(o) === BigInt(a);
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === a)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var i = t.timeZone;
             void 0 !== i && (i = ToTemporalTimeZoneSlotValue(i));
             var
              _ToSecondsStringPreci = ToSecondsStringPrecisionRecord(a, r),
              s = _ToSecondsStringPreci.precision,
              l = _ToSecondsStringPreci.unit,
              d = _ToSecondsStringPreci.increment,
              m = RoundInstant(GetSlot(this, n), d, l, o);
             return TemporalInstantToString(new Instant(m), i, s);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return TemporalInstantToString(this, void 0, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.Instant");
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("invalid argument in toZonedDateTime");
             var t = e.calendar;
             if(void 0 === t)
              throw new
                     TypeError
                     ("missing calendar property in toZonedDateTime");
             var r = ToTemporalCalendarSlotValue(t), o = e.timeZone;
             if(void 0 === o)
              throw new
                     TypeError
                     ("missing timeZone property in toZonedDateTime");
             var a = ToTemporalTimeZoneSlotValue(o);
             return CreateTemporalZonedDateTime(GetSlot(this, n), a, r);
            }},
           {key: "toZonedDateTimeISO",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), t, "iso8601");
            }}],
          [{key: "fromEpochSeconds",
            value:
            function(t){
             var r = ToNumber(t), o = BigInt(r) * ve;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochMilliseconds",
            value:
            function(t){
             var r = ToNumber(t), o = BigInt(r) * Ge;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochMicroseconds",
            value:
            function(t){
             var r = ToBigInt(t), o = r * De;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochNanoseconds",
            value:
            function(e){
             var t = ToBigInt(e);
             return ValidateEpochNanoseconds(t), new Instant(t);
            }},
           {key: "from",
            value:
            function(e){
             return IsTemporalInstant(e)
                     ? new Instant(GetSlot(e, n))
                     : ToTemporalInstant(e);
            }},
           {key: "compare",
            value:
            function(t, r){
             var
              o = ToTemporalInstant(t),
              a = ToTemporalInstant(r),
              i = GetSlot(o, n),
              s = GetSlot(a, n);
             return i < s ? - 1 : i > s ? 1 : 0;
            }}]);
        return Instant;
       }
       ();
   MakeIntrinsicClass(Instant, "Temporal.Instant");
   var
    Tt = Array.prototype.includes,
    pt = Array.prototype.push,
    ft = globalThis.Intl.DateTimeFormat,
    yt = Array.prototype.sort,
    It = Math.abs,
    St = Math.floor,
    gt = Object.create,
    wt = Object.entries,
    Dt = Set,
    Gt = Reflect.ownKeys,
    vt = Set.prototype.add,
    Ct = Set.prototype.values,
    Ot = {},
    Calendar =
      function(){
        function Calendar(e){
         _classCallCheck(this, Calendar);
         if(arguments.length < 1)
          throw new RangeError("missing argument: id is required");
         var t = ToString(e);
         if(! IsBuiltinCalendar(t))
          throw new RangeError("invalid calendar identifier ".concat(t));
         N(this), SetSlot(this, F, ASCIILowercase(t));
        }
        _createClass
         (Calendar,
          [{key: "id",
            get:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }},
           {key: "dateFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].dateFromFields(e, r, o);
            }},
           {key: "yearMonthFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].yearMonthFromFields(e, r, o);
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].monthDayFromFields(e, r, o);
            }},
           {key: "fields",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              t = [],
              r =
                new
                 Set
                 (["year",
                   "month",
                   "monthCode",
                   "day",
                   "hour",
                   "minute",
                   "second",
                   "millisecond",
                   "microsecond",
                   "nanosecond"]),
              _iterator15 = _createForOfIteratorHelper(e),
              _step15;
             try{
              for(_iterator15.s(); ! (_step15 = _iterator15.n()).done;){
               var _o32 = _step15.value;
               if("string" != typeof _o32)
                throw new TypeError("invalid fields");
               if(! r.has(_o32))
                throw new RangeError("invalid field name ".concat(_o32));
               r["delete"](_o32), pt.call(t, _o32);
              }
             }
             catch(err){_iterator15.e(err);}
             finally{_iterator15.f();}
             return Ot[GetSlot(this, F)].fields(t);
            }},
           {key: "mergeFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var r = ToObject(e), o = gt(null);
             CopyDataProperties(o, r, [], [void 0]);
             var n = ToObject(t), a = gt(null);
             CopyDataProperties(a, n, [], [void 0]);
             var
              i = Gt(a),
              s = Ot[GetSlot(this, F)].fieldKeysToIgnore(i),
              l = gt(null),
              d = Gt(o),
              _iterator16 = _createForOfIteratorHelper(d),
              _step16;
             try{
              for(_iterator16.s(); ! (_step16 = _iterator16.n()).done;){
               var _e35 = _step16.value, _t42 = void 0;
               _t42 = Call(Tt, s, [_e35]) ? a[_e35] : o[_e35],
               void 0 !== _t42 && (l[_e35] = _t42);
              }
             }
             catch(err){_iterator16.e(err);}
             finally{_iterator16.f();}
             return CopyDataProperties(l, a, []), l;
            }},
           {key: "dateAdd",
            value:
            function(e, t, r){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              o = ToTemporalDate(e),
              n = ToTemporalDuration(t),
              a = ToTemporalOverflow(GetOptionsObject(r)),
              _BalanceDuration10 =
                BalanceDuration
                 (GetSlot(n, v),
                  GetSlot(n, C),
                  GetSlot(n, O),
                  GetSlot(n, b),
                  GetSlot(n, E),
                  GetSlot(n, M),
                  GetSlot(n, R),
                  "day"),
              i = _BalanceDuration10.days,
              s = GetSlot(this, F);
             return Ot[s].dateAdd
                     (o, GetSlot(n, w), GetSlot(n, D), GetSlot(n, G), i, a, s);
            }},
           {key: "dateUntil",
            value:
            function(e, t, r){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              o = ToTemporalDate(e),
              n = ToTemporalDate(t),
              a =
                GetTemporalUnit
                 (GetOptionsObject(r), "largestUnit", "date", "auto");
             "auto" === a && (a = "day");
             var
              _Ot$GetSlot$dateUntil = Ot[GetSlot(this, F)].dateUntil(o, n, a),
              i = _Ot$GetSlot$dateUntil.years,
              s = _Ot$GetSlot$dateUntil.months,
              l = _Ot$GetSlot$dateUntil.weeks,
              d = _Ot$GetSlot$dateUntil.days;
             return new
                     (GetIntrinsic("%Temporal.Duration%"))
                     (i, s, l, d, 0, 0, 0, 0, 0, 0);
            }},
           {key: "year",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].year(t);
            }},
           {key: "month",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(IsTemporalMonthDay(t))
              throw new TypeError("use monthCode on PlainMonthDay instead");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].month(t);
            }},
           {key: "monthCode",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || IsTemporalMonthDay(t)
                    || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].monthCode(t);
            }},
           {key: "day",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalMonthDay(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].day(t);
            }},
           {key: "era",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].era(t);
            }},
           {key: "eraYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].eraYear(t);
            }},
           {key: "dayOfWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].dayOfWeek(t);
            }},
           {key: "dayOfYear",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].dayOfYear(t);
            }},
           {key: "weekOfYear",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].weekOfYear(t);
            }},
           {key: "yearOfWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].yearOfWeek(t);
            }},
           {key: "daysInWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].daysInWeek(t);
            }},
           {key: "daysInMonth",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].daysInMonth(t);
            }},
           {key: "daysInYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].daysInYear(t);
            }},
           {key: "monthsInYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].monthsInYear(t);
            }},
           {key: "inLeapYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].inLeapYear(t);
            }},
           {key: "toString",
            value:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }}],
          [{key: "from",
            value:
            function(e){
             return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e));
            }}]);
        return Calendar;
       }
       ();
   function monthCodeNumberPart(e){
    if(! e.startsWith("M"))
     throw new
            RangeError
            ("Invalid month code: ".concat
              (e, ".  Month codes must start with M."));
    var t = + e.slice(1);
    if(isNaN(t)) throw new RangeError("Invalid month code: ".concat(e));
    return t;
   }
   function buildMonthCode(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ! 1;
    return "M".concat(e.toString().padStart(2, "0")).concat(t ? "L" : "");
   }
   function resolveNonLunisolarMonth(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12,
     o = e.month,
     n = e.monthCode;
    if(void 0 === n){
     if(void 0 === o)
      throw new TypeError("Either month or monthCode are required");
     "reject" === t && RejectToRange(o, 1, r),
     "constrain" === t && (o = ConstrainToRange(o, 1, r)),
     n = buildMonthCode(o);
    }
    else{
     var _e36 = monthCodeNumberPart(n);
     if(void 0 !== o && o !== _e36)
      throw new
             RangeError
             ("monthCode ".concat(n, " and month ").concat
               (o, " must match if both are present"));
     if(n !== buildMonthCode(_e36))
      throw new RangeError("Invalid month code: ".concat(n));
     if(o = _e36, o < 1 || o > r)
      throw new RangeError("Invalid monthCode: ".concat(n));
    }
    return _objectSpread2(_objectSpread2({}, e), {}, {month: o, monthCode: n});
   }
   MakeIntrinsicClass(Calendar, "Temporal.Calendar"),
   DefineIntrinsic("Temporal.Calendar.from", Calendar.from),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateFromFields",
     Calendar.prototype.dateFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil),
   DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInMonth",
     Calendar.prototype.daysInMonth),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear),
   DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.fields", Calendar.prototype.fields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.mergeFields",
     Calendar.prototype.mergeFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.month", Calendar.prototype.month),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthDayFromFields",
     Calendar.prototype.monthDayFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthsInYear",
     Calendar.prototype.monthsInYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.year", Calendar.prototype.year),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.yearMonthFromFields",
     Calendar.prototype.yearMonthFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek),
   Ot.iso8601 =
    {dateFromFields:
     function(e, t, r){
      var
       _RegulateISODate2,
       o =
         PrepareTemporalFields
          (e, ["day", "month", "monthCode", "year"], ["year", "day"]),
       n = ToTemporalOverflow(t);
      o = resolveNonLunisolarMonth(o);
      var _o33 = o, a = _o33.year, i = _o33.month, s = _o33.day;
      return _RegulateISODate2 = RegulateISODate(a, i, s, n),
             a = _RegulateISODate2.year,
             i = _RegulateISODate2.month,
             s = _RegulateISODate2.day,
             CreateTemporalDate(a, i, s, r);
     },
     yearMonthFromFields:
     function(e, t, r){
      var
       _RegulateISOYearMonth,
       o = PrepareTemporalFields(e, ["month", "monthCode", "year"], ["year"]),
       n = ToTemporalOverflow(t);
      o = resolveNonLunisolarMonth(o);
      var _o34 = o, a = _o34.year, i = _o34.month;
      return _RegulateISOYearMonth =
              function(e, t, r){
                var o = e, n = t;
                switch(r){
                  case "reject":
                   RejectISODate(o, n, 1); break;
                  case "constrain":
                   var _ConstrainISODate2 = ConstrainISODate(o, n);
                   o = _ConstrainISODate2.year;
                   n = _ConstrainISODate2.month;
                }
                return {year: o, month: n};
               }
               (a, i, n),
             a = _RegulateISOYearMonth.year,
             i = _RegulateISOYearMonth.month,
             CreateTemporalYearMonth(a, i, r, 1);
     },
     monthDayFromFields:
     function(e, t, r){
      var
       _RegulateISODate3,
       o =
         PrepareTemporalFields
          (e, ["day", "month", "monthCode", "year"], ["day"]),
       n = ToTemporalOverflow(t);
      if(void 0 !== o.month && void 0 === o.year && void 0 === o.monthCode)
       throw new TypeError("either year or monthCode required with month");
      var a = void 0 === o.monthCode;
      o = resolveNonLunisolarMonth(o);
      var _o35 = o, i = _o35.month, s = _o35.day, l = _o35.year;
      return _RegulateISODate3 = RegulateISODate(a ? l : 1972, i, s, n),
             i = _RegulateISODate3.month,
             s = _RegulateISODate3.day,
             CreateTemporalMonthDay(i, s, r, 1972);
     },
     fields: function(e){return e;},
     fieldKeysToIgnore:
     function(e){
      var t = new Dt();
      for(var _r58 = 0; _r58 < e.length; _r58++){
       var _o36 = e[_r58];
       Call(vt, t, [_o36]),
       "month" === _o36
        ? Call(vt, t, ["monthCode"])
        : "monthCode" === _o36 && Call(vt, t, ["month"]);
      }
      return _toConsumableArray(Call(Ct, t, []));
     },
     dateAdd:
     function(e, t, r, o, n, a, d){
      var
       _AddISODate,
       m = GetSlot(e, i),
       c = GetSlot(e, s),
       h = GetSlot(e, l);
      return _AddISODate = AddISODate(m, c, h, t, r, o, n, a),
             m = _AddISODate.year,
             c = _AddISODate.month,
             h = _AddISODate.day,
             CreateTemporalDate(m, c, h, d);
     },
     dateUntil:
     function(e, t, r){
      return DifferenceISODate
              (GetSlot(e, i),
               GetSlot(e, s),
               GetSlot(e, l),
               GetSlot(t, i),
               GetSlot(t, s),
               GetSlot(t, l),
               r);
     },
     year: function(e){return GetSlot(e, i);},
     era: function(){},
     eraYear: function(){},
     month: function(e){return GetSlot(e, s);},
     monthCode: function(e){return buildMonthCode(GetSlot(e, s));},
     day: function(e){return GetSlot(e, l);},
     dayOfWeek:
     function(e){
      return DayOfWeek(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
     },
     dayOfYear:
     function(e){
      return DayOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
     },
     weekOfYear:
     function(e){
      return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).week;
     },
     yearOfWeek:
     function(e){
      return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).year;
     },
     daysInWeek: function(){return 7;},
     daysInMonth:
     function(e){return ISODaysInMonth(GetSlot(e, i), GetSlot(e, s));},
     daysInYear:
     function(e){
      var t = e;
      return HasSlot(t, i) || (t = ToTemporalDate(t)),
             LeapYear(GetSlot(t, i)) ? 366 : 365;
     },
     monthsInYear: function(){return 12;},
     inLeapYear:
     function(e){
      var t = e;
      return HasSlot(t, i) || (t = ToTemporalDate(t)),
             LeapYear(GetSlot(t, i));
     }};
   var
    OneObjectCache =
      function(){
        function OneObjectCache(e){
         _classCallCheck(this, OneObjectCache);
         if
          (this.map = new Map(),
           this.calls = 0,
           this.hits = 0,
           this.misses = 0,
           this.now =
            globalThis.performance ? globalThis.performance.now() : Date.now(),
           void 0 !== e){
          var
           _t43 = 0,
           _iterator17 = _createForOfIteratorHelper(e.map.entries()),
           _step17;
          try{
           for(_iterator17.s(); ! (_step17 = _iterator17.n()).done;){
            var _this$map, _r59 = _step17.value;
            if(++_t43 > OneObjectCache.MAX_CACHE_ENTRIES) break;
            (_this$map = this.map).set.apply
             (_this$map, _toConsumableArray(_r59));
           }
          }
          catch(err){_iterator17.e(err);}
          finally{_iterator17.f();}
         }
        }
        _createClass
         (OneObjectCache,
          [{key: "get",
            value:
            function(e){
             var t = this.map.get(e);
             return t && (this.hits++, this.report()), this.calls++, t;
            }},
           {key: "set",
            value:
            function(e, t){this.map.set(e, t), this.misses++, this.report();}},
           {key: "report", value: function(){}},
           {key: "setObject",
            value:
            function(e){
             if(OneObjectCache.objectMap.get(e))
              throw new RangeError("object already cached");
             OneObjectCache.objectMap.set(e, this), this.report();
            }}],
          [{key: "getCacheForObject",
            value:
            function(e){
             var t = OneObjectCache.objectMap.get(e);
             return t
                    ||
                     (t = new OneObjectCache(),
                      OneObjectCache.objectMap.set(e, t)),
                    t;
            }}]);
        return OneObjectCache;
       }
       ();
   function toUtcIsoDateString(_ref8){
    var e = _ref8.isoYear, t = _ref8.isoMonth, r = _ref8.isoDay;
    return "".concat(ISOYearString(e), "-").concat
             (ISODateTimePartString(t), "-").concat
            (ISODateTimePartString(r), "T00:00Z");
   }
   function simpleDateDiff(e, t){
    return {years: e.year - t.year,
            months: e.month - t.month,
            days: e.day - t.day};
   }
   OneObjectCache.objectMap = new WeakMap(),
   OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
   var
    HelperBase =
      function(){
        function HelperBase(){
         _classCallCheck(this, HelperBase);
         this.eraLength = "short",
         this.hasEra = ! 0,
         this.erasBeginMidYear = ! 1;
        }
        _createClass
         (HelperBase,
          [{key: "getFormatter",
            value:
            function(){
             return void 0 === this.formatter
                    &&
                     (this.formatter =
                      new
                       ft
                       ("en-US-u-ca-".concat(this.id),
                        {day: "numeric",
                         month: "numeric",
                         year: "numeric",
                         era: this.eraLength,
                         timeZone: "UTC"})),
                    this.formatter;
            }},
           {key: "isoToCalendarDate",
            value:
            function(e, t){
             var
              _this = this,
              r = e.year,
              o = e.month,
              n = e.day,
              a =
                JSON.stringify
                 ({func: "isoToCalendarDate",
                   isoYear: r,
                   isoMonth: o,
                   isoDay: n,
                   id: this.id}),
              i = t.get(a);
             if(i) return i;
             var s = this.getFormatter(), l, d;
             try{
              d = toUtcIsoDateString({isoYear: r, isoMonth: o, isoDay: n}),
              l = s.formatToParts(new Date(d));
             }
             catch(e){
              throw new
                     RangeError
                     ("Invalid ISO date: ".concat
                       (JSON.stringify({isoYear: r, isoMonth: o, isoDay: n})));
             }
             var m = {}, _iterator18 = _createForOfIteratorHelper(l), _step18;
             try{
              for(_iterator18.s(); ! (_step18 = _iterator18.n()).done;){
               var
                _step18$value = _step18.value,
                _e37 = _step18$value.type,
                _t45 = _step18$value.value;
               if
                ("year" === _e37 && (m.eraYear = + _t45),
                 "relatedYear" === _e37 && (m.eraYear = + _t45),
                 "month" === _e37){
                var _e38 = /^([0-9]*)(.*?)$/.exec(_t45);
                if(! _e38 || 3 != _e38.length || ! _e38[1] && ! _e38[2])
                 throw new RangeError("Unexpected month: ".concat(_t45));
                if(m.month = _e38[1] ? + _e38[1] : 1, m.month < 1)
                 throw new
                        RangeError
                        ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
                          (this.id,
                           "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)"));
                if(m.month > 13)
                 throw new
                        RangeError
                        ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
                          (this.id,
                           "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
                _e38[2] && (m.monthExtra = _e38[2]);
               }
               "day" === _e37 && (m.day = + _t45),
               this.hasEra && "era" === _e37 && null != _t45 && "" !== _t45
               &&
                (_t45 = _t45.split(" (")[0],
                 m.era =
                  _t45.normalize("NFD").replace
                     (/(?:[\0-\x1F!-,\.\/:-@\[-`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u036F\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482-\u0489\u0530\u0557\u0558\u055A-\u055F\u0589-\u05CF\u05EB-\u05EE\u05F3-\u061F\u064B-\u066D\u0670\u06D4\u06D6-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u06FD\u06FE\u0700-\u070F\u0711\u0730-\u074C\u07A6-\u07B0\u07B2-\u07C9\u07EB-\u07F3\u07F6-\u07F9\u07FB-\u07FF\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u083F\u0859-\u085F\u086B-\u086F\u0888\u088F-\u089F\u08CA-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0970\u0981-\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA-\u09BC\u09BE-\u09CD\u09CF-\u09DB\u09DE\u09E2-\u09EF\u09F2-\u09FB\u09FD-\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A-\u0A58\u0A5D\u0A5F-\u0A71\u0A75-\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA-\u0ABC\u0ABE-\u0ACF\u0AD1-\u0ADF\u0AE2-\u0AF8\u0AFA-\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A-\u0B3C\u0B3E-\u0B5B\u0B5E\u0B62-\u0B70\u0B72-\u0B82\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BCF\u0BD1-\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C3E-\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C62-\u0C7F\u0C81-\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA-\u0CBC\u0CBE-\u0CDC\u0CDF\u0CE2-\u0CF0\u0CF3-\u0D03\u0D0D\u0D11\u0D3B\u0D3C\u0D3E-\u0D4D\u0D4F-\u0D53\u0D57-\u0D5E\u0D62-\u0D79\u0D80-\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0E00\u0E31\u0E34-\u0E3F\u0E47-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EB1\u0EB4-\u0EBC\u0EBE\u0EBF\u0EC5\u0EC7-\u0EDB\u0EE0-\u0EFF\u0F01-\u0F3F\u0F48\u0F6D-\u0F87\u0F8D-\u0FFF\u102B-\u103E\u1040-\u104F\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16F0\u16F9-\u16FF\u1712-\u171E\u1732-\u173F\u1752-\u175F\u176D\u1771-\u177F\u17B4-\u17D6\u17D8-\u17DB\u17DD-\u181F\u1879-\u187F\u1885\u1886\u18A9\u18AB-\u18AF\u18F6-\u18FF\u191F-\u194F\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19FF\u1A17-\u1A1F\u1A55-\u1AA6\u1AA8-\u1B04\u1B34-\u1B44\u1B4D-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BFF\u1C24-\u1C4C\u1C50-\u1C59\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1CFB-\u1CFF\u1DC0-\u1DFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u2182\u2185-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7F\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF-\u2E2E\u2E30-\u3004\u3007-\u3030\u3036-\u303A\u303D-\u3040\u3097-\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA620-\uA629\uA62C-\uA63F\uA66F-\uA67E\uA69E\uA69F\uA6E6-\uA716\uA720\uA721\uA789\uA78A\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA802\uA806\uA80B\uA823-\uA83F\uA874-\uA881\uA8B4-\uA8F1\uA8F8-\uA8FA\uA8FC\uA8FF-\uA909\uA926-\uA92F\uA947-\uA95F\uA97D-\uA983\uA9B3-\uA9CE\uA9D0-\uA9DF\uA9E5\uA9F0-\uA9F9\uA9FF\uAA29-\uAA3F\uAA43\uAA4C-\uAA5F\uAA77-\uAA79\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAC3-\uAADA\uAADE\uAADF\uAAEB-\uAAF1\uAAF5-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABE3-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB1E\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFE6F\uFE75\uFEFD-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEFF\uDF20-\uDF2C\uDF41\uDF4A-\uDF4F\uDF76-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0-\uDFFF]|\uD801[\uDC9E-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6F\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE01-\uDE0F\uDE14\uDE18\uDE36-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE5-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD24-\uDE7F\uDEAA-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF46-\uDF6F\uDF82-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC00-\uDC02\uDC38-\uDC70\uDC73\uDC74\uDC76-\uDC82\uDCB0-\uDCCF\uDCE9-\uDD02\uDD27-\uDD43\uDD45\uDD46\uDD48-\uDD4F\uDD73-\uDD75\uDD77-\uDD82\uDDB3-\uDDC0\uDDC5-\uDDD9\uDDDB\uDDDD-\uDDFF\uDE12\uDE2C-\uDE3E\uDE41-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEDF-\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A-\uDF3C\uDF3E-\uDF4F\uDF51-\uDF5C\uDF62-\uDFFF]|\uD805[\uDC35-\uDC46\uDC4B-\uDC5E\uDC62-\uDC7F\uDCB0-\uDCC3\uDCC6\uDCC8-\uDD7F\uDDAF-\uDDD7\uDDDC-\uDDFF\uDE30-\uDE43\uDE45-\uDE7F\uDEAB-\uDEB7\uDEB9-\uDEFF\uDF1B-\uDF3F\uDF47-\uDFFF]|\uD806[\uDC2C-\uDC9F\uDCE0-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD30-\uDD3E\uDD40\uDD42-\uDD9F\uDDA8\uDDA9\uDDD1-\uDDE0\uDDE2\uDDE4-\uDDFF\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE4F\uDE51-\uDE5B\uDE8A-\uDE9C\uDE9E-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC2F-\uDC3F\uDC41-\uDC71\uDC90-\uDCFF\uDD07\uDD0A\uDD31-\uDD45\uDD47-\uDD5F\uDD66\uDD69\uDD8A-\uDD97\uDD99-\uDEDF\uDEF3-\uDF01\uDF03\uDF11\uDF34-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC00-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD834\uD836\uD83C-\uD83F\uD87C\uD87D\uD87F\uD889-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF1-\uDFFF]|\uD80D[\uDC30-\uDC40\uDC47-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F-\uDE6F\uDEBF-\uDECF\uDEEE-\uDEFF\uDF30-\uDF3F\uDF44-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4F\uDF51-\uDF92\uDFA0-\uDFDF\uDFE2\uDFE4-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD31\uDD33-\uDD4F\uDD53\uDD54\uDD56-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDF24\uDF2B-\uDFFF]|\uD838[\uDC00-\uDC2F\uDC6E-\uDCFF\uDD2D-\uDD36\uDD3E-\uDD4D\uDD4F-\uDE8F\uDEAE-\uDEBF\uDEEC-\uDFFF]|\uD839[\uDC00-\uDCCF\uDCEC-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5-\uDCFF\uDD44-\uDD4A\uDD4C-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF3A-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFEF]|\uD87B[\uDE5E-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDF4F]|\uD888[\uDFB0-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
                      "").replace
                    (" ", "-").toLowerCase
                   ());
              }
             }
             catch(err){_iterator18.e(err);}
             finally{_iterator18.f();}
             if(void 0 === m.eraYear)
              throw new
                     RangeError
                     ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
                       (this.id, " calendar. Try Node 14+ or modern browsers."));
             if(this.reviseIntlEra){
              var
               _this$reviseIntlEra = this.reviseIntlEra(m, e),
               _t44 = _this$reviseIntlEra.era,
               _r60 = _this$reviseIntlEra.eraYear;
              m.era = _t44, m.eraYear = _r60;
             }
             this.checkIcuBugs && this.checkIcuBugs(e);
             var c = this.adjustCalendarDate(m, t, "constrain", ! 0);
             if(void 0 === c.year)
              throw new
                     RangeError
                     ("Missing year converting ".concat(JSON.stringify(e)));
             if(void 0 === c.month)
              throw new
                     RangeError
                     ("Missing month converting ".concat(JSON.stringify(e)));
             if(void 0 === c.day)
              throw new
                     RangeError
                     ("Missing day converting ".concat(JSON.stringify(e)));
             return t.set(a, c),
                    ["constrain", "reject"].forEach
                     (function(r){
                       var
                        o =
                          JSON.stringify
                           ({func: "calendarToIsoDate",
                             year: c.year,
                             month: c.month,
                             day: c.day,
                             overflow: r,
                             id: _this.id});
                       t.set(o, e);
                      }),
                    c;
            }},
           {key: "validateCalendarDate",
            value:
            function(e){
             var
              t = e.era,
              r = e.month,
              o = e.year,
              n = e.day,
              a = e.eraYear,
              i = e.monthCode,
              s = e.monthExtra;
             if(void 0 !== s)
              throw new RangeError("Unexpected `monthExtra` value");
             if(void 0 === o && void 0 === a)
              throw new TypeError("year or eraYear is required");
             if(void 0 === r && void 0 === i)
              throw new TypeError("month or monthCode is required");
             if(void 0 === n) throw new RangeError("Missing day");
             if(void 0 !== i){
              if("string" != typeof i)
               throw new
                      RangeError
                      ("monthCode must be a string, not " + _typeof(i));
              if(! /^M([01]?\d)(L?)$/.test(i))
               throw new RangeError("Invalid monthCode: ".concat(i));
             }
             if(this.constantEra){
              if(void 0 !== t && t !== this.constantEra)
               throw new
                      RangeError
                      ("era must be ".concat(this.constantEra, ", not ").concat(t));
              if(void 0 !== a && void 0 !== o && a !== o)
               throw new
                      RangeError
                      ("eraYear ".concat(a, " does not match year ").concat(o));
             }
             if(this.hasEra && void 0 === e.era != (void 0 === e.eraYear))
              throw new
                     RangeError
                     ("properties 'era' and 'eraYear' must be provided together");
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              _resolveNonLunisolarM,
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain";
             if("lunisolar" === this.calendarType)
              throw new
                     RangeError
                     ("Override required for lunisolar calendars");
             var n = e;
             if(this.validateCalendarDate(n), this.constantEra){
              var _n21 = n, _e39 = _n21.year, _t46 = _n21.eraYear;
              n =
               _objectSpread2
                (_objectSpread2({}, n),
                 {},
                 {era: this.constantEra,
                  year: void 0 !== _e39 ? _e39 : _t46,
                  eraYear: void 0 !== _t46 ? _t46 : _e39});
             }
             var
              a = this.monthsInYear(n, t),
              _n22 = n,
              i = _n22.month,
              s = _n22.monthCode;
             return _resolveNonLunisolarM = resolveNonLunisolarMonth(n, r, a),
                    i = _resolveNonLunisolarM.month,
                    s = _resolveNonLunisolarM.monthCode,
                    _objectSpread2
                     (_objectSpread2({}, n), {}, {month: i, monthCode: s});
            }},
           {key: "regulateMonthDayNaive",
            value:
            function(e, t, r){
             var o = this.monthsInYear(e, r), n = e.month, a = e.day;
             return "reject" === t
                     ? (RejectToRange
                        (n, 1, o),
                       RejectToRange(a, 1, this.maximumMonthLength(e)))
                     : (n
                       = ConstrainToRange(n, 1, o),
                       a =
                        ConstrainToRange
                         (a,
                          1,
                          this.maximumMonthLength
                           (_objectSpread2(_objectSpread2({}, e), {}, {month: n})))),
                    _objectSpread2
                     (_objectSpread2({}, e), {}, {month: n, day: a});
            }},
           {key: "calendarToIsoDate",
            value:
            function(e){
             var
              _this2 = this,
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "constrain",
              r = arguments.length > 2 ? arguments[2] : undefined,
              o = e,
              n = this.adjustCalendarDate(e, r, t, ! 1);
             n = this.regulateMonthDayNaive(n, t, r);
             var
              _n23 = n,
              a = _n23.year,
              i = _n23.month,
              s = _n23.day,
              l =
                JSON.stringify
                 ({func: "calendarToIsoDate",
                   year: a,
                   month: i,
                   day: s,
                   overflow: t,
                   id: this.id}),
              d,
              m = r.get(l);
             if(m) return m;
             if
              (void 0 !== o.year && void 0 !== o.month && void 0 !== o.day
               &&
                (o.year !== n.year || o.month !== n.month || o.day !== n.day)
               &&
                (d =
                  JSON.stringify
                   ({func: "calendarToIsoDate",
                     year: o.year,
                     month: o.month,
                     day: o.day,
                     overflow: t,
                     id: this.id}),
                 m = r.get(d),
                 m))
              return m;
             var
              c = this.estimateIsoDate({year: a, month: i, day: s}),
              calculateSameMonthResult =
                function(e){
                 var o = _this2.addDaysIso(c, e);
                 if(n.day > _this2.minimumMonthLength(n)){
                  var _e40 = _this2.isoToCalendarDate(o, r);
                  for(; _e40.month !== i || _e40.year !== a;){
                   if("reject" === t)
                    throw new
                           RangeError
                           ("day ".concat(s, " does not exist in month ").concat
                              (i, " of year ").concat
                             (a));
                   o = _this2.addDaysIso(o, - 1),
                   _e40 = _this2.isoToCalendarDate(o, r);
                  }
                 }
                 return o;
                },
              h = 0,
              u = this.isoToCalendarDate(c, r),
              T = simpleDateDiff(n, u);
             if(0 !== T.years || 0 !== T.months || 0 !== T.days){
              var _e41 = 365 * T.years + 30 * T.months + T.days;
              c = this.addDaysIso(c, _e41),
              u = this.isoToCalendarDate(c, r),
              T = simpleDateDiff(n, u),
              0 === T.years && 0 === T.months
               ? c = calculateSameMonthResult(T.days)
               : h = this.compareCalendarDates(n, u);
             }
             var p = 8;
             for(; h;){
              c = this.addDaysIso(c, h * p);
              var _e42 = u;
              u = this.isoToCalendarDate(c, r);
              var _a17 = h;
              if(h = this.compareCalendarDates(n, u), h)
               if(T = simpleDateDiff(n, u), 0 === T.years && 0 === T.months)
                c = calculateSameMonthResult(T.days), h = 0;
               else if(_a17 && h !== _a17)
                if(p > 1)
                 p /= 2;
                else{
                 if("reject" === t)
                  throw new
                         RangeError
                         ("Can't find ISO date from calendar date: ".concat
                           (JSON.stringify(_objectSpread2({}, o))));
                 this.compareCalendarDates(u, _e42) > 0
                 && (c = this.addDaysIso(c, - 1)),
                 h = 0;
                }
             }
             if
              (r.set(l, c),
               d && r.set(d, c),
               void 0 === n.year || void 0 === n.month || void 0 === n.day
               || void 0 === n.monthCode
               || this.hasEra && (void 0 === n.era || void 0 === n.eraYear))
              throw new RangeError("Unexpected missing property");
             return c;
            }},
           {key: "temporalToCalendarDate",
            value:
            function(e, t){
             var
              r =
                {year: GetSlot(e, i),
                 month: GetSlot(e, s),
                 day: GetSlot(e, l)};
             return this.isoToCalendarDate(r, t);
            }},
           {key: "compareCalendarDates",
            value:
            function(e, t){
             var
              r =
                PrepareTemporalFields
                 (e, ["day", "month", "year"], ["day", "month", "year"]),
              o =
                PrepareTemporalFields
                 (t, ["day", "month", "year"], ["day", "month", "year"]);
             return r.year !== o.year
                     ? ComparisonResult(r.year - o.year)
                     : r.month
                       !== o.month
                       ? ComparisonResult(r.month - o.month)
                       : r.day !== o.day ? ComparisonResult(r.day - o.day) : 0;
            }},
           {key: "regulateDate",
            value:
            function(e){
             var
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "constrain",
              r = arguments.length > 2 ? arguments[2] : undefined,
              o = this.calendarToIsoDate(e, t, r);
             return this.isoToCalendarDate(o, r);
            }},
           {key: "addDaysIso",
            value:
            function(e, t){
             return AddISODate
                     (e.year, e.month, e.day, 0, 0, 0, t, "constrain");
            }},
           {key: "addDaysCalendar",
            value:
            function(e, t, r){
             var
              o = this.calendarToIsoDate(e, "constrain", r),
              n = this.addDaysIso(o, t);
             return this.isoToCalendarDate(n, r);
            }},
           {key: "addMonthsCalendar",
            value:
            function(e, t, r, o){
             var n = e, _n24 = n, a = _n24.day;
             for(var _e43 = 0, _r61 = It(t); _e43 < _r61; _e43++){
              var
               _n25 = n,
               _e44 = _n25.month,
               _r62 = n,
               _i18 =
                 t < 0
                  ? - Math.max(a, this.daysInPreviousMonth(n, o))
                  : this.daysInMonth(n, o),
               _s7 = this.calendarToIsoDate(n, "constrain", o),
               _l7 = this.addDaysIso(_s7, _i18);
              if(n = this.isoToCalendarDate(_l7, o), t > 0){
               var _t47 = this.monthsInYear(_r62, o);
               for(; n.month - 1 != _e44 % _t47;)
                _l7 = this.addDaysIso(_l7, - 1),
                n = this.isoToCalendarDate(_l7, o);
              }
              n.day !== a
              &&
               (n =
                this.regulateDate
                 (_objectSpread2(_objectSpread2({}, n), {}, {day: a}),
                  "constrain",
                  o));
             }
             if("reject" === r && n.day !== a)
              throw new
                     RangeError
                     ("Day ".concat
                       (a, " does not exist in resulting calendar month"));
             return n;
            }},
           {key: "addCalendar",
            value:
            function(e, _ref9, a, i){
             var
              _ref9$years = _ref9.years,
              t = _ref9$years === void 0 ? 0 : _ref9$years,
              _ref9$months = _ref9.months,
              r = _ref9$months === void 0 ? 0 : _ref9$months,
              _ref9$weeks = _ref9.weeks,
              o = _ref9$weeks === void 0 ? 0 : _ref9$weeks,
              _ref9$days = _ref9.days,
              n = _ref9$days === void 0 ? 0 : _ref9$days,
              s = e.year,
              l = e.day,
              d = e.monthCode,
              m =
                this.adjustCalendarDate
                 ({year: s + t, monthCode: d, day: l}, i),
              c = this.addMonthsCalendar(m, r, a, i),
              h = n + 7 * o;
             return this.addDaysCalendar(c, h, i);
            }},
           {key: "untilCalendar",
            value:
            function(e, t, r, o){
             var n = 0, a = 0, i = 0, s = 0;
             switch(r){
               case "day":
                n = this.calendarDaysUntil(e, t, o); break;
               case "week":
                {
                 var _r63 = this.calendarDaysUntil(e, t, o);
                 n = _r63 % 7, a = (_r63 - n) / 7;
                 break;
                }
               case "month":
               case "year":
                {
                 var _a18 = this.compareCalendarDates(t, e);
                 if(! _a18) return {years: 0, months: 0, weeks: 0, days: 0};
                 var _l8 = t.year - e.year, _d10 = t.day - e.day;
                 if("year" === r && _l8){
                  var _r64 = 0;
                  t.monthCode > e.monthCode && (_r64 = 1),
                  t.monthCode < e.monthCode && (_r64 = - 1),
                  _r64 || (_r64 = Math.sign(_d10));
                  s = _r64 * _a18 < 0 ? _l8 - _a18 : _l8;
                 }
                 var
                  _m9,
                  _c5 =
                    s ? this.addCalendar(e, {years: s}, "constrain", o) : e;
                 do
                  i += _a18,
                  _m9 = _c5,
                  _c5 = this.addMonthsCalendar(_m9, _a18, "constrain", o),
                  _c5.day !== e.day
                  &&
                   (_c5 =
                    this.regulateDate
                     (_objectSpread2(_objectSpread2({}, _c5), {}, {day: e.day}),
                      "constrain",
                      o));
                 while
                  (this.compareCalendarDates(t, _c5) * _a18 >= 0);
                 i -= _a18;
                 n = this.calendarDaysUntil(_m9, t, o);
                 break;
                }
             }
             return {years: s, months: i, weeks: a, days: n};
            }},
           {key: "daysInMonth",
            value:
            function(e, t){
             var
              r = e.day,
              o = this.maximumMonthLength(e),
              n = this.minimumMonthLength(e);
             if(n === o) return n;
             var
              a = r <= o - n ? o : n,
              i = this.calendarToIsoDate(e, "constrain", t),
              s = this.addDaysIso(i, a),
              l = this.isoToCalendarDate(s, t),
              d = this.addDaysIso(s, - l.day);
             return this.isoToCalendarDate(d, t).day;
            }},
           {key: "daysInPreviousMonth",
            value:
            function(e, t){
             var
              r = e.day,
              o = e.month,
              n = e.year,
              a = {year: o > 1 ? n : n - 1, month: o, day: 1},
              i = o > 1 ? o - 1 : this.monthsInYear(a, t);
             a = _objectSpread2(_objectSpread2({}, a), {}, {month: i});
             var
              s = this.minimumMonthLength(a),
              l = this.maximumMonthLength(a);
             if(s === l) return l;
             var
              d = this.calendarToIsoDate(e, "constrain", t),
              m = this.addDaysIso(d, - r);
             return this.isoToCalendarDate(m, t).day;
            }},
           {key: "startOfCalendarYear",
            value:
            function(e){
             return {year: e.year, month: 1, monthCode: "M01", day: 1};
            }},
           {key: "startOfCalendarMonth",
            value: function(e){return {year: e.year, month: e.month, day: 1};}},
           {key: "calendarDaysUntil",
            value:
            function(e, t, r){
             var
              o = this.calendarToIsoDate(e, "constrain", r),
              n = this.calendarToIsoDate(t, "constrain", r);
             return this.isoDaysUntil(o, n);
            }},
           {key: "isoDaysUntil",
            value:
            function(e, t){
             return DifferenceISODate
                     (e.year, e.month, e.day, t.year, t.month, t.day, "day").days;
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t, r){
             var o, n, a, i, s, l = e.monthCode, d = e.day;
             if(void 0 === l){
              var _o37 = e.year, _n26 = e.era, _a19 = e.eraYear;
              if(void 0 === _o37 && (void 0 === _n26 || void 0 === _a19))
               throw new
                      TypeError
                      ("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
              var
               _this$isoToCalendarDa =
                 this.isoToCalendarDate(this.calendarToIsoDate(e, t, r), r);
              l = _this$isoToCalendarDa.monthCode;
              d = _this$isoToCalendarDa.day;
             }
             var
              m = this.isoToCalendarDate({year: 1972, month: 12, day: 31}, r),
              c =
                m.monthCode > l || m.monthCode === l && m.day >= d
                 ? m.year
                 : m.year - 1;
             for(var _e45 = 0; _e45 < 100; _e45++){
              var
               _m10 =
                 this.adjustCalendarDate
                  ({day: d, monthCode: l, year: c - _e45}, r),
               _h3 = this.calendarToIsoDate(_m10, "constrain", r),
               _u2 = this.isoToCalendarDate(_h3, r);
              if
               (o = _h3.year,
                n = _h3.month,
                a = _h3.day,
                _u2.monthCode === l && _u2.day === d)
               return {month: n, day: a, year: o};
              "constrain" === t
              &&
               (void 0 === i
               || _u2.monthCode === i.monthCode && _u2.day > i.day)
              && (i = _u2, s = _h3);
             }
             if("constrain" === t && void 0 !== s) return s;
             throw new
                    RangeError
                    ("No recent ".concat(this.id, " year with monthCode ").concat
                       (l, " and day ").concat
                      (d));
            }}]);
        return HelperBase;
       }
       (),
    HebrewHelper =
      function(_HelperBase){
        _inherits(HebrewHelper, _HelperBase);
        var _super = _createSuper(HebrewHelper);
        function HebrewHelper(){
         var _this3;
         _classCallCheck(this, HebrewHelper);
         _this3 = _super.apply(this, arguments),
         _this3.id = "hebrew",
         _this3.calendarType = "lunisolar",
         _this3.months =
          {Tishri: {leap: 1, regular: 1, monthCode: "M01", days: 30},
           Heshvan:
           {leap: 2, regular: 2, monthCode: "M02", days: {min: 29, max: 30}},
           Kislev:
           {leap: 3, regular: 3, monthCode: "M03", days: {min: 29, max: 30}},
           Tevet: {leap: 4, regular: 4, monthCode: "M04", days: 29},
           Shevat: {leap: 5, regular: 5, monthCode: "M05", days: 30},
           Adar: {leap: void 0, regular: 6, monthCode: "M06", days: 29},
           "Adar I": {leap: 6, regular: void 0, monthCode: "M05L", days: 30},
           "Adar II": {leap: 7, regular: void 0, monthCode: "M06", days: 29},
           Nisan: {leap: 8, regular: 7, monthCode: "M07", days: 30},
           Iyar: {leap: 9, regular: 8, monthCode: "M08", days: 29},
           Sivan: {leap: 10, regular: 9, monthCode: "M09", days: 30},
           Tamuz: {leap: 11, regular: 10, monthCode: "M10", days: 29},
           Av: {leap: 12, regular: 11, monthCode: "M11", days: 30},
           Elul: {leap: 13, regular: 12, monthCode: "M12", days: 29}},
         _this3.hasEra = ! 1;
         return _this3;
        }
        _createClass
         (HebrewHelper,
          [{key: "inLeapYear",
            value: function(e){var t = e.year; return (7 * t + 1) % 19 < 7;}},
           {key: "monthsInYear",
            value: function(e){return this.inLeapYear(e) ? 13 : 12;}},
           {key: "minimumMonthLength",
            value: function(e){return this.minMaxMonthLength(e, "min");}},
           {key: "maximumMonthLength",
            value: function(e){return this.minMaxMonthLength(e, "max");}},
           {key: "minMaxMonthLength",
            value:
            function(e, t){
             var
              r = e.month,
              o = e.year,
              n = this.getMonthCode(o, r),
              a =
                wt(this.months).find
                 (function(e){return e[1].monthCode === n;});
             if(void 0 === a)
              throw new RangeError("unmatched Hebrew month: ".concat(r));
             var i = a[1].days;
             return "number" == typeof i ? i : i[t];
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = e.year;
             return {year: t - 3760, month: 1, day: 1};
            }},
           {key: "getMonthCode",
            value:
            function(e, t){
             return this.inLeapYear({year: e})
                     ? 6
                       === t
                       ? buildMonthCode(5, ! 0)
                       : buildMonthCode(t < 6 ? t : t - 1)
                     : buildMonthCode(t);
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o =
                arguments.length > 3 && arguments[3] !== undefined
                 ? arguments[3]
                 : ! 1,
              n = e.year,
              a = e.eraYear,
              i = e.month,
              s = e.monthCode,
              l = e.day,
              d = e.monthExtra;
             if
              (void 0 === n && void 0 !== a && (n = a),
               void 0 === a && void 0 !== n && (a = n),
               o){
              if(d){
               var _e46 = this.months[d];
               if(! _e46)
                throw new
                       RangeError
                       ("Unrecognized month from formatToParts: ".concat(d));
               i = this.inLeapYear({year: n}) ? _e46.leap : _e46.regular;
              }
              s = this.getMonthCode(n, i);
              return {year: n,
                      month: i,
                      day: l,
                      era: void 0,
                      eraYear: a,
                      monthCode: s};
             }
             if(this.validateCalendarDate(e), void 0 === i)
              if(s.endsWith("L")){
               if("M05L" !== s)
                throw new
                       RangeError
                       ("Hebrew leap month must have monthCode M05L, not ".concat
                         (s));
               if(i = 6, ! this.inLeapYear({year: n})){
                if("reject" === r)
                 throw new
                        RangeError
                        ("Hebrew monthCode M05L is invalid in year ".concat
                          (n, " which is not a leap year"));
                i = 6, s = "M06";
               }
              }
              else{
               i = monthCodeNumberPart(s),
               this.inLeapYear({year: n}) && i >= 6 && i++;
               var _e47 = this.monthsInYear({year: n});
               if(i < 1 || i > _e47)
                throw new RangeError("Invalid monthCode: ".concat(s));
              }
             else if
              ("reject" === r
                ? (RejectToRange
                   (i, 1, this.monthsInYear({year: n})),
                  RejectToRange
                   (l, 1, this.maximumMonthLength({year: n, month: i})))
                : (i
                  = ConstrainToRange(i, 1, this.monthsInYear({year: n})),
                  l =
                   ConstrainToRange
                    (l, 1, this.maximumMonthLength({year: n, month: i}))),
               void 0 === s)
              s = this.getMonthCode(n, i);
             else if(this.getMonthCode(n, i) !== s)
              throw new
                     RangeError
                     ("monthCode ".concat(s, " doesn't correspond to month ").concat
                        (i, " in Hebrew year ").concat
                       (n));
             return _objectSpread2
                     (_objectSpread2({}, e),
                      {},
                      {day: l, month: i, monthCode: s, year: n, eraYear: a});
            }}]);
        return HebrewHelper;
       }
       (HelperBase),
    IslamicBaseHelper =
      function(_HelperBase2){
        _inherits(IslamicBaseHelper, _HelperBase2);
        var _super2 = _createSuper(IslamicBaseHelper);
        function IslamicBaseHelper(){
         var _this4;
         _classCallCheck(this, IslamicBaseHelper);
         _this4 = _super2.apply(this, arguments),
         _this4.calendarType = "lunar",
         _this4.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30,
         _this4.DAYS_PER_ISO_YEAR = 365.2425,
         _this4.constantEra = "ah";
         return _this4;
        }
        _createClass
         (IslamicBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             return 30
                    === this.daysInMonth({year: e.year, month: 12, day: 1}, t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength", value: function(){return 29;}},
           {key: "maximumMonthLength", value: function(){return 30;}},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              _this$adjustCalendarD = this.adjustCalendarDate(e),
              t = _this$adjustCalendarD.year;
             return {year:
                     St(t * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR)
                     + 622,
                     month: 1,
                     day: 1};
            }}]);
        return IslamicBaseHelper;
       }
       (HelperBase),
    IslamicHelper =
      function(_IslamicBaseHelper){
        _inherits(IslamicHelper, _IslamicBaseHelper);
        var _super3 = _createSuper(IslamicHelper);
        function IslamicHelper(){
         var _this5;
         _classCallCheck(this, IslamicHelper);
         _this5 = _super3.apply(this, arguments), _this5.id = "islamic";
         return _this5;
        }
        return _createClass(IslamicHelper);
       }
       (IslamicBaseHelper),
    IslamicUmalquraHelper =
      function(_IslamicBaseHelper2){
        _inherits(IslamicUmalquraHelper, _IslamicBaseHelper2);
        var _super4 = _createSuper(IslamicUmalquraHelper);
        function IslamicUmalquraHelper(){
         var _this6;
         _classCallCheck(this, IslamicUmalquraHelper);
         _this6 = _super4.apply(this, arguments),
         _this6.id = "islamic-umalqura";
         return _this6;
        }
        return _createClass(IslamicUmalquraHelper);
       }
       (IslamicBaseHelper),
    IslamicTblaHelper =
      function(_IslamicBaseHelper3){
        _inherits(IslamicTblaHelper, _IslamicBaseHelper3);
        var _super5 = _createSuper(IslamicTblaHelper);
        function IslamicTblaHelper(){
         var _this7;
         _classCallCheck(this, IslamicTblaHelper);
         _this7 = _super5.apply(this, arguments), _this7.id = "islamic-tbla";
         return _this7;
        }
        return _createClass(IslamicTblaHelper);
       }
       (IslamicBaseHelper),
    IslamicCivilHelper =
      function(_IslamicBaseHelper4){
        _inherits(IslamicCivilHelper, _IslamicBaseHelper4);
        var _super6 = _createSuper(IslamicCivilHelper);
        function IslamicCivilHelper(){
         var _this8;
         _classCallCheck(this, IslamicCivilHelper);
         _this8 = _super6.apply(this, arguments), _this8.id = "islamic-civil";
         return _this8;
        }
        return _createClass(IslamicCivilHelper);
       }
       (IslamicBaseHelper),
    IslamicRgsaHelper =
      function(_IslamicBaseHelper5){
        _inherits(IslamicRgsaHelper, _IslamicBaseHelper5);
        var _super7 = _createSuper(IslamicRgsaHelper);
        function IslamicRgsaHelper(){
         var _this9;
         _classCallCheck(this, IslamicRgsaHelper);
         _this9 = _super7.apply(this, arguments), _this9.id = "islamic-rgsa";
         return _this9;
        }
        return _createClass(IslamicRgsaHelper);
       }
       (IslamicBaseHelper),
    IslamicCcHelper =
      function(_IslamicBaseHelper6){
        _inherits(IslamicCcHelper, _IslamicBaseHelper6);
        var _super8 = _createSuper(IslamicCcHelper);
        function IslamicCcHelper(){
         var _this10;
         _classCallCheck(this, IslamicCcHelper);
         _this10 = _super8.apply(this, arguments), _this10.id = "islamicc";
         return _this10;
        }
        return _createClass(IslamicCcHelper);
       }
       (IslamicBaseHelper),
    PersianHelper =
      function(_HelperBase3){
        _inherits(PersianHelper, _HelperBase3);
        var _super9 = _createSuper(PersianHelper);
        function PersianHelper(){
         var _this11;
         _classCallCheck(this, PersianHelper);
         _this11 = _super9.apply(this, arguments),
         _this11.id = "persian",
         _this11.calendarType = "solar",
         _this11.constantEra = "ap";
         return _this11;
        }
        _createClass
         (PersianHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             return IslamicHelper.prototype.inLeapYear.call(this, e, t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 12 === t ? 29 : t <= 6 ? 31 : 30;
            }},
           {key: "maximumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 12 === t ? 30 : t <= 6 ? 31 : 30;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              _this$adjustCalendarD2 = this.adjustCalendarDate(e),
              t = _this$adjustCalendarD2.year;
             return {year: t + 621, month: 1, day: 1};
            }}]);
        return PersianHelper;
       }
       (HelperBase),
    IndianHelper =
      function(_HelperBase4){
        _inherits(IndianHelper, _HelperBase4);
        var _super10 = _createSuper(IndianHelper);
        function IndianHelper(){
         var _this12;
         _classCallCheck(this, IndianHelper);
         _this12 = _super10.apply(this, arguments),
         _this12.id = "indian",
         _this12.calendarType = "solar",
         _this12.constantEra = "saka",
         _this12.months =
          {1:
           {length: 30,
            month: 3,
            day: 22,
            leap: {length: 31, month: 3, day: 21}},
           2: {length: 31, month: 4, day: 21},
           3: {length: 31, month: 5, day: 22},
           4: {length: 31, month: 6, day: 22},
           5: {length: 31, month: 7, day: 23},
           6: {length: 31, month: 8, day: 23},
           7: {length: 30, month: 9, day: 23},
           8: {length: 30, month: 10, day: 23},
           9: {length: 30, month: 11, day: 22},
           10: {length: 30, month: 12, day: 22},
           11: {length: 30, month: 1, nextYear: ! 0, day: 21},
           12: {length: 30, month: 2, nextYear: ! 0, day: 20}},
         _this12.vulnerableToBceBug =
          "10/11/-79 Saka"
          !==
           new Date("0000-01-01T00:00Z").toLocaleDateString
            ("en-US-u-ca-indian", {timeZone: "UTC"});
         return _this12;
        }
        _createClass
         (IndianHelper,
          [{key: "inLeapYear",
            value: function(e){return isGregorianLeapYear(e.year + 78);}},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value: function(e){return this.getMonthInfo(e).length;}},
           {key: "maximumMonthLength",
            value: function(e){return this.getMonthInfo(e).length;}},
           {key: "getMonthInfo",
            value:
            function(e){
             var t = e.month, r = this.months[t];
             if(void 0 === r)
              throw new RangeError("Invalid month: ".concat(t));
             return this.inLeapYear(e) && r.leap && (r = r.leap), r;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = this.adjustCalendarDate(e), r = this.getMonthInfo(t);
             return AddISODate
                     (t.year + 78 + (r.nextYear ? 1 : 0),
                      r.month,
                      r.day,
                      0,
                      0,
                      0,
                      t.day - 1,
                      "constrain");
            }},
           {key: "checkIcuBugs",
            value:
            function(e){
             if(this.vulnerableToBceBug && e.year < 1)
              throw new
                     RangeError
                     ("calendar '".concat
                       (this.id,
                        "' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
            }}]);
        return IndianHelper;
       }
       (HelperBase);
   function isGregorianLeapYear(e){
    return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
   }
   var
    GregorianBaseHelper =
      function(_HelperBase5){
        _inherits(GregorianBaseHelper, _HelperBase5);
        var _super11 = _createSuper(GregorianBaseHelper);
        function GregorianBaseHelper(e, t){
         var _this13;
         _classCallCheck(this, GregorianBaseHelper);
         _this13 = _super11.call(this),
         _this13.calendarType = "solar",
         _this13.v8IsVulnerableToJulianBug =
          new Date("+001001-01-01T00:00Z").toLocaleDateString
            ("en-US-u-ca-japanese", {timeZone: "UTC"}).startsWith
           ("12"),
         _this13.calendarIsVulnerableToJulianBug = ! 1,
         _this13.id = e;
         var
          _adjustEras =
            function(e){
              var t, r = e;
              if(0 === r.length)
               throw new RangeError("Invalid era data: eras are required");
              if(1 === r.length && r[0].reverseOf)
               throw new
                      RangeError
                      ("Invalid era data: anchor era cannot count years backwards");
              if(1 === r.length && ! r[0].name)
               throw new
                      RangeError
                      ("Invalid era data: at least one named era is required");
              if
               (r.filter(function(e){return null != e.reverseOf;}).length > 1)
               throw new
                      RangeError
                      ("Invalid era data: only one era can count years backwards");
              r.forEach
               (function(e){
                 if(e.isAnchor || ! e.anchorEpoch && ! e.reverseOf){
                  if(t)
                   throw new
                          RangeError
                          ("Invalid era data: cannot have multiple anchor eras");
                  t = e, e.anchorEpoch = {year: e.hasYearZero ? 0 : 1};
                 }
                 else if(! e.name)
                  throw new
                         RangeError
                         ("If era name is blank, it must be the anchor era");
                }),
              r = r.filter(function(e){return e.name;}),
              r.forEach
               (function(e){
                 var t = e.reverseOf;
                 if(t){
                  var _o38 = r.find(function(e){return e.name === t;});
                  if(void 0 === _o38)
                   throw new
                          RangeError
                          ("Invalid era data: unmatched reverseOf era: ".concat(t));
                  e.reverseOf = _o38,
                  e.anchorEpoch = _o38.anchorEpoch,
                  e.isoEpoch = _o38.isoEpoch;
                 }
                 void 0 === e.anchorEpoch.month && (e.anchorEpoch.month = 1),
                 void 0 === e.anchorEpoch.day && (e.anchorEpoch.day = 1);
                }),
              yt.call
               (r,
                function(e, t){
                 if(e.reverseOf) return 1;
                 if(t.reverseOf) return - 1;
                 if(! e.isoEpoch || ! t.isoEpoch)
                  throw new RangeError("Invalid era data: missing ISO epoch");
                 return t.isoEpoch.year - e.isoEpoch.year;
                });
              var o = r[r.length - 1].reverseOf;
              if(o && o !== r[r.length - 2])
               throw new
                      RangeError
                      ("Invalid era data: invalid reverse-sign era");
              return r.forEach
                      (function(e, t){e.genericName = "era" + (r.length - 1 - t);}),
                     {eras: r, anchorEra: t || r[0]};
             }
             (t),
          r = _adjustEras.eras,
          o = _adjustEras.anchorEra;
         _this13.anchorEra = o, _this13.eras = r;
         return _this13;
        }
        _createClass
         (GregorianBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e){
             var
              _this$estimateIsoDate =
                this.estimateIsoDate({month: 1, day: 1, year: e.year}),
              t = _this$estimateIsoDate.year;
             return isGregorianLeapYear(t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 2 === t
                     ? this.inLeapYear(e) ? 29 : 28
                     : [4, 6, 9, 11].indexOf(t) >= 0 ? 30 : 31;
            }},
           {key: "maximumMonthLength",
            value: function(e){return this.minimumMonthLength(e);}},
           {key: "completeEraYear",
            value:
            function(e){
             var
              _this14 = this,
              _eraFromYear,
              checkField =
                function(t, r){
                 var o = e[t];
                 if(null != o && o != r)
                  throw new
                         RangeError
                         ("Input ".concat(t, " ").concat
                            (o, " doesn't match calculated value ").concat
                           (r));
                },
              eraFromYear =
                function(t){
                 var
                  r,
                  o = _objectSpread2(_objectSpread2({}, e), {}, {year: t}),
                  n =
                    _this14.eras.find
                     (function(e, n){
                       if(n === _this14.eras.length - 1){
                        if(e.reverseOf){
                         if(t > 0)
                          throw new
                                 RangeError
                                 ("Signed year ".concat(t, " is invalid for era ").concat
                                   (e.name));
                         return r = e.anchorEpoch.year - t, ! 0;
                        }
                        return r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1),
                               !
                               0;
                       }
                       return _this14.compareCalendarDates(o, e.anchorEpoch) >= 0
                              &&
                               (r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1), ! 0);
                      });
                 if(! n)
                  throw new
                         RangeError
                         ("Year ".concat(t, " was not matched by any era"));
                 return {eraYear: r, era: n.name};
                },
              t = e.year,
              r = e.eraYear,
              o = e.era;
             if(null != t)
              _eraFromYear = eraFromYear(t),
              r = _eraFromYear.eraYear,
              o = _eraFromYear.era,
              checkField("era", o),
              checkField("eraYear", r);
             else{
              if(null == r)
               throw new
                      RangeError
                      ("Either `year` or `eraYear` and `era` are required");
              {
               var
                _eraFromYear2,
                _e48 =
                  void 0 === o
                   ? void 0
                   : this.eras.find
                     (function(e){return e.name === o || e.genericName === o;});
               if(! _e48)
                throw new
                       RangeError
                       ("Era ".concat(o, " (ISO year ").concat
                         (r, ") was not matched by any era"));
               if(r < 1 && _e48.reverseOf)
                throw new
                       RangeError
                       ("Years in ".concat(o, " era must be positive, not ").concat
                         (t));
               t =
                _e48.reverseOf
                 ? _e48.anchorEpoch.year - r
                 : r + _e48.anchorEpoch.year - (_e48.hasYearZero ? 0 : 1),
               checkField("year", t),
               _eraFromYear2 = eraFromYear(t),
               r = _eraFromYear2.eraYear,
               o = _eraFromYear2.era;
              }
             }
             return _objectSpread2
                     (_objectSpread2({}, e), {}, {year: t, eraYear: r, era: o});
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o = e,
              _o39 = o,
              n = _o39.month,
              a = _o39.monthCode;
             return void 0 === n
                    &&
                     (o =
                      _objectSpread2
                       (_objectSpread2({}, o), {}, {month: monthCodeNumberPart(a)})),
                    this.validateCalendarDate(o),
                    o = this.completeEraYear(o),
                    _get
                      (_getPrototypeOf(GregorianBaseHelper.prototype),
                       "adjustCalendarDate",
                       this).call
                     (this, o, t, r);
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              t = this.adjustCalendarDate(e),
              r = t.year,
              o = t.month,
              n = t.day,
              a = this.anchorEra;
             return RegulateISODate
                     (r + a.isoEpoch.year - (a.hasYearZero ? 0 : 1),
                      o,
                      n,
                      "constrain");
            }},
           {key: "checkIcuBugs",
            value:
            function(e){
             if
              (this.calendarIsVulnerableToJulianBug
               && this.v8IsVulnerableToJulianBug)
              if(CompareISODate(e.year, e.month, e.day, 1582, 10, 15) < 0)
               throw new
                      RangeError
                      ("calendar '".concat
                        (this.id,
                         "' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)"));
            }}]);
        return GregorianBaseHelper;
       }
       (HelperBase),
    OrthodoxBaseHelper =
      function(_GregorianBaseHelper){
        _inherits(OrthodoxBaseHelper, _GregorianBaseHelper);
        var _super12 = _createSuper(OrthodoxBaseHelper);
        function OrthodoxBaseHelper(e, t){
         _classCallCheck(this, OrthodoxBaseHelper);
         return _super12.call(this, e, t);
        }
        _createClass
         (OrthodoxBaseHelper,
          [{key: "inLeapYear",
            value: function(e){var t = e.year; return (t + 1) % 4 == 0;}},
           {key: "monthsInYear", value: function(){return 13;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 13 === t ? this.inLeapYear(e) ? 6 : 5 : 30;
            }},
           {key: "maximumMonthLength",
            value: function(e){return this.minimumMonthLength(e);}}]);
        return OrthodoxBaseHelper;
       }
       (GregorianBaseHelper),
    EthioaaHelper =
      function(_OrthodoxBaseHelper){
        _inherits(EthioaaHelper, _OrthodoxBaseHelper);
        var _super13 = _createSuper(EthioaaHelper);
        function EthioaaHelper(){
         _classCallCheck(this, EthioaaHelper);
         return _super13.call
                 (this,
                  "ethioaa",
                  [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}}]);
        }
        return _createClass(EthioaaHelper);
       }
       (OrthodoxBaseHelper),
    CopticHelper =
      function(_OrthodoxBaseHelper2){
        _inherits(CopticHelper, _OrthodoxBaseHelper2);
        var _super14 = _createSuper(CopticHelper);
        function CopticHelper(){
         _classCallCheck(this, CopticHelper);
         return _super14.call
                 (this,
                  "coptic",
                  [{name: "era1", isoEpoch: {year: 284, month: 8, day: 29}},
                   {name: "era0", reverseOf: "era1"}]);
        }
        return _createClass(CopticHelper);
       }
       (OrthodoxBaseHelper),
    EthiopicHelper =
      function(_OrthodoxBaseHelper3){
        _inherits(EthiopicHelper, _OrthodoxBaseHelper3);
        var _super15 = _createSuper(EthiopicHelper);
        function EthiopicHelper(){
         _classCallCheck(this, EthiopicHelper);
         return _super15.call
                 (this,
                  "ethiopic",
                  [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}},
                   {name: "era1",
                    isoEpoch: {year: 8, month: 8, day: 27},
                    anchorEpoch: {year: 5501}}]);
        }
        return _createClass(EthiopicHelper);
       }
       (OrthodoxBaseHelper),
    RocHelper =
      function(_GregorianBaseHelper2){
        _inherits(RocHelper, _GregorianBaseHelper2);
        var _super16 = _createSuper(RocHelper);
        function RocHelper(){
         var _this15;
         _classCallCheck(this, RocHelper);
         _this15 =
          _super16.call
           (this,
            "roc",
            [{name: "minguo", isoEpoch: {year: 1912, month: 1, day: 1}},
             {name: "before-roc", reverseOf: "minguo"}]),
         _this15.calendarIsVulnerableToJulianBug = ! 0;
         return _this15;
        }
        return _createClass(RocHelper);
       }
       (GregorianBaseHelper),
    BuddhistHelper =
      function(_GregorianBaseHelper3){
        _inherits(BuddhistHelper, _GregorianBaseHelper3);
        var _super17 = _createSuper(BuddhistHelper);
        function BuddhistHelper(){
         var _this16;
         _classCallCheck(this, BuddhistHelper);
         _this16 =
          _super17.call
           (this,
            "buddhist",
            [{name: "be",
              hasYearZero: ! 0,
              isoEpoch: {year: - 543, month: 1, day: 1}}]),
         _this16.calendarIsVulnerableToJulianBug = ! 0;
         return _this16;
        }
        return _createClass(BuddhistHelper);
       }
       (GregorianBaseHelper),
    GregoryHelper =
      function(_GregorianBaseHelper4){
        _inherits(GregoryHelper, _GregorianBaseHelper4);
        var _super18 = _createSuper(GregoryHelper);
        function GregoryHelper(){
         _classCallCheck(this, GregoryHelper);
         return _super18.call
                 (this,
                  "gregory",
                  [{name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
                   {name: "bce", reverseOf: "ce"}]);
        }
        _createClass
         (GregoryHelper,
          [{key: "reviseIntlEra",
            value:
            function(e){
             var t = e.era, r = e.eraYear;
             return "bc" !== t && "b" !== t || (t = "bce"),
                    "ad" !== t && "a" !== t || (t = "ce"),
                    {era: t, eraYear: r};
            }}]);
        return GregoryHelper;
       }
       (GregorianBaseHelper),
    JapaneseHelper =
      function(_GregorianBaseHelper5){
        _inherits(JapaneseHelper, _GregorianBaseHelper5);
        var _super19 = _createSuper(JapaneseHelper);
        function JapaneseHelper(){
         var _this17;
         _classCallCheck(this, JapaneseHelper);
         _this17 =
          _super19.call
           (this,
            "japanese",
            [{name: "reiwa",
              isoEpoch: {year: 2019, month: 5, day: 1},
              anchorEpoch: {year: 2019, month: 5, day: 1}},
             {name: "heisei",
              isoEpoch: {year: 1989, month: 1, day: 8},
              anchorEpoch: {year: 1989, month: 1, day: 8}},
             {name: "showa",
              isoEpoch: {year: 1926, month: 12, day: 25},
              anchorEpoch: {year: 1926, month: 12, day: 25}},
             {name: "taisho",
              isoEpoch: {year: 1912, month: 7, day: 30},
              anchorEpoch: {year: 1912, month: 7, day: 30}},
             {name: "meiji",
              isoEpoch: {year: 1868, month: 9, day: 8},
              anchorEpoch: {year: 1868, month: 9, day: 8}},
             {name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
             {name: "bce", reverseOf: "ce"}]),
         _this17.calendarIsVulnerableToJulianBug = ! 0,
         _this17.eraLength = "long",
         _this17.erasBeginMidYear = ! 0;
         return _this17;
        }
        _createClass
         (JapaneseHelper,
          [{key: "reviseIntlEra",
            value:
            function(e, t){
             var r = e.era, o = e.eraYear, n = t.year;
             return this.eras.find(function(e){return e.name === r;})
                     ? {era: r, eraYear: o}
                     : n
                       < 1
                       ? {era: "bce", eraYear: 1 - n}
                       : {era: "ce", eraYear: n};
            }}]);
        return JapaneseHelper;
       }
       (GregorianBaseHelper),
    ChineseBaseHelper =
      function(_HelperBase6){
        _inherits(ChineseBaseHelper, _HelperBase6);
        var _super20 = _createSuper(ChineseBaseHelper);
        function ChineseBaseHelper(){
         var _this18;
         _classCallCheck(this, ChineseBaseHelper);
         _this18 = _super20.apply(this, arguments),
         _this18.calendarType = "lunisolar",
         _this18.hasEra = ! 1;
         return _this18;
        }
        _createClass
         (ChineseBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             var r = this.getMonthList(e.year, t);
             return 13 === wt(r).length;
            }},
           {key: "monthsInYear",
            value: function(e, t){return this.inLeapYear(e, t) ? 13 : 12;}},
           {key: "minimumMonthLength", value: function(){return 29;}},
           {key: "maximumMonthLength", value: function(){return 30;}},
           {key: "getMonthList",
            value:
            function(e, t){
             var _this19 = this, _getCalendarDate2;
             if(void 0 === e) throw new TypeError("Missing year");
             var
              r =
                JSON.stringify
                 ({func: "getMonthList", calendarYear: e, id: this.id}),
              o = t.get(r);
             if(o) return o;
             var
              n = this.getFormatter(),
              getCalendarDate =
                function(e, t){
                 var
                  r = toUtcIsoDateString({isoYear: e, isoMonth: 2, isoDay: 1}),
                  o = new Date(r);
                 o.setUTCDate(t + 1);
                 var
                  a = n.formatToParts(o),
                  i = a.find(function(e){return "month" === e.type;}).value,
                  s = + a.find(function(e){return "day" === e.type;}).value,
                  l = a.find(function(e){return "relatedYear" === e.type;});
                 if(void 0 === l)
                  throw new
                         RangeError
                         ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
                           (_this19.id, " calendar. Try Node 14+ or modern browsers."));
                 return l = + l.value,
                        {calendarMonthString: i,
                         calendarDay: s,
                         calendarYearToVerify: l};
                },
              a = 17,
              _getCalendarDate = getCalendarDate(e, a),
              i = _getCalendarDate.calendarMonthString,
              s = _getCalendarDate.calendarDay,
              l = _getCalendarDate.calendarYearToVerify;
             "1" !== i
             &&
              (a += 29,
               _getCalendarDate2 = getCalendarDate(e, a),
               i = _getCalendarDate2.calendarMonthString,
               s = _getCalendarDate2.calendarDay),
             a -= s - 5;
             var d = {}, m, c, h = 1, u = ! 1;
             do{
              var _getCalendarDate3;
              _getCalendarDate3 = getCalendarDate(e, a),
              i = _getCalendarDate3.calendarMonthString,
              s = _getCalendarDate3.calendarDay,
              l = _getCalendarDate3.calendarYearToVerify,
              m && (d[c].daysInMonth = m + 30 - s),
              l !== e ? u = ! 0 : (d[i] = {monthIndex: h++}, a += 30),
              m = s,
              c = i;
             }
             while
              (! u);
             return d[c].daysInMonth = m + 30 - s, t.set(r, d), d;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = e.year, r = e.month;
             return {year: t, month: r >= 12 ? 12 : r + 1, day: 1};
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o =
                arguments.length > 3 && arguments[3] !== undefined
                 ? arguments[3]
                 : ! 1,
              n = e.year,
              a = e.month,
              i = e.monthExtra,
              s = e.day,
              l = e.monthCode,
              d = e.eraYear;
             if(o){
              if(n = d, i && "bis" !== i)
               throw new
                      RangeError
                      ("Unexpected leap month suffix: ".concat(i));
              var
               _e49 = buildMonthCode(a, void 0 !== i),
               _r65 = "".concat(a).concat(i || ""),
               _o40 = this.getMonthList(n, t)[_r65];
              if(void 0 === _o40)
               throw new
                      RangeError
                      ("Unmatched month ".concat(_r65, " in Chinese year ").concat
                        (n));
              return a = _o40.monthIndex,
                     {year: n,
                      month: a,
                      day: s,
                      era: void 0,
                      eraYear: d,
                      monthCode: _e49};
             }
             if
              (this.validateCalendarDate(e),
               void 0 === n && (n = d),
               void 0 === d && (d = n),
               void 0 === a){
              var
               _e50 = this.getMonthList(n, t),
               _o41 = l.replace("L", "bis").slice(1);
              "0" === _o41[0] && (_o41 = _o41.slice(1));
              var _i19 = _e50[_o41];
              if
               (a = _i19 && _i19.monthIndex,
                void 0 === a && l.endsWith("L") && "M13L" != l
                && "constrain" === r){
               var _t48 = l.slice(1, - 1);
               "0" === _t48[0] && (_t48 = _t48.slice(1)),
               _i19 = _e50[_t48],
               _i19 && (a = _i19.monthIndex, l = buildMonthCode(_t48));
              }
              if(void 0 === a)
               throw new
                      RangeError
                      ("Unmatched month ".concat(l, " in Chinese year ").concat(n));
             }
             else if(void 0 === l){
              var
               _e51 = this.getMonthList(n, t),
               _o42 = wt(_e51),
               _i20 = _o42.length;
              "reject" === r
               ? (RejectToRange
                  (a, 1, _i20),
                 RejectToRange(s, 1, this.maximumMonthLength()))
               : (a
                 = ConstrainToRange(a, 1, _i20),
                 s = ConstrainToRange(s, 1, this.maximumMonthLength()));
              var
               _d11 =
                 _o42.find
                  (function(_ref10){
                    var _ref11 = _slicedToArray(_ref10, 2), e = _ref11[1];
                    return e.monthIndex === a;
                   });
              if(void 0 === _d11)
               throw new
                      RangeError
                      ("Invalid month ".concat(a, " in Chinese year ").concat(n));
              l =
               buildMonthCode
                (_d11[0].replace("bis", ""), - 1 !== _d11[0].indexOf("bis"));
             }
             else{
              var
               _e52 = this.getMonthList(n, t),
               _r66 = l.replace("L", "bis").slice(1);
              "0" === _r66[0] && (_r66 = _r66.slice(1));
              var _o43 = _e52[_r66];
              if(! _o43)
               throw new
                      RangeError
                      ("Unmatched monthCode ".concat(l, " in Chinese year ").concat
                        (n));
              if(a !== _o43.monthIndex)
               throw new
                      RangeError
                      ("monthCode ".concat(l, " doesn't correspond to month ").concat
                         (a, " in Chinese year ").concat
                        (n));
             }
             return _objectSpread2
                     (_objectSpread2({}, e),
                      {},
                      {year: n, eraYear: d, month: a, monthCode: l, day: s});
            }}]);
        return ChineseBaseHelper;
       }
       (HelperBase),
    ChineseHelper =
      function(_ChineseBaseHelper){
        _inherits(ChineseHelper, _ChineseBaseHelper);
        var _super21 = _createSuper(ChineseHelper);
        function ChineseHelper(){
         var _this20;
         _classCallCheck(this, ChineseHelper);
         _this20 = _super21.apply(this, arguments), _this20.id = "chinese";
         return _this20;
        }
        return _createClass(ChineseHelper);
       }
       (ChineseBaseHelper),
    DangiHelper =
      function(_ChineseBaseHelper2){
        _inherits(DangiHelper, _ChineseBaseHelper2);
        var _super22 = _createSuper(DangiHelper);
        function DangiHelper(){
         var _this21;
         _classCallCheck(this, DangiHelper);
         _this21 = _super22.apply(this, arguments), _this21.id = "dangi";
         return _this21;
        }
        return _createClass(DangiHelper);
       }
       (ChineseBaseHelper),
    NonIsoCalendar =
      function(){
        function NonIsoCalendar(e){
         _classCallCheck(this, NonIsoCalendar);
         this.helper = e;
        }
        _createClass
         (NonIsoCalendar,
          [{key: "dateFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["day", "month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$calendar = this.helper.calendarToIsoDate(n, a, o),
              i = _this$helper$calendar.year,
              s = _this$helper$calendar.month,
              l = _this$helper$calendar.day,
              d = CreateTemporalDate(i, s, l, r);
             return o.setObject(d), d;
            }},
           {key: "yearMonthFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$calendar2 =
                this.helper.calendarToIsoDate
                 (_objectSpread2(_objectSpread2({}, n), {}, {day: 1}), a, o),
              i = _this$helper$calendar2.year,
              s = _this$helper$calendar2.month,
              l = _this$helper$calendar2.day,
              d = CreateTemporalYearMonth(i, s, r, l);
             return o.setObject(d), d;
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["day", "month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$monthDay = this.helper.monthDayFromFields(n, a, o),
              i = _this$helper$monthDay.year,
              s = _this$helper$monthDay.month,
              l = _this$helper$monthDay.day,
              d = CreateTemporalMonthDay(s, l, r, i);
             return o.setObject(d), d;
            }},
           {key: "fields",
            value:
            function(e){
             var t = e;
             return Tt.call(t, "year")
                    &&
                     (t = [].concat(_toConsumableArray(t), ["era", "eraYear"])),
                    t;
            }},
           {key: "fieldKeysToIgnore",
            value:
            function(e){
             var t = new Dt();
             for(var _r67 = 0; _r67 < e.length; _r67++){
              var _o44 = e[_r67];
              switch(Call(vt, t, [_o44]), _o44){
                case "era":
                 Call(vt, t, ["eraYear"]), Call(vt, t, ["year"]); break;
                case "eraYear":
                 Call(vt, t, ["era"]), Call(vt, t, ["year"]); break;
                case "year":
                 Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]); break;
                case "month":
                 Call(vt, t, ["monthCode"]),
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
                 break;
                case "monthCode":
                 Call(vt, t, ["month"]),
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
                 break;
                case "day":
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
              }
             }
             return _toConsumableArray(Call(Ct, t, []));
            }},
           {key: "dateAdd",
            value:
            function(e, t, r, o, n, a, i){
             var
              s = OneObjectCache.getCacheForObject(e),
              l = this.helper.temporalToCalendarDate(e, s),
              d =
                this.helper.addCalendar
                 (l, {years: t, months: r, weeks: o, days: n}, a, s),
              m = this.helper.calendarToIsoDate(d, "constrain", s),
              c = m.year,
              h = m.month,
              u = m.day,
              T = CreateTemporalDate(c, h, u, i);
             return new OneObjectCache(s).setObject(T), T;
            }},
           {key: "dateUntil",
            value:
            function(e, t, r){
             var
              o = OneObjectCache.getCacheForObject(e),
              n = OneObjectCache.getCacheForObject(t),
              a = this.helper.temporalToCalendarDate(e, o),
              i = this.helper.temporalToCalendarDate(t, n);
             return this.helper.untilCalendar(a, i, r, o);
            }},
           {key: "year",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).year;
            }},
           {key: "month",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).month;
            }},
           {key: "day",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).day;
            }},
           {key: "era",
            value:
            function(e){
             if(! this.helper.hasEra) return;
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).era;
            }},
           {key: "eraYear",
            value:
            function(e){
             if(! this.helper.hasEra) return;
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).eraYear;
            }},
           {key: "monthCode",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).monthCode;
            }},
           {key: "dayOfWeek",
            value: function(e){return Ot.iso8601.dayOfWeek(e);}},
           {key: "dayOfYear",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.isoToCalendarDate(e, t),
              o = this.helper.startOfCalendarYear(r);
             return this.helper.calendarDaysUntil(o, r, t) + 1;
            }},
           {key: "weekOfYear",
            value: function(e){return Ot.iso8601.weekOfYear(e);}},
           {key: "yearOfWeek",
            value: function(e){return Ot.iso8601.yearOfWeek(e);}},
           {key: "daysInWeek",
            value: function(e){return Ot.iso8601.daysInWeek(e);}},
           {key: "daysInMonth",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.temporalToCalendarDate(e, t),
              o = this.helper.maximumMonthLength(r);
             if(o === this.helper.minimumMonthLength(r)) return o;
             var
              n = this.helper.startOfCalendarMonth(r),
              a = this.helper.addMonthsCalendar(n, 1, "constrain", t);
             return this.helper.calendarDaysUntil(n, a, t);
            }},
           {key: "daysInYear",
            value:
            function(e){
             var t = e;
             HasSlot(t, i) || (t = ToTemporalDate(t));
             var
              r = OneObjectCache.getCacheForObject(t),
              o = this.helper.temporalToCalendarDate(t, r),
              n = this.helper.startOfCalendarYear(o),
              a = this.helper.addCalendar(n, {years: 1}, "constrain", r);
             return this.helper.calendarDaysUntil(n, a, r);
            }},
           {key: "monthsInYear",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.temporalToCalendarDate(e, t);
             return this.helper.monthsInYear(r, t);
            }},
           {key: "inLeapYear",
            value:
            function(e){
             var t = e;
             HasSlot(t, i) || (t = ToTemporalDate(t));
             var
              r = OneObjectCache.getCacheForObject(t),
              o = this.helper.temporalToCalendarDate(t, r);
             return this.helper.inLeapYear(o, r);
            }}]);
        return NonIsoCalendar;
       }
       ();
   for
   (var
     _i21 = 0,
     _arr7 =
       [HebrewHelper,
        PersianHelper,
        EthiopicHelper,
        EthioaaHelper,
        CopticHelper,
        ChineseHelper,
        DangiHelper,
        RocHelper,
        IndianHelper,
        BuddhistHelper,
        GregoryHelper,
        JapaneseHelper,
        IslamicHelper,
        IslamicUmalquraHelper,
        IslamicTblaHelper,
        IslamicCivilHelper,
        IslamicRgsaHelper,
        IslamicCcHelper];
    _i21 < _arr7.length;
    _i21++){
    var _e53 = _arr7[_i21], _t49 = new _e53();
    Ot[_t49.id] = new NonIsoCalendar(_t49);
   }
   var
    PlainDate =
      function(){
        function PlainDate(e, t, r){
         var
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : "iso8601";
         _classCallCheck(this, PlainDate);
         CreateTemporalDateSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToIntegerWithTruncation(r),
           ToTemporalCalendarSlotValue(o));
        }
        _createClass
         (PlainDate,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), this);
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), this);
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), this);
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), this);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["day", "month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarDateFromFields(o, a, r);
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return new
                     PlainDate
                     (GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var r = ToTemporalDuration(e), o = GetOptionsObject(t);
             return CalendarDateAdd(GetSlot(this, p), this, r, o);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var
              r = CreateNegatedTemporalDuration(ToTemporalDuration(e)),
              o = GetOptionsObject(t);
             return CalendarDateAdd(GetSlot(this, p), this, r, o);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDate("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDate("since", this, e, t);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             for(var _i22 = 0, _arr8 = [i, s, l]; _i22 < _arr8.length; _i22++){
              var _e54 = _arr8[_i22];
              if(GetSlot(this, _e54) !== GetSlot(t, _e54)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return TemporalDateToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return TemporalDateToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainDate");
            }},
           {key: "toPlainDateTime",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, i),
              r = GetSlot(this, s),
              o = GetSlot(this, l),
              n = GetSlot(this, p);
             if(void 0 === e)
              return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
             var a = ToTemporalTime(e);
             return CreateTemporalDateTime
                     (t,
                      r,
                      o,
                      GetSlot(a, d),
                      GetSlot(a, m),
                      GetSlot(a, c),
                      GetSlot(a, h),
                      GetSlot(a, u),
                      GetSlot(a, T),
                      n);
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t, r;
             if(IsObject(e))
              if(IsTemporalTimeZone(e))
               t = e;
              else{
               var _o45 = e.timeZone;
               void 0 === _o45
                ? t = ToTemporalTimeZoneSlotValue(e)
                : (t = ToTemporalTimeZoneSlotValue(_o45), r = e.plainTime);
              }
             else
              t = ToTemporalTimeZoneSlotValue(e);
             var
              o = GetSlot(this, i),
              a = GetSlot(this, s),
              f = GetSlot(this, l),
              y = GetSlot(this, p),
              I = 0,
              S = 0,
              g = 0,
              w = 0,
              D = 0,
              G = 0;
             void 0 !== r
             &&
              (r = ToTemporalTime(r),
               I = GetSlot(r, d),
               S = GetSlot(r, m),
               g = GetSlot(r, c),
               w = GetSlot(r, h),
               D = GetSlot(r, u),
               G = GetSlot(r, T));
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (t,
                          CreateTemporalDateTime(o, a, f, I, S, g, w, D, G, y),
                          "compatible"),
                        n),
                      t,
                      y);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalDate(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalDate
                        (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p)))
                     : ToTemporalDate(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalDate(e), o = ToTemporalDate(t);
             return CompareISODate
                     (GetSlot(r, i),
                      GetSlot(r, s),
                      GetSlot(r, l),
                      GetSlot(o, i),
                      GetSlot(o, s),
                      GetSlot(o, l));
            }}]);
        return PlainDate;
       }
       ();
   MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
   var
    PlainDateTime =
      function(){
        function PlainDateTime(e, t, r){
         var
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0,
          i =
            arguments.length > 6 && arguments[6] !== undefined
             ? arguments[6]
             : 0,
          s =
            arguments.length > 7 && arguments[7] !== undefined
             ? arguments[7]
             : 0,
          l =
            arguments.length > 8 && arguments[8] !== undefined
             ? arguments[8]
             : 0,
          d =
            arguments.length > 9 && arguments[9] !== undefined
             ? arguments[9]
             : "iso8601";
         _classCallCheck(this, PlainDateTime);
         CreateTemporalDateTimeSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToIntegerWithTruncation(r),
           void 0 === o ? 0 : ToIntegerWithTruncation(o),
           void 0 === n ? 0 : ToIntegerWithTruncation(n),
           void 0 === a ? 0 : ToIntegerWithTruncation(a),
           void 0 === i ? 0 : ToIntegerWithTruncation(i),
           void 0 === s ? 0 : ToIntegerWithTruncation(s),
           void 0 === l ? 0 : ToIntegerWithTruncation(l),
           ToTemporalCalendarSlotValue(d));
        }
        _createClass
         (PlainDateTime,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "hour",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, T);
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), this);
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), this);
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), this);
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), this);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n =
                CalendarFields
                 (o,
                  ["day",
                   "hour",
                   "microsecond",
                   "millisecond",
                   "minute",
                   "month",
                   "monthCode",
                   "nanosecond",
                   "second",
                   "year"]),
              a = PrepareTemporalFields(this, n, []);
             a =
              CalendarMergeFields
               (o, a, PrepareTemporalFields(e, n, "partial")),
             a = PrepareTemporalFields(a, n, []);
             var
              _InterpretTemporalDat4 =
                InterpretTemporalDateTimeFields(o, a, r),
              i = _InterpretTemporalDat4.year,
              s = _InterpretTemporalDat4.month,
              l = _InterpretTemporalDat4.day,
              d = _InterpretTemporalDat4.hour,
              m = _InterpretTemporalDat4.minute,
              c = _InterpretTemporalDat4.second,
              h = _InterpretTemporalDat4.millisecond,
              u = _InterpretTemporalDat4.microsecond,
              T = _InterpretTemporalDat4.nanosecond;
             return CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, o);
            }},
           {key: "withPlainTime",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, i),
              r = GetSlot(this, s),
              o = GetSlot(this, l),
              n = GetSlot(this, p);
             if(void 0 === e)
              return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
             var a = ToTemporalTime(e);
             return CreateTemporalDateTime
                     (t,
                      r,
                      o,
                      GetSlot(a, d),
                      GetSlot(a, m),
                      GetSlot(a, c),
                      GetSlot(a, h),
                      GetSlot(a, u),
                      GetSlot(a, T),
                      n);
            }},
           {key: "withPlainDate",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              n = GetSlot(t, l),
              a = GetSlot(t, p),
              f = GetSlot(this, d),
              y = GetSlot(this, m),
              I = GetSlot(this, c),
              S = GetSlot(this, h),
              g = GetSlot(this, u),
              w = GetSlot(this, T);
             return a = ConsolidateCalendars(GetSlot(this, p), a),
                    CreateTemporalDateTime(r, o, n, f, y, I, S, g, w, a);
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return new
                     PlainDateTime
                     (GetSlot(this, i),
                      GetSlot(this, s),
                      GetSlot(this, l),
                      GetSlot(this, d),
                      GetSlot(this, m),
                      GetSlot(this, c),
                      GetSlot(this, h),
                      GetSlot(this, u),
                      GetSlot(this, T),
                      t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainDateTime
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainDateTime
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDateTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDateTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             var _RoundISODateTime2;
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              n = GetTemporalUnit(t, "smallestUnit", "time", He, ["day"]),
              a =
                {day: 1,
                  hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [n];
             ValidateTemporalRoundingIncrement(r, a, 1 === a);
             var
              f = GetSlot(this, i),
              y = GetSlot(this, s),
              I = GetSlot(this, l),
              S = GetSlot(this, d),
              g = GetSlot(this, m),
              w = GetSlot(this, c),
              D = GetSlot(this, h),
              G = GetSlot(this, u),
              v = GetSlot(this, T);
             return _RoundISODateTime2 =
                     RoundISODateTime(f, y, I, S, g, w, D, G, v, r, n, o),
                    f = _RoundISODateTime2.year,
                    y = _RoundISODateTime2.month,
                    I = _RoundISODateTime2.day,
                    S = _RoundISODateTime2.hour,
                    g = _RoundISODateTime2.minute,
                    w = _RoundISODateTime2.second,
                    D = _RoundISODateTime2.millisecond,
                    G = _RoundISODateTime2.microsecond,
                    v = _RoundISODateTime2.nanosecond,
                    CreateTemporalDateTime
                     (f, y, I, S, g, w, D, G, v, GetSlot(this, p));
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDateTime(e);
             for
             (var _i23 = 0, _arr9 = [i, s, l, d, m, c, h, u, T];
              _i23 < _arr9.length;
              _i23++){
              var _e55 = _arr9[_i23];
              if(GetSlot(this, _e55) !== GetSlot(t, _e55)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToCalendarNameOption(t),
              o = ToFractionalSecondDigits(t),
              n = ToTemporalRoundingMode(t, "trunc"),
              a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === a)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              _ToSecondsStringPreci2 = ToSecondsStringPrecisionRecord(a, o),
              i = _ToSecondsStringPreci2.precision,
              s = _ToSecondsStringPreci2.unit,
              l = _ToSecondsStringPreci2.increment;
             return TemporalDateTimeToString
                     (this, i, r, {unit: s, increment: l, roundingMode: n});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToString(this, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainDateTime");
            }},
           {key: "toZonedDateTime",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var r = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (r, this, ToTemporalDisambiguation(GetOptionsObject(t))),
                        n),
                      r,
                      GetSlot(this, p));
            }},
           {key: "toPlainDate",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToDate(this);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "toPlainTime",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToTime(this);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoHour: GetSlot(this, d),
                     isoMicrosecond: GetSlot(this, u),
                     isoMillisecond: GetSlot(this, h),
                     isoMinute: GetSlot(this, m),
                     isoMonth: GetSlot(this, s),
                     isoNanosecond: GetSlot(this, T),
                     isoSecond: GetSlot(this, c),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalDateTime(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalDateTime
                        (GetSlot(e, i),
                         GetSlot(e, s),
                         GetSlot(e, l),
                         GetSlot(e, d),
                         GetSlot(e, m),
                         GetSlot(e, c),
                         GetSlot(e, h),
                         GetSlot(e, u),
                         GetSlot(e, T),
                         GetSlot(e, p)))
                     : ToTemporalDateTime(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalDateTime(e), o = ToTemporalDateTime(t);
             for
             (var _i24 = 0, _arr10 = [i, s, l, d, m, c, h, u, T];
              _i24 < _arr10.length;
              _i24++){
              var
               _e56 = _arr10[_i24],
               _t50 = GetSlot(r, _e56),
               _n27 = GetSlot(o, _e56);
              if(_t50 !== _n27) return ComparisonResult(_t50 - _n27);
             }
             return 0;
            }}]);
        return PlainDateTime;
       }
       ();
   MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
   var
    Duration =
      function(){
        function Duration(){
         var
          e =
            arguments.length > 0 && arguments[0] !== undefined
             ? arguments[0]
             : 0,
          t =
            arguments.length > 1 && arguments[1] !== undefined
             ? arguments[1]
             : 0,
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : 0,
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0,
          i =
            arguments.length > 6 && arguments[6] !== undefined
             ? arguments[6]
             : 0,
          s =
            arguments.length > 7 && arguments[7] !== undefined
             ? arguments[7]
             : 0,
          l =
            arguments.length > 8 && arguments[8] !== undefined
             ? arguments[8]
             : 0,
          d =
            arguments.length > 9 && arguments[9] !== undefined
             ? arguments[9]
             : 0;
         _classCallCheck(this, Duration);
         var
          m = void 0 === e ? 0 : ToIntegerIfIntegral(e),
          c = void 0 === t ? 0 : ToIntegerIfIntegral(t),
          h = void 0 === r ? 0 : ToIntegerIfIntegral(r),
          u = void 0 === o ? 0 : ToIntegerIfIntegral(o),
          T = void 0 === n ? 0 : ToIntegerIfIntegral(n),
          p = void 0 === a ? 0 : ToIntegerIfIntegral(a),
          f = void 0 === i ? 0 : ToIntegerIfIntegral(i),
          y = void 0 === s ? 0 : ToIntegerIfIntegral(s),
          I = void 0 === l ? 0 : ToIntegerIfIntegral(l),
          S = void 0 === d ? 0 : ToIntegerIfIntegral(d);
         RejectDuration(m, c, h, u, T, p, f, y, I, S),
         N(this),
         SetSlot(this, w, m),
         SetSlot(this, D, c),
         SetSlot(this, G, h),
         SetSlot(this, v, u),
         SetSlot(this, C, T),
         SetSlot(this, O, p),
         SetSlot(this, b, f),
         SetSlot(this, E, y),
         SetSlot(this, M, I),
         SetSlot(this, R, S);
        }
        _createClass
         (Duration,
          [{key: "years",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, w);
            }},
           {key: "months",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, D);
            }},
           {key: "weeks",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, G);
            }},
           {key: "days",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, v);
            }},
           {key: "hours",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, C);
            }},
           {key: "minutes",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, O);
            }},
           {key: "seconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, b);
            }},
           {key: "milliseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, E);
            }},
           {key: "microseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, M);
            }},
           {key: "nanoseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, R);
            }},
           {key: "sign",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return DurationSign
                     (GetSlot(this, w),
                      GetSlot(this, D),
                      GetSlot(this, G),
                      GetSlot(this, v),
                      GetSlot(this, C),
                      GetSlot(this, O),
                      GetSlot(this, b),
                      GetSlot(this, E),
                      GetSlot(this, M),
                      GetSlot(this, R));
            }},
           {key: "blank",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return 0
                    ===
                     DurationSign
                      (GetSlot(this, w),
                       GetSlot(this, D),
                       GetSlot(this, G),
                       GetSlot(this, v),
                       GetSlot(this, C),
                       GetSlot(this, O),
                       GetSlot(this, b),
                       GetSlot(this, E),
                       GetSlot(this, M),
                       GetSlot(this, R));
            }},
           {key: "with",
            value:
            function(e){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t =
                PrepareTemporalFields
                 (e,
                  ["days",
                   "hours",
                   "microseconds",
                   "milliseconds",
                   "minutes",
                   "months",
                   "nanoseconds",
                   "seconds",
                   "weeks",
                   "years"],
                  "partial"),
              _t$years = t.years,
              r = _t$years === void 0 ? GetSlot(this, w) : _t$years,
              _t$months = t.months,
              o = _t$months === void 0 ? GetSlot(this, D) : _t$months,
              _t$weeks = t.weeks,
              n = _t$weeks === void 0 ? GetSlot(this, G) : _t$weeks,
              _t$days = t.days,
              a = _t$days === void 0 ? GetSlot(this, v) : _t$days,
              _t$hours = t.hours,
              i = _t$hours === void 0 ? GetSlot(this, C) : _t$hours,
              _t$minutes = t.minutes,
              s = _t$minutes === void 0 ? GetSlot(this, O) : _t$minutes,
              _t$seconds = t.seconds,
              l = _t$seconds === void 0 ? GetSlot(this, b) : _t$seconds,
              _t$milliseconds = t.milliseconds,
              d =
                _t$milliseconds === void 0
                 ? GetSlot(this, E)
                 : _t$milliseconds,
              _t$microseconds = t.microseconds,
              m =
                _t$microseconds === void 0
                 ? GetSlot(this, M)
                 : _t$microseconds,
              _t$nanoseconds = t.nanoseconds,
              c =
                _t$nanoseconds === void 0 ? GetSlot(this, R) : _t$nanoseconds;
             return new Duration(r, o, n, a, i, s, l, d, m, c);
            }},
           {key: "negated",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return CreateNegatedTemporalDuration(this);
            }},
           {key: "abs",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return new
                     Duration
                     (Math.abs(GetSlot(this, w)),
                      Math.abs(GetSlot(this, D)),
                      Math.abs(GetSlot(this, G)),
                      Math.abs(GetSlot(this, v)),
                      Math.abs(GetSlot(this, C)),
                      Math.abs(GetSlot(this, O)),
                      Math.abs(GetSlot(this, b)),
                      Math.abs(GetSlot(this, E)),
                      Math.abs(GetSlot(this, M)),
                      Math.abs(GetSlot(this, R)));
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromDuration
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromDuration
                     ("subtract", this, e, t);
            }},
           {key: "round",
            value:
            function(t){
             var
              _UnbalanceDurationRel,
              _RoundDuration8,
              _AdjustRoundedDuratio2,
              _BalanceDuration11,
              _BalanceDurationRelat;
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             if(void 0 === t)
              throw new TypeError("options parameter is required");
             var
              r = GetSlot(this, w),
              o = GetSlot(this, D),
              n = GetSlot(this, G),
              a = GetSlot(this, v),
              i = GetSlot(this, C),
              s = GetSlot(this, O),
              l = GetSlot(this, b),
              d = GetSlot(this, E),
              m = GetSlot(this, M),
              c = GetSlot(this, R),
              h = DefaultTemporalLargestUnit(r, o, n, a, i, s, l, d, m, c),
              u =
                "string" == typeof t
                 ? CreateOnePropObject("smallestUnit", t)
                 : GetOptionsObject(t),
              T =
                GetTemporalUnit
                 (u, "largestUnit", "datetime", void 0, ["auto"]),
              f = ToRelativeTemporalObject(u),
              y = ToTemporalRoundingIncrement(u),
              I = ToTemporalRoundingMode(u, "halfExpand"),
              S = GetTemporalUnit(u, "smallestUnit", "datetime", void 0),
              g = ! 0;
             S || (g = ! 1, S = "nanosecond"),
             h = LargerOfTwoTemporalUnits(h, S);
             var F = ! 0;
             if(T || (F = ! 1, T = h), "auto" === T && (T = h), ! g && ! F)
              throw new
                     RangeError
                     ("at least one of smallestUnit or largestUnit is required");
             if(LargerOfTwoTemporalUnits(T, S) !== T)
              throw new
                     RangeError
                     ("largestUnit ".concat
                        (T, " cannot be smaller than smallestUnit ").concat
                       (S));
             var
              Y =
                {hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [S];
             return void 0 !== Y
                    && ValidateTemporalRoundingIncrement(y, Y, ! 1),
                    _UnbalanceDurationRel =
                     UnbalanceDurationRelative(r, o, n, a, T, f),
                    r = _UnbalanceDurationRel.years,
                    o = _UnbalanceDurationRel.months,
                    n = _UnbalanceDurationRel.weeks,
                    a = _UnbalanceDurationRel.days,
                    _RoundDuration8 =
                     RoundDuration(r, o, n, a, i, s, l, d, m, c, y, S, I, f),
                    r = _RoundDuration8.years,
                    o = _RoundDuration8.months,
                    n = _RoundDuration8.weeks,
                    a = _RoundDuration8.days,
                    i = _RoundDuration8.hours,
                    s = _RoundDuration8.minutes,
                    l = _RoundDuration8.seconds,
                    d = _RoundDuration8.milliseconds,
                    m = _RoundDuration8.microseconds,
                    c = _RoundDuration8.nanoseconds,
                    _AdjustRoundedDuratio2 =
                     AdjustRoundedDurationDays
                      (r, o, n, a, i, s, l, d, m, c, y, S, I, f),
                    r = _AdjustRoundedDuratio2.years,
                    o = _AdjustRoundedDuratio2.months,
                    n = _AdjustRoundedDuratio2.weeks,
                    a = _AdjustRoundedDuratio2.days,
                    i = _AdjustRoundedDuratio2.hours,
                    s = _AdjustRoundedDuratio2.minutes,
                    l = _AdjustRoundedDuratio2.seconds,
                    d = _AdjustRoundedDuratio2.milliseconds,
                    m = _AdjustRoundedDuratio2.microseconds,
                    c = _AdjustRoundedDuratio2.nanoseconds,
                    _BalanceDuration11 =
                     BalanceDuration(a, i, s, l, d, m, c, T, f),
                    a = _BalanceDuration11.days,
                    i = _BalanceDuration11.hours,
                    s = _BalanceDuration11.minutes,
                    l = _BalanceDuration11.seconds,
                    d = _BalanceDuration11.milliseconds,
                    m = _BalanceDuration11.microseconds,
                    c = _BalanceDuration11.nanoseconds,
                    _BalanceDurationRelat =
                     function(t, r, o, n, a, i){
                       var
                        s = GetIntrinsic("%Temporal.Duration%"),
                        l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
                       if(0 === l) return {years: t, months: r, weeks: o, days: n};
                       var
                        d = BigInt(l),
                        m,
                        c,
                        h = BigInt(t),
                        u = BigInt(r),
                        T = BigInt(o),
                        f = BigInt(n);
                       i && (c = ToTemporalDate(i), m = GetSlot(c, p));
                       var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
                       switch(a){
                         case "year":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for years balancing");
                           var
                            _t51 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r68,
                            _o46,
                            _n28;
                           for
                           (_MoveRelativeDate11 = MoveRelativeDate(m, c, y, _t51),
                            _r68 = _MoveRelativeDate11.relativeTo,
                            _o46 = _MoveRelativeDate11.days,
                            _MoveRelativeDate11;
                            abs(f) >= BigInt(ae(_o46));){
                            var _MoveRelativeDate11, _MoveRelativeDate12;
                            f = f - BigInt(_o46),
                            h = h + d,
                            c = _r68,
                            _MoveRelativeDate12 = MoveRelativeDate(m, c, y, _t51),
                            _r68 = _MoveRelativeDate12.relativeTo,
                            _o46 = _MoveRelativeDate12.days;
                           }
                           for
                           (_MoveRelativeDate13 = MoveRelativeDate(m, c, I, _t51),
                            _r68 = _MoveRelativeDate13.relativeTo,
                            _n28 = _MoveRelativeDate13.days,
                            _MoveRelativeDate13;
                            abs(f) >= BigInt(ae(_n28));){
                            var _MoveRelativeDate13, _MoveRelativeDate14;
                            f = f - BigInt(_n28),
                            u = u + d,
                            c = _r68,
                            _MoveRelativeDate14 = MoveRelativeDate(m, c, I, _t51),
                            _r68 = _MoveRelativeDate14.relativeTo,
                            _n28 = _MoveRelativeDate14.days;
                           }
                           _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
                           var
                            _a20 =
                              "string" != typeof m ? GetMethod(m, "dateUntil") : void 0,
                            _i25 = Te(null);
                           _i25.largestUnit = "month";
                           var
                            _s8 = CalendarDateUntil(m, c, _r68, _i25, _a20),
                            _l9 = GetSlot(_s8, D);
                           for(; abs(u) >= BigInt(ae(_l9));){
                            u = u - BigInt(_l9),
                            h = h + d,
                            c = _r68,
                            _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
                            var _o47 = Te(null);
                            _o47.largestUnit = "month",
                            _s8 = CalendarDateUntil(m, c, _r68, _o47, _a20),
                            _l9 = GetSlot(_s8, D);
                           }
                           break;
                          }
                         case "month":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for months balancing");
                           var
                            _t52 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r69,
                            _o48;
                           for
                           (_MoveRelativeDate15 = MoveRelativeDate(m, c, I, _t52),
                            _r69 = _MoveRelativeDate15.relativeTo,
                            _o48 = _MoveRelativeDate15.days,
                            _MoveRelativeDate15;
                            abs(f) >= BigInt(ae(_o48));){
                            var _MoveRelativeDate15, _MoveRelativeDate16;
                            f = f - BigInt(_o48),
                            u = u + d,
                            c = _r69,
                            _MoveRelativeDate16 = MoveRelativeDate(m, c, I, _t52),
                            _r69 = _MoveRelativeDate16.relativeTo,
                            _o48 = _MoveRelativeDate16.days;
                           }
                           break;
                          }
                         case "week":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for weeks balancing");
                           var
                            _t53 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r70,
                            _o49;
                           for
                           (_MoveRelativeDate17 = MoveRelativeDate(m, c, S, _t53),
                            _r70 = _MoveRelativeDate17.relativeTo,
                            _o49 = _MoveRelativeDate17.days,
                            _MoveRelativeDate17;
                            abs(f) >= BigInt(ae(_o49));){
                            var _MoveRelativeDate17, _MoveRelativeDate18;
                            f = f - BigInt(_o49),
                            T = T + d,
                            c = _r70,
                            _MoveRelativeDate18 = MoveRelativeDate(m, c, S, _t53),
                            _r70 = _MoveRelativeDate18.relativeTo,
                            _o49 = _MoveRelativeDate18.days;
                           }
                           break;
                          }
                       }
                       return {years: Number(h),
                               months: Number(u),
                               weeks: Number(T),
                               days: Number(f)};
                      }
                      (r, o, n, a, T, f),
                    r = _BalanceDurationRelat.years,
                    o = _BalanceDurationRelat.months,
                    n = _BalanceDurationRelat.weeks,
                    a = _BalanceDurationRelat.days,
                    new Duration(r, o, n, a, i, s, l, d, m, c);
            }},
           {key: "total",
            value:
            function(e){
             var _UnbalanceDurationRel2;
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, w),
              r = GetSlot(this, D),
              o = GetSlot(this, G),
              n = GetSlot(this, v),
              a = GetSlot(this, C),
              i = GetSlot(this, O),
              s = GetSlot(this, b),
              l = GetSlot(this, E),
              d = GetSlot(this, M),
              m = GetSlot(this, R);
             if(void 0 === e)
              throw new TypeError("options argument is required");
             var
              c =
                "string" == typeof e
                 ? CreateOnePropObject("unit", e)
                 : GetOptionsObject(e),
              h = ToRelativeTemporalObject(c),
              u = GetTemporalUnit(c, "unit", "datetime", He),
              T;
             _UnbalanceDurationRel2 =
              UnbalanceDurationRelative(t, r, o, n, u, h),
             t = _UnbalanceDurationRel2.years,
             r = _UnbalanceDurationRel2.months,
             o = _UnbalanceDurationRel2.weeks,
             n = _UnbalanceDurationRel2.days,
             IsTemporalZonedDateTime(h)
             && (T = MoveRelativeZonedDateTime(h, t, r, o, 0));
             var
              p = BalancePossiblyInfiniteDuration(n, a, i, s, l, d, m, u, T);
             if("positive overflow" === p) return 1 / 0;
             if("negative overflow" === p) return - (1 / 0);
             n = p.days;
             a = p.hours;
             i = p.minutes;
             s = p.seconds;
             l = p.milliseconds;
             d = p.microseconds;
             m = p.nanoseconds;
             var
              _RoundDuration9 =
                RoundDuration(t, r, o, n, a, i, s, l, d, m, 1, u, "trunc", h),
              f = _RoundDuration9.total;
             return f;
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === n || "minute" === n)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hours" or "minutes"');
             var
              _ToSecondsStringPreci3 = ToSecondsStringPrecisionRecord(n, r),
              a = _ToSecondsStringPreci3.precision,
              i = _ToSecondsStringPreci3.unit,
              s = _ToSecondsStringPreci3.increment;
             return TemporalDurationToString
                     (this, a, {unit: i, increment: s, roundingMode: o});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return TemporalDurationToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return "undefined" != typeof Intl
                     && void 0 !== Intl.DurationFormat
                     ? new Intl.DurationFormat(e, t).format(this)
                     : (console.warn
                        ("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."),
                       TemporalDurationToString(this));
            }},
           {key: "valueOf",
            value:
            function(){
             throw new TypeError("use compare() to compare Temporal.Duration");
            }}],
          [{key: "from",
            value:
            function(e){
             return IsTemporalDuration(e)
                     ? new
                       Duration
                       (GetSlot(e, w),
                        GetSlot(e, D),
                        GetSlot(e, G),
                        GetSlot(e, v),
                        GetSlot(e, C),
                        GetSlot(e, O),
                        GetSlot(e, b),
                        GetSlot(e, E),
                        GetSlot(e, M),
                        GetSlot(e, R))
                     : ToTemporalDuration(e);
            }},
           {key: "compare",
            value:
            function(t, r, o){
             var
              _UnbalanceDurationRel3,
              _UnbalanceDurationRel4,
              n = ToTemporalDuration(t),
              a = ToTemporalDuration(r),
              i = ToRelativeTemporalObject(GetOptionsObject(o)),
              s = GetSlot(n, w),
              l = GetSlot(n, D),
              d = GetSlot(n, G),
              m = GetSlot(n, v),
              c = GetSlot(n, C),
              h = GetSlot(n, O),
              u = GetSlot(n, b),
              T = GetSlot(n, E),
              p = GetSlot(n, M),
              f = GetSlot(n, R),
              y = GetSlot(a, w),
              I = GetSlot(a, D),
              S = GetSlot(a, G),
              g = GetSlot(a, v),
              F = GetSlot(a, C),
              Y = GetSlot(a, O),
              P = GetSlot(a, b),
              Z = GetSlot(a, E),
              B = GetSlot(a, M),
              N = GetSlot(a, R),
              j = CalculateOffsetShift(i, s, l, d, m),
              $ = CalculateOffsetShift(i, y, I, S, g);
             0 === s && 0 === y && 0 === l && 0 === I && 0 === d && 0 === S
             ||
              (_UnbalanceDurationRel3 =
                UnbalanceDurationRelative(s, l, d, m, "day", i),
               m = _UnbalanceDurationRel3.days,
               _UnbalanceDurationRel4 =
                UnbalanceDurationRelative(y, I, S, g, "day", i),
               g = _UnbalanceDurationRel4.days);
             var
              k = TotalDurationNanoseconds(m, c, h, u, T, p, f, j),
              U = TotalDurationNanoseconds(g, F, Y, P, Z, B, N, $);
             return ComparisonResult(Number(k - U));
            }}]);
        return Duration;
       }
       ();
   MakeIntrinsicClass(Duration, "Temporal.Duration");
   var
    bt = Object.create,
    PlainMonthDay =
      function(){
        function PlainMonthDay(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601",
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 1972;
         _classCallCheck(this, PlainMonthDay);
         CreateTemporalMonthDaySlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToTemporalCalendarSlotValue(r),
           ToIntegerWithTruncation(o));
        }
        _createClass
         (PlainMonthDay,
          [{key: "monthCode",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "calendarId",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["day", "month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarMonthDayFromFields(o, a, r);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalMonthDay(e);
             for
             (var _i26 = 0, _arr11 = [s, l, i]; _i26 < _arr11.length; _i26++){
              var _e57 = _arr11[_i26];
              if(GetSlot(this, _e57) !== GetSlot(t, _e57)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return TemporalMonthDayToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return TemporalMonthDayToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use equals() to compare Temporal.PlainMonthDay");
            }},
           {key: "toPlainDate",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("argument should be an object");
             var
              t = GetSlot(this, p),
              r = CalendarFields(t, ["day", "monthCode"]),
              o = PrepareTemporalFields(this, r, []),
              n = CalendarFields(t, ["year"]),
              a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
             a =
              PrepareTemporalFields
               (a,
                _toConsumableArray
                 (new
                   Set
                   ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
                []);
             var i = bt(null);
             return i.overflow = "reject", CalendarDateFromFields(t, a, i);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalMonthDay(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalMonthDay
                        (GetSlot(e, s), GetSlot(e, l), GetSlot(e, p), GetSlot(e, i)))
                     : ToTemporalMonthDay(e, r);
            }}]);
        return PlainMonthDay;
       }
       ();
   MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
   var
    instant =
      function(){return new (GetIntrinsic("%Temporal.Instant%"))(Ve());},
    plainDateTime =
      function(e){
       var
        t =
          arguments.length > 1 && arguments[1] !== undefined
           ? arguments[1]
           : DefaultTimeZone(),
        r = ToTemporalTimeZoneSlotValue(t),
        o = ToTemporalCalendarSlotValue(e);
       return GetPlainDateTimeFor(r, instant(), o);
      },
    plainDateTimeISO =
      function(){
       var
        e =
          arguments.length > 0 && arguments[0] !== undefined
           ? arguments[0]
           : DefaultTimeZone();
       return GetPlainDateTimeFor
               (ToTemporalTimeZoneSlotValue(e), instant(), "iso8601");
      },
    zonedDateTime =
      function(e){
       var
        t =
          arguments.length > 1 && arguments[1] !== undefined
           ? arguments[1]
           : DefaultTimeZone(),
        r = ToTemporalTimeZoneSlotValue(t),
        o = ToTemporalCalendarSlotValue(e);
       return CreateTemporalZonedDateTime(Ve(), r, o);
      },
    Et =
      _defineProperty
       ({instant: instant,
         plainDateTime: plainDateTime,
         plainDateTimeISO: plainDateTimeISO,
         plainDate:
         function(e){
          var
           t =
             arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : DefaultTimeZone();
          return TemporalDateTimeToDate(plainDateTime(e, t));
         },
         plainDateISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return TemporalDateTimeToDate(plainDateTimeISO(e));
         },
         plainTimeISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return TemporalDateTimeToTime(plainDateTimeISO(e));
         },
         timeZoneId: function(){return DefaultTimeZone();},
         zonedDateTime: zonedDateTime,
         zonedDateTimeISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return zonedDateTime("iso8601", e);
         }},
        Symbol.toStringTag,
        "Temporal.Now");
   Object.defineProperty
    (Et,
     Symbol.toStringTag,
     {value: "Temporal.Now",
      writable: ! 1,
      enumerable: ! 1,
      configurable: ! 0});
   var Mt = Object.assign;
   function TemporalTimeToString(e, t, r){
    var
     o = GetSlot(e, d),
     n = GetSlot(e, m),
     a = GetSlot(e, c),
     i = GetSlot(e, h),
     s = GetSlot(e, u),
     l = GetSlot(e, T);
    if(r){
     var
      _e58 = r.unit,
      _t54 = r.increment,
      _d12 = r.roundingMode,
      _RoundTime2 = RoundTime(o, n, a, i, s, l, _t54, _e58, _d12);
     o = _RoundTime2.hour;
     n = _RoundTime2.minute;
     a = _RoundTime2.second;
     i = _RoundTime2.millisecond;
     s = _RoundTime2.microsecond;
     l = _RoundTime2.nanosecond;
    }
    return "".concat(ISODateTimePartString(o), ":").concat
             (ISODateTimePartString(n)).concat
            (FormatSecondsStringPart(a, i, s, l, t));
   }
   var
    PlainTime =
      function(){
        function PlainTime(){
         var
          e =
            arguments.length > 0 && arguments[0] !== undefined
             ? arguments[0]
             : 0,
          t =
            arguments.length > 1 && arguments[1] !== undefined
             ? arguments[1]
             : 0,
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : 0,
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0;
         _classCallCheck(this, PlainTime);
         var
          i = void 0 === e ? 0 : ToIntegerWithTruncation(e),
          s = void 0 === t ? 0 : ToIntegerWithTruncation(t),
          l = void 0 === r ? 0 : ToIntegerWithTruncation(r),
          p = void 0 === o ? 0 : ToIntegerWithTruncation(o),
          f = void 0 === n ? 0 : ToIntegerWithTruncation(n),
          y = void 0 === a ? 0 : ToIntegerWithTruncation(a);
         RejectTime(i, s, l, p, f, y),
         N(this),
         SetSlot(this, d, i),
         SetSlot(this, m, s),
         SetSlot(this, c, l),
         SetSlot(this, h, p),
         SetSlot(this, u, f),
         SetSlot(this, T, y);
        }
        _createClass
         (PlainTime,
          [{key: "hour",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, T);
            }},
           {key: "with",
            value:
            function(e, t){
             var _RegulateTime4;
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = ToTemporalOverflow(GetOptionsObject(t)),
              o = ToTemporalTimeRecord(e, "partial"),
              n = ToTemporalTimeRecord(this),
              _Mt = Mt(n, o),
              a = _Mt.hour,
              i = _Mt.minute,
              s = _Mt.second,
              l = _Mt.millisecond,
              d = _Mt.microsecond,
              m = _Mt.nanosecond;
             return _RegulateTime4 = RegulateTime(a, i, s, l, d, m, r),
                    a = _RegulateTime4.hour,
                    i = _RegulateTime4.minute,
                    s = _RegulateTime4.second,
                    l = _RegulateTime4.millisecond,
                    d = _RegulateTime4.microsecond,
                    m = _RegulateTime4.nanosecond,
                    new PlainTime(a, i, s, l, d, m);
            }},
           {key: "add",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainTime
                     ("add", this, e);
            }},
           {key: "subtract",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainTime
                     ("subtract", this, e);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             var _RoundTime3;
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              n = GetTemporalUnit(t, "smallestUnit", "time", He);
             ValidateTemporalRoundingIncrement
              (r,
               {hour: 24,
                 minute: 60,
                 second: 60,
                 millisecond: 1e3,
                 microsecond: 1e3,
                 nanosecond: 1e3}
                [n],
               ! 1);
             var
              a = GetSlot(this, d),
              i = GetSlot(this, m),
              s = GetSlot(this, c),
              l = GetSlot(this, h),
              p = GetSlot(this, u),
              f = GetSlot(this, T);
             return _RoundTime3 = RoundTime(a, i, s, l, p, f, r, n, o),
                    a = _RoundTime3.hour,
                    i = _RoundTime3.minute,
                    s = _RoundTime3.second,
                    l = _RoundTime3.millisecond,
                    p = _RoundTime3.microsecond,
                    f = _RoundTime3.nanosecond,
                    new PlainTime(a, i, s, l, p, f);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTime(e);
             for
             (var _i27 = 0, _arr12 = [d, m, c, h, u, T];
              _i27 < _arr12.length;
              _i27++){
              var _e59 = _arr12[_i27];
              if(GetSlot(this, _e59) !== GetSlot(t, _e59)) return ! 1;
             }
             return ! 0;
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === n)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              _ToSecondsStringPreci4 = ToSecondsStringPrecisionRecord(n, r),
              a = _ToSecondsStringPreci4.precision,
              i = _ToSecondsStringPreci4.unit,
              s = _ToSecondsStringPreci4.increment;
             return TemporalTimeToString
                     (this, a, {unit: i, increment: s, roundingMode: o});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return TemporalTimeToString(this, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainTime");
            }},
           {key: "toPlainDateTime",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              n = GetSlot(t, l),
              a = GetSlot(t, p);
             return CreateTemporalDateTime
                     (r,
                      o,
                      n,
                      GetSlot(this, d),
                      GetSlot(this, m),
                      GetSlot(this, c),
                      GetSlot(this, h),
                      GetSlot(this, u),
                      GetSlot(this, T),
                      a);
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             var t = e.plainDate;
             if(void 0 === t) throw new TypeError("missing date property");
             var r = ToTemporalDate(t), o = e.timeZone;
             if(void 0 === o)
              throw new TypeError("missing timeZone property");
             var
              a = ToTemporalTimeZoneSlotValue(o),
              f = GetSlot(r, i),
              y = GetSlot(r, s),
              I = GetSlot(r, l),
              S = GetSlot(r, p),
              g = GetSlot(this, d),
              w = GetSlot(this, m),
              D = GetSlot(this, c),
              G = GetSlot(this, h),
              v = GetSlot(this, u),
              C = GetSlot(this, T);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (a,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (f, y, I, g, w, D, G, v, C, S),
                          "compatible"),
                        n),
                      a,
                      S);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return {isoHour: GetSlot(this, d),
                     isoMicrosecond: GetSlot(this, u),
                     isoMillisecond: GetSlot(this, h),
                     isoMinute: GetSlot(this, m),
                     isoNanosecond: GetSlot(this, T),
                     isoSecond: GetSlot(this, c)};
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = ToTemporalOverflow(GetOptionsObject(t));
             return IsTemporalTime(e)
                     ? new
                       PlainTime
                       (GetSlot(e, d),
                        GetSlot(e, m),
                        GetSlot(e, c),
                        GetSlot(e, h),
                        GetSlot(e, u),
                        GetSlot(e, T))
                     : ToTemporalTime(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalTime(e), o = ToTemporalTime(t);
             for
             (var _i28 = 0, _arr13 = [d, m, c, h, u, T];
              _i28 < _arr13.length;
              _i28++){
              var
               _e60 = _arr13[_i28],
               _t55 = GetSlot(r, _e60),
               _n29 = GetSlot(o, _e60);
              if(_t55 !== _n29) return ComparisonResult(_t55 - _n29);
             }
             return 0;
            }}]);
        return PlainTime;
       }
       ();
   MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
   var
    TimeZone =
      function(){
        function TimeZone(e){
         _classCallCheck(this, TimeZone);
         if(arguments.length < 1)
          throw new RangeError("missing argument: identifier is required");
         var t = GetCanonicalTimeZoneIdentifier(e);
         N(this), SetSlot(this, a, t);
        }
        _createClass
         (TimeZone,
          [{key: "id",
            get:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }},
           {key: "getOffsetNanosecondsFor",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             return IsTimeZoneOffsetString(r)
                     ? ParseTimeZoneOffsetString(r)
                     : GetNamedTimeZoneOffsetNanoseconds(r, GetSlot(t, n));
            }},
           {key: "getOffsetStringFor",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetOffsetStringFor(this, ToTemporalInstant(e));
            }},
           {key: "getPlainDateTimeFor",
            value:
            function(e){
             var
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "iso8601";
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetPlainDateTimeFor
                     (this, ToTemporalInstant(e), ToTemporalCalendarSlotValue(t));
            }},
           {key: "getInstantFor",
            value:
            function(e, t){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetInstantFor
                     (this,
                      ToTemporalDateTime(e),
                      ToTemporalDisambiguation(GetOptionsObject(t)));
            }},
           {key: "getPossibleInstantsFor",
            value:
            function(t){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalDateTime(t),
              o = GetIntrinsic("%Temporal.Instant%"),
              n = GetSlot(this, a);
             if(IsTimeZoneOffsetString(n)){
              var
               _t56 =
                 GetUTCEpochNanoseconds
                  (GetSlot(r, i),
                   GetSlot(r, s),
                   GetSlot(r, l),
                   GetSlot(r, d),
                   GetSlot(r, m),
                   GetSlot(r, c),
                   GetSlot(r, h),
                   GetSlot(r, u),
                   GetSlot(r, T));
              if(null === _t56)
               throw new RangeError("DateTime outside of supported range");
              var _a21 = ParseTimeZoneOffsetString(n);
              return [new o(_t56 - BigInt(_a21))];
             }
             var
              p =
                function(t, r, o, n, a, i, s, l, d, m){
                  var c = GetUTCEpochNanoseconds(r, o, n, a, i, s, l, d, m);
                  if(null === c)
                   throw new RangeError("DateTime outside of supported range");
                  var h = c - Ee;
                  h < Me && (h = c);
                  var u = c + Ee;
                  u > Re && (u = c);
                  var
                   T = GetNamedTimeZoneOffsetNanoseconds(t, h),
                   p = GetNamedTimeZoneOffsetNanoseconds(t, u);
                  return (T === p ? [T] : [T, p]).map
                           (function(h){
                             var
                              u = c - BigInt(h),
                              T = GetNamedTimeZoneDateTimeParts(t, u);
                             if
                              (r === T.year && o === T.month && n === T.day
                               && a === T.hour
                               && i === T.minute
                               && s === T.second
                               && l === T.millisecond
                               && d === T.microsecond
                               && m === T.nanosecond)
                              return u;
                            }).filter
                          (function(e){return void 0 !== e;});
                 }
                 (n,
                  GetSlot(r, i),
                  GetSlot(r, s),
                  GetSlot(r, l),
                  GetSlot(r, d),
                  GetSlot(r, m),
                  GetSlot(r, c),
                  GetSlot(r, h),
                  GetSlot(r, u),
                  GetSlot(r, T));
             return p.map(function(e){return new o(e);});
            }},
           {key: "getNextTransition",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
             var o = GetSlot(t, n), i = GetIntrinsic("%Temporal.Instant%");
             return o = GetNamedTimeZoneNextTransition(r, o),
                    null === o ? null : new i(o);
            }},
           {key: "getPreviousTransition",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
             var o = GetSlot(t, n), i = GetIntrinsic("%Temporal.Instant%");
             return o = GetNamedTimeZonePreviousTransition(r, o),
                    null === o ? null : new i(o);
            }},
           {key: "toString",
            value:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }}],
          [{key: "from",
            value:
            function(e){
             return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e));
            }}]);
        return TimeZone;
       }
       ();
   MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"),
   DefineIntrinsic
    ("Temporal.TimeZone.prototype.getOffsetNanosecondsFor",
     TimeZone.prototype.getOffsetNanosecondsFor),
   DefineIntrinsic
    ("Temporal.TimeZone.prototype.getPossibleInstantsFor",
     TimeZone.prototype.getPossibleInstantsFor);
   var
    Rt = Object.create,
    PlainYearMonth =
      function(){
        function PlainYearMonth(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601",
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 1;
         _classCallCheck(this, PlainYearMonth);
         CreateTemporalYearMonthSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToTemporalCalendarSlotValue(r),
           ToIntegerWithTruncation(o));
        }
        _createClass
         (PlainYearMonth,
          [{key: "year",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "calendarId",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarYearMonthFromFields(o, a, r);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainYearMonth
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainYearMonth
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainYearMonth("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainYearMonth("since", this, e, t);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalYearMonth(e);
             for
             (var _i29 = 0, _arr14 = [i, s, l]; _i29 < _arr14.length; _i29++){
              var _e61 = _arr14[_i29];
              if(GetSlot(this, _e61) !== GetSlot(t, _e61)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return TemporalYearMonthToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return TemporalYearMonthToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainYearMonth");
            }},
           {key: "toPlainDate",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("argument should be an object");
             var
              t = GetSlot(this, p),
              r = CalendarFields(t, ["monthCode", "year"]),
              o = PrepareTemporalFields(this, r, []),
              n = CalendarFields(t, ["day"]),
              a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
             a =
              PrepareTemporalFields
               (a,
                _toConsumableArray
                 (new
                   Set
                   ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
                []);
             var i = Rt(null);
             return i.overflow = "reject", CalendarDateFromFields(t, a, i);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalYearMonth(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalYearMonth
                        (GetSlot(e, i), GetSlot(e, s), GetSlot(e, p), GetSlot(e, l)))
                     : ToTemporalYearMonth(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalYearMonth(e), o = ToTemporalYearMonth(t);
             return CompareISODate
                     (GetSlot(r, i),
                      GetSlot(r, s),
                      GetSlot(r, l),
                      GetSlot(o, i),
                      GetSlot(o, s),
                      GetSlot(o, l));
            }}]);
        return PlainYearMonth;
       }
       ();
   MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
   var
    Ft = ht.prototype.resolvedOptions,
    Yt = Object.create,
    ZonedDateTime =
      function(){
        function ZonedDateTime(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601";
         _classCallCheck(this, ZonedDateTime);
         if(arguments.length < 1)
          throw new
                 TypeError
                 ("missing argument: epochNanoseconds is required");
         CreateTemporalZonedDateTimeSlots
          (this,
           ToBigInt(e),
           ToTemporalTimeZoneSlotValue(t),
           ToTemporalCalendarSlotValue(r));
        }
        _createClass
         (ZonedDateTime,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "timeZoneId",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), dateTime(this));
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), dateTime(this));
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), dateTime(this));
            }},
           {key: "hour",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), T);
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), dateTime(this));
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "epochSeconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, ve));
            }},
           {key: "epochMilliseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, Ge));
            }},
           {key: "epochMicroseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
            }},
           {key: "epochNanoseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(GetSlot(this, n));
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "hoursInDay",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = dateTime(this),
              r = GetIntrinsic("%Temporal.PlainDateTime%"),
              o = GetSlot(t, i),
              a = GetSlot(t, s),
              d = GetSlot(t, l),
              m = new r(o, a, d, 0, 0, 0, 0, 0, 0),
              c = AddISODate(o, a, d, 0, 0, 0, 1, "reject"),
              h = new r(c.year, c.month, c.day, 0, 0, 0, 0, 0, 0),
              u = GetSlot(this, g),
              T = GetSlot(GetInstantFor(u, m, "compatible"), n),
              p = GetSlot(GetInstantFor(u, h, "compatible"), n);
             return BigIntDivideToNumber(p - T, Oe);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "offset",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
            }},
           {key: "offsetNanoseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetOffsetNanosecondsFor
                     (GetSlot(this, g), GetSlot(this, S));
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("invalid zoned-date-time-like");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n =
                CalendarFields
                 (o,
                  ["day",
                   "hour",
                   "microsecond",
                   "millisecond",
                   "minute",
                   "month",
                   "monthCode",
                   "nanosecond",
                   "second",
                   "year"]);
             n.push("offset");
             var a = PrepareTemporalFields(this, n, ["offset"]);
             a =
              CalendarMergeFields
               (o, a, PrepareTemporalFields(e, n, "partial")),
             a = PrepareTemporalFields(a, n, ["offset"]);
             var
              i = ToTemporalDisambiguation(r),
              s = ToTemporalOffset(r, "prefer"),
              _InterpretTemporalDat5 =
                InterpretTemporalDateTimeFields(o, a, r),
              l = _InterpretTemporalDat5.year,
              d = _InterpretTemporalDat5.month,
              m = _InterpretTemporalDat5.day,
              c = _InterpretTemporalDat5.hour,
              h = _InterpretTemporalDat5.minute,
              u = _InterpretTemporalDat5.second,
              T = _InterpretTemporalDat5.millisecond,
              f = _InterpretTemporalDat5.microsecond,
              y = _InterpretTemporalDat5.nanosecond,
              I = ParseTimeZoneOffsetString(a.offset),
              S = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (InterpretISODateTimeOffset
                       (l, d, m, c, h, u, T, f, y, "option", I, S, i, s, ! 1),
                      S,
                      o);
            }},
           {key: "withPlainDate",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              a = GetSlot(t, l),
              f = GetSlot(t, p),
              y = dateTime(this),
              I = GetSlot(y, d),
              S = GetSlot(y, m),
              w = GetSlot(y, c),
              D = GetSlot(y, h),
              G = GetSlot(y, u),
              v = GetSlot(y, T);
             f = ConsolidateCalendars(GetSlot(this, p), f);
             var C = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (C,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (r, o, a, I, S, w, D, G, v, f),
                          "compatible"),
                        n),
                      C,
                      f);
            }},
           {key: "withPlainTime",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetIntrinsic("%Temporal.PlainTime%"),
              r = void 0 === e ? new t() : ToTemporalTime(e),
              o = dateTime(this),
              a = GetSlot(o, i),
              f = GetSlot(o, s),
              y = GetSlot(o, l),
              I = GetSlot(this, p),
              S = GetSlot(r, d),
              w = GetSlot(r, m),
              D = GetSlot(r, c),
              G = GetSlot(r, h),
              v = GetSlot(r, u),
              C = GetSlot(r, T),
              O = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (O,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (a, f, y, S, w, D, G, v, C, I),
                          "compatible"),
                        n),
                      O,
                      I);
            }},
           {key: "withTimeZone",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), t, GetSlot(this, p));
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), GetSlot(this, g), t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromZonedDateTime
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromZonedDateTime
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalZonedDateTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalZonedDateTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === t)
              throw new TypeError("options parameter is required");
             var
              r =
                "string" == typeof t
                 ? CreateOnePropObject("smallestUnit", t)
                 : GetOptionsObject(t),
              o = ToTemporalRoundingIncrement(r),
              a = ToTemporalRoundingMode(r, "halfExpand"),
              f = GetTemporalUnit(r, "smallestUnit", "time", He, ["day"]),
              y =
                {day: 1,
                  hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [f];
             ValidateTemporalRoundingIncrement(o, y, 1 === y);
             var
              I = dateTime(this),
              w = GetSlot(I, i),
              D = GetSlot(I, s),
              G = GetSlot(I, l),
              v = GetSlot(I, d),
              C = GetSlot(I, m),
              O = GetSlot(I, c),
              b = GetSlot(I, h),
              E = GetSlot(I, u),
              M = GetSlot(I, T),
              R = GetIntrinsic("%Temporal.PlainDateTime%"),
              F = GetSlot(this, g),
              Y = GetSlot(this, p),
              P =
                GetInstantFor
                 (F,
                  new
                   R
                   (GetSlot(I, i),
                    GetSlot(I, s),
                    GetSlot(I, l),
                    0,
                    0,
                    0,
                    0,
                    0,
                    0),
                  "compatible"),
              Z = AddZonedDateTime(P, F, Y, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0),
              B = Z - BigInt(GetSlot(P, n));
             if(B <= Ie)
              throw new
                     RangeError
                     ("cannot round a ZonedDateTime in a calendar with zero or negative length days");
             var
              _RoundISODateTime3 =
                RoundISODateTime
                 (w, D, G, v, C, O, b, E, M, o, f, a, Number(B));
             w = _RoundISODateTime3.year;
             D = _RoundISODateTime3.month;
             G = _RoundISODateTime3.day;
             v = _RoundISODateTime3.hour;
             C = _RoundISODateTime3.minute;
             O = _RoundISODateTime3.second;
             b = _RoundISODateTime3.millisecond;
             E = _RoundISODateTime3.microsecond;
             M = _RoundISODateTime3.nanosecond;
             return CreateTemporalZonedDateTime
                     (InterpretISODateTimeOffset
                       (w,
                        D,
                        G,
                        v,
                        C,
                        O,
                        b,
                        E,
                        M,
                        "option",
                        GetOffsetNanosecondsFor(F, GetSlot(this, S)),
                        F,
                        "compatible",
                        "prefer",
                        ! 1),
                      F,
                      GetSlot(this, p));
            }},
           {key: "equals",
            value:
            function(t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalZonedDateTime(t),
              o = GetSlot(this, n),
              a = GetSlot(r, n);
             return !
                    !
                    (BigInt(o) === BigInt(a))
                    && ! ! TimeZoneEquals(GetSlot(this, g), GetSlot(r, g))
                    && CalendarEquals(GetSlot(this, p), GetSlot(r, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToCalendarNameOption(t),
              o = ToFractionalSecondDigits(t),
              n =
                function(e){
                  return GetOption(e, "offset", ["auto", "never"], "auto");
                 }
                 (t),
              a = ToTemporalRoundingMode(t, "trunc"),
              i = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === i)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              s =
                function(e){
                  return GetOption
                          (e, "timeZoneName", ["auto", "never", "critical"], "auto");
                 }
                 (t),
              _ToSecondsStringPreci5 = ToSecondsStringPrecisionRecord(i, o),
              l = _ToSecondsStringPreci5.precision,
              d = _ToSecondsStringPreci5.unit,
              m = _ToSecondsStringPreci5.increment;
             return TemporalZonedDateTimeToString
                     (this, l, r, s, n, {unit: d, increment: m, roundingMode: a});
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var r = GetOptionsObject(t), o = Yt(null);
             if(CopyDataProperties(o, r, ["timeZone"]), void 0 !== r.timeZone)
              throw new
                     TypeError
                     ("ZonedDateTime toLocaleString does not accept a timeZone option");
             void 0 === o.year && void 0 === o.month && void 0 === o.day
             && void 0 === o.weekday
             && void 0 === o.dateStyle
             && void 0 === o.hour
             && void 0 === o.minute
             && void 0 === o.second
             && void 0 === o.timeStyle
             && void 0 === o.dayPeriod
             && void 0 === o.timeZoneName
             && (o.timeZoneName = "short");
             var n = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
             if(IsTimeZoneOffsetString(n))
              throw new
                     RangeError
                     ("toLocaleString does not support offset string time zones");
             n = GetCanonicalTimeZoneIdentifier(n), o.timeZone = n;
             var
              a = new ht(e, o),
              i = Call(Ft, a, []).calendar,
              s = ToTemporalCalendarIdentifier(GetSlot(this, p));
             if("iso8601" !== s && "iso8601" !== i && i !== s)
              throw new
                     RangeError
                     ("cannot format ZonedDateTime with calendar ".concat
                        (s, " in locale with calendar ").concat
                       (i));
             return a.format(GetSlot(this, S));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalZonedDateTimeToString(this, "auto");
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.ZonedDateTime");
            }},
           {key: "startOfDay",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              e = dateTime(this),
              t = GetIntrinsic("%Temporal.PlainDateTime%"),
              r = GetSlot(this, p),
              o =
                new
                 t
                 (GetSlot(e, i),
                  GetSlot(e, s),
                  GetSlot(e, l),
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  r),
              a = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot(GetInstantFor(a, o, "compatible"), n), a, r);
            }},
           {key: "toInstant",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
            }},
           {key: "toPlainDate",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToDate(dateTime(this));
            }},
           {key: "toPlainTime",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToTime(dateTime(this));
            }},
           {key: "toPlainDateTime",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return dateTime(this);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = dateTime(this), t = GetSlot(this, g);
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(e, l),
                     isoHour: GetSlot(e, d),
                     isoMicrosecond: GetSlot(e, u),
                     isoMillisecond: GetSlot(e, h),
                     isoMinute: GetSlot(e, m),
                     isoMonth: GetSlot(e, s),
                     isoNanosecond: GetSlot(e, T),
                     isoSecond: GetSlot(e, c),
                     isoYear: GetSlot(e, i),
                     offset: GetOffsetStringFor(t, GetSlot(this, S)),
                     timeZone: t};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }},
           {key: "getTimeZone",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalTimeZoneObject(GetSlot(this, g));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalZonedDateTime(e)
                     ? (ToTemporalDisambiguation
                        (r),
                       ToTemporalOffset(r, "reject"),
                       ToTemporalOverflow(r),
                       CreateTemporalZonedDateTime
                        (GetSlot(e, n), GetSlot(e, g), GetSlot(e, p)))
                     : ToTemporalZonedDateTime(e, r);
            }},
           {key: "compare",
            value:
            function(t, r){
             var
              o = ToTemporalZonedDateTime(t),
              a = ToTemporalZonedDateTime(r),
              i = GetSlot(o, n),
              s = GetSlot(a, n);
             return BigInt(i) < BigInt(s)
                     ? - 1
                     : BigInt(i) > BigInt(s) ? 1 : 0;
            }}]);
        return ZonedDateTime;
       }
       ();
   function dateTime(e){
    return GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
   }
   MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
   var
    Pt =
      Object.freeze
       ({__proto__: null,
         Calendar: Calendar,
         Duration: Duration,
         Instant: Instant,
         Now: Et,
         PlainDate: PlainDate,
         PlainDateTime: PlainDateTime,
         PlainMonthDay: PlainMonthDay,
         PlainTime: PlainTime,
         PlainYearMonth: PlainYearMonth,
         TimeZone: TimeZone,
         ZonedDateTime: ZonedDateTime});
   function toTemporalInstant(){
    var t = BigInt(+ this) * Ge;
    return new Instant(t);
   }
   var
    Zt =
      [Instant,
       Calendar,
       PlainDate,
       PlainDateTime,
       Duration,
       PlainMonthDay,
       PlainTime,
       TimeZone,
       PlainYearMonth,
       ZonedDateTime];
   for(var _i30 = 0, _Zt = Zt; _i30 < _Zt.length; _i30++){
    var
     _e62 = _Zt[_i30],
     _t57 = Object.getOwnPropertyDescriptor(_e62, "prototype");
    (_t57.configurable || _t57.enumerable || _t57.writable)
    &&
     (_t57.configurable = ! 1,
      _t57.enumerable = ! 1,
      _t57.writable = ! 1,
      Object.defineProperty(_e62, "prototype", _t57));
   }
   var
    TemporalPolyfill =
      Object.freeze
       ({__proto__: null,
         Intl: ut,
         Temporal: Pt,
         toTemporalInstant: toTemporalInstant});
   globalThis.TemporalPolyfill = TemporalPolyfill;
  }
  (globalThis));
(function(globalThis){
   "use strict";
   var joo_global_object = globalThis;
   function Base_am_testing(x){return 0;}
   function Base_caml_exn_is_most_recent_exn(x){return 1;}
   function Base_clear_caml_backtrace_pos(x){return 0;}
   function caml_is_continuation_tag(t){return t === 245 ? 1 : 0;}
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_int64_lo32(v){return v.lo32();}
   function caml_int64_hi32(v){return v.hi32();}
   var
    jsoo_dataview = new DataView(new ArrayBuffer(8)),
    caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   var caml_global_data = [0];
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   class MlInt64{
      constructor(lo, mi, hi){
       this.lo = lo & 0xffffff;
       this.mi = mi & 0xffffff;
       this.hi = hi & 0xffff;
       this.caml_custom = "_j";
      }
      static UNSIGNED_MAX = new MlInt64(0xffffff, 0xffffff, 0xffff);
      static SIGNED_MAX = new MlInt64(0xffffff, 0xffffff, 0x7fff);
      static SIGNED_MIN = new MlInt64(0x000000, 0x000000, 0x8000);
      slice(){return new MlInt64(this.lo, this.mi, this.hi);}
      ucompare(x){
       if(this.hi > x.hi) return 1;
       if(this.hi < x.hi) return - 1;
       if(this.mi > x.mi) return 1;
       if(this.mi < x.mi) return - 1;
       if(this.lo > x.lo) return 1;
       if(this.lo < x.lo) return - 1;
       return 0;
      }
      compare(x){
       var hi = this.hi << 16, xhi = x.hi << 16;
       if(hi > xhi) return 1;
       if(hi < xhi) return - 1;
       if(this.mi > x.mi) return 1;
       if(this.mi < x.mi) return - 1;
       if(this.lo > x.lo) return 1;
       if(this.lo < x.lo) return - 1;
       return 0;
      }
      neg(){
       var
        lo = - this.lo,
        mi = - this.mi + (lo >> 24),
        hi = - this.hi + (mi >> 24);
       return new MlInt64(lo, mi, hi);
      }
      add(x){
       var
        lo = this.lo + x.lo,
        mi = this.mi + x.mi + (lo >> 24),
        hi = this.hi + x.hi + (mi >> 24);
       return new MlInt64(lo, mi, hi);
      }
      sub(x){
       var
        lo = this.lo - x.lo,
        mi = this.mi - x.mi + (lo >> 24),
        hi = this.hi - x.hi + (mi >> 24);
       return new MlInt64(lo, mi, hi);
      }
      mul(x){
       var
        lo = this.lo * x.lo,
        mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
        hi =
          (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
          + this.lo * x.hi;
       return new MlInt64(lo, mi, hi);
      }
      isZero(){return (this.lo | this.mi | this.hi) === 0;}
      isNeg(){return this.hi << 16 < 0;}
      and(x){
       return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
      }
      or(x){
       return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
      }
      xor(x){
       return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
      }
      shift_left(s){
       s = s & 63;
       if(s === 0) return this;
       if(s < 24)
        return new
                MlInt64
                (this.lo << s,
                 this.mi << s | this.lo >> 24 - s,
                 this.hi << s | this.mi >> 24 - s);
       if(s < 48)
        return new
                MlInt64
                (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
       return new MlInt64(0, 0, this.lo << s - 48);
      }
      shift_right_unsigned(s){
       s = s & 63;
       if(s === 0) return this;
       if(s < 24)
        return new
                MlInt64
                (this.lo >> s | this.mi << 24 - s,
                 this.mi >> s | this.hi << 24 - s,
                 this.hi >> s);
       if(s < 48)
        return new
                MlInt64
                (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
       return new MlInt64(this.hi >> s - 48, 0, 0);
      }
      shift_right(s){
       s = s & 63;
       if(s === 0) return this;
       var h = this.hi << 16 >> 16;
       if(s < 24)
        return new
                MlInt64
                (this.lo >> s | this.mi << 24 - s,
                 this.mi >> s | h << 24 - s,
                 this.hi << 16 >> s >>> 16);
       var sign = this.hi << 16 >> 31;
       if(s < 48)
        return new
                MlInt64
                (this.mi >> s - 24 | this.hi << 48 - s,
                 this.hi << 16 >> s - 24 >> 16,
                 sign & 0xffff);
       return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
      }
      lsl1(){
       this.hi = this.hi << 1 | this.mi >> 23;
       this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
       this.lo = this.lo << 1 & 0xffffff;
      }
      lsr1(){
       this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
       this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
       this.hi = this.hi >>> 1;
      }
      udivmod(x){
       var
        offset = 0,
        modulus = this.slice(),
        divisor = x.slice(),
        quotient = new MlInt64(0, 0, 0);
       while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
       while(offset >= 0){
        offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0){
         quotient.lo++;
         modulus = modulus.sub(divisor);
        }
        divisor.lsr1();
       }
       return {quotient: quotient, modulus: modulus};
      }
      div(y){
       var x = this;
       if(y.isZero()) caml_raise_zero_divide();
       var sign = x.hi ^ y.hi;
       if(x.hi & 0x8000) x = x.neg();
       if(y.hi & 0x8000) y = y.neg();
       var q = x.udivmod(y).quotient;
       if(sign & 0x8000) q = q.neg();
       return q;
      }
      mod(y){
       var x = this;
       if(y.isZero()) caml_raise_zero_divide();
       var sign = x.hi;
       if(x.hi & 0x8000) x = x.neg();
       if(y.hi & 0x8000) y = y.neg();
       var r = x.udivmod(y).modulus;
       if(sign & 0x8000) r = r.neg();
       return r;
      }
      toInt(){return this.lo | this.mi << 24;}
      toFloat(){
       return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
              + this.lo;
      }
      toArray(){
       return [this.hi >> 8,
               this.hi & 0xff,
               this.mi >> 16,
               this.mi >> 8 & 0xff,
               this.mi & 0xff,
               this.lo >> 16,
               this.lo >> 8 & 0xff,
               this.lo & 0xff];
      }
      lo32(){return this.lo | (this.mi & 0xff) << 24;}
      hi32(){return this.mi >>> 8 & 0xffff | this.hi << 16;}
    }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    jsoo_dataview.setFloat64(0, x, true);
    var
     lo32 = jsoo_dataview.getUint32(0, true),
     hi32 = jsoo_dataview.getUint32(4, true),
     r1 = lo32 & 0xffffff,
     r2 = lo32 >>> 24 | hi32 << 8 & 0xffffff,
     r3 = hi32 >>> 16 & 0xffff;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_hash_mix_float(hash, v0){
    var
     i64 = caml_int64_bits_of_float(v0),
     l = caml_int64_lo32(i64),
     h = caml_int64_hi32(i64);
    if((h & 0x7ff00000) === 0x7ff00000 && (l | h & 0xfffff) !== 0){h = 0x7ff00000; l = 0x00000001;}
    else if(h === (0x80000000 | 0) && l === 0) h = 0;
    hash = caml_hash_mix_int(hash, l);
    hash = caml_hash_mix_int(hash, h);
    return hash;
   }
   function caml_jsbytes_of_string(x){return x;}
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   var jsoo_text_decoder = new TextDecoder();
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t !== 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_str_repeat(n, s){return s.repeat(n);}
   function caml_sub_uint8_array_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.subarray(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_convert_string_to_bytes(s){
    if(s.t === 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_sub_uint8_array_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   class MlBytes{
      constructor(tag, contents, length){
       this.t = tag;
       this.c = contents;
       this.l = length;
      }
      toString(){
       switch(this.t){
         case 9:
         case 8:
          return this.c;
         case 4:
         case 2:
          caml_convert_string_to_bytes(this);
         case 0:
          if(jsoo_is_ascii(this.c)) this.t = 9; else this.t = 8;
          return this.c;
       }
      }
      toUtf16(){
       if(this.t === 9) return this.c;
       var a = caml_uint8_array_of_bytes(this);
       return jsoo_text_decoder.decode(a);
      }
      slice(){
       var content = this.t === 4 ? this.c.slice() : this.c;
       return new MlBytes(this.t, content, this.l);
      }
    }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      case 2:
       caml_convert_string_to_bytes(s); return s.c;
      default: return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   var
    caml_packFloat16 =
      function(){
        const INVERSE_OF_EPSILON = 1 / Number.EPSILON;
        function roundTiesToEven(num){
         return num + INVERSE_OF_EPSILON - INVERSE_OF_EPSILON;
        }
        const
         FLOAT16_MIN_VALUE = 6.103515625e-5,
         FLOAT16_MAX_VALUE = 65504,
         FLOAT16_EPSILON = 0.0009765625,
         FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE,
         FLOAT16_EPSILON_DEVIDED_BY_EPSILON =
           FLOAT16_EPSILON * INVERSE_OF_EPSILON;
        function roundToFloat16(num){
         const number = + num;
         if(! Number.isFinite(number) || number === 0) return number;
         const sign = number > 0 ? 1 : - 1, absolute = Math.abs(number);
         if(absolute < FLOAT16_MIN_VALUE)
          return sign
                 *
                  roundTiesToEven
                   (absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE)
                 * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;
         const
          temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute,
          result = temp - (temp - absolute);
         if(result > FLOAT16_MAX_VALUE || Number.isNaN(result))
          return sign * Number.POSITIVE_INFINITY;
         return sign * result;
        }
        const
         baseTable = new Uint16Array(512),
         shiftTable = new Uint8Array(512);
        for(let i = 0; i < 256; ++i){
         const e = i - 127;
         if(e < - 24){
          baseTable[i] = 0x0000;
          baseTable[i | 0x100] = 0x8000;
          shiftTable[i] = 24;
          shiftTable[i | 0x100] = 24;
         }
         else if(e < - 14){
          baseTable[i] = 0x0400 >> - e - 14;
          baseTable[i | 0x100] = 0x0400 >> - e - 14 | 0x8000;
          shiftTable[i] = - e - 1;
          shiftTable[i | 0x100] = - e - 1;
         }
         else if(e <= 15){
          baseTable[i] = e + 15 << 10;
          baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
          shiftTable[i] = 13;
          shiftTable[i | 0x100] = 13;
         }
         else if(e < 128){
          baseTable[i] = 0x7c00;
          baseTable[i | 0x100] = 0xfc00;
          shiftTable[i] = 24;
          shiftTable[i | 0x100] = 24;
         }
         else{
          baseTable[i] = 0x7c00;
          baseTable[i | 0x100] = 0xfc00;
          shiftTable[i] = 13;
          shiftTable[i | 0x100] = 13;
         }
        }
        const
         buffer = new ArrayBuffer(4),
         floatView = new Float32Array(buffer),
         uint32View = new Uint32Array(buffer);
        return function(num){
         floatView[0] = roundToFloat16(num);
         const f = uint32View[0], e = f >> 23 & 0x1ff;
         return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);};
       }
       ();
   function caml_int32_bits_of_float(x){
    jsoo_dataview.setFloat32(0, x, true);
    return jsoo_dataview.getUint32(0, true) | 0;
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom === "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 13:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   var
    caml_unpackFloat16 =
      function(){
        var
         pow = Math.pow,
         EXP_MASK16 = 31,
         SIGNIFICAND_MASK16 = 1023,
         MIN_SUBNORMAL16 = pow(2, - 24),
         SIGNIFICAND_DENOM16 = 0.0009765625;
        return function(bytes){
         var
          sign = bytes >>> 15,
          exponent = bytes >>> 10 & EXP_MASK16,
          significand = bytes & SIGNIFICAND_MASK16;
         if(exponent === EXP_MASK16)
          return significand === 0
                  ? sign
                    === 0
                    ? Number.POSITIVE_INFINITY
                    : Number.NEGATIVE_INFINITY
                  : Number.NaN;
         if(exponent === 0)
          return significand
                 * (sign === 0 ? MIN_SUBNORMAL16 : - MIN_SUBNORMAL16);
         var
          r =
            pow(2, exponent - 15)
            *
             (sign === 0
               ? 1 + significand * SIGNIFICAND_DENOM16
               : - 1 - significand * SIGNIFICAND_DENOM16);
         return r;};
       }
       (),
    jsoo_static_env = {};
   function jsoo_sys_getenv(n){
    if(jsoo_static_env[n]) return jsoo_static_env[n];
    var process = globalThis.process;
    if(process && process.env && process.env[n] !== undefined)
     return process.env[n];
    if(globalThis.jsoo_env && typeof globalThis.jsoo_env[n] === "string")
     return globalThis.jsoo_env[n];
   }
   var caml_record_backtrace_env_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] === "b"){
         caml_record_backtrace_env_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_env_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   var caml_record_backtrace_runtime_flag = caml_record_backtrace_env_flag;
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] === 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_env_flag
            && caml_record_backtrace_runtime_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
      case 13:
       view = Uint16Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_int32_float_of_bits(x){
    jsoo_dataview.setUint32(0, x, true);
    return jsoo_dataview.getFloat32(0, true);
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi;
    jsoo_dataview.setUint32(0, lo | mi << 24, true);
    jsoo_dataview.setUint32(4, mi >>> 8 | hi << 16, true);
    return jsoo_dataview.getFloat64(0, true);
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   var caml_ba_custom_name = "_bigarr02";
   class Ml_Bigarray{
      constructor(kind, layout, dims, buffer){
       this.kind = kind;
       this.layout = layout;
       this.dims = dims;
       this.data = buffer;
       this.caml_custom = caml_ba_custom_name;
      }
      offset(arg){
       var ofs = 0;
       if(typeof arg === "number") arg = [arg];
       if(! Array.isArray(arg))
        caml_invalid_argument("bigarray.js: invalid offset");
       if(this.dims.length !== arg.length)
        caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
       if(this.layout === 0)
        for(var i = 0; i < this.dims.length; i++){
         if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i];
        }
       else
        for(var i = this.dims.length - 1; i >= 0; i--){
         if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1);
        }
       return ofs;
      }
      get(ofs){
       switch(this.kind){
         case 7:
          var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
          return caml_int64_create_lo_hi(l, h);
         case 10:
         case 11:
          var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
          return [254, r, i];
         case 13:
          return caml_unpackFloat16(this.data[ofs]);
         default: return this.data[ofs];
       }
      }
      set(ofs, v){
       switch(this.kind){
         case 7:
          this.data[ofs * 2 + 0] = caml_int64_lo32(v);
          this.data[ofs * 2 + 1] = caml_int64_hi32(v);
          break;
         case 10:
         case 11:
          this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
         case 13:
          this.data[ofs] = caml_packFloat16(v); break;
         default: this.data[ofs] = v; break;
       }
       return 0;
      }
      fill(v){
       switch(this.kind){
         case 7:
          var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
          if(a === b)
           this.data.fill(a);
          else
           for(var i = 0; i < this.data.length; i++)
            this.data[i] = i % 2 === 0 ? a : b;
          break;
         case 10:
         case 11:
          var im = v[1], re = v[2];
          if(im === re)
           this.data.fill(im);
          else
           for(var i = 0; i < this.data.length; i++)
            this.data[i] = i % 2 === 0 ? im : re;
          break;
         case 13:
          this.data.fill(caml_packFloat16(v)); break;
         default: this.data.fill(v); break;
       }
      }
      compare(b, total){
       if(this.layout !== b.layout || this.kind !== b.kind){
        var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
        return k2 - k1;
       }
       if(this.dims.length !== b.dims.length)
        return b.dims.length - this.dims.length;
       for(var i = 0; i < this.dims.length; i++)
        if(this.dims[i] !== b.dims[i])
         return this.dims[i] < b.dims[i] ? - 1 : 1;
       switch(this.kind){
         case 0:
         case 1:
         case 10:
         case 11:
          var x, y;
          for(var i = 0; i < this.data.length; i++){
           x = this.data[i];
           y = b.data[i];
           if(x < y) return - 1;
           if(x > y) return 1;
           if(x !== y){
            if(! total) return Number.NaN;
            if(! Number.isNaN(x)) return 1;
            if(! Number.isNaN(y)) return - 1;
           }
          }
          break;
         case 7:
          for(var i = 0; i < this.data.length; i += 2){
           if(this.data[i + 1] < b.data[i + 1]) return - 1;
           if(this.data[i + 1] > b.data[i + 1]) return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
          }
          break;
         case 13:
          for(var i = 0; i < this.data.length; i++){
           var
            aa = caml_unpackFloat16(this.data[i]),
            bb = caml_unpackFloat16(b.data[i]);
           if(aa < bb) return - 1;
           if(aa > bb) return 1;
          }
          break;
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 8:
         case 9:
         case 12:
          for(var i = 0; i < this.data.length; i++){
           if(this.data[i] < b.data[i]) return - 1;
           if(this.data[i] > b.data[i]) return 1;
          }
          break;
       }
       return 0;
      }
    }
   class Ml_Bigarray_c_1_1 extends Ml_Bigarray {
      offset(arg){
       if(typeof arg !== "number")
        if(Array.isArray(arg) && arg.length === 1)
         arg = arg[0];
        else
         caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
       if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
       return arg;
      }
      get(ofs){return this.data[ofs];}
      set(ofs, v){this.data[ofs] = v; return 0;}
      fill(v){this.data.fill(v); return 0;}
    }
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element !== data.length)
     caml_invalid_argument("length doesn't match dims");
    if
     (layout === 0 && dims.length === 1 && size_per_element === 1
      && kind !== 13)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name === "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim === 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi !== 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 13:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_hash_mix_float16(hash, d){
    if((d & 0x7c00) === 0x7c00 && (d & 0x03ff) !== 0)
     d = 0x7c01;
    else if(d === 0x8000) d = 0;
    return caml_hash_mix_int(hash, d);
   }
   function caml_hash_mix_float32(hash, v){
    var i = caml_int32_bits_of_float(v);
    if((i & 0x7f800000) === 0x7f800000 && (i & 0x7fffff) !== 0)
     i = 0x7f800001;
    else if(i === (0x80000000 | 0)) i = 0;
    hash = caml_hash_mix_int(hash, i);
    return hash;
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= num_elts; i += 4){
        w =
         ba.data[i + 0] & 0xff | (ba.data[i + 1] & 0xff) << 8
         | (ba.data[i + 2] & 0xff) << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= num_elts; i += 2){
        w = ba.data[i + 0] & 0xffff | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) !== 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float32(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 13:
       if(num_elts > 128) num_elts = 128;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float16(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large"); break;
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_int64_compare(x, y, _total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {_j:
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       _i: {deserialize: caml_int32_unmarshal, fixed_length: 4},
       _n: {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       _bigarray:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       _bigarr02:
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v?.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(Array.isArray(v) && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3fffffff;
   }
   function Base_hash_double(d){return caml_hash(1, 1, 0, d);}
   function Base_hash_string(s){return caml_hash(1, 1, 0, s);}
   function Base_int_math_int32_clz(x){
    var n = 32, y;
    y = x >> 16;
    if(y != 0){n = n - 16; x = y;}
    y = x >> 8;
    if(y != 0){n = n - 8; x = y;}
    y = x >> 4;
    if(y != 0){n = n - 4; x = y;}
    y = x >> 2;
    if(y != 0){n = n - 2; x = y;}
    y = x >> 1;
    if(y != 0) return n - 2;
    return n - x;
   }
   function Base_int_math_int32_ctz(x){
    if(x === 0) return 32;
    var n = 1;
    if((x & 0x0000FFFF) === 0){n = n + 16; x = x >> 16;}
    if((x & 0x000000FF) === 0){n = n + 8; x = x >> 8;}
    if((x & 0x0000000F) === 0){n = n + 4; x = x >> 4;}
    if((x & 0x00000003) === 0){n = n + 2; x = x >> 2;}
    return n - (x & 1);
   }
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_int64_to_int32(x){return x.toInt();}
   function Base_int_math_int64_clz(x){
    var n = 64, y;
    y = caml_int64_shift_right_unsigned(x, 32);
    if(! caml_int64_is_zero(y)){n = n - 32; x = y;}
    y = caml_int64_shift_right_unsigned(x, 16);
    if(! caml_int64_is_zero(y)){n = n - 16; x = y;}
    y = caml_int64_shift_right_unsigned(x, 8);
    if(! caml_int64_is_zero(y)){n = n - 8; x = y;}
    y = caml_int64_shift_right_unsigned(x, 4);
    if(! caml_int64_is_zero(y)){n = n - 4; x = y;}
    y = caml_int64_shift_right_unsigned(x, 2);
    if(! caml_int64_is_zero(y)){n = n - 2; x = y;}
    y = caml_int64_shift_right_unsigned(x, 1);
    if(! caml_int64_is_zero(y)) return n - 2;
    return n - caml_int64_to_int32(x);
   }
   function caml_int64_and(x, y){return x.and(y);}
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function Base_int_math_int64_ctz(x){
    if(caml_int64_is_zero(x)) return 64;
    var n = 1;
    function is_zero(x){return caml_int64_is_zero(x);}
    function land(x, y){return caml_int64_and(x, y);}
    function small_int64(x){return caml_int64_create_lo_mi_hi(x, 0, 0);}
    if
     (is_zero(land(x, caml_int64_create_lo_mi_hi(0xFFFFFF, 0x0000FF, 0x0000)))){n = n + 32; x = caml_int64_shift_right_unsigned(x, 32);}
    if(is_zero(land(x, small_int64(0x00FFFF)))){
     n = n + 16;
     x = caml_int64_shift_right_unsigned(x, 16);
    }
    if(is_zero(land(x, small_int64(0x0000FF)))){
     n = n + 8;
     x = caml_int64_shift_right_unsigned(x, 8);
    }
    if(is_zero(land(x, small_int64(0x00000F)))){
     n = n + 4;
     x = caml_int64_shift_right_unsigned(x, 4);
    }
    if(is_zero(land(x, small_int64(0x000003)))){
     n = n + 2;
     x = caml_int64_shift_right_unsigned(x, 2);
    }
    return n - caml_int64_to_int32(caml_int64_and(x, small_int64(0x000001)));
   }
   function caml_int64_mul(x, y){return x.mul(y);}
   function Base_int_math_int64_pow_stub(base, exponent){
    var
     one = caml_int64_create_lo_hi(1, 0),
     mul = [one, base, one, one],
     res = one;
    while(! caml_int64_is_zero(exponent)){
     mul[1] = caml_int64_mul(mul[1], mul[3]);
     mul[2] = caml_int64_mul(mul[1], mul[1]);
     mul[3] = caml_int64_mul(mul[2], mul[1]);
     res = caml_int64_mul(res, mul[caml_int64_lo32(exponent) & 3]);
     exponent = caml_int64_shift_right_unsigned(exponent, 2);
    }
    return res;
   }
   function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x);}
   function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x);}
   function Base_int_math_int_popcount(v){
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
   }
   function Base_int_math_int_pow_stub(base, exponent){
    var one = 1, mul = [one, base, one, one], res = one;
    while(! exponent == 0){
     mul[1] = mul[1] * mul[3] | 0;
     mul[2] = mul[1] * mul[1] | 0;
     mul[3] = mul[2] * mul[1] | 0;
     res = res * mul[exponent & 3] | 0;
     exponent = exponent >> 2;
    }
    return res;
   }
   function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x);}
   function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x);}
   var
    Base_internalhash_fold_float = caml_hash_mix_float,
    Base_internalhash_fold_int = caml_hash_mix_int;
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   var
    Base_internalhash_fold_int64 = caml_hash_mix_int64,
    Base_internalhash_fold_string = caml_hash_mix_string;
   function Base_internalhash_get_hash_value(seed){
    var h = caml_hash_mix_final(seed);
    return h & 0x3FFFFFFF;
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function Base_unsafe_create_local_bytes(v_len){return caml_create_bytes(v_len);
   }
   class JsStringReader{
      constructor(s, i){this.s = s; this.i = i;}
      read8u(){return this.s.charCodeAt(this.i++);}
      read8s(){return this.s.charCodeAt(this.i++) << 24 >> 24;}
      read16u(){
       var s = this.s, i = this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
      }
      read16s(){
       var s = this.s, i = this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
      }
      read32u(){
       var s = this.s, i = this.i;
       this.i = i + 4;
       return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
              | s.charCodeAt(i + 2) << 8
              | s.charCodeAt(i + 3))
              >>> 0;
      }
      read32s(){
       var s = this.s, i = this.i;
       this.i = i + 4;
       return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
              | s.charCodeAt(i + 2) << 8
              | s.charCodeAt(i + 3);
      }
      readstr(len){
       var i = this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.slice(i, i + len));
      }
      readuint8array(len){
       var b = new Uint8Array(len), s = this.s, i = this.i;
       for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
       this.i = i + len;
       return b;
      }
    }
   function MlChanid(id){this.id = id;}
   var jsoo_text_encoder = new TextEncoder();
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_string_of_jsstring(s){
    if(jsoo_is_ascii(s)) return caml_string_of_jsbytes(s);
    var a = jsoo_text_encoder.encode(s);
    return caml_string_of_array(a);
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_arg
     (caml_global_data.Sys_error, caml_string_of_jsstring(msg));
   }
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, - errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function caml_raise_system_error(raise_unix, code, cmd, msg, path){
    var unix_error = caml_named_value("Unix.Unix_error");
    if(raise_unix && unix_error)
     caml_raise_with_args(unix_error, make_unix_err_args(code, cmd, path));
    else{
     var msg = code + ": " + msg + ", " + cmd;
     if(path !== undefined) msg += " '" + path + "'";
     caml_raise_sys_error(msg);
    }
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_no_such_file(name, raise_unix){
    caml_raise_system_error
     (raise_unix, "ENOENT", "no such file or directory", name);
   }
   function caml_bytes_of_uint8_array(a){return new MlBytes(4, a, a.length);}
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len === 0) return 0;
    if(i2 === 0 && (len >= s2.l || s2.t === 2 && len >= s2.c.length)){
     s2.c =
      s1.t === 4
       ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else if(s2.t === 2 && i2 === s2.c.length){
     s2.c +=
      s1.t === 4
       ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)
       : i1 === 0 && s1.c.length === len ? s1.c : s1.c.slice(i1, i1 + len);
     s2.t = s2.c.length === s2.l ? 0 : 2;
    }
    else{
     if(s2.t !== 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t === 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   class MlFakeFile extends MlFile {
      constructor(content){super(); this.data = content;}
      truncate(len){
       var old = this.data;
       this.data = caml_create_bytes(len | 0);
       caml_blit_bytes(old, 0, this.data, 0, len);
      }
      length(){return caml_ml_bytes_length(this.data);}
      write(offset, buf, pos, len){
       var clen = this.length();
       if(offset + len >= clen){
        var new_str = caml_create_bytes(offset + len), old_data = this.data;
        this.data = new_str;
        caml_blit_bytes(old_data, 0, this.data, 0, clen);
       }
       caml_blit_bytes
        (caml_bytes_of_uint8_array(buf), pos, this.data, offset, len);
       return len;
      }
      read(offset, buf, pos, len){
       var clen = this.length();
       if(offset + len >= clen) len = clen - offset;
       if(len){
        var data = caml_create_bytes(len | 0);
        caml_blit_bytes(this.data, offset, data, 0, len);
        buf.set(caml_uint8_array_of_bytes(data), pos);
       }
       return len;
      }
    }
   class MlFakeFd{
      constructor(name, file, flags){
       this.file = file;
       this.name = name;
       this.flags = flags;
       this.offset = 0;
       this.seeked = false;
      }
      err_closed(cmd, raise_unix){
       caml_raise_system_error
        (raise_unix, "EBADF", cmd, "bad file descriptor");
      }
      length(){
       if(this.file) return this.file.length();
       this.err_closed("length");
      }
      truncate(len, raise_unix){
       if(this.file){
        if(! (this.flags.wronly || this.flags.rdwr))
         caml_raise_system_error
          (raise_unix, "EINVAL", "truncate", "invalid argument");
        return this.file.truncate(len);
       }
       this.err_closed("truncate", raise_unix);
      }
      write(buf, pos, len, raise_unix){
       if(this.file && (this.flags.wronly || this.flags.rdwr)){
        var offset = this.offset;
        len = this.file.write(offset, buf, pos, len);
        this.offset += len;
        return len;
       }
       this.err_closed("write", raise_unix);
      }
      read(buf, pos, len, raise_unix){
       if(this.file && ! this.flags.wronly){
        var offset = this.offset;
        len = this.file.read(offset, buf, pos, len);
        this.offset += len;
        return len;
       }
       this.err_closed("read", raise_unix);
      }
      seek(offset, whence, raise_unix){
       switch(whence){
         case 0: break;
         case 1:
          offset += this.offset; break;
         case 2:
          offset += this.length(); break;
       }
       if(offset < 0)
        caml_raise_system_error
         (raise_unix, "EINVAL", "lseek", "invalid argument");
       this.offset = offset;
       this.seeked = true;
      }
      close(){
       if(! this.file) this.err_closed("close");
       this.file = undefined;
      }
      check_stream_semantics(cmd){
       if(! this.file) return this.err_closed(cmd, 1);
      }
    }
   class MlFakeDevice{
      constructor(root, f){
       this.content = {};
       this.root = root;
       this.lookupFun = f;
      }
      nm(name){return this.root + name;}
      create_dir_if_needed(name){
       var comp = name.split("/"), res = "";
       for(var i = 0; i < comp.length - 1; i++){
        res += comp[i] + "/";
        if(this.content[res]) continue;
        this.content[res] = Symbol("directory");
       }
      }
      slash(name){return /\/$/.test(name) ? name : name + "/";}
      lookup(name){
       if(! this.content[name] && this.lookupFun){
        var
         res =
           this.lookupFun
            (caml_string_of_jsstring(this.root),
             caml_string_of_jsstring(name));
        if(res !== 0){
         this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
        }
       }
      }
      exists(name, do_not_lookup){
       if(name === "") return 1;
       var name_slash = this.slash(name);
       if(this.content[name_slash]) return 1;
       if(! do_not_lookup) this.lookup(name);
       return this.content[name] ? 1 : 0;
      }
      isFile(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;}
      rename_dir(oldname, newname){
       if(this.exists(newname)){
        if(! this.is_dir(newname))
         caml_raise_sys_error
          (this.nm(newname) + " : file already exists and is not a directory");
        if(this.readdir(newname).length > 0)
         caml_raise_sys_error(this.nm(newname) + " : directory not empty");
       }
       var old_slash = this.slash(oldname), new_slash = this.slash(newname);
       this.create_dir_if_needed(new_slash);
       for(const f of this.readdir(oldname))
        this.rename(old_slash + f, new_slash + f);
       delete this.content[old_slash];
      }
      rename(oldname, newname){
       if(! this.exists(oldname))
        caml_raise_sys_error
         (this.nm(oldname) + " : no such file or directory");
       if(this.is_dir(oldname))
        this.rename_dir(oldname, newname);
       else{
        if(this.exists(newname) && this.is_dir(newname))
         caml_raise_sys_error
          (this.nm(newname) + " : file already exists and is a directory");
        this.content[newname] = this.content[oldname];
        delete this.content[oldname];
       }
      }
      mkdir(name, _mode, raise_unix){
       if(this.exists(name))
        caml_raise_system_error
         (raise_unix, "EEXIST", "mkdir", "file already exists", this.nm(name));
       var parent = /^(.*)\/[^/]+/.exec(name);
       parent = parent?.[1] || "";
       if(! this.exists(parent))
        caml_raise_system_error
         (raise_unix,
          "ENOENT",
          "mkdir",
          "no such file or directory",
          this.nm(name));
       if(! this.is_dir(parent))
        caml_raise_system_error
         (raise_unix, "ENOTDIR", "mkdir", "not a directory", this.nm(name));
       this.create_dir_if_needed(this.slash(name));
      }
      rmdir(name, raise_unix){
       var
        name_slash = name === "" ? "" : this.slash(name),
        r = new RegExp("^" + name_slash + "([^/]+)");
       if(! this.exists(name))
        caml_raise_system_error
         (raise_unix,
          "ENOENT",
          "rmdir",
          "no such file or directory",
          this.nm(name));
       if(! this.is_dir(name))
        caml_raise_system_error
         (raise_unix, "ENOTDIR", "rmdir", "not a directory", this.nm(name));
       for(var n in this.content)
        if(n.match(r))
         caml_raise_system_error
          (raise_unix,
           "ENOTEMPTY",
           "rmdir",
           "directory not empty",
           this.nm(name));
       delete this.content[name_slash];
      }
      readdir(name){
       var name_slash = name === "" ? "" : this.slash(name);
       if(! this.exists(name))
        caml_raise_sys_error(name + ": No such file or directory");
       if(! this.is_dir(name))
        caml_raise_sys_error(name + ": Not a directory");
       var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
       for(var n in this.content){
        var m = n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
       }
       return a;
      }
      opendir(name, raise_unix){
       var a = this.readdir(name), c = false, i = 0;
       return {readSync:
               function(){
                if(c)
                 caml_raise_system_error
                  (raise_unix, "EBADF", "readdir", "bad file descriptor");
                if(i === a.length) return null;
                var entry = a[i];
                i++;
                return {name: entry};
               },
               closeSync:
               function(){
                if(c)
                 caml_raise_system_error
                  (raise_unix, "EBADF", "readdir", "bad file descriptor");
                c = true;
                a = [];
               }};
      }
      is_dir(name){
       if(name === "") return true;
       var name_slash = this.slash(name);
       return this.content[name_slash] ? 1 : 0;
      }
      unlink(name, raise_unix){
       if(! this.exists(name, true))
        caml_raise_system_error
         (raise_unix, "ENOENT", "unlink", "no such file or directory", name);
       delete this.content[name];
       return 0;
      }
      access(name, _flags, raise_unix){
       this.lookup(name);
       if(this.content[name]){
        if(this.is_dir(name))
         caml_raise_system_error
          (raise_unix,
           "EACCESS",
           "access",
           "permission denied,",
           this.nm(name));
       }
       else
        caml_raise_no_such_file(this.nm(name), raise_unix);
       return 0;
      }
      open(name, f, _perms, raise_unix){
       var file;
       this.lookup(name);
       if(this.content[name]){
        if(this.is_dir(name))
         caml_raise_system_error
          (raise_unix,
           "EISDIR",
           "open",
           "illegal operation on a directory",
           this.nm(name));
        if(f.create && f.excl)
         caml_raise_system_error
          (raise_unix, "EEXIST", "open", "file already exists", this.nm(name));
        file = this.content[name];
        if(f.truncate) file.truncate();
       }
       else if(f.create){
        this.create_dir_if_needed(name);
        this.content[name] = new MlFakeFile(caml_create_bytes(0));
        file = this.content[name];
       }
       else
        caml_raise_no_such_file(this.nm(name), raise_unix);
       return new MlFakeFd(this.nm(name), file, f);
      }
      truncate(name, len, raise_unix){
       var file;
       this.lookup(name);
       if(this.content[name]){
        if(this.is_dir(name))
         caml_raise_system_error
          (raise_unix,
           "EISDIR",
           "open",
           "illegal operation on a directory",
           this.nm(name));
        file = this.content[name];
        file.truncate(len);
       }
       else
        caml_raise_no_such_file(this.nm(name), raise_unix);
      }
      register(name, content){
       var file;
       if(this.content[name])
        caml_raise_sys_error(this.nm(name) + " : file already exists");
       if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
       if(caml_is_ml_string(content))
        file = new MlFakeFile(caml_bytes_of_string(content));
       else if(Array.isArray(content))
        file = new MlFakeFile(caml_bytes_of_array(content));
       else if(typeof content === "string")
        file = new MlFakeFile(caml_bytes_of_jsbytes(content));
       else if(content.toString){
        var
         bytes =
           caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
        file = new MlFakeFile(bytes);
       }
       if(file){
        this.create_dir_if_needed(name);
        this.content[name] = file;
       }
       else
        caml_raise_sys_error
         (this.nm(name) + " : registering file with invalid content type");
      }
    }
   class MlFakeFd_out extends MlFakeFile {
      constructor(fd, flags){
       super(caml_create_bytes(0));
       this.log = function(_s){return 0;};
       if(fd === 1 && typeof console.log === "function")
        this.log = console.log;
       else if(fd === 2 && typeof console.error === "function")
        this.log = console.error;
       else if(typeof console.log === "function") this.log = console.log;
       this.flags = flags;
      }
      length(){return 0;}
      truncate(_len, raise_unix){
       caml_raise_system_error
        (raise_unix, "EINVAL", "ftruncate", "invalid argument");
      }
      write(buf, pos, len, raise_unix){
       var written = len;
       if(this.log){
        if
         (len > 0 && pos >= 0 && pos + len <= buf.length
          && buf[pos + len - 1] === 10)
         len--;
        var src = caml_create_bytes(len);
        caml_blit_bytes(caml_bytes_of_uint8_array(buf), pos, src, 0, len);
        this.log(src.toUtf16());
        return written;
       }
       caml_raise_system_error
        (raise_unix, "EBADF", "write", "bad file descriptor");
      }
      read(_buf, _pos, _len, raise_unix){
       caml_raise_system_error
        (raise_unix, "EBADF", "read", "bad file descriptor");
      }
      seek(_len, _whence, raise_unix){
       caml_raise_system_error(raise_unix, "ESPIPE", "lseek", "illegal seek");
      }
      close(){this.log = undefined;}
      check_stream_semantics(_cmd){}
    }
   class MlMutex{constructor(){this.locked = false;}}
   class MlNat{
      constructor(x){
       this.data = new Int32Array(x);
       this.length = this.data.length + 2;
       this.caml_custom = "_nat";
      }
    }
   function caml_raise_nodejs_error(err, raise_unix, cmd){
    var unix_error = caml_named_value("Unix.Unix_error");
    if(raise_unix && unix_error){
     var
      args =
        make_unix_err_args(err.code, cmd || err.syscall, err.path, err.errno);
     caml_raise_with_args(unix_error, args);
    }
    else
     caml_raise_sys_error(err.toString());
   }
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   function fs_node_stats_from_js(js_stats, large){
    var file_kind;
    if(js_stats.isFile())
     file_kind = 0;
    else if(js_stats.isDirectory())
     file_kind = 1;
    else if(js_stats.isCharacterDevice())
     file_kind = 2;
    else if(js_stats.isBlockDevice())
     file_kind = 3;
    else if(js_stats.isSymbolicLink())
     file_kind = 4;
    else if(js_stats.isFIFO())
     file_kind = 5;
    else if(js_stats.isSocket()) file_kind = 6;
    return [0,
            js_stats.dev,
            js_stats.ino | 0,
            file_kind,
            js_stats.mode,
            js_stats.nlink,
            js_stats.uid,
            js_stats.gid,
            js_stats.rdev,
            large ? caml_int64_of_float(js_stats.size) : js_stats.size | 0,
            js_stats.atimeMs / 1000,
            js_stats.mtimeMs / 1000,
            js_stats.ctimeMs / 1000];
   }
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Uint8Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t !== 4){
     if(i === s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 === s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   class MlNodeFd extends MlFile {
      constructor(fd, flags){
       super();
       this.fs = require("node:fs");
       this.fd = fd;
       this.flags = flags;
       try{
        var stats = this.fs.fstatSync(fd);
        flags.noSeek =
         stats.isCharacterDevice() || stats.isFIFO() || stats.isSocket();
       }
       catch(err){flags.noSeek = true;}
       this.offset = this.flags.append ? stats.size : 0;
       this.seeked = false;
      }
      truncate(len, raise_unix){
       try{
        this.fs.ftruncateSync(this.fd, len | 0);
        if(this.offset > len) this.offset = len;
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      length(){
       try{return this.fs.fstatSync(this.fd).size;}
       catch(err){caml_raise_sys_error(err.toString());}
      }
      write(buf, buf_offset, len, raise_unix){
       try{
        if(this.flags.noSeek || ! this.seeked)
         var written = this.fs.writeSync(this.fd, buf, buf_offset, len);
        else
         var
          written =
            this.fs.writeSync(this.fd, buf, buf_offset, len, this.offset);
        this.offset += written;
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
       return written;
      }
      read(a, buf_offset, len, raise_unix){
       try{
        if(this.flags.noSeek || ! this.seeked)
         var read = this.fs.readSync(this.fd, a, buf_offset, len);
        else
         var
          read = this.fs.readSync(this.fd, a, buf_offset, len, this.offset);
        this.offset += read;
        return read;
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      seek(offset, whence, raise_unix){
       if(this.flags.noSeek)
        caml_raise_system_error(raise_unix, "ESPIPE", "lseek", "illegal seek");
       switch(whence){
         case 0: break;
         case 1:
          offset += this.offset; break;
         case 2:
          offset += this.length(); break;
       }
       if(offset < 0)
        caml_raise_system_error
         (raise_unix, "EINVAL", "lseek", "invalid argument");
       this.offset = offset;
       this.seeked = true;
       return this.offset;
      }
      stat(large){
       try{
        var js_stats = this.fs.fstatSync(this.fd);
        return fs_node_stats_from_js(js_stats, large);
       }
       catch(err){caml_raise_nodejs_error(err, 1);}
      }
      chmod(perms){
       try{this.fs.fchmodSync(this.fd, perms); return 0;}
       catch(err){caml_raise_nodejs_error(err, 1);}
      }
      sync(){
       try{this.fs.fsyncSync(this.fd); return 0;}
       catch(err){caml_raise_nodejs_error(err, 1);}
      }
      close(raise_unix){
       try{this.fs.closeSync(this.fd); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      check_stream_semantics(cmd){
       try{var js_stats = this.fs.fstatSync(this.fd);}
       catch(err){caml_raise_nodejs_error(err, 1, cmd);}
       if
        (!
         (js_stats.isFile() || js_stats.isCharacterDevice()
         || js_stats.isFIFO()
         || js_stats.isSocket()))
        caml_raise_system_error(1, "EINVAL", cmd, "invalid argument");
      }
    }
   class MlNodeDevice{
      constructor(root){this.fs = require("node:fs"); this.root = root;}
      nm(name){return this.root + name;}
      exists(name){
       try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
       catch(err){return 0;}
      }
      isFile(name){
       try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
       catch(err){caml_raise_sys_error(err.toString());}
      }
      mkdir(name, mode, raise_unix){
       try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      rmdir(name, raise_unix){
       try{this.fs.rmdirSync(this.nm(name)); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      readdir(name, raise_unix){
       try{return this.fs.readdirSync(this.nm(name));}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      is_dir(name){
       try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
       catch(err){caml_raise_sys_error(err.toString());}
      }
      unlink(name, raise_unix){
       try{this.fs.unlinkSync(this.nm(name)); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      utimes(name, atime, mtime, raise_unix){
       try{
        if(atime === 0 && mtime === 0){
         atime = new Date().getTime() / 1000;
         mtime = atime;
        }
        this.fs.utimesSync(this.nm(name), atime, mtime);
        return 0;
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      truncate(name, len, raise_unix){
       try{this.fs.truncateSync(this.nm(name), len | 0); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      access(name, f, raise_unix){
       var consts = require("node:fs").constants, res = 0;
       for(var key in f)
        switch(key){
          case "r":
           res |= consts.R_OK; break;
          case "w":
           res |= consts.W_OK; break;
          case "x":
           res |=
            globalThis.process?.platform === "win32"
             ? consts.R_OK
             : consts.X_OK;
           break;
          case "f":
           res |= consts.F_OK; break;
        }
       try{this.fs.accessSync(this.nm(name), res); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      open(name, f, perms, raise_unix){
       var consts = require("node:fs").constants, res = 0;
       for(var key in f)
        switch(key){
          case "rdonly":
           res |= consts.O_RDONLY; break;
          case "wronly":
           res |= consts.O_WRONLY; break;
          case "rdwr":
           res |= consts.O_RDWR; break;
          case "append":
           res |= consts.O_APPEND; break;
          case "create":
           res |= consts.O_CREAT; break;
          case "truncate":
           res |= consts.O_TRUNC; break;
          case "excl":
           res |= consts.O_EXCL; break;
          case "binary":
           res |= consts.O_BINARY; break;
          case "text":
           res |= consts.O_TEXT; break;
          case "nonblock":
           res |= consts.O_NONBLOCK; break;
          case "noctty":
           res |= consts.O_NOCTTY; break;
          case "dsync":
           res |= consts.O_DSYNC; break;
          case "sync":
           res |= consts.O_SYNC; break;
        }
       try{
        var fd = this.fs.openSync(this.nm(name), res, perms);
        return new MlNodeFd(fd, f);
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      slash(name){return /\/$/.test(name) ? name : name + "/";}
      rename(o, n, raise_unix){
       if(globalThis.process?.platform === "win32")
        try{
         var
          target = this.nm(n),
          source = this.nm(o),
          target_stats,
          source_stats;
         if
          ((target_stats = this.fs.statSync(target, {throwIfNoEntry: false}))
           &&
            (source_stats = this.fs.statSync(source, {throwIfNoEntry: false}))
           && source_stats.isDirectory())
          if(target_stats.isDirectory()){
           if(! this.slash(target).startsWith(this.slash(source)))
            try{this.fs.rmdirSync(target);}catch{}
          }
          else{
           var
            err =
              new
               Error
               (`ENOTDIR: not a directory, rename '${source}' -> '${target}'`);
           throw Object.assign
                  (err,
                   {errno: - 20,
                    code: "ENOTDIR",
                    syscall: "rename",
                    path: target});
          }
         this.fs.renameSync(this.nm(o), this.nm(n));
        }
        catch(err){caml_raise_nodejs_error(err, raise_unix);}
       else
        try{this.fs.renameSync(this.nm(o), this.nm(n));}
        catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      stat(name, large, raise_unix){
       try{
        var js_stats = this.fs.statSync(this.nm(name));
        return fs_node_stats_from_js(js_stats, large);
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      lstat(name, large, raise_unix){
       try{
        var js_stats = this.fs.lstatSync(this.nm(name));
        return fs_node_stats_from_js(js_stats, large);
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      chmod(name, perms, raise_unix){
       try{this.fs.chmodSync(this.nm(name), perms); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      link(target, path, raise_unix){
       try{this.fs.linkSync(this.nm(target), this.nm(path)); return 0;}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      symlink(to_dir, target, path, raise_unix){
       try{
        this.fs.symlinkSync
         (target,
          this.nm(path),
          to_dir === 0 ? null : to_dir[1] ? "dir" : "file");
        return 0;
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      readlink(name, raise_unix){
       try{
        var link = this.fs.readlinkSync(this.nm(name), "utf8");
        return caml_string_of_jsstring(link);
       }
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
      opendir(name, raise_unix){
       try{return this.fs.opendirSync(this.nm(name));}
       catch(err){caml_raise_nodejs_error(err, raise_unix);}
      }
    }
   class MlObjectTable{
      constructor(){this.objs = []; this.lookup = new globalThis.Map();}
      store(v){this.lookup.set(v, this.objs.length); this.objs.push(v);}
      recall(v){
       var i = this.lookup.get(v);
       return i === undefined ? undefined : this.objs.length - i;
      }
    }
   function caml_string_of_uint8_array(a){
    return caml_sub_uint8_array_to_jsbytes(a, 0, a.length);
   }
   class UInt8ArrayReader{
      constructor(s, i){this.s = s; this.i = i;}
      read8u(){return this.s[this.i++];}
      read8s(){return this.s[this.i++] << 24 >> 24;}
      read16u(){
       var s = this.s, i = this.i;
       this.i = i + 2;
       return s[i] << 8 | s[i + 1];
      }
      read16s(){
       var s = this.s, i = this.i;
       this.i = i + 2;
       return s[i] << 24 >> 16 | s[i + 1];
      }
      read32u(){
       var s = this.s, i = this.i;
       this.i = i + 4;
       return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
      }
      read32s(){
       var s = this.s, i = this.i;
       this.i = i + 4;
       return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
      }
      readstr(len){
       var i = this.i;
       this.i = i + len;
       return caml_string_of_uint8_array(this.s.subarray(i, i + len));
      }
      readuint8array(len){
       var i = this.i;
       this.i = i + len;
       return this.s.subarray(i, i + len);
      }
    }
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x === x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x === x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function bigstring_alloc_v2(size){return caml_ba_create(12, 0, [0, size]);}
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 !== ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_uint8_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function bigstring_blit_bigstring_bytes_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_ba_to_bytes(src, src_pos, dst, dst_pos, len);
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).subarray(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function bigstring_blit_bytes_bigstring_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_bytes_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).subarray(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function bigstring_blit_string_bigstring_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 !== ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 !== ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len === 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function bigstring_blit_stub(s1, i1, s2, i2, len){
    return caml_bigstring_blit_ba_to_ba(s1, i1, s2, i2, len);
   }
   function bigstring_destroy_stub(v_bstr){
    if(v_bstr.hasOwnProperty("__is_deallocated"))
     caml_invalid_argument
      ("bigstring_destroy: bigstring is already deallocated");
    v_bstr.__is_deallocated = true;
    v_bstr.data = new v_bstr.data.__proto__.constructor(0);
    v_bstr.dims = [0];
    return 0;
   }
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function bigstring_find(bs, chr, pos, len){
    while(len > 0){
     if(caml_ba_get_1(bs, pos) == chr) return pos;
     pos++;
     len--;
    }
    return - 1;
   }
   function bigstring_is_mmapped_stub(x){return 0;}
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      case 0:
       return s.c.charCodeAt(i);
      case 2:
       if(i >= s.c.length) return 0; return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function bigstring_memcmp_bytes_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){
    for(var i = 0; i < v_len; i++){
     var
      a = caml_ba_get_1(v_s1, v_s1_pos + i),
      b = caml_bytes_get(v_s2, v_s2_pos + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function bigstring_memcmp_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){
    for(var i = 0; i < v_len; i++){
     var
      a = caml_ba_get_1(v_s1, v_s1_pos + i),
      b = caml_ba_get_1(v_s2, v_s2_pos + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function bigstring_memmem_bytecode
   (haystack, needle, haystack_pos, haystack_len, needle_pos, needle_len){
    var i = 0, lim = haystack_len - needle_len;
    for(var i = 0; i <= lim; ++i){
     var matches = true;
     for(var j = 0; j < needle_len; ++j)
      if
       (caml_ba_get_1(haystack, haystack_pos + i + j)
        != caml_ba_get_1(needle, needle_pos + j)){matches = false; break;}
     if(matches) return haystack_pos + i;
    }
    return - 1;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function bigstring_memset_stub(bigstring, v_pos, v_len, v_char){
    for(var i = 0; i < v_len; i++)
     caml_ba_set_1(bigstring, v_pos + i, v_char);
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bigstring_realloc(bigstring, size){
    if(bigstring.hasOwnProperty("__is_deallocated"))
     caml_invalid_argument
      ("bigstring_realloc: bigstring is already deallocated");
    var new_data = new bigstring.data.__proto__.constructor(size);
    new_data.set(bigstring.data.slice(0, size));
    var
     new_bigstring =
       caml_ba_create_unsafe
        (bigstring.kind, bigstring.layout, [size], new_data);
    bigstring_destroy_stub(bigstring);
    return new_bigstring;
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function bigstring_to_typed_array(bs){return bs.data;}
   function bin_prot_blit_buf_bytes_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_ba_to_bytes(src, src_pos, dst, dst_pos, len);
   }
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_check_bound_bigstring(bigstring, i){
    if(i >>> 0 >= bigstring.data.length) caml_array_bound_error();
   }
   function bin_prot_blit_buf_float_array_stub
   (src_pos, src, dst_pos, dst, len){
    if(len == 0) return 0;
    caml_check_bound(dst, dst_pos);
    caml_check_bound(dst, dst_pos + len - 1);
    caml_check_bound_bigstring(src, src_pos);
    caml_check_bound_bigstring(src, src_pos + len * 8 - 1);
    var
     view = new joo_global_object.Float64Array(len),
     buffer = new joo_global_object.Uint8Array(view.buffer);
    buffer.set(src.data.subarray(src_pos, src_pos + len * 8));
    for(var i = 0; i < len; i++) dst[dst_pos + i + 1] = view[i];
    return 0;
   }
   function bin_prot_blit_buf_stub(src_pos, src, dst_pos, dst, len){
    if(src.kind != 12) src = bigstring_of_typed_array(src.data);
    if(dst.kind != 12) dst = bigstring_of_typed_array(dst.data);
    return caml_bigstring_blit_ba_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function bin_prot_blit_bytes_buf_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function bin_prot_blit_float_array_buf_stub
   (src_pos, src, dst_pos, dst, len){
    if(len == 0) return 0;
    caml_check_bound(src, src_pos);
    caml_check_bound(src, src_pos + len - 1);
    caml_check_bound_bigstring(dst, dst_pos);
    caml_check_bound_bigstring(dst, dst_pos + len * 8 - 1);
    src_pos = src_pos + 1;
    var
     float64 =
       new joo_global_object.Float64Array(src.slice(src_pos, src_pos + len)),
     float64_uint8 = new joo_global_object.Uint8Array(float64.buffer),
     view = dst.data.subarray(dst_pos, dst_pos + len * 8);
    view.set(float64_uint8);
    return 0;
   }
   function bin_prot_blit_string_buf_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   var
    blake2b =
      function(){
        function ADD64AA(v, a, b){
         const o0 = v[a] + v[b];
         let o1 = v[a + 1] + v[b + 1];
         if(o0 >= 0x100000000) o1++;
         v[a] = o0;
         v[a + 1] = o1;
        }
        function ADD64AC(v, a, b0, b1){
         let o0 = v[a] + b0;
         if(b0 < 0) o0 += 0x100000000;
         let o1 = v[a + 1] + b1;
         if(o0 >= 0x100000000) o1++;
         v[a] = o0;
         v[a + 1] = o1;
        }
        function B2B_GET32(arr, i){
         return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
        }
        function B2B_G(a, b, c, d, ix, iy){
         const x0 = m[ix], x1 = m[ix + 1], y0 = m[iy], y1 = m[iy + 1];
         ADD64AA(v, a, b);
         ADD64AC(v, a, x0, x1);
         let xor0 = v[d] ^ v[a], xor1 = v[d + 1] ^ v[a + 1];
         v[d] = xor1;
         v[d + 1] = xor0;
         ADD64AA(v, c, d);
         xor0 = v[b] ^ v[c];
         xor1 = v[b + 1] ^ v[c + 1];
         v[b] = xor0 >>> 24 ^ xor1 << 8;
         v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
         ADD64AA(v, a, b);
         ADD64AC(v, a, y0, y1);
         xor0 = v[d] ^ v[a];
         xor1 = v[d + 1] ^ v[a + 1];
         v[d] = xor0 >>> 16 ^ xor1 << 16;
         v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
         ADD64AA(v, c, d);
         xor0 = v[b] ^ v[c];
         xor1 = v[b + 1] ^ v[c + 1];
         v[b] = xor1 >>> 31 ^ xor0 << 1;
         v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
        }
        const
         BLAKE2B_IV32 =
           new
            Uint32Array
            ([0xf3bcc908,
              0x6a09e667,
              0x84caa73b,
              0xbb67ae85,
              0xfe94f82b,
              0x3c6ef372,
              0x5f1d36f1,
              0xa54ff53a,
              0xade682d1,
              0x510e527f,
              0x2b3e6c1f,
              0x9b05688c,
              0xfb41bd6b,
              0x1f83d9ab,
              0x137e2179,
              0x5be0cd19]),
         SIGMA8 =
           [0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            14,
            10,
            4,
            8,
            9,
            15,
            13,
            6,
            1,
            12,
            0,
            2,
            11,
            7,
            5,
            3,
            11,
            8,
            12,
            0,
            5,
            2,
            15,
            13,
            10,
            14,
            3,
            6,
            7,
            1,
            9,
            4,
            7,
            9,
            3,
            1,
            13,
            12,
            11,
            14,
            2,
            6,
            5,
            10,
            4,
            0,
            15,
            8,
            9,
            0,
            5,
            7,
            2,
            4,
            10,
            15,
            14,
            1,
            11,
            12,
            6,
            8,
            3,
            13,
            2,
            12,
            6,
            10,
            0,
            11,
            8,
            3,
            4,
            13,
            7,
            5,
            15,
            14,
            1,
            9,
            12,
            5,
            1,
            15,
            14,
            13,
            4,
            10,
            0,
            7,
            6,
            3,
            9,
            2,
            8,
            11,
            13,
            11,
            7,
            14,
            12,
            1,
            3,
            9,
            5,
            0,
            15,
            4,
            8,
            6,
            2,
            10,
            6,
            15,
            14,
            9,
            11,
            3,
            0,
            8,
            12,
            2,
            13,
            7,
            1,
            4,
            10,
            5,
            10,
            2,
            8,
            4,
            7,
            6,
            1,
            5,
            15,
            11,
            9,
            14,
            3,
            12,
            13,
            0,
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            14,
            10,
            4,
            8,
            9,
            15,
            13,
            6,
            1,
            12,
            0,
            2,
            11,
            7,
            5,
            3],
         SIGMA82 = new Uint8Array(SIGMA8.map(function(x){return x * 2;})),
         v = new Uint32Array(32),
         m = new Uint32Array(32);
        function blake2bCompress(ctx, last){
         let i = 0;
         for(i = 0; i < 16; i++){
          v[i] = ctx.h[i];
          v[i + 16] = BLAKE2B_IV32[i];
         }
         v[24] = v[24] ^ ctx.t;
         v[25] = v[25] ^ ctx.t / 0x100000000;
         if(last){v[28] = ~ v[28]; v[29] = ~ v[29];}
         for(i = 0; i < 32; i++) m[i] = B2B_GET32(ctx.b, 4 * i);
         for(i = 0; i < 12; i++){
          B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
          B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
          B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
          B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
          B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
          B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
          B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
          B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
         }
         for(i = 0; i < 16; i++) ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
        }
        const
         parameterBlock =
           new
            Uint8Array
            ([0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0]);
        function blake2bInit(outlen, key){
         if(outlen === 0 || outlen > 64)
          throw new Error("Illegal output length, expected 0 < length <= 64");
         if(key.length > 64)
          throw new
                 Error
                 ("Illegal key, expected Uint8Array with 0 < length <= 64");
         const
          ctx =
            {b: new Uint8Array(128),
             h: new Uint32Array(16),
             t: 0,
             c: 0,
             outlen: outlen};
         parameterBlock.fill(0);
         parameterBlock[0] = outlen;
         parameterBlock[1] = key.length;
         parameterBlock[2] = 1;
         parameterBlock[3] = 1;
         for(let i = 0; i < 16; i++)
          ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
         if(key.length > 0){blake2bUpdate(ctx, key); ctx.c = 128;}
         return ctx;
        }
        function blake2bUpdate(ctx, input){
         for(let i = 0; i < input.length; i++){
          if(ctx.c === 128){
           ctx.t += ctx.c;
           blake2bCompress(ctx, false);
           ctx.c = 0;
          }
          ctx.b[ctx.c++] = input[i];
         }
        }
        function blake2bFinal(ctx){
         ctx.t += ctx.c;
         while(ctx.c < 128) ctx.b[ctx.c++] = 0;
         blake2bCompress(ctx, true);
         const out = new Uint8Array(ctx.outlen);
         for(let i = 0; i < ctx.outlen; i++)
          out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
         return out;
        }
        return {Init: blake2bInit, Update: blake2bUpdate, Final: blake2bFinal};
       }
       ();
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xd76aa478);
         d = ff(d, a, b, c, buffer[1], 12, 0xe8c7b756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070db);
         b = ff(b, c, d, a, buffer[3], 22, 0xc1bdceee);
         a = ff(a, b, c, d, buffer[4], 7, 0xf57c0faf);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787c62a);
         c = ff(c, d, a, b, buffer[6], 17, 0xa8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xfd469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098d8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8b44f7af);
         c = ff(c, d, a, b, buffer[10], 17, 0xffff5bb1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895cd7be);
         a = ff(a, b, c, d, buffer[12], 7, 0x6b901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xfd987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xa679438e);
         b = ff(b, c, d, a, buffer[15], 22, 0x49b40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xf61e2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xc040b340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265e5a51);
         b = gg(b, c, d, a, buffer[0], 20, 0xe9b6c7aa);
         a = gg(a, b, c, d, buffer[5], 5, 0xd62f105d);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xd8a1e681);
         b = gg(b, c, d, a, buffer[4], 20, 0xe7d3fbc8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21e1cde6);
         d = gg(d, a, b, c, buffer[14], 9, 0xc33707d6);
         c = gg(c, d, a, b, buffer[3], 14, 0xf4d50d87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455a14ed);
         a = gg(a, b, c, d, buffer[13], 5, 0xa9e3e905);
         d = gg(d, a, b, c, buffer[2], 9, 0xfcefa3f8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676f02d9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8d2a4c8a);
         a = hh(a, b, c, d, buffer[5], 4, 0xfffa3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771f681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6d9d6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xfde5380c);
         a = hh(a, b, c, d, buffer[1], 4, 0xa4beea44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4bdecfa9);
         c = hh(c, d, a, b, buffer[7], 16, 0xf6bb4b60);
         b = hh(b, c, d, a, buffer[10], 23, 0xbebfbc70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289b7ec6);
         d = hh(d, a, b, c, buffer[0], 11, 0xeaa127fa);
         c = hh(c, d, a, b, buffer[3], 16, 0xd4ef3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881d05);
         a = hh(a, b, c, d, buffer[9], 4, 0xd9d4d039);
         d = hh(d, a, b, c, buffer[12], 11, 0xe6db99e5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1fa27cf8);
         b = hh(b, c, d, a, buffer[2], 23, 0xc4ac5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xf4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432aff97);
         c = ii(c, d, a, b, buffer[14], 15, 0xab9423a7);
         b = ii(b, c, d, a, buffer[5], 21, 0xfc93a039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655b59c3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8f0ccc92);
         c = ii(c, d, a, b, buffer[10], 15, 0xffeff47d);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845dd1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6fa87e4f);
         d = ii(d, a, b, c, buffer[15], 10, 0xfe2ce6e0);
         c = ii(c, d, a, b, buffer[6], 15, 0xa3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4e0811a1);
         a = ii(a, b, c, d, buffer[4], 6, 0xf7537e82);
         d = ii(d, a, b, c, buffer[11], 10, 0xbd3af235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2ad7d2bb);
         b = ii(b, c, d, a, buffer[9], 21, 0xeb86d391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1fffffff;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xff;
    return t;
   }
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d === 0)
     return f(...args);
    else if(d < 0){
     var g = f(...args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f(...nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f(...nargs);
            };
         break;
        }
       default:
        var
         g =
           function(...extra_args){
            if(extra_args.length === 0) extra_args = [undefined];
            return caml_call_gen(f, args.concat(extra_args));
           };
     }
     g.l = d;
     return g;
    }
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_alloc_stack(_hv, _hx, _hf){return 0;}
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process?.argv?.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       ();
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_array_make(len, init){
    if(len >>> 0 >= (0x7fffffff / 4 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_atomic_make_contended(a){return [0, a];}
   function caml_ba_blit(src, dst){
    if(dst.dims.length !== src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] !== src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout === layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_ba_create_from(data1, data2, _jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) === 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_ba_init(){return 0;}
   function caml_ba_kind(ba){return ba.kind;}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_ba_map_file(_vfd, _kind, _layout, _shared, _dims, _pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, _argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts !== size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout === 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout === 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_runtime_flag ? 1 : 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_blake2_create(hashlen, key){
    key = caml_uint8_array_of_string(key);
    if(key.length > 64) key.subarray(0, 64);
    return blake2b.Init(hashlen, key);
   }
   function caml_blake2_final(ctx, _hashlen){
    var r = blake2b.Final(ctx);
    return caml_string_of_uint8_array(r);
   }
   function caml_blake2_update(ctx, buf, ofs, len){
    var input = caml_uint8_array_of_string(buf);
    input = input.subarray(ofs, ofs + len);
    blake2b.Update(ctx, input);
    return 0;
   }
   function caml_blake2_string(hashlen, key, buf, ofs, len){
    var ctx = caml_blake2_create(hashlen, key);
    caml_blake2_update(ctx, buf, ofs, len);
    return caml_blake2_final(ctx, hashlen);
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function caml_bswap16(x){return (x & 0x00ff) << 8 | (x & 0xff00) >> 8;}
   var jsoo_text_decoder_buff = new ArrayBuffer(1024);
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    var
     a =
       s.length <= jsoo_text_decoder_buff.length
        ? new Uint8Array(jsoo_text_decoder_buff, 0, s.length)
        : new Uint8Array(s.length);
    for(var i = 0; i < s.length; i++) a[i] = s.charCodeAt(i);
    return jsoo_text_decoder.decode(a);
   }
   function caml_build_symbols(symb){
    var r = {}, max = - 1;
    if(symb)
     for(var i = 1; i < symb.length; i++){
      var idx = symb[i][2];
      max = Math.max(max, idx);
      r[caml_jsstring_of_string(symb[i][1])] = idx;
     }
    r.next_idx = max + 1;
    return r;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c === s2.c ? 1 : 0;
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_bytes_of_utf16_jsstring(s){
    if(jsoo_is_ascii(s))
     return new MlBytes(9, s, s.length);
    else{
     var a = jsoo_text_encoder.encode(s);
     return new MlBytes(4, a, a.length);
    }
   }
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xff & i16 >> 8, b1 = 0xff & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xff & i32 >> 24,
     b3 = 0xff & i32 >> 16,
     b2 = 0xff & i32 >> 8,
     b1 = 0xff & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   var caml_callback = caml_call_gen;
   function caml_cbrt_float(x){return Math.cbrt(x);}
   class caml_ml_channels_state{
      constructor(){
       this.map = new globalThis.WeakMap();
       this.opened = new globalThis.Set();
      }
      close(chanid){this.opened.delete(chanid);}
      get(chanid){return this.map.get(chanid);}
      set(chanid, val){
       if(val.opened) this.opened.add(chanid);
       return this.map.set(chanid, val);
      }
      all(){return this.opened.values();}
    }
   var caml_ml_channels = new caml_ml_channels_state();
   function caml_ml_channel_get(id){return caml_ml_channels.get(id);}
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.fd;
   }
   function caml_classify_float(x){
    if(Number.isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x !== 0) return 1;
     return 2;
    }
    return Number.isNaN(x) ? 4 : 3;
   }
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && Number.isNaN(x)) return swap;
     if(Number.isNaN(+ x)) return + x;
     if((x | 0) !== 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(Array.isArray(a) && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag === 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a === "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a?.caml_custom)
     return 1255;
    else if(a?.compare)
     return 1256;
    else if(typeof a === "function")
     return 1247;
    else if(typeof a === "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a === b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a === 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b === 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a === 1000){
        if(tag_b === 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b === 1000){
        if(tag_a === 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]) | 0;
         if(x !== 0) return x;
         break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b) | 0;
          if(x !== 0) return x;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp !== caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(Number.isNaN(x)) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x !== 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b){
          if(! total) return Number.NaN;
          if(! Number.isNaN(a)) return 1;
          if(! Number.isNaN(b)) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a !== b) return total ? 1 : Number.NaN;
         break;
        case 1251:
         if(a !== b) return total ? 1 : Number.NaN; break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length !== b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length === 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    if(stack === 0) return stack;
    var last = cont[2];
    last.h[1] = hval;
    last.h[2] = hexn;
    last.h[3] = heff;
    return stack;
   }
   function caml_convert_raw_backtrace(){return [0];}
   function caml_convert_raw_backtrace_slot(_rbt){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_copysign_float(x, y){
    if(y === 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function fs_node_supported(){
    return globalThis.process?.versions?.node !== undefined;
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.slice(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = device.length > 0 && device.charAt(1) !== ":";
     if(result[2] || isUnc){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.slice(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split(/[/\\]/),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) === 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root?.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.slice(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function caml_create_string(_len){caml_invalid_argument("String.create");}
   function caml_csel_value(v_cond, v_true, v_false){return v_cond ? v_true : v_false;
   }
   var caml_custom_event_index = 0;
   function caml_custom_identifier(o){
    return caml_string_of_jsstring(o.caml_custom);
   }
   var
    zstd_decompress =
      function(){
        var
         ab = ArrayBuffer,
         u8 = Uint8Array,
         u16 = Uint16Array,
         i16 = Int16Array,
         i32 = Int32Array;
        function slc(v, s, e){
         if(u8.prototype.slice) return u8.prototype.slice.call(v, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         var n = new u8(e - s);
         n.set(v.subarray(s, e));
         return n;
        }
        function fill(v, n, s, e){
         if(u8.prototype.fill) return u8.prototype.fill.call(v, n, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         for(; s < e; ++s) v[s] = n;
         return v;
        }
        function cpw(v, t, s, e){
         if(u8.prototype.copyWithin)
          return u8.prototype.copyWithin.call(v, t, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         while(s < e) v[t++] = v[s++];
        }
        var
         ec =
           ["invalid zstd data",
            "window size too large (>2046MB)",
            "invalid block type",
            "FSE accuracy too high",
            "match distance too far back",
            "unexpected EOF"];
        function err(ind, msg, nt){
         var e = new Error(msg || ec[ind]);
         e.code = ind;
         if(! nt) throw e;
         return e;
        }
        function rb(d, b, n){
         var i = 0, o = 0;
         for(; i < n; ++i) o |= d[b++] << (i << 3);
         return o;
        }
        function b4(d, b){
         return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        }
        function rzfh(dat, w){
         var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
         if(n3 === 0x2fb528 && dat[3] === 253){
          var
           flg = dat[4],
           ss = flg >> 5 & 1,
           cc = flg >> 2 & 1,
           df = flg & 3,
           fcf = flg >> 6;
          if(flg & 8) err(0);
          var bt = 6 - ss, db = df === 3 ? 4 : df, di = rb(dat, bt, db);
          bt += db;
          var
           fsb = fcf ? 1 << fcf : ss,
           fss = rb(dat, bt, fsb) + (fcf === 1 && 256),
           ws = fss;
          if(! ss){
           var wb = 1 << 10 + (dat[5] >> 3);
           ws = wb + (wb >> 3) * (dat[5] & 7);
          }
          if(ws > 2145386496) err(1);
          var buf = new u8((w === 1 ? fss || ws : w ? 0 : ws) + 12);
          buf[0] = 1, buf[4] = 4, buf[8] = 8;
          return {b: bt + fsb,
                  y: 0,
                  l: 0,
                  d: di,
                  w: w && w !== 1 ? w : buf.subarray(12),
                  e: ws,
                  o: new i32(buf.buffer, 0, 3),
                  u: fss,
                  c: cc,
                  m: Math.min(131072, ws)};
         }
         else if((n3 >> 4 | dat[3] << 20) === 0x184d2a5)
          return b4(dat, 4) + 8;
         err(0);
        }
        function msb(val){
         var bits = 0;
         for(; 1 << bits <= val; ++bits) ;
         return bits - 1;
        }
        function rfse(dat, bt, mal){
         var tpos = (bt << 3) + 4, al = (dat[bt] & 15) + 5;
         if(al > mal) err(3);
         var
          sz = 1 << al,
          probs = sz,
          sym = - 1,
          re = - 1,
          i = - 1,
          ht = sz,
          buf = new ab(512 + (sz << 2)),
          freq = new i16(buf, 0, 256),
          dstate = new u16(buf, 0, 256),
          nstate = new u16(buf, 512, sz),
          bb1 = 512 + (sz << 1),
          syms = new u8(buf, bb1, sz),
          nbits = new u8(buf, bb1 + sz);
         while(sym < 255 && probs > 0){
          var
           bits = msb(probs + 1),
           cbt = tpos >> 3,
           msk = (1 << bits + 1) - 1,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7)
             & msk,
           msk1fb = (1 << bits) - 1,
           msv = msk - probs - 1,
           sval = val & msk1fb;
          if(sval < msv)
           tpos += bits, val = sval;
          else{tpos += bits + 1; if(val > msk1fb) val -= msv;}
          freq[++sym] = --val;
          if(val === - 1){probs += val; syms[--ht] = sym;} else probs -= val;
          if(! val)
           do{
            var rbt = tpos >> 3;
            re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
            tpos += 2;
            sym += re;
           }
           while
            (re === 3);
         }
         if(sym > 255 || probs) err(0);
         var sympos = 0, sstep = (sz >> 1) + (sz >> 3) + 3, smask = sz - 1;
         for(var s = 0; s <= sym; ++s){
          var sf = freq[s];
          if(sf < 1){dstate[s] = - sf; continue;}
          for(i = 0; i < sf; ++i){
           syms[sympos] = s;
           do sympos = sympos + sstep & smask;while(sympos >= ht);
          }
         }
         if(sympos) err(0);
         for(i = 0; i < sz; ++i){
          var ns = dstate[syms[i]]++, nb = nbits[i] = al - msb(ns);
          nstate[i] = (ns << nb) - sz;
         }
         return [tpos + 7 >> 3, {b: al, s: syms, n: nbits, t: nstate}];
        }
        function rhu(dat, bt){
         var
          i = 0,
          wc = - 1,
          buf = new u8(292),
          hb = dat[bt],
          hw = buf.subarray(0, 256),
          rc = buf.subarray(256, 268),
          ri = new u16(buf.buffer, 268);
         if(hb < 128){
          var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];
          bt += hb;
          var epos = ebt << 3, lb = dat[bt];
          if(! lb) err(0);
          var
           st1 = 0,
           st2 = 0,
           btr1 = fdt.b,
           btr2 = btr1,
           fpos = (++bt << 3) - 8 + msb(lb);
          for(;;){
           fpos -= btr1;
           if(fpos < epos) break;
           var cbt = fpos >> 3;
           st1 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
           hw[++wc] = fdt.s[st1];
           fpos -= btr2;
           if(fpos < epos) break;
           cbt = fpos >> 3;
           st2 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
           hw[++wc] = fdt.s[st2];
           btr1 = fdt.n[st1];
           st1 = fdt.t[st1];
           btr2 = fdt.n[st2];
           st2 = fdt.t[st2];
          }
          if(++wc > 255) err(0);
         }
         else{
          wc = hb - 127;
          for(; i < wc; i += 2){
           var byte = dat[++bt];
           hw[i] = byte >> 4;
           hw[i + 1] = byte & 15;
          }
          ++bt;
         }
         var wes = 0;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          if(wt > 11) err(0);
          wes += wt && 1 << wt - 1;
         }
         var mb = msb(wes) + 1, ts = 1 << mb, rem = ts - wes;
         if(rem & rem - 1) err(0);
         hw[wc++] = msb(rem) + 1;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          ++rc[hw[i] = wt && mb + 1 - wt];
         }
         var
          hbuf = new u8(ts << 1),
          syms = hbuf.subarray(0, ts),
          nb = hbuf.subarray(ts);
         ri[mb] = 0;
         for(i = mb; i > 0; --i){
          var pv = ri[i];
          fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
         }
         if(ri[0] !== ts) err(0);
         for(i = 0; i < wc; ++i){
          var bits = hw[i];
          if(bits){
           var code = ri[bits];
           fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
          }
         }
         return [bt, {n: nb, b: mb, s: syms}];
        }
        var
         dllt =
           rfse
             (new
               u8
               ([81,
                 16,
                 99,
                 140,
                 49,
                 198,
                 24,
                 99,
                 12,
                 33,
                 196,
                 24,
                 99,
                 102,
                 102,
                 134,
                 70,
                 146,
                 4]),
              0,
              6)
            [1],
         dmlt =
           rfse
             (new
               u8
               ([33,
                 20,
                 196,
                 24,
                 99,
                 140,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 36,
                 9]),
              0,
              6)
            [1],
         doct =
           rfse
             (new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]),
              0,
              5)
            [1];
        function b2bl(b, s){
         var len = b.length, bl = new i32(len);
         for(var i = 0; i < len; ++i){bl[i] = s; s += 1 << b[i];}
         return bl;
        }
        var
         llb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                16843009,
                50528770,
                134678020,
                202050057,
                269422093]).buffer,
             0,
             36),
         llbl = b2bl(llb, 0),
         mlb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                16843009,
                50528770,
                117769220,
                185207048,
                252579084,
                16]).buffer,
             0,
             53),
         mlbl = b2bl(mlb, 3);
        function dhu(dat, out, hu){
         var
          len = dat.length,
          ss = out.length,
          lb = dat[len - 1],
          msk = (1 << hu.b) - 1,
          eb = - hu.b;
         if(! lb) err(0);
         var
          st = 0,
          btr = hu.b,
          pos = (len << 3) - 8 + msb(lb) - btr,
          i = - 1;
         while(pos > eb && i < ss){
          var
           cbt = pos >> 3,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
          st = (st << btr | val) & msk;
          out[++i] = hu.s[st];
          pos -= btr = hu.n[st];
         }
         if(pos !== eb || i + 1 !== ss) err(0);
        }
        function dhu4(dat, out, hu){
         var
          bt = 6,
          ss = out.length,
          sz1 = ss + 3 >> 2,
          sz2 = sz1 << 1,
          sz3 = sz1 + sz2;
         dhu
          (dat.subarray(bt, bt += dat[0] | dat[1] << 8),
           out.subarray(0, sz1),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[2] | dat[3] << 8),
           out.subarray(sz1, sz2),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[4] | dat[5] << 8),
           out.subarray(sz2, sz3),
           hu);
         dhu(dat.subarray(bt), out.subarray(sz3), hu);
        }
        function rzb(dat, st, out){
         var _a, bt = st.b, b0 = dat[bt], btype = b0 >> 1 & 3;
         st.l = b0 & 1;
         var
          sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13,
          ebt = (bt += 3) + sz;
         if(btype === 1){
          if(bt >= dat.length) return;
          st.b = bt + 1;
          if(out){fill(out, dat[bt], st.y, st.y += sz); return out;}
          return fill(new u8(sz), dat[bt]);
         }
         if(ebt > dat.length) return;
         if(btype === 0){
          st.b = ebt;
          if(out){
           out.set(dat.subarray(bt, ebt), st.y);
           st.y += sz;
           return out;
          }
          return slc(dat, bt, ebt);
         }
         if(btype === 2){
          var
           b3 = dat[bt],
           lbt = b3 & 3,
           sf = b3 >> 2 & 3,
           lss = b3 >> 4,
           lcs = 0,
           s4 = 0;
          if(lbt < 2)
           if(sf & 1)
            lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);
           else
            lss = b3 >> 3;
          else{
           s4 = sf;
           if(sf < 2)
            lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;
           else if(sf === 2)
            lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12,
            lcs = dat[bt] >> 2 | dat[++bt] << 6;
           else
            lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12,
            lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
          }
          ++bt;
          var
           buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m),
           spl = buf.length - lss;
          if(lbt === 0)
           buf.set(dat.subarray(bt, bt += lss), spl);
          else if(lbt === 1)
           fill(buf, dat[bt++], spl);
          else{
           var hu = st.h;
           if(lbt === 2){
            var hud = rhu(dat, bt);
            lcs += bt - (bt = hud[0]);
            st.h = hu = hud[1];
           }
           else if(! hu) err(0);
           (s4 ? dhu4 : dhu)
            (dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
          }
          var ns = dat[bt++];
          if(ns){
           if(ns === 255)
            ns = (dat[bt++] | dat[bt++] << 8) + 0x7f00;
           else if(ns > 127) ns = ns - 128 << 8 | dat[bt++];
           var scm = dat[bt++];
           if(scm & 3) err(0);
           var dts = [dmlt, doct, dllt];
           for(var i = 2; i > - 1; --i){
            var md = scm >> (i << 1) + 2 & 3;
            if(md === 1){
             var rbuf = new u8([0, 0, dat[bt++]]);
             dts[i] =
              {s: rbuf.subarray(2, 3),
               n: rbuf.subarray(0, 1),
               t: new u16(rbuf.buffer, 0, 1),
               b: 0};
            }
            else if(md === 2)
             _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
            else if(md === 3){if(! st.t) err(0); dts[i] = st.t[i];}
           }
           var
            _b = st.t = dts,
            mlt = _b[0],
            oct = _b[1],
            llt = _b[2],
            lb = dat[ebt - 1];
           if(! lb) err(0);
           var
            spos = (ebt << 3) - 8 + msb(lb) - llt.b,
            cbt = spos >> 3,
            oubt = 0,
            lst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
           cbt = (spos -= oct.b) >> 3;
           var
            ost =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
           cbt = (spos -= mlt.b) >> 3;
           var
            mst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
           for(++ns; --ns;){
            var
             llc = llt.s[lst],
             lbtr = llt.n[lst],
             mlc = mlt.s[mst],
             mbtr = mlt.n[mst],
             ofc = oct.s[ost],
             obtr = oct.n[ost];
            cbt = (spos -= ofc) >> 3;
            var
             ofp = 1 << ofc,
             off =
               ofp
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16
                | dat[cbt + 3] << 24)
                >>> (spos & 7)
                & ofp - 1);
            cbt = (spos -= mlb[mlc]) >> 3;
            var
             ml =
               mlbl[mlc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << mlb[mlc]) - 1);
            cbt = (spos -= llb[llc]) >> 3;
            var
             ll =
               llbl[llc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << llb[llc]) - 1);
            cbt = (spos -= lbtr) >> 3;
            lst =
             llt.t[lst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
            cbt = (spos -= mbtr) >> 3;
            mst =
             mlt.t[mst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
            cbt = (spos -= obtr) >> 3;
            ost =
             oct.t[ost]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
            if(off > 3){
             st.o[2] = st.o[1];
             st.o[1] = st.o[0];
             st.o[0] = off -= 3;
            }
            else{
             var idx = off - (ll !== 0);
             if(idx){
              off = idx === 3 ? st.o[0] - 1 : st.o[idx];
              if(idx > 1) st.o[2] = st.o[1];
              st.o[1] = st.o[0];
              st.o[0] = off;
             }
             else
              off = st.o[0];
            }
            for(var i = 0; i < ll; ++i) buf[oubt + i] = buf[spl + i];
            oubt += ll, spl += ll;
            var stin = oubt - off;
            if(stin < 0){
             var len = - stin, bs = st.e + stin;
             if(len > ml) len = ml;
             for(var i = 0; i < len; ++i) buf[oubt + i] = st.w[bs + i];
             oubt += len, ml -= len, stin = 0;
            }
            for(var i = 0; i < ml; ++i) buf[oubt + i] = buf[stin + i];
            oubt += ml;
           }
           if(oubt !== spl)
            while(spl < buf.length) buf[oubt++] = buf[spl++];
           else
            oubt = buf.length;
           if(out) st.y += oubt; else buf = slc(buf, 0, oubt);
          }
          else if(out){
           st.y += lss;
           if(spl) for(var i = 0; i < lss; ++i) buf[i] = buf[spl + i];
          }
          else if(spl) buf = slc(buf, spl);
          st.b = ebt;
          return buf;
         }
         err(2);
        }
        function cct(bufs, ol){
         if(bufs.length === 1) return bufs[0];
         var buf = new u8(ol);
         for(var i = 0, b = 0; i < bufs.length; ++i){
          var chk = bufs[i];
          buf.set(chk, b);
          b += chk.length;
         }
         return buf;
        }
        return function(dat, buf){
         var bt = 0, bufs = [], nb = + ! buf, ol = 0;
         while(dat.length){
          var st = rzfh(dat, nb || buf);
          if(typeof st === "object"){
           if(nb){
            buf = null;
            if(st.w.length === st.u){bufs.push(buf = st.w); ol += st.u;}
           }
           else{bufs.push(buf); st.e = 0;}
           while(! st.l){
            var blk = rzb(dat, st, buf);
            if(! blk) err(5);
            if(buf)
             st.e = st.y;
            else{
             bufs.push(blk);
             ol += blk.length;
             cpw(st.w, 0, blk.length);
             st.w.set(blk, st.w.length - blk.length);
            }
           }
           bt = st.b + st.c * 4;
          }
          else
           bt = st;
          dat = dat.subarray(bt);
         }
         return cct(bufs, ol);};
       }
       (),
    caml_decompress_input = zstd_decompress;
   function caml_div(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_compare_and_set(old, n){
    if(caml_domain_dls !== old) return 0;
    caml_domain_dls = n;
    return 1;
   }
   function caml_domain_dls_get(_unit){return caml_domain_dls;}
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, term_sync){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(term_sync[2]);
    term_sync[1] = [0, [0, res]];
    return id;
   }
   function caml_dummy_obj_is_stack(x){
    throw new
           Error
           (`BUG: this function should be unreachable; please report to compiler or base devs.`);
   }
   var
    caml_ephe_none = {caml_ephe_none: 0},
    caml_ephe_data_offset = 2,
    caml_ephe_key_offset = 3;
   function caml_ephe_get_data(x){
    var data = x[caml_ephe_data_offset];
    if(data === caml_ephe_none) return 0;
    for(var i = caml_ephe_key_offset; i < x.length; i++){
     var k = x[i];
     if(globalThis.WeakRef && k instanceof globalThis.WeakRef){
      var d = k.deref();
      if(d === undefined){
       x[i] = caml_ephe_none;
       x[caml_ephe_data_offset] = caml_ephe_none;
       return 0;
      }
      if(globalThis.WeakMap){
       data = data.get(k);
       if(data === undefined){
        x[caml_ephe_data_offset] = caml_ephe_none;
        return 0;
       }
      }
     }
    }
    return [0, data];
   }
   function caml_ephe_unset_data(x){
    x[caml_ephe_data_offset] = caml_ephe_none;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    for(var i = x.length - 1; i >= caml_ephe_key_offset; i--){
     var k = x[i];
     if(globalThis.WeakRef && k instanceof globalThis.WeakRef){
      var d = k.deref();
      if(d === undefined){x[i] = caml_ephe_none; continue;}
      if(globalThis.WeakMap) data = new globalThis.WeakMap().set(k, data);
     }
    }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_set_data_opt(x, data_opt){
    if(data_opt === 0)
     caml_ephe_unset_data(x);
    else
     caml_ephe_set_data(x, data_opt[1]);
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var old = caml_ephe_get_data(src);
    caml_ephe_set_data_opt(dst, old);
    return 0;
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    var old = caml_ephe_get_data(a1);
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    caml_ephe_set_data_opt(a2, old);
    return 0;
   }
   function caml_ephe_check_data(x){
    var data = caml_ephe_get_data(x);
    return data === 0 ? 0 : 1;
   }
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(weak === caml_ephe_none) return 0;
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef){
     weak = weak.deref();
     if(weak === undefined){
      x[caml_ephe_key_offset + i] = caml_ephe_none;
      x[caml_ephe_data_offset] = caml_ephe_none;
      return 0;
     }
    }
    return 1;
   }
   function caml_weak_create(n){
    var alen = caml_ephe_key_offset + n, x = new Array(alen);
    x[0] = 251;
    x[1] = "caml_ephe_list_head";
    for(var i = 2; i < alen; i++) x[i] = caml_ephe_none;
    return x;
   }
   function caml_ephe_create(n){return caml_weak_create(n);}
   function caml_obj_dup(x){return typeof x === "number" ? x : x.slice();}
   function caml_ephe_get_data_copy(x){
    var r = caml_ephe_get_data(x);
    if(r === 0) return 0;
    var z = r[1];
    if(Array.isArray(z)) return [0, caml_obj_dup(z)];
    return r;
   }
   function caml_ephe_get_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(weak === caml_ephe_none) return 0;
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef){
     weak = weak.deref();
     if(weak === undefined){
      x[caml_ephe_key_offset + i] = caml_ephe_none;
      x[caml_ephe_data_offset] = caml_ephe_none;
      return 0;
     }
    }
    return [0, weak];
   }
   function caml_ephe_get_key_copy(x, i){
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(Array.isArray(z)) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_ephe_set_key(x, i, v){
    var old = caml_ephe_get_data(x);
    if(globalThis.WeakRef && v instanceof Object)
     v = new globalThis.WeakRef(v);
    x[caml_ephe_key_offset + i] = v;
    caml_ephe_set_data_opt(x, old);
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    var old = caml_ephe_get_data(x);
    x[caml_ephe_key_offset + i] = caml_ephe_none;
    caml_ephe_set_data_opt(x, old);
    return 0;
   }
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) === 0);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   var caml_executable_name = caml_argv[1];
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] === 0){
     r += exn[1][1];
     if
      (exn.length === 3 && exn[2][0] === 0
       && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v === "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v === "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] === 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(Array.isArray(err) && (err[0] === 0 || err[0] === 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i === 0 && (l >= s.l || s.t === 2 && l >= s.c.length))
      if(c === 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l === s.l ? 0 : 2;
      }
     else{
      if(s.t !== 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_final_register(_f, _x){return 0;}
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_final_release(_unit){return 0;}
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle !== "-")) len++;
    if(f.alternate){if(f.base === 8) len += 1; if(f.base === 16) len += 2;}
    var buffer = "";
    if(f.justify === "+" && f.filler === " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle !== "-") buffer += f.signstyle;
    if(f.alternate && f.base === 8) buffer += "0";
    if(f.alternate && f.base === 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify === "+" && f.filler === "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify === "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(! Number.isNaN(x)) return 1;
    if(! Number.isNaN(y)) return - 1;
    return 0;
   }
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_float_of_string(s){
    var res, r_float = /^ *[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?$/;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(! Number.isNaN(res) && r_float.test(s)) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(! Number.isNaN(res) && r_float.test(s) || /^[+-]?nan$/i.test(s))
     return res;
    var
     m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?$/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = Number.parseInt(m[1] + m[2] + m3, 16),
      exponent = (+ m[5] || 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Number.POSITIVE_INFINITY;
    if(/^-inf(inity)?$/i.test(s)) return Number.NEGATIVE_INFINITY;
    caml_failwith("float_of_string");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){return caml_array_blit(a1, i1, a2, i2, len);
   }
   function caml_floatarray_create(len){
    if(len >>> 0 >= (0x7fffffff / 8 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if(x === 0 || y === 0 || ! Number.isFinite(x) || ! Number.isFinite(y))
     return x * y + z;
    if(z === 0) return x * y;
    if(! Number.isFinite(z)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
        break;
       case "d":
       case "i":
        f.signedconv = true; f.base = 10; break;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = Number.parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += caml_str_repeat(e, "0");
       if(dp > 0) x = x + "." + caml_str_repeat(dp, "0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x === 0 && 1 / x === Number.NEGATIVE_INFINITY){f.sign = - 1; x = - x;}
    if(Number.isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! Number.isFinite(x)){s = "inf"; f.filler = " ";}
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) === "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) === "0") i--;
         if(s.charAt(i) === ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) === "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) === "0") i--;
          if(s.charAt(i) === ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) === "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   var caml_oo_last_id = 0;
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_frexp_float(x){
    if(x === 0 || ! Number.isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, Math.floor(Math.log2(x)) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsstring(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.jsoo_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.jsoo_fs_tmp = [];
    return 0;
   }
   function caml_gc_compaction(_unit){return 0;}
   function caml_gc_counters(_unit){return [254, 0, 0, 0];}
   function caml_gc_full_major(_unit){
    if(typeof globalThis.gc === "function") globalThis.gc();
    return 0;
   }
   function caml_gc_get(_unit){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_gc_major(_unit){
    if(typeof globalThis.gc === "function") globalThis.gc();
    return 0;
   }
   function caml_gc_major_slice(_work){return 0;}
   function caml_gc_minor(_unit){
    if(typeof globalThis.gc === "function") globalThis.gc(true);
    return 0;
   }
   function caml_gc_minor_words(_unit){return 0;}
   function caml_gc_quick_stat(_unit){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_gc_set(_control){return 0;}
   function caml_gc_stat(unit){return caml_gc_quick_stat(unit);}
   var caml_method_cache = [];
   function caml_get_cached_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(meths[ofs + 4] === tag) return meths[ofs + 3];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li - 3;
    return meths[li];
   }
   function caml_get_continuation_callstack(){return [0];}
   function caml_get_current_callstack(){return [0];}
   function caml_get_exception_backtrace(){return 0;}
   function caml_get_exception_raw_backtrace(_unit){return [0];}
   function caml_get_global_data(_unit){return caml_global_data;}
   function caml_get_minor_free(_unit){return 0;}
   function caml_get_public_method(obj, tag){
    var meths = obj[1], li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    return tag === meths[li + 1] ? meths[li] : 0;
   }
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j === 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev !== xPos || yPos_prev !== yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_gr_close_subwindow(_a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c === - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info === "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? Number.parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? Number.parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_gr_open_subwindow(_a, _b, _c, _d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xff;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_gr_sigio_signal(){return 0;}
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_window_id(_a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--)
     if(nat.data[ofs + i] !== 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! Number.isFinite(x)){
     if(Number.isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var
     sign = x === 0 && 1 / x === Number.NEGATIVE_INFINITY ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x === 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.slice(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   var caml_marshal_header_size = 16;
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length === 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     if(chan.fd === - 1) caml_raise_sys_error("Bad file descriptor");
     var
      nread =
        chan.file.read
         (chan.buffer, chan.buffer_max, chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7f;
     while((c & 0x80) !== 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n !== n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7f;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495a6be:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495a6bd:
       var
        header_len = r.read8u() & 0x3f,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495a6bf:
       caml_failwith
        ("Marshal.data_size: object too large to be read back on a 32-bit platform");
       break;
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_input_value_from_reader(reader){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7f;
     while((c & 0x80) !== 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n !== n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7f;
     }
     return n;
    }
    var old_pos = reader.i, magic = reader.read32u();
    switch(magic){
      case 0x8495a6be:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495a6bd:
       var
        header_len = reader.read8u() & 0x3f,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495a6bf:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    if(header_len !== reader.i - old_pos)
     caml_failwith("caml_input_value_from_reader: invalid header");
    var
     stack = [],
     objects = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xf, size = code >> 4 & 0x7, v = [tag];
       if(size === 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       if(tag === 248) objects.push(v);
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3f;
     else if(code >= 0x20){
      var len = code & 0x1f, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed === 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xff,
          size = header >> 10,
          v = [tag];
         if(size === 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         if(tag === 248) objects.push(v);
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0a:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0c:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0b:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0e:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0d:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0f:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) !== 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var size = [0], v = ops.deserialize(reader, size);
         if(expected_size !== undefined)
          if(expected_size !== size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    while(objects.length > 0){
     var x = objects.pop();
     if(x[2] >= 0) caml_set_oo_id(x);
    }
    return res;
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     c = caml_ml_bytes_content(s),
     ofs = typeof ofs === "number" ? ofs : ofs[0],
     reader =
       c instanceof Uint8Array
        ? new UInt8ArrayReader(c, ofs)
        : new JsStringReader(c, ofs);
    return caml_input_value_from_reader(reader);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channel_get(chanid),
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r === 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_uint8_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var res = caml_input_value_from_bytes(caml_bytes_of_uint8_array(buf), 0);
    return res;
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_install_signal_handler(){return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000ff) << 24 | (x & 0x0000ff00) << 8
           | (x & 0x00ff0000) >>> 8
           | (x & 0xff000000) >>> 24;
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_int64_div(x, y){return x.div(y);}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var
     i = 0,
     len = caml_ml_string_length(s),
     base = 10,
     sign = 1,
     signedness = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) === 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        signedness = 0; base = 16; i += 2; break;
       case 111:
       case 79:
        signedness = 0; base = 8; i += 2; break;
       case 98:
       case 66:
        signedness = 0; base = 2; i += 2; break;
       case 117:
       case 85:
        signedness = 0; i += 2; break;
     }
    return [i, sign, base, signedness];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     base64 = caml_int64_of_int32(base),
     threshold = MlInt64.UNSIGNED_MAX.udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("Int64.of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("Int64.of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("Int64.of_string");
    }
    if(i !== caml_ml_string_length(s)) caml_failwith("Int64.of_string");
    if
     (signedness
      &&
       caml_int64_ult(sign < 0 ? MlInt64.SIGNED_MIN : MlInt64.SIGNED_MAX, res))
     caml_failwith("Int64.of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_int64_or(x, y){return x.or(y);}
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     signedness = r[3],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c === 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i !== len) caml_failwith("int_of_string");
    res = sign * res;
    if(signedness && (res | 0) !== res) caml_failwith("int_of_string");
    return res | 0;
   }
   var caml_io_buffer_size = 65536;
   function caml_is_js(){return 1;}
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_js_from_bool(x){return ! ! x;}
   function caml_js_from_float(x){return x;}
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_get(o, f){return o[f];}
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     return null;
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /"/g, all: /[&<"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c();
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F();
   }
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_js_to_bool(x){return + x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_js_to_float(x){return x;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function caml_js_typeof(o){return typeof o;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_js_wrap_callback(f){
    return function(...args){
     if(args.length === 0) args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_callback_arguments(f){
    return function(...args){return caml_callback(f, [args]);};
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(...args){
     args.length = arity;
     return caml_callback(f, args);};
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(...args){
     var len = caml_js_function_arity(f);
     args.length = len;
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback(f){
    return function(...args){
     args.unshift(this);
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback_arguments(f){
    return function(...args){return caml_callback(f, [this, args]);};
   }
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(...args){
     args.length = arity;
     args.unshift(this);
     return caml_callback(f, args);};
   }
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(...args){
     var len = caml_js_function_arity(f);
     args.unshift(this);
     args.length = len;
     return caml_callback(f, args);};
   }
   function caml_jsoo_flags_effects(_unit){
    return caml_string_of_jsstring("disabled");
   }
   function caml_jsoo_flags_use_js_string(_unit){return 1;}
   function caml_lazy_make_forward(v){return [250, v];}
   function caml_obj_tag(x){
    if(Array.isArray(x) && x[0] === x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x === "function")
     return 247;
    else if(x?.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) === 250 ? o[1] : o;
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] === o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return Array.isArray(o) && o[0] === o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var c, state = start_state, buffer = lexbuf[lex_buffer];
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] === 0) return - state - 1; else c = 256;
     else{
      c = caml_bytes_unsafe_get(buffer, lexbuf[lex_curr_pos]);
      lexbuf[lex_curr_pos]++;
     }
     if(tbl.lex_check[base + c] === state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] === - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c === 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsstring(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   function caml_log10_float(x){return Math.log10(x);}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_log2_float(x){return Math.log2(x);}
   var
    caml_lxm_M =
      caml_int64_of_string(caml_string_of_jsstring("0xd1342543de82ef95")),
    caml_lxm_daba =
      caml_int64_of_string(caml_string_of_jsstring("0xdaba0b6eb09322e3"));
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_lxm_M,
     daba = caml_lxm_daba,
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_make_float_vect(len){
    if(len >>> 0 >= (0x7fffffff / 8 | 0)) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_make_vect(len, init){return caml_array_make(len, init);}
   function caml_make_local_vect(v_len, v_elt){return caml_make_vect(v_len, v_elt);
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0a,
       CODE_DOUBLE_BIG: 0x0b,
       CODE_DOUBLE_LITTLE: 0x0c,
       CODE_DOUBLE_ARRAY8_BIG: 0x0d,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0e,
       CODE_DOUBLE_ARRAY32_BIG: 0x0f,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_maybe_print_stats(_unit){return 0;}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_uint8_array(caml_MD5Final(ctx));
   }
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channel_get(chanid),
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read === 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read === 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_uint8_array(caml_MD5Final(ctx));
   }
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_memprof_discard(_t){return 0;}
   function caml_memprof_start(_rate, _stack_size, _tracker){return 0;}
   function caml_memprof_stop(_unit){return 0;}
   function caml_ml_channel_redirect(captured, into){
    var
     to_restore = caml_ml_channel_get(captured),
     new_ = caml_ml_channel_get(into);
    caml_ml_channels.set(captured, new_);
    return to_restore;
   }
   function caml_ml_channel_restore(captured, to_restore){caml_ml_channels.set(captured, to_restore); return 0;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.length() | 0;
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channel_get(chanid);
    return caml_int64_of_float(chan.file.length());
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var x = caml_sys_fds[fd];
    if(x){x.file.close(); delete caml_sys_fds[fd];}
    return 0;
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr === 0) return 0;
    if(chan.output)
     chan.output
      (caml_sub_uint8_array_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     for(var pos = 0; pos < chan.buffer_curr;)
      pos += chan.file.write(chan.buffer, pos, chan.buffer_curr - pos);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.opened){
     chan.opened = false;
     caml_ml_channels.close(chanid);
     caml_sys_close(chan.fd);
     chan.fd = - 1;
     chan.buffer = new Uint8Array(0);
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_condition_broadcast(_t){return 0;}
   function caml_ml_condition_new(_unit){return {condition: 1};}
   function caml_ml_condition_signal(_t){return 0;}
   function caml_ml_condition_wait(_t, _mutext){return 0;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_ml_domain_cpu_relax(_unit){return 0;}
   function caml_ml_domain_id(_unit){return caml_domain_id;}
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_bigarray(chanid, b, i, l){
    var ba = caml_ba_to_typed_array(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channel_get(chanid);
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channel_get(chanid), p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max === chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] !== 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_ml_is_binary_mode(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.file.flags.binary;
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channel_get(chanid).buffered ? 1 : 0;
   }
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function caml_ml_mutex_new(_unit){return new MlMutex();}
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.altname)
     try{
      var fs = require("node:fs"), fd2 = fs.openSync(flags.altname, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function caml_sys_open_internal(file, idx){
    var chanid;
    if(idx === undefined){
     idx = caml_sys_fds.length;
     chanid = new MlChanid(idx);
    }
    else if(caml_sys_fds[idx])
     chanid = caml_sys_fds[idx].chanid;
    else
     chanid = new MlChanid(idx);
    caml_sys_fds[idx] = {file: file, chanid: chanid};
    return idx | 0;
   }
   function caml_sys_open(name, flags, perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; f.writeonly = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    var
     root = resolve_fs_device(name),
     file = root.device.open(root.rest, f, perms);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      var is_node = fs_node_supported();
      function file(fd, flags){
       return is_node
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file
         (1, {buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true}),
        1);
      caml_sys_open_internal
       (file
         (2, {buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true}),
        2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined)
     caml_raise_sys_error("fd " + fd + " doesn't exist");
    var
     file = fd_desc.file,
     chanid = fd_desc.chanid,
     refill = null,
     channel =
       {file: file,
        offset: file.offset,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(caml_io_buffer_size),
        refill: refill};
    caml_ml_channels.set(chanid, channel);
    return chanid;
   }
   function caml_ml_open_descriptor_in_with_flags(fd, _flags){return caml_ml_open_descriptor_in(fd);
   }
   function caml_ml_open_descriptor_out(fd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined)
     caml_raise_sys_error("fd " + fd + " doesn't exist");
    var
     file = fd_desc.file,
     chanid = fd_desc.chanid,
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.offset,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(caml_io_buffer_size),
        buffered: buffered};
    caml_ml_channels.set(chanid, channel);
    return chanid;
   }
   function caml_ml_open_descriptor_out_with_flags(fd, _flags){return caml_ml_open_descriptor_out(fd);
   }
   function caml_ml_out_channels_list(){
    var l = 0, keys = caml_ml_channels.all();
    for(var k of keys){
     var chan = caml_ml_channel_get(k);
     if(chan.opened && chan.out) l = [0, k, l];
    }
    return l;
   }
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channel_get(chanid);
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_output_bigarray(chanid, buffer, offset, len){
    var buffer = caml_ba_to_typed_array(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_ml_output_int(chanid, i){
    var arr = [i >> 24 & 0xff, i >> 16 & 0xff, i >> 8 & 0xff, i & 0xff];
    caml_ml_output_ta(chanid, new Uint8Array(arr), 0, 4);
    return 0;
   }
   function caml_pos_in(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset - (chan.buffer_max - chan.buffer_curr);
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid) | 0;}
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_pos_out(chanid){
    var chan = caml_ml_channel_get(chanid);
    return chan.offset + chan.buffer_curr;
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid) | 0;}
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_ml_runtime_events_are_active(){return 0;}
   function caml_ml_runtime_events_pause(){return 0;}
   function caml_ml_runtime_events_resume(){return 0;}
   function caml_ml_runtime_events_start(){return 0;}
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channel_get(chanid);
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{
     chan.file.seek(pos, 0);
     chan.offset = pos;
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
    }
    return 0;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channel_get(chanid);
    chan.file.seek(pos, 0);
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channel_get(chanid);
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channel_get(chanid).buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channel_get(chanid);
    chan.name = name;
    return 0;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channel_get(chanid);
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channel_get(chanid).refill = f;
    return 0;
   }
   function caml_mod(x, y){
    if(y === 0) caml_raise_zero_divide();
    return x % y;
   }
   function caml_modf_float(x){
    if(Number.isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(Number.isNaN(x)) return [0, Number.NaN, Number.NaN];
    return [0, 1 / x, x];
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst === 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src === 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst === 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src === 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var c, state = start_state, buffer = lexbuf[lex_buffer];
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] === 0) return - state - 1; else c = 256;
     else{
      c = caml_bytes_unsafe_get(buffer, lexbuf[lex_curr_pos]);
      lexbuf[lex_curr_pos]++;
     }
     var pstate = state;
     if(tbl.lex_check[base + c] === state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] === - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] === pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c === 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_nextafter_float(x, y){
    if(Number.isNaN(x) || Number.isNaN(y)) return Number.NaN;
    if(x === y) return y;
    if(x === 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y === x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) !== 0);
   }
   function caml_obj_add_offset(_v, _offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] === old){x[i + 1] = n; return 1;}
    return 0;
   }
   function caml_obj_is_shared(_x){return 1;}
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_obj_reachable_words(_o){return 0;}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c();
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F();
   }
   function caml_oo_cache_id(){
    var cacheid = caml_method_cache.length;
    caml_method_cache[cacheid] = 0;
   }
   var
    caml_output_val =
      function(){
        class Writer{
           constructor(){
            this.chunk = [];
            this.chunk_idx = 20;
            this.block_len = 0;
            this.obj_counter = 0;
            this.size_32 = 0;
            this.size_64 = 0;
           }
           write(size, value){
            for(var i = size - 8; i >= 0; i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xff;
           }
           write_at(pos, size, value){
            var pos = pos;
            for(var i = size - 8; i >= 0; i -= 8)
             this.chunk[pos++] = value >> i & 0xff;
           }
           write_code(size, code, value){
            this.chunk[this.chunk_idx++] = code;
            for(var i = size - 8; i >= 0; i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xff;
           }
           write_shared(offset){
            if(offset < 1 << 8)
             this.write_code(8, 0x04, offset);
            else if(offset < 1 << 16)
             this.write_code(16, 0x05, offset);
            else
             this.write_code(32, 0x06, offset);
           }
           pos(){return this.chunk_idx;}
           finalize(){
            this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32, 0x8495a6be);
            this.write(32, this.block_len);
            this.write(32, this.obj_counter);
            this.write(32, this.size_32);
            this.write(32, this.size_64);
            return this.chunk;
           }
         }
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length === undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length !== sz_32_64[0])
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(Array.isArray(v) && v[0] === (v[0] | 0)){
           if(v[0] === 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0a, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0a, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v !== (v | 0)){
           var type_of_v = typeof v;
           if(type_of_v !== "number")
            caml_failwith("output_value: abstract value (" + type_of_v + ")");
           if(memo(v)) return;
           var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));
           writer.write(8, 0x0c);
           for(var i = 0; i < 8; i++) writer.write(8, t[7 - i]);
           writer.size_32 += 3;
           writer.size_64 += 2;
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0x40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return new Uint8Array(writer.chunk);};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_uint8_array(caml_output_val(v, flags));
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(caml_bytes_of_uint8_array(t), 0, s, ofs, t.length);
    return 0;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_uint8_array(caml_output_val(v, flags));
   }
   var caml_parser_trace = 0;
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(caml_sys_fds[2].chanid, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] === "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(Array.isArray(tok)){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] === "number")
       kind = "" + tok[1];
      else if(typeof tok[1] === "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    the_loop:
    for(;;)
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n !== 0){cmd = reduce; continue the_loop;}
        if(env[env_curr_char] >= 0){cmd = testshift; continue the_loop;}
        res = READ_TOKEN;
        break the_loop;
       case 1:
        if(Array.isArray(arg)){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === env[env_curr_char]){cmd = shift; continue the_loop;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         continue the_loop;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break the_loop;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] === ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           continue the_loop;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] === 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         continue the_loop;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break the_loop;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        continue the_loop;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 !== 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] === state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break the_loop;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break the_loop;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        continue the_loop;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_raw_backtrace_next_slot(_slot){return 0;}
   function caml_raw_backtrace_slot(_bt, _idx){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_read_file_content(name){
    var
     name = typeof name === "string" ? caml_string_of_jsstring(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(buf, 0, len);
     return caml_string_of_uint8_array(buf);
    }
    caml_raise_no_such_file(caml_jsstring_of_string(name));
   }
   function caml_recommended_domain_count(_unit){return 1;}
   function caml_record_backtrace(b){
    caml_record_backtrace_runtime_flag = b;
    return 0;
   }
   var jsoo_toplevel_reloc = undefined;
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(jsoo_toplevel_reloc)
      n = caml_callback(jsoo_toplevel_reloc, [name]);
     else if(caml_global_data.symbols){
      if(! caml_global_data.symidx)
       caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
      var nid = caml_global_data.symidx[name];
      if(nid >= 0)
       n = nid;
      else{
       var n = caml_global_data.symidx.next_idx++;
       caml_global_data.symidx[name] = n;
      }
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function caml_restore_raw_backtrace(_exn, _bt){return 0;}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_runtime_events_create_cursor(_target){return {};}
   function caml_runtime_events_free_cursor(_cursor){return 0;}
   function caml_runtime_events_read_poll(_cursor, _callbacks, _num){return 0;
   }
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   function caml_runtime_events_user_write(_event, _event_content){return 0;}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_set_static_env(k, v){jsoo_static_env[k] = v; return 0;}
   function caml_signbit_float(x){
    if(x === 0) x = 1 / x;
    return x < 0 ? 1 : 0;
   }
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_sse2_float64_max_bytecode(x, y){return x > y ? x : y;}
   function caml_sse2_float64_min_bytecode(x, y){return x < y ? x : y;}
   function caml_strerror(errno){
    const util = require("node:util");
    if(errno >= 0){
     const code = unix_error[errno];
     return util.getSystemErrorMap().entries().find(x=>x[1][0] === code)[1][1];
    }
    else
     return util.getSystemErrorMessage(errno);
   }
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_concat(a, b){return a + b;}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3fffffff;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_string_set(_s, _i, _c){caml_failwith("caml_string_set");}
   function caml_sys_argv(_unit){return caml_argv;}
   function caml_sys_chdir(dir, raise_unix){
    var root = resolve_fs_device(dir);
    if(root.device.is_dir(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else if(root.device.exists(root.rest))
     caml_raise_system_error
      (raise_unix,
       "ENOTDIR",
       "chdir",
       "not a directory",
       caml_jsstring_of_string(dir));
    else
     caml_raise_no_such_file(caml_jsstring_of_string(dir), raise_unix);
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_sys_const_int_size(){return 32;}
   function caml_sys_const_max_wosize(){return 0x7fffffff / 4 | 0;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   var os_type = globalThis.process?.platform === "win32" ? "Win32" : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type === "Cygwin" ? 1 : 0;
   }
   function caml_sys_const_ostype_unix(){return os_type === "Unix" ? 1 : 0;}
   function caml_sys_const_ostype_win32(){return os_type === "Win32" ? 1 : 0;}
   function caml_sys_const_word_size(){return 32;}
   function caml_sys_executable_name(_unit){return caml_executable_name;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process?.exit) globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_sys_get_argv(_unit){return [0, caml_argv[1], caml_argv];}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsstring(caml_current_dir);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_sys_isatty(_chan){return 0;}
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++)
     l[i + 1] = caml_string_of_jsstring(a[i]);
    return l;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name);
    return root.device.unlink(root.rest);
   }
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device !== n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require !== "undefined"){
     var child_process = require("node:child_process");
     if(child_process?.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(_b){return caml_sys_time();}
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_throw_js_exception(exn){throw exn;}
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res?.joo_tramp){res = res.joo_tramp.apply(null, res.joo_args); c++;}
    return res;
   }
   function caml_trampoline_return(f, args, direct){
    return {joo_tramp: f, joo_args: args, joo_direct: direct};
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_unix_access(name, flags){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.r = 1; break;
       case 1:
        f.w = 1; break;
       case 2:
        f.x = 1; break;
       case 3:
        f.f = 1; break;
     }
     flags = flags[2];
    }
    var root = resolve_fs_device(name);
    if(! root.device.access)
     caml_failwith("caml_unix_access: not implemented");
    root.device.access(root.rest, f, true);
    return 0;
   }
   function caml_unix_chdir(dir){return caml_sys_chdir(dir, true);}
   function caml_unix_chmod(name, perms){
    var root = resolve_fs_device(name);
    if(! root.device.chmod) caml_failwith("caml_unix_chmod: not implemented");
    return root.device.chmod(root.rest, perms);
   }
   function caml_unix_cleanup(){}
   function caml_unix_lookup_file(fd, cmd){
    var fd_desc = caml_sys_fds[fd];
    if(fd_desc === undefined) caml_raise_system_error(1, "EBADF", cmd);
    return fd_desc.file;
   }
   function caml_unix_close(fd){
    var file = caml_unix_lookup_file(fd, "close");
    file.close(1);
    return 0;
   }
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){caml_raise_system_error(1, "EBADF", "closedir");}
   }
   function caml_unix_fchmod(fd, perms){
    var file = caml_unix_lookup_file(fd, "fchmod");
    if(! file.chmod) caml_failwith("caml_unix_fchmod: not implemented");
    return file.chmod(perms);
   }
   function caml_unix_filedescr_of_fd(x){return x;}
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){caml_raise_system_error(1, "EBADF", "readdir");}
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_unix_fstat(fd){
    var file = caml_unix_lookup_file(fd, "fstat");
    if(! file.stat) caml_failwith("caml_unix_fstat: not implemented");
    return file.stat(false);
   }
   function caml_unix_fstat_64(fd){
    var file = caml_unix_lookup_file(fd, "fstat");
    if(! file.stat) caml_failwith("caml_unix_fstat64: not implemented");
    return file.stat(true);
   }
   function caml_unix_fsync(fd){
    var file = caml_unix_lookup_file(fd, "fsync");
    if(! file.sync) caml_failwith("caml_unix_fsync: not implemented");
    return file.sync();
   }
   function caml_unix_ftruncate(fd, len){
    var file = caml_unix_lookup_file(fd, "ftruncate");
    if(! file.truncate) caml_failwith("caml_unix_ftruncate: not implemented");
    file.truncate(len, 1);
    return 0;
   }
   function caml_unix_ftruncate_64(fd, len){
    var file = caml_unix_lookup_file(fd, "ftruncate");
    if(! file.truncate)
     caml_failwith("caml_unix_ftruncate_64: not implemented");
    file.truncate(caml_int64_to_float(len), 1);
    return 0;
   }
   function caml_unix_getegid(_unit){
    if(globalThis.process?.getegid) return globalThis.process.getegid();
    return 1;
   }
   function caml_unix_geteuid(_unit){
    if(globalThis.process?.geteuid) return globalThis.process.geteuid();
    return 1;
   }
   function caml_unix_getgid(_unit){
    if(globalThis.process?.getgid) return globalThis.process.getgid();
    return 1;
   }
   function caml_unix_getpwnam(_unit){caml_raise_not_found();}
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_getuid(_unit){
    if(globalThis.process?.getuid) return globalThis.process.getuid();
    return 1;
   }
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_unix_has_symlink(_unit){return fs_node_supported() ? 1 : 0;}
   function caml_unix_inchannel_of_filedescr(fd){
    var file = caml_unix_lookup_file(fd, "out_channel_of_descr");
    file.check_stream_semantics("in_channel_of_descr");
    return caml_ml_open_descriptor_in(fd);
   }
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_unix_isatty(fd){
    if(fs_node_supported()){
     var tty = require("node:tty");
     return tty.isatty(caml_unix_lookup_file(fd).fd) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_unix_link(follow, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(! src_root.device.link)
     caml_failwith("caml_unix_link: not implemented");
    if(typeof follow !== "number")
     caml_raise_system_error(1, "ENOSYS", "link");
    if(src_root.device !== dst_root.device)
     caml_raise_system_error(1, "EXDEV", "link");
    return src_root.device.link(src_root.rest, dst_root.rest, true);
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_lseek(fd, len, whence){
    var file = caml_unix_lookup_file(fd, "lseek");
    return file.seek(len, whence, 1);
   }
   function caml_unix_lseek_64(fd, len, whence){
    var file = caml_unix_lookup_file(fd, "lseek");
    return file.seek(caml_int64_to_float(len), whence, 1);
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, false, true);
   }
   function caml_unix_lstat_64(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat)
     caml_failwith("caml_unix_lstat_64: not implemented");
    return root.device.lstat(root.rest, true, true);
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_unix_open(name, flags, perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.rdwr = 1; break;
       case 3:
        f.nonblock = 1; break;
       case 4:
        f.append = 1; break;
       case 5:
        f.create = 1; break;
       case 6:
        f.truncate = 1; break;
       case 7:
        f.excl = 1; break;
       case 8:
        f.noctty = 1; break;
       case 9:
        f.dsync = 1; break;
       case 10:
        f.sync = 1; break;
     }
     flags = flags[2];
    }
    var
     root = resolve_fs_device(name),
     file = root.device.open(root.rest, f, perms, true),
     idx = caml_sys_fds.length,
     chanid = new MlChanid(idx);
    caml_sys_fds[idx] = {file: file, chanid: chanid};
    return idx | 0;
   }
   function caml_unix_outchannel_of_filedescr(fd){
    var file = caml_unix_lookup_file(fd, "out_channel_of_descr");
    file.check_stream_semantics("out_channel_of_descr");
    return caml_ml_open_descriptor_out(fd);
   }
   function caml_unix_read(fd, buf, pos, len){
    var file = caml_unix_lookup_file(fd, "read");
    return file.read(caml_uint8_array_of_bytes(buf), pos, len, 1);
   }
   function caml_unix_read_bigarray(fd, buf, pos, len){
    var
     a = caml_ba_to_typed_array(buf),
     file = caml_unix_lookup_file(fd, "read");
    return file.read(a, pos, len, 1);
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_unix_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device !== n_root.device)
     caml_raise_system_error(1, "EXDEV", "rename");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest, true);
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_unix_single_write(fd, buf, pos, len){
    var file = caml_unix_lookup_file(fd, "write");
    if(len === 0) return 0;
    return file.write(caml_uint8_array_of_bytes(buf), pos, len, 1);
   }
   function caml_unix_startup(){}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, false, true);
   }
   function caml_unix_stat_64(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat)
     caml_failwith("caml_unix_stat_64: not implemented");
    return root.device.stat(root.rest, true, true);
   }
   function caml_unix_symlink(to_dir, src, dst){
    var dst_root = resolve_fs_device(dst);
    if(! dst_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return dst_root.device.symlink
            (to_dir, caml_jsstring_of_string(src), dst_root.rest, true);
   }
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_unix_times(){
    if(globalThis.process?.cpuUsage){
     var t = globalThis.process.cpuUsage();
     return [0, t.user / 1e6, t.system / 1e6, 0, 0];
    }
    else if(globalThis.performance?.now)
     return [0, globalThis.performance.now() / 1000, 0, 0, 0];
    else
     caml_failwith("caml_unix_times: not implemented");
   }
   function caml_unix_truncate(name, len){
    var root = resolve_fs_device(name);
    if(! root.device.truncate)
     caml_failwith("caml_unix_truncate: not implemented");
    root.device.truncate(root.rest, len, true);
    return 0;
   }
   function caml_unix_truncate_64(name, len){
    var root = resolve_fs_device(name);
    if(! root.device.truncate)
     caml_failwith("caml_unix_truncate_64: not implemented");
    root.device.truncate(root.rest, caml_int64_to_float(len), true);
    return 0;
   }
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    root.device.unlink(root.rest, true);
    return 0;
   }
   function caml_unix_utimes(name, atime, mtime){
    var root = resolve_fs_device(name);
    if(! root.device.utimes)
     caml_failwith("caml_unix_utimes: not implemented");
    root.device.utimes(root.rest, atime, mtime, true);
    return 0;
   }
   function caml_unix_write(fd, buf, pos, len){
    var
     file = caml_unix_lookup_file(fd, "write"),
     a = caml_uint8_array_of_bytes(buf),
     written = 0;
    while(len > 0){
     var n = file.write(a, pos, len, 1);
     written += n;
     pos += n;
     len -= n;
    }
    return written;
   }
   function caml_unix_write_bigarray(fd, buf, pos, len){
    var
     a = caml_ba_to_typed_array(buf),
     file = caml_unix_lookup_file(fd, "write"),
     written = 0;
    while(len > 0){
     var n = file.write(a, pos, len, 1);
     written += n;
     pos += n;
     len -= n;
    }
    return written;
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path === name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v === 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_wrap_exception(e){
    {
     if(Array.isArray(e)) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_xdg_defaults(_unit){return 0;}
   function caml_xmlhttprequest_create(_unit){
    if(typeof XMLHttpRequest === "undefined")
     caml_failwith("XMLHttpRequest is not available");
    try{return new XMLHttpRequest();}
    catch{caml_failwith("Failed to create XMLHttpRequest");}
   }
   function caml_zstd_initialize(_unit){
    caml_decompress_input = zstd_decompress;
    return 1;
   }
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   var
    core_array_unsafe_float_blit = caml_array_blit,
    core_array_unsafe_int_blit = caml_array_blit;
   function core_gc_compactions(){return 0;}
   function core_gc_heap_chunks(){return 0;}
   function core_gc_heap_words(){return 0;}
   function core_gc_major_collections(){return 0;}
   function core_gc_major_plus_minor_words(){return 0;}
   function core_gc_major_words(){return 0;}
   function core_gc_minor_collections(){return 0;}
   function core_gc_minor_words(){return 0;}
   function core_gc_promoted_words(){return 0;}
   function core_gc_run_memprof_callbacks(){return 0;}
   function core_gc_top_heap_words(){return 0;}
   function core_heap_block_is_heap_block(x){return + (x instanceof Array);}
   function core_md5_digest_subbigstring(buf, ofs, len, res){
    var bytes = caml_create_bytes(len);
    bigstring_blit_bigstring_bytes_stub(buf, ofs, bytes, 0, len);
    var res2 = caml_md5_string(caml_string_of_bytes(bytes), 0, len);
    caml_blit_string(res2, 0, res, 0, 16);
    return 0;
   }
   function core_md5_fd(fd){
    var ic = caml_ml_open_descriptor_in(fd);
    try{return caml_md5_chan(ic, - 1);}finally{caml_ml_close_channel(ic);}
   }
   function core_time_ns_format(time, format){
    var
     d = new Date(time * 1000),
     formatjs = caml_jsbytes_of_string(format),
     jstring = joo_global_object.strftime(formatjs, d);
    return caml_string_of_jsbytes(jstring);
   }
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in === 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow === 1 ? 0 : 1;
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000ffff);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xffff0000){b += 16; a >>>= 16;}
    if(a & 0xff00){b += 8; a >>>= 8;}
    if(a & 0xf0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits === 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits === 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000ffff)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in === 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow === 1 ? 0 : 1);
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 === 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d === 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] !== 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function initialize_nat(){
    caml_custom_ops._nat =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   var internalhash_fold_bigstring = caml_hash_mix_bigstring;
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function is_digit_normalized(_nat, _ofs){return 1;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] === 0) return 1;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.jsoo_fs_tmp) globalThis.jsoo_fs_tmp = [];
     globalThis.jsoo_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function length_nat(x){return x.data.length;}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function ms_float_to_ns_int64(ms){
    return caml_int64_of_float(ms * (1000.0 * 1000.0));
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   var ppx_expect_runtime_saved_stderr, ppx_expect_runtime_saved_stdout;
   function ppx_expect_runtime_after_test(vstdout, vstderr){
    caml_ml_channel_restore(vstdout, ppx_expect_runtime_saved_stdout);
    caml_ml_channel_restore(vstderr, ppx_expect_runtime_saved_stderr);
    return 0;
   }
   function ppx_expect_runtime_before_test(voutput, vstdout, vstderr){
    ppx_expect_runtime_saved_stderr =
     caml_ml_channel_redirect(vstderr, voutput);
    ppx_expect_runtime_saved_stdout =
     caml_ml_channel_redirect(vstdout, voutput);
    return 0;
   }
   function ppx_expect_runtime_flush_stubs_streams(vunit){return 0;}
   function ppx_expect_runtime_out_channel_position(chan){
    var info = caml_ml_channel_get(chan);
    return info.offset;
   }
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xff,
            0x03,
            0xfe,
            0xff,
            0xff,
            0x87,
            0xfe,
            0xff,
            0xff,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xff,
            0xff,
            0x7f,
            0xff,
            0xff,
            0xff,
            0x7f,
            0xff],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] !== 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] !== 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos === 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) !== is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] !== s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur !== "\\")
      res += cur;
     else{
      if(n === len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start === - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    var startchars = re[6] | 0;
    if(startchars >= 0){
     startchars = re[2][startchars + 1];
     var len = caml_ml_string_length(s);
     do{
      while
      (pos > 0 && pos < len
       && caml_string_get(startchars, caml_string_get(s, pos)) === 0)
       pos--;
      var res = re_match(re, s, pos, 0);
      if(res) return res;
      pos--;
     }
     while
      (pos >= 0);
    }
    else
     do{var res = re_match(re, s, pos, 0); if(res) return res; pos--;}
     while
      (pos >= 0);
    return [0];
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    var startchars = re[6] | 0, len = caml_ml_string_length(s);
    if(startchars >= 0){
     startchars = re[2][startchars + 1];
     do{
      while
      (pos < len && caml_string_get(startchars, caml_string_get(s, pos)) === 0)
       pos++;
      var res = re_match(re, s, pos, 0);
      if(res) return res;
      pos++;
     }
     while
      (pos <= len);
    }
    else
     do{var res = re_match(re, s, pos, 0); if(res) return res; pos++;}
     while
      (pos <= len);
    return [0];
   }
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function should_use_timezone_js_loader
   (yes, _platform_not_supported, disabled){
    return globalThis.DISABLE_TIMEZONE_JS_LOADER === undefined
            ? yes
            : disabled;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function time_now_nanosecond_counter_for_timing(){
    var
     ms_since_program_started = performance.now(),
     ns_since_program_started = ms_float_to_ns_int64(ms_since_program_started);
    return caml_int64_shift_left(ns_since_program_started, 1);
   }
   var ms_to_nano = caml_int64_of_int32(1000 * 1000);
   function time_now_nanoseconds_since_unix_epoch_or_zero(){
    var ms = Date.now(), ms_i63 = caml_int64_of_float(ms * 2);
    return caml_int64_mul(ms_i63, ms_to_nano);
   }
   function timezone_js_loader_compare_instants(a, b){
    return globalThis.TemporalPolyfill.Temporal.Instant.compare(a, b);
   }
   function timezone_js_loader_create_zone(zone_name){
    zone_name = caml_jsstring_of_string(zone_name);
    return new globalThis.TemporalPolyfill.Temporal.TimeZone(zone_name);
   }
   function timezone_js_loader_disable_for_testing(){globalThis.DISABLE_TIMEZONE_JS_LOADER = true;
   }
   function timezone_js_loader_enable_for_testing(){
    globalThis.DISABLE_TIMEZONE_JS_LOADER = undefined;
   }
   function timezone_js_loader_epoch_seconds(instant){return caml_int64_of_float(instant.epochSeconds);
   }
   function timezone_js_loader_from_epoch_seconds(seconds){
    return globalThis.TemporalPolyfill.Temporal.Instant.fromEpochSeconds
            (caml_int64_to_float(seconds));
   }
   function timezone_js_loader_get_next_transition_or_this_time_if_none
   (zone, instant){
    var ret = zone.getNextTransition(instant);
    return ret ? ret : instant;
   }
   function timezone_js_loader_get_offset_nanos_for(zone, instant){
    return caml_int64_of_float(zone.getOffsetNanosecondsFor(instant));
   }
   function timezone_js_loader_instant_plus_hours(instant, hours){
    hours = caml_int64_to_float(hours);
    var
     duration =
       globalThis.TemporalPolyfill.Temporal.Duration.from({hours: hours});
    return instant.add(duration);
   }
   function timezone_js_loader_now(){
    return globalThis.TemporalPolyfill.Temporal.Now.instant();
   }
   function unix_error_message(err){
    const errno = typeof err === "number" ? err : - err[1];
    return caml_string_of_jsstring(caml_strerror(errno));
   }
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process?.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {timezone_js_loader_get_offset_nanos_for:
     timezone_js_loader_get_offset_nanos_for,
     timezone_js_loader_instant_plus_hours:
     timezone_js_loader_instant_plus_hours,
     timezone_js_loader_now: timezone_js_loader_now,
     timezone_js_loader_epoch_seconds: timezone_js_loader_epoch_seconds,
     timezone_js_loader_compare_instants: timezone_js_loader_compare_instants,
     timezone_js_loader_from_epoch_seconds:
     timezone_js_loader_from_epoch_seconds,
     timezone_js_loader_get_next_transition_or_this_time_if_none:
     timezone_js_loader_get_next_transition_or_this_time_if_none,
     timezone_js_loader_create_zone: timezone_js_loader_create_zone,
     timezone_js_loader_enable_for_testing:
     timezone_js_loader_enable_for_testing,
     timezone_js_loader_disable_for_testing:
     timezone_js_loader_disable_for_testing,
     should_use_timezone_js_loader: should_use_timezone_js_loader,
     bigstring_realloc: bigstring_realloc,
     bigstring_destroy_stub: bigstring_destroy_stub,
     core_md5_digest_subbigstring: core_md5_digest_subbigstring,
     core_md5_fd: core_md5_fd,
     core_gc_run_memprof_callbacks: core_gc_run_memprof_callbacks,
     core_gc_top_heap_words: core_gc_top_heap_words,
     core_gc_promoted_words: core_gc_promoted_words,
     core_gc_minor_words: core_gc_minor_words,
     core_gc_minor_collections: core_gc_minor_collections,
     core_gc_major_words: core_gc_major_words,
     core_gc_major_plus_minor_words: core_gc_major_plus_minor_words,
     core_gc_major_collections: core_gc_major_collections,
     core_gc_heap_words: core_gc_heap_words,
     core_gc_heap_chunks: core_gc_heap_chunks,
     core_gc_compactions: core_gc_compactions,
     core_time_ns_format: core_time_ns_format,
     core_array_unsafe_float_blit: core_array_unsafe_float_blit,
     core_array_unsafe_int_blit: core_array_unsafe_int_blit,
     core_heap_block_is_heap_block: core_heap_block_is_heap_block,
     bigstring_memmem_bytecode: bigstring_memmem_bytecode,
     bigstring_find: bigstring_find,
     internalhash_fold_bigstring: internalhash_fold_bigstring,
     bigstring_memcmp_bytes_stub: bigstring_memcmp_bytes_stub,
     bigstring_memcmp_stub: bigstring_memcmp_stub,
     bigstring_memset_stub: bigstring_memset_stub,
     bigstring_blit_string_bigstring_stub:
     bigstring_blit_string_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub: bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_bytes_bigstring_stub: bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_stub: bigstring_blit_stub,
     bigstring_is_mmapped_stub: bigstring_is_mmapped_stub,
     bigstring_alloc_v2: bigstring_alloc_v2,
     ppx_expect_runtime_flush_stubs_streams:
     ppx_expect_runtime_flush_stubs_streams,
     ppx_expect_runtime_out_channel_position:
     ppx_expect_runtime_out_channel_position,
     ppx_expect_runtime_after_test: ppx_expect_runtime_after_test,
     ppx_expect_runtime_before_test: ppx_expect_runtime_before_test,
     ppx_expect_runtime_saved_stderr: ppx_expect_runtime_saved_stderr,
     ppx_expect_runtime_saved_stdout: ppx_expect_runtime_saved_stdout,
     time_now_nanosecond_counter_for_timing:
     time_now_nanosecond_counter_for_timing,
     ms_float_to_ns_int64: ms_float_to_ns_int64,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     bin_prot_blit_buf_stub: bin_prot_blit_buf_stub,
     bin_prot_blit_bytes_buf_stub: bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_string_buf_stub: bin_prot_blit_string_buf_stub,
     bin_prot_blit_float_array_buf_stub: bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_buf_bytes_stub: bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_buf_float_array_stub: bin_prot_blit_buf_float_array_stub,
     caml_check_bound_bigstring: caml_check_bound_bigstring,
     caml_dummy_obj_is_stack: caml_dummy_obj_is_stack,
     caml_make_local_vect: caml_make_local_vect,
     Base_unsafe_create_local_bytes: Base_unsafe_create_local_bytes,
     Base_am_testing: Base_am_testing,
     Base_hash_double: Base_hash_double,
     Base_hash_string: Base_hash_string,
     Base_int_math_int64_pow_stub: Base_int_math_int64_pow_stub,
     Base_int_math_int_pow_stub: Base_int_math_int_pow_stub,
     Base_int_math_int64_ctz: Base_int_math_int64_ctz,
     Base_int_math_nativeint_ctz: Base_int_math_nativeint_ctz,
     Base_int_math_int_ctz: Base_int_math_int_ctz,
     Base_int_math_int32_ctz: Base_int_math_int32_ctz,
     Base_int_math_int64_clz: Base_int_math_int64_clz,
     Base_int_math_nativeint_clz: Base_int_math_nativeint_clz,
     Base_int_math_int_clz: Base_int_math_int_clz,
     Base_int_math_int32_clz: Base_int_math_int32_clz,
     Base_caml_exn_is_most_recent_exn: Base_caml_exn_is_most_recent_exn,
     Base_clear_caml_backtrace_pos: Base_clear_caml_backtrace_pos,
     Base_int_math_int_popcount: Base_int_math_int_popcount,
     caml_sse2_float64_max_bytecode: caml_sse2_float64_max_bytecode,
     caml_sse2_float64_min_bytecode: caml_sse2_float64_min_bytecode,
     caml_csel_value: caml_csel_value,
     Base_internalhash_get_hash_value: Base_internalhash_get_hash_value,
     Base_internalhash_fold_string: Base_internalhash_fold_string,
     Base_internalhash_fold_float: Base_internalhash_fold_float,
     Base_internalhash_fold_int: Base_internalhash_fold_int,
     Base_internalhash_fold_int64: Base_internalhash_fold_int64,
     caml_blake2_string: caml_blake2_string,
     caml_blake2_update: caml_blake2_update,
     caml_blake2_final: caml_blake2_final,
     caml_blake2_create: caml_blake2_create,
     blake2b: blake2b,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_ml_runtime_events_resume: caml_ml_runtime_events_resume,
     caml_ml_runtime_events_are_active: caml_ml_runtime_events_are_active,
     caml_ml_runtime_events_pause: caml_ml_runtime_events_pause,
     caml_ml_runtime_events_start: caml_ml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_zstd_initialize: caml_zstd_initialize,
     caml_decompress_input: caml_decompress_input,
     zstd_decompress: zstd_decompress,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_lxm_daba: caml_lxm_daba,
     caml_lxm_M: caml_lxm_M,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_atomic_make_contended: caml_atomic_make_contended,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_compare_and_set: caml_domain_dls_compare_and_set,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data_opt: caml_ephe_set_data_opt,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_none: caml_ephe_none,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_raise_system_error: caml_raise_system_error,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwnam: caml_unix_getpwnam,
     caml_unix_getegid: caml_unix_getegid,
     caml_unix_getgid: caml_unix_getgid,
     caml_unix_geteuid: caml_unix_geteuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_outchannel_of_filedescr: caml_unix_outchannel_of_filedescr,
     caml_unix_inchannel_of_filedescr: caml_unix_inchannel_of_filedescr,
     caml_unix_close: caml_unix_close,
     caml_unix_ftruncate_64: caml_unix_ftruncate_64,
     caml_unix_ftruncate: caml_unix_ftruncate,
     caml_unix_lseek_64: caml_unix_lseek_64,
     caml_unix_lseek: caml_unix_lseek,
     caml_unix_read_bigarray: caml_unix_read_bigarray,
     caml_unix_read: caml_unix_read,
     caml_unix_write_bigarray: caml_unix_write_bigarray,
     caml_unix_single_write: caml_unix_single_write,
     caml_unix_write: caml_unix_write,
     caml_unix_fsync: caml_unix_fsync,
     caml_unix_fchmod: caml_unix_fchmod,
     caml_unix_fstat_64: caml_unix_fstat_64,
     caml_unix_fstat: caml_unix_fstat,
     caml_unix_lookup_file: caml_unix_lookup_file,
     caml_unix_open: caml_unix_open,
     caml_unix_access: caml_unix_access,
     caml_unix_truncate_64: caml_unix_truncate_64,
     caml_unix_truncate: caml_unix_truncate,
     caml_unix_utimes: caml_unix_utimes,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_link: caml_unix_link,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_rename: caml_unix_rename,
     caml_unix_chmod: caml_unix_chmod,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     caml_unix_chdir: caml_unix_chdir,
     unix_error_message: unix_error_message,
     caml_strerror: caml_strerror,
     make_unix_err_args: make_unix_err_args,
     unix_error: unix_error,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_times: caml_unix_times,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_io_buffer_size: caml_io_buffer_size,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_xdg_defaults: caml_xdg_defaults,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     jsoo_static_env: jsoo_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     jsoo_toplevel_reloc: jsoo_toplevel_reloc,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_custom_identifier: caml_custom_identifier,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_get_cached_method: caml_get_cached_method,
     caml_oo_cache_id: caml_oo_cache_id,
     caml_method_cache: caml_method_cache,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_tag: caml_obj_tag,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_normalized: is_digit_normalized,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_new_string: caml_new_string,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     jsoo_text_decoder_buff: jsoo_text_decoder_buff,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_string_concat: caml_string_concat,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_uint8_array: caml_bytes_of_uint8_array,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_uint8_array: caml_string_of_uint8_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     jsoo_text_decoder: jsoo_text_decoder,
     jsoo_text_encoder: jsoo_text_encoder,
     caml_bytes_set: caml_bytes_set,
     caml_bytes_set64: caml_bytes_set64,
     caml_bytes_set32: caml_bytes_set32,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_sub_uint8_array_to_jsbytes: caml_sub_uint8_array_to_jsbytes,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_float_of_bytes: caml_float_of_bytes,
     JsStringReader: JsStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_throw_js_exception: caml_throw_js_exception,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bigarray: caml_ml_output_bigarray,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input_bigarray: caml_ml_input_bigarray,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_is_binary_mode: caml_ml_is_binary_mode,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_out_with_flags:
     caml_ml_open_descriptor_out_with_flags,
     caml_ml_open_descriptor_in_with_flags:
     caml_ml_open_descriptor_in_with_flags,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channel_restore: caml_ml_channel_restore,
     caml_ml_channel_redirect: caml_ml_channel_redirect,
     caml_ml_channel_get: caml_ml_channel_get,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     MlChanid: MlChanid,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_dataview: jsoo_dataview,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_memprof_discard: caml_memprof_discard,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_raise_nodejs_error: caml_raise_nodejs_error,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     fs_node_stats_from_js: fs_node_stats_from_js,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_hash_mix_float32: caml_hash_mix_float32,
     caml_hash_mix_float16: caml_hash_mix_float16,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_packFloat16: caml_packFloat16,
     caml_unpackFloat16: caml_unpackFloat16,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_runtime_flag: caml_record_backtrace_runtime_flag,
     caml_record_backtrace_env_flag: caml_record_backtrace_env_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_array_make: caml_array_make,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLm1haW4uZW9ianMvanNvby9tYWluLmJjLnJ1bnRpbWUuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLm1haW4uZW9ianMvanNvby9tYWluLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2NvcmUvc3RyZnRpbWUuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvY29yZS90ZW1wb3JhbC1wb2x5ZmlsbC5qcyIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytpbnQ2NC5qcyIsIi9idWlsdGluLytpZWVlXzc1NC5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLyttbEJ5dGVzLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK3N5cy5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlL2Jhc2VfaW50ZXJuYWxoYXNoX3R5cGVzL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK3N5bmMuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZV9iaWdzdHJpbmcvcnVudGltZS5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvY29yZS9ydW50aW1lLmpzIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jpbl9wcm90L3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvYnVpbHRpbi8rYmxha2UyLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytlZmZlY3QuanMiLCIvYnVpbHRpbi8rZG9tYWluLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvb2NhbWxfaW50cmluc2ljc19rZXJuZWwvcnVudGltZS5qcyIsIi9idWlsdGluLytydW50aW1lX2V2ZW50cy5qcyIsIi9idWlsdGluLyt6c3RkLmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLytwcm5nLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvY29yZS9oZWFwX2Jsb2NrL3J1bnRpbWUuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvdGltZV9ub3cvcnVudGltZS5qcyIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvcnVudGltZS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvY29yZS90aW1lem9uZV9qc19sb2FkZXJfc3R1YnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIvL1xuLy8gc3RyZnRpbWVcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvc3RyZnRpbWVcbi8vIEBfc2pzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgLSAyMDE1IFNhbWkgU2FtaHVyaSA8c2FtaUBzYW1odXJpLm5ldD5cbi8vXG4vLyBNSVQgTGljZW5zZVxuLy8gaHR0cDovL3Nqcy5taXQtbGljZW5zZS5vcmdcbi8vXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgRGVmYXVsdExvY2FsZSA9IHtcbiAgICAgICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICAgICAgQU06ICdBTScsXG4gICAgICAgICAgICBQTTogJ1BNJyxcbiAgICAgICAgICAgIGFtOiAnYW0nLFxuICAgICAgICAgICAgcG06ICdwbScsXG4gICAgICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgICAgICBGOiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICAgICAgVDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgICAgICBYOiAnJVQnLFxuICAgICAgICAgICAgICAgIGM6ICclYSAlYiAlZCAlWCAlWScsXG4gICAgICAgICAgICAgICAgcjogJyVJOiVNOiVTICVwJyxcbiAgICAgICAgICAgICAgICB2OiAnJWUtJWItJVknLFxuICAgICAgICAgICAgICAgIHg6ICclRCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFN0cmZ0aW1lID0gbmV3IFN0cmZ0aW1lKERlZmF1bHRMb2NhbGUsIDAsIGZhbHNlKSxcbiAgICAgICAgaXNDb21tb25KUyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICBuYW1lc3BhY2U7XG5cbiAgICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gICAgaWYgKGlzQ29tbW9uSlMpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gbW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZTtcbiAgICAgICAgaWYoam9vX2dsb2JhbF9vYmplY3QpIGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cbiAgICAvLyBCcm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIG9iamVjdC4gV29ya3MgaW4gRVMzLCBFUzUsIGFuZCBFUzUgc3RyaWN0IG1vZGUuXG4gICAgICAgIG5hbWVzcGFjZSA9IGpvb19nbG9iYWxfb2JqZWN0IHx8IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKTsgfSgpKTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgQVBJLCB0byBiZSByZW1vdmVkIGluIHYxLjBcbiAgICB2YXIgX3JlcXVpcmUgPSBpc0NvbW1vbkpTID8gXCJyZXF1aXJlKCdzdHJmdGltZScpXCIgOiBcInN0cmZ0aW1lXCI7XG4gICAgdmFyIF9kZXByZWNhdGlvbldhcm5pbmdzID0ge307XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG5hbWUsIGluc3RlYWQpIHtcbiAgICAgICAgaWYgKCFfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gXCIgKyBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMS4wLiBJbnN0ZWFkLCB1c2UgYFwiICsgaW5zdGVhZCArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVUWiA9IGRlcHJlY2F0ZWRTdHJmdGltZVRaO1xuICAgIG5hbWVzcGFjZS5zdHJmdGltZVVUQyA9IGRlcHJlY2F0ZWRTdHJmdGltZVVUQztcbiAgICBuYW1lc3BhY2UubG9jYWxpemVkU3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQ7XG5cbiAgICAvLyBBZGFwdCB0aGUgb2xkIEFQSSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXcgQVBJLlxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9yd2FyZHMoZm4pIHtcbiAgICAgICAgZm4ubG9jYWxpemUgPSBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi50aW1lem9uZSA9IGRlZmF1bHRTdHJmdGltZS50aW1lem9uZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnV0YyA9IGRlZmF1bHRTdHJmdGltZS51dGMuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoYWRhcHRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBhZGFwdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgLy8gZCBhbmQgbG9jYWxlIGFyZSBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBsb2NhbGUpXG4gICAgICAgIGlmIChkICYmIGQuZGF5cykge1xuICAgICAgICAgICAgbG9jYWxlID0gZDtcbiAgICAgICAgICAgIGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGRlcHJlY2F0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0pYFwiLCBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVFooZm10LCBkLCBsb2NhbGUsIHRpbWV6b25lKSB7XG4gICAgICAgIC8vIGxvY2FsZSBpcyBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBkYXRlLCB0aW1lem9uZSlcbiAgICAgICAgaWYgKCh0eXBlb2YgbG9jYWxlID09ICdudW1iZXInIHx8IHR5cGVvZiBsb2NhbGUgPT0gJ3N0cmluZycpICYmIHRpbWV6b25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWV6b25lID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgdmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcy50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IChsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZSkudGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICB2YXIgdXRjU3RyZnRpbWUgPSBkZWZhdWx0U3RyZnRpbWUudXRjKCk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBkYXRlLCBsb2NhbGUpYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIFtkYXRlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IHV0Y1N0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiB1dGNTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkKGxvY2FsZSkge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplZFN0cmZ0aW1lKGxvY2FsZSlgXCIsIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKVwiKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZGVwcmVjYXRlZCBBUElcblxuICAgIC8vIFBvbHlmaWxsIERhdGUubm93IGZvciBvbGQgYnJvd3NlcnMuXG4gICAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJmdGltZShsb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNUaW1lem9uZSkge1xuICAgICAgICB2YXIgX2xvY2FsZSA9IGxvY2FsZSB8fCBEZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID0gY3VzdG9tVGltZXpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIF91c2VVdGNCYXNlZERhdGUgPSB1c2VVdGNUaW1lem9uZSB8fCBmYWxzZSxcblxuICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdW5peCB0aW1lc3RhbXAgdmFsdWUgaGVyZSB0byBub3QgY3JlYXRlIG5ldyBEYXRlKCkgZWFjaCBpdGVyYXRpb24gKGVhY2ggbWlsbGlzZWNvbmQpXG4gICAgICAgICAgICAvLyBEYXRlLm5vdygpIGlzIDIgdGltZXMgZmFzdGVyIHRoYW4gbmV3IERhdGUoKVxuICAgICAgICAgICAgLy8gd2hpbGUgbWlsbGlzZWNvbmQgcHJlY2lzZSBpcyBlbm91Z2ggaGVyZVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB2ZXJ5IGhlbHBmdWwgd2hlbiBzdHJmdGltZSB0cmlnZ2VyZWQgYSBsb3Qgb2YgdGltZXMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgX2NhY2hlZERhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0cmZ0aW1lKGZvcm1hdCwgZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZXN0YW1wID4gX2NhY2hlZERhdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSBjdXJyZW50VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wKTtcblxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfY2FjaGVkRGF0ZVRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIGRhdGUgaW5zdGFudGlhdGlvbiBmb3IgdXRjIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0aWVkIHRvIGdldFRpbWV6b25lT2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXAgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihfY2FjaGVkRGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBfY2FjaGVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgX2xvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyQ29kZSA9IGZvcm1hdC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY29wZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICdfJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA1OCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFRaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlcyBmb3IgbmV3IERhdGUoMCkgaW4gR01UXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHVyc2RheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW51YXJ5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxLzAxLzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ELCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwLTAxLTAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5GLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhNYXRoLmZsb29yKHRpbWVzdGFtcCAlIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1pbnV0ZXMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuYW0gOiBsb2NhbGUucG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuUiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0U2Vjb25kcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ULCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnc3VuZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ21vbmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE2OjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5YLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdHTVQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBcIkdNVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4bWUgb3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR6U3RyaW5nID0gZGF0ZS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gdHpTdHJpbmcgJiYgdHpTdHJpbmdbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnREYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuYywgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IE1hdGguY2VpbCgoZGF0ZS5nZXRUaW1lKCkgLSB5LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1vbnRoKCkgKyAxLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSArIG9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5BTSA6IGxvY2FsZS5QTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyOjAwOjAwIEFNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuciwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXkgPT09IDAgPyA3IDogZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxIC0gNywgTW9uZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEtSmFuLTE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy52LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMCAtIDYsIFN1bmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyLzMxLzY5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMueCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAoJycgKyBkYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnKzAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZXh0ZW5kZWRUWiA/IFwiKzAwOjAwXCIgOiBcIiswMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1c3RvbVRpbWV6b25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQgLyAoNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBvZmYgPCAwID8gJy0nIDogJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gZXh0ZW5kZWRUWiA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZiAvIDYwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5zID0gTWF0aC5hYnMob2ZmICUgNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gc2lnbiArIHBhZFRpbGwyKGhvdXJzKSArIHNlcCArIHBhZFRpbGwyKG1pbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAzNykge1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gX3N0cmZ0aW1lO1xuXG4gICAgICAgIHN0cmZ0aW1lLmxvY2FsaXplID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKGxvY2FsZSB8fCBfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIF91c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21UaW1lem9uZU9mZnNldCA9IF9jdXN0b21UaW1lem9uZU9mZnNldDtcbiAgICAgICAgICAgIHZhciB1c2VVdGNCYXNlZERhdGUgPSBfdXNlVXRjQmFzZWREYXRlO1xuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVUeXBlID0gdHlwZW9mIHRpbWV6b25lO1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicgfHwgdGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVzZVV0Y0Jhc2VkRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJU08gODYwMSBmb3JtYXQgdGltZXpvbmUgc3RyaW5nLCBbLStdSEhNTVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGltZXpvbmVbMF0gPT09ICctJyA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMSwgMyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgzLCA1KSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gc2lnbiAqICgoNjAgKiBob3VycykgKyBtaW51dGVzKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWludXRlczogNDIwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwyKG51bWJlclRvUGFkLCBwYWRkaW5nQ2hhcikge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT09ICcnIHx8IG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nQ2hhciA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0NoYXIgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMyhudW1iZXJUb1BhZCkge1xuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCcgKyBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzAwJyArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvdXJzMTIoaG91cikge1xuICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgLSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdFdlZWtkYXk6ICdzdW5kYXknIG9yICdtb25kYXknLCBkZWZhdWx0IGlzICdzdW5kYXknXG4gICAgLy9cbiAgICAvLyBQaWxmZXJlZCAmIHBvcnRlZCBmcm9tIFJ1YnkncyBzdHJmdGltZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmdW5jdGlvbiB3ZWVrTnVtYmVyKGRhdGUsIGZpcnN0V2Vla2RheSkge1xuICAgICAgICBmaXJzdFdlZWtkYXkgPSBmaXJzdFdlZWtkYXkgfHwgJ3N1bmRheSc7XG5cbiAgICAgICAgLy8gVGhpcyB3b3JrcyBieSBzaGlmdGluZyB0aGUgd2Vla2RheSBiYWNrIGJ5IG9uZSBkYXkgaWYgd2VcbiAgICAgICAgLy8gYXJlIHRyZWF0aW5nIE1vbmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChmaXJzdFdlZWtkYXkgPT09ICdtb25kYXknKSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA9PT0gMCkgLy8gU3VuZGF5XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IDY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2Vla2RheS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZZZWFyVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICAgIGRhdGVVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLFxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoKGRhdGVVdGMgLSBmaXJzdERheU9mWWVhclV0YykgLyA4NjQwMDAwMCksXG4gICAgICAgICAgICB3ZWVrTnVtID0gKHlkYXkgKyA3IC0gd2Vla2RheSkgLyA3O1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHdlZWtOdW0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgb3JkaW5hbCBzdWZmaXggZm9yIGEgbnVtYmVyOiBzdCwgbmQsIHJkLCBvciB0aFxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHZhciBpID0gbnVtYmVyICUgMTA7XG4gICAgICAgIHZhciBpaSA9IG51bWJlciAlIDEwMDtcblxuICAgICAgICBpZiAoKGlpID49IDExICYmIGlpIDw9IDEzKSB8fCBpID09PSAwIHx8IGkgPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiAnc3QnO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICdyZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIHx8IDApICogNjAwMDA7XG4gICAgfVxuXG59KCkpO1xuIiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghaXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCA9IGl0LmNhbGwobyk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgdCA9IHt9O1xuZnVuY3Rpb24gTWFrZUludHJpbnNpY0NsYXNzKGUsIHQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogdCxcbiAgICB3cml0YWJsZTogITEsXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF90ID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgX3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIF90KTtcbiAgICAgIF9yLmNvbmZpZ3VyYWJsZSAmJiBfci5lbnVtZXJhYmxlICYmIChfci5lbnVtZXJhYmxlID0gITEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdCwgX3IpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUucHJvdG90eXBlKSksXG4gICAgX3N0ZXAyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3QyID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgdmFyIF9yMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZS5wcm90b3R5cGUsIF90Mik7XG4gICAgICBfcjIuY29uZmlndXJhYmxlICYmIF9yMi5lbnVtZXJhYmxlICYmIChfcjIuZW51bWVyYWJsZSA9ICExLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsIF90MiwgX3IyKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuICBEZWZpbmVJbnRyaW5zaWModCwgZSksIERlZmluZUludHJpbnNpYyhcIlwiLmNvbmNhdCh0LCBcIi5wcm90b3R5cGVcIiksIGUucHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIERlZmluZUludHJpbnNpYyhlLCByKSB7XG4gIHZhciBvID0gXCIlXCIuY29uY2F0KGUsIFwiJVwiKTtcbiAgaWYgKHZvaWQgMCAhPT0gdFtvXSkgdGhyb3cgbmV3IEVycm9yKFwiaW50cmluc2ljIFwiLmNvbmNhdChlLCBcIiBhbHJlYWR5IGV4aXN0c1wiKSk7XG4gIHRbb10gPSByO1xufVxuZnVuY3Rpb24gR2V0SW50cmluc2ljKGUpIHtcbiAgcmV0dXJuIHRbZV07XG59XG52YXIgciwgbztcbnZhciBuID0gXCJzbG90LWVwb2NoTmFub1NlY29uZHNcIixcbiAgYSA9IFwic2xvdC10aW1lem9uZS1pZGVudGlmaWVyXCIsXG4gIGkgPSBcInNsb3QteWVhclwiLFxuICBzID0gXCJzbG90LW1vbnRoXCIsXG4gIGwgPSBcInNsb3QtZGF5XCIsXG4gIGQgPSBcInNsb3QtaG91clwiLFxuICBtID0gXCJzbG90LW1pbnV0ZVwiLFxuICBjID0gXCJzbG90LXNlY29uZFwiLFxuICBoID0gXCJzbG90LW1pbGxpc2Vjb25kXCIsXG4gIHUgPSBcInNsb3QtbWljcm9zZWNvbmRcIixcbiAgVCA9IFwic2xvdC1uYW5vc2Vjb25kXCIsXG4gIHAgPSBcInNsb3QtY2FsZW5kYXJcIixcbiAgZiA9IFwic2xvdC1kYXRlLWJyYW5kXCIsXG4gIHkgPSBcInNsb3QteWVhci1tb250aC1icmFuZFwiLFxuICBJID0gXCJzbG90LW1vbnRoLWRheS1icmFuZFwiLFxuICBTID0gXCJzbG90LWNhY2hlZC1pbnN0YW50XCIsXG4gIGcgPSBcInNsb3QtdGltZS16b25lXCIsXG4gIHcgPSBcInNsb3QteWVhcnNcIixcbiAgRCA9IFwic2xvdC1tb250aHNcIixcbiAgRyA9IFwic2xvdC13ZWVrc1wiLFxuICB2ID0gXCJzbG90LWRheXNcIixcbiAgQyA9IFwic2xvdC1ob3Vyc1wiLFxuICBPID0gXCJzbG90LW1pbnV0ZXNcIixcbiAgYiA9IFwic2xvdC1zZWNvbmRzXCIsXG4gIEUgPSBcInNsb3QtbWlsbGlzZWNvbmRzXCIsXG4gIE0gPSBcInNsb3QtbWljcm9zZWNvbmRzXCIsXG4gIFIgPSBcInNsb3QtbmFub3NlY29uZHNcIixcbiAgRiA9IFwic2xvdC1jYWxlbmRhci1pZGVudGlmaWVyXCIsXG4gIFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIFAgPSBTeW1ib2xbXCJmb3JcIl0oXCJAQFRlbXBvcmFsX19HZXRTbG90c1wiKTtcbihyID0gZ2xvYmFsVGhpcylbUF0gfHwgKHJbUF0gPSBmdW5jdGlvbiBfR2V0U2xvdHMoZSkge1xuICByZXR1cm4gWS5nZXQoZSk7XG59KTtcbnZhciBaID0gZ2xvYmFsVGhpc1tQXTtcbnZhciBCID0gU3ltYm9sW1wiZm9yXCJdKFwiQEBUZW1wb3JhbF9fQ3JlYXRlU2xvdHNcIik7XG4obyA9IGdsb2JhbFRoaXMpW0JdIHx8IChvW0JdID0gZnVuY3Rpb24gX0NyZWF0ZVNsb3RzKGUpIHtcbiAgWS5zZXQoZSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59KTtcbnZhciBOID0gZ2xvYmFsVGhpc1tCXTtcbmZ1bmN0aW9uIEhhc1Nsb3QoZSkge1xuICBpZiAoIWUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpKSByZXR1cm4gITE7XG4gIHZhciByID0gWihlKTtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiAhIXIgJiYgdC5ldmVyeShmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlIGluIHI7XG4gIH0pO1xufVxuZnVuY3Rpb24gR2V0U2xvdChlLCB0KSB7XG4gIHZhciBfWjtcbiAgdmFyIHIgPSAoX1ogPSBaKGUpKSA9PT0gbnVsbCB8fCBfWiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX1pbdF07XG4gIGlmICh2b2lkIDAgPT09IHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIGludGVybmFsIHNsb3QgXCIuY29uY2F0KHQpKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBTZXRTbG90KGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBaKGUpO1xuICBpZiAodm9pZCAwID09PSBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBzbG90cyBmb3IgdGhlIGdpdmVuIGNvbnRhaW5lclwiKTtcbiAgaWYgKG9bdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQodCwgXCIgYWxyZWFkeSBoYXMgc2V0XCIpKTtcbiAgb1t0XSA9IHI7XG59XG52YXIgaiA9IC9cXC5bLUEtWmEtel9dfFxcLlxcLlstQS1aYS16Ll9dezEsMTJ9fFxcLlstQS1aYS16X11bLUEtWmEtei5fXXswLDEyfXxbQS1aYS16X11bLUEtWmEtei5fXXswLDEzfS8sXG4gICQgPSBuZXcgUmVnRXhwKFwiKD86XCIgKyBbXCIoPzpcIi5jb25jYXQoai5zb3VyY2UsIFwiKSg/OlxcXFwvKD86XCIpLmNvbmNhdChqLnNvdXJjZSwgXCIpKSpcIiksIFwiRXRjL0dNVCg/OjB8Wy0rXVxcXFxkezEsMn0pXCIsIFwiR01UWy0rXT8wXCIsIFwiRVNUNUVEVFwiLCBcIkNTVDZDRFRcIiwgXCJNU1Q3TURUXCIsIFwiUFNUOFBEVFwiLCAvKD86WytcXHUyMjEyLV1bMC0yXVswLTldKD86Oj9bMC01XVswLTldKD86Oj9bMC01XVswLTldKD86Wy4sXVxcZHsxLDl9KT8pPyk/KS8uc291cmNlXS5qb2luKFwifFwiKSArIFwiKVwiKSxcbiAgayA9IC8oPzpbK1xcdTIyMTItXVxcZHs2fXxcXGR7NH0pLyxcbiAgVSA9IC8oPzowWzEtOV18MVswLTJdKS8sXG4gIEEgPSAvKD86MFsxLTldfFsxMl1cXGR8M1swMV0pLyxcbiAgTCA9IG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGsuc291cmNlLCBcIikoPzotKFwiKS5jb25jYXQoVS5zb3VyY2UsIFwiKS0oXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpfChcIikuY29uY2F0KFUuc291cmNlLCBcIikoXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpKVwiKSksXG4gIHggPSAvKFxcZHsyfSkoPzo6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpbLixdKFxcZHsxLDl9KSk/KT98KFxcZHsyfSkoPzooXFxkezJ9KSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LyxcbiAgVyA9IC8oWytcXHUyMjEyLV0pKFswMV1bMC05XXwyWzAtM10pKD86Oj8oWzAtNV1bMC05XSkoPzo6PyhbMC01XVswLTldKSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LyxcbiAgcSA9IG5ldyBSZWdFeHAoXCIoW3paXSl8XCIuY29uY2F0KFcuc291cmNlLCBcIj9cIikpLFxuICBIID0gL1xcWyghKT8oW2Etel9dW2EtejAtOV8tXSopPShbQS1aYS16MC05XSsoPzotW0EtWmEtejAtOV0rKSopXFxdL2csXG4gIFYgPSBuZXcgUmVnRXhwKFtcIl5cIi5jb25jYXQoTC5zb3VyY2UpLCBcIig/Oig/OlR8XFxcXHMrKVwiLmNvbmNhdCh4LnNvdXJjZSwgXCIoPzpcIikuY29uY2F0KHEuc291cmNlLCBcIik/KT9cIiksIFwiKD86XFxcXFshPyhcIi5jb25jYXQoJC5zb3VyY2UsIFwiKVxcXFxdKT9cIiksIFwiKCg/OlwiLmNvbmNhdChILnNvdXJjZSwgXCIpKikkXCIpXS5qb2luKFwiXCIpLCBcImlcIiksXG4gIHogPSBuZXcgUmVnRXhwKFtcIl5UP1wiLmNvbmNhdCh4LnNvdXJjZSksIFwiKD86XCIuY29uY2F0KHEuc291cmNlLCBcIik/XCIpLCBcIig/OlxcXFxbIT9cIi5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pP1wiKSwgXCIoKD86XCIuY29uY2F0KEguc291cmNlLCBcIikqKSRcIildLmpvaW4oXCJcIiksIFwiaVwiKSxcbiAgXyA9IG5ldyBSZWdFeHAoXCJeKFwiLmNvbmNhdChrLnNvdXJjZSwgXCIpLT8oXCIpLmNvbmNhdChVLnNvdXJjZSwgXCIpKD86XFxcXFshP1wiKS5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pPygoPzpcIikuY29uY2F0KEguc291cmNlLCBcIikqKSRcIikpLFxuICBKID0gbmV3IFJlZ0V4cChcIl4oPzotLSk/KFwiLmNvbmNhdChVLnNvdXJjZSwgXCIpLT8oXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpKD86XFxcXFshP1wiKS5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pPygoPzpcIikuY29uY2F0KEguc291cmNlLCBcIikqKSRcIikpLFxuICBLID0gLyhcXGQrKSg/OlsuLF0oXFxkezEsOX0pKT8vLFxuICBYID0gbmV3IFJlZ0V4cChcIig/OlwiLmNvbmNhdChLLnNvdXJjZSwgXCJIKT8oPzpcIikuY29uY2F0KEsuc291cmNlLCBcIk0pPyg/OlwiKS5jb25jYXQoSy5zb3VyY2UsIFwiUyk/XCIpKSxcbiAgUSA9IG5ldyBSZWdFeHAoXCJeKFsrXFx1MjIxMi1dKT9QXCIuY29uY2F0KC8oPzooXFxkKylZKT8oPzooXFxkKylNKT8oPzooXFxkKylXKT8oPzooXFxkKylEKT8vLnNvdXJjZSwgXCIoPzpUKD8hJClcIikuY29uY2F0KFguc291cmNlLCBcIik/JFwiKSwgXCJpXCIpLFxuICBlZSA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcyxcbiAgdGUgPSBBcnJheS5wcm90b3R5cGUucHVzaCxcbiAgcmUgPSBnbG9iYWxUaGlzLkludGwuRGF0ZVRpbWVGb3JtYXQsXG4gIG9lID0gTWF0aC5taW4sXG4gIG5lID0gTWF0aC5tYXgsXG4gIGFlID0gTWF0aC5hYnMsXG4gIGllID0gTWF0aC5mbG9vcixcbiAgc2UgPSBNYXRoLnNpZ24sXG4gIGxlID0gTWF0aC50cnVuYyxcbiAgZGUgPSBOdW1iZXIuaXNOYU4sXG4gIG1lID0gTnVtYmVyLmlzRmluaXRlLFxuICBjZSA9IE51bWJlcixcbiAgaGUgPSBTdHJpbmcsXG4gIHVlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIFRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgcGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBmZSA9IFJlZmxlY3QuYXBwbHksXG4gIHllID0gUmVmbGVjdC5vd25LZXlzLFxuICBJZSA9IDBuLFxuICBTZSA9IDFuLFxuICBnZSA9IDYwbixcbiAgd2UgPSAyNG4sXG4gIERlID0gMTAwMG4sXG4gIEdlID0gMTAwMDAwMG4sXG4gIHZlID0gMTAwMDAwMDAwMG4sXG4gIENlID0gQmlnSW50KC0xKSxcbiAgT2UgPSAzNjAwbiAqIHZlLFxuICBiZSA9IGdlICogdmUsXG4gIEVlID0gT2UgKiB3ZSxcbiAgTWUgPSBCaWdJbnQoLTg2NDAwKSAqIDEwMDAwMDAwMDAwMDAwMDAwMG4sXG4gIFJlID0gODY0MDBuICogMTAwMDAwMDAwMDAwMDAwMDAwbixcbiAgRmUgPSAtMjcxODIxLFxuICBZZSA9IDI3NTc2MCxcbiAgUGUgPSBCaWdJbnQoLTM4ODE1MikgKiAxMDAwMDAwMDAwMDAwMG4sXG4gIFplID0gRWUgKiAzNjYwbixcbiAgQmUgPSBFZSAqIDM2Nm4sXG4gIE5lID0gRWUgKiAxNG4sXG4gIGplID0gW1wiaXNvODYwMVwiLCBcImhlYnJld1wiLCBcImlzbGFtaWNcIiwgXCJpc2xhbWljLXVtYWxxdXJhXCIsIFwiaXNsYW1pYy10YmxhXCIsIFwiaXNsYW1pYy1jaXZpbFwiLCBcImlzbGFtaWMtcmdzYVwiLCBcImlzbGFtaWNjXCIsIFwicGVyc2lhblwiLCBcImV0aGlvcGljXCIsIFwiZXRoaW9hYVwiLCBcImNvcHRpY1wiLCBcImNoaW5lc2VcIiwgXCJkYW5naVwiLCBcInJvY1wiLCBcImluZGlhblwiLCBcImJ1ZGRoaXN0XCIsIFwiamFwYW5lc2VcIiwgXCJncmVnb3J5XCJdO1xuZnVuY3Rpb24gaXNaZXJvKHQpIHtcbiAgcmV0dXJuIHQgPT09IEllO1xufVxuZnVuY3Rpb24gR2V0TWV0aG9kKGUsIHQpIHtcbiAgdmFyIHIgPSBlW3RdO1xuICBpZiAodm9pZCAwICE9PSByKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGwoZSwgdCwgcikge1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gciA6IFtdO1xuICByZXR1cm4gZmUoZSwgdCwgbyk7XG59XG5mdW5jdGlvbiBJc09iamVjdChlKSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09IF90eXBlb2YoZSkgJiYgbnVsbCAhPT0gZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGU7XG59XG5mdW5jdGlvbiBUb051bWJlcihlKSB7XG4gIGlmIChcImJpZ2ludFwiID09IHR5cGVvZiBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgQmlnSW50IHRvIG51bWJlclwiKTtcbiAgcmV0dXJuIGNlKGUpO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyT3JJbmZpbml0eShlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmIChkZSh0KSB8fCAwID09PSB0KSByZXR1cm4gMDtcbiAgaWYgKCFtZSh0KSkgcmV0dXJuIHQ7XG4gIHZhciByID0gaWUoYWUodCkpO1xuICByZXR1cm4gMCA9PT0gciA/IDAgOiBzZSh0KSAqIHI7XG59XG5mdW5jdGlvbiBJc0ludGVncmFsTnVtYmVyKGUpIHtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgfHwgZGUoZSkgfHwgIW1lKGUpKSByZXR1cm4gITE7XG4gIHZhciB0ID0gYWUoZSk7XG4gIHJldHVybiBpZSh0KSA9PT0gdDtcbn1cbmZ1bmN0aW9uIFRvU3RyaW5nKGUpIHtcbiAgaWYgKFwic3ltYm9sXCIgPT0gX3R5cGVvZihlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgU3RyaW5nXCIpO1xuICByZXR1cm4gaGUoZSk7XG59XG5mdW5jdGlvbiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmICgwID09PSB0KSByZXR1cm4gMDtcbiAgaWYgKGRlKHQpIHx8ICFtZSh0KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIG51bWJlciB2YWx1ZVwiKTtcbiAgdmFyIHIgPSBsZSh0KTtcbiAgcmV0dXJuIDAgPT09IHIgPyAwIDogcjtcbn1cbmZ1bmN0aW9uIFRvUG9zaXRpdmVJbnRlZ2VyV2l0aFRydW5jYXRpb24oZSwgdCkge1xuICB2YXIgciA9IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpO1xuICBpZiAociA8PSAwKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0eSAnXCIuY29uY2F0KHQsIFwiJyBjYW5ub3QgYmUgYSBhIG51bWJlciBsZXNzIHRoYW4gb25lXCIpKTtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgbnVtYmVyIGxlc3MgdGhhbiBvbmUgdG8gYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VySWZJbnRlZ3JhbChlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmICghbWUodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwidW5zdXBwb3J0ZWQgZnJhY3Rpb25hbCB2YWx1ZSBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gMCA9PT0gdCA/IDAgOiB0O1xufVxuZnVuY3Rpb24gZGl2bW9kKHQsIHIpIHtcbiAgcmV0dXJuIHtcbiAgICBxdW90aWVudDogdCAvIHIsXG4gICAgcmVtYWluZGVyOiB0ICUgclxuICB9O1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZUpTQkkodCkge1xuICByZXR1cm4gdCA8IEllO1xufVxuZnVuY3Rpb24gc2lnbkpTQkkoZSkge1xuICByZXR1cm4gaXNaZXJvKGUpID8gMCA6IGlzTmVnYXRpdmVKU0JJKGUpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gYWJzKHQpIHtcbiAgcmV0dXJuIHQgPCBJZSA/IHQgKiBDZSA6IHQ7XG59XG52YXIgJGUgPSBuZXcgTWFwKFtbXCJ5ZWFyXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wibW9udGhcIiwgVG9Qb3NpdGl2ZUludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1vbnRoQ29kZVwiLCBUb1N0cmluZ10sIFtcImRheVwiLCBUb1Bvc2l0aXZlSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wiaG91clwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1pbnV0ZVwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcInNlY29uZFwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1pbGxpc2Vjb25kXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wibWljcm9zZWNvbmRcIiwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb25dLCBbXCJuYW5vc2Vjb25kXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wieWVhcnNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcIm1vbnRoc1wiLCBUb0ludGVnZXJJZkludGVncmFsXSwgW1wid2Vla3NcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImRheXNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImhvdXJzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJtaW51dGVzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJzZWNvbmRzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJtaWxsaXNlY29uZHNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcIm1pY3Jvc2Vjb25kc1wiLCBUb0ludGVnZXJJZkludGVncmFsXSwgW1wibmFub3NlY29uZHNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImVyYVwiLCBUb1N0cmluZ10sIFtcImVyYVllYXJcIiwgVG9JbnRlZ2VyT3JJbmZpbml0eV0sIFtcIm9mZnNldFwiLCBUb1N0cmluZ11dKSxcbiAga2UgPSBuZXcgTWFwKFtbXCJob3VyXCIsIDBdLCBbXCJtaW51dGVcIiwgMF0sIFtcInNlY29uZFwiLCAwXSwgW1wibWlsbGlzZWNvbmRcIiwgMF0sIFtcIm1pY3Jvc2Vjb25kXCIsIDBdLCBbXCJuYW5vc2Vjb25kXCIsIDBdXSksXG4gIFVlID0gW1tcInllYXJzXCIsIFwieWVhclwiLCBcImRhdGVcIl0sIFtcIm1vbnRoc1wiLCBcIm1vbnRoXCIsIFwiZGF0ZVwiXSwgW1wid2Vla3NcIiwgXCJ3ZWVrXCIsIFwiZGF0ZVwiXSwgW1wiZGF5c1wiLCBcImRheVwiLCBcImRhdGVcIl0sIFtcImhvdXJzXCIsIFwiaG91clwiLCBcInRpbWVcIl0sIFtcIm1pbnV0ZXNcIiwgXCJtaW51dGVcIiwgXCJ0aW1lXCJdLCBbXCJzZWNvbmRzXCIsIFwic2Vjb25kXCIsIFwidGltZVwiXSwgW1wibWlsbGlzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJ0aW1lXCJdLCBbXCJtaWNyb3NlY29uZHNcIiwgXCJtaWNyb3NlY29uZFwiLCBcInRpbWVcIl0sIFtcIm5hbm9zZWNvbmRzXCIsIFwibmFub3NlY29uZFwiLCBcInRpbWVcIl1dLFxuICBBZSA9IG5ldyBNYXAoVWUubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIFtlWzBdLCBlWzFdXTtcbiAgfSkpLFxuICBMZSA9IG5ldyBNYXAoVWUubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICBlID0gX3JlZjJbMF0sXG4gICAgICB0ID0gX3JlZjJbMV07XG4gICAgcmV0dXJuIFt0LCBlXTtcbiAgfSkpLFxuICB4ZSA9IFVlLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBlID0gX3JlZjRbMV07XG4gICAgcmV0dXJuIGU7XG4gIH0pLFxuICBXZSA9IEFycmF5LmZyb20oQWUua2V5cygpKS5zb3J0KCksXG4gIHFlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0SW50bERhdGVUaW1lRm9ybWF0RW5Vc0ZvclRpbWVab25lKGUpIHtcbiAgdmFyIHQgPSBxZS5nZXQoZSk7XG4gIHJldHVybiB2b2lkIDAgPT09IHQgJiYgKHQgPSBuZXcgcmUoXCJlbi11c1wiLCB7XG4gICAgdGltZVpvbmU6IGhlKGUpLFxuICAgIGhvdXIxMjogITEsXG4gICAgZXJhOiBcInNob3J0XCIsXG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICBzZWNvbmQ6IFwibnVtZXJpY1wiXG4gIH0pLCBxZS5zZXQoZSwgdCkpLCB0O1xufVxuZnVuY3Rpb24gVG9PYmplY3QoZSkge1xuICBpZiAobnVsbCA9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgb2JqZWN0IG5vdCBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gT2JqZWN0KGUpO1xufVxuZnVuY3Rpb24gQ29weURhdGFQcm9wZXJ0aWVzKGUsIHQsIHIsIG8pIHtcbiAgaWYgKG51bGwgPT0gdCkgcmV0dXJuO1xuICB2YXIgbiA9IHllKHQpO1xuICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG4pLFxuICAgIF9zdGVwMztcbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBhID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgaWYgKCFyLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5pcyhlLCBhKTtcbiAgICAgIH0pICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0LCBhKSkge1xuICAgICAgICB2YXIgX3IzID0gdFthXTtcbiAgICAgICAgaWYgKG8gJiYgby5zb21lKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5pcyhlLCBfcjMpO1xuICAgICAgICB9KSkgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgICAgIGVbYV0gPSBfcjM7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMy5mKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxJbnN0YW50KGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgbikgJiYgIUhhc1Nsb3QoZSwgZywgcCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsVGltZVpvbmUoZSkge1xuICByZXR1cm4gSGFzU2xvdChlLCBhKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxDYWxlbmRhcihlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIEYpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbER1cmF0aW9uKGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgdywgRCwgdiwgQywgTywgYiwgRSwgTSwgUik7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsRGF0ZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIGYpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFRpbWUoZSkge1xuICByZXR1cm4gSGFzU2xvdChlLCBkLCBtLCBjLCBoLCB1LCBUKSAmJiAhSGFzU2xvdChlLCBpLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEYXRlVGltZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFllYXJNb250aChlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIHkpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbE1vbnRoRGF5KGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgSSk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIG4sIGcsIHApO1xufVxuZnVuY3Rpb24gUmVqZWN0VGVtcG9yYWxMaWtlT2JqZWN0KGUpIHtcbiAgaWYgKEhhc1Nsb3QoZSwgcCkgfHwgSGFzU2xvdChlLCBnKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIndpdGgoKSBkb2VzIG5vdCBzdXBwb3J0IGEgY2FsZW5kYXIgb3IgdGltZVpvbmUgcHJvcGVydHlcIik7XG4gIGlmIChJc1RlbXBvcmFsVGltZShlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIndpdGgoKSBkb2VzIG5vdCBhY2NlcHQgVGVtcG9yYWwuUGxhaW5UaW1lLCB1c2Ugd2l0aFBsYWluVGltZSgpIGluc3RlYWRcIik7XG4gIGlmICh2b2lkIDAgIT09IGUuY2FsZW5kYXIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ3aXRoKCkgZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGVuZGFyIHByb3BlcnR5XCIpO1xuICBpZiAodm9pZCAwICE9PSBlLnRpbWVab25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwid2l0aCgpIGRvZXMgbm90IHN1cHBvcnQgYSB0aW1lWm9uZSBwcm9wZXJ0eVwiKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxUaW1lWm9uZShlKSB7XG4gIHZhciBfUGFyc2VUZW1wb3JhbFRpbWVab24gPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVpvbmVTdHJpbmcoZSkge1xuICAgICAgaWYgKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KCQuc291cmNlLCBcIiRcIiksIFwiaVwiKS50ZXN0KGUpKSByZXR1cm4ge1xuICAgICAgICBpYW5hTmFtZTogZVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfdDMgPSBQYXJzZUlTT0RhdGVUaW1lKGUpO1xuICAgICAgICBpZiAoX3QzLnogfHwgX3QzLm9mZnNldCB8fCBfdDMuaWFuYU5hbWUpIHJldHVybiBfdDM7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgem9uZTogXCIuY29uY2F0KGUpKTtcbiAgICB9KGUpLFxuICAgIHQgPSBfUGFyc2VUZW1wb3JhbFRpbWVab24uaWFuYU5hbWUsXG4gICAgciA9IF9QYXJzZVRlbXBvcmFsVGltZVpvbi5vZmZzZXQsXG4gICAgbyA9IF9QYXJzZVRlbXBvcmFsVGltZVpvbi56O1xuICBpZiAodCkgcmV0dXJuIEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih0KTtcbiAgaWYgKG8pIHJldHVybiBcIlVUQ1wiO1xuICByZXR1cm4gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhyKSk7XG59XG5mdW5jdGlvbiBNYXliZUZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihlLCB0KSB7XG4gIHJldHVybiBcIm5ldmVyXCIgPT09IHQgPyBcIlwiIDogRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoZSksIHQpO1xufVxuZnVuY3Rpb24gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGUsIHQpIHtcbiAgaWYgKFwibmV2ZXJcIiA9PT0gdCkgcmV0dXJuIFwiXCI7XG4gIGlmIChcImF1dG9cIiA9PT0gdCAmJiBcImlzbzg2MDFcIiA9PT0gZSkgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBcIltcIi5jb25jYXQoXCJjcml0aWNhbFwiID09PSB0ID8gXCIhXCIgOiBcIlwiLCBcInUtY2E9XCIpLmNvbmNhdChlLCBcIl1cIik7XG59XG5mdW5jdGlvbiBQYXJzZUlTT0RhdGVUaW1lKGUpIHtcbiAgdmFyIHQgPSBWLmV4ZWMoZSk7XG4gIGlmICghdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgdmFyIHIgPSB0WzFdO1xuICBpZiAoXCLiiJJcIiA9PT0gclswXSAmJiAociA9IFwiLVwiLmNvbmNhdChyLnNsaWNlKDEpKSksIFwiLTAwMDAwMFwiID09PSByKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiBcIi5jb25jYXQoZSkpO1xuICB2YXIgbyA9IFRvSW50ZWdlck9ySW5maW5pdHkociksXG4gICAgbiA9IFRvSW50ZWdlck9ySW5maW5pdHkodFsyXSB8fCB0WzRdKSxcbiAgICBhID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzNdIHx8IHRbNV0pLFxuICAgIGkgPSBUb0ludGVnZXJPckluZmluaXR5KHRbNl0pLFxuICAgIHMgPSB2b2lkIDAgIT09IHRbNl0sXG4gICAgbCA9IFRvSW50ZWdlck9ySW5maW5pdHkodFs3XSB8fCB0WzEwXSk7XG4gIHZhciBkID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzhdIHx8IHRbMTFdKTtcbiAgNjAgPT09IGQgJiYgKGQgPSA1OSk7XG4gIHZhciBtID0gKHRbOV0gfHwgdFsxMl0pICsgXCIwMDAwMDAwMDBcIixcbiAgICBjID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDAsIDMpKSxcbiAgICBoID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDMsIDYpKSxcbiAgICB1ID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDYsIDkpKTtcbiAgdmFyIFQsXG4gICAgcCA9ICExO1xuICBpZiAodFsxM10pIFQgPSB2b2lkIDAsIHAgPSAhMDtlbHNlIGlmICh0WzE0XSAmJiB0WzE1XSkge1xuICAgIHZhciBfZTIgPSBcIi1cIiA9PT0gdFsxNF0gfHwgXCLiiJJcIiA9PT0gdFsxNF0gPyBcIi1cIiA6IFwiK1wiLFxuICAgICAgX3I0ID0gdFsxNV0gfHwgXCIwMFwiLFxuICAgICAgX28gPSB0WzE2XSB8fCBcIjAwXCIsXG4gICAgICBfbiA9IHRbMTddIHx8IFwiMDBcIjtcbiAgICB2YXIgX2EgPSB0WzE4XSB8fCBcIjBcIjtcbiAgICBpZiAoVCA9IFwiXCIuY29uY2F0KF9lMikuY29uY2F0KF9yNCwgXCI6XCIpLmNvbmNhdChfbyksICtfYSkge1xuICAgICAgZm9yICg7IF9hLmVuZHNXaXRoKFwiMFwiKTspIF9hID0gX2Euc2xpY2UoMCwgLTEpO1xuICAgICAgVCArPSBcIjpcIi5jb25jYXQoX24sIFwiLlwiKS5jb25jYXQoX2EpO1xuICAgIH0gZWxzZSArX24gJiYgKFQgKz0gXCI6XCIuY29uY2F0KF9uKSk7XG4gICAgXCItMDA6MDBcIiA9PT0gVCAmJiAoVCA9IFwiKzAwOjAwXCIpO1xuICB9XG4gIHZhciBmID0gdFsxOV0sXG4gICAgeSA9IHRbMjBdO1xuICB2YXIgSTtcbiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih5Lm1hdGNoQWxsKEgpKSxcbiAgICBfc3RlcDQ7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDQpLFxuICAgICAgICBfZTMgPSBfc3RlcDQkdmFsdWVbMV0sXG4gICAgICAgIF90NCA9IF9zdGVwNCR2YWx1ZVsyXSxcbiAgICAgICAgX3I1ID0gX3N0ZXA0JHZhbHVlWzNdO1xuICAgICAgaWYgKFwidS1jYVwiID09PSBfdDQpIHZvaWQgMCA9PT0gSSAmJiAoSSA9IF9yNSk7ZWxzZSBpZiAoXCIhXCIgPT09IF9lMykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnJlY29nbml6ZWQgYW5ub3RhdGlvbjogIVwiLmNvbmNhdChfdDQsIFwiPVwiKS5jb25jYXQoX3I1KSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I0LmYoKTtcbiAgfVxuICByZXR1cm4gUmVqZWN0RGF0ZVRpbWUobywgbiwgYSwgaSwgbCwgZCwgYywgaCwgdSksIHtcbiAgICB5ZWFyOiBvLFxuICAgIG1vbnRoOiBuLFxuICAgIGRheTogYSxcbiAgICBoYXNUaW1lOiBzLFxuICAgIGhvdXI6IGksXG4gICAgbWludXRlOiBsLFxuICAgIHNlY29uZDogZCxcbiAgICBtaWxsaXNlY29uZDogYyxcbiAgICBtaWNyb3NlY29uZDogaCxcbiAgICBuYW5vc2Vjb25kOiB1LFxuICAgIGlhbmFOYW1lOiBmLFxuICAgIG9mZnNldDogVCxcbiAgICB6OiBwLFxuICAgIGNhbGVuZGFyOiBJXG4gIH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsWWVhck1vbnRoU3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBfLmV4ZWMoZSk7XG4gIHZhciByLCBvLCBuLCBhO1xuICBpZiAodCkge1xuICAgIHZhciBfYTIgPSB0WzFdO1xuICAgIGlmIChcIuKIklwiID09PSBfYTJbMF0gJiYgKF9hMiA9IFwiLVwiLmNvbmNhdChfYTIuc2xpY2UoMSkpKSwgXCItMDAwMDAwXCIgPT09IF9hMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgICByID0gVG9JbnRlZ2VyT3JJbmZpbml0eShfYTIpLCBvID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzJdKTtcbiAgICB2YXIgX2kgPSB0WzNdO1xuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2kubWF0Y2hBbGwoSCkpLFxuICAgICAgX3N0ZXA1O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCA0KSxcbiAgICAgICAgICBfZTQgPSBfc3RlcDUkdmFsdWVbMV0sXG4gICAgICAgICAgX3Q1ID0gX3N0ZXA1JHZhbHVlWzJdLFxuICAgICAgICAgIF9yNiA9IF9zdGVwNSR2YWx1ZVszXTtcbiAgICAgICAgaWYgKFwidS1jYVwiID09PSBfdDUpIHZvaWQgMCA9PT0gbiAmJiAobiA9IF9yNik7ZWxzZSBpZiAoXCIhXCIgPT09IF9lNCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnJlY29nbml6ZWQgYW5ub3RhdGlvbjogIVwiLmNvbmNhdChfdDUsIFwiPVwiKS5jb25jYXQoX3I2KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuICAgIGlmICh2b2lkIDAgIT09IG4gJiYgXCJpc284NjAxXCIgIT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWVlZWS1NTSBmb3JtYXQgaXMgb25seSB2YWxpZCB3aXRoIGlzbzg2MDEgY2FsZW5kYXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lO1xuICAgIHZhciBfdDY7XG4gICAgaWYgKChfUGFyc2VJU09EYXRlVGltZSA9IFBhcnNlSVNPRGF0ZVRpbWUoZSksIHIgPSBfUGFyc2VJU09EYXRlVGltZS55ZWFyLCBvID0gX1BhcnNlSVNPRGF0ZVRpbWUubW9udGgsIG4gPSBfUGFyc2VJU09EYXRlVGltZS5jYWxlbmRhciwgYSA9IF9QYXJzZUlTT0RhdGVUaW1lLmRheSwgX3Q2ID0gX1BhcnNlSVNPRGF0ZVRpbWUueiksIF90NikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5ZZWFyTW9udGhcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiByLFxuICAgIG1vbnRoOiBvLFxuICAgIGNhbGVuZGFyOiBuLFxuICAgIHJlZmVyZW5jZUlTT0RheTogYVxuICB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBKLmV4ZWMoZSk7XG4gIHZhciByLCBvLCBuLCBhO1xuICBpZiAodCkge1xuICAgIHIgPSBUb0ludGVnZXJPckluZmluaXR5KHRbMV0pLCBvID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzJdKTtcbiAgICB2YXIgX2U1ID0gdFszXTtcbiAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9lNS5tYXRjaEFsbChIKSksXG4gICAgICBfc3RlcDY7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDQpLFxuICAgICAgICAgIF90NyA9IF9zdGVwNiR2YWx1ZVsxXSxcbiAgICAgICAgICBfcjcgPSBfc3RlcDYkdmFsdWVbMl0sXG4gICAgICAgICAgX28yID0gX3N0ZXA2JHZhbHVlWzNdO1xuICAgICAgICBpZiAoXCJ1LWNhXCIgPT09IF9yNykgdm9pZCAwID09PSBuICYmIChuID0gX28yKTtlbHNlIGlmIChcIiFcIiA9PT0gX3Q3KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVucmVjb2duaXplZCBhbm5vdGF0aW9uOiAhXCIuY29uY2F0KF9yNywgXCI9XCIpLmNvbmNhdChfbzIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCAhPT0gbiAmJiBcImlzbzg2MDFcIiAhPT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNTS1ERCBmb3JtYXQgaXMgb25seSB2YWxpZCB3aXRoIGlzbzg2MDEgY2FsZW5kYXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lMjtcbiAgICB2YXIgX3Q4O1xuICAgIGlmICgoX1BhcnNlSVNPRGF0ZVRpbWUyID0gUGFyc2VJU09EYXRlVGltZShlKSwgciA9IF9QYXJzZUlTT0RhdGVUaW1lMi5tb250aCwgbyA9IF9QYXJzZUlTT0RhdGVUaW1lMi5kYXksIG4gPSBfUGFyc2VJU09EYXRlVGltZTIuY2FsZW5kYXIsIGEgPSBfUGFyc2VJU09EYXRlVGltZTIueWVhciwgX3Q4ID0gX1BhcnNlSVNPRGF0ZVRpbWUyLnopLCBfdDgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluTW9udGhEYXlcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb250aDogcixcbiAgICBkYXk6IG8sXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgcmVmZXJlbmNlSVNPWWVhcjogYVxuICB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbEluc3RhbnQoZSkge1xuICB2YXIgX1BhcnNlVGVtcG9yYWxJbnN0YW50ID0gZnVuY3Rpb24gUGFyc2VUZW1wb3JhbEluc3RhbnRTdHJpbmcoZSkge1xuICAgICAgdmFyIHQgPSBQYXJzZUlTT0RhdGVUaW1lKGUpO1xuICAgICAgaWYgKCF0LnogJiYgIXQub2Zmc2V0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRlbXBvcmFsLkluc3RhbnQgcmVxdWlyZXMgYSB0aW1lIHpvbmUgb2Zmc2V0XCIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfShlKSxcbiAgICB0ID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LnllYXIsXG4gICAgciA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5tb250aCxcbiAgICBvID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LmRheSxcbiAgICBuID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LmhvdXIsXG4gICAgYSA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5taW51dGUsXG4gICAgaSA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5zZWNvbmQsXG4gICAgcyA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5taWxsaXNlY29uZCxcbiAgICBsID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lm1pY3Jvc2Vjb25kLFxuICAgIGQgPSBfUGFyc2VUZW1wb3JhbEluc3RhbnQubmFub3NlY29uZCxcbiAgICBtID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lm9mZnNldCxcbiAgICBjID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lno7XG4gIGlmICghYyAmJiAhbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZW1wb3JhbC5JbnN0YW50IHJlcXVpcmVzIGEgdGltZSB6b25lIG9mZnNldFwiKTtcbiAgdmFyIGggPSBjID8gMCA6IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcobSk7XG4gIHZhciBfQmFsYW5jZUlTT0RhdGVUaW1lID0gQmFsYW5jZUlTT0RhdGVUaW1lKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQgLSBoKTtcbiAgdCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUueWVhcjtcbiAgciA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubW9udGg7XG4gIG8gPSBfQmFsYW5jZUlTT0RhdGVUaW1lLmRheTtcbiAgbiA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUuaG91cjtcbiAgYSA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubWludXRlO1xuICBpID0gX0JhbGFuY2VJU09EYXRlVGltZS5zZWNvbmQ7XG4gIHMgPSBfQmFsYW5jZUlTT0RhdGVUaW1lLm1pbGxpc2Vjb25kO1xuICBsID0gX0JhbGFuY2VJU09EYXRlVGltZS5taWNyb3NlY29uZDtcbiAgZCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubmFub3NlY29uZDtcbiAgdmFyIHUgPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpO1xuICBpZiAobnVsbCA9PT0gdSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiBSZWd1bGF0ZUlTT0RhdGUoZSwgdCwgciwgbykge1xuICB2YXIgbiA9IGUsXG4gICAgYSA9IHQsXG4gICAgaSA9IHI7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIFJlamVjdElTT0RhdGUobiwgYSwgaSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29uc3RyYWluXCI6XG4gICAgICB2YXIgX0NvbnN0cmFpbklTT0RhdGUgPSBDb25zdHJhaW5JU09EYXRlKG4sIGEsIGkpO1xuICAgICAgbiA9IF9Db25zdHJhaW5JU09EYXRlLnllYXI7XG4gICAgICBhID0gX0NvbnN0cmFpbklTT0RhdGUubW9udGg7XG4gICAgICBpID0gX0NvbnN0cmFpbklTT0RhdGUuZGF5O1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcjogbixcbiAgICBtb250aDogYSxcbiAgICBkYXk6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBzID0gZSxcbiAgICBsID0gdCxcbiAgICBkID0gcixcbiAgICBtID0gbyxcbiAgICBjID0gbixcbiAgICBoID0gYTtcbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSBcInJlamVjdFwiOlxuICAgICAgUmVqZWN0VGltZShzLCBsLCBkLCBtLCBjLCBoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb25zdHJhaW5cIjpcbiAgICAgIHZhciBfQ29uc3RyYWluVGltZSA9IGZ1bmN0aW9uIENvbnN0cmFpblRpbWUoZSwgdCwgciwgbywgbiwgYSkge1xuICAgICAgICB2YXIgaSA9IENvbnN0cmFpblRvUmFuZ2UoZSwgMCwgMjMpLFxuICAgICAgICAgIHMgPSBDb25zdHJhaW5Ub1JhbmdlKHQsIDAsIDU5KSxcbiAgICAgICAgICBsID0gQ29uc3RyYWluVG9SYW5nZShyLCAwLCA1OSksXG4gICAgICAgICAgZCA9IENvbnN0cmFpblRvUmFuZ2UobywgMCwgOTk5KSxcbiAgICAgICAgICBtID0gQ29uc3RyYWluVG9SYW5nZShuLCAwLCA5OTkpLFxuICAgICAgICAgIGMgPSBDb25zdHJhaW5Ub1JhbmdlKGEsIDAsIDk5OSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG91cjogaSxcbiAgICAgICAgICBtaW51dGU6IHMsXG4gICAgICAgICAgc2Vjb25kOiBsLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBkLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiBtLFxuICAgICAgICAgIG5hbm9zZWNvbmQ6IGNcbiAgICAgICAgfTtcbiAgICAgIH0ocywgbCwgZCwgbSwgYywgaCk7XG4gICAgICBzID0gX0NvbnN0cmFpblRpbWUuaG91cjtcbiAgICAgIGwgPSBfQ29uc3RyYWluVGltZS5taW51dGU7XG4gICAgICBkID0gX0NvbnN0cmFpblRpbWUuc2Vjb25kO1xuICAgICAgbSA9IF9Db25zdHJhaW5UaW1lLm1pbGxpc2Vjb25kO1xuICAgICAgYyA9IF9Db25zdHJhaW5UaW1lLm1pY3Jvc2Vjb25kO1xuICAgICAgaCA9IF9Db25zdHJhaW5UaW1lLm5hbm9zZWNvbmQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBob3VyOiBzLFxuICAgIG1pbnV0ZTogbCxcbiAgICBzZWNvbmQ6IGQsXG4gICAgbWlsbGlzZWNvbmQ6IG0sXG4gICAgbWljcm9zZWNvbmQ6IGMsXG4gICAgbmFub3NlY29uZDogaFxuICB9O1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpIHtcbiAgaWYgKCFJc09iamVjdChlKSkgcmV0dXJuIGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEdXJhdGlvblN0cmluZyhlKSB7XG4gICAgdmFyIHQgPSBRLmV4ZWMoZSk7XG4gICAgaWYgKCF0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZHVyYXRpb246IFwiLmNvbmNhdChlKSk7XG4gICAgaWYgKHQuc2xpY2UoMikuZXZlcnkoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGU7XG4gICAgfSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbjogXCIuY29uY2F0KGUpKTtcbiAgICB2YXIgciA9IFwiLVwiID09PSB0WzFdIHx8IFwi4oiSXCIgPT09IHRbMV0gPyAtMSA6IDEsXG4gICAgICBvID0gdm9pZCAwID09PSB0WzJdID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHRbMl0pICogcixcbiAgICAgIG4gPSB2b2lkIDAgPT09IHRbM10gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odFszXSkgKiByLFxuICAgICAgYSA9IHZvaWQgMCA9PT0gdFs0XSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0WzRdKSAqIHIsXG4gICAgICBpID0gdm9pZCAwID09PSB0WzVdID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHRbNV0pICogcixcbiAgICAgIHMgPSB2b2lkIDAgPT09IHRbNl0gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odFs2XSkgKiByLFxuICAgICAgbCA9IHRbN10sXG4gICAgICBkID0gdFs4XSxcbiAgICAgIG0gPSB0WzldLFxuICAgICAgYyA9IHRbMTBdLFxuICAgICAgaCA9IHRbMTFdO1xuICAgIHZhciB1ID0gMCxcbiAgICAgIFQgPSAwLFxuICAgICAgcCA9IDA7XG4gICAgaWYgKHZvaWQgMCAhPT0gbCkge1xuICAgICAgdmFyIF9yZWY1LCBfcmVmNjtcbiAgICAgIGlmICgoX3JlZjUgPSAoX3JlZjYgPSBkICE9PSBudWxsICYmIGQgIT09IHZvaWQgMCA/IGQgOiBtKSAhPT0gbnVsbCAmJiBfcmVmNiAhPT0gdm9pZCAwID8gX3JlZjYgOiBjKSAhPT0gbnVsbCAmJiBfcmVmNSAhPT0gdm9pZCAwID8gX3JlZjUgOiBoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWxcIik7XG4gICAgICBwID0gMzYwMCAqIFRvSW50ZWdlck9ySW5maW5pdHkoKGwgKyBcIjAwMDAwMDAwMFwiKS5zbGljZSgwLCA5KSkgKiByO1xuICAgIH0gZWxzZSBpZiAodSA9IHZvaWQgMCA9PT0gZCA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihkKSAqIHIsIHZvaWQgMCAhPT0gbSkge1xuICAgICAgaWYgKGMgIT09IG51bGwgJiYgYyAhPT0gdm9pZCAwID8gYyA6IGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbFwiKTtcbiAgICAgIHAgPSA2MCAqIFRvSW50ZWdlck9ySW5maW5pdHkoKG0gKyBcIjAwMDAwMDAwMFwiKS5zbGljZSgwLCA5KSkgKiByO1xuICAgIH0gZWxzZSBUID0gdm9pZCAwID09PSBjID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGMpICogciwgdm9pZCAwICE9PSBoICYmIChwID0gVG9JbnRlZ2VyT3JJbmZpbml0eSgoaCArIFwiMDAwMDAwMDAwXCIpLnNsaWNlKDAsIDkpKSAqIHIpO1xuICAgIHZhciBmID0gcCAlIDFlMyxcbiAgICAgIHkgPSBsZShwIC8gMWUzKSAlIDFlMyxcbiAgICAgIEkgPSBsZShwIC8gMWU2KSAlIDFlMztcbiAgICByZXR1cm4gVCArPSBsZShwIC8gMWU5KSAlIDYwLCB1ICs9IGxlKHAgLyA2ZTEwKSwgUmVqZWN0RHVyYXRpb24obywgbiwgYSwgaSwgcywgdSwgVCwgSSwgeSwgZiksIHtcbiAgICAgIHllYXJzOiBvLFxuICAgICAgbW9udGhzOiBuLFxuICAgICAgd2Vla3M6IGEsXG4gICAgICBkYXlzOiBpLFxuICAgICAgaG91cnM6IHMsXG4gICAgICBtaW51dGVzOiB1LFxuICAgICAgc2Vjb25kczogVCxcbiAgICAgIG1pbGxpc2Vjb25kczogSSxcbiAgICAgIG1pY3Jvc2Vjb25kczogeSxcbiAgICAgIG5hbm9zZWNvbmRzOiBmXG4gICAgfTtcbiAgfShUb1N0cmluZyhlKSk7XG4gIGlmIChJc1RlbXBvcmFsRHVyYXRpb24oZSkpIHJldHVybiB7XG4gICAgeWVhcnM6IEdldFNsb3QoZSwgdyksXG4gICAgbW9udGhzOiBHZXRTbG90KGUsIEQpLFxuICAgIHdlZWtzOiBHZXRTbG90KGUsIEcpLFxuICAgIGRheXM6IEdldFNsb3QoZSwgdiksXG4gICAgaG91cnM6IEdldFNsb3QoZSwgQyksXG4gICAgbWludXRlczogR2V0U2xvdChlLCBPKSxcbiAgICBzZWNvbmRzOiBHZXRTbG90KGUsIGIpLFxuICAgIG1pbGxpc2Vjb25kczogR2V0U2xvdChlLCBFKSxcbiAgICBtaWNyb3NlY29uZHM6IEdldFNsb3QoZSwgTSksXG4gICAgbmFub3NlY29uZHM6IEdldFNsb3QoZSwgUilcbiAgfTtcbiAgdmFyIHQgPSB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIHdlZWtzOiAwLFxuICAgIGRheXM6IDAsXG4gICAgaG91cnM6IDAsXG4gICAgbWludXRlczogMCxcbiAgICBzZWNvbmRzOiAwLFxuICAgIG1pbGxpc2Vjb25kczogMCxcbiAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgbmFub3NlY29uZHM6IDBcbiAgfTtcbiAgdmFyIHIgPSBmdW5jdGlvbiBUb1RlbXBvcmFsUGFydGlhbER1cmF0aW9uUmVjb3JkKGUpIHtcbiAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbi1saWtlXCIpO1xuICAgIHZhciB0ID0ge1xuICAgICAgeWVhcnM6IHZvaWQgMCxcbiAgICAgIG1vbnRoczogdm9pZCAwLFxuICAgICAgd2Vla3M6IHZvaWQgMCxcbiAgICAgIGRheXM6IHZvaWQgMCxcbiAgICAgIGhvdXJzOiB2b2lkIDAsXG4gICAgICBtaW51dGVzOiB2b2lkIDAsXG4gICAgICBzZWNvbmRzOiB2b2lkIDAsXG4gICAgICBtaWxsaXNlY29uZHM6IHZvaWQgMCxcbiAgICAgIG1pY3Jvc2Vjb25kczogdm9pZCAwLFxuICAgICAgbmFub3NlY29uZHM6IHZvaWQgMFxuICAgIH07XG4gICAgdmFyIHIgPSAhMTtcbiAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFdlKSxcbiAgICAgIF9zdGVwNztcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9vMyA9IF9zdGVwNy52YWx1ZTtcbiAgICAgICAgdmFyIF9uMiA9IGVbX28zXTtcbiAgICAgICAgdm9pZCAwICE9PSBfbjIgJiYgKHIgPSAhMCwgdFtfbzNdID0gVG9JbnRlZ2VySWZJbnRlZ3JhbChfbjIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICB9XG4gICAgaWYgKCFyKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbi1saWtlXCIpO1xuICAgIHJldHVybiB0O1xuICB9KGUpO1xuICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFdlKSxcbiAgICBfc3RlcDg7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfZTYgPSBfc3RlcDgudmFsdWU7XG4gICAgICB2YXIgX280ID0gcltfZTZdO1xuICAgICAgdm9pZCAwICE9PSBfbzQgJiYgKHRbX2U2XSA9IF9vNCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I4LmYoKTtcbiAgfVxuICB2YXIgbyA9IHQueWVhcnMsXG4gICAgbiA9IHQubW9udGhzLFxuICAgIGEgPSB0LndlZWtzLFxuICAgIGkgPSB0LmRheXMsXG4gICAgcyA9IHQuaG91cnMsXG4gICAgbCA9IHQubWludXRlcyxcbiAgICBkID0gdC5zZWNvbmRzLFxuICAgIG0gPSB0Lm1pbGxpc2Vjb25kcyxcbiAgICBjID0gdC5taWNyb3NlY29uZHMsXG4gICAgaCA9IHQubmFub3NlY29uZHM7XG4gIHJldHVybiBSZWplY3REdXJhdGlvbihvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjLCBoKSwge1xuICAgIHllYXJzOiBvLFxuICAgIG1vbnRoczogbixcbiAgICB3ZWVrczogYSxcbiAgICBkYXlzOiBpLFxuICAgIGhvdXJzOiBzLFxuICAgIG1pbnV0ZXM6IGwsXG4gICAgc2Vjb25kczogZCxcbiAgICBtaWxsaXNlY29uZHM6IG0sXG4gICAgbWljcm9zZWNvbmRzOiBjLFxuICAgIG5hbm9zZWNvbmRzOiBoXG4gIH07XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsT3ZlcmZsb3coZSkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gXCJjb25zdHJhaW5cIiA6IEdldE9wdGlvbihlLCBcIm92ZXJmbG93XCIsIFtcImNvbnN0cmFpblwiLCBcInJlamVjdFwiXSwgXCJjb25zdHJhaW5cIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24oZSkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gXCJjb21wYXRpYmxlXCIgOiBHZXRPcHRpb24oZSwgXCJkaXNhbWJpZ3VhdGlvblwiLCBbXCJjb21wYXRpYmxlXCIsIFwiZWFybGllclwiLCBcImxhdGVyXCIsIFwicmVqZWN0XCJdLCBcImNvbXBhdGlibGVcIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKGUsIHQpIHtcbiAgcmV0dXJuIEdldE9wdGlvbihlLCBcInJvdW5kaW5nTW9kZVwiLCBbXCJjZWlsXCIsIFwiZmxvb3JcIiwgXCJleHBhbmRcIiwgXCJ0cnVuY1wiLCBcImhhbGZDZWlsXCIsIFwiaGFsZkZsb29yXCIsIFwiaGFsZkV4cGFuZFwiLCBcImhhbGZUcnVuY1wiLCBcImhhbGZFdmVuXCJdLCB0KTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxPZmZzZXQoZSwgdCkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gdCA6IEdldE9wdGlvbihlLCBcIm9mZnNldFwiLCBbXCJwcmVmZXJcIiwgXCJ1c2VcIiwgXCJpZ25vcmVcIiwgXCJyZWplY3RcIl0sIHQpO1xufVxuZnVuY3Rpb24gVG9DYWxlbmRhck5hbWVPcHRpb24oZSkge1xuICByZXR1cm4gR2V0T3B0aW9uKGUsIFwiY2FsZW5kYXJOYW1lXCIsIFtcImF1dG9cIiwgXCJhbHdheXNcIiwgXCJuZXZlclwiLCBcImNyaXRpY2FsXCJdLCBcImF1dG9cIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQoZSkge1xuICB2YXIgdCA9IGUucm91bmRpbmdJbmNyZW1lbnQ7XG4gIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiAxO1xuICBpZiAodCA9IFRvTnVtYmVyKHQpLCAhbWUodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwicm91bmRpbmdJbmNyZW1lbnQgbXVzdCBiZSBmaW5pdGVcIik7XG4gIHZhciByID0gbGUodCk7XG4gIGlmIChyIDwgMSB8fCByID4gMWU5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJvdW5kaW5nSW5jcmVtZW50IG11c3QgYmUgYXQgbGVhc3QgMSBhbmQgYXQgbW9zdCAxZTksIG5vdCBcIi5jb25jYXQodCkpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFZhbGlkYXRlVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChlLCB0LCByKSB7XG4gIHZhciBvID0gciA/IHQgOiB0IC0gMTtcbiAgaWYgKGUgPiBvKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJvdW5kaW5nSW5jcmVtZW50IG11c3QgYmUgYXQgbGVhc3QgMSBhbmQgbGVzcyB0aGFuIFwiLmNvbmNhdChvLCBcIiwgbm90IFwiKS5jb25jYXQoZSkpO1xuICBpZiAodCAlIGUgIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSb3VuZGluZyBpbmNyZW1lbnQgbXVzdCBkaXZpZGUgZXZlbmx5IGludG8gXCIuY29uY2F0KHQpKTtcbn1cbmZ1bmN0aW9uIFRvRnJhY3Rpb25hbFNlY29uZERpZ2l0cyhlKSB7XG4gIHZhciB0ID0gZS5mcmFjdGlvbmFsU2Vjb25kRGlnaXRzO1xuICBpZiAodm9pZCAwID09PSB0KSByZXR1cm4gXCJhdXRvXCI7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB0KSB7XG4gICAgaWYgKFwiYXV0b1wiICE9PSBUb1N0cmluZyh0KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgXCIuY29uY2F0KHQpKTtcbiAgICByZXR1cm4gXCJhdXRvXCI7XG4gIH1cbiAgdmFyIHIgPSBpZSh0KTtcbiAgaWYgKCFtZShyKSB8fCByIDwgMCB8fCByID4gOSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgXCIuY29uY2F0KHQpKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb25SZWNvcmQoZSwgdCkge1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IFwibWludXRlXCIsXG4gICAgICAgIHVuaXQ6IFwibWludXRlXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDAsXG4gICAgICAgIHVuaXQ6IFwic2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogMyxcbiAgICAgICAgdW5pdDogXCJtaWxsaXNlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IDFcbiAgICAgIH07XG4gICAgY2FzZSBcIm1pY3Jvc2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDYsXG4gICAgICAgIHVuaXQ6IFwibWljcm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiAxXG4gICAgICB9O1xuICAgIGNhc2UgXCJuYW5vc2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDksXG4gICAgICAgIHVuaXQ6IFwibmFub3NlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IDFcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcImF1dG9cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogdCxcbiAgICAgICAgdW5pdDogXCJuYW5vc2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IHQsXG4gICAgICAgIHVuaXQ6IFwic2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogdCxcbiAgICAgICAgdW5pdDogXCJtaWxsaXNlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IE1hdGgucG93KDEwLCAzIC0gdClcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IHQsXG4gICAgICAgIHVuaXQ6IFwibWljcm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiBNYXRoLnBvdygxMCwgNiAtIHQpXG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICBjYXNlIDg6XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJlY2lzaW9uOiB0LFxuICAgICAgICB1bml0OiBcIm5hbm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiBNYXRoLnBvdygxMCwgOSAtIHQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZyYWN0aW9uYWxTZWNvbmREaWdpdHMgbXVzdCBiZSAnYXV0bycgb3IgMCB0aHJvdWdoIDksIG5vdCBcIi5jb25jYXQodCkpO1xuICB9XG59XG52YXIgSGUgPSBTeW1ib2woXCJ+cmVxdWlyZWR+XCIpO1xuZnVuY3Rpb24gR2V0VGVtcG9yYWxVbml0KGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICB2YXIgYSA9IFtdO1xuICBmb3IgKHZhciBfaTIgPSAwLCBfVWUgPSBVZTsgX2kyIDwgX1VlLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX1VlJF9pID0gX3NsaWNlZFRvQXJyYXkoX1VlW19pMl0sIDMpLFxuICAgICAgX2U3ID0gX1VlJF9pWzFdLFxuICAgICAgX3Q5ID0gX1VlJF9pWzJdO1xuICAgIFwiZGF0ZXRpbWVcIiAhPT0gciAmJiByICE9PSBfdDkgfHwgYS5wdXNoKF9lNyk7XG4gIH1cbiAgYS5wdXNoLmFwcGx5KGEsIF90b0NvbnN1bWFibGVBcnJheShuKSk7XG4gIHZhciBpID0gbztcbiAgaSA9PT0gSGUgPyBpID0gdm9pZCAwIDogdm9pZCAwICE9PSBpICYmIGEucHVzaChpKTtcbiAgdmFyIHMgPSBbXS5jb25jYXQoYSk7XG4gIGZvciAodmFyIF9pMyA9IDAsIF9hMyA9IGE7IF9pMyA8IF9hMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9lOCA9IF9hM1tfaTNdO1xuICAgIHZhciBfdDEwID0gTGUuZ2V0KF9lOCk7XG4gICAgdm9pZCAwICE9PSBfdDEwICYmIHMucHVzaChfdDEwKTtcbiAgfVxuICB2YXIgbCA9IEdldE9wdGlvbihlLCB0LCBzLCBpKTtcbiAgaWYgKHZvaWQgMCA9PT0gbCAmJiBvID09PSBIZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQodCwgXCIgaXMgcmVxdWlyZWRcIikpO1xuICByZXR1cm4gQWUuaGFzKGwpID8gQWUuZ2V0KGwpIDogbDtcbn1cbmZ1bmN0aW9uIFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChlKSB7XG4gIHZhciB0ID0gZS5yZWxhdGl2ZVRvO1xuICBpZiAodm9pZCAwID09PSB0KSByZXR1cm4gdDtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwsXG4gICAgZCxcbiAgICBtLFxuICAgIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQgPSBcIm9wdGlvblwiLFxuICAgIHAgPSAhMTtcbiAgaWYgKElzT2JqZWN0KHQpKSB7XG4gICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodCkgfHwgSXNUZW1wb3JhbERhdGUodCkpIHJldHVybiB0O1xuICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUodCkpIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHQpO1xuICAgIGMgPSBHZXRUZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlV2l0aElTT0RlZmF1bHQodCk7XG4gICAgdmFyIF9lOSA9IENhbGVuZGFyRmllbGRzKGMsIFtcImRheVwiLCBcImhvdXJcIiwgXCJtaWNyb3NlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCIsIFwibWludXRlXCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJuYW5vc2Vjb25kXCIsIFwic2Vjb25kXCIsIFwieWVhclwiXSk7XG4gICAgX2U5LnB1c2goXCJ0aW1lWm9uZVwiLCBcIm9mZnNldFwiKTtcbiAgICB2YXIgX3AgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgX2U5LCBbXSksXG4gICAgICBfZiA9IFRlKG51bGwpO1xuICAgIF9mLm92ZXJmbG93ID0gXCJjb25zdHJhaW5cIiwgKF9JbnRlcnByZXRUZW1wb3JhbERhdCA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoYywgX3AsIF9mKSwgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC55ZWFyLCBvID0gX0ludGVycHJldFRlbXBvcmFsRGF0Lm1vbnRoLCBuID0gX0ludGVycHJldFRlbXBvcmFsRGF0LmRheSwgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC5ob3VyLCBpID0gX0ludGVycHJldFRlbXBvcmFsRGF0Lm1pbnV0ZSwgcyA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC5zZWNvbmQsIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubWlsbGlzZWNvbmQsIGQgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubWljcm9zZWNvbmQsIG0gPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubmFub3NlY29uZCksIHUgPSBfcC5vZmZzZXQsIHZvaWQgMCA9PT0gdSAmJiAoVCA9IFwid2FsbFwiKSwgaCA9IF9wLnRpbWVab25lLCB2b2lkIDAgIT09IGggJiYgKGggPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoaCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfUGFyc2VJU09EYXRlVGltZTM7XG4gICAgdmFyIF9lMTAsIF9mMjtcbiAgICBpZiAoKF9QYXJzZUlTT0RhdGVUaW1lMyA9IFBhcnNlSVNPRGF0ZVRpbWUoVG9TdHJpbmcodCkpLCByID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnllYXIsIG8gPSBfUGFyc2VJU09EYXRlVGltZTMubW9udGgsIG4gPSBfUGFyc2VJU09EYXRlVGltZTMuZGF5LCBhID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmhvdXIsIGkgPSBfUGFyc2VJU09EYXRlVGltZTMubWludXRlLCBzID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnNlY29uZCwgbCA9IF9QYXJzZUlTT0RhdGVUaW1lMy5taWxsaXNlY29uZCwgZCA9IF9QYXJzZUlTT0RhdGVUaW1lMy5taWNyb3NlY29uZCwgbSA9IF9QYXJzZUlTT0RhdGVUaW1lMy5uYW5vc2Vjb25kLCBjID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmNhbGVuZGFyLCBfZTEwID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmlhbmFOYW1lLCB1ID0gX1BhcnNlSVNPRGF0ZVRpbWUzLm9mZnNldCwgX2YyID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnopLCBfZTEwKSBoID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9lMTApLCBfZjIgPyBUID0gXCJleGFjdFwiIDogdSB8fCAoVCA9IFwid2FsbFwiKSwgcCA9ICEwO2Vsc2UgaWYgKF9mMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5EYXRlIHJlbGF0aXZlVG87IGVpdGhlciByZW1vdmUgdGhlIFogb3IgYWRkIGEgYnJhY2tldGVkIHRpbWUgem9uZVwiKTtcbiAgICBpZiAoYyB8fCAoYyA9IFwiaXNvODYwMVwiKSwgIUlzQnVpbHRpbkNhbGVuZGFyKGMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgY2FsZW5kYXIgaWRlbnRpZmllciBcIi5jb25jYXQoYykpO1xuICAgIGMgPSBBU0NJSUxvd2VyY2FzZShjKTtcbiAgfVxuICBpZiAodm9pZCAwID09PSBoKSByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKHIsIG8sIG4sIGMpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIFQsIFwib3B0aW9uXCIgPT09IFQgPyBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHUpIDogMCwgaCwgXCJjb21wYXRpYmxlXCIsIFwicmVqZWN0XCIsIHApLCBoLCBjKTtcbn1cbmZ1bmN0aW9uIERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpIHtcbiAgZm9yICh2YXIgX2k0ID0gMCwgX2FyciA9IFtbXCJ5ZWFyc1wiLCBlXSwgW1wibW9udGhzXCIsIHRdLCBbXCJ3ZWVrc1wiLCByXSwgW1wiZGF5c1wiLCBvXSwgW1wiaG91cnNcIiwgbl0sIFtcIm1pbnV0ZXNcIiwgYV0sIFtcInNlY29uZHNcIiwgaV0sIFtcIm1pbGxpc2Vjb25kc1wiLCBzXSwgW1wibWljcm9zZWNvbmRzXCIsIGxdLCBbXCJuYW5vc2Vjb25kc1wiLCBkXV07IF9pNCA8IF9hcnIubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBfYXJyJF9pID0gX3NsaWNlZFRvQXJyYXkoX2FycltfaTRdLCAyKSxcbiAgICAgIF9tID0gX2FyciRfaVswXSxcbiAgICAgIF9jID0gX2FyciRfaVsxXTtcbiAgICBpZiAoMCAhPT0gX2MpIHJldHVybiBBZS5nZXQoX20pO1xuICB9XG4gIHJldHVybiBcIm5hbm9zZWNvbmRcIjtcbn1cbmZ1bmN0aW9uIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhlLCB0KSB7XG4gIHJldHVybiB4ZS5pbmRleE9mKGUpID4geGUuaW5kZXhPZih0KSA/IHQgOiBlO1xufVxuZnVuY3Rpb24gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIHQsIHIpIHtcbiAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICBlbXB0eVNvdXJjZUVycm9yTWVzc2FnZTogXCJubyBzdXBwb3J0ZWQgcHJvcGVydGllcyBmb3VuZFwiXG4gICAgfSxcbiAgICBvID0gX3JlZjcuZW1wdHlTb3VyY2VFcnJvck1lc3NhZ2U7XG4gIHZhciBuID0gVGUobnVsbCk7XG4gIHZhciBhID0gITE7XG4gIHQuc29ydCgpO1xuICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwOTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgdmFyIF9vNSA9IF9zdGVwOS52YWx1ZTtcbiAgICAgIHZhciBfdDExID0gZVtfbzVdO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gX3QxMSkgYSA9ICEwLCAkZS5oYXMoX281KSAmJiAoX3QxMSA9ICRlLmdldChfbzUpKF90MTEpKSwgbltfbzVdID0gX3QxMTtlbHNlIGlmIChcInBhcnRpYWxcIiAhPT0gcikge1xuICAgICAgICBpZiAoZWUuY2FsbChyLCBfbzUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVxdWlyZWQgcHJvcGVydHkgJ1wiLmNvbmNhdChfbzUsIFwiJyBtaXNzaW5nIG9yIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIF90MTEgPSBrZS5nZXQoX281KSwgbltfbzVdID0gX3QxMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjkuZigpO1xuICB9XG4gIGlmIChcInBhcnRpYWxcIiA9PT0gciAmJiAhYSkgdGhyb3cgbmV3IFR5cGVFcnJvcihvKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVJlY29yZChlKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImNvbXBsZXRlXCI7XG4gIHZhciByID0gW1wiaG91clwiLCBcIm1pY3Jvc2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJuYW5vc2Vjb25kXCIsIFwic2Vjb25kXCJdLFxuICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgciwgXCJwYXJ0aWFsXCIsIHtcbiAgICAgIGVtcHR5U291cmNlRXJyb3JNZXNzYWdlOiBcImludmFsaWQgdGltZS1saWtlXCJcbiAgICB9KSxcbiAgICBuID0ge307XG4gIGZvciAodmFyIF9pNSA9IDAsIF9yOCA9IHI7IF9pNSA8IF9yOC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgdmFyIF9lMTEgPSBfcjhbX2k1XTtcbiAgICB2YXIgX3I5ID0gcGUobywgX2UxMSk7XG4gICAgdm9pZCAwICE9PSBfcjkgPyBuW19lMTFdID0gX3I5LnZhbHVlIDogXCJjb21wbGV0ZVwiID09PSB0ICYmIChuW19lMTFdID0gMCk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZShlLCB0KSB7XG4gIHZhciByID0gZTtcbiAgaWYgKElzT2JqZWN0KHIpKSB7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKHIpKSByZXR1cm4gcjtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocikgJiYgKFRvVGVtcG9yYWxPdmVyZmxvdyh0KSwgciA9IEdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChyLCBnKSwgR2V0U2xvdChyLCBTKSwgR2V0U2xvdChyLCBwKSkpLCBJc1RlbXBvcmFsRGF0ZVRpbWUocikpIHJldHVybiBUb1RlbXBvcmFsT3ZlcmZsb3codCksIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIHApKTtcbiAgICB2YXIgX2UxMiA9IEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChyKTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhfZTEyLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHMociwgQ2FsZW5kYXJGaWVsZHMoX2UxMiwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLCB0KTtcbiAgfVxuICBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gIHZhciBfUGFyc2VUZW1wb3JhbERhdGVTdHIgPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVN0cmluZyhlKSB7XG4gICAgICByZXR1cm4gUGFyc2VJU09EYXRlVGltZShlKTtcbiAgICB9KFRvU3RyaW5nKHIpKSxcbiAgICBvID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLnllYXIsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVN0ci5tb250aCxcbiAgICBhID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLmRheSxcbiAgICBkID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLmNhbGVuZGFyLFxuICAgIG0gPSBfUGFyc2VUZW1wb3JhbERhdGVTdHIuejtcbiAgaWYgKG0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZVwiKTtcbiAgaWYgKGQgfHwgKGQgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcihkKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KGQpKTtcbiAgcmV0dXJuIGQgPSBBU0NJSUxvd2VyY2FzZShkKSwgQ3JlYXRlVGVtcG9yYWxEYXRlKG8sIG4sIGEsIGQpO1xufVxuZnVuY3Rpb24gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhlLCB0LCByKSB7XG4gIHZhciBfUmVndWxhdGVUaW1lO1xuICB2YXIgX1RvVGVtcG9yYWxUaW1lUmVjb3JkID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQodCksXG4gICAgbyA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZC5ob3VyLFxuICAgIG4gPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQubWludXRlLFxuICAgIGEgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQuc2Vjb25kLFxuICAgIGQgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQubWlsbGlzZWNvbmQsXG4gICAgbSA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZC5taWNyb3NlY29uZCxcbiAgICBjID0gX1RvVGVtcG9yYWxUaW1lUmVjb3JkLm5hbm9zZWNvbmQ7XG4gIHZhciBoID0gVG9UZW1wb3JhbE92ZXJmbG93KHIpLFxuICAgIHUgPSBDYWxlbmRhckRhdGVGcm9tRmllbGRzKGUsIHQsIHIpLFxuICAgIFQgPSBHZXRTbG90KHUsIGkpLFxuICAgIHAgPSBHZXRTbG90KHUsIHMpLFxuICAgIGYgPSBHZXRTbG90KHUsIGwpO1xuICByZXR1cm4gKF9SZWd1bGF0ZVRpbWUgPSBSZWd1bGF0ZVRpbWUobywgbiwgYSwgZCwgbSwgYywgaCksIG8gPSBfUmVndWxhdGVUaW1lLmhvdXIsIG4gPSBfUmVndWxhdGVUaW1lLm1pbnV0ZSwgYSA9IF9SZWd1bGF0ZVRpbWUuc2Vjb25kLCBkID0gX1JlZ3VsYXRlVGltZS5taWxsaXNlY29uZCwgbSA9IF9SZWd1bGF0ZVRpbWUubWljcm9zZWNvbmQsIGMgPSBfUmVndWxhdGVUaW1lLm5hbm9zZWNvbmQpLCB7XG4gICAgeWVhcjogVCxcbiAgICBtb250aDogcCxcbiAgICBkYXk6IGYsXG4gICAgaG91cjogbyxcbiAgICBtaW51dGU6IG4sXG4gICAgc2Vjb25kOiBhLFxuICAgIG1pbGxpc2Vjb25kOiBkLFxuICAgIG1pY3Jvc2Vjb25kOiBtLFxuICAgIG5hbm9zZWNvbmQ6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlVGltZShlLCB0KSB7XG4gIHZhciByLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBUO1xuICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGUpKSByZXR1cm4gZTtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHJldHVybiBUb1RlbXBvcmFsT3ZlcmZsb3codCksIEdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChlLCBnKSwgR2V0U2xvdChlLCBTKSwgR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKGUpKSByZXR1cm4gVG9UZW1wb3JhbE92ZXJmbG93KHQpLCBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIDAsIDAsIDAsIDAsIDAsIDAsIEdldFNsb3QoZSwgcCkpO1xuICAgIFQgPSBHZXRUZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlV2l0aElTT0RlZmF1bHQoZSk7XG4gICAgdmFyIF9mMyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBDYWxlbmRhckZpZWxkcyhULCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pLCBbXSk7XG4gICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDIgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKFQsIF9mMywgdCk7XG4gICAgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIueWVhcjtcbiAgICBvID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5tb250aDtcbiAgICBuID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5kYXk7XG4gICAgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIuaG91cjtcbiAgICBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5taW51dGU7XG4gICAgbSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIuc2Vjb25kO1xuICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm1pbGxpc2Vjb25kO1xuICAgIGggPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm1pY3Jvc2Vjb25kO1xuICAgIHUgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm5hbm9zZWNvbmQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZVRlbXBvcmFsRGF0ZVRpbTtcbiAgICB2YXIgX2k2O1xuICAgIGlmIChUb1RlbXBvcmFsT3ZlcmZsb3codCksIChfUGFyc2VUZW1wb3JhbERhdGVUaW0gPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoZSkge1xuICAgICAgcmV0dXJuIFBhcnNlSVNPRGF0ZVRpbWUoZSk7XG4gICAgfShUb1N0cmluZyhlKSksIHIgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0ueWVhciwgbyA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5tb250aCwgbiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5kYXksIGEgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uaG91ciwgZCA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5taW51dGUsIG0gPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uc2Vjb25kLCBjID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm1pbGxpc2Vjb25kLCBoID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm1pY3Jvc2Vjb25kLCB1ID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm5hbm9zZWNvbmQsIFQgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uY2FsZW5kYXIsIF9pNiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS56KSwgX2k2KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpbkRhdGVUaW1lXCIpO1xuICAgIGlmIChSZWplY3REYXRlVGltZShyLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1KSwgVCB8fCAoVCA9IFwiaXNvODYwMVwiKSwgIUlzQnVpbHRpbkNhbGVuZGFyKFQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgY2FsZW5kYXIgaWRlbnRpZmllciBcIi5jb25jYXQoVCkpO1xuICAgIFQgPSBBU0NJSUxvd2VyY2FzZShUKTtcbiAgfVxuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShyLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBUKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEdXJhdGlvbihlKSB7XG4gIGlmIChJc1RlbXBvcmFsRHVyYXRpb24oZSkpIHJldHVybiBlO1xuICB2YXIgX1RvVGVtcG9yYWxEdXJhdGlvblJlID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpLFxuICAgIHQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUueWVhcnMsXG4gICAgciA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5tb250aHMsXG4gICAgbyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS53ZWVrcyxcbiAgICBuID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlLmRheXMsXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5ob3VycyxcbiAgICBpID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlLm1pbnV0ZXMsXG4gICAgcyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5zZWNvbmRzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubWlsbGlzZWNvbmRzLFxuICAgIGQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubWljcm9zZWNvbmRzLFxuICAgIG0gPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubmFub3NlY29uZHM7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbEluc3RhbnQoZSkge1xuICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoZSkpIHJldHVybiBlO1xuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHtcbiAgICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKEdldFNsb3QoZSwgbikpO1xuICB9XG4gIHZhciB0ID0gUGFyc2VUZW1wb3JhbEluc3RhbnQoVG9TdHJpbmcoZSkpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKHQpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE1vbnRoRGF5KGUsIHQpIHtcbiAgdmFyIHIgPSBlO1xuICBpZiAoSXNPYmplY3QocikpIHtcbiAgICBpZiAoSXNUZW1wb3JhbE1vbnRoRGF5KHIpKSByZXR1cm4gcjtcbiAgICB2YXIgX2UxMywgX282O1xuICAgIGlmIChIYXNTbG90KHIsIHApKSBfZTEzID0gR2V0U2xvdChyLCBwKSwgX282ID0gITE7ZWxzZSB7XG4gICAgICB2YXIgX3QxMiA9IHIuY2FsZW5kYXI7XG4gICAgICBfbzYgPSB2b2lkIDAgPT09IF90MTIsIHZvaWQgMCA9PT0gX3QxMiAmJiAoX3QxMiA9IFwiaXNvODYwMVwiKSwgX2UxMyA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShfdDEyKTtcbiAgICB9XG4gICAgdmFyIF9uMyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhyLCBDYWxlbmRhckZpZWxkcyhfZTEzLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSk7XG4gICAgcmV0dXJuIF9vNiAmJiB2b2lkIDAgIT09IF9uMy5tb250aCAmJiB2b2lkIDAgPT09IF9uMy5tb250aENvZGUgJiYgdm9pZCAwID09PSBfbjMueWVhciAmJiAoX24zLnllYXIgPSAxOTcyKSwgQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoX2UxMywgX24zLCB0KTtcbiAgfVxuICBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gIHZhciBfUGFyc2VUZW1wb3JhbE1vbnRoRGEgPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoVG9TdHJpbmcocikpLFxuICAgIG8gPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEubW9udGgsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYS5kYXksXG4gICAgYSA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYS5yZWZlcmVuY2VJU09ZZWFyLFxuICAgIGkgPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEuY2FsZW5kYXI7XG4gIGlmICh2b2lkIDAgPT09IGkgJiYgKGkgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcihpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KGkpKTtcbiAgaWYgKGkgPSBBU0NJSUxvd2VyY2FzZShpKSwgdm9pZCAwID09PSBhKSByZXR1cm4gUmVqZWN0SVNPRGF0ZSgxOTcyLCBvLCBuKSwgQ3JlYXRlVGVtcG9yYWxNb250aERheShvLCBuLCBpKTtcbiAgcmV0dXJuIENhbGVuZGFyTW9udGhEYXlGcm9tRmllbGRzKGksIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobywgbiwgaSwgYSkpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWUoZSkge1xuICB2YXIgX1BhcnNlVGVtcG9yYWxUaW1lU3RyO1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJjb25zdHJhaW5cIjtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwgPSBlO1xuICBpZiAoSXNPYmplY3QobCkpIHtcbiAgICB2YXIgX1RvVGVtcG9yYWxUaW1lUmVjb3JkMiwgX1JlZ3VsYXRlVGltZTI7XG4gICAgaWYgKElzVGVtcG9yYWxUaW1lKGwpKSByZXR1cm4gbDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUobCkgJiYgKGwgPSBHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QobCwgZyksIEdldFNsb3QobCwgUyksIEdldFNsb3QobCwgcCkpKSwgSXNUZW1wb3JhbERhdGVUaW1lKGwpKSB7XG4gICAgICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkoR2V0U2xvdChsLCBkKSwgR2V0U2xvdChsLCBtKSwgR2V0U2xvdChsLCBjKSwgR2V0U2xvdChsLCBoKSwgR2V0U2xvdChsLCB1KSwgR2V0U2xvdChsLCBUKSk7XG4gICAgfVxuICAgIChfVG9UZW1wb3JhbFRpbWVSZWNvcmQyID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQobCksIHIgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLmhvdXIsIG8gPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLm1pbnV0ZSwgbiA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZDIuc2Vjb25kLCBhID0gX1RvVGVtcG9yYWxUaW1lUmVjb3JkMi5taWxsaXNlY29uZCwgaSA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZDIubWljcm9zZWNvbmQsIHMgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLm5hbm9zZWNvbmQpLCAoX1JlZ3VsYXRlVGltZTIgPSBSZWd1bGF0ZVRpbWUociwgbywgbiwgYSwgaSwgcywgdCksIHIgPSBfUmVndWxhdGVUaW1lMi5ob3VyLCBvID0gX1JlZ3VsYXRlVGltZTIubWludXRlLCBuID0gX1JlZ3VsYXRlVGltZTIuc2Vjb25kLCBhID0gX1JlZ3VsYXRlVGltZTIubWlsbGlzZWNvbmQsIGkgPSBfUmVndWxhdGVUaW1lMi5taWNyb3NlY29uZCwgcyA9IF9SZWd1bGF0ZVRpbWUyLm5hbm9zZWNvbmQpO1xuICB9IGVsc2UgKF9QYXJzZVRlbXBvcmFsVGltZVN0ciA9IGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxUaW1lU3RyaW5nKGUpIHtcbiAgICB2YXIgdCA9IHouZXhlYyhlKTtcbiAgICB2YXIgciwgbywgbiwgYSwgaSwgcywgbDtcbiAgICBpZiAodCkge1xuICAgICAgciA9IFRvSW50ZWdlck9ySW5maW5pdHkodFsxXSksIG8gPSBUb0ludGVnZXJPckluZmluaXR5KHRbMl0gfHwgdFs1XSksIG4gPSBUb0ludGVnZXJPckluZmluaXR5KHRbM10gfHwgdFs2XSksIDYwID09PSBuICYmIChuID0gNTkpO1xuICAgICAgdmFyIF9lMTQgPSAodFs0XSB8fCB0WzddKSArIFwiMDAwMDAwMDAwXCI7XG4gICAgICBhID0gVG9JbnRlZ2VyT3JJbmZpbml0eShfZTE0LnNsaWNlKDAsIDMpKSwgaSA9IFRvSW50ZWdlck9ySW5maW5pdHkoX2UxNC5zbGljZSgzLCA2KSksIHMgPSBUb0ludGVnZXJPckluZmluaXR5KF9lMTQuc2xpY2UoNiwgOSkpLCBsID0gdFsxNF07XG4gICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsLm1hdGNoQWxsKEgpKSxcbiAgICAgICAgX3N0ZXAxMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEwLnZhbHVlLCA0KSxcbiAgICAgICAgICAgIF9lMTUgPSBfc3RlcDEwJHZhbHVlWzFdLFxuICAgICAgICAgICAgX3QxMyA9IF9zdGVwMTAkdmFsdWVbMl0sXG4gICAgICAgICAgICBfcjEwID0gX3N0ZXAxMCR2YWx1ZVszXTtcbiAgICAgICAgICBpZiAoXCJ1LWNhXCIgIT09IF90MTMgJiYgXCIhXCIgPT09IF9lMTUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5yZWNvZ25pemVkIGFubm90YXRpb246ICFcIi5jb25jYXQoX3QxMywgXCI9XCIpLmNvbmNhdChfcjEwKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMC5mKCk7XG4gICAgICB9XG4gICAgICBpZiAodFs4XSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5UaW1lXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX1BhcnNlSVNPRGF0ZVRpbWU0O1xuICAgICAgdmFyIF90MTQsIF9sO1xuICAgICAgaWYgKChfUGFyc2VJU09EYXRlVGltZTQgPSBQYXJzZUlTT0RhdGVUaW1lKGUpLCBfbCA9IF9QYXJzZUlTT0RhdGVUaW1lNC5oYXNUaW1lLCByID0gX1BhcnNlSVNPRGF0ZVRpbWU0LmhvdXIsIG8gPSBfUGFyc2VJU09EYXRlVGltZTQubWludXRlLCBuID0gX1BhcnNlSVNPRGF0ZVRpbWU0LnNlY29uZCwgYSA9IF9QYXJzZUlTT0RhdGVUaW1lNC5taWxsaXNlY29uZCwgaSA9IF9QYXJzZUlTT0RhdGVUaW1lNC5taWNyb3NlY29uZCwgcyA9IF9QYXJzZUlTT0RhdGVUaW1lNC5uYW5vc2Vjb25kLCBfdDE0ID0gX1BhcnNlSVNPRGF0ZVRpbWU0LnopLCAhX2wpIHRocm93IG5ldyBSYW5nZUVycm9yKFwidGltZSBpcyBtaXNzaW5nIGluIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgICAgIGlmIChfdDE0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpblRpbWVcIik7XG4gICAgfVxuICAgIGlmICgvW3RUIF1bMC05XVswLTldLy50ZXN0KGUpKSByZXR1cm4ge1xuICAgICAgaG91cjogcixcbiAgICAgIG1pbnV0ZTogbyxcbiAgICAgIHNlY29uZDogbixcbiAgICAgIG1pbGxpc2Vjb25kOiBhLFxuICAgICAgbWljcm9zZWNvbmQ6IGksXG4gICAgICBuYW5vc2Vjb25kOiBzXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgdmFyIF9QYXJzZVRlbXBvcmFsTW9udGhEYTIgPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoZSksXG4gICAgICAgIF90MTUgPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEyLm1vbnRoLFxuICAgICAgICBfcjExID0gX1BhcnNlVGVtcG9yYWxNb250aERhMi5kYXk7XG4gICAgICBSZWplY3RJU09EYXRlKDE5NzIsIF90MTUsIF9yMTEpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX1BhcnNlVGVtcG9yYWxZZWFyTW9uID0gUGFyc2VUZW1wb3JhbFllYXJNb250aFN0cmluZyhlKSxcbiAgICAgICAgICBfdDE2ID0gX1BhcnNlVGVtcG9yYWxZZWFyTW9uLnllYXIsXG4gICAgICAgICAgX3IxMiA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbi5tb250aDtcbiAgICAgICAgUmVqZWN0SVNPRGF0ZShfdDE2LCBfcjEyLCAxKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG91cjogcixcbiAgICAgICAgICBtaW51dGU6IG8sXG4gICAgICAgICAgc2Vjb25kOiBuLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBhLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiBpLFxuICAgICAgICAgIG5hbm9zZWNvbmQ6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHRpbWUtb25seSBzdHJpbmcgXCIuY29uY2F0KGUsIFwiOyBtYXkgbmVlZCBhIFQgcHJlZml4XCIpKTtcbiAgfShUb1N0cmluZyhsKSksIHIgPSBfUGFyc2VUZW1wb3JhbFRpbWVTdHIuaG91ciwgbyA9IF9QYXJzZVRlbXBvcmFsVGltZVN0ci5taW51dGUsIG4gPSBfUGFyc2VUZW1wb3JhbFRpbWVTdHIuc2Vjb25kLCBhID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm1pbGxpc2Vjb25kLCBpID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm1pY3Jvc2Vjb25kLCBzID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm5hbm9zZWNvbmQpLCBSZWplY3RUaW1lKHIsIG8sIG4sIGEsIGksIHMpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkociwgbywgbiwgYSwgaSwgcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWWVhck1vbnRoKGUsIHQpIHtcbiAgaWYgKElzT2JqZWN0KGUpKSB7XG4gICAgaWYgKElzVGVtcG9yYWxZZWFyTW9udGgoZSkpIHJldHVybiBlO1xuICAgIHZhciBfcjEzID0gR2V0VGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZVdpdGhJU09EZWZhdWx0KGUpO1xuICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoX3IxMywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIENhbGVuZGFyRmllbGRzKF9yMTMsIFtcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSwgdCk7XG4gIH1cbiAgVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICB2YXIgX1BhcnNlVGVtcG9yYWxZZWFyTW9uMiA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoVG9TdHJpbmcoZSkpLFxuICAgIHIgPSBfUGFyc2VUZW1wb3JhbFllYXJNb24yLnllYXIsXG4gICAgbyA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjIubW9udGgsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjIucmVmZXJlbmNlSVNPRGF5LFxuICAgIGEgPSBfUGFyc2VUZW1wb3JhbFllYXJNb24yLmNhbGVuZGFyO1xuICBpZiAodm9pZCAwID09PSBhICYmIChhID0gXCJpc284NjAxXCIpLCAhSXNCdWlsdGluQ2FsZW5kYXIoYSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdChhKSk7XG4gIGlmIChhID0gQVNDSUlMb3dlcmNhc2UoYSksIHZvaWQgMCA9PT0gbikgcmV0dXJuIFJlamVjdElTT0RhdGUociwgbywgMSksIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHIsIG8sIGEpO1xuICByZXR1cm4gQ2FsZW5kYXJZZWFyTW9udGhGcm9tRmllbGRzKGEsIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHIsIG8sIGEsIG4pKTtcbn1cbmZ1bmN0aW9uIEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHQsIHIsIG8sIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQsIHAsIGYsIHkpIHtcbiAgdmFyIEkgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSkodCwgciwgbywgaSwgcywgbCwgZCwgbSwgYyk7XG4gIGlmIChcIndhbGxcIiA9PT0gaCB8fCBcImlnbm9yZVwiID09PSBmKSB7XG4gICAgcmV0dXJuIEdldFNsb3QoR2V0SW5zdGFudEZvcihULCBJLCBwKSwgbik7XG4gIH1cbiAgaWYgKFwiZXhhY3RcIiA9PT0gaCB8fCBcInVzZVwiID09PSBmKSB7XG4gICAgdmFyIF9uNCA9IEdldFVUQ0Vwb2NoTmFub3NlY29uZHModCwgciwgbywgaSwgcywgbCwgZCwgbSwgYyk7XG4gICAgaWYgKG51bGwgPT09IF9uNCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJab25lZERhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlXCIpO1xuICAgIHJldHVybiBfbjQgLSBCaWdJbnQodSk7XG4gIH1cbiAgdmFyIFMgPSBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKFQsIEkpO1xuICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihTKSxcbiAgICBfc3RlcDExO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3QxOCA9IF9zdGVwMTEudmFsdWU7XG4gICAgICB2YXIgX3IxNCA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKFQsIF90MTgpLFxuICAgICAgICBfbzcgPSBOdW1iZXIoUm91bmROdW1iZXJUb0luY3JlbWVudChCaWdJbnQoX3IxNCksIGJlLCBcImhhbGZFeHBhbmRcIikpO1xuICAgICAgaWYgKF9yMTQgPT09IHUgfHwgeSAmJiBfbzcgPT09IHUpIHJldHVybiBHZXRTbG90KF90MTgsIG4pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTEuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjExLmYoKTtcbiAgfVxuICBpZiAoXCJyZWplY3RcIiA9PT0gZikge1xuICAgIHZhciBfZTE2ID0gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcodSksXG4gICAgICBfdDE3ID0gSXNUZW1wb3JhbFRpbWVab25lKFQpID8gR2V0U2xvdChULCBhKSA6IFwidGltZSB6b25lXCI7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPZmZzZXQgXCIuY29uY2F0KF9lMTYsIFwiIGlzIGludmFsaWQgZm9yIFwiKS5jb25jYXQoSS50b1N0cmluZygpLCBcIiBpbiBcIikuY29uY2F0KF90MTcpKTtcbiAgfVxuICByZXR1cm4gR2V0U2xvdChEaXNhbWJpZ3VhdGVQb3NzaWJsZUluc3RhbnRzKFMsIFQsIEksIHApLCBuKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwsXG4gICAgZCxcbiAgICBtLFxuICAgIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQsXG4gICAgcCxcbiAgICBmID0gITEsXG4gICAgeSA9IFwib3B0aW9uXCI7XG4gIGlmIChJc09iamVjdChlKSkge1xuICAgIHZhciBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkgcmV0dXJuIGU7XG4gICAgdSA9IEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChlKTtcbiAgICB2YXIgX2Y0ID0gQ2FsZW5kYXJGaWVsZHModSwgW1wiZGF5XCIsIFwiaG91clwiLCBcIm1pY3Jvc2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcIm5hbm9zZWNvbmRcIiwgXCJzZWNvbmRcIiwgXCJ5ZWFyXCJdKTtcbiAgICBfZjQucHVzaChcInRpbWVab25lXCIsIFwib2Zmc2V0XCIpO1xuICAgIHZhciBfSSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBfZjQsIFtcInRpbWVab25lXCJdKTtcbiAgICBjID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9JLnRpbWVab25lKSwgaCA9IF9JLm9mZnNldCwgdm9pZCAwID09PSBoICYmICh5ID0gXCJ3YWxsXCIpLCBUID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKHQpLCBwID0gVG9UZW1wb3JhbE9mZnNldCh0LCBcInJlamVjdFwiKSwgKF9JbnRlcnByZXRUZW1wb3JhbERhdDMgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKHUsIF9JLCB0KSwgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMueWVhciwgbyA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubW9udGgsIG4gPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzLmRheSwgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMuaG91ciwgaSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubWludXRlLCBzID0gX0ludGVycHJldFRlbXBvcmFsRGF0My5zZWNvbmQsIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzLm1pbGxpc2Vjb25kLCBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0My5taWNyb3NlY29uZCwgbSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubmFub3NlY29uZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZVRlbXBvcmFsWm9uZWREYTtcbiAgICB2YXIgX0kyLCBfUztcbiAgICBpZiAoKF9QYXJzZVRlbXBvcmFsWm9uZWREYSA9IGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxab25lZERhdGVUaW1lU3RyaW5nKGUpIHtcbiAgICAgIHZhciB0ID0gUGFyc2VJU09EYXRlVGltZShlKTtcbiAgICAgIGlmICghdC5pYW5hTmFtZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZW1wb3JhbC5ab25lZERhdGVUaW1lIHJlcXVpcmVzIGEgdGltZSB6b25lIElEIGluIGJyYWNrZXRzXCIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfShUb1N0cmluZyhlKSksIHIgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEueWVhciwgbyA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5tb250aCwgbiA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5kYXksIGEgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuaG91ciwgaSA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5taW51dGUsIHMgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuc2Vjb25kLCBsID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm1pbGxpc2Vjb25kLCBkID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm1pY3Jvc2Vjb25kLCBtID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm5hbm9zZWNvbmQsIF9JMiA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5pYW5hTmFtZSwgaCA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5vZmZzZXQsIF9TID0gX1BhcnNlVGVtcG9yYWxab25lZERhLnosIHUgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuY2FsZW5kYXIpLCBjID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9JMiksIF9TID8geSA9IFwiZXhhY3RcIiA6IGggfHwgKHkgPSBcIndhbGxcIiksIHUgfHwgKHUgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcih1KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KHUpKTtcbiAgICB1ID0gQVNDSUlMb3dlcmNhc2UodSksIGYgPSAhMCwgVCA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbih0KSwgcCA9IFRvVGVtcG9yYWxPZmZzZXQodCwgXCJyZWplY3RcIiksIFRvVGVtcG9yYWxPdmVyZmxvdyh0KTtcbiAgfVxuICB2YXIgSSA9IDA7XG4gIFwib3B0aW9uXCIgPT09IHkgJiYgKEkgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKGgpKTtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldChyLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCB5LCBJLCBjLCBULCBwLCBmKSwgYywgdSk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVTbG90cyhlLCB0LCByLCBvLCBuKSB7XG4gIFJlamVjdElTT0RhdGUodCwgciwgbyksIFJlamVjdERhdGVSYW5nZSh0LCByLCBvKSwgTihlKSwgU2V0U2xvdChlLCBpLCB0KSwgU2V0U2xvdChlLCBzLCByKSwgU2V0U2xvdChlLCBsLCBvKSwgU2V0U2xvdChlLCBwLCBuKSwgU2V0U2xvdChlLCBmLCAhMCk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJpc284NjAxXCI7XG4gIHZhciBuID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZSVcIiksXG4gICAgYSA9IFRlKG4ucHJvdG90eXBlKTtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKGUsIHQsIHIsIG8sIG4sIGEsIGYsIHksIEksIFMsIGcpIHtcbiAgUmVqZWN0RGF0ZVRpbWUodCwgciwgbywgbiwgYSwgZiwgeSwgSSwgUyksIFJlamVjdERhdGVUaW1lUmFuZ2UodCwgciwgbywgbiwgYSwgZiwgeSwgSSwgUyksIE4oZSksIFNldFNsb3QoZSwgaSwgdCksIFNldFNsb3QoZSwgcywgciksIFNldFNsb3QoZSwgbCwgbyksIFNldFNsb3QoZSwgZCwgbiksIFNldFNsb3QoZSwgbSwgYSksIFNldFNsb3QoZSwgYywgZiksIFNldFNsb3QoZSwgaCwgeSksIFNldFNsb3QoZSwgdSwgSSksIFNldFNsb3QoZSwgVCwgUyksIFNldFNsb3QoZSwgcCwgZyk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwpIHtcbiAgdmFyIGQgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICBjID0gVGUobS5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKGMsIGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpLCBjO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKGUsIHQsIHIsIG8sIG4pIHtcbiAgUmVqZWN0SVNPRGF0ZShuLCB0LCByKSwgUmVqZWN0RGF0ZVJhbmdlKG4sIHQsIHIpLCBOKGUpLCBTZXRTbG90KGUsIHMsIHQpLCBTZXRTbG90KGUsIGwsIHIpLCBTZXRTbG90KGUsIGksIG4pLCBTZXRTbG90KGUsIHAsIG8pLCBTZXRTbG90KGUsIEksICEwKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxOTcyO1xuICB2YXIgbiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbk1vbnRoRGF5JVwiKSxcbiAgICBhID0gVGUobi5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cyhlLCB0LCByLCBvLCBuKSB7XG4gIFJlamVjdElTT0RhdGUodCwgciwgbiksIGZ1bmN0aW9uIFJlamVjdFllYXJNb250aFJhbmdlKGUsIHQpIHtcbiAgICBSZWplY3RUb1JhbmdlKGUsIEZlLCBZZSksIGUgPT09IEZlID8gUmVqZWN0VG9SYW5nZSh0LCA0LCAxMikgOiBlID09PSBZZSAmJiBSZWplY3RUb1JhbmdlKHQsIDEsIDkpO1xuICB9KHQsIHIpLCBOKGUpLCBTZXRTbG90KGUsIGksIHQpLCBTZXRTbG90KGUsIHMsIHIpLCBTZXRTbG90KGUsIGwsIG4pLCBTZXRTbG90KGUsIHAsIG8pLCBTZXRTbG90KGUsIHksICEwKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKGUsIHQpIHtcbiAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgdmFyIG4gPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5ZZWFyTW9udGglXCIpLFxuICAgIGEgPSBUZShuLnByb3RvdHlwZSk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMoZSwgdCwgciwgbykge1xuICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHModCksIE4oZSksIFNldFNsb3QoZSwgbiwgdCksIFNldFNsb3QoZSwgZywgciksIFNldFNsb3QoZSwgcCwgbyk7XG4gIHZhciBhID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKEdldFNsb3QoZSwgbikpO1xuICBTZXRTbG90KGUsIFMsIGEpO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbyA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5ab25lZERhdGVUaW1lJVwiKSxcbiAgICBuID0gVGUoby5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMobiwgZSwgdCwgciksIG47XG59XG5mdW5jdGlvbiBDYWxlbmRhckZpZWxkcyhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMTUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZmllbGRzJVwiKSwgX3IxNSwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwiZmllbGRzXCIpLCBlLCBbdF0pLFxuICAgIG8gPSBbXTtcbiAgdmFyIF9pdGVyYXRvcjEyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociksXG4gICAgX3N0ZXAxMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9lMTcgPSBfc3RlcDEyLnZhbHVlO1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIF9lMTcpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gY2FsZW5kYXIuZmllbGRzKClcIik7XG4gICAgICB0ZS5jYWxsKG8sIF9lMTcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjEyLmYoKTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTWVyZ2VGaWVsZHMoZSwgdCwgcikge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbzggPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubWVyZ2VGaWVsZHMlXCIpLCBfbzgsIFt0LCByXSk7XG4gIH1cbiAgdmFyIG8gPSBDYWxsKEdldE1ldGhvZChlLCBcIm1lcmdlRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzT2JqZWN0KG8pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYmFkIHJldHVybiBmcm9tIGNhbGVuZGFyLm1lcmdlRmllbGRzKClcIik7XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlQWRkKGUsIHQsIHIsIG8sIG4pIHtcbiAgdmFyIGEgPSBuO1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbjUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF0ZUFkZCVcIiksIF9uNSwgW3QsIHIsIG9dKTtcbiAgfVxuICB2b2lkIDAgPT09IGEgJiYgKGEgPSBHZXRNZXRob2QoZSwgXCJkYXRlQWRkXCIpKTtcbiAgdmFyIGkgPSBmZShhLCBlLCBbdCwgciwgb10pO1xuICBpZiAoIUlzVGVtcG9yYWxEYXRlKGkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZXN1bHRcIik7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlVW50aWwoZSwgdCwgciwgbywgbikge1xuICB2YXIgYSA9IG47XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9uNiA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXRlVW50aWwlXCIpLCBfbjYsIFt0LCByLCBvXSk7XG4gIH1cbiAgdm9pZCAwID09PSBhICYmIChhID0gR2V0TWV0aG9kKGUsIFwiZGF0ZVVudGlsXCIpKTtcbiAgdmFyIGkgPSBmZShhLCBlLCBbdCwgciwgb10pO1xuICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbihpKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVzdWx0XCIpO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyWWVhcihlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMTYgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhciVcIiksIF9yMTYsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcInllYXJcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGgoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjE3ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoJVwiKSwgX3IxNywgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwibW9udGhcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGhDb2RlKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IxOCA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5tb250aENvZGUlXCIpLCBfcjE4LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJtb250aENvZGVcIiksIGUsIFt0XSk7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgbW9udGhDb2RlIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5KGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IxOSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXklXCIpLCBfcjE5LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5IHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheSByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcmEoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjIwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmVyYSVcIiksIF9yMjAsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImVyYVwiKSwgZSwgW3RdKTtcbiAgaWYgKHZvaWQgMCA9PT0gcikgcmV0dXJuIHI7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZXJhIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckVyYVllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjIxID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmVyYVllYXIlXCIpLCBfcjIxLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJlcmFZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAodm9pZCAwID09PSByKSByZXR1cm4gcjtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBlcmFZZWFyIHJlc3VsdCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdW5kZWZpbmVkXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgZXJhWWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheU9mV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjIgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZXZWVrJVwiKSwgX3IyMiwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwiZGF5T2ZXZWVrXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheU9mV2VlayByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihyKSB8fCByIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciBkYXlPZldlZWsgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5T2ZZZWFyKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyMyA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlPZlllYXIlXCIpLCBfcjIzLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlPZlllYXJcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5T2ZZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheU9mWWVhciByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJXZWVrT2ZZZWFyKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyNCA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS53ZWVrT2ZZZWFyJVwiKSwgX3IyNCwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwid2Vla09mWWVhclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciB3ZWVrT2ZZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIHdlZWtPZlllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyWWVhck9mV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2VlayVcIiksIF9yMjUsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcInllYXJPZldlZWtcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgeWVhck9mV2VlayByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgeWVhck9mV2VlayByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjYgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF5c0luV2VlayVcIiksIF9yMjYsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImRheXNJbldlZWtcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5c0luV2VlayByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihyKSB8fCByIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciBkYXlzSW5XZWVrIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheXNJbk1vbnRoKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyNyA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5Nb250aCVcIiksIF9yMjcsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImRheXNJbk1vbnRoXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheXNJbk1vbnRoIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheXNJbk1vbnRoIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheXNJblllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjI4ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXIlXCIpLCBfcjI4LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlzSW5ZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheXNJblllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgZGF5c0luWWVhciByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJNb250aHNJblllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjI5ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoc0luWWVhciVcIiksIF9yMjksIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcIm1vbnRoc0luWWVhclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBtb250aHNJblllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgbW9udGhzSW5ZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckluTGVhcFllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjMwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmluTGVhcFllYXIlXCIpLCBfcjMwLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJpbkxlYXBZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJib29sZWFuXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBpbkxlYXBZZWFyIHJlc3VsdCBtdXN0IGJlIGEgYm9vbGVhblwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUoZSkge1xuICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICBpZiAoSGFzU2xvdChlLCBwKSkgcmV0dXJuIEdldFNsb3QoZSwgcCk7XG4gICAgaWYgKCFmdW5jdGlvbiBPYmplY3RJbXBsZW1lbnRzVGVtcG9yYWxDYWxlbmRhclByb3RvY29sKGUpIHtcbiAgICAgIHJldHVybiAhIUlzVGVtcG9yYWxDYWxlbmRhcihlKSB8fCBcImRhdGVBZGRcIiBpbiBlICYmIFwiZGF0ZUZyb21GaWVsZHNcIiBpbiBlICYmIFwiZGF0ZVVudGlsXCIgaW4gZSAmJiBcImRheVwiIGluIGUgJiYgXCJkYXlPZldlZWtcIiBpbiBlICYmIFwiZGF5T2ZZZWFyXCIgaW4gZSAmJiBcImRheXNJbk1vbnRoXCIgaW4gZSAmJiBcImRheXNJbldlZWtcIiBpbiBlICYmIFwiZGF5c0luWWVhclwiIGluIGUgJiYgXCJmaWVsZHNcIiBpbiBlICYmIFwiaWRcIiBpbiBlICYmIFwiaW5MZWFwWWVhclwiIGluIGUgJiYgXCJtZXJnZUZpZWxkc1wiIGluIGUgJiYgXCJtb250aFwiIGluIGUgJiYgXCJtb250aENvZGVcIiBpbiBlICYmIFwibW9udGhEYXlGcm9tRmllbGRzXCIgaW4gZSAmJiBcIm1vbnRoc0luWWVhclwiIGluIGUgJiYgXCJ3ZWVrT2ZZZWFyXCIgaW4gZSAmJiBcInllYXJcIiBpbiBlICYmIFwieWVhck1vbnRoRnJvbUZpZWxkc1wiIGluIGUgJiYgXCJ5ZWFyT2ZXZWVrXCIgaW4gZTtcbiAgICB9KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0ZWQgYSBUZW1wb3JhbC5DYWxlbmRhciBvciBvYmplY3QgaW1wbGVtZW50aW5nIHRoZSBUZW1wb3JhbC5DYWxlbmRhciBwcm90b2NvbFwiKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICB2YXIgdCA9IFRvU3RyaW5nKGUpO1xuICBpZiAoSXNCdWlsdGluQ2FsZW5kYXIodCkpIHJldHVybiBBU0NJSUxvd2VyY2FzZSh0KTtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lNSA9IFBhcnNlSVNPRGF0ZVRpbWUodCk7XG4gICAgciA9IF9QYXJzZUlTT0RhdGVUaW1lNS5jYWxlbmRhcjtcbiAgfSBjYXRjaCAoX3VudXNlZDQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9QYXJzZVRlbXBvcmFsWWVhck1vbjMgPSBQYXJzZVRlbXBvcmFsWWVhck1vbnRoU3RyaW5nKHQpO1xuICAgICAgciA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjMuY2FsZW5kYXI7XG4gICAgfSBjYXRjaCAoX3VudXNlZDUpIHtcbiAgICAgIHZhciBfUGFyc2VUZW1wb3JhbE1vbnRoRGEzID0gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKHQpO1xuICAgICAgciA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYTMuY2FsZW5kYXI7XG4gICAgfVxuICB9XG4gIGlmIChyIHx8IChyID0gXCJpc284NjAxXCIpLCAhSXNCdWlsdGluQ2FsZW5kYXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdChyKSk7XG4gIHJldHVybiBBU0NJSUxvd2VyY2FzZShyKTtcbn1cbmZ1bmN0aW9uIEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChlKSB7XG4gIGlmIChIYXNTbG90KGUsIHApKSByZXR1cm4gR2V0U2xvdChlLCBwKTtcbiAgdmFyIHQgPSBlLmNhbGVuZGFyO1xuICByZXR1cm4gdm9pZCAwID09PSB0ID8gXCJpc284NjAxXCIgOiBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUodCk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKGUpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBlO1xuICB2YXIgdCA9IGUuaWQ7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIuaWQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChlKSB7XG4gIGlmIChJc09iamVjdChlKSkgcmV0dXJuIGU7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcXVhbHMoZSwgdCkge1xuICBpZiAoZSA9PT0gdCkgcmV0dXJuICEwO1xuICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihlKSA9PT0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcih0KTtcbn1cbmZ1bmN0aW9uIFRocm93SWZDYWxlbmRhcnNOb3RFcXVhbChlLCB0LCByKSB7XG4gIGlmIChlID09PSB0KSByZXR1cm47XG4gIHZhciBvID0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihlKSxcbiAgICBuID0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcih0KTtcbiAgaWYgKG8gIT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IFwiLmNvbmNhdChyLCBcIiBvZiBcIikuY29uY2F0KG8sIFwiIGFuZCBcIikuY29uY2F0KG4sIFwiIGNhbGVuZGFyc1wiKSk7XG59XG5mdW5jdGlvbiBDb25zb2xpZGF0ZUNhbGVuZGFycyhlLCB0KSB7XG4gIGlmIChlID09PSB0KSByZXR1cm4gdDtcbiAgdmFyIHIgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKGUpLFxuICAgIG8gPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKHQpO1xuICBpZiAociA9PT0gbyB8fCBcImlzbzg2MDFcIiA9PT0gcikgcmV0dXJuIHQ7XG4gIGlmIChcImlzbzg2MDFcIiA9PT0gbykgcmV0dXJuIGU7XG4gIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaXJyZWNvbmNpbGFibGUgY2FsZW5kYXJzXCIpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhlLCB0LCByLCBvKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9vOSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXRlRnJvbUZpZWxkcyVcIiksIF9vOSwgW3QsIHJdKTtcbiAgfVxuICB2YXIgbiA9IENhbGwobyAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogR2V0TWV0aG9kKGUsIFwiZGF0ZUZyb21GaWVsZHNcIiksIGUsIFt0LCByXSk7XG4gIGlmICghSXNUZW1wb3JhbERhdGUobikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgdCwgcikge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbzEwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHMlXCIpLCBfbzEwLCBbdCwgcl0pO1xuICB9XG4gIHZhciBvID0gQ2FsbChHZXRNZXRob2QoZSwgXCJ5ZWFyTW9udGhGcm9tRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgobykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBDYWxlbmRhck1vbnRoRGF5RnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9vMTEgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhEYXlGcm9tRmllbGRzJVwiKSwgX28xMSwgW3QsIHJdKTtcbiAgfVxuICB2YXIgbyA9IENhbGwoR2V0TWV0aG9kKGUsIFwibW9udGhEYXlGcm9tRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzVGVtcG9yYWxNb250aERheShvKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVzdWx0XCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKSB7XG4gIGlmIChJc09iamVjdChlKSkge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkgcmV0dXJuIEdldFNsb3QoZSwgZyk7XG4gICAgaWYgKCFmdW5jdGlvbiBPYmplY3RJbXBsZW1lbnRzVGVtcG9yYWxUaW1lWm9uZVByb3RvY29sKGUpIHtcbiAgICAgIHJldHVybiAhIUlzVGVtcG9yYWxUaW1lWm9uZShlKSB8fCBcImdldE9mZnNldE5hbm9zZWNvbmRzRm9yXCIgaW4gZSAmJiBcImdldFBvc3NpYmxlSW5zdGFudHNGb3JcIiBpbiBlICYmIFwiaWRcIiBpbiBlO1xuICAgIH0oZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCBhIFRlbXBvcmFsLlRpbWVab25lIG9yIG9iamVjdCBpbXBsZW1lbnRpbmcgdGhlIFRlbXBvcmFsLlRpbWVab25lIHByb3RvY29sXCIpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBQYXJzZVRlbXBvcmFsVGltZVpvbmUoVG9TdHJpbmcoZSkpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihlKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gZTtcbiAgdmFyIHQgPSBlLmlkO1xuICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRpbWVab25lLmlkIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVpvbmVPYmplY3QoZSkge1xuICBpZiAoSXNPYmplY3QoZSkpIHJldHVybiBlO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuVGltZVpvbmUlXCIpKShlKTtcbn1cbmZ1bmN0aW9uIFRpbWVab25lRXF1YWxzKGUsIHQpIHtcbiAgaWYgKGUgPT09IHQpIHJldHVybiAhMDtcbiAgcmV0dXJuIFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIoZSkgPT09IFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIodCk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGUpIHtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KGUsIHApKTtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUoZSkge1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkoR2V0U2xvdChlLCBkKSwgR2V0U2xvdChlLCBtKSwgR2V0U2xvdChlLCBjKSwgR2V0U2xvdChlLCBoKSwgR2V0U2xvdChlLCB1KSwgR2V0U2xvdChlLCBUKSk7XG59XG5mdW5jdGlvbiBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihlLCB0LCByKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMzEgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5UaW1lWm9uZSVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5UaW1lWm9uZS5wcm90b3R5cGUuZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IlXCIpLCBfcjMxLCBbdF0pO1xuICB9XG4gIHZhciBvID0gQ2FsbChyICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBHZXRNZXRob2QoZSwgXCJnZXRPZmZzZXROYW5vc2Vjb25kc0ZvclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihvKSB8fCBhZShvKSA+PSA4NjRlMTEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0LW9mLXJhbmdlIHJldHVybiBmcm9tIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yXCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEdldE9mZnNldFN0cmluZ0ZvcihlLCB0KSB7XG4gIHJldHVybiBGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyhHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihlLCB0KSk7XG59XG5mdW5jdGlvbiBHZXRQbGFpbkRhdGVUaW1lRm9yKGUsIHQsIHIpIHtcbiAgdmFyIF9CYWxhbmNlSVNPRGF0ZVRpbWUyO1xuICB2YXIgbyA9IEdldFNsb3QodCwgbiksXG4gICAgYSA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKGUsIHQpO1xuICB2YXIgX0dldElTT1BhcnRzRnJvbUVwb2NoID0gR2V0SVNPUGFydHNGcm9tRXBvY2gobyksXG4gICAgaSA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC55ZWFyLFxuICAgIHMgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubW9udGgsXG4gICAgbCA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5kYXksXG4gICAgZCA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5ob3VyLFxuICAgIG0gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubWludXRlLFxuICAgIGMgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2guc2Vjb25kLFxuICAgIGggPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubWlsbGlzZWNvbmQsXG4gICAgdSA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5taWNyb3NlY29uZCxcbiAgICBUID0gX0dldElTT1BhcnRzRnJvbUVwb2NoLm5hbm9zZWNvbmQ7XG4gIHJldHVybiAoX0JhbGFuY2VJU09EYXRlVGltZTIgPSBCYWxhbmNlSVNPRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCArIGEpLCBpID0gX0JhbGFuY2VJU09EYXRlVGltZTIueWVhciwgcyA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1vbnRoLCBsID0gX0JhbGFuY2VJU09EYXRlVGltZTIuZGF5LCBkID0gX0JhbGFuY2VJU09EYXRlVGltZTIuaG91ciwgbSA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1pbnV0ZSwgYyA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLnNlY29uZCwgaCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1pbGxpc2Vjb25kLCB1ID0gX0JhbGFuY2VJU09EYXRlVGltZTIubWljcm9zZWNvbmQsIFQgPSBfQmFsYW5jZUlTT0RhdGVUaW1lMi5uYW5vc2Vjb25kKSwgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShpLCBzLCBsLCBkLCBtLCBjLCBoLCB1LCBULCByKTtcbn1cbmZ1bmN0aW9uIEdldEluc3RhbnRGb3IoZSwgdCwgcikge1xuICByZXR1cm4gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhHZXRQb3NzaWJsZUluc3RhbnRzRm9yKGUsIHQpLCBlLCB0LCByKTtcbn1cbmZ1bmN0aW9uIERpc2FtYmlndWF0ZVBvc3NpYmxlSW5zdGFudHModCwgciwgbywgbikge1xuICB2YXIgYSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5JbnN0YW50JVwiKSxcbiAgICBmID0gdC5sZW5ndGg7XG4gIGlmICgxID09PSBmKSByZXR1cm4gdFswXTtcbiAgaWYgKGYpIHN3aXRjaCAobikge1xuICAgIGNhc2UgXCJjb21wYXRpYmxlXCI6XG4gICAgY2FzZSBcImVhcmxpZXJcIjpcbiAgICAgIHJldHVybiB0WzBdO1xuICAgIGNhc2UgXCJsYXRlclwiOlxuICAgICAgcmV0dXJuIHRbZiAtIDFdO1xuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibXVsdGlwbGUgaW5zdGFudHMgZm91bmRcIik7XG4gIH1cbiAgdmFyIHkgPSBHZXRTbG90KG8sIGkpLFxuICAgIEkgPSBHZXRTbG90KG8sIHMpLFxuICAgIFMgPSBHZXRTbG90KG8sIGwpLFxuICAgIGcgPSBHZXRTbG90KG8sIGQpLFxuICAgIHcgPSBHZXRTbG90KG8sIG0pLFxuICAgIEQgPSBHZXRTbG90KG8sIGMpLFxuICAgIEcgPSBHZXRTbG90KG8sIGgpLFxuICAgIHYgPSBHZXRTbG90KG8sIHUpLFxuICAgIEMgPSBHZXRTbG90KG8sIFQpLFxuICAgIE8gPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHksIEksIFMsIGcsIHcsIEQsIEcsIHYsIEMpO1xuICBpZiAobnVsbCA9PT0gTykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgdmFyIGIgPSBuZXcgYShPIC0gRWUpLFxuICAgIEUgPSBuZXcgYShPICsgRWUpLFxuICAgIE0gPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihyLCBiKSxcbiAgICBSID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IociwgRSkgLSBNO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFwiZWFybGllclwiOlxuICAgICAge1xuICAgICAgICB2YXIgX2UxOCA9IEdldFNsb3QobywgcCksXG4gICAgICAgICAgX3QxOSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgICBfbjcgPSBBZGREYXRlVGltZSh5LCBJLCBTLCBnLCB3LCBELCBHLCB2LCBDLCBfZTE4LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAtUiwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIEdldFBvc3NpYmxlSW5zdGFudHNGb3IociwgbmV3IF90MTkoX243LnllYXIsIF9uNy5tb250aCwgX243LmRheSwgX243LmhvdXIsIF9uNy5taW51dGUsIF9uNy5zZWNvbmQsIF9uNy5taWxsaXNlY29uZCwgX243Lm1pY3Jvc2Vjb25kLCBfbjcubmFub3NlY29uZCwgX2UxOCkpWzBdO1xuICAgICAgfVxuICAgIGNhc2UgXCJjb21wYXRpYmxlXCI6XG4gICAgY2FzZSBcImxhdGVyXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfZTE5ID0gR2V0U2xvdChvLCBwKSxcbiAgICAgICAgICBfdDIwID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpLFxuICAgICAgICAgIF9uOCA9IEFkZERhdGVUaW1lKHksIEksIFMsIGcsIHcsIEQsIEcsIHYsIEMsIF9lMTksIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIFIsIHZvaWQgMCksXG4gICAgICAgICAgX2E0ID0gR2V0UG9zc2libGVJbnN0YW50c0ZvcihyLCBuZXcgX3QyMChfbjgueWVhciwgX244Lm1vbnRoLCBfbjguZGF5LCBfbjguaG91ciwgX244Lm1pbnV0ZSwgX244LnNlY29uZCwgX244Lm1pbGxpc2Vjb25kLCBfbjgubWljcm9zZWNvbmQsIF9uOC5uYW5vc2Vjb25kLCBfZTE5KSk7XG4gICAgICAgIHJldHVybiBfYTRbX2E0Lmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibm8gc3VjaCBpbnN0YW50IGZvdW5kXCIpO1xuICB9XG59XG5mdW5jdGlvbiBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKGUsIHQsIHIpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IzMiA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlRpbWVab25lJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlRpbWVab25lLnByb3RvdHlwZS5nZXRQb3NzaWJsZUluc3RhbnRzRm9yJVwiKSwgX3IzMiwgW3RdKTtcbiAgfVxuICB2YXIgbyA9IENhbGwociAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogR2V0TWV0aG9kKGUsIFwiZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiKSwgZSwgW3RdKSxcbiAgICBuID0gW107XG4gIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pLFxuICAgIF9zdGVwMTM7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfZTIwID0gX3N0ZXAxMy52YWx1ZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQoX2UyMCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiKTtcbiAgICAgIHRlLmNhbGwobiwgX2UyMCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTMuZigpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSVNPWWVhclN0cmluZyhlKSB7XG4gIHZhciB0O1xuICBpZiAoZSA8IDAgfHwgZSA+IDk5OTkpIHtcbiAgICB0ID0gKGUgPCAwID8gXCItXCIgOiBcIitcIikgKyBcIjAwMDAwMFwiLmNvbmNhdChhZShlKSkuc2xpY2UoLTYpO1xuICB9IGVsc2UgdCA9IFwiMDAwMFwiLmNvbmNhdChlKS5zbGljZSgtNCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGUpIHtcbiAgcmV0dXJuIFwiMDBcIi5jb25jYXQoZSkuc2xpY2UoLTIpO1xufVxuZnVuY3Rpb24gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoZSwgdCwgciwgbywgbikge1xuICBpZiAoXCJtaW51dGVcIiA9PT0gbikgcmV0dXJuIFwiXCI7XG4gIHZhciBhID0gXCI6XCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhlKSk7XG4gIHZhciBpLFxuICAgIHMgPSAxZTYgKiB0ICsgMWUzICogciArIG87XG4gIGlmIChcImF1dG9cIiA9PT0gbikge1xuICAgIGlmICgwID09PSBzKSByZXR1cm4gYTtcbiAgICBmb3IgKGkgPSBcIlwiLmNvbmNhdChzKS5wYWRTdGFydCg5LCBcIjBcIik7IFwiMFwiID09PSBpW2kubGVuZ3RoIC0gMV07KSBpID0gaS5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKDAgPT09IG4pIHJldHVybiBhO1xuICAgIGkgPSBcIlwiLmNvbmNhdChzKS5wYWRTdGFydCg5LCBcIjBcIikuc2xpY2UoMCwgbik7XG4gIH1cbiAgcmV0dXJuIFwiXCIuY29uY2F0KGEsIFwiLlwiKS5jb25jYXQoaSk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyhlLCB0LCByKSB7XG4gIHZhciBvID0gdDtcbiAgdm9pZCAwID09PSBvICYmIChvID0gXCJVVENcIik7XG4gIHZhciBuID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBlLCBcImlzbzg2MDFcIiksXG4gICAgYSA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChuLCBpKSksXG4gICAgcCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG4sIHMpKSxcbiAgICBmID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QobiwgbCkpLFxuICAgIHkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChuLCBkKSksXG4gICAgSSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG4sIG0pKSxcbiAgICBTID0gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoR2V0U2xvdChuLCBjKSwgR2V0U2xvdChuLCBoKSwgR2V0U2xvdChuLCB1KSwgR2V0U2xvdChuLCBUKSwgcik7XG4gIHZhciBnID0gXCJaXCI7XG4gIGlmICh2b2lkIDAgIT09IHQpIHtcbiAgICBnID0gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcoR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IobywgZSkpO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChhLCBcIi1cIikuY29uY2F0KHAsIFwiLVwiKS5jb25jYXQoZiwgXCJUXCIpLmNvbmNhdCh5LCBcIjpcIikuY29uY2F0KEkpLmNvbmNhdChTKS5jb25jYXQoZyk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodCkge1xuICB2YXIgX2Rpdm1vZCwgX2Rpdm1vZDIsIF9kaXZtb2QzO1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIGZvcm1hdE51bWJlcih0KSB7XG4gICAgcmV0dXJuIHQgPD0gdWUgPyB0LnRvU3RyaW5nKDEwKSA6IEJpZ0ludCh0KS50b1N0cmluZygxMCk7XG4gIH1cbiAgdmFyIG4gPSBHZXRTbG90KHQsIHcpLFxuICAgIGEgPSBHZXRTbG90KHQsIEQpLFxuICAgIGkgPSBHZXRTbG90KHQsIEcpLFxuICAgIHMgPSBHZXRTbG90KHQsIHYpLFxuICAgIGwgPSBHZXRTbG90KHQsIEMpLFxuICAgIGQgPSBHZXRTbG90KHQsIE8pO1xuICB2YXIgbSA9IEdldFNsb3QodCwgYiksXG4gICAgYyA9IEdldFNsb3QodCwgRSksXG4gICAgaCA9IEdldFNsb3QodCwgTSksXG4gICAgdSA9IEdldFNsb3QodCwgUik7XG4gIHZhciBUID0gRHVyYXRpb25TaWduKG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUpO1xuICBpZiAobykge1xuICAgIHZhciBfZTIxID0gby51bml0LFxuICAgICAgX3QyMSA9IG8uaW5jcmVtZW50LFxuICAgICAgX3IzMyA9IG8ucm91bmRpbmdNb2RlO1xuICAgIHZhciBfUm91bmREdXJhdGlvbiA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgbSwgYywgaCwgdSwgX3QyMSwgX2UyMSwgX3IzMyk7XG4gICAgbSA9IF9Sb3VuZER1cmF0aW9uLnNlY29uZHM7XG4gICAgYyA9IF9Sb3VuZER1cmF0aW9uLm1pbGxpc2Vjb25kcztcbiAgICBoID0gX1JvdW5kRHVyYXRpb24ubWljcm9zZWNvbmRzO1xuICAgIHUgPSBfUm91bmREdXJhdGlvbi5uYW5vc2Vjb25kcztcbiAgfVxuICB2YXIgcCA9IFtdO1xuICBuICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUobikpLCBcIllcIikpLCBhICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoYSkpLCBcIk1cIikpLCBpICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoaSkpLCBcIldcIikpLCBzICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUocykpLCBcIkRcIikpO1xuICB2YXIgZiA9IFtdO1xuICBsICYmIGYucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUobCkpLCBcIkhcIikpLCBkICYmIGYucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoZCkpLCBcIk1cIikpO1xuICB2YXIgeSA9IFtdO1xuICB2YXIgSSxcbiAgICBTLFxuICAgIGcsXG4gICAgRixcbiAgICBZID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIDAsIDAsIG0sIGMsIGgsIHUsIDApO1xuICAoX2Rpdm1vZCA9IGRpdm1vZChZLCBEZSksIFkgPSBfZGl2bW9kLnF1b3RpZW50LCBJID0gX2Rpdm1vZC5yZW1haW5kZXIpLCAoX2Rpdm1vZDIgPSBkaXZtb2QoWSwgRGUpLCBZID0gX2Rpdm1vZDIucXVvdGllbnQsIFMgPSBfZGl2bW9kMi5yZW1haW5kZXIpLCAoX2Rpdm1vZDMgPSBkaXZtb2QoWSwgRGUpLCBGID0gX2Rpdm1vZDMucXVvdGllbnQsIGcgPSBfZGl2bW9kMy5yZW1haW5kZXIpO1xuICB2YXIgUCA9IDFlNiAqIGFlKE51bWJlcihnKSkgKyAxZTMgKiBhZShOdW1iZXIoUykpICsgYWUoTnVtYmVyKEkpKTtcbiAgdmFyIFo7XG4gIGlmIChcImF1dG9cIiA9PT0gcikge1xuICAgIGlmICgwICE9PSBQKSBmb3IgKFogPSBcIlwiLmNvbmNhdChQKS5wYWRTdGFydCg5LCBcIjBcIik7IFwiMFwiID09PSBaW1oubGVuZ3RoIC0gMV07KSBaID0gWi5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSAwICE9PSByICYmIChaID0gXCJcIi5jb25jYXQoUCkucGFkU3RhcnQoOSwgXCIwXCIpLnNsaWNlKDAsIHIpKTtcbiAgcmV0dXJuIFogJiYgeS51bnNoaWZ0KFwiLlwiLCBaKSwgRiA9PT0gSWUgJiYgIXkubGVuZ3RoICYmIFwiYXV0b1wiID09PSByIHx8IHkudW5zaGlmdChhYnMoRikudG9TdHJpbmcoKSksIHkubGVuZ3RoICYmIGYucHVzaChcIlwiLmNvbmNhdCh5LmpvaW4oXCJcIiksIFwiU1wiKSksIGYubGVuZ3RoICYmIGYudW5zaGlmdChcIlRcIiksIHAubGVuZ3RoIHx8IGYubGVuZ3RoID8gXCJcIi5jb25jYXQoVCA8IDAgPyBcIi1cIiA6IFwiXCIsIFwiUFwiKS5jb25jYXQocC5qb2luKFwiXCIpKS5jb25jYXQoZi5qb2luKFwiXCIpKSA6IFwiUFQwU1wiO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVG9TdHJpbmcoZSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHJldHVybiBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKEdldFNsb3QoZSwgaSkpLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIHMpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBsKSkpLmNvbmNhdChNYXliZUZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihHZXRTbG90KGUsIHApLCB0KSk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciBuID0gR2V0U2xvdChlLCBpKSxcbiAgICBhID0gR2V0U2xvdChlLCBzKSxcbiAgICBmID0gR2V0U2xvdChlLCBsKSxcbiAgICB5ID0gR2V0U2xvdChlLCBkKSxcbiAgICBJID0gR2V0U2xvdChlLCBtKSxcbiAgICBTID0gR2V0U2xvdChlLCBjKSxcbiAgICBnID0gR2V0U2xvdChlLCBoKSxcbiAgICB3ID0gR2V0U2xvdChlLCB1KSxcbiAgICBEID0gR2V0U2xvdChlLCBUKTtcbiAgaWYgKG8pIHtcbiAgICB2YXIgX2UyMiA9IG8udW5pdCxcbiAgICAgIF90MjIgPSBvLmluY3JlbWVudCxcbiAgICAgIF9yMzQgPSBvLnJvdW5kaW5nTW9kZTtcbiAgICB2YXIgX1JvdW5kSVNPRGF0ZVRpbWUgPSBSb3VuZElTT0RhdGVUaW1lKG4sIGEsIGYsIHksIEksIFMsIGcsIHcsIEQsIF90MjIsIF9lMjIsIF9yMzQpO1xuICAgIG4gPSBfUm91bmRJU09EYXRlVGltZS55ZWFyO1xuICAgIGEgPSBfUm91bmRJU09EYXRlVGltZS5tb250aDtcbiAgICBmID0gX1JvdW5kSVNPRGF0ZVRpbWUuZGF5O1xuICAgIHkgPSBfUm91bmRJU09EYXRlVGltZS5ob3VyO1xuICAgIEkgPSBfUm91bmRJU09EYXRlVGltZS5taW51dGU7XG4gICAgUyA9IF9Sb3VuZElTT0RhdGVUaW1lLnNlY29uZDtcbiAgICBnID0gX1JvdW5kSVNPRGF0ZVRpbWUubWlsbGlzZWNvbmQ7XG4gICAgdyA9IF9Sb3VuZElTT0RhdGVUaW1lLm1pY3Jvc2Vjb25kO1xuICAgIEQgPSBfUm91bmRJU09EYXRlVGltZS5uYW5vc2Vjb25kO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKG4pLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhhKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoZiksIFwiVFwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHkpLCBcIjpcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhJKSkuY29uY2F0KEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KFMsIGcsIHcsIEQsIHQpKS5jb25jYXQoTWF5YmVGb3JtYXRDYWxlbmRhckFubm90YXRpb24oR2V0U2xvdChlLCBwKSwgcikpO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxNb250aERheVRvU3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiYXV0b1wiO1xuICB2YXIgciA9IFwiXCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIHMpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBsKSkpO1xuICB2YXIgbyA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gIGlmIChcImFsd2F5c1wiID09PSB0IHx8IFwiY3JpdGljYWxcIiA9PT0gdCB8fCBcImlzbzg2MDFcIiAhPT0gbykge1xuICAgIHIgPSBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKEdldFNsb3QoZSwgaSkpLCBcIi1cIikuY29uY2F0KHIpO1xuICB9XG4gIHZhciBuID0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKG8sIHQpO1xuICByZXR1cm4gbiAmJiAociArPSBuKSwgcjtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcoZSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHZhciByID0gXCJcIi5jb25jYXQoSVNPWWVhclN0cmluZyhHZXRTbG90KGUsIGkpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBzKSkpO1xuICB2YXIgbyA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gIGlmIChcImFsd2F5c1wiID09PSB0IHx8IFwiY3JpdGljYWxcIiA9PT0gdCB8fCBcImlzbzg2MDFcIiAhPT0gbykge1xuICAgIHIgKz0gXCItXCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIGwpKSk7XG4gIH1cbiAgdmFyIG4gPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24obywgdCk7XG4gIHJldHVybiBuICYmIChyICs9IG4pLCByO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcImF1dG9cIjtcbiAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFwiYXV0b1wiO1xuICB2YXIgZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICB2YXIgeSA9IEdldFNsb3QoZSwgUyk7XG4gIGlmIChmKSB7XG4gICAgdmFyIF90MjMgPSBmLnVuaXQsXG4gICAgICBfcjM1ID0gZi5pbmNyZW1lbnQsXG4gICAgICBfbzEyID0gZi5yb3VuZGluZ01vZGUsXG4gICAgICBfYTUgPSBSb3VuZEluc3RhbnQoR2V0U2xvdChlLCBuKSwgX3IzNSwgX3QyMywgX28xMik7XG4gICAgeSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShfYTUpO1xuICB9XG4gIHZhciBJID0gR2V0U2xvdChlLCBnKSxcbiAgICB3ID0gR2V0UGxhaW5EYXRlVGltZUZvcihJLCB5LCBcImlzbzg2MDFcIik7XG4gIHZhciBEID0gXCJcIi5jb25jYXQoSVNPWWVhclN0cmluZyhHZXRTbG90KHcsIGkpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh3LCBzKSksIFwiLVwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QodywgbCkpLCBcIlRcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KHcsIGQpKSwgXCI6XCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh3LCBtKSkpLmNvbmNhdChGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChHZXRTbG90KHcsIGMpLCBHZXRTbG90KHcsIGgpLCBHZXRTbG90KHcsIHUpLCBHZXRTbG90KHcsIFQpLCB0KSk7XG4gIGlmIChcIm5ldmVyXCIgIT09IGEpIHtcbiAgICBEICs9IEZvcm1hdElTT1RpbWVab25lT2Zmc2V0U3RyaW5nKEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEksIHkpKTtcbiAgfVxuICBpZiAoXCJuZXZlclwiICE9PSBvKSB7XG4gICAgRCArPSBcIltcIi5jb25jYXQoXCJjcml0aWNhbFwiID09PSBvID8gXCIhXCIgOiBcIlwiKS5jb25jYXQoVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihJKSwgXCJdXCIpO1xuICB9XG4gIHJldHVybiBEICs9IE1heWJlRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKEdldFNsb3QoZSwgcCksIHIpLCBEO1xufVxuZnVuY3Rpb24gSXNUaW1lWm9uZU9mZnNldFN0cmluZyhlKSB7XG4gIHJldHVybiB6ZS50ZXN0KGhlKGUpKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoZSkge1xuICB2YXIgdCA9IHplLmV4ZWMoaGUoZSkpO1xuICBpZiAoIXQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCB0aW1lIHpvbmUgb2Zmc2V0OiBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gKFwiLVwiID09PSB0WzFdIHx8IFwi4oiSXCIgPT09IHRbMV0gPyAtMSA6IDEpICogKDFlOSAqICg2MCAqICg2MCAqICt0WzJdICsgKyh0WzNdIHx8IDApKSArICsodFs0XSB8fCAwKSkgKyArKCh0WzVdIHx8IDApICsgXCIwMDAwMDAwMDBcIikuc2xpY2UoMCwgOSkpO1xufVxuZnVuY3Rpb24gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKGUpIHtcbiAgaWYgKElzVGltZVpvbmVPZmZzZXRTdHJpbmcoZSkpIHtcbiAgICByZXR1cm4gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhlKSk7XG4gIH1cbiAgcmV0dXJuIGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZShoZShlKSkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG59XG5mdW5jdGlvbiBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgcikge1xuICB2YXIgX0dldE5hbWVkVGltZVpvbmVEYXRlID0gR2V0TmFtZWRUaW1lWm9uZURhdGVUaW1lUGFydHModCwgciksXG4gICAgbyA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS55ZWFyLFxuICAgIG4gPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubW9udGgsXG4gICAgYSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5kYXksXG4gICAgaSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5ob3VyLFxuICAgIHMgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubWludXRlLFxuICAgIGwgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUuc2Vjb25kLFxuICAgIGQgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubWlsbGlzZWNvbmQsXG4gICAgbSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5taWNyb3NlY29uZCxcbiAgICBjID0gX0dldE5hbWVkVGltZVpvbmVEYXRlLm5hbm9zZWNvbmQsXG4gICAgaCA9IG8gJSA0MDAsXG4gICAgdSA9IChvIC0gaCkgLyA0MDAsXG4gICAgVCA9IDE0NjA5N24gKiBFZSxcbiAgICBwID0gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyhoLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSxcbiAgICBmID0gcCArIFQgKiBCaWdJbnQodSk7XG4gIHJldHVybiBOdW1iZXIoZiAtIHIpO1xufVxuZnVuY3Rpb24gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoZSkge1xuICB2YXIgdCA9IGUgPCAwID8gXCItXCIgOiBcIitcIixcbiAgICByID0gYWUoZSksXG4gICAgbyA9IHIgJSAxZTksXG4gICAgbiA9IGllKHIgLyAxZTkpICUgNjAsXG4gICAgYSA9IGllKHIgLyA2ZTEwKSAlIDYwLFxuICAgIGkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaWUociAvIDM2ZTExKSksXG4gICAgcyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhhKSxcbiAgICBsID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG4pO1xuICB2YXIgZCA9IFwiXCI7XG4gIGlmIChvKSB7XG4gICAgdmFyIF9lMjMgPSBcIlwiLmNvbmNhdChvKS5wYWRTdGFydCg5LCBcIjBcIik7XG4gICAgZm9yICg7IFwiMFwiID09PSBfZTIzW19lMjMubGVuZ3RoIC0gMV07KSBfZTIzID0gX2UyMy5zbGljZSgwLCAtMSk7XG4gICAgZCA9IFwiOlwiLmNvbmNhdChsLCBcIi5cIikuY29uY2F0KF9lMjMpO1xuICB9IGVsc2UgbiAmJiAoZCA9IFwiOlwiLmNvbmNhdChsKSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh0KS5jb25jYXQoaSwgXCI6XCIpLmNvbmNhdChzKS5jb25jYXQoZCk7XG59XG5mdW5jdGlvbiBGb3JtYXRJU09UaW1lWm9uZU9mZnNldFN0cmluZyh0KSB7XG4gIHZhciByID0gTnVtYmVyKFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQmlnSW50KHQpLCBiZSwgXCJoYWxmRXhwYW5kXCIpKTtcbiAgdmFyIG8gPSByIDwgMCA/IFwiLVwiIDogXCIrXCI7XG4gIHIgPSBhZShyKTtcbiAgdmFyIG4gPSByIC8gNmUxMCAlIDYwO1xuICByZXR1cm4gXCJcIi5jb25jYXQobykuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhpZShyIC8gMzZlMTEpKSwgXCI6XCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcobikpO1xufVxuZnVuY3Rpb24gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyh0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkKSB7XG4gIHZhciBtID0gbmV3IERhdGUoKTtcbiAgbS5zZXRVVENIb3VycyhuLCBhLCBpLCBzKSwgbS5zZXRVVENGdWxsWWVhcih0LCByIC0gMSwgbyk7XG4gIHZhciBjID0gbS5nZXRUaW1lKCk7XG4gIGlmIChkZShjKSkgcmV0dXJuIG51bGw7XG4gIHZhciBoID0gQmlnSW50KGMpICogR2U7XG4gIHJldHVybiBoID0gaCArIEJpZ0ludChsKSAqIERlLCBoID0gaCArIEJpZ0ludChkKSwgaCA8IE1lIHx8IGggPiBSZSA/IG51bGwgOiBoO1xufVxuZnVuY3Rpb24gR2V0SVNPUGFydHNGcm9tRXBvY2godCkge1xuICB2YXIgX2Rpdm1vZDQgPSBkaXZtb2QodCwgR2UpLFxuICAgIHIgPSBfZGl2bW9kNC5xdW90aWVudCxcbiAgICBvID0gX2Rpdm1vZDQucmVtYWluZGVyO1xuICB2YXIgbiA9IE51bWJlcihyKSxcbiAgICBhID0gTnVtYmVyKG8pO1xuICBhIDwgMCAmJiAoYSArPSAxZTYsIG4gLT0gMSk7XG4gIHZhciBpID0gaWUoYSAvIDFlMykgJSAxZTMsXG4gICAgcyA9IGEgJSAxZTMsXG4gICAgbCA9IG5ldyBEYXRlKG4pO1xuICByZXR1cm4ge1xuICAgIGVwb2NoTWlsbGlzZWNvbmRzOiBuLFxuICAgIHllYXI6IGwuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogbC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGwuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGwuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGwuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogbC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGwuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgbWljcm9zZWNvbmQ6IGksXG4gICAgbmFub3NlY29uZDogc1xuICB9O1xufVxuZnVuY3Rpb24gR2V0TmFtZWRUaW1lWm9uZURhdGVUaW1lUGFydHMoZSwgdCkge1xuICB2YXIgX0dldElTT1BhcnRzRnJvbUVwb2NoMiA9IEdldElTT1BhcnRzRnJvbUVwb2NoKHQpLFxuICAgIHIgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLmVwb2NoTWlsbGlzZWNvbmRzLFxuICAgIG8gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm1pbGxpc2Vjb25kLFxuICAgIG4gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm1pY3Jvc2Vjb25kLFxuICAgIGEgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm5hbm9zZWNvbmQsXG4gICAgX0dldEZvcm1hdHRlclBhcnRzID0gZnVuY3Rpb24gR2V0Rm9ybWF0dGVyUGFydHMoZSwgdCkge1xuICAgICAgdmFyIHIgPSBnZXRJbnRsRGF0ZVRpbWVGb3JtYXRFblVzRm9yVGltZVpvbmUoZSkuZm9ybWF0KG5ldyBEYXRlKHQpKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZyb21FblVzRm9ybWF0KGUpIHtcbiAgICAgICAgdmFyIHQgPSBlLnNwbGl0KC9bXlxcd10rLyk7XG4gICAgICAgIGlmICg3ICE9PSB0Lmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJleHBlY3RlZCA3IHBhcnRzIGluIFxcXCJcIi5jb25jYXQoZSkpO1xuICAgICAgICB2YXIgciA9ICt0WzBdLFxuICAgICAgICAgIG8gPSArdFsxXTtcbiAgICAgICAgdmFyIG4gPSArdFsyXTtcbiAgICAgICAgdmFyIGEgPSB0WzNdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChcIkJcIiA9PT0gYSB8fCBcIkJDXCIgPT09IGEpIG4gPSAxIC0gbjtlbHNlIGlmIChcIkFcIiAhPT0gYSAmJiBcIkFEXCIgIT09IGEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBlcmEgXCIuY29uY2F0KGEsIFwiIGluIFxcXCJcIikuY29uY2F0KGUpKTtcbiAgICAgICAgdmFyIGkgPSArdFs0XTtcbiAgICAgICAgMjQgPT09IGkgJiYgKGkgPSAwKTtcbiAgICAgICAgdmFyIHMgPSArdFs1XSxcbiAgICAgICAgICBsID0gK3RbNl07XG4gICAgICAgIGlmICghKG1lKG4pICYmIG1lKHIpICYmIG1lKG8pICYmIG1lKGkpICYmIG1lKHMpICYmIG1lKGwpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlciBpbiBcXFwiXCIuY29uY2F0KGUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyOiBuLFxuICAgICAgICAgIG1vbnRoOiByLFxuICAgICAgICAgIGRheTogbyxcbiAgICAgICAgICBob3VyOiBpLFxuICAgICAgICAgIG1pbnV0ZTogcyxcbiAgICAgICAgICBzZWNvbmQ6IGxcbiAgICAgICAgfTtcbiAgICAgIH0ocik7XG4gICAgfShlLCByKSxcbiAgICBpID0gX0dldEZvcm1hdHRlclBhcnRzLnllYXIsXG4gICAgcyA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5tb250aCxcbiAgICBsID0gX0dldEZvcm1hdHRlclBhcnRzLmRheSxcbiAgICBkID0gX0dldEZvcm1hdHRlclBhcnRzLmhvdXIsXG4gICAgbSA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5taW51dGUsXG4gICAgYyA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5zZWNvbmQ7XG4gIHJldHVybiBCYWxhbmNlSVNPRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgbywgbiwgYSk7XG59XG5mdW5jdGlvbiBtYXhKU0JJKHQsIHIpIHtcbiAgcmV0dXJuIHQgPCByID8gciA6IHQ7XG59XG5mdW5jdGlvbiBhZnRlckxhdGVzdFBvc3NpYmxlVHpkYlJ1bGVDaGFuZ2UoKSB7XG4gIHJldHVybiBWZSgpICsgWmU7XG59XG5mdW5jdGlvbiBHZXROYW1lZFRpbWVab25lTmV4dFRyYW5zaXRpb24odCwgcikge1xuICBpZiAociA8IFBlKSByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZU5leHRUcmFuc2l0aW9uKHQsIFBlKTtcbiAgdmFyIG8gPSByICsgQmUsXG4gICAgbiA9IG1heEpTQkkoYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCksIG8pO1xuICB2YXIgYSA9IG1heEpTQkkoUGUsIHIpO1xuICB2YXIgaSA9IEdldE5hbWVkVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyh0LCBhKTtcbiAgdmFyIHMgPSBhLFxuICAgIGwgPSBpO1xuICBmb3IgKDsgaSA9PT0gbCAmJiBCaWdJbnQoYSkgPCBuOykge1xuICAgIGlmIChzID0gYSArIE5lLCBzID4gUmUpIHJldHVybiBudWxsO1xuICAgIGwgPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgcyksIGkgPT09IGwgJiYgKGEgPSBzKTtcbiAgfVxuICBpZiAoaSA9PT0gbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBiaXNlY3QoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIGUpO1xuICB9LCBhLCBzLCBpLCBsKTtcbn1cbmZ1bmN0aW9uIEdldE5hbWVkVGltZVpvbmVQcmV2aW91c1RyYW5zaXRpb24odCwgcikge1xuICB2YXIgbyA9IGFmdGVyTGF0ZXN0UG9zc2libGVUemRiUnVsZUNoYW5nZSgpLFxuICAgIGEgPSByID4gbyxcbiAgICBpID0gYSA/IHIgLSBCZSA6IFBlO1xuICBpZiAoXCJBZnJpY2EvQ2FzYWJsYW5jYVwiID09PSB0IHx8IFwiQWZyaWNhL0VsX0FhaXVuXCIgPT09IHQpIHtcbiAgICB2YXIgX28xMyA9IEdldFNsb3QoVG9UZW1wb3JhbEluc3RhbnQoXCIyMDg4LTAxLTAxVDAwWlwiKSwgbik7XG4gICAgaWYgKF9vMTMgPCByKSByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZVByZXZpb3VzVHJhbnNpdGlvbih0LCBfbzEzKTtcbiAgfVxuICB2YXIgcyA9IHIgLSBTZTtcbiAgaWYgKHMgPCBQZSkgcmV0dXJuIG51bGw7XG4gIHZhciBsID0gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIHMpO1xuICB2YXIgZCA9IHMsXG4gICAgbSA9IGw7XG4gIGZvciAoOyBsID09PSBtICYmIHMgPiBpOykge1xuICAgIGlmIChkID0gcyAtIE5lLCBkIDwgUGUpIHJldHVybiBudWxsO1xuICAgIG0gPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgZCksIGwgPT09IG0gJiYgKHMgPSBkKTtcbiAgfVxuICBpZiAobCA9PT0gbSkge1xuICAgIGlmIChhKSB7XG4gICAgICB2YXIgX3IzNiA9IG8gLSBFZTtcbiAgICAgIHJldHVybiBHZXROYW1lZFRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKHQsIF9yMzYpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYmlzZWN0KGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIEdldE5hbWVkVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyh0LCBlKTtcbiAgfSwgZCwgcywgbSwgbCk7XG59XG5mdW5jdGlvbiBMZWFwWWVhcihlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiAhMTtcbiAgcmV0dXJuIGUgJSA0ID09IDAgJiYgKCEoZSAlIDEwMCA9PSAwKSB8fCBlICUgNDAwID09IDApO1xufVxuZnVuY3Rpb24gSVNPRGF5c0luTW9udGgoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHN0YW5kYXJkOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgbGVhcHllYXI6IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxuICB9W0xlYXBZZWFyKGUpID8gXCJsZWFweWVhclwiIDogXCJzdGFuZGFyZFwiXVt0IC0gMV07XG59XG5mdW5jdGlvbiBEYXlPZldlZWsoZSwgdCwgcikge1xuICB2YXIgbyA9IHQgKyAodCA8IDMgPyAxMCA6IC0yKSxcbiAgICBuID0gZSAtICh0IDwgMyA/IDEgOiAwKSxcbiAgICBhID0gaWUobiAvIDEwMCksXG4gICAgaSA9IG4gLSAxMDAgKiBhLFxuICAgIHMgPSAociArIGllKDIuNiAqIG8gLSAuMikgKyAoaSArIGllKGkgLyA0KSkgKyAoaWUoYSAvIDQpIC0gMiAqIGEpKSAlIDc7XG4gIHJldHVybiBzICsgKHMgPD0gMCA/IDcgOiAwKTtcbn1cbmZ1bmN0aW9uIERheU9mWWVhcihlLCB0LCByKSB7XG4gIHZhciBvID0gcjtcbiAgZm9yICh2YXIgX3IzNyA9IHQgLSAxOyBfcjM3ID4gMDsgX3IzNy0tKSBvICs9IElTT0RheXNJbk1vbnRoKGUsIF9yMzcpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIFdlZWtPZlllYXIoZSwgdCwgcikge1xuICB2YXIgbyA9IERheU9mWWVhcihlLCB0LCByKSxcbiAgICBuID0gRGF5T2ZXZWVrKGUsIHQsIHIpIHx8IDcsXG4gICAgYSA9IERheU9mV2VlayhlLCAxLCAxKSxcbiAgICBpID0gaWUoKG8gLSBuICsgMTApIC8gNyk7XG4gIHJldHVybiBpIDwgMSA/IDUgPT09IGEgfHwgNiA9PT0gYSAmJiBMZWFwWWVhcihlIC0gMSkgPyB7XG4gICAgd2VlazogNTMsXG4gICAgeWVhcjogZSAtIDFcbiAgfSA6IHtcbiAgICB3ZWVrOiA1MixcbiAgICB5ZWFyOiBlIC0gMVxuICB9IDogNTMgPT09IGkgJiYgKExlYXBZZWFyKGUpID8gMzY2IDogMzY1KSAtIG8gPCA0IC0gbiA/IHtcbiAgICB3ZWVrOiAxLFxuICAgIHllYXI6IGUgKyAxXG4gIH0gOiB7XG4gICAgd2VlazogaSxcbiAgICB5ZWFyOiBlXG4gIH07XG59XG5mdW5jdGlvbiBEdXJhdGlvblNpZ24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICBmb3IgKHZhciBfaTcgPSAwLCBfYXJyMiA9IFtlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkXTsgX2k3IDwgX2FycjIubGVuZ3RoOyBfaTcrKykge1xuICAgIHZhciBfbTIgPSBfYXJyMltfaTddO1xuICAgIGlmICgwICE9PSBfbTIpIHJldHVybiBfbTIgPCAwID8gLTEgOiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT1llYXJNb250aChlLCB0KSB7XG4gIHZhciByID0gZSxcbiAgICBvID0gdDtcbiAgaWYgKCFtZShyKSB8fCAhbWUobykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICByZXR1cm4gbyAtPSAxLCByICs9IGllKG8gLyAxMiksIG8gJT0gMTIsIG8gPCAwICYmIChvICs9IDEyKSwgbyArPSAxLCB7XG4gICAgeWVhcjogcixcbiAgICBtb250aDogb1xuICB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT0RhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IGUsXG4gICAgbiA9IHQsXG4gICAgYSA9IHI7XG4gIGlmICghbWUoYSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGggPSBCYWxhbmNlSVNPWWVhck1vbnRoKG8sIG4pO1xuICBvID0gX0JhbGFuY2VJU09ZZWFyTW9udGgueWVhcjtcbiAgbiA9IF9CYWxhbmNlSVNPWWVhck1vbnRoLm1vbnRoO1xuICB2YXIgaSA9IDE0NjA5NztcbiAgaWYgKGFlKGEpID4gaSkge1xuICAgIHZhciBfZTI0ID0gbGUoYSAvIGkpO1xuICAgIG8gKz0gNDAwICogX2UyNCwgYSAtPSBfZTI0ICogaTtcbiAgfVxuICB2YXIgcyA9IDAsXG4gICAgbCA9IG4gPiAyID8gbyA6IG8gLSAxO1xuICBmb3IgKDsgcyA9IExlYXBZZWFyKGwpID8gMzY2IDogMzY1LCBhIDwgLXM7KSBvIC09IDEsIGwgLT0gMSwgYSArPSBzO1xuICBmb3IgKGwgKz0gMTsgcyA9IExlYXBZZWFyKGwpID8gMzY2IDogMzY1LCBhID4gczspIG8gKz0gMSwgbCArPSAxLCBhIC09IHM7XG4gIGZvciAoOyBhIDwgMTspIHtcbiAgICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGgyO1xuICAgIChfQmFsYW5jZUlTT1llYXJNb250aDIgPSBCYWxhbmNlSVNPWWVhck1vbnRoKG8sIG4gLSAxKSwgbyA9IF9CYWxhbmNlSVNPWWVhck1vbnRoMi55ZWFyLCBuID0gX0JhbGFuY2VJU09ZZWFyTW9udGgyLm1vbnRoKSwgYSArPSBJU09EYXlzSW5Nb250aChvLCBuKTtcbiAgfVxuICBmb3IgKDsgYSA+IElTT0RheXNJbk1vbnRoKG8sIG4pOykge1xuICAgIHZhciBfQmFsYW5jZUlTT1llYXJNb250aDM7XG4gICAgYSAtPSBJU09EYXlzSW5Nb250aChvLCBuKSwgKF9CYWxhbmNlSVNPWWVhck1vbnRoMyA9IEJhbGFuY2VJU09ZZWFyTW9udGgobywgbiArIDEpLCBvID0gX0JhbGFuY2VJU09ZZWFyTW9udGgzLnllYXIsIG4gPSBfQmFsYW5jZUlTT1llYXJNb250aDMubW9udGgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcjogbyxcbiAgICBtb250aDogbixcbiAgICBkYXk6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09EYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsKSB7XG4gIHZhciBfQmFsYW5jZVRpbWUgPSBCYWxhbmNlVGltZShvLCBuLCBhLCBpLCBzLCBsKSxcbiAgICBkID0gX0JhbGFuY2VUaW1lLmRlbHRhRGF5cyxcbiAgICBtID0gX0JhbGFuY2VUaW1lLmhvdXIsXG4gICAgYyA9IF9CYWxhbmNlVGltZS5taW51dGUsXG4gICAgaCA9IF9CYWxhbmNlVGltZS5zZWNvbmQsXG4gICAgdSA9IF9CYWxhbmNlVGltZS5taWxsaXNlY29uZCxcbiAgICBUID0gX0JhbGFuY2VUaW1lLm1pY3Jvc2Vjb25kLFxuICAgIHAgPSBfQmFsYW5jZVRpbWUubmFub3NlY29uZCxcbiAgICBfQmFsYW5jZUlTT0RhdGUgPSBCYWxhbmNlSVNPRGF0ZShlLCB0LCByICsgZCksXG4gICAgZiA9IF9CYWxhbmNlSVNPRGF0ZS55ZWFyLFxuICAgIHkgPSBfQmFsYW5jZUlTT0RhdGUubW9udGgsXG4gICAgSSA9IF9CYWxhbmNlSVNPRGF0ZS5kYXk7XG4gIHJldHVybiB7XG4gICAgeWVhcjogZixcbiAgICBtb250aDogeSxcbiAgICBkYXk6IEksXG4gICAgaG91cjogbSxcbiAgICBtaW51dGU6IGMsXG4gICAgc2Vjb25kOiBoLFxuICAgIG1pbGxpc2Vjb25kOiB1LFxuICAgIG1pY3Jvc2Vjb25kOiBULFxuICAgIG5hbm9zZWNvbmQ6IHBcbiAgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VUaW1lKHQsIHIsIG8sIG4sIGEsIGkpIHtcbiAgdmFyIF9Ob25OZWdhdGl2ZUJpZ0ludERpdiwgX05vbk5lZ2F0aXZlQmlnSW50RGl2MiwgX05vbk5lZ2F0aXZlQmlnSW50RGl2MywgX05vbk5lZ2F0aXZlQmlnSW50RGl2NCwgX05vbk5lZ2F0aXZlQmlnSW50RGl2NSwgX05vbk5lZ2F0aXZlQmlnSW50RGl2NjtcbiAgdmFyIHMsXG4gICAgbCA9IEJpZ0ludCh0KSxcbiAgICBkID0gQmlnSW50KHIpLFxuICAgIG0gPSBCaWdJbnQobyksXG4gICAgYyA9IEJpZ0ludChuKSxcbiAgICBoID0gQmlnSW50KGEpLFxuICAgIHUgPSBCaWdJbnQoaSk7XG4gIHJldHVybiAoX05vbk5lZ2F0aXZlQmlnSW50RGl2ID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QodSwgRGUpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2LnF1b3RpZW50LCB1ID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2LnJlbWFpbmRlciksIGggPSBoICsgcywgKF9Ob25OZWdhdGl2ZUJpZ0ludERpdjIgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZChoLCBEZSksIHMgPSBfTm9uTmVnYXRpdmVCaWdJbnREaXYyLnF1b3RpZW50LCBoID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2Mi5yZW1haW5kZXIpLCBjID0gYyArIHMsIChfTm9uTmVnYXRpdmVCaWdJbnREaXYzID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QoYywgRGUpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2My5xdW90aWVudCwgYyA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjMucmVtYWluZGVyKSwgbSA9IG0gKyBzLCAoX05vbk5lZ2F0aXZlQmlnSW50RGl2NCA9IE5vbk5lZ2F0aXZlQmlnSW50RGl2bW9kKG0sIGdlKSwgcyA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjQucXVvdGllbnQsIG0gPSBfTm9uTmVnYXRpdmVCaWdJbnREaXY0LnJlbWFpbmRlciksIGQgPSBkICsgcywgKF9Ob25OZWdhdGl2ZUJpZ0ludERpdjUgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZChkLCBnZSksIHMgPSBfTm9uTmVnYXRpdmVCaWdJbnREaXY1LnF1b3RpZW50LCBkID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2NS5yZW1haW5kZXIpLCBsID0gbCArIHMsIChfTm9uTmVnYXRpdmVCaWdJbnREaXY2ID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QobCwgd2UpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2Ni5xdW90aWVudCwgbCA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjYucmVtYWluZGVyKSwge1xuICAgIGRlbHRhRGF5czogTnVtYmVyKHMpLFxuICAgIGhvdXI6IE51bWJlcihsKSxcbiAgICBtaW51dGU6IE51bWJlcihkKSxcbiAgICBzZWNvbmQ6IE51bWJlcihtKSxcbiAgICBtaWxsaXNlY29uZDogTnVtYmVyKGMpLFxuICAgIG1pY3Jvc2Vjb25kOiBOdW1iZXIoaCksXG4gICAgbmFub3NlY29uZDogTnVtYmVyKHUpXG4gIH07XG59XG5mdW5jdGlvbiBUb3RhbER1cmF0aW9uTmFub3NlY29uZHModCwgciwgbywgbiwgYSwgaSwgcywgbCkge1xuICB2YXIgZCA9IEJpZ0ludCh0KTtcbiAgdmFyIG0gPSBCaWdJbnQocyk7XG4gIDAgIT09IHQgJiYgKG0gPSBCaWdJbnQocykgLSBCaWdJbnQobCkpO1xuICB2YXIgYyA9IEJpZ0ludChyKSArIGQgKiAyNG4sXG4gICAgaCA9IEJpZ0ludChvKSArIGMgKiBnZSxcbiAgICB1ID0gQmlnSW50KG4pICsgaCAqIGdlLFxuICAgIFQgPSBCaWdJbnQoYSkgKyB1ICogRGUsXG4gICAgcCA9IEJpZ0ludChpKSArIFQgKiBEZTtcbiAgcmV0dXJuIEJpZ0ludChtKSArIHAgKiBEZTtcbn1cbmZ1bmN0aW9uIE5hbm9zZWNvbmRzVG9EYXlzKHQsIHIpIHtcbiAgdmFyIG8gPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgYSA9IHNlKE51bWJlcih0KSk7XG4gIHZhciBmID0gQmlnSW50KHQpLFxuICAgIHkgPSA4NjRlMTE7XG4gIGlmICgwID09PSBhKSByZXR1cm4ge1xuICAgIGRheXM6IDAsXG4gICAgbmFub3NlY29uZHM6IEllLFxuICAgIGRheUxlbmd0aE5zOiB5XG4gIH07XG4gIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocikpIHtcbiAgICB2YXIgX2Rpdm1vZDU7XG4gICAgdmFyIF90MjQ7XG4gICAgcmV0dXJuIChfZGl2bW9kNSA9IGRpdm1vZChmLCBCaWdJbnQoeSkpLCBfdDI0ID0gX2Rpdm1vZDUucXVvdGllbnQsIGYgPSBfZGl2bW9kNS5yZW1haW5kZXIpLCB7XG4gICAgICBkYXlzOiBOdW1iZXIoX3QyNCksXG4gICAgICBuYW5vc2Vjb25kczogZixcbiAgICAgIGRheUxlbmd0aE5zOiB5XG4gICAgfTtcbiAgfVxuICB2YXIgSSA9IEdldFNsb3QociwgbiksXG4gICAgdyA9IEdldFNsb3QociwgUyksXG4gICAgRCA9IEkgKyBmLFxuICAgIEcgPSBuZXcgbyhEKSxcbiAgICB2ID0gR2V0U2xvdChyLCBnKSxcbiAgICBDID0gR2V0U2xvdChyLCBwKSxcbiAgICBPID0gR2V0UGxhaW5EYXRlVGltZUZvcih2LCB3LCBDKSxcbiAgICBiID0gR2V0UGxhaW5EYXRlVGltZUZvcih2LCBHLCBDKTtcbiAgdmFyIF9EaWZmZXJlbmNlSVNPRGF0ZVRpbSA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KE8sIGkpLCBHZXRTbG90KE8sIHMpLCBHZXRTbG90KE8sIGwpLCBHZXRTbG90KE8sIGQpLCBHZXRTbG90KE8sIG0pLCBHZXRTbG90KE8sIGMpLCBHZXRTbG90KE8sIGgpLCBHZXRTbG90KE8sIHUpLCBHZXRTbG90KE8sIFQpLCBHZXRTbG90KGIsIGkpLCBHZXRTbG90KGIsIHMpLCBHZXRTbG90KGIsIGwpLCBHZXRTbG90KGIsIGQpLCBHZXRTbG90KGIsIG0pLCBHZXRTbG90KGIsIGMpLCBHZXRTbG90KGIsIGgpLCBHZXRTbG90KGIsIHUpLCBHZXRTbG90KGIsIFQpLCBDLCBcImRheVwiLCBUZShudWxsKSksXG4gICAgRSA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbS5kYXlzLFxuICAgIE0gPSBBZGRab25lZERhdGVUaW1lKHcsIHYsIEMsIDAsIDAsIDAsIEUsIDAsIDAsIDAsIDAsIDAsIDApLFxuICAgIFIgPSBCaWdJbnQoRSk7XG4gIGlmICgxID09PSBhKSBmb3IgKDsgUiA+IEllICYmIE0gPiBEOykgUiA9IFIgLSBTZSwgTSA9IEFkZFpvbmVkRGF0ZVRpbWUodywgdiwgQywgMCwgMCwgMCwgTnVtYmVyKFIpLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgZiA9IEQgLSBNO1xuICB2YXIgRiA9ICExLFxuICAgIFkgPSBuZXcgbyhNKTtcbiAgZG8ge1xuICAgIHZhciBfdDI1ID0gQWRkWm9uZWREYXRlVGltZShZLCB2LCBDLCAwLCAwLCAwLCBhLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgIF9yMzggPSBHZXRTbG90KFksIG4pO1xuICAgIHkgPSBOdW1iZXIoX3QyNSAtIF9yMzgpLCBGID0gKGYgLSBCaWdJbnQoeSkpICogQmlnSW50KGEpID49IEllLCBGICYmIChmID0gZiAtIEJpZ0ludCh5KSwgWSA9IG5ldyBvKF90MjUpLCBSID0gUiArIEJpZ0ludChhKSk7XG4gIH0gd2hpbGUgKEYpO1xuICBpZiAoIWlzWmVybyhSKSAmJiBzaWduSlNCSShSKSAhPT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaW1lIHpvbmUgb3IgY2FsZW5kYXIgY29udmVydGVkIG5hbm9zZWNvbmRzIGludG8gYSBudW1iZXIgb2YgZGF5cyB3aXRoIHRoZSBvcHBvc2l0ZSBzaWduXCIpO1xuICBpZiAoIWlzWmVybyhmKSAmJiBzaWduSlNCSShmKSAhPT0gYSkge1xuICAgIGlmIChpc05lZ2F0aXZlSlNCSShmKSAmJiAxID09PSBhKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3NlcnQgbm90IHJlYWNoZWRcIik7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaW1lIHpvbmUgb3IgY2FsZW5kYXIgZW5kZWQgdXAgd2l0aCBhIHJlbWFpbmRlciBvZiBuYW5vc2Vjb25kcyB3aXRoIHRoZSBvcHBvc2l0ZSBzaWduXCIpO1xuICB9XG4gIGlmIChhYnMoZikgPj0gYWJzKEJpZ0ludCh5KSkpIHRocm93IG5ldyBFcnJvcihcImFzc2VydCBub3QgcmVhY2hlZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBkYXlzOiBOdW1iZXIoUiksXG4gICAgbmFub3NlY29uZHM6IGYsXG4gICAgZGF5TGVuZ3RoTnM6IGFlKHkpXG4gIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlRHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCkge1xuICB2YXIgZCA9IEJhbGFuY2VQb3NzaWJseUluZmluaXRlRHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCk7XG4gIGlmIChcInBvc2l0aXZlIG92ZXJmbG93XCIgPT09IGQgfHwgXCJuZWdhdGl2ZSBvdmVyZmxvd1wiID09PSBkKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cmF0aW9uIG91dCBvZiByYW5nZVwiKTtcbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBCYWxhbmNlUG9zc2libHlJbmZpbml0ZUR1cmF0aW9uKHQsIHIsIG8sIGEsIGksIHMsIGwsIGQsIG0pIHtcbiAgdmFyIF9OYW5vc2Vjb25kc1RvRGF5cywgX2Rpdm1vZDYsIF9kaXZtb2Q3LCBfZGl2bW9kOCwgX2Rpdm1vZDksIF9kaXZtb2QxMCwgX2Rpdm1vZDExLCBfZGl2bW9kMTIsIF9kaXZtb2QxMywgX2Rpdm1vZDE0LCBfZGl2bW9kMTUsIF9kaXZtb2QxNiwgX2Rpdm1vZDE3LCBfZGl2bW9kMTgsIF9kaXZtb2QxOTtcbiAgdmFyIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQsXG4gICAgZixcbiAgICB5LFxuICAgIEkgPSB0O1xuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUobSkpIHtcbiAgICB2YXIgX3QyNiA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChtLCBTKSwgR2V0U2xvdChtLCBnKSwgR2V0U2xvdChtLCBwKSwgMCwgMCwgMCwgSSwgciwgbywgYSwgaSwgcywgbCksXG4gICAgICBfZCA9IEdldFNsb3QobSwgbik7XG4gICAgYyA9IF90MjYgLSBfZDtcbiAgfSBlbHNlIGMgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoSSwgciwgbywgYSwgaSwgcywgbCwgMCk7XG4gIFwieWVhclwiID09PSBkIHx8IFwibW9udGhcIiA9PT0gZCB8fCBcIndlZWtcIiA9PT0gZCB8fCBcImRheVwiID09PSBkID8gKF9OYW5vc2Vjb25kc1RvRGF5cyA9IE5hbm9zZWNvbmRzVG9EYXlzKGMsIG0pLCBJID0gX05hbm9zZWNvbmRzVG9EYXlzLmRheXMsIGMgPSBfTmFub3NlY29uZHNUb0RheXMubmFub3NlY29uZHMsIF9OYW5vc2Vjb25kc1RvRGF5cykgOiBJID0gMDtcbiAgdmFyIHcgPSBjIDwgSWUgPyAtMSA6IDE7XG4gIHN3aXRjaCAoYyA9IGFicyhjKSwgaCA9IHUgPSBUID0gZiA9IHkgPSBJZSwgZCkge1xuICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgY2FzZSBcIndlZWtcIjpcbiAgICBjYXNlIFwiZGF5XCI6XG4gICAgY2FzZSBcImhvdXJcIjpcbiAgICAgIChfZGl2bW9kNiA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kNi5xdW90aWVudCwgYyA9IF9kaXZtb2Q2LnJlbWFpbmRlciksIChfZGl2bW9kNyA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kNy5xdW90aWVudCwgaCA9IF9kaXZtb2Q3LnJlbWFpbmRlciksIChfZGl2bW9kOCA9IGRpdm1vZCh1LCBEZSksIFQgPSBfZGl2bW9kOC5xdW90aWVudCwgdSA9IF9kaXZtb2Q4LnJlbWFpbmRlciksIChfZGl2bW9kOSA9IGRpdm1vZChULCBnZSksIGYgPSBfZGl2bW9kOS5xdW90aWVudCwgVCA9IF9kaXZtb2Q5LnJlbWFpbmRlciksIChfZGl2bW9kMTAgPSBkaXZtb2QoZiwgZ2UpLCB5ID0gX2Rpdm1vZDEwLnF1b3RpZW50LCBmID0gX2Rpdm1vZDEwLnJlbWFpbmRlcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAoX2Rpdm1vZDExID0gZGl2bW9kKGMsIERlKSwgaCA9IF9kaXZtb2QxMS5xdW90aWVudCwgYyA9IF9kaXZtb2QxMS5yZW1haW5kZXIpLCAoX2Rpdm1vZDEyID0gZGl2bW9kKGgsIERlKSwgdSA9IF9kaXZtb2QxMi5xdW90aWVudCwgaCA9IF9kaXZtb2QxMi5yZW1haW5kZXIpLCAoX2Rpdm1vZDEzID0gZGl2bW9kKHUsIERlKSwgVCA9IF9kaXZtb2QxMy5xdW90aWVudCwgdSA9IF9kaXZtb2QxMy5yZW1haW5kZXIpLCAoX2Rpdm1vZDE0ID0gZGl2bW9kKFQsIGdlKSwgZiA9IF9kaXZtb2QxNC5xdW90aWVudCwgVCA9IF9kaXZtb2QxNC5yZW1haW5kZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNlY29uZFwiOlxuICAgICAgKF9kaXZtb2QxNSA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kMTUucXVvdGllbnQsIGMgPSBfZGl2bW9kMTUucmVtYWluZGVyKSwgKF9kaXZtb2QxNiA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kMTYucXVvdGllbnQsIGggPSBfZGl2bW9kMTYucmVtYWluZGVyKSwgKF9kaXZtb2QxNyA9IGRpdm1vZCh1LCBEZSksIFQgPSBfZGl2bW9kMTcucXVvdGllbnQsIHUgPSBfZGl2bW9kMTcucmVtYWluZGVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgKF9kaXZtb2QxOCA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kMTgucXVvdGllbnQsIGMgPSBfZGl2bW9kMTgucmVtYWluZGVyKSwgKF9kaXZtb2QxOSA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kMTkucXVvdGllbnQsIGggPSBfZGl2bW9kMTkucmVtYWluZGVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtaWNyb3NlY29uZFwiOlxuICAgICAgdmFyIF9kaXZtb2QyMCA9IGRpdm1vZChjLCBEZSk7XG4gICAgICBoID0gX2Rpdm1vZDIwLnF1b3RpZW50O1xuICAgICAgYyA9IF9kaXZtb2QyMC5yZW1haW5kZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibmFub3NlY29uZFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFzc2VydCBub3QgcmVhY2hlZFwiKTtcbiAgfVxuICB2YXIgRCA9IE51bWJlcih5KSAqIHcsXG4gICAgRyA9IE51bWJlcihmKSAqIHcsXG4gICAgdiA9IE51bWJlcihUKSAqIHcsXG4gICAgQyA9IE51bWJlcih1KSAqIHcsXG4gICAgTyA9IE51bWJlcihoKSAqIHcsXG4gICAgYiA9IE51bWJlcihjKSAqIHc7XG4gIGZvciAodmFyIF9pOCA9IDAsIF9hcnIzID0gW0ksIEQsIEcsIHYsIEMsIE8sIGJdOyBfaTggPCBfYXJyMy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIF9lMjUgPSBfYXJyM1tfaThdO1xuICAgIGlmICghbWUoX2UyNSkpIHJldHVybiAxID09PSB3ID8gXCJwb3NpdGl2ZSBvdmVyZmxvd1wiIDogXCJuZWdhdGl2ZSBvdmVyZmxvd1wiO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF5czogSSxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xufVxuZnVuY3Rpb24gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBzID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICBsID0gRHVyYXRpb25TaWduKHQsIHIsIG8sIG4sIDAsIDAsIDAsIDAsIDAsIDApO1xuICBpZiAoMCA9PT0gbCkgcmV0dXJuIHtcbiAgICB5ZWFyczogdCxcbiAgICBtb250aHM6IHIsXG4gICAgd2Vla3M6IG8sXG4gICAgZGF5czogblxuICB9O1xuICB2YXIgZCA9IEJpZ0ludChsKTtcbiAgdmFyIG0sXG4gICAgYyxcbiAgICBoID0gQmlnSW50KHQpLFxuICAgIHUgPSBCaWdJbnQociksXG4gICAgVCA9IEJpZ0ludChvKSxcbiAgICBmID0gQmlnSW50KG4pO1xuICBpICYmIChjID0gVG9UZW1wb3JhbERhdGUoaSksIG0gPSBHZXRTbG90KGMsIHApKTtcbiAgdmFyIHkgPSBuZXcgcyhsKSxcbiAgICBJID0gbmV3IHMoMCwgbCksXG4gICAgUyA9IG5ldyBzKDAsIDAsIGwpO1xuICBzd2l0Y2ggKGEpIHtcbiAgICBjYXNlIFwieWVhclwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICB7XG4gICAgICAgIGlmICghbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBtb250aHMgYmFsYW5jaW5nXCIpO1xuICAgICAgICB2YXIgX3QyNywgX3IzOTtcbiAgICAgICAgZm9yIChcInN0cmluZ1wiICE9IHR5cGVvZiBtICYmIChfdDI3ID0gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSwgX3IzOSA9IEdldE1ldGhvZChtLCBcImRhdGVVbnRpbFwiKSk7ICFpc1plcm8oaCk7KSB7XG4gICAgICAgICAgdmFyIF9vMTQgPSBDYWxlbmRhckRhdGVBZGQobSwgYywgeSwgdm9pZCAwLCBfdDI3KSxcbiAgICAgICAgICAgIF9uOSA9IFRlKG51bGwpO1xuICAgICAgICAgIF9uOS5sYXJnZXN0VW5pdCA9IFwibW9udGhcIjtcbiAgICAgICAgICB2YXIgX2E2ID0gQ2FsZW5kYXJEYXRlVW50aWwobSwgYywgX28xNCwgX245LCBfcjM5KSxcbiAgICAgICAgICAgIF9pOSA9IEJpZ0ludChHZXRTbG90KF9hNiwgRCkpO1xuICAgICAgICAgIGMgPSBfbzE0LCB1ID0gdSArIF9pOSwgaCA9IGggLSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwid2Vla1wiOlxuICAgICAge1xuICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3MgYmFsYW5jaW5nXCIpO1xuICAgICAgICB2YXIgX3QyOCA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlQWRkXCIpIDogdm9pZCAwO1xuICAgICAgICBmb3IgKDsgIWlzWmVybyhoKTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGU7XG4gICAgICAgICAgdmFyIF9yNDAgPSB2b2lkIDA7XG4gICAgICAgICAgKF9Nb3ZlUmVsYXRpdmVEYXRlID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDI4KSwgYyA9IF9Nb3ZlUmVsYXRpdmVEYXRlLnJlbGF0aXZlVG8sIF9yNDAgPSBfTW92ZVJlbGF0aXZlRGF0ZS5kYXlzKSwgZiA9IGYgKyBCaWdJbnQoX3I0MCksIGggPSBoIC0gZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgIWlzWmVybyh1KTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGUyO1xuICAgICAgICAgIHZhciBfcjQxID0gdm9pZCAwO1xuICAgICAgICAgIChfTW92ZVJlbGF0aXZlRGF0ZTIgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIEksIF90MjgpLCBjID0gX01vdmVSZWxhdGl2ZURhdGUyLnJlbGF0aXZlVG8sIF9yNDEgPSBfTW92ZVJlbGF0aXZlRGF0ZTIuZGF5cyksIGYgPSBmICsgQmlnSW50KF9yNDEpLCB1ID0gdSAtIGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzWmVybyhoKSAmJiBpc1plcm8odSkgJiYgaXNaZXJvKFQpKSBicmVhaztcbiAgICAgICAgaWYgKCFtKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGJhbGFuY2luZyBjYWxlbmRhciB1bml0c1wiKTtcbiAgICAgICAgdmFyIF90MjkgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBtID8gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICg7ICFpc1plcm8oaCk7KSB7XG4gICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMztcbiAgICAgICAgICB2YXIgX3I0MiA9IHZvaWQgMDtcbiAgICAgICAgICAoX01vdmVSZWxhdGl2ZURhdGUzID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDI5KSwgYyA9IF9Nb3ZlUmVsYXRpdmVEYXRlMy5yZWxhdGl2ZVRvLCBfcjQyID0gX01vdmVSZWxhdGl2ZURhdGUzLmRheXMpLCBmID0gZiArIEJpZ0ludChfcjQyKSwgaCA9IGggLSBkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyAhaXNaZXJvKHUpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTQ7XG4gICAgICAgICAgdmFyIF9yNDMgPSB2b2lkIDA7XG4gICAgICAgICAgKF9Nb3ZlUmVsYXRpdmVEYXRlNCA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3QyOSksIGMgPSBfTW92ZVJlbGF0aXZlRGF0ZTQucmVsYXRpdmVUbywgX3I0MyA9IF9Nb3ZlUmVsYXRpdmVEYXRlNC5kYXlzKSwgZiA9IGYgKyBCaWdJbnQoX3I0MyksIHUgPSB1IC0gZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgIWlzWmVybyhUKTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGU1O1xuICAgICAgICAgIHZhciBfcjQ0ID0gdm9pZCAwO1xuICAgICAgICAgIChfTW92ZVJlbGF0aXZlRGF0ZTUgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90MjkpLCBjID0gX01vdmVSZWxhdGl2ZURhdGU1LnJlbGF0aXZlVG8sIF9yNDQgPSBfTW92ZVJlbGF0aXZlRGF0ZTUuZGF5cyksIGYgPSBmICsgQmlnSW50KF9yNDQpLCBUID0gVCAtIGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5ZWFyczogTnVtYmVyKGgpLFxuICAgIG1vbnRoczogTnVtYmVyKHUpLFxuICAgIHdlZWtzOiBOdW1iZXIoVCksXG4gICAgZGF5czogTnVtYmVyKGYpXG4gIH07XG59XG5mdW5jdGlvbiBDYWxjdWxhdGVPZmZzZXRTaGlmdChlLCB0LCByLCBvLCBuKSB7XG4gIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkge1xuICAgIHZhciBfYTcgPSBHZXRTbG90KGUsIFMpLFxuICAgICAgX2kxMCA9IEdldFNsb3QoZSwgZyksXG4gICAgICBfcyA9IEdldFNsb3QoZSwgcCksXG4gICAgICBfbDIgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihfaTEwLCBfYTcpLFxuICAgICAgX2QyID0gQWRkWm9uZWREYXRlVGltZShfYTcsIF9pMTAsIF9zLCB0LCByLCBvLCBuLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoX2kxMCwgbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKF9kMikpIC0gX2wyO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQ3JlYXRlTmVnYXRlZFRlbXBvcmFsRHVyYXRpb24oZSkge1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKSgtR2V0U2xvdChlLCB3KSwgLUdldFNsb3QoZSwgRCksIC1HZXRTbG90KGUsIEcpLCAtR2V0U2xvdChlLCB2KSwgLUdldFNsb3QoZSwgQyksIC1HZXRTbG90KGUsIE8pLCAtR2V0U2xvdChlLCBiKSwgLUdldFNsb3QoZSwgRSksIC1HZXRTbG90KGUsIE0pLCAtR2V0U2xvdChlLCBSKSk7XG59XG5mdW5jdGlvbiBDb25zdHJhaW5Ub1JhbmdlKGUsIHQsIHIpIHtcbiAgcmV0dXJuIG9lKHIsIG5lKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIENvbnN0cmFpbklTT0RhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IENvbnN0cmFpblRvUmFuZ2UodCwgMSwgMTIpO1xuICByZXR1cm4ge1xuICAgIHllYXI6IGUsXG4gICAgbW9udGg6IG8sXG4gICAgZGF5OiBDb25zdHJhaW5Ub1JhbmdlKHIsIDEsIElTT0RheXNJbk1vbnRoKGUsIG8pKVxuICB9O1xufVxuZnVuY3Rpb24gUmVqZWN0VG9SYW5nZShlLCB0LCByKSB7XG4gIGlmIChlIDwgdCB8fCBlID4gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2U6IFwiLmNvbmNhdCh0LCBcIiA8PSBcIikuY29uY2F0KGUsIFwiIDw9IFwiKS5jb25jYXQocikpO1xufVxuZnVuY3Rpb24gUmVqZWN0SVNPRGF0ZShlLCB0LCByKSB7XG4gIFJlamVjdFRvUmFuZ2UodCwgMSwgMTIpLCBSZWplY3RUb1JhbmdlKHIsIDEsIElTT0RheXNJbk1vbnRoKGUsIHQpKTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVSYW5nZShlLCB0LCByKSB7XG4gIFJlamVjdERhdGVUaW1lUmFuZ2UoZSwgdCwgciwgMTIsIDAsIDAsIDAsIDAsIDApO1xufVxuZnVuY3Rpb24gUmVqZWN0VGltZShlLCB0LCByLCBvLCBuLCBhKSB7XG4gIFJlamVjdFRvUmFuZ2UoZSwgMCwgMjMpLCBSZWplY3RUb1JhbmdlKHQsIDAsIDU5KSwgUmVqZWN0VG9SYW5nZShyLCAwLCA1OSksIFJlamVjdFRvUmFuZ2UobywgMCwgOTk5KSwgUmVqZWN0VG9SYW5nZShuLCAwLCA5OTkpLCBSZWplY3RUb1JhbmdlKGEsIDAsIDk5OSk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsKSB7XG4gIFJlamVjdElTT0RhdGUoZSwgdCwgciksIFJlamVjdFRpbWUobywgbiwgYSwgaSwgcywgbCk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZVJhbmdlKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwpIHtcbiAgaWYgKFJlamVjdFRvUmFuZ2UoZSwgRmUsIFllKSwgZSA9PT0gRmUgJiYgbnVsbCA9PSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKGUsIHQsIHIgKyAxLCBvLCBuLCBhLCBpLCBzLCBsIC0gMSkgfHwgZSA9PT0gWWUgJiYgbnVsbCA9PSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKGUsIHQsIHIgLSAxLCBvLCBuLCBhLCBpLCBzLCBsICsgMSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2VcIik7XG59XG5mdW5jdGlvbiBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHModCkge1xuICBpZiAodCA8IE1lIHx8IHQgPiBSZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnN0YW50IG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlXCIpO1xufVxuZnVuY3Rpb24gUmVqZWN0RHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICB2YXIgbSA9IER1cmF0aW9uU2lnbihlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkKTtcbiAgZm9yICh2YXIgX2kxMSA9IDAsIF9hcnI0ID0gW2UsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGRdOyBfaTExIDwgX2FycjQubGVuZ3RoOyBfaTExKyspIHtcbiAgICB2YXIgX2MyID0gX2FycjRbX2kxMV07XG4gICAgaWYgKCFtZShfYzIpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluZmluaXRlIHZhbHVlcyBub3QgYWxsb3dlZCBhcyBkdXJhdGlvbiBmaWVsZHNcIik7XG4gICAgdmFyIF9lMjYgPSBzZShfYzIpO1xuICAgIGlmICgwICE9PSBfZTI2ICYmIF9lMjYgIT09IG0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzXCIpO1xuICB9XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSVNPRGF0ZShlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfczIgPSAtQ29tcGFyZUlTT0RhdGUoZSwgdCwgciwgbywgbiwgYSk7XG4gICAgICAgIGlmICgwID09PSBfczIpIHJldHVybiB7XG4gICAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgIGRheXM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9sMyA9IHtcbiAgICAgICAgICAgIHllYXI6IGUsXG4gICAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICAgIGRheTogclxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2QzID0ge1xuICAgICAgICAgICAgeWVhcjogbyxcbiAgICAgICAgICAgIG1vbnRoOiBuLFxuICAgICAgICAgICAgZGF5OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgdmFyIF9tMyA9IF9kMy55ZWFyIC0gX2wzLnllYXIsXG4gICAgICAgICAgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIDAsIDAsIDAsIFwiY29uc3RyYWluXCIpLFxuICAgICAgICAgIF9oID0gLUNvbXBhcmVJU09EYXRlKF9jMy55ZWFyLCBfYzMubW9udGgsIF9jMy5kYXksIG8sIG4sIGEpO1xuICAgICAgICBpZiAoMCA9PT0gX2gpIHJldHVybiBcInllYXJcIiA9PT0gaSA/IHtcbiAgICAgICAgICB5ZWFyczogX20zLFxuICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICBkYXlzOiAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgICAgbW9udGhzOiAxMiAqIF9tMyxcbiAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICBkYXlzOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdSA9IF9kMy5tb250aCAtIF9sMy5tb250aDtcbiAgICAgICAgaWYgKF9oICE9PSBfczIgJiYgKF9tMyAtPSBfczIsIF91ICs9IDEyICogX3MyKSwgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIF91LCAwLCAwLCBcImNvbnN0cmFpblwiKSwgX2ggPSAtQ29tcGFyZUlTT0RhdGUoX2MzLnllYXIsIF9jMy5tb250aCwgX2MzLmRheSwgbywgbiwgYSksIDAgPT09IF9oKSByZXR1cm4gXCJ5ZWFyXCIgPT09IGkgPyB7XG4gICAgICAgICAgeWVhcnM6IF9tMyxcbiAgICAgICAgICBtb250aHM6IF91LFxuICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgIGRheXM6IDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICBtb250aHM6IF91ICsgMTIgKiBfbTMsXG4gICAgICAgICAgd2Vla3M6IDAsXG4gICAgICAgICAgZGF5czogMFxuICAgICAgICB9O1xuICAgICAgICBfaCAhPT0gX3MyICYmIChfdSAtPSBfczIsIF91ID09PSAtX3MyICYmIChfbTMgLT0gX3MyLCBfdSA9IDExICogX3MyKSwgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIF91LCAwLCAwLCBcImNvbnN0cmFpblwiKSk7XG4gICAgICAgIHZhciBfVCA9IDA7XG4gICAgICAgIHJldHVybiBfVCA9IF9jMy5tb250aCA9PT0gX2QzLm1vbnRoID8gX2QzLmRheSAtIF9jMy5kYXkgOiBfczIgPCAwID8gLV9jMy5kYXkgLSAoSVNPRGF5c0luTW9udGgoX2QzLnllYXIsIF9kMy5tb250aCkgLSBfZDMuZGF5KSA6IF9kMy5kYXkgKyAoSVNPRGF5c0luTW9udGgoX2MzLnllYXIsIF9jMy5tb250aCkgLSBfYzMuZGF5KSwgXCJtb250aFwiID09PSBpICYmIChfdSArPSAxMiAqIF9tMywgX20zID0gMCksIHtcbiAgICAgICAgICB5ZWFyczogX20zLFxuICAgICAgICAgIG1vbnRoczogX3UsXG4gICAgICAgICAgd2Vla3M6IDAsXG4gICAgICAgICAgZGF5czogX1RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwid2Vla1wiOlxuICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9zMywgX2w0LCBfZDQ7XG4gICAgICAgIENvbXBhcmVJU09EYXRlKGUsIHQsIHIsIG8sIG4sIGEpIDwgMCA/IChfbDQgPSB7XG4gICAgICAgICAgeWVhcjogZSxcbiAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICBkYXk6IHJcbiAgICAgICAgfSwgX3MzID0ge1xuICAgICAgICAgIHllYXI6IG8sXG4gICAgICAgICAgbW9udGg6IG4sXG4gICAgICAgICAgZGF5OiBhXG4gICAgICAgIH0sIF9kNCA9IDEpIDogKF9sNCA9IHtcbiAgICAgICAgICB5ZWFyOiBvLFxuICAgICAgICAgIG1vbnRoOiBuLFxuICAgICAgICAgIGRheTogYVxuICAgICAgICB9LCBfczMgPSB7XG4gICAgICAgICAgeWVhcjogZSxcbiAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICBkYXk6IHJcbiAgICAgICAgfSwgX2Q0ID0gLTEpO1xuICAgICAgICB2YXIgX200ID0gRGF5T2ZZZWFyKF9zMy55ZWFyLCBfczMubW9udGgsIF9zMy5kYXkpIC0gRGF5T2ZZZWFyKF9sNC55ZWFyLCBfbDQubW9udGgsIF9sNC5kYXkpO1xuICAgICAgICBmb3IgKHZhciBfZTI3ID0gX2w0LnllYXI7IF9lMjcgPCBfczMueWVhcjsgKytfZTI3KSBfbTQgKz0gTGVhcFllYXIoX2UyNykgPyAzNjYgOiAzNjU7XG4gICAgICAgIHZhciBfYzQgPSAwO1xuICAgICAgICByZXR1cm4gXCJ3ZWVrXCIgPT09IGkgJiYgKF9jNCA9IGllKF9tNCAvIDcpLCBfbTQgJT0gNyksIF9jNCAqPSBfZDQsIF9tNCAqPSBfZDQsIHtcbiAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICBtb250aHM6IDAsXG4gICAgICAgICAgd2Vla3M6IF9jNCxcbiAgICAgICAgICBkYXlzOiBfbTRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXNzZXJ0IG5vdCByZWFjaGVkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSB7XG4gIHZhciBfQmFsYW5jZVRpbWUyO1xuICB2YXIgaCA9IGkgLSBlLFxuICAgIHUgPSBzIC0gdCxcbiAgICBUID0gbCAtIHIsXG4gICAgcCA9IGQgLSBvLFxuICAgIGYgPSBtIC0gbixcbiAgICB5ID0gYyAtIGE7XG4gIHZhciBJID0gRHVyYXRpb25TaWduKDAsIDAsIDAsIDAsIGgsIHUsIFQsIHAsIGYsIHkpO1xuICBoICo9IEksIHUgKj0gSSwgVCAqPSBJLCBwICo9IEksIGYgKj0gSSwgeSAqPSBJO1xuICB2YXIgUyA9IDA7XG4gIGlmICgoX0JhbGFuY2VUaW1lMiA9IEJhbGFuY2VUaW1lKGgsIHUsIFQsIHAsIGYsIHkpLCBTID0gX0JhbGFuY2VUaW1lMi5kZWx0YURheXMsIGggPSBfQmFsYW5jZVRpbWUyLmhvdXIsIHUgPSBfQmFsYW5jZVRpbWUyLm1pbnV0ZSwgVCA9IF9CYWxhbmNlVGltZTIuc2Vjb25kLCBwID0gX0JhbGFuY2VUaW1lMi5taWxsaXNlY29uZCwgZiA9IF9CYWxhbmNlVGltZTIubWljcm9zZWNvbmQsIHkgPSBfQmFsYW5jZVRpbWUyLm5hbm9zZWNvbmQpLCAwICE9IFMpIHRocm93IG5ldyBFcnJvcihcImFzc2VydGlvbiBmYWlsdXJlIGluIERpZmZlcmVuY2VUaW1lOiBfYnRfLltbRGF5c11dIHNob3VsZCBiZSAwXCIpO1xuICByZXR1cm4gaCAqPSBJLCB1ICo9IEksIFQgKj0gSSwgcCAqPSBJLCBmICo9IEksIHkgKj0gSSwge1xuICAgIGhvdXJzOiBoLFxuICAgIG1pbnV0ZXM6IHUsXG4gICAgc2Vjb25kczogVCxcbiAgICBtaWxsaXNlY29uZHM6IHAsXG4gICAgbWljcm9zZWNvbmRzOiBmLFxuICAgIG5hbm9zZWNvbmRzOiB5XG4gIH07XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSW5zdGFudCh0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjI7XG4gIHZhciBzID0gciAtIHQ7XG4gIHZhciBsID0gMCxcbiAgICBkID0gMCxcbiAgICBtID0gTnVtYmVyKHMgJSBEZSksXG4gICAgYyA9IE51bWJlcihzIC8gRGUgJSBEZSksXG4gICAgaCA9IE51bWJlcihzIC8gR2UgJSBEZSksXG4gICAgdSA9IE51bWJlcihzIC8gdmUpO1xuICByZXR1cm4gKF9Sb3VuZER1cmF0aW9uMiA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgdSwgaCwgYywgbSwgbywgbiwgaSksIGwgPSBfUm91bmREdXJhdGlvbjIuaG91cnMsIGQgPSBfUm91bmREdXJhdGlvbjIubWludXRlcywgdSA9IF9Sb3VuZER1cmF0aW9uMi5zZWNvbmRzLCBoID0gX1JvdW5kRHVyYXRpb24yLm1pbGxpc2Vjb25kcywgYyA9IF9Sb3VuZER1cmF0aW9uMi5taWNyb3NlY29uZHMsIG0gPSBfUm91bmREdXJhdGlvbjIubmFub3NlY29uZHMpLCBCYWxhbmNlRHVyYXRpb24oMCwgbCwgZCwgdSwgaCwgYywgbSwgYSk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgcCwgZiwgeSwgSSwgUywgZykge1xuICB2YXIgX0JhbGFuY2VJU09EYXRlMiwgX0JhbGFuY2VEdXJhdGlvbiwgX0JhbGFuY2VEdXJhdGlvbjI7XG4gIHZhciB3ID0gZSxcbiAgICBEID0gdCxcbiAgICBHID0gcixcbiAgICBfRGlmZmVyZW5jZVRpbWUgPSBEaWZmZXJlbmNlVGltZShvLCBuLCBhLCBpLCBzLCBsLCBoLCB1LCBULCBwLCBmLCB5KSxcbiAgICB2ID0gX0RpZmZlcmVuY2VUaW1lLmhvdXJzLFxuICAgIEMgPSBfRGlmZmVyZW5jZVRpbWUubWludXRlcyxcbiAgICBPID0gX0RpZmZlcmVuY2VUaW1lLnNlY29uZHMsXG4gICAgYiA9IF9EaWZmZXJlbmNlVGltZS5taWxsaXNlY29uZHMsXG4gICAgRSA9IF9EaWZmZXJlbmNlVGltZS5taWNyb3NlY29uZHMsXG4gICAgTSA9IF9EaWZmZXJlbmNlVGltZS5uYW5vc2Vjb25kcztcbiAgdmFyIFIgPSBEdXJhdGlvblNpZ24oMCwgMCwgMCwgMCwgdiwgQywgTywgYiwgRSwgTSk7XG4gIENvbXBhcmVJU09EYXRlKGQsIG0sIGMsIHcsIEQsIEcpID09PSAtUiAmJiAoKF9CYWxhbmNlSVNPRGF0ZTIgPSBCYWxhbmNlSVNPRGF0ZSh3LCBELCBHIC0gUiksIHcgPSBfQmFsYW5jZUlTT0RhdGUyLnllYXIsIEQgPSBfQmFsYW5jZUlTT0RhdGUyLm1vbnRoLCBHID0gX0JhbGFuY2VJU09EYXRlMi5kYXkpLCAoX0JhbGFuY2VEdXJhdGlvbiA9IEJhbGFuY2VEdXJhdGlvbigtUiwgdiwgQywgTywgYiwgRSwgTSwgUyksIHYgPSBfQmFsYW5jZUR1cmF0aW9uLmhvdXJzLCBDID0gX0JhbGFuY2VEdXJhdGlvbi5taW51dGVzLCBPID0gX0JhbGFuY2VEdXJhdGlvbi5zZWNvbmRzLCBiID0gX0JhbGFuY2VEdXJhdGlvbi5taWxsaXNlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uLm1pY3Jvc2Vjb25kcywgTSA9IF9CYWxhbmNlRHVyYXRpb24ubmFub3NlY29uZHMpKTtcbiAgdmFyIEYgPSBDcmVhdGVUZW1wb3JhbERhdGUodywgRCwgRywgSSksXG4gICAgWSA9IENyZWF0ZVRlbXBvcmFsRGF0ZShkLCBtLCBjLCBJKSxcbiAgICBQID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFwiZGF5XCIsIFMpLFxuICAgIFogPSBDb3B5T3B0aW9ucyhnKTtcbiAgWi5sYXJnZXN0VW5pdCA9IFA7XG4gIHZhciBfQ2FsZW5kYXJEYXRlVW50aWwgPSBDYWxlbmRhckRhdGVVbnRpbChJLCBGLCBZLCBaKSxcbiAgICBCID0gX0NhbGVuZGFyRGF0ZVVudGlsLnllYXJzLFxuICAgIE4gPSBfQ2FsZW5kYXJEYXRlVW50aWwubW9udGhzLFxuICAgIGogPSBfQ2FsZW5kYXJEYXRlVW50aWwud2Vla3MsXG4gICAgJCA9IF9DYWxlbmRhckRhdGVVbnRpbC5kYXlzO1xuICByZXR1cm4gKF9CYWxhbmNlRHVyYXRpb24yID0gQmFsYW5jZUR1cmF0aW9uKCQsIHYsIEMsIE8sIGIsIEUsIE0sIFMpLCAkID0gX0JhbGFuY2VEdXJhdGlvbjIuZGF5cywgdiA9IF9CYWxhbmNlRHVyYXRpb24yLmhvdXJzLCBDID0gX0JhbGFuY2VEdXJhdGlvbjIubWludXRlcywgTyA9IF9CYWxhbmNlRHVyYXRpb24yLnNlY29uZHMsIGIgPSBfQmFsYW5jZUR1cmF0aW9uMi5taWxsaXNlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uMi5taWNyb3NlY29uZHMsIE0gPSBfQmFsYW5jZUR1cmF0aW9uMi5uYW5vc2Vjb25kcyksIHtcbiAgICB5ZWFyczogQixcbiAgICBtb250aHM6IE4sXG4gICAgd2Vla3M6IGosXG4gICAgZGF5czogJCxcbiAgICBob3VyczogdixcbiAgICBtaW51dGVzOiBDLFxuICAgIHNlY29uZHM6IE8sXG4gICAgbWlsbGlzZWNvbmRzOiBiLFxuICAgIG1pY3Jvc2Vjb25kczogRSxcbiAgICBuYW5vc2Vjb25kczogTVxuICB9O1xufVxuZnVuY3Rpb24gRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUodCwgciwgbywgbiwgYSwgcCkge1xuICB2YXIgZiA9IHIgLSB0O1xuICBpZiAoZiA9PT0gSWUpIHJldHVybiB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIHdlZWtzOiAwLFxuICAgIGRheXM6IDAsXG4gICAgaG91cnM6IDAsXG4gICAgbWludXRlczogMCxcbiAgICBzZWNvbmRzOiAwLFxuICAgIG1pbGxpc2Vjb25kczogMCxcbiAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgbmFub3NlY29uZHM6IDBcbiAgfTtcbiAgdmFyIHkgPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgSSA9IG5ldyB5KHQpLFxuICAgIFMgPSBuZXcgeShyKSxcbiAgICBnID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBJLCBuKSxcbiAgICB3ID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBTLCBuKTtcbiAgdmFyIF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIgPSBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoR2V0U2xvdChnLCBpKSwgR2V0U2xvdChnLCBzKSwgR2V0U2xvdChnLCBsKSwgR2V0U2xvdChnLCBkKSwgR2V0U2xvdChnLCBtKSwgR2V0U2xvdChnLCBjKSwgR2V0U2xvdChnLCBoKSwgR2V0U2xvdChnLCB1KSwgR2V0U2xvdChnLCBUKSwgR2V0U2xvdCh3LCBpKSwgR2V0U2xvdCh3LCBzKSwgR2V0U2xvdCh3LCBsKSwgR2V0U2xvdCh3LCBkKSwgR2V0U2xvdCh3LCBtKSwgR2V0U2xvdCh3LCBjKSwgR2V0U2xvdCh3LCBoKSwgR2V0U2xvdCh3LCB1KSwgR2V0U2xvdCh3LCBUKSwgbiwgYSwgcCksXG4gICAgRCA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIueWVhcnMsXG4gICAgRyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIubW9udGhzLFxuICAgIHYgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0yLndlZWtzLFxuICAgIEMgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0yLmRheXM7XG4gIHZhciBPID0gQWRkWm9uZWREYXRlVGltZShJLCBvLCBuLCBELCBHLCB2LCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgdmFyIGIgPSByIC0gTztcbiAgdmFyIEUgPSBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoTywgbywgbik7XG4gIHZhciBfTmFub3NlY29uZHNUb0RheXMyID0gTmFub3NlY29uZHNUb0RheXMoYiwgRSk7XG4gIGIgPSBfTmFub3NlY29uZHNUb0RheXMyLm5hbm9zZWNvbmRzO1xuICBDID0gX05hbm9zZWNvbmRzVG9EYXlzMi5kYXlzO1xuICB2YXIgX0JhbGFuY2VEdXJhdGlvbjMgPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgTnVtYmVyKGIpLCBcImhvdXJcIiksXG4gICAgTSA9IF9CYWxhbmNlRHVyYXRpb24zLmhvdXJzLFxuICAgIFIgPSBfQmFsYW5jZUR1cmF0aW9uMy5taW51dGVzLFxuICAgIEYgPSBfQmFsYW5jZUR1cmF0aW9uMy5zZWNvbmRzLFxuICAgIFkgPSBfQmFsYW5jZUR1cmF0aW9uMy5taWxsaXNlY29uZHMsXG4gICAgUCA9IF9CYWxhbmNlRHVyYXRpb24zLm1pY3Jvc2Vjb25kcyxcbiAgICBaID0gX0JhbGFuY2VEdXJhdGlvbjMubmFub3NlY29uZHM7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IEQsXG4gICAgbW9udGhzOiBHLFxuICAgIHdlZWtzOiB2LFxuICAgIGRheXM6IEMsXG4gICAgaG91cnM6IE0sXG4gICAgbWludXRlczogUixcbiAgICBzZWNvbmRzOiBGLFxuICAgIG1pbGxpc2Vjb25kczogWSxcbiAgICBtaWNyb3NlY29uZHM6IFAsXG4gICAgbmFub3NlY29uZHM6IFpcbiAgfTtcbn1cbmZ1bmN0aW9uIEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCB0LCByLCBvLCBuLCBhKSB7XG4gIHZhciBpID0gVWUucmVkdWNlKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgdmFyIG4gPSB0WzBdLFxuICAgICAgYSA9IHRbMV0sXG4gICAgICBpID0gdFsyXTtcbiAgICByZXR1cm4gXCJkYXRldGltZVwiICE9PSByICYmIGkgIT09IHIgfHwgby5pbmNsdWRlcyhhKSB8fCBlLnB1c2goYSwgbiksIGU7XG4gIH0sIFtdKTtcbiAgdmFyIHMgPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJsYXJnZXN0VW5pdFwiLCByLCBcImF1dG9cIik7XG4gIGlmIChvLmluY2x1ZGVzKHMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImxhcmdlc3RVbml0IG11c3QgYmUgb25lIG9mIFwiLmNvbmNhdChpLmpvaW4oXCIsIFwiKSwgXCIsIG5vdCBcIikuY29uY2F0KHMpKTtcbiAgdmFyIGwgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCk7XG4gIHZhciBkID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpO1xuICBcInNpbmNlXCIgPT09IGUgJiYgKGQgPSBmdW5jdGlvbiBOZWdhdGVUZW1wb3JhbFJvdW5kaW5nTW9kZShlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgICByZXR1cm4gXCJmbG9vclwiO1xuICAgICAgY2FzZSBcImZsb29yXCI6XG4gICAgICAgIHJldHVybiBcImNlaWxcIjtcbiAgICAgIGNhc2UgXCJoYWxmQ2VpbFwiOlxuICAgICAgICByZXR1cm4gXCJoYWxmRmxvb3JcIjtcbiAgICAgIGNhc2UgXCJoYWxmRmxvb3JcIjpcbiAgICAgICAgcmV0dXJuIFwiaGFsZkNlaWxcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfShkKSk7XG4gIHZhciBtID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIHIsIG4pO1xuICBpZiAoby5pbmNsdWRlcyhtKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzbWFsbGVzdFVuaXQgbXVzdCBiZSBvbmUgb2YgXCIuY29uY2F0KGkuam9pbihcIiwgXCIpLCBcIiwgbm90IFwiKS5jb25jYXQobSkpO1xuICB2YXIgYyA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhhLCBtKTtcbiAgaWYgKFwiYXV0b1wiID09PSBzICYmIChzID0gYyksIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhzLCBtKSAhPT0gcykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsYXJnZXN0VW5pdCBcIi5jb25jYXQocywgXCIgY2Fubm90IGJlIHNtYWxsZXIgdGhhbiBzbWFsbGVzdFVuaXQgXCIpLmNvbmNhdChtKSk7XG4gIHZhciBoID0ge1xuICAgIGhvdXI6IDI0LFxuICAgIG1pbnV0ZTogNjAsXG4gICAgc2Vjb25kOiA2MCxcbiAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgbmFub3NlY29uZDogMWUzXG4gIH1bbV07XG4gIHJldHVybiB2b2lkIDAgIT09IGggJiYgVmFsaWRhdGVUZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KGwsIGgsICExKSwge1xuICAgIGxhcmdlc3RVbml0OiBzLFxuICAgIHJvdW5kaW5nSW5jcmVtZW50OiBsLFxuICAgIHJvdW5kaW5nTW9kZTogZCxcbiAgICBzbWFsbGVzdFVuaXQ6IG1cbiAgfTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbEluc3RhbnQoZSwgdCwgciwgbykge1xuICB2YXIgYSA9IFwic2luY2VcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBpID0gVG9UZW1wb3JhbEluc3RhbnQociksXG4gICAgcyA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBDb3B5T3B0aW9ucyhvKSwgXCJ0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJzZWNvbmRcIiksXG4gICAgbCA9IEdldFNsb3QodCwgbiksXG4gICAgZCA9IEdldFNsb3QoaSwgbik7XG4gIHZhciBfRGlmZmVyZW5jZUluc3RhbnQgPSBEaWZmZXJlbmNlSW5zdGFudChsLCBkLCBzLnJvdW5kaW5nSW5jcmVtZW50LCBzLnNtYWxsZXN0VW5pdCwgcy5sYXJnZXN0VW5pdCwgcy5yb3VuZGluZ01vZGUpLFxuICAgIG0gPSBfRGlmZmVyZW5jZUluc3RhbnQuaG91cnMsXG4gICAgYyA9IF9EaWZmZXJlbmNlSW5zdGFudC5taW51dGVzLFxuICAgIGggPSBfRGlmZmVyZW5jZUluc3RhbnQuc2Vjb25kcyxcbiAgICB1ID0gX0RpZmZlcmVuY2VJbnN0YW50Lm1pbGxpc2Vjb25kcyxcbiAgICBUID0gX0RpZmZlcmVuY2VJbnN0YW50Lm1pY3Jvc2Vjb25kcyxcbiAgICBwID0gX0RpZmZlcmVuY2VJbnN0YW50Lm5hbm9zZWNvbmRzO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKSgwLCAwLCAwLCAwLCBhICogbSwgYSAqIGMsIGEgKiBoLCBhICogdSwgYSAqIFQsIGEgKiBwKTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluRGF0ZShlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjM7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsRGF0ZShyKSxcbiAgICBpID0gR2V0U2xvdCh0LCBwKTtcbiAgVGhyb3dJZkNhbGVuZGFyc05vdEVxdWFsKGksIEdldFNsb3QoYSwgcCksIFwiY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXNcIik7XG4gIHZhciBzID0gQ29weU9wdGlvbnMobyksXG4gICAgbCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBzLCBcImRhdGVcIiwgW10sIFwiZGF5XCIsIFwiZGF5XCIpO1xuICBzLmxhcmdlc3RVbml0ID0gbC5sYXJnZXN0VW5pdDtcbiAgdmFyIF9DYWxlbmRhckRhdGVVbnRpbDIgPSBDYWxlbmRhckRhdGVVbnRpbChpLCB0LCBhLCBzKSxcbiAgICBkID0gX0NhbGVuZGFyRGF0ZVVudGlsMi55ZWFycyxcbiAgICBtID0gX0NhbGVuZGFyRGF0ZVVudGlsMi5tb250aHMsXG4gICAgYyA9IF9DYWxlbmRhckRhdGVVbnRpbDIud2Vla3MsXG4gICAgaCA9IF9DYWxlbmRhckRhdGVVbnRpbDIuZGF5cztcbiAgXCJkYXlcIiA9PT0gbC5zbWFsbGVzdFVuaXQgJiYgMSA9PT0gbC5yb3VuZGluZ0luY3JlbWVudCB8fCAoX1JvdW5kRHVyYXRpb24zID0gUm91bmREdXJhdGlvbihkLCBtLCBjLCBoLCAwLCAwLCAwLCAwLCAwLCAwLCBsLnJvdW5kaW5nSW5jcmVtZW50LCBsLnNtYWxsZXN0VW5pdCwgbC5yb3VuZGluZ01vZGUsIHQpLCBkID0gX1JvdW5kRHVyYXRpb24zLnllYXJzLCBtID0gX1JvdW5kRHVyYXRpb24zLm1vbnRocywgYyA9IF9Sb3VuZER1cmF0aW9uMy53ZWVrcywgaCA9IF9Sb3VuZER1cmF0aW9uMy5kYXlzLCBfUm91bmREdXJhdGlvbjMpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKShuICogZCwgbiAqIG0sIG4gKiBjLCBuICogaCwgMCwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpbkRhdGVUaW1lKGUsIHQsIHIsIG8pIHtcbiAgdmFyIF9Sb3VuZER1cmF0aW9uNCwgX0JhbGFuY2VEdXJhdGlvbjQ7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsRGF0ZVRpbWUociksXG4gICAgZiA9IEdldFNsb3QodCwgcCk7XG4gIFRocm93SWZDYWxlbmRhcnNOb3RFcXVhbChmLCBHZXRTbG90KGEsIHApLCBcImNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzXCIpO1xuICB2YXIgeSA9IENvcHlPcHRpb25zKG8pLFxuICAgIEkgPSBHZXREaWZmZXJlbmNlU2V0dGluZ3MoZSwgeSwgXCJkYXRldGltZVwiLCBbXSwgXCJuYW5vc2Vjb25kXCIsIFwiZGF5XCIpO1xuICB2YXIgX0RpZmZlcmVuY2VJU09EYXRlVGltMyA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KHQsIGkpLCBHZXRTbG90KHQsIHMpLCBHZXRTbG90KHQsIGwpLCBHZXRTbG90KHQsIGQpLCBHZXRTbG90KHQsIG0pLCBHZXRTbG90KHQsIGMpLCBHZXRTbG90KHQsIGgpLCBHZXRTbG90KHQsIHUpLCBHZXRTbG90KHQsIFQpLCBHZXRTbG90KGEsIGkpLCBHZXRTbG90KGEsIHMpLCBHZXRTbG90KGEsIGwpLCBHZXRTbG90KGEsIGQpLCBHZXRTbG90KGEsIG0pLCBHZXRTbG90KGEsIGMpLCBHZXRTbG90KGEsIGgpLCBHZXRTbG90KGEsIHUpLCBHZXRTbG90KGEsIFQpLCBmLCBJLmxhcmdlc3RVbml0LCB5KSxcbiAgICBTID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy55ZWFycyxcbiAgICBnID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5tb250aHMsXG4gICAgdyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMud2Vla3MsXG4gICAgRCA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMuZGF5cyxcbiAgICBHID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5ob3VycyxcbiAgICB2ID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5taW51dGVzLFxuICAgIEMgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0zLnNlY29uZHMsXG4gICAgTyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMubWlsbGlzZWNvbmRzLFxuICAgIGIgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0zLm1pY3Jvc2Vjb25kcyxcbiAgICBFID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5uYW5vc2Vjb25kcztcbiAgdmFyIE0gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHQpO1xuICAoX1JvdW5kRHVyYXRpb240ID0gUm91bmREdXJhdGlvbihTLCBnLCB3LCBELCBHLCB2LCBDLCBPLCBiLCBFLCBJLnJvdW5kaW5nSW5jcmVtZW50LCBJLnNtYWxsZXN0VW5pdCwgSS5yb3VuZGluZ01vZGUsIE0pLCBTID0gX1JvdW5kRHVyYXRpb240LnllYXJzLCBnID0gX1JvdW5kRHVyYXRpb240Lm1vbnRocywgdyA9IF9Sb3VuZER1cmF0aW9uNC53ZWVrcywgRCA9IF9Sb3VuZER1cmF0aW9uNC5kYXlzLCBHID0gX1JvdW5kRHVyYXRpb240LmhvdXJzLCB2ID0gX1JvdW5kRHVyYXRpb240Lm1pbnV0ZXMsIEMgPSBfUm91bmREdXJhdGlvbjQuc2Vjb25kcywgTyA9IF9Sb3VuZER1cmF0aW9uNC5taWxsaXNlY29uZHMsIGIgPSBfUm91bmREdXJhdGlvbjQubWljcm9zZWNvbmRzLCBFID0gX1JvdW5kRHVyYXRpb240Lm5hbm9zZWNvbmRzKSwgKF9CYWxhbmNlRHVyYXRpb240ID0gQmFsYW5jZUR1cmF0aW9uKEQsIEcsIHYsIEMsIE8sIGIsIEUsIEkubGFyZ2VzdFVuaXQpLCBEID0gX0JhbGFuY2VEdXJhdGlvbjQuZGF5cywgRyA9IF9CYWxhbmNlRHVyYXRpb240LmhvdXJzLCB2ID0gX0JhbGFuY2VEdXJhdGlvbjQubWludXRlcywgQyA9IF9CYWxhbmNlRHVyYXRpb240LnNlY29uZHMsIE8gPSBfQmFsYW5jZUR1cmF0aW9uNC5taWxsaXNlY29uZHMsIGIgPSBfQmFsYW5jZUR1cmF0aW9uNC5taWNyb3NlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uNC5uYW5vc2Vjb25kcyk7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKG4gKiBTLCBuICogZywgbiAqIHcsIG4gKiBELCBuICogRywgbiAqIHYsIG4gKiBDLCBuICogTywgbiAqIGIsIG4gKiBFKTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjUsIF9CYWxhbmNlRHVyYXRpb241O1xuICB2YXIgbiA9IFwic2luY2VcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBhID0gVG9UZW1wb3JhbFRpbWUociksXG4gICAgaSA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBDb3B5T3B0aW9ucyhvKSwgXCJ0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJob3VyXCIpO1xuICB2YXIgX0RpZmZlcmVuY2VUaW1lMiA9IERpZmZlcmVuY2VUaW1lKEdldFNsb3QodCwgZCksIEdldFNsb3QodCwgbSksIEdldFNsb3QodCwgYyksIEdldFNsb3QodCwgaCksIEdldFNsb3QodCwgdSksIEdldFNsb3QodCwgVCksIEdldFNsb3QoYSwgZCksIEdldFNsb3QoYSwgbSksIEdldFNsb3QoYSwgYyksIEdldFNsb3QoYSwgaCksIEdldFNsb3QoYSwgdSksIEdldFNsb3QoYSwgVCkpLFxuICAgIHMgPSBfRGlmZmVyZW5jZVRpbWUyLmhvdXJzLFxuICAgIGwgPSBfRGlmZmVyZW5jZVRpbWUyLm1pbnV0ZXMsXG4gICAgcCA9IF9EaWZmZXJlbmNlVGltZTIuc2Vjb25kcyxcbiAgICBmID0gX0RpZmZlcmVuY2VUaW1lMi5taWxsaXNlY29uZHMsXG4gICAgeSA9IF9EaWZmZXJlbmNlVGltZTIubWljcm9zZWNvbmRzLFxuICAgIEkgPSBfRGlmZmVyZW5jZVRpbWUyLm5hbm9zZWNvbmRzO1xuICAoX1JvdW5kRHVyYXRpb241ID0gUm91bmREdXJhdGlvbigwLCAwLCAwLCAwLCBzLCBsLCBwLCBmLCB5LCBJLCBpLnJvdW5kaW5nSW5jcmVtZW50LCBpLnNtYWxsZXN0VW5pdCwgaS5yb3VuZGluZ01vZGUpLCBzID0gX1JvdW5kRHVyYXRpb241LmhvdXJzLCBsID0gX1JvdW5kRHVyYXRpb241Lm1pbnV0ZXMsIHAgPSBfUm91bmREdXJhdGlvbjUuc2Vjb25kcywgZiA9IF9Sb3VuZER1cmF0aW9uNS5taWxsaXNlY29uZHMsIHkgPSBfUm91bmREdXJhdGlvbjUubWljcm9zZWNvbmRzLCBJID0gX1JvdW5kRHVyYXRpb241Lm5hbm9zZWNvbmRzKSwgKF9CYWxhbmNlRHVyYXRpb241ID0gQmFsYW5jZUR1cmF0aW9uKDAsIHMsIGwsIHAsIGYsIHksIEksIGkubGFyZ2VzdFVuaXQpLCBzID0gX0JhbGFuY2VEdXJhdGlvbjUuaG91cnMsIGwgPSBfQmFsYW5jZUR1cmF0aW9uNS5taW51dGVzLCBwID0gX0JhbGFuY2VEdXJhdGlvbjUuc2Vjb25kcywgZiA9IF9CYWxhbmNlRHVyYXRpb241Lm1pbGxpc2Vjb25kcywgeSA9IF9CYWxhbmNlRHVyYXRpb241Lm1pY3Jvc2Vjb25kcywgSSA9IF9CYWxhbmNlRHVyYXRpb241Lm5hbm9zZWNvbmRzKTtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoMCwgMCwgMCwgMCwgbiAqIHMsIG4gKiBsLCBuICogcCwgbiAqIGYsIG4gKiB5LCBuICogSSk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpblllYXJNb250aChlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjY7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsWWVhck1vbnRoKHIpLFxuICAgIGkgPSBHZXRTbG90KHQsIHApO1xuICBUaHJvd0lmQ2FsZW5kYXJzTm90RXF1YWwoaSwgR2V0U2xvdChhLCBwKSwgXCJjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBtb250aHNcIik7XG4gIHZhciBzID0gQ29weU9wdGlvbnMobyksXG4gICAgbCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBzLCBcImRhdGVcIiwgW1wid2Vla1wiLCBcImRheVwiXSwgXCJtb250aFwiLCBcInllYXJcIik7XG4gIHMubGFyZ2VzdFVuaXQgPSBsLmxhcmdlc3RVbml0O1xuICB2YXIgZCA9IENhbGVuZGFyRmllbGRzKGksIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLFxuICAgIG0gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgZCwgW10pO1xuICBtLmRheSA9IDE7XG4gIHZhciBjID0gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhpLCBtKSxcbiAgICBoID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIGQsIFtdKTtcbiAgaC5kYXkgPSAxO1xuICB2YXIgdSA9IENhbGVuZGFyRGF0ZUZyb21GaWVsZHMoaSwgaCk7XG4gIHZhciBfQ2FsZW5kYXJEYXRlVW50aWwzID0gQ2FsZW5kYXJEYXRlVW50aWwoaSwgYywgdSwgcyksXG4gICAgVCA9IF9DYWxlbmRhckRhdGVVbnRpbDMueWVhcnMsXG4gICAgZiA9IF9DYWxlbmRhckRhdGVVbnRpbDMubW9udGhzO1xuICBcIm1vbnRoXCIgPT09IGwuc21hbGxlc3RVbml0ICYmIDEgPT09IGwucm91bmRpbmdJbmNyZW1lbnQgfHwgKF9Sb3VuZER1cmF0aW9uNiA9IFJvdW5kRHVyYXRpb24oVCwgZiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgbC5yb3VuZGluZ0luY3JlbWVudCwgbC5zbWFsbGVzdFVuaXQsIGwucm91bmRpbmdNb2RlLCBjKSwgVCA9IF9Sb3VuZER1cmF0aW9uNi55ZWFycywgZiA9IF9Sb3VuZER1cmF0aW9uNi5tb250aHMsIF9Sb3VuZER1cmF0aW9uNik7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKG4gKiBULCBuICogZiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQsIHIsIG8pIHtcbiAgdmFyIF9EaWZmZXJlbmNlSW5zdGFudDI7XG4gIHZhciBhID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGkgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShyKSxcbiAgICBzID0gR2V0U2xvdCh0LCBwKTtcbiAgVGhyb3dJZkNhbGVuZGFyc05vdEVxdWFsKHMsIEdldFNsb3QoaSwgcCksIFwiY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXNcIik7XG4gIHZhciBsID0gQ29weU9wdGlvbnMobyksXG4gICAgZCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBsLCBcImRhdGV0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJob3VyXCIpO1xuICBsLmxhcmdlc3RVbml0ID0gZC5sYXJnZXN0VW5pdDtcbiAgdmFyIG0gPSBHZXRTbG90KHQsIG4pLFxuICAgIGMgPSBHZXRTbG90KGksIG4pO1xuICB2YXIgaCwgdSwgVCwgZiwgeSwgSSwgUywgdywgRCwgRztcbiAgaWYgKFwieWVhclwiICE9PSBkLmxhcmdlc3RVbml0ICYmIFwibW9udGhcIiAhPT0gZC5sYXJnZXN0VW5pdCAmJiBcIndlZWtcIiAhPT0gZC5sYXJnZXN0VW5pdCAmJiBcImRheVwiICE9PSBkLmxhcmdlc3RVbml0KSBoID0gMCwgdSA9IDAsIFQgPSAwLCBmID0gMCwgKF9EaWZmZXJlbmNlSW5zdGFudDIgPSBEaWZmZXJlbmNlSW5zdGFudChtLCBjLCBkLnJvdW5kaW5nSW5jcmVtZW50LCBkLnNtYWxsZXN0VW5pdCwgZC5sYXJnZXN0VW5pdCwgZC5yb3VuZGluZ01vZGUpLCB5ID0gX0RpZmZlcmVuY2VJbnN0YW50Mi5ob3VycywgSSA9IF9EaWZmZXJlbmNlSW5zdGFudDIubWludXRlcywgUyA9IF9EaWZmZXJlbmNlSW5zdGFudDIuc2Vjb25kcywgdyA9IF9EaWZmZXJlbmNlSW5zdGFudDIubWlsbGlzZWNvbmRzLCBEID0gX0RpZmZlcmVuY2VJbnN0YW50Mi5taWNyb3NlY29uZHMsIEcgPSBfRGlmZmVyZW5jZUluc3RhbnQyLm5hbm9zZWNvbmRzKTtlbHNlIHtcbiAgICB2YXIgX0RpZmZlcmVuY2Vab25lZERhdGVULCBfUm91bmREdXJhdGlvbjcsIF9BZGp1c3RSb3VuZGVkRHVyYXRpbztcbiAgICB2YXIgX2UyOCA9IEdldFNsb3QodCwgZyk7XG4gICAgaWYgKCFUaW1lWm9uZUVxdWFscyhfZTI4LCBHZXRTbG90KGksIGcpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaGVuIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgYmV0d2VlbiB0aW1lIHpvbmVzLCBsYXJnZXN0VW5pdCBtdXN0IGJlICdob3Vycycgb3Igc21hbGxlciBiZWNhdXNlIGRheSBsZW5ndGhzIGNhbiB2YXJ5IGJldHdlZW4gdGltZSB6b25lcyBkdWUgdG8gRFNUIG9yIHRpbWUgem9uZSBvZmZzZXQgY2hhbmdlcy5cIik7XG4gICAgKF9EaWZmZXJlbmNlWm9uZWREYXRlVCA9IERpZmZlcmVuY2Vab25lZERhdGVUaW1lKG0sIGMsIF9lMjgsIHMsIGQubGFyZ2VzdFVuaXQsIGwpLCBoID0gX0RpZmZlcmVuY2Vab25lZERhdGVULnllYXJzLCB1ID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm1vbnRocywgVCA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC53ZWVrcywgZiA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC5kYXlzLCB5ID0gX0RpZmZlcmVuY2Vab25lZERhdGVULmhvdXJzLCBJID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm1pbnV0ZXMsIFMgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQuc2Vjb25kcywgdyA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC5taWxsaXNlY29uZHMsIEQgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQubWljcm9zZWNvbmRzLCBHID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm5hbm9zZWNvbmRzKSwgKF9Sb3VuZER1cmF0aW9uNyA9IFJvdW5kRHVyYXRpb24oaCwgdSwgVCwgZiwgeSwgSSwgUywgdywgRCwgRywgZC5yb3VuZGluZ0luY3JlbWVudCwgZC5zbWFsbGVzdFVuaXQsIGQucm91bmRpbmdNb2RlLCB0KSwgaCA9IF9Sb3VuZER1cmF0aW9uNy55ZWFycywgdSA9IF9Sb3VuZER1cmF0aW9uNy5tb250aHMsIFQgPSBfUm91bmREdXJhdGlvbjcud2Vla3MsIGYgPSBfUm91bmREdXJhdGlvbjcuZGF5cywgeSA9IF9Sb3VuZER1cmF0aW9uNy5ob3VycywgSSA9IF9Sb3VuZER1cmF0aW9uNy5taW51dGVzLCBTID0gX1JvdW5kRHVyYXRpb243LnNlY29uZHMsIHcgPSBfUm91bmREdXJhdGlvbjcubWlsbGlzZWNvbmRzLCBEID0gX1JvdW5kRHVyYXRpb243Lm1pY3Jvc2Vjb25kcywgRyA9IF9Sb3VuZER1cmF0aW9uNy5uYW5vc2Vjb25kcyksIChfQWRqdXN0Um91bmRlZER1cmF0aW8gPSBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKGgsIHUsIFQsIGYsIHksIEksIFMsIHcsIEQsIEcsIGQucm91bmRpbmdJbmNyZW1lbnQsIGQuc21hbGxlc3RVbml0LCBkLnJvdW5kaW5nTW9kZSwgdCksIGggPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ueWVhcnMsIHUgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubW9udGhzLCBUID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLndlZWtzLCBmID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLmRheXMsIHkgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8uaG91cnMsIEkgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubWludXRlcywgUyA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpby5zZWNvbmRzLCB3ID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLm1pbGxpc2Vjb25kcywgRCA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpby5taWNyb3NlY29uZHMsIEcgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubmFub3NlY29uZHMpO1xuICB9XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKGEgKiBoLCBhICogdSwgYSAqIFQsIGEgKiBmLCBhICogeSwgYSAqIEksIGEgKiBTLCBhICogdywgYSAqIEQsIGEgKiBHKTtcbn1cbmZ1bmN0aW9uIEFkZElTT0RhdGUoZSwgdCwgciwgbywgbiwgYSwgaSwgcykge1xuICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGg0LCBfUmVndWxhdGVJU09EYXRlLCBfQmFsYW5jZUlTT0RhdGUzO1xuICB2YXIgbCA9IGUsXG4gICAgZCA9IHQsXG4gICAgbSA9IHIsXG4gICAgYyA9IGEsXG4gICAgaCA9IGk7XG4gIHJldHVybiBsICs9IG8sIGQgKz0gbiwgKF9CYWxhbmNlSVNPWWVhck1vbnRoNCA9IEJhbGFuY2VJU09ZZWFyTW9udGgobCwgZCksIGwgPSBfQmFsYW5jZUlTT1llYXJNb250aDQueWVhciwgZCA9IF9CYWxhbmNlSVNPWWVhck1vbnRoNC5tb250aCksIChfUmVndWxhdGVJU09EYXRlID0gUmVndWxhdGVJU09EYXRlKGwsIGQsIG0sIHMpLCBsID0gX1JlZ3VsYXRlSVNPRGF0ZS55ZWFyLCBkID0gX1JlZ3VsYXRlSVNPRGF0ZS5tb250aCwgbSA9IF9SZWd1bGF0ZUlTT0RhdGUuZGF5KSwgaCArPSA3ICogYywgbSArPSBoLCAoX0JhbGFuY2VJU09EYXRlMyA9IEJhbGFuY2VJU09EYXRlKGwsIGQsIG0pLCBsID0gX0JhbGFuY2VJU09EYXRlMy55ZWFyLCBkID0gX0JhbGFuY2VJU09EYXRlMy5tb250aCwgbSA9IF9CYWxhbmNlSVNPRGF0ZTMuZGF5KSwge1xuICAgIHllYXI6IGwsXG4gICAgbW9udGg6IGQsXG4gICAgZGF5OiBtXG4gIH07XG59XG5mdW5jdGlvbiBBZGRUaW1lKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpIHtcbiAgdmFyIF9CYWxhbmNlVGltZTM7XG4gIHZhciBoID0gZSxcbiAgICB1ID0gdCxcbiAgICBUID0gcixcbiAgICBwID0gbyxcbiAgICBmID0gbixcbiAgICB5ID0gYTtcbiAgaCArPSBpLCB1ICs9IHMsIFQgKz0gbCwgcCArPSBkLCBmICs9IG0sIHkgKz0gYztcbiAgdmFyIEkgPSAwO1xuICByZXR1cm4gKF9CYWxhbmNlVGltZTMgPSBCYWxhbmNlVGltZShoLCB1LCBULCBwLCBmLCB5KSwgSSA9IF9CYWxhbmNlVGltZTMuZGVsdGFEYXlzLCBoID0gX0JhbGFuY2VUaW1lMy5ob3VyLCB1ID0gX0JhbGFuY2VUaW1lMy5taW51dGUsIFQgPSBfQmFsYW5jZVRpbWUzLnNlY29uZCwgcCA9IF9CYWxhbmNlVGltZTMubWlsbGlzZWNvbmQsIGYgPSBfQmFsYW5jZVRpbWUzLm1pY3Jvc2Vjb25kLCB5ID0gX0JhbGFuY2VUaW1lMy5uYW5vc2Vjb25kKSwge1xuICAgIGRlbHRhRGF5czogSSxcbiAgICBob3VyOiBoLFxuICAgIG1pbnV0ZTogdSxcbiAgICBzZWNvbmQ6IFQsXG4gICAgbWlsbGlzZWNvbmQ6IHAsXG4gICAgbWljcm9zZWNvbmQ6IGYsXG4gICAgbmFub3NlY29uZDogeVxuICB9O1xufVxuZnVuY3Rpb24gQWRkRHVyYXRpb24odCwgciwgbywgYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgZiwgeSwgSSwgdywgRCwgRywgdiwgQykge1xuICB2YXIgTyA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh0LCByLCBvLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSwgRGVmYXVsdFRlbXBvcmFsTGFyZ2VzdFVuaXQoaCwgdSwgVCwgZiwgeSwgSSwgdywgRCwgRywgdikpO1xuICB2YXIgYiwgRSwgTSwgUiwgRiwgWSwgUCwgWiwgQiwgTjtcbiAgaWYgKEMpIHtcbiAgICBpZiAoSXNUZW1wb3JhbERhdGUoQykpIHtcbiAgICAgIHZhciBfQ2FsZW5kYXJEYXRlVW50aWw0LCBfQmFsYW5jZUR1cmF0aW9uNjtcbiAgICAgIHZhciBfbjEwID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICAgICAgX1MyID0gR2V0U2xvdChDLCBwKSxcbiAgICAgICAgX2cgPSBuZXcgX24xMCh0LCByLCBvLCBhLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgX2ogPSBuZXcgX24xMChoLCB1LCBULCBmLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgXyQgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBfUzIgPyBHZXRNZXRob2QoX1MyLCBcImRhdGVBZGRcIikgOiB2b2lkIDAsXG4gICAgICAgIF9rID0gQ2FsZW5kYXJEYXRlQWRkKF9TMiwgQywgX2csIHZvaWQgMCwgXyQpLFxuICAgICAgICBfVSA9IENhbGVuZGFyRGF0ZUFkZChfUzIsIF9rLCBfaiwgdm9pZCAwLCBfJCksXG4gICAgICAgIF9BID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFwiZGF5XCIsIE8pLFxuICAgICAgICBfTCA9IFRlKG51bGwpO1xuICAgICAgX0wubGFyZ2VzdFVuaXQgPSBfQSwgKF9DYWxlbmRhckRhdGVVbnRpbDQgPSBDYWxlbmRhckRhdGVVbnRpbChfUzIsIEMsIF9VLCBfTCksIGIgPSBfQ2FsZW5kYXJEYXRlVW50aWw0LnllYXJzLCBFID0gX0NhbGVuZGFyRGF0ZVVudGlsNC5tb250aHMsIE0gPSBfQ2FsZW5kYXJEYXRlVW50aWw0LndlZWtzLCBSID0gX0NhbGVuZGFyRGF0ZVVudGlsNC5kYXlzKSwgKF9CYWxhbmNlRHVyYXRpb242ID0gQmFsYW5jZUR1cmF0aW9uKFIsIEJpZ0ludChpKSArIEJpZ0ludCh5KSwgQmlnSW50KHMpICsgQmlnSW50KEkpLCBCaWdJbnQobCkgKyBCaWdJbnQodyksIEJpZ0ludChkKSArIEJpZ0ludChEKSwgQmlnSW50KG0pICsgQmlnSW50KEcpLCBCaWdJbnQoYykgKyBCaWdJbnQodiksIE8pLCBSID0gX0JhbGFuY2VEdXJhdGlvbjYuZGF5cywgRiA9IF9CYWxhbmNlRHVyYXRpb242LmhvdXJzLCBZID0gX0JhbGFuY2VEdXJhdGlvbjYubWludXRlcywgUCA9IF9CYWxhbmNlRHVyYXRpb242LnNlY29uZHMsIFogPSBfQmFsYW5jZUR1cmF0aW9uNi5taWxsaXNlY29uZHMsIEIgPSBfQmFsYW5jZUR1cmF0aW9uNi5taWNyb3NlY29uZHMsIE4gPSBfQmFsYW5jZUR1cmF0aW9uNi5uYW5vc2Vjb25kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfRGlmZmVyZW5jZUluc3RhbnQzLCBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyO1xuICAgICAgdmFyIF9lMjkgPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgICAgIF9qMiA9IEdldFNsb3QoQywgZyksXG4gICAgICAgIF8kMiA9IEdldFNsb3QoQywgcCksXG4gICAgICAgIF9rMiA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChDLCBTKSwgX2oyLCBfJDIsIHQsIHIsIG8sIGEsIGksIHMsIGwsIGQsIG0sIGMpLFxuICAgICAgICBfVTIgPSBBZGRab25lZERhdGVUaW1lKG5ldyBfZTI5KF9rMiksIF9qMiwgXyQyLCBoLCB1LCBULCBmLCB5LCBJLCB3LCBELCBHLCB2KTtcbiAgICAgIFwieWVhclwiICE9PSBPICYmIFwibW9udGhcIiAhPT0gTyAmJiBcIndlZWtcIiAhPT0gTyAmJiBcImRheVwiICE9PSBPID8gKGIgPSAwLCBFID0gMCwgTSA9IDAsIFIgPSAwLCAoX0RpZmZlcmVuY2VJbnN0YW50MyA9IERpZmZlcmVuY2VJbnN0YW50KEdldFNsb3QoQywgbiksIF9VMiwgMSwgXCJuYW5vc2Vjb25kXCIsIE8sIFwiaGFsZkV4cGFuZFwiKSwgRiA9IF9EaWZmZXJlbmNlSW5zdGFudDMuaG91cnMsIFkgPSBfRGlmZmVyZW5jZUluc3RhbnQzLm1pbnV0ZXMsIFAgPSBfRGlmZmVyZW5jZUluc3RhbnQzLnNlY29uZHMsIFogPSBfRGlmZmVyZW5jZUluc3RhbnQzLm1pbGxpc2Vjb25kcywgQiA9IF9EaWZmZXJlbmNlSW5zdGFudDMubWljcm9zZWNvbmRzLCBOID0gX0RpZmZlcmVuY2VJbnN0YW50My5uYW5vc2Vjb25kcykpIDogKF9EaWZmZXJlbmNlWm9uZWREYXRlVDIgPSBEaWZmZXJlbmNlWm9uZWREYXRlVGltZShHZXRTbG90KEMsIG4pLCBfVTIsIF9qMiwgXyQyLCBPLCBUZShudWxsKSksIGIgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLnllYXJzLCBFID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5tb250aHMsIE0gPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLndlZWtzLCBSID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5kYXlzLCBGID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5ob3VycywgWSA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIubWludXRlcywgUCA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIuc2Vjb25kcywgWiA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIubWlsbGlzZWNvbmRzLCBCID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5taWNyb3NlY29uZHMsIE4gPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLm5hbm9zZWNvbmRzLCBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9CYWxhbmNlRHVyYXRpb243O1xuICAgIGlmIChcInllYXJcIiA9PT0gTyB8fCBcIm1vbnRoXCIgPT09IE8gfHwgXCJ3ZWVrXCIgPT09IE8pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicmVsYXRpdmVUbyBpcyByZXF1aXJlZCBmb3IgeWVhcnMsIG1vbnRocywgb3Igd2Vla3MgYXJpdGhtZXRpY1wiKTtcbiAgICBiID0gRSA9IE0gPSAwLCAoX0JhbGFuY2VEdXJhdGlvbjcgPSBCYWxhbmNlRHVyYXRpb24oYSArIGYsIEJpZ0ludChpKSArIEJpZ0ludCh5KSwgQmlnSW50KHMpICsgQmlnSW50KEkpLCBCaWdJbnQobCkgKyBCaWdJbnQodyksIEJpZ0ludChkKSArIEJpZ0ludChEKSwgQmlnSW50KG0pICsgQmlnSW50KEcpLCBCaWdJbnQoYykgKyBCaWdJbnQodiksIE8pLCBSID0gX0JhbGFuY2VEdXJhdGlvbjcuZGF5cywgRiA9IF9CYWxhbmNlRHVyYXRpb243LmhvdXJzLCBZID0gX0JhbGFuY2VEdXJhdGlvbjcubWludXRlcywgUCA9IF9CYWxhbmNlRHVyYXRpb243LnNlY29uZHMsIFogPSBfQmFsYW5jZUR1cmF0aW9uNy5taWxsaXNlY29uZHMsIEIgPSBfQmFsYW5jZUR1cmF0aW9uNy5taWNyb3NlY29uZHMsIE4gPSBfQmFsYW5jZUR1cmF0aW9uNy5uYW5vc2Vjb25kcyk7XG4gIH1cbiAgcmV0dXJuIFJlamVjdER1cmF0aW9uKGIsIEUsIE0sIFIsIEYsIFksIFAsIFosIEIsIE4pLCB7XG4gICAgeWVhcnM6IGIsXG4gICAgbW9udGhzOiBFLFxuICAgIHdlZWtzOiBNLFxuICAgIGRheXM6IFIsXG4gICAgaG91cnM6IEYsXG4gICAgbWludXRlczogWSxcbiAgICBzZWNvbmRzOiBQLFxuICAgIG1pbGxpc2Vjb25kczogWixcbiAgICBtaWNyb3NlY29uZHM6IEIsXG4gICAgbmFub3NlY29uZHM6IE5cbiAgfTtcbn1cbmZ1bmN0aW9uIEFkZEluc3RhbnQodCwgciwgbywgbiwgYSwgaSwgcykge1xuICB2YXIgbCA9IEllO1xuICBsID0gbCArIEJpZ0ludChzKSwgbCA9IGwgKyBCaWdJbnQoaSkgKiBEZSwgbCA9IGwgKyBCaWdJbnQoYSkgKiBHZSwgbCA9IGwgKyBCaWdJbnQobikgKiB2ZSwgbCA9IGwgKyBCaWdJbnQobykgKiA2MDAwMDAwMDAwMG4sIGwgPSBsICsgQmlnSW50KHIpICogMzYwMDAwMDAwMDAwMG47XG4gIHZhciBkID0gdCArIGw7XG4gIHJldHVybiBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZCksIGQ7XG59XG5mdW5jdGlvbiBBZGREYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBULCBwLCBmLCB5LCBJLCBTLCBnLCB3LCBELCBHKSB7XG4gIHZhciB2ID0gZixcbiAgICBfQWRkVGltZSA9IEFkZFRpbWUobywgbiwgYSwgZCwgbSwgYywgeSwgSSwgUywgZywgdywgRCksXG4gICAgQyA9IF9BZGRUaW1lLmRlbHRhRGF5cyxcbiAgICBPID0gX0FkZFRpbWUuaG91cixcbiAgICBiID0gX0FkZFRpbWUubWludXRlLFxuICAgIEUgPSBfQWRkVGltZS5zZWNvbmQsXG4gICAgTSA9IF9BZGRUaW1lLm1pbGxpc2Vjb25kLFxuICAgIFIgPSBfQWRkVGltZS5taWNyb3NlY29uZCxcbiAgICBGID0gX0FkZFRpbWUubmFub3NlY29uZDtcbiAgdiArPSBDO1xuICB2YXIgWSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIiksXG4gICAgUCA9IENhbGVuZGFyRGF0ZUFkZChoLCBDcmVhdGVUZW1wb3JhbERhdGUoZSwgdCwgciwgaCksIG5ldyBZKHUsIFQsIHAsIHYsIDAsIDAsIDAsIDAsIDAsIDApLCBHKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBHZXRTbG90KFAsIGkpLFxuICAgIG1vbnRoOiBHZXRTbG90KFAsIHMpLFxuICAgIGRheTogR2V0U2xvdChQLCBsKSxcbiAgICBob3VyOiBPLFxuICAgIG1pbnV0ZTogYixcbiAgICBzZWNvbmQ6IEUsXG4gICAgbWlsbGlzZWNvbmQ6IE0sXG4gICAgbWljcm9zZWNvbmQ6IFIsXG4gICAgbmFub3NlY29uZDogRlxuICB9O1xufVxuZnVuY3Rpb24gQWRkWm9uZWREYXRlVGltZShlLCB0LCByLCBvLCBhLCBwLCBmLCB5LCBJLCBTLCBnLCB3LCBELCBHKSB7XG4gIHZhciB2ID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKTtcbiAgaWYgKDAgPT09IER1cmF0aW9uU2lnbihvLCBhLCBwLCBmLCAwLCAwLCAwLCAwLCAwLCAwKSkgcmV0dXJuIEFkZEluc3RhbnQoR2V0U2xvdChlLCBuKSwgeSwgSSwgUywgZywgdywgRCk7XG4gIHZhciBDID0gR2V0UGxhaW5EYXRlVGltZUZvcih0LCBlLCByKSxcbiAgICBPID0gQ2FsZW5kYXJEYXRlQWRkKHIsIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KEMsIGkpLCBHZXRTbG90KEMsIHMpLCBHZXRTbG90KEMsIGwpLCByKSwgbmV3IHYobywgYSwgcCwgZiwgMCwgMCwgMCwgMCwgMCwgMCksIEcpLFxuICAgIGIgPSBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoTywgaSksIEdldFNsb3QoTywgcyksIEdldFNsb3QoTywgbCksIEdldFNsb3QoQywgZCksIEdldFNsb3QoQywgbSksIEdldFNsb3QoQywgYyksIEdldFNsb3QoQywgaCksIEdldFNsb3QoQywgdSksIEdldFNsb3QoQywgVCksIHIpO1xuICByZXR1cm4gQWRkSW5zdGFudChHZXRTbG90KEdldEluc3RhbnRGb3IodCwgYiwgXCJjb21wYXRpYmxlXCIpLCBuKSwgeSwgSSwgUywgZywgdywgRCk7XG59XG5mdW5jdGlvbiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUR1cmF0aW9uKGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBcInN1YnRyYWN0XCIgPT09IGUgPyAtMSA6IDE7XG4gIHZhciBfVG9UZW1wb3JhbER1cmF0aW9uUmUyID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKHIpLFxuICAgIGEgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLnllYXJzLFxuICAgIGkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm1vbnRocyxcbiAgICBzID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi53ZWVrcyxcbiAgICBsID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi5kYXlzLFxuICAgIGQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLmhvdXJzLFxuICAgIG0gPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm1pbnV0ZXMsXG4gICAgYyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTIuc2Vjb25kcyxcbiAgICBoID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi5taWxsaXNlY29uZHMsXG4gICAgdSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTIubWljcm9zZWNvbmRzLFxuICAgIFQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm5hbm9zZWNvbmRzO1xuICB2YXIgcCA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChHZXRPcHRpb25zT2JqZWN0KG8pKTtcbiAgdmFyIF9BZGREdXJhdGlvbiA9IEFkZER1cmF0aW9uKEdldFNsb3QodCwgdyksIEdldFNsb3QodCwgRCksIEdldFNsb3QodCwgRyksIEdldFNsb3QodCwgdiksIEdldFNsb3QodCwgQyksIEdldFNsb3QodCwgTyksIEdldFNsb3QodCwgYiksIEdldFNsb3QodCwgRSksIEdldFNsb3QodCwgTSksIEdldFNsb3QodCwgUiksIG4gKiBhLCBuICogaSwgbiAqIHMsIG4gKiBsLCBuICogZCwgbiAqIG0sIG4gKiBjLCBuICogaCwgbiAqIHUsIG4gKiBULCBwKTtcbiAgYSA9IF9BZGREdXJhdGlvbi55ZWFycztcbiAgaSA9IF9BZGREdXJhdGlvbi5tb250aHM7XG4gIHMgPSBfQWRkRHVyYXRpb24ud2Vla3M7XG4gIGwgPSBfQWRkRHVyYXRpb24uZGF5cztcbiAgZCA9IF9BZGREdXJhdGlvbi5ob3VycztcbiAgbSA9IF9BZGREdXJhdGlvbi5taW51dGVzO1xuICBjID0gX0FkZER1cmF0aW9uLnNlY29uZHM7XG4gIGggPSBfQWRkRHVyYXRpb24ubWlsbGlzZWNvbmRzO1xuICB1ID0gX0FkZER1cmF0aW9uLm1pY3Jvc2Vjb25kcztcbiAgVCA9IF9BZGREdXJhdGlvbi5uYW5vc2Vjb25kcztcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCk7XG59XG5mdW5jdGlvbiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUluc3RhbnQoZSwgdCwgcikge1xuICB2YXIgbyA9IFwic3VidHJhY3RcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBfVG9MaW1pdGVkVGVtcG9yYWxEdXIgPSBmdW5jdGlvbiBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKGUsIHQpIHtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpO1xuICAgICAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgICAgIF9zdGVwMTQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZTMwID0gX3N0ZXAxNC52YWx1ZTtcbiAgICAgICAgICBpZiAoMCAhPT0gcltfZTMwXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXJhdGlvbiBmaWVsZCBcIi5jb25jYXQoX2UzMCwgXCIgbm90IHN1cHBvcnRlZCBieSBUZW1wb3JhbC5JbnN0YW50LiBUcnkgVGVtcG9yYWwuWm9uZWREYXRlVGltZSBpbnN0ZWFkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNC5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9KHIsIFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCJdKSxcbiAgICBhID0gX1RvTGltaXRlZFRlbXBvcmFsRHVyLmhvdXJzLFxuICAgIGkgPSBfVG9MaW1pdGVkVGVtcG9yYWxEdXIubWludXRlcyxcbiAgICBzID0gX1RvTGltaXRlZFRlbXBvcmFsRHVyLnNlY29uZHMsXG4gICAgbCA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5taWxsaXNlY29uZHMsXG4gICAgZCA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5taWNyb3NlY29uZHMsXG4gICAgbSA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5uYW5vc2Vjb25kcyxcbiAgICBjID0gQWRkSW5zdGFudChHZXRTbG90KHQsIG4pLCBvICogYSwgbyAqIGksIG8gKiBzLCBvICogbCwgbyAqIGQsIG8gKiBtKTtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShjKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gXCJzdWJ0cmFjdFwiID09PSBlID8gLTEgOiAxLFxuICAgIF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQociksXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMueWVhcnMsXG4gICAgZiA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubW9udGhzLFxuICAgIHkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLndlZWtzLFxuICAgIEkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLmRheXMsXG4gICAgUyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMuaG91cnMsXG4gICAgZyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubWludXRlcyxcbiAgICB3ID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMy5zZWNvbmRzLFxuICAgIEQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLm1pbGxpc2Vjb25kcyxcbiAgICBHID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMy5taWNyb3NlY29uZHMsXG4gICAgdiA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubmFub3NlY29uZHMsXG4gICAgQyA9IEdldE9wdGlvbnNPYmplY3QobyksXG4gICAgTyA9IEdldFNsb3QodCwgcCksXG4gICAgX0FkZERhdGVUaW1lID0gQWRkRGF0ZVRpbWUoR2V0U2xvdCh0LCBpKSwgR2V0U2xvdCh0LCBzKSwgR2V0U2xvdCh0LCBsKSwgR2V0U2xvdCh0LCBkKSwgR2V0U2xvdCh0LCBtKSwgR2V0U2xvdCh0LCBjKSwgR2V0U2xvdCh0LCBoKSwgR2V0U2xvdCh0LCB1KSwgR2V0U2xvdCh0LCBUKSwgTywgbiAqIGEsIG4gKiBmLCBuICogeSwgbiAqIEksIG4gKiBTLCBuICogZywgbiAqIHcsIG4gKiBELCBuICogRywgbiAqIHYsIEMpLFxuICAgIGIgPSBfQWRkRGF0ZVRpbWUueWVhcixcbiAgICBFID0gX0FkZERhdGVUaW1lLm1vbnRoLFxuICAgIE0gPSBfQWRkRGF0ZVRpbWUuZGF5LFxuICAgIFIgPSBfQWRkRGF0ZVRpbWUuaG91cixcbiAgICBGID0gX0FkZERhdGVUaW1lLm1pbnV0ZSxcbiAgICBZID0gX0FkZERhdGVUaW1lLnNlY29uZCxcbiAgICBQID0gX0FkZERhdGVUaW1lLm1pbGxpc2Vjb25kLFxuICAgIFogPSBfQWRkRGF0ZVRpbWUubWljcm9zZWNvbmQsXG4gICAgQiA9IF9BZGREYXRlVGltZS5uYW5vc2Vjb25kO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShiLCBFLCBNLCBSLCBGLCBZLCBQLCBaLCBCLCBPKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5UaW1lKGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBcInN1YnRyYWN0XCIgPT09IGUgPyAtMSA6IDEsXG4gICAgX1RvVGVtcG9yYWxEdXJhdGlvblJlNCA9IFRvVGVtcG9yYWxEdXJhdGlvblJlY29yZChyKSxcbiAgICBuID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5ob3VycyxcbiAgICBhID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5taW51dGVzLFxuICAgIGkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU0LnNlY29uZHMsXG4gICAgcyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTQubWlsbGlzZWNvbmRzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU0Lm1pY3Jvc2Vjb25kcyxcbiAgICBwID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5uYW5vc2Vjb25kcztcbiAgdmFyIF9BZGRUaW1lMiA9IEFkZFRpbWUoR2V0U2xvdCh0LCBkKSwgR2V0U2xvdCh0LCBtKSwgR2V0U2xvdCh0LCBjKSwgR2V0U2xvdCh0LCBoKSwgR2V0U2xvdCh0LCB1KSwgR2V0U2xvdCh0LCBUKSwgbyAqIG4sIG8gKiBhLCBvICogaSwgbyAqIHMsIG8gKiBsLCBvICogcCksXG4gICAgZiA9IF9BZGRUaW1lMi5ob3VyLFxuICAgIHkgPSBfQWRkVGltZTIubWludXRlLFxuICAgIEkgPSBfQWRkVGltZTIuc2Vjb25kLFxuICAgIFMgPSBfQWRkVGltZTIubWlsbGlzZWNvbmQsXG4gICAgZyA9IF9BZGRUaW1lMi5taWNyb3NlY29uZCxcbiAgICB3ID0gX0FkZFRpbWUyLm5hbm9zZWNvbmQ7XG4gIHZhciBfUmVndWxhdGVUaW1lMyA9IFJlZ3VsYXRlVGltZShmLCB5LCBJLCBTLCBnLCB3LCBcInJlamVjdFwiKTtcbiAgZiA9IF9SZWd1bGF0ZVRpbWUzLmhvdXI7XG4gIHkgPSBfUmVndWxhdGVUaW1lMy5taW51dGU7XG4gIEkgPSBfUmVndWxhdGVUaW1lMy5zZWNvbmQ7XG4gIFMgPSBfUmVndWxhdGVUaW1lMy5taWxsaXNlY29uZDtcbiAgZyA9IF9SZWd1bGF0ZVRpbWUzLm1pY3Jvc2Vjb25kO1xuICB3ID0gX1JlZ3VsYXRlVGltZTMubmFub3NlY29uZDtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluVGltZSVcIikpKGYsIHksIEksIFMsIGcsIHcpO1xufVxuZnVuY3Rpb24gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblllYXJNb250aChlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKHIpO1xuICBcInN1YnRyYWN0XCIgPT09IGUgJiYgKG4gPSB7XG4gICAgeWVhcnM6IC1uLnllYXJzLFxuICAgIG1vbnRoczogLW4ubW9udGhzLFxuICAgIHdlZWtzOiAtbi53ZWVrcyxcbiAgICBkYXlzOiAtbi5kYXlzLFxuICAgIGhvdXJzOiAtbi5ob3VycyxcbiAgICBtaW51dGVzOiAtbi5taW51dGVzLFxuICAgIHNlY29uZHM6IC1uLnNlY29uZHMsXG4gICAgbWlsbGlzZWNvbmRzOiAtbi5taWxsaXNlY29uZHMsXG4gICAgbWljcm9zZWNvbmRzOiAtbi5taWNyb3NlY29uZHMsXG4gICAgbmFub3NlY29uZHM6IC1uLm5hbm9zZWNvbmRzXG4gIH0pO1xuICB2YXIgX24xMSA9IG4sXG4gICAgYSA9IF9uMTEueWVhcnMsXG4gICAgaSA9IF9uMTEubW9udGhzLFxuICAgIHMgPSBfbjExLndlZWtzLFxuICAgIGwgPSBfbjExLmRheXMsXG4gICAgZCA9IF9uMTEuaG91cnMsXG4gICAgbSA9IF9uMTEubWludXRlcyxcbiAgICBjID0gX24xMS5zZWNvbmRzLFxuICAgIGggPSBfbjExLm1pbGxpc2Vjb25kcyxcbiAgICB1ID0gX24xMS5taWNyb3NlY29uZHMsXG4gICAgVCA9IF9uMTEubmFub3NlY29uZHM7XG4gIHZhciBfQmFsYW5jZUR1cmF0aW9uOCA9IEJhbGFuY2VEdXJhdGlvbihsLCBkLCBtLCBjLCBoLCB1LCBULCBcImRheVwiKTtcbiAgbCA9IF9CYWxhbmNlRHVyYXRpb244LmRheXM7XG4gIHZhciBmID0gR2V0T3B0aW9uc09iamVjdChvKSxcbiAgICB5ID0gR2V0U2xvdCh0LCBwKSxcbiAgICBJID0gQ2FsZW5kYXJGaWVsZHMoeSwgW1wibW9udGhDb2RlXCIsIFwieWVhclwiXSksXG4gICAgUyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyh0LCBJLCBbXSksXG4gICAgZyA9IFRlKG51bGwpO1xuICBDb3B5RGF0YVByb3BlcnRpZXMoZywgUywgW10pLCBTLmRheSA9IDE7XG4gIHZhciB3ID0gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh5LCBTKTtcbiAgdmFyIEQgPSBEdXJhdGlvblNpZ24oYSwgaSwgcywgbCwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgRyA9IEdldE1ldGhvZCh5LCBcImRhdGVBZGRcIiksXG4gICAgdiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIik7XG4gIGlmIChEIDwgMCkge1xuICAgIHZhciBfZTMxID0gQ2FsZW5kYXJEYXRlQWRkKHksIHcsIG5ldyB2KDAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApLCB2b2lkIDAsIEcpLFxuICAgICAgX3QzMCA9IENhbGVuZGFyRGF0ZUFkZCh5LCBfZTMxLCBuZXcgdigwLCAwLCAwLCAtMSwgMCwgMCwgMCwgMCwgMCwgMCksIHZvaWQgMCwgRyk7XG4gICAgZy5kYXkgPSBDYWxlbmRhckRheSh5LCBfdDMwKSwgdyA9IENhbGVuZGFyRGF0ZUZyb21GaWVsZHMoeSwgZyk7XG4gIH1cbiAgdmFyIEMgPSBuZXcgdihhLCBpLCBzLCBsLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICBPID0gQ29weU9wdGlvbnMoZik7XG4gIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoeSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKENhbGVuZGFyRGF0ZUFkZCh5LCB3LCBDLCBmLCBHKSwgSSwgW10pLCBPKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tWm9uZWREYXRlVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gXCJzdWJ0cmFjdFwiID09PSBlID8gLTEgOiAxLFxuICAgIF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQociksXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUueWVhcnMsXG4gICAgaSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubW9udGhzLFxuICAgIHMgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1LndlZWtzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1LmRheXMsXG4gICAgZCA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUuaG91cnMsXG4gICAgbSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubWludXRlcyxcbiAgICBjID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNS5zZWNvbmRzLFxuICAgIGggPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1Lm1pbGxpc2Vjb25kcyxcbiAgICB1ID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNS5taWNyb3NlY29uZHMsXG4gICAgVCA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubmFub3NlY29uZHMsXG4gICAgZiA9IEdldE9wdGlvbnNPYmplY3QobyksXG4gICAgeSA9IEdldFNsb3QodCwgZyksXG4gICAgSSA9IEdldFNsb3QodCwgcCk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHQsIFMpLCB5LCBJLCBuICogYSwgbiAqIGksIG4gKiBzLCBuICogbCwgbiAqIGQsIG4gKiBtLCBuICogYywgbiAqIGgsIG4gKiB1LCBuICogVCwgZiksIHksIEkpO1xufVxuZnVuY3Rpb24gUm91bmROdW1iZXJUb0luY3JlbWVudCh0LCByLCBvKSB7XG4gIGlmIChyID09PSBTZSkgcmV0dXJuIHQ7XG4gIHZhciBfZGl2bW9kMjEgPSBkaXZtb2QodCwgciksXG4gICAgbiA9IF9kaXZtb2QyMS5xdW90aWVudCxcbiAgICBhID0gX2Rpdm1vZDIxLnJlbWFpbmRlcjtcbiAgaWYgKGEgPT09IEllKSByZXR1cm4gdDtcbiAgdmFyIGkgPSBhIDwgSWUgPyAtMSA6IDEsXG4gICAgcyA9IGFicyhhICogMm4pLFxuICAgIGwgPSBzID09PSByLFxuICAgIGQgPSBzID4gcjtcbiAgc3dpdGNoIChvKSB7XG4gICAgY2FzZSBcImNlaWxcIjpcbiAgICAgIGkgPiAwICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmxvb3JcIjpcbiAgICAgIGkgPCAwICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZXhwYW5kXCI6XG4gICAgICBuID0gbiArIEJpZ0ludChpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZDZWlsXCI6XG4gICAgICAoZCB8fCBsICYmIGkgPiAwKSAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZGbG9vclwiOlxuICAgICAgKGQgfHwgbCAmJiBpIDwgMCkgJiYgKG4gPSBuICsgQmlnSW50KGkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJoYWxmRXhwYW5kXCI6XG4gICAgICAoZCB8fCBsKSAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZUcnVuY1wiOlxuICAgICAgZCAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZFdmVuXCI6XG4gICAgICAoZCB8fCBsICYmIDEgPT09IE51bWJlcihhYnMobikgJSAybikpICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gIH1cbiAgcmV0dXJuIG4gKiByO1xufVxuZnVuY3Rpb24gUm91bmRJbnN0YW50KHQsIHIsIG8sIG4pIHtcbiAgdmFyIF9Ob25OZWdhdGl2ZUJpZ0ludERpdjcgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZCh0LCBFZSksXG4gICAgYSA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjcucmVtYWluZGVyO1xuICB2YXIgaSA9IHQgLSBhLFxuICAgIHMgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGEsIEJpZ0ludChfZVtvXSAqIHIpLCBuKTtcbiAgcmV0dXJuIGkgKyBzO1xufVxuZnVuY3Rpb24gUm91bmRJU09EYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSB7XG4gIHZhciBoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEyICYmIGFyZ3VtZW50c1sxMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxMl0gOiA4NjRlMTE7XG4gIHZhciBfUm91bmRUaW1lID0gUm91bmRUaW1lKG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgpLFxuICAgIHUgPSBfUm91bmRUaW1lLmRlbHRhRGF5cyxcbiAgICBUID0gX1JvdW5kVGltZS5ob3VyLFxuICAgIHAgPSBfUm91bmRUaW1lLm1pbnV0ZSxcbiAgICBmID0gX1JvdW5kVGltZS5zZWNvbmQsXG4gICAgeSA9IF9Sb3VuZFRpbWUubWlsbGlzZWNvbmQsXG4gICAgSSA9IF9Sb3VuZFRpbWUubWljcm9zZWNvbmQsXG4gICAgUyA9IF9Sb3VuZFRpbWUubmFub3NlY29uZCxcbiAgICBfQmFsYW5jZUlTT0RhdGU0ID0gQmFsYW5jZUlTT0RhdGUoZSwgdCwgciArIHUpLFxuICAgIGcgPSBfQmFsYW5jZUlTT0RhdGU0LnllYXIsXG4gICAgdyA9IF9CYWxhbmNlSVNPRGF0ZTQubW9udGgsXG4gICAgRCA9IF9CYWxhbmNlSVNPRGF0ZTQuZGF5O1xuICByZXR1cm4ge1xuICAgIHllYXI6IGcsXG4gICAgbW9udGg6IHcsXG4gICAgZGF5OiBELFxuICAgIGhvdXI6IFQsXG4gICAgbWludXRlOiBwLFxuICAgIHNlY29uZDogZixcbiAgICBtaWxsaXNlY29uZDogeSxcbiAgICBtaWNyb3NlY29uZDogSSxcbiAgICBuYW5vc2Vjb25kOiBTXG4gIH07XG59XG5mdW5jdGlvbiBSb3VuZFRpbWUodCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICB2YXIgbSA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ICYmIGFyZ3VtZW50c1s5XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzldIDogODY0ZTExO1xuICB2YXIgYyA9IEllO1xuICBzd2l0Y2ggKGwpIHtcbiAgICBjYXNlIFwiZGF5XCI6XG4gICAgY2FzZSBcImhvdXJcIjpcbiAgICAgIGMgPSBCaWdJbnQodCk7XG4gICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgYyA9IGMgKiBnZSArIEJpZ0ludChyKTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICBjID0gYyAqIGdlICsgQmlnSW50KG8pO1xuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgYyA9IGMgKiBEZSArIEJpZ0ludChuKTtcbiAgICBjYXNlIFwibWljcm9zZWNvbmRcIjpcbiAgICAgIGMgPSBjICogRGUgKyBCaWdJbnQoYSk7XG4gICAgY2FzZSBcIm5hbm9zZWNvbmRcIjpcbiAgICAgIGMgPSBjICogRGUgKyBCaWdJbnQoaSk7XG4gIH1cbiAgdmFyIGggPSBcImRheVwiID09PSBsID8gbSA6IF9lW2xdLFxuICAgIHUgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGMsIEJpZ0ludChoICogcyksIGQpLFxuICAgIFQgPSBOdW1iZXIodSAvIEJpZ0ludChoKSk7XG4gIHN3aXRjaCAobCkge1xuICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhRGF5czogVCxcbiAgICAgICAgaG91cjogMCxcbiAgICAgICAgbWludXRlOiAwLFxuICAgICAgICBzZWNvbmQ6IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgICAgICBtaWNyb3NlY29uZDogMCxcbiAgICAgICAgbmFub3NlY29uZDogMFxuICAgICAgfTtcbiAgICBjYXNlIFwiaG91clwiOlxuICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKFQsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgIHJldHVybiBCYWxhbmNlVGltZSh0LCBULCAwLCAwLCAwLCAwKTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgVCwgMCwgMCwgMCk7XG4gICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgbywgVCwgMCwgMCk7XG4gICAgY2FzZSBcIm1pY3Jvc2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgbywgbiwgVCwgMCk7XG4gICAgY2FzZSBcIm5hbm9zZWNvbmRcIjpcbiAgICAgIHJldHVybiBCYWxhbmNlVGltZSh0LCByLCBvLCBuLCBhLCBUKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1bml0IFwiLmNvbmNhdChsKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIERheXNVbnRpbChlLCB0KSB7XG4gIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KHQsIGkpLCBHZXRTbG90KHQsIHMpLCBHZXRTbG90KHQsIGwpLCBcImRheVwiKS5kYXlzO1xufVxuZnVuY3Rpb24gTW92ZVJlbGF0aXZlRGF0ZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gQ2FsZW5kYXJEYXRlQWRkKGUsIHQsIHIsIHZvaWQgMCwgbyk7XG4gIHJldHVybiB7XG4gICAgcmVsYXRpdmVUbzogbixcbiAgICBkYXlzOiBEYXlzVW50aWwodCwgbilcbiAgfTtcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUoZSwgdCwgciwgbywgbikge1xuICB2YXIgYSA9IEdldFNsb3QoZSwgZyksXG4gICAgaSA9IEdldFNsb3QoZSwgcCk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoQWRkWm9uZWREYXRlVGltZShHZXRTbG90KGUsIFMpLCBhLCBpLCB0LCByLCBvLCBuLCAwLCAwLCAwLCAwLCAwLCAwKSwgYSwgaSk7XG59XG5mdW5jdGlvbiBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQpIHtcbiAgdmFyIF9BZGREdXJhdGlvbjIsIF9CYWxhbmNlRHVyYXRpb245O1xuICB2YXIgZiA9IHQsXG4gICAgeSA9IHIsXG4gICAgSSA9IG8sXG4gICAgdyA9IG4sXG4gICAgRCA9IGEsXG4gICAgRyA9IGksXG4gICAgdiA9IHMsXG4gICAgQyA9IGwsXG4gICAgTyA9IGQsXG4gICAgYiA9IG07XG4gIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoVCkgfHwgXCJ5ZWFyXCIgPT09IGggfHwgXCJtb250aFwiID09PSBoIHx8IFwid2Vla1wiID09PSBoIHx8IFwiZGF5XCIgPT09IGggfHwgXCJuYW5vc2Vjb25kXCIgPT09IGggJiYgMSA9PT0gYykgcmV0dXJuIHtcbiAgICB5ZWFyczogZixcbiAgICBtb250aHM6IHksXG4gICAgd2Vla3M6IEksXG4gICAgZGF5czogdyxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xuICB2YXIgRSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBELCBHLCB2LCBDLCBPLCBiLCAwKTtcbiAgdmFyIE0gPSBzZShOdW1iZXIoRSkpLFxuICAgIFIgPSBHZXRTbG90KFQsIGcpLFxuICAgIEYgPSBHZXRTbG90KFQsIHApLFxuICAgIFkgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QoVCwgUyksIFIsIEYsIGYsIHksIEksIHcsIDAsIDAsIDAsIDAsIDAsIDApLFxuICAgIFAgPSBBZGRab25lZERhdGVUaW1lKG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShZKSwgUiwgRiwgMCwgMCwgMCwgTSwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgWiA9IFAgLSBZO1xuICByZXR1cm4gKEUgLSBaKSAqIEJpZ0ludChNKSA+PSBJZSAmJiAoKF9BZGREdXJhdGlvbjIgPSBBZGREdXJhdGlvbihmLCB5LCBJLCB3LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBNLCAwLCAwLCAwLCAwLCAwLCAwLCBUKSwgZiA9IF9BZGREdXJhdGlvbjIueWVhcnMsIHkgPSBfQWRkRHVyYXRpb24yLm1vbnRocywgSSA9IF9BZGREdXJhdGlvbjIud2Vla3MsIHcgPSBfQWRkRHVyYXRpb24yLmRheXMpLCBFID0gUm91bmRJbnN0YW50KEUgLSBaLCBjLCBoLCB1KSwgKF9CYWxhbmNlRHVyYXRpb245ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIDAsIDAsIDAsIE51bWJlcihFKSwgXCJob3VyXCIpLCBEID0gX0JhbGFuY2VEdXJhdGlvbjkuaG91cnMsIEcgPSBfQmFsYW5jZUR1cmF0aW9uOS5taW51dGVzLCB2ID0gX0JhbGFuY2VEdXJhdGlvbjkuc2Vjb25kcywgQyA9IF9CYWxhbmNlRHVyYXRpb245Lm1pbGxpc2Vjb25kcywgTyA9IF9CYWxhbmNlRHVyYXRpb245Lm1pY3Jvc2Vjb25kcywgYiA9IF9CYWxhbmNlRHVyYXRpb245Lm5hbm9zZWNvbmRzKSksIHtcbiAgICB5ZWFyczogZixcbiAgICBtb250aHM6IHksXG4gICAgd2Vla3M6IEksXG4gICAgZGF5czogdyxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xufVxuZnVuY3Rpb24gUm91bmREdXJhdGlvbih0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjLCBoLCB1LCBUKSB7XG4gIHZhciBmID0gdCxcbiAgICB5ID0gcixcbiAgICBJID0gbyxcbiAgICBTID0gbixcbiAgICBnID0gYSxcbiAgICB3ID0gaSxcbiAgICBEID0gcyxcbiAgICBHID0gbCxcbiAgICB2ID0gZCxcbiAgICBDID0gQmlnSW50KG0pO1xuICB2YXIgTyA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIik7XG4gIHZhciBiLFxuICAgIEUsXG4gICAgTSxcbiAgICBSLFxuICAgIEYgPSBUO1xuICBpZiAoRikge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShGKSkgRSA9IEYsIEYgPSBUb1RlbXBvcmFsRGF0ZShGKTtlbHNlIGlmICghSXNUZW1wb3JhbERhdGUoRikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzdGFydGluZyBwb2ludCBtdXN0IGJlIFBsYWluRGF0ZSBvciBab25lZERhdGVUaW1lXCIpO1xuICAgIGIgPSBHZXRTbG90KEYsIHApO1xuICB9XG4gIGlmIChcInllYXJcIiA9PT0gaCB8fCBcIm1vbnRoXCIgPT09IGggfHwgXCJ3ZWVrXCIgPT09IGggfHwgXCJkYXlcIiA9PT0gaCkge1xuICAgIHZhciBfTmFub3NlY29uZHNUb0RheXMzO1xuICAgIHZhciBfdDMxLCBfcjQ1LCBfbzE1O1xuICAgIEMgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoMCwgZywgdywgRCwgRywgdiwgbSwgMCksIEUgJiYgKF90MzEgPSBNb3ZlUmVsYXRpdmVab25lZERhdGVUaW1lKEUsIGYsIHksIEksIFMpKSwgKF9OYW5vc2Vjb25kc1RvRGF5czMgPSBOYW5vc2Vjb25kc1RvRGF5cyhDLCBfdDMxKSwgX3I0NSA9IF9OYW5vc2Vjb25kc1RvRGF5czMuZGF5cywgQyA9IF9OYW5vc2Vjb25kc1RvRGF5czMubmFub3NlY29uZHMsIF9vMTUgPSBfTmFub3NlY29uZHNUb0RheXMzLmRheUxlbmd0aE5zKSwgTSA9IEJpZ0ludChfbzE1KSwgUyArPSBfcjQ1LCBnID0gdyA9IEQgPSBHID0gdiA9IDA7XG4gIH1cbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSBcInllYXJcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHllYXJzIHJvdW5kaW5nXCIpO1xuICAgICAgICB2YXIgX3QzMiA9IG5ldyBPKGYpLFxuICAgICAgICAgIF9yNDYgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBiID8gR2V0TWV0aG9kKGIsIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMCxcbiAgICAgICAgICBfbzE2ID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIF90MzIsIHZvaWQgMCwgX3I0NiksXG4gICAgICAgICAgX24xMiA9IENhbGVuZGFyRGF0ZUFkZChiLCBGLCBuZXcgTyhmLCB5LCBJKSwgdm9pZCAwLCBfcjQ2KTtcbiAgICAgICAgRiA9IF9vMTYsIFMgKz0gRGF5c1VudGlsKF9vMTYsIF9uMTIpO1xuICAgICAgICB2YXIgX2E4ID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIG5ldyBPKDAsIDAsIDAsIFMpLCB2b2lkIDAsIF9yNDYpLFxuICAgICAgICAgIF9pMTIgPSBUZShudWxsKTtcbiAgICAgICAgX2kxMi5sYXJnZXN0VW5pdCA9IFwieWVhclwiO1xuICAgICAgICB2YXIgX3M0ID0gQ2FsZW5kYXJEYXRlVW50aWwoYiwgRiwgX2E4LCBfaTEyKS55ZWFycztcbiAgICAgICAgZiArPSBfczQ7XG4gICAgICAgIHZhciBfbDUgPSBGO1xuICAgICAgICBGID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIG5ldyBPKF9zNCksIHZvaWQgMCwgX3I0Nik7XG4gICAgICAgIFMgLT0gRGF5c1VudGlsKF9sNSwgRik7XG4gICAgICAgIHZhciBfZDUgPSBuZXcgTyhTIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTYgPSBNb3ZlUmVsYXRpdmVEYXRlKGIsIEYsIF9kNSwgX3I0NiksXG4gICAgICAgICAgX201ID0gX01vdmVSZWxhdGl2ZURhdGU2LmRheXM7XG4gICAgICAgIF9tNSA9IGFlKF9tNSk7XG4gICAgICAgIHZhciBfaDIgPSBCaWdJbnQoX201KSAqIE07XG4gICAgICAgIEMgPSBfaDIgKiBCaWdJbnQoZikgKyBCaWdJbnQoUykgKiBNICsgQztcbiAgICAgICAgdmFyIF9UMiA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQywgX2gyICogQmlnSW50KGMpLCB1KTtcbiAgICAgICAgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKEMsIF9oMiksIGYgPSBOdW1iZXIoX1QyIC8gX2gyKSwgQyA9IEllLCB5ID0gSSA9IFMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyByb3VuZGluZ1wiKTtcbiAgICAgICAgdmFyIF90MzMgPSBuZXcgTyhmLCB5KSxcbiAgICAgICAgICBfcjQ3ID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiA/IEdldE1ldGhvZChiLCBcImRhdGVBZGRcIikgOiB2b2lkIDAsXG4gICAgICAgICAgX28xNyA9IENhbGVuZGFyRGF0ZUFkZChiLCBGLCBfdDMzLCB2b2lkIDAsIF9yNDcpLFxuICAgICAgICAgIF9uMTMgPSBDYWxlbmRhckRhdGVBZGQoYiwgRiwgbmV3IE8oZiwgeSwgSSksIHZvaWQgMCwgX3I0Nyk7XG4gICAgICAgIEYgPSBfbzE3LCBTICs9IERheXNVbnRpbChfbzE3LCBfbjEzKTtcbiAgICAgICAgdmFyIF9hOSA9IHNlKFMpLFxuICAgICAgICAgIF9pMTMgPSBuZXcgTygwLCBTIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHZhciBfczU7XG4gICAgICAgIGZvciAoX01vdmVSZWxhdGl2ZURhdGU3ID0gTW92ZVJlbGF0aXZlRGF0ZShiLCBGLCBfaTEzLCBfcjQ3KSwgRiA9IF9Nb3ZlUmVsYXRpdmVEYXRlNy5yZWxhdGl2ZVRvLCBfczUgPSBfTW92ZVJlbGF0aXZlRGF0ZTcuZGF5cywgX01vdmVSZWxhdGl2ZURhdGU3OyBhZShTKSA+PSBhZShfczUpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTcsIF9Nb3ZlUmVsYXRpdmVEYXRlODtcbiAgICAgICAgICB5ICs9IF9hOSwgUyAtPSBfczUsIChfTW92ZVJlbGF0aXZlRGF0ZTggPSBNb3ZlUmVsYXRpdmVEYXRlKGIsIEYsIF9pMTMsIF9yNDcpLCBGID0gX01vdmVSZWxhdGl2ZURhdGU4LnJlbGF0aXZlVG8sIF9zNSA9IF9Nb3ZlUmVsYXRpdmVEYXRlOC5kYXlzKTtcbiAgICAgICAgfVxuICAgICAgICBfczUgPSBhZShfczUpO1xuICAgICAgICB2YXIgX2w2ID0gQmlnSW50KF9zNSkgKiBNO1xuICAgICAgICBDID0gX2w2ICogQmlnSW50KHkpICsgQmlnSW50KFMpICogTSArIEM7XG4gICAgICAgIHZhciBfZDYgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KEMsIF9sNiAqIEJpZ0ludChjKSwgdSk7XG4gICAgICAgIFIgPSBCaWdJbnREaXZpZGVUb051bWJlcihDLCBfbDYpLCB5ID0gTnVtYmVyKF9kNiAvIF9sNiksIEMgPSBJZSwgSSA9IFMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwid2Vla1wiOlxuICAgICAge1xuICAgICAgICBpZiAoIWIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3Mgcm91bmRpbmdcIik7XG4gICAgICAgIHZhciBfdDM0ID0gc2UoUyksXG4gICAgICAgICAgX3I0OCA9IG5ldyBPKDAsIDAsIFMgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICBfbzE4ID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiA/IEdldE1ldGhvZChiLCBcImRhdGVBZGRcIikgOiB2b2lkIDA7XG4gICAgICAgIHZhciBfbjE0O1xuICAgICAgICBmb3IgKF9Nb3ZlUmVsYXRpdmVEYXRlOSA9IE1vdmVSZWxhdGl2ZURhdGUoYiwgRiwgX3I0OCwgX28xOCksIEYgPSBfTW92ZVJlbGF0aXZlRGF0ZTkucmVsYXRpdmVUbywgX24xNCA9IF9Nb3ZlUmVsYXRpdmVEYXRlOS5kYXlzLCBfTW92ZVJlbGF0aXZlRGF0ZTk7IGFlKFMpID49IGFlKF9uMTQpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTksIF9Nb3ZlUmVsYXRpdmVEYXRlMTA7XG4gICAgICAgICAgSSArPSBfdDM0LCBTIC09IF9uMTQsIChfTW92ZVJlbGF0aXZlRGF0ZTEwID0gTW92ZVJlbGF0aXZlRGF0ZShiLCBGLCBfcjQ4LCBfbzE4KSwgRiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTAucmVsYXRpdmVUbywgX24xNCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTAuZGF5cyk7XG4gICAgICAgIH1cbiAgICAgICAgX24xNCA9IGFlKF9uMTQpO1xuICAgICAgICB2YXIgX2ExMCA9IEJpZ0ludChfbjE0KSAqIE07XG4gICAgICAgIEMgPSBfYTEwICogQmlnSW50KEkpICsgQmlnSW50KFMpICogTSArIEM7XG4gICAgICAgIHZhciBfaTE0ID0gUm91bmROdW1iZXJUb0luY3JlbWVudChDLCBfYTEwICogQmlnSW50KGMpLCB1KTtcbiAgICAgICAgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKEMsIF9hMTApLCBJID0gTnVtYmVyKF9pMTQgLyBfYTEwKSwgQyA9IEllLCBTID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcImRheVwiOlxuICAgICAge1xuICAgICAgICB2YXIgX3QzNSA9IE07XG4gICAgICAgIEMgPSBfdDM1ICogQmlnSW50KFMpICsgQztcbiAgICAgICAgdmFyIF9yNDkgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KEMsIF90MzUgKiBCaWdJbnQoYyksIHUpO1xuICAgICAgICBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoQywgX3QzNSksIFMgPSBOdW1iZXIoX3I0OSAvIF90MzUpLCBDID0gSWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfdDM2ID0gMzZlMTE7XG4gICAgICAgIHZhciBfcjUwID0gQmlnSW50KGcpICogMzYwMDAwMDAwMDAwMG47XG4gICAgICAgIF9yNTAgPSBfcjUwICsgQmlnSW50KHcpICogNjAwMDAwMDAwMDBuLCBfcjUwID0gX3I1MCArIEJpZ0ludChEKSAqIHZlLCBfcjUwID0gX3I1MCArIEJpZ0ludChHKSAqIEdlLCBfcjUwID0gX3I1MCArIEJpZ0ludCh2KSAqIERlLCBfcjUwID0gX3I1MCArIEMsIFIgPSBCaWdJbnREaXZpZGVUb051bWJlcihfcjUwLCBCaWdJbnQoX3QzNikpO1xuICAgICAgICB2YXIgX28xOSA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoX3I1MCwgQmlnSW50KF90MzYgKiBjKSwgdSk7XG4gICAgICAgIGcgPSBOdW1iZXIoX28xOSAvIEJpZ0ludChfdDM2KSksIEMgPSBJZSwgdyA9IEQgPSBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90MzcgPSA2ZTEwO1xuICAgICAgICB2YXIgX3I1MSA9IEJpZ0ludCh3KSAqIDYwMDAwMDAwMDAwbjtcbiAgICAgICAgX3I1MSA9IF9yNTEgKyBCaWdJbnQoRCkgKiB2ZSwgX3I1MSA9IF9yNTEgKyBCaWdJbnQoRykgKiBHZSwgX3I1MSA9IF9yNTEgKyBCaWdJbnQodikgKiBEZSwgX3I1MSA9IF9yNTEgKyBDLCBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoX3I1MSwgQmlnSW50KF90MzcpKTtcbiAgICAgICAgdmFyIF9vMjAgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KF9yNTEsIEJpZ0ludChfdDM3ICogYyksIHUpO1xuICAgICAgICB3ID0gTnVtYmVyKF9vMjAgLyBCaWdJbnQoX3QzNykpLCBDID0gSWUsIEQgPSBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90MzggPSAxZTk7XG4gICAgICAgIHZhciBfcjUyID0gQmlnSW50KEQpICogdmU7XG4gICAgICAgIF9yNTIgPSBfcjUyICsgQmlnSW50KEcpICogR2UsIF9yNTIgPSBfcjUyICsgQmlnSW50KHYpICogRGUsIF9yNTIgPSBfcjUyICsgQywgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKF9yNTIsIEJpZ0ludChfdDM4KSk7XG4gICAgICAgIHZhciBfbzIxID0gUm91bmROdW1iZXJUb0luY3JlbWVudChfcjUyLCBCaWdJbnQoX3QzOCAqIGMpLCB1KTtcbiAgICAgICAgRCA9IE51bWJlcihfbzIxIC8gQmlnSW50KF90MzgpKSwgQyA9IEllLCBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAge1xuICAgICAgICB2YXIgX3QzOSA9IDFlNjtcbiAgICAgICAgdmFyIF9yNTMgPSBCaWdJbnQoRykgKiBHZTtcbiAgICAgICAgX3I1MyA9IF9yNTMgKyBCaWdJbnQodikgKiBEZSwgX3I1MyA9IF9yNTMgKyBDLCBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoX3I1MywgQmlnSW50KF90MzkpKTtcbiAgICAgICAgdmFyIF9vMjIgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KF9yNTMsIEJpZ0ludChfdDM5ICogYyksIHUpO1xuICAgICAgICBHID0gTnVtYmVyKF9vMjIgLyBCaWdJbnQoX3QzOSkpLCBDID0gSWUsIHYgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibWljcm9zZWNvbmRcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90NDAgPSAxZTM7XG4gICAgICAgIHZhciBfcjU0ID0gQmlnSW50KHYpICogRGU7XG4gICAgICAgIF9yNTQgPSBfcjU0ICsgQywgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKF9yNTQsIEJpZ0ludChfdDQwKSk7XG4gICAgICAgIHZhciBfbzIzID0gUm91bmROdW1iZXJUb0luY3JlbWVudChfcjU0LCBCaWdJbnQoX3Q0MCAqIGMpLCB1KTtcbiAgICAgICAgdiA9IE51bWJlcihfbzIzIC8gQmlnSW50KF90NDApKSwgQyA9IEllO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibmFub3NlY29uZFwiOlxuICAgICAgUiA9IE51bWJlcihDKSwgQyA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQmlnSW50KEMpLCBCaWdJbnQoYyksIHUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGYsXG4gICAgbW9udGhzOiB5LFxuICAgIHdlZWtzOiBJLFxuICAgIGRheXM6IFMsXG4gICAgaG91cnM6IGcsXG4gICAgbWludXRlczogdyxcbiAgICBzZWNvbmRzOiBELFxuICAgIG1pbGxpc2Vjb25kczogRyxcbiAgICBtaWNyb3NlY29uZHM6IHYsXG4gICAgbmFub3NlY29uZHM6IE51bWJlcihDKSxcbiAgICB0b3RhbDogUlxuICB9O1xufVxuZnVuY3Rpb24gQ29tcGFyZUlTT0RhdGUoZSwgdCwgciwgbywgbiwgYSkge1xuICBmb3IgKHZhciBfaTE1ID0gMCwgX2FycjUgPSBbW2UsIG9dLCBbdCwgbl0sIFtyLCBhXV07IF9pMTUgPCBfYXJyNS5sZW5ndGg7IF9pMTUrKykge1xuICAgIHZhciBfYXJyNSRfaSA9IF9zbGljZWRUb0FycmF5KF9hcnI1W19pMTVdLCAyKSxcbiAgICAgIF9pMTYgPSBfYXJyNSRfaVswXSxcbiAgICAgIF9zNiA9IF9hcnI1JF9pWzFdO1xuICAgIGlmIChfaTE2ICE9PSBfczYpIHJldHVybiBDb21wYXJpc29uUmVzdWx0KF9pMTYgLSBfczYpO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QodCwgcikge1xuICB2YXIgX2Rpdm1vZDIyID0gZGl2bW9kKHQsIHIpLFxuICAgIG8gPSBfZGl2bW9kMjIucXVvdGllbnQsXG4gICAgbiA9IF9kaXZtb2QyMi5yZW1haW5kZXI7XG4gIHJldHVybiBuIDwgSWUgJiYgKG8gPSBvIC0gU2UsIG4gPSBuICsgciksIHtcbiAgICBxdW90aWVudDogbyxcbiAgICByZW1haW5kZXI6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEJpZ0ludEZsb29yRGl2KHQsIHIpIHtcbiAgdmFyIF9kaXZtb2QyMyA9IGRpdm1vZCh0LCByKSxcbiAgICBvID0gX2Rpdm1vZDIzLnF1b3RpZW50LFxuICAgIG4gPSBfZGl2bW9kMjMucmVtYWluZGVyO1xuICByZXR1cm4gaXNaZXJvKG4pIHx8ICFpc05lZ2F0aXZlSlNCSSh0KSA9PSAhaXNOZWdhdGl2ZUpTQkkocikgPyBvIDogbyAtIFNlO1xufVxuZnVuY3Rpb24gQmlnSW50RGl2aWRlVG9OdW1iZXIodCwgcikge1xuICB2YXIgX2Rpdm1vZDI0ID0gZGl2bW9kKHQsIHIpLFxuICAgIG8gPSBfZGl2bW9kMjQucXVvdGllbnQsXG4gICAgbiA9IF9kaXZtb2QyNC5yZW1haW5kZXI7XG4gIHJldHVybiBOdW1iZXIobykgKyBOdW1iZXIobikgLyBOdW1iZXIocik7XG59XG5mdW5jdGlvbiBUb0JpZ0ludEV4dGVybmFsKGUpIHtcbiAgdmFyIHQgPSBUb0JpZ0ludChlKTtcbiAgcmV0dXJuIHZvaWQgMCAhPT0gZ2xvYmFsVGhpcy5CaWdJbnQgPyBnbG9iYWxUaGlzLkJpZ0ludCh0LnRvU3RyaW5nKDEwKSkgOiB0O1xufVxuZnVuY3Rpb24gVG9CaWdJbnQodCkge1xuICB2YXIgciA9IHQ7XG4gIGlmIChcIm9iamVjdFwiID09IF90eXBlb2YodCkpIHtcbiAgICB2YXIgX2UzMiA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICBfZTMyICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgX2UzMiAmJiAociA9IGZlKF9lMzIsIHQsIFtcIm51bWJlclwiXSkpO1xuICB9XG4gIGlmIChcIm51bWJlclwiID09IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgcmV0dXJuIFwiYmlnaW50XCIgPT0gdHlwZW9mIHIgPyBCaWdJbnQoci50b1N0cmluZygxMCkpIDogQmlnSW50KHIpO1xufVxudmFyIFZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdCA9IEJpZ0ludChEYXRlLm5vdygpICUgMWU2KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IEJpZ0ludChEYXRlLm5vdygpKSxcbiAgICAgIG8gPSByICogR2UgKyB0O1xuICAgIHJldHVybiB0ID0gciAlIEdlLCBvID4gUmUgPyBSZSA6IG8gPCBNZSA/IE1lIDogbztcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIERlZmF1bHRUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyByZSgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xufVxuZnVuY3Rpb24gQ29tcGFyaXNvblJlc3VsdChlKSB7XG4gIHJldHVybiBlIDwgMCA/IC0xIDogZSA+IDAgPyAxIDogZTtcbn1cbmZ1bmN0aW9uIEdldE9wdGlvbnNPYmplY3QoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gVGUobnVsbCk7XG4gIGlmIChJc09iamVjdChlKSAmJiBudWxsICE9PSBlKSByZXR1cm4gZTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9wdGlvbnMgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgXCIgKyAobnVsbCA9PT0gZSA/IFwibnVsbFwiIDogXCJcIiArIF90eXBlb2YoZSkpKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZU9uZVByb3BPYmplY3QoZSwgdCkge1xuICB2YXIgciA9IFRlKG51bGwpO1xuICByZXR1cm4gcltlXSA9IHQsIHI7XG59XG5mdW5jdGlvbiBDb3B5T3B0aW9ucyhlKSB7XG4gIHZhciB0ID0gVGUobnVsbCk7XG4gIHJldHVybiBDb3B5RGF0YVByb3BlcnRpZXModCwgR2V0T3B0aW9uc09iamVjdChlKSwgW10pLCB0O1xufVxuZnVuY3Rpb24gR2V0T3B0aW9uKGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBlW3RdO1xuICBpZiAodm9pZCAwICE9PSBuKSB7XG4gICAgaWYgKG4gPSBUb1N0cmluZyhuKSwgIXIuaW5jbHVkZXMobikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KHQsIFwiIG11c3QgYmUgb25lIG9mIFwiKS5jb25jYXQoci5qb2luKFwiLCBcIiksIFwiLCBub3QgXCIpLmNvbmNhdChuKSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBJc0J1aWx0aW5DYWxlbmRhcihlKSB7XG4gIHJldHVybiBqZS5pbmNsdWRlcyhBU0NJSUxvd2VyY2FzZShlKSk7XG59XG5mdW5jdGlvbiBBU0NJSUxvd2VyY2FzZShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHQgPSBlLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodCArIDMyKTtcbiAgfSk7XG59XG52YXIgemUgPSBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChXLnNvdXJjZSwgXCIkXCIpKTtcbmZ1bmN0aW9uIGJpc2VjdCh0LCByLCBvKSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0KHIpO1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdChvKTtcbiAgdmFyIGkgPSBCaWdJbnQociksXG4gICAgcyA9IEJpZ0ludChvKSxcbiAgICBsID0gbixcbiAgICBkID0gYTtcbiAgZm9yICg7IHMgLSBpID4gU2U7KSB7XG4gICAgdmFyIF9yNTUgPSAoaSArIHMpIC8gMm4sXG4gICAgICBfbzI0ID0gdChfcjU1KTtcbiAgICBpZiAoX28yNCA9PT0gbCkgaSA9IF9yNTUsIGwgPSBfbzI0O2Vsc2Uge1xuICAgICAgaWYgKF9vMjQgIT09IGQpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUgaW4gYmlzZWN0aW9uIFwiLmNvbmNhdChsLCBcIiAtIFwiKS5jb25jYXQoX28yNCwgXCIgLSBcIikuY29uY2F0KGQpKTtcbiAgICAgIHMgPSBfcjU1LCBkID0gX28yNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG52YXIgX2UgPSB7XG4gICAgaG91cjogMzZlMTEsXG4gICAgbWludXRlOiA2ZTEwLFxuICAgIHNlY29uZDogMWU5LFxuICAgIG1pbGxpc2Vjb25kOiAxZTYsXG4gICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICBuYW5vc2Vjb25kOiAxXG4gIH0sXG4gIEplID0gU3ltYm9sKFwiZGF0ZVwiKSxcbiAgS2UgPSBTeW1ib2woXCJ5bVwiKSxcbiAgWGUgPSBTeW1ib2woXCJtZFwiKSxcbiAgUWUgPSBTeW1ib2woXCJ0aW1lXCIpLFxuICBldCA9IFN5bWJvbChcImRhdGV0aW1lXCIpLFxuICB0dCA9IFN5bWJvbChcImluc3RhbnRcIiksXG4gIHJ0ID0gU3ltYm9sKFwib3JpZ2luYWxcIiksXG4gIG90ID0gU3ltYm9sKFwidGltZXpvbmVcIiksXG4gIG50ID0gU3ltYm9sKFwiY2FsZW5kYXItaWRcIiksXG4gIGF0ID0gU3ltYm9sKFwibG9jYWxlXCIpLFxuICBpdCA9IFN5bWJvbChcIm9wdGlvbnNcIiksXG4gIGRlc2NyaXB0b3IgPSBmdW5jdGlvbiBkZXNjcmlwdG9yKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9O1xuICB9LFxuICBzdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdCxcbiAgbHQgPSBPYmplY3QuYXNzaWduLFxuICBkdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gIG10ID0gUmVmbGVjdC5hcHBseTtcbmZ1bmN0aW9uIGdldFByb3BMYXp5KGUsIHQpIHtcbiAgdmFyIHIgPSBlW3RdO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiByICYmIChyID0gbmV3IHN0KGVbYXRdLCByKGVbaXRdKSksIGVbdF0gPSByKSwgcjtcbn1cbmZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0SW1wbChlKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERhdGVUaW1lRm9ybWF0SW1wbCkpIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRJbXBsKGUsIHQpO1xuICB2YXIgciA9IHZvaWQgMCAhPT0gdCxcbiAgICBvID0gciA/IGx0KHt9LCB0KSA6IHt9LFxuICAgIG4gPSBuZXcgc3QoZSwgbyksXG4gICAgYSA9IG4ucmVzb2x2ZWRPcHRpb25zKCk7XG4gIGlmIChyKSB7XG4gICAgdmFyIF9lMzMgPSBsdCh7fSwgYSk7XG4gICAgZm9yICh2YXIgX3Q0MSBpbiBfZTMzKSBtdChkdCwgbywgW190NDFdKSB8fCBkZWxldGUgX2UzM1tfdDQxXTtcbiAgICB0aGlzW2l0XSA9IF9lMzM7XG4gIH0gZWxzZSB0aGlzW2l0XSA9IG87XG4gIHRoaXNbYXRdID0gYS5sb2NhbGUsIHRoaXNbcnRdID0gbiwgdGhpc1tvdF0gPSBhLnRpbWVab25lLCB0aGlzW250XSA9IGEuY2FsZW5kYXIsIHRoaXNbSmVdID0gZGF0ZUFtZW5kLCB0aGlzW0tlXSA9IHllYXJNb250aEFtZW5kLCB0aGlzW1hlXSA9IG1vbnRoRGF5QW1lbmQsIHRoaXNbUWVdID0gdGltZUFtZW5kLCB0aGlzW2V0XSA9IGRhdGV0aW1lQW1lbmQsIHRoaXNbdHRdID0gaW5zdGFudEFtZW5kO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVUaW1lRm9ybWF0SW1wbCwgXCJuYW1lXCIsIHtcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogXCJEYXRlVGltZUZvcm1hdFwiXG59KSwgRGF0ZVRpbWVGb3JtYXRJbXBsLnN1cHBvcnRlZExvY2FsZXNPZiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gIHJldHVybiBzdC5zdXBwb3J0ZWRMb2NhbGVzT2YoZSwgdCk7XG59O1xudmFyIGN0ID0ge1xuICByZXNvbHZlZE9wdGlvbnM6IGRlc2NyaXB0b3IoZnVuY3Rpb24gcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzW3J0XS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfSksXG4gIGZvcm1hdDogZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXQoZSkge1xuICAgIHZhciBfdGhpcyRydDtcbiAgICB2YXIgX2V4dHJhY3RPdmVycmlkZXMgPSBleHRyYWN0T3ZlcnJpZGVzKGUsIHRoaXMpLFxuICAgICAgciA9IF9leHRyYWN0T3ZlcnJpZGVzLmluc3RhbnQsXG4gICAgICBvID0gX2V4dHJhY3RPdmVycmlkZXMuZm9ybWF0dGVyO1xuICAgIGlmIChyICYmIG8pIHJldHVybiBvLmZvcm1hdChyLmVwb2NoTWlsbGlzZWNvbmRzKTtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgdFtfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIChfdGhpcyRydCA9IHRoaXNbcnRdKS5mb3JtYXQuYXBwbHkoX3RoaXMkcnQsIFtlXS5jb25jYXQodCkpO1xuICB9KSxcbiAgZm9ybWF0UmFuZ2U6IGRlc2NyaXB0b3IoZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZSwgdCkge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGUpIHx8IGlzVGVtcG9yYWxPYmplY3QodCkpIHtcbiAgICAgIGlmICghc2FtZVRlbXBvcmFsVHlwZShlLCB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0UmFuZ2UgYWNjZXB0cyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICB2YXIgX2V4dHJhY3RPdmVycmlkZXMyID0gZXh0cmFjdE92ZXJyaWRlcyhlLCB0aGlzKSxcbiAgICAgICAgX3I1NiA9IF9leHRyYWN0T3ZlcnJpZGVzMi5pbnN0YW50LFxuICAgICAgICBfbzI1ID0gX2V4dHJhY3RPdmVycmlkZXMyLmZvcm1hdHRlcixcbiAgICAgICAgX2V4dHJhY3RPdmVycmlkZXMzID0gZXh0cmFjdE92ZXJyaWRlcyh0LCB0aGlzKSxcbiAgICAgICAgX24xNSA9IF9leHRyYWN0T3ZlcnJpZGVzMy5pbnN0YW50LFxuICAgICAgICBfYTExID0gX2V4dHJhY3RPdmVycmlkZXMzLmZvcm1hdHRlcjtcbiAgICAgIGlmIChfcjU2ICYmIF9uMTUgJiYgX28yNSAmJiBfYTExICYmIF9vMjUgPT09IF9hMTEpIHJldHVybiBfbzI1LmZvcm1hdFJhbmdlKF9yNTYuZXBvY2hNaWxsaXNlY29uZHMsIF9uMTUuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tydF0uZm9ybWF0UmFuZ2UoZSwgdCk7XG4gIH0pXG59O1xuXCJmb3JtYXRUb1BhcnRzXCIgaW4gc3QucHJvdG90eXBlICYmIChjdC5mb3JtYXRUb1BhcnRzID0gZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXRUb1BhcnRzKGUpIHtcbiAgdmFyIF90aGlzJHJ0MjtcbiAgdmFyIF9leHRyYWN0T3ZlcnJpZGVzNCA9IGV4dHJhY3RPdmVycmlkZXMoZSwgdGhpcyksXG4gICAgciA9IF9leHRyYWN0T3ZlcnJpZGVzNC5pbnN0YW50LFxuICAgIG8gPSBfZXh0cmFjdE92ZXJyaWRlczQuZm9ybWF0dGVyO1xuICBpZiAociAmJiBvKSByZXR1cm4gby5mb3JtYXRUb1BhcnRzKHIuZXBvY2hNaWxsaXNlY29uZHMpO1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHRbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgcmV0dXJuIChfdGhpcyRydDIgPSB0aGlzW3J0XSkuZm9ybWF0VG9QYXJ0cy5hcHBseShfdGhpcyRydDIsIFtlXS5jb25jYXQodCkpO1xufSkpLCBcImZvcm1hdFJhbmdlVG9QYXJ0c1wiIGluIHN0LnByb3RvdHlwZSAmJiAoY3QuZm9ybWF0UmFuZ2VUb1BhcnRzID0gZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXRSYW5nZVRvUGFydHMoZSwgdCkge1xuICBpZiAoaXNUZW1wb3JhbE9iamVjdChlKSB8fCBpc1RlbXBvcmFsT2JqZWN0KHQpKSB7XG4gICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGUsIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRSYW5nZVRvUGFydHMgYWNjZXB0cyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgdmFyIF9leHRyYWN0T3ZlcnJpZGVzNSA9IGV4dHJhY3RPdmVycmlkZXMoZSwgdGhpcyksXG4gICAgICBfcjU3ID0gX2V4dHJhY3RPdmVycmlkZXM1Lmluc3RhbnQsXG4gICAgICBfbzI2ID0gX2V4dHJhY3RPdmVycmlkZXM1LmZvcm1hdHRlcixcbiAgICAgIF9leHRyYWN0T3ZlcnJpZGVzNiA9IGV4dHJhY3RPdmVycmlkZXModCwgdGhpcyksXG4gICAgICBfbjE2ID0gX2V4dHJhY3RPdmVycmlkZXM2Lmluc3RhbnQsXG4gICAgICBfYTEyID0gX2V4dHJhY3RPdmVycmlkZXM2LmZvcm1hdHRlcjtcbiAgICBpZiAoX3I1NyAmJiBfbjE2ICYmIF9vMjYgJiYgX2ExMiAmJiBfbzI2ID09PSBfYTEyKSByZXR1cm4gX28yNi5mb3JtYXRSYW5nZVRvUGFydHMoX3I1Ny5lcG9jaE1pbGxpc2Vjb25kcywgX24xNi5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXNbcnRdLmZvcm1hdFJhbmdlVG9QYXJ0cyhlLCB0KTtcbn0pKSwgRGF0ZVRpbWVGb3JtYXRJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3QucHJvdG90eXBlLCBjdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZUZvcm1hdEltcGwsIFwicHJvdG90eXBlXCIsIHtcbiAgd3JpdGFibGU6ICExLFxuICBlbnVtZXJhYmxlOiAhMSxcbiAgY29uZmlndXJhYmxlOiAhMVxufSk7XG52YXIgaHQgPSBEYXRlVGltZUZvcm1hdEltcGw7XG5mdW5jdGlvbiBhbWVuZCgpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciByID0gbHQoe30sIGUpO1xuICBmb3IgKHZhciBfaTE3ID0gMCwgX2FycjYgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwid2Vla2RheVwiLCBcImRheVBlcmlvZFwiLCBcInRpbWVab25lTmFtZVwiLCBcImRhdGVTdHlsZVwiLCBcInRpbWVTdHlsZVwiXTsgX2kxNyA8IF9hcnI2Lmxlbmd0aDsgX2kxNysrKSB7XG4gICAgdmFyIF9lMzQgPSBfYXJyNltfaTE3XTtcbiAgICByW19lMzRdID0gX2UzNCBpbiB0ID8gdFtfZTM0XSA6IHJbX2UzNF0sICExICE9PSByW19lMzRdICYmIHZvaWQgMCAhPT0gcltfZTM0XSB8fCBkZWxldGUgcltfZTM0XTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRpbWVBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHllYXI6ICExLFxuICAgIG1vbnRoOiAhMSxcbiAgICBkYXk6ICExLFxuICAgIHdlZWtkYXk6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMVxuICB9KTtcbiAgcmV0dXJuIGhhc1RpbWVPcHRpb25zKHQpIHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgIHNlY29uZDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24geWVhck1vbnRoQW1lbmQoZSkge1xuICB2YXIgdCA9IGFtZW5kKGUsIHtcbiAgICBkYXk6ICExLFxuICAgIGhvdXI6ICExLFxuICAgIG1pbnV0ZTogITEsXG4gICAgc2Vjb25kOiAhMSxcbiAgICB3ZWVrZGF5OiAhMSxcbiAgICBkYXlQZXJpb2Q6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMSxcbiAgICB0aW1lU3R5bGU6ICExXG4gIH0pO1xuICByZXR1cm4gXCJ5ZWFyXCIgaW4gdCB8fCBcIm1vbnRoXCIgaW4gdCB8fCAodCA9IGx0KHQsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gbW9udGhEYXlBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHllYXI6ICExLFxuICAgIGhvdXI6ICExLFxuICAgIG1pbnV0ZTogITEsXG4gICAgc2Vjb25kOiAhMSxcbiAgICB3ZWVrZGF5OiAhMSxcbiAgICBkYXlQZXJpb2Q6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMSxcbiAgICB0aW1lU3R5bGU6ICExXG4gIH0pO1xuICByZXR1cm4gXCJtb250aFwiIGluIHQgfHwgXCJkYXlcIiBpbiB0IHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIlxuICB9KSksIHQ7XG59XG5mdW5jdGlvbiBkYXRlQW1lbmQoZSkge1xuICB2YXIgdCA9IGFtZW5kKGUsIHtcbiAgICBob3VyOiAhMSxcbiAgICBtaW51dGU6ICExLFxuICAgIHNlY29uZDogITEsXG4gICAgZGF5UGVyaW9kOiAhMSxcbiAgICB0aW1lWm9uZU5hbWU6ICExLFxuICAgIHRpbWVTdHlsZTogITFcbiAgfSk7XG4gIHJldHVybiBoYXNEYXRlT3B0aW9ucyh0KSB8fCAodCA9IGx0KHt9LCB0LCB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gZGF0ZXRpbWVBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHRpbWVab25lTmFtZTogITFcbiAgfSk7XG4gIHJldHVybiBoYXNUaW1lT3B0aW9ucyh0KSB8fCBoYXNEYXRlT3B0aW9ucyh0KSB8fCAodCA9IGx0KHt9LCB0LCB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICBzZWNvbmQ6IFwibnVtZXJpY1wiXG4gIH0pKSwgdDtcbn1cbmZ1bmN0aW9uIGluc3RhbnRBbWVuZChlKSB7XG4gIHZhciB0ID0gZTtcbiAgcmV0dXJuIGhhc1RpbWVPcHRpb25zKHQpIHx8IGhhc0RhdGVPcHRpb25zKHQpIHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgIHNlY29uZDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gaGFzRGF0ZU9wdGlvbnMoZSkge1xuICByZXR1cm4gXCJ5ZWFyXCIgaW4gZSB8fCBcIm1vbnRoXCIgaW4gZSB8fCBcImRheVwiIGluIGUgfHwgXCJ3ZWVrZGF5XCIgaW4gZSB8fCBcImRhdGVTdHlsZVwiIGluIGU7XG59XG5mdW5jdGlvbiBoYXNUaW1lT3B0aW9ucyhlKSB7XG4gIHJldHVybiBcImhvdXJcIiBpbiBlIHx8IFwibWludXRlXCIgaW4gZSB8fCBcInNlY29uZFwiIGluIGUgfHwgXCJ0aW1lU3R5bGVcIiBpbiBlIHx8IFwiZGF5UGVyaW9kXCIgaW4gZTtcbn1cbmZ1bmN0aW9uIGlzVGVtcG9yYWxPYmplY3QoZSkge1xuICByZXR1cm4gSXNUZW1wb3JhbERhdGUoZSkgfHwgSXNUZW1wb3JhbFRpbWUoZSkgfHwgSXNUZW1wb3JhbERhdGVUaW1lKGUpIHx8IElzVGVtcG9yYWxab25lZERhdGVUaW1lKGUpIHx8IElzVGVtcG9yYWxZZWFyTW9udGgoZSkgfHwgSXNUZW1wb3JhbE1vbnRoRGF5KGUpIHx8IElzVGVtcG9yYWxJbnN0YW50KGUpO1xufVxuZnVuY3Rpb24gc2FtZVRlbXBvcmFsVHlwZShlLCB0KSB7XG4gIHJldHVybiAhKCFpc1RlbXBvcmFsT2JqZWN0KGUpIHx8ICFpc1RlbXBvcmFsT2JqZWN0KHQpKSAmJiAhKElzVGVtcG9yYWxUaW1lKGUpICYmICFJc1RlbXBvcmFsVGltZSh0KSkgJiYgIShJc1RlbXBvcmFsRGF0ZShlKSAmJiAhSXNUZW1wb3JhbERhdGUodCkpICYmICEoSXNUZW1wb3JhbERhdGVUaW1lKGUpICYmICFJc1RlbXBvcmFsRGF0ZVRpbWUodCkpICYmICEoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkgJiYgIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHQpKSAmJiAhKElzVGVtcG9yYWxZZWFyTW9udGgoZSkgJiYgIUlzVGVtcG9yYWxZZWFyTW9udGgodCkpICYmICEoSXNUZW1wb3JhbE1vbnRoRGF5KGUpICYmICFJc1RlbXBvcmFsTW9udGhEYXkodCkpICYmICEoSXNUZW1wb3JhbEluc3RhbnQoZSkgJiYgIUlzVGVtcG9yYWxJbnN0YW50KHQpKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPdmVycmlkZXMoZSwgdCkge1xuICB2YXIgciA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKTtcbiAgaWYgKElzVGVtcG9yYWxUaW1lKGUpKSB7XG4gICAgdmFyIF9vMjcgPSBuZXcgcigxOTcwLCAxLCAxLCBHZXRTbG90KGUsIGQpLCBHZXRTbG90KGUsIG0pLCBHZXRTbG90KGUsIGMpLCBHZXRTbG90KGUsIGgpLCBHZXRTbG90KGUsIHUpLCBHZXRTbG90KGUsIFQpLCB0W250XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbnQ6IEdldEluc3RhbnRGb3IodFtvdF0sIF9vMjcsIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgUWUpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbFllYXJNb250aChlKSkge1xuICAgIHZhciBfbzI4ID0gR2V0U2xvdChlLCBpKSxcbiAgICAgIF9uMTcgPSBHZXRTbG90KGUsIHMpLFxuICAgICAgX2ExMyA9IEdldFNsb3QoZSwgbCksXG4gICAgICBfZDcgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QoZSwgcCkpO1xuICAgIGlmIChfZDcgIT09IHRbbnRdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBmb3JtYXQgUGxhaW5ZZWFyTW9udGggd2l0aCBjYWxlbmRhciBcIi5jb25jYXQoX2Q3LCBcIiBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciBcIikuY29uY2F0KHRbbnRdKSk7XG4gICAgdmFyIF9tNiA9IG5ldyByKF9vMjgsIF9uMTcsIF9hMTMsIDEyLCAwLCAwLCAwLCAwLCAwLCBfZDcpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW50OiBHZXRJbnN0YW50Rm9yKHRbb3RdLCBfbTYsIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgS2UpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbE1vbnRoRGF5KGUpKSB7XG4gICAgdmFyIF9vMjkgPSBHZXRTbG90KGUsIGkpLFxuICAgICAgX24xOCA9IEdldFNsb3QoZSwgcyksXG4gICAgICBfYTE0ID0gR2V0U2xvdChlLCBsKSxcbiAgICAgIF9kOCA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKF9kOCAhPT0gdFtudF0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IGZvcm1hdCBQbGFpbk1vbnRoRGF5IHdpdGggY2FsZW5kYXIgXCIuY29uY2F0KF9kOCwgXCIgaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgXCIpLmNvbmNhdCh0W250XSkpO1xuICAgIHZhciBfbTcgPSBuZXcgcihfbzI5LCBfbjE4LCBfYTE0LCAxMiwgMCwgMCwgMCwgMCwgMCwgX2Q4KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX203LCBcImNvbXBhdGlibGVcIiksXG4gICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KHQsIFhlKVxuICAgIH07XG4gIH1cbiAgaWYgKElzVGVtcG9yYWxEYXRlKGUpKSB7XG4gICAgdmFyIF9vMzAgPSBHZXRTbG90KGUsIGkpLFxuICAgICAgX24xOSA9IEdldFNsb3QoZSwgcyksXG4gICAgICBfYTE1ID0gR2V0U2xvdChlLCBsKSxcbiAgICAgIF9kOSA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKFwiaXNvODYwMVwiICE9PSBfZDkgJiYgX2Q5ICE9PSB0W250XSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYW5ub3QgZm9ybWF0IFBsYWluRGF0ZSB3aXRoIGNhbGVuZGFyIFwiLmNvbmNhdChfZDksIFwiIGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyIFwiKS5jb25jYXQodFtudF0pKTtcbiAgICB2YXIgX204ID0gbmV3IHIoX28zMCwgX24xOSwgX2ExNSwgMTIsIDAsIDAsIDAsIDAsIDAsIHRbbnRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX204LCBcImNvbXBhdGlibGVcIiksXG4gICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KHQsIEplKVxuICAgIH07XG4gIH1cbiAgaWYgKElzVGVtcG9yYWxEYXRlVGltZShlKSkge1xuICAgIHZhciBfbzMxID0gR2V0U2xvdChlLCBpKSxcbiAgICAgIF9uMjAgPSBHZXRTbG90KGUsIHMpLFxuICAgICAgX2ExNiA9IEdldFNsb3QoZSwgbCksXG4gICAgICBfZjUgPSBHZXRTbG90KGUsIGQpLFxuICAgICAgX3kgPSBHZXRTbG90KGUsIG0pLFxuICAgICAgX0kzID0gR2V0U2xvdChlLCBjKSxcbiAgICAgIF9TMyA9IEdldFNsb3QoZSwgaCksXG4gICAgICBfZzIgPSBHZXRTbG90KGUsIHUpLFxuICAgICAgX3cgPSBHZXRTbG90KGUsIFQpLFxuICAgICAgX0QgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QoZSwgcCkpO1xuICAgIGlmIChcImlzbzg2MDFcIiAhPT0gX0QgJiYgX0QgIT09IHRbbnRdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBmb3JtYXQgUGxhaW5EYXRlVGltZSB3aXRoIGNhbGVuZGFyIFwiLmNvbmNhdChfRCwgXCIgaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgXCIpLmNvbmNhdCh0W250XSkpO1xuICAgIHZhciBfRyA9IGU7XG4gICAgcmV0dXJuIFwiaXNvODYwMVwiID09PSBfRCAmJiAoX0cgPSBuZXcgcihfbzMxLCBfbjIwLCBfYTE2LCBfZjUsIF95LCBfSTMsIF9TMywgX2cyLCBfdywgdFtudF0pKSwge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX0csIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgZXQpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW1wb3JhbC5ab25lZERhdGVUaW1lIG5vdCBzdXBwb3J0ZWQgaW4gRGF0ZVRpbWVGb3JtYXQgbWV0aG9kcy4gVXNlIHRvTG9jYWxlU3RyaW5nKCkgaW5zdGVhZC5cIik7XG4gIHJldHVybiBJc1RlbXBvcmFsSW5zdGFudChlKSA/IHtcbiAgICBpbnN0YW50OiBlLFxuICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgdHQpXG4gIH0gOiB7fTtcbn1cbnZhciB1dCA9IE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIERhdGVUaW1lRm9ybWF0OiBodFxufSk7XG52YXIgSW5zdGFudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluc3RhbnQoZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnN0YW50KTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50OiBlcG9jaE5hbm9zZWNvbmRzIGlzIHJlcXVpcmVkXCIpO1xuICAgIHZhciB0ID0gVG9CaWdJbnQoZSk7XG4gICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKHQpLCBOKHRoaXMpLCBTZXRTbG90KHRoaXMsIG4sIHQpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhJbnN0YW50LCBbe1xuICAgIGtleTogXCJlcG9jaFNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIG4pO1xuICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnRGbG9vckRpdih0LCB2ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE1pbGxpc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEJpZ0ludChHZXRTbG90KHRoaXMsIG4pKTtcbiAgICAgIHJldHVybiBOdW1iZXIoQmlnSW50Rmxvb3JEaXYodCwgR2UpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXBvY2hNaWNyb3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoQmlnSW50Rmxvb3JEaXYoQmlnSW50KEdldFNsb3QodGhpcywgbikpLCBEZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE5hbm9zZWNvbmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEJpZ0ludChHZXRTbG90KHRoaXMsIG4pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21JbnN0YW50KFwiYWRkXCIsIHRoaXMsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUluc3RhbnQoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsSW5zdGFudChcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxJbnN0YW50KFwic2luY2VcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHQgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgYSA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUpO1xuICAgICAgVmFsaWRhdGVUZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHIsIHtcbiAgICAgICAgaG91cjogMjQsXG4gICAgICAgIG1pbnV0ZTogMTQ0MCxcbiAgICAgICAgc2Vjb25kOiA4NjQwMCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDg2NGU1LFxuICAgICAgICBtaWNyb3NlY29uZDogODY0ZTgsXG4gICAgICAgIG5hbm9zZWNvbmQ6IDg2NGUxMVxuICAgICAgfVthXSwgITApO1xuICAgICAgdmFyIGkgPSBSb3VuZEluc3RhbnQoR2V0U2xvdCh0aGlzLCBuKSwgciwgYSwgbyk7XG4gICAgICByZXR1cm4gbmV3IEluc3RhbnQoaSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHModCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxJbnN0YW50KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBuKSxcbiAgICAgICAgYSA9IEdldFNsb3Qociwgbik7XG4gICAgICByZXR1cm4gQmlnSW50KG8pID09PSBCaWdJbnQoYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRPcHRpb25zT2JqZWN0KGUpLFxuICAgICAgICByID0gVG9GcmFjdGlvbmFsU2Vjb25kRGlnaXRzKHQpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpLFxuICAgICAgICBhID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIFwidGltZVwiLCB2b2lkIDApO1xuICAgICAgaWYgKFwiaG91clwiID09PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3QgYmUgYSB0aW1lIHVuaXQgb3RoZXIgdGhhbiBcImhvdXJcIicpO1xuICAgICAgdmFyIGkgPSB0LnRpbWVab25lO1xuICAgICAgdm9pZCAwICE9PSBpICYmIChpID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKGkpKTtcbiAgICAgIHZhciBfVG9TZWNvbmRzU3RyaW5nUHJlY2kgPSBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb25SZWNvcmQoYSwgciksXG4gICAgICAgIHMgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kucHJlY2lzaW9uLFxuICAgICAgICBsID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpLnVuaXQsXG4gICAgICAgIGQgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kuaW5jcmVtZW50LFxuICAgICAgICBtID0gUm91bmRJbnN0YW50KEdldFNsb3QodGhpcywgbiksIGQsIGwsIG8pO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKG5ldyBJbnN0YW50KG0pLCBpLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKHRoaXMsIHZvaWQgMCwgXCJhdXRvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBuZXcgaHQoZSwgdCkuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLkluc3RhbnRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvWm9uZWREYXRlVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudCBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgdCA9IGUuY2FsZW5kYXI7XG4gICAgICBpZiAodm9pZCAwID09PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWlzc2luZyBjYWxlbmRhciBwcm9wZXJ0eSBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZSh0KSxcbiAgICAgICAgbyA9IGUudGltZVpvbmU7XG4gICAgICBpZiAodm9pZCAwID09PSBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWlzc2luZyB0aW1lWm9uZSBwcm9wZXJ0eSBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgYSA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShvKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvWm9uZWREYXRlVGltZUlTT1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWVJU08oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgdCwgXCJpc284NjAxXCIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21FcG9jaFNlY29uZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVwb2NoU2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvTnVtYmVyKHQpLFxuICAgICAgICBvID0gQmlnSW50KHIpICogdmU7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKG8pLCBuZXcgSW5zdGFudChvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVwb2NoTWlsbGlzZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE1pbGxpc2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvTnVtYmVyKHQpLFxuICAgICAgICBvID0gQmlnSW50KHIpICogR2U7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKG8pLCBuZXcgSW5zdGFudChvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVwb2NoTWljcm9zZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE1pY3Jvc2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvQmlnSW50KHQpLFxuICAgICAgICBvID0gciAqIERlO1xuICAgICAgcmV0dXJuIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhvKSwgbmV3IEluc3RhbnQobyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21FcG9jaE5hbm9zZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE5hbm9zZWNvbmRzKGUpIHtcbiAgICAgIHZhciB0ID0gVG9CaWdJbnQoZSk7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKHQpLCBuZXcgSW5zdGFudCh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUpIHtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsSW5zdGFudChlKSA/IG5ldyBJbnN0YW50KEdldFNsb3QoZSwgbikpIDogVG9UZW1wb3JhbEluc3RhbnQoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZSh0LCByKSB7XG4gICAgICB2YXIgbyA9IFRvVGVtcG9yYWxJbnN0YW50KHQpLFxuICAgICAgICBhID0gVG9UZW1wb3JhbEluc3RhbnQociksXG4gICAgICAgIGkgPSBHZXRTbG90KG8sIG4pLFxuICAgICAgICBzID0gR2V0U2xvdChhLCBuKTtcbiAgICAgIHJldHVybiBpIDwgcyA/IC0xIDogaSA+IHMgPyAxIDogMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEluc3RhbnQ7XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoSW5zdGFudCwgXCJUZW1wb3JhbC5JbnN0YW50XCIpO1xudmFyIFR0ID0gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzLFxuICBwdCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLFxuICBmdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdCxcbiAgeXQgPSBBcnJheS5wcm90b3R5cGUuc29ydCxcbiAgSXQgPSBNYXRoLmFicyxcbiAgU3QgPSBNYXRoLmZsb29yLFxuICBndCA9IE9iamVjdC5jcmVhdGUsXG4gIHd0ID0gT2JqZWN0LmVudHJpZXMsXG4gIER0ID0gU2V0LFxuICBHdCA9IFJlZmxlY3Qub3duS2V5cyxcbiAgdnQgPSBTZXQucHJvdG90eXBlLmFkZCxcbiAgQ3QgPSBTZXQucHJvdG90eXBlLnZhbHVlcyxcbiAgT3QgPSB7fTtcbnZhciBDYWxlbmRhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbGVuZGFyKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXIpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50OiBpZCBpcyByZXF1aXJlZFwiKTtcbiAgICB2YXIgdCA9IFRvU3RyaW5nKGUpO1xuICAgIGlmICghSXNCdWlsdGluQ2FsZW5kYXIodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdCh0KSk7XG4gICAgTih0aGlzKSwgU2V0U2xvdCh0aGlzLCBGLCBBU0NJSUxvd2VyY2FzZSh0KSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENhbGVuZGFyLCBbe1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgRik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGVGcm9tRmllbGRzKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGZpZWxkc1wiKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRik7XG4gICAgICByZXR1cm4gT3Rbb10uZGF0ZUZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJNb250aEZyb21GaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck1vbnRoRnJvbUZpZWxkcyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBmaWVsZHNcIik7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIEYpO1xuICAgICAgcmV0dXJuIE90W29dLnllYXJNb250aEZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoRGF5RnJvbUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aERheUZyb21GaWVsZHMoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgZmllbGRzXCIpO1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICAgIHJldHVybiBPdFtvXS5tb250aERheUZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBbXSxcbiAgICAgICAgciA9IG5ldyBTZXQoW1wieWVhclwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCIsIFwibWljcm9zZWNvbmRcIiwgXCJuYW5vc2Vjb25kXCJdKTtcbiAgICAgIHZhciBfaXRlcmF0b3IxNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGUpLFxuICAgICAgICBfc3RlcDE1O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNS5zKCk7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX28zMiA9IF9zdGVwMTUudmFsdWU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIF9vMzIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGZpZWxkc1wiKTtcbiAgICAgICAgICBpZiAoIXIuaGFzKF9vMzIpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZmllbGQgbmFtZSBcIi5jb25jYXQoX28zMikpO1xuICAgICAgICAgIHJbXCJkZWxldGVcIl0oX28zMiksIHB0LmNhbGwodCwgX28zMik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNS5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3RbR2V0U2xvdCh0aGlzLCBGKV0uZmllbGRzKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUZpZWxkcyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvT2JqZWN0KGUpLFxuICAgICAgICBvID0gZ3QobnVsbCk7XG4gICAgICBDb3B5RGF0YVByb3BlcnRpZXMobywgciwgW10sIFt2b2lkIDBdKTtcbiAgICAgIHZhciBuID0gVG9PYmplY3QodCksXG4gICAgICAgIGEgPSBndChudWxsKTtcbiAgICAgIENvcHlEYXRhUHJvcGVydGllcyhhLCBuLCBbXSwgW3ZvaWQgMF0pO1xuICAgICAgdmFyIGkgPSBHdChhKSxcbiAgICAgICAgcyA9IE90W0dldFNsb3QodGhpcywgRildLmZpZWxkS2V5c1RvSWdub3JlKGkpLFxuICAgICAgICBsID0gZ3QobnVsbCksXG4gICAgICAgIGQgPSBHdChvKTtcbiAgICAgIHZhciBfaXRlcmF0b3IxNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGQpLFxuICAgICAgICBfc3RlcDE2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNi5zKCk7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2UzNSA9IF9zdGVwMTYudmFsdWU7XG4gICAgICAgICAgdmFyIF90NDIgPSB2b2lkIDA7XG4gICAgICAgICAgX3Q0MiA9IENhbGwoVHQsIHMsIFtfZTM1XSkgPyBhW19lMzVdIDogb1tfZTM1XSwgdm9pZCAwICE9PSBfdDQyICYmIChsW19lMzVdID0gX3Q0Mik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNi5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29weURhdGFQcm9wZXJ0aWVzKGwsIGEsIFtdKSwgbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0ZUFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlQWRkKGUsIHQsIHIpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIG4gPSBUb1RlbXBvcmFsRHVyYXRpb24odCksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsT3ZlcmZsb3coR2V0T3B0aW9uc09iamVjdChyKSksXG4gICAgICAgIF9CYWxhbmNlRHVyYXRpb24xMCA9IEJhbGFuY2VEdXJhdGlvbihHZXRTbG90KG4sIHYpLCBHZXRTbG90KG4sIEMpLCBHZXRTbG90KG4sIE8pLCBHZXRTbG90KG4sIGIpLCBHZXRTbG90KG4sIEUpLCBHZXRTbG90KG4sIE0pLCBHZXRTbG90KG4sIFIpLCBcImRheVwiKSxcbiAgICAgICAgaSA9IF9CYWxhbmNlRHVyYXRpb24xMC5kYXlzLFxuICAgICAgICBzID0gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICAgIHJldHVybiBPdFtzXS5kYXRlQWRkKG8sIEdldFNsb3QobiwgdyksIEdldFNsb3QobiwgRCksIEdldFNsb3QobiwgRyksIGksIGEsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRlVW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZVVudGlsKGUsIHQsIHIpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIG4gPSBUb1RlbXBvcmFsRGF0ZSh0KTtcbiAgICAgIHZhciBhID0gR2V0VGVtcG9yYWxVbml0KEdldE9wdGlvbnNPYmplY3QociksIFwibGFyZ2VzdFVuaXRcIiwgXCJkYXRlXCIsIFwiYXV0b1wiKTtcbiAgICAgIFwiYXV0b1wiID09PSBhICYmIChhID0gXCJkYXlcIik7XG4gICAgICB2YXIgX090JEdldFNsb3QkZGF0ZVVudGlsID0gT3RbR2V0U2xvdCh0aGlzLCBGKV0uZGF0ZVVudGlsKG8sIG4sIGEpLFxuICAgICAgICBpID0gX090JEdldFNsb3QkZGF0ZVVudGlsLnllYXJzLFxuICAgICAgICBzID0gX090JEdldFNsb3QkZGF0ZVVudGlsLm1vbnRocyxcbiAgICAgICAgbCA9IF9PdCRHZXRTbG90JGRhdGVVbnRpbC53ZWVrcyxcbiAgICAgICAgZCA9IF9PdCRHZXRTbG90JGRhdGVVbnRpbC5kYXlzO1xuICAgICAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoaSwgcywgbCwgZCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0ueWVhcih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGgoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheSh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVzZSBtb250aENvZGUgb24gUGxhaW5Nb250aERheSBpbnN0ZWFkXCIpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLm1vbnRoKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhDb2RlKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8IElzVGVtcG9yYWxNb250aERheSh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0ubW9udGhDb2RlKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5KGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsTW9udGhEYXkodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLmRheSh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYShlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0uZXJhKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcmFZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYVllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLmVyYVllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlPZldlZWsoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIHJldHVybiBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlPZldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlPZlllYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIHJldHVybiBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlPZlllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndlZWtPZlllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2Vla09mWWVhcihlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLndlZWtPZlllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLnllYXJPZldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5c0luV2VlayhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLmRheXNJbldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlzSW5Nb250aCh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlzSW5ZZWFyKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5tb250aHNJblllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0uaW5MZWFwWWVhcih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEYpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlKSB7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyT2JqZWN0KFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYWxlbmRhcjtcbn0oKTtcbmZ1bmN0aW9uIG1vbnRoQ29kZU51bWJlclBhcnQoZSkge1xuICBpZiAoIWUuc3RhcnRzV2l0aChcIk1cIikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aCBjb2RlOiBcIi5jb25jYXQoZSwgXCIuICBNb250aCBjb2RlcyBtdXN0IHN0YXJ0IHdpdGggTS5cIikpO1xuICB2YXIgdCA9ICtlLnNsaWNlKDEpO1xuICBpZiAoaXNOYU4odCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aCBjb2RlOiBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTW9udGhDb2RlKGUpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICExO1xuICByZXR1cm4gXCJNXCIuY29uY2F0KGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikpLmNvbmNhdCh0ID8gXCJMXCIgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOb25MdW5pc29sYXJNb250aChlLCB0KSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMjtcbiAgdmFyIG8gPSBlLm1vbnRoLFxuICAgIG4gPSBlLm1vbnRoQ29kZTtcbiAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgIGlmICh2b2lkIDAgPT09IG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFaXRoZXIgbW9udGggb3IgbW9udGhDb2RlIGFyZSByZXF1aXJlZFwiKTtcbiAgICBcInJlamVjdFwiID09PSB0ICYmIFJlamVjdFRvUmFuZ2UobywgMSwgciksIFwiY29uc3RyYWluXCIgPT09IHQgJiYgKG8gPSBDb25zdHJhaW5Ub1JhbmdlKG8sIDEsIHIpKSwgbiA9IGJ1aWxkTW9udGhDb2RlKG8pO1xuICB9IGVsc2Uge1xuICAgIHZhciBfZTM2ID0gbW9udGhDb2RlTnVtYmVyUGFydChuKTtcbiAgICBpZiAodm9pZCAwICE9PSBvICYmIG8gIT09IF9lMzYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIFwiLmNvbmNhdChuLCBcIiBhbmQgbW9udGggXCIpLmNvbmNhdChvLCBcIiBtdXN0IG1hdGNoIGlmIGJvdGggYXJlIHByZXNlbnRcIikpO1xuICAgIGlmIChuICE9PSBidWlsZE1vbnRoQ29kZShfZTM2KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoIGNvZGU6IFwiLmNvbmNhdChuKSk7XG4gICAgaWYgKG8gPSBfZTM2LCBvIDwgMSB8fCBvID4gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoQ29kZTogXCIuY29uY2F0KG4pKTtcbiAgfVxuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgIG1vbnRoOiBvLFxuICAgIG1vbnRoQ29kZTogblxuICB9KTtcbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhDYWxlbmRhciwgXCJUZW1wb3JhbC5DYWxlbmRhclwiKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIuZnJvbVwiLCBDYWxlbmRhci5mcm9tKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVBZGRcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVBZGQpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF0ZUZyb21GaWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVGcm9tRmllbGRzKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVVbnRpbFwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF0ZVVudGlsKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheVwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5KSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheU9mV2Vla1wiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZXZWVrKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheU9mWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZZZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJbk1vbnRoXCIsIENhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5Nb250aCksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5XZWVrXCIsIENhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5XZWVrKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXJcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZXJhXCIsIENhbGVuZGFyLnByb3RvdHlwZS5lcmEpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZXJhWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUuZXJhWWVhciksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5maWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmZpZWxkcyksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5pbkxlYXBZZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS5pbkxlYXBZZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1lcmdlRmllbGRzXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tZXJnZUZpZWxkcyksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5tb250aFwiLCBDYWxlbmRhci5wcm90b3R5cGUubW9udGgpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhDb2RlXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aENvZGUpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhEYXlGcm9tRmllbGRzXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aERheUZyb21GaWVsZHMpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhzSW5ZZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aHNJblllYXIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUud2Vla09mWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUud2Vla09mWWVhciksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS55ZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS55ZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHMpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2Vla1wiLCBDYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2VlayksIE90Lmlzbzg2MDEgPSB7XG4gIGRhdGVGcm9tRmllbGRzOiBmdW5jdGlvbiBkYXRlRnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgdmFyIF9SZWd1bGF0ZUlTT0RhdGUyO1xuICAgIHZhciBvID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSwgW1wieWVhclwiLCBcImRheVwiXSk7XG4gICAgdmFyIG4gPSBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gICAgbyA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChvKTtcbiAgICB2YXIgX28zMyA9IG8sXG4gICAgICBhID0gX28zMy55ZWFyLFxuICAgICAgaSA9IF9vMzMubW9udGgsXG4gICAgICBzID0gX28zMy5kYXk7XG4gICAgcmV0dXJuIChfUmVndWxhdGVJU09EYXRlMiA9IFJlZ3VsYXRlSVNPRGF0ZShhLCBpLCBzLCBuKSwgYSA9IF9SZWd1bGF0ZUlTT0RhdGUyLnllYXIsIGkgPSBfUmVndWxhdGVJU09EYXRlMi5tb250aCwgcyA9IF9SZWd1bGF0ZUlTT0RhdGUyLmRheSksIENyZWF0ZVRlbXBvcmFsRGF0ZShhLCBpLCBzLCByKTtcbiAgfSxcbiAgeWVhck1vbnRoRnJvbUZpZWxkczogZnVuY3Rpb24geWVhck1vbnRoRnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgdmFyIF9SZWd1bGF0ZUlTT1llYXJNb250aDtcbiAgICB2YXIgbyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBbXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0sIFtcInllYXJcIl0pO1xuICAgIHZhciBuID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICAgIG8gPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgobyk7XG4gICAgdmFyIF9vMzQgPSBvLFxuICAgICAgYSA9IF9vMzQueWVhcixcbiAgICAgIGkgPSBfbzM0Lm1vbnRoO1xuICAgIHJldHVybiAoX1JlZ3VsYXRlSVNPWWVhck1vbnRoID0gZnVuY3Rpb24gUmVndWxhdGVJU09ZZWFyTW9udGgoZSwgdCwgcikge1xuICAgICAgdmFyIG8gPSBlLFxuICAgICAgICBuID0gdDtcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwicmVqZWN0XCI6XG4gICAgICAgICAgUmVqZWN0SVNPRGF0ZShvLCBuLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbnN0cmFpblwiOlxuICAgICAgICAgIHZhciBfQ29uc3RyYWluSVNPRGF0ZTIgPSBDb25zdHJhaW5JU09EYXRlKG8sIG4pO1xuICAgICAgICAgIG8gPSBfQ29uc3RyYWluSVNPRGF0ZTIueWVhcjtcbiAgICAgICAgICBuID0gX0NvbnN0cmFpbklTT0RhdGUyLm1vbnRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogbyxcbiAgICAgICAgbW9udGg6IG5cbiAgICAgIH07XG4gICAgfShhLCBpLCBuKSwgYSA9IF9SZWd1bGF0ZUlTT1llYXJNb250aC55ZWFyLCBpID0gX1JlZ3VsYXRlSVNPWWVhck1vbnRoLm1vbnRoKSwgQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoYSwgaSwgciwgMSk7XG4gIH0sXG4gIG1vbnRoRGF5RnJvbUZpZWxkczogZnVuY3Rpb24gbW9udGhEYXlGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICB2YXIgX1JlZ3VsYXRlSVNPRGF0ZTM7XG4gICAgdmFyIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdLCBbXCJkYXlcIl0pO1xuICAgIHZhciBuID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICAgIGlmICh2b2lkIDAgIT09IG8ubW9udGggJiYgdm9pZCAwID09PSBvLnllYXIgJiYgdm9pZCAwID09PSBvLm1vbnRoQ29kZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVpdGhlciB5ZWFyIG9yIG1vbnRoQ29kZSByZXF1aXJlZCB3aXRoIG1vbnRoXCIpO1xuICAgIHZhciBhID0gdm9pZCAwID09PSBvLm1vbnRoQ29kZTtcbiAgICBvID0gcmVzb2x2ZU5vbkx1bmlzb2xhck1vbnRoKG8pO1xuICAgIHZhciBfbzM1ID0gbyxcbiAgICAgIGkgPSBfbzM1Lm1vbnRoLFxuICAgICAgcyA9IF9vMzUuZGF5LFxuICAgICAgbCA9IF9vMzUueWVhcjtcbiAgICByZXR1cm4gKF9SZWd1bGF0ZUlTT0RhdGUzID0gUmVndWxhdGVJU09EYXRlKGEgPyBsIDogMTk3MiwgaSwgcywgbiksIGkgPSBfUmVndWxhdGVJU09EYXRlMy5tb250aCwgcyA9IF9SZWd1bGF0ZUlTT0RhdGUzLmRheSksIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkoaSwgcywgciwgMTk3Mik7XG4gIH0sXG4gIGZpZWxkczogZnVuY3Rpb24gZmllbGRzKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgZmllbGRLZXlzVG9JZ25vcmU6IGZ1bmN0aW9uIGZpZWxkS2V5c1RvSWdub3JlKGUpIHtcbiAgICB2YXIgdCA9IG5ldyBEdCgpO1xuICAgIGZvciAodmFyIF9yNTggPSAwOyBfcjU4IDwgZS5sZW5ndGg7IF9yNTgrKykge1xuICAgICAgdmFyIF9vMzYgPSBlW19yNThdO1xuICAgICAgQ2FsbCh2dCwgdCwgW19vMzZdKSwgXCJtb250aFwiID09PSBfbzM2ID8gQ2FsbCh2dCwgdCwgW1wibW9udGhDb2RlXCJdKSA6IFwibW9udGhDb2RlXCIgPT09IF9vMzYgJiYgQ2FsbCh2dCwgdCwgW1wibW9udGhcIl0pO1xuICAgIH1cbiAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KENhbGwoQ3QsIHQsIFtdKSk7XG4gIH0sXG4gIGRhdGVBZGQ6IGZ1bmN0aW9uIGRhdGVBZGQoZSwgdCwgciwgbywgbiwgYSwgZCkge1xuICAgIHZhciBfQWRkSVNPRGF0ZTtcbiAgICB2YXIgbSA9IEdldFNsb3QoZSwgaSksXG4gICAgICBjID0gR2V0U2xvdChlLCBzKSxcbiAgICAgIGggPSBHZXRTbG90KGUsIGwpO1xuICAgIHJldHVybiAoX0FkZElTT0RhdGUgPSBBZGRJU09EYXRlKG0sIGMsIGgsIHQsIHIsIG8sIG4sIGEpLCBtID0gX0FkZElTT0RhdGUueWVhciwgYyA9IF9BZGRJU09EYXRlLm1vbnRoLCBoID0gX0FkZElTT0RhdGUuZGF5KSwgQ3JlYXRlVGVtcG9yYWxEYXRlKG0sIGMsIGgsIGQpO1xuICB9LFxuICBkYXRlVW50aWw6IGZ1bmN0aW9uIGRhdGVVbnRpbChlLCB0LCByKSB7XG4gICAgcmV0dXJuIERpZmZlcmVuY2VJU09EYXRlKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QodCwgaSksIEdldFNsb3QodCwgcyksIEdldFNsb3QodCwgbCksIHIpO1xuICB9LFxuICB5ZWFyOiBmdW5jdGlvbiB5ZWFyKGUpIHtcbiAgICByZXR1cm4gR2V0U2xvdChlLCBpKTtcbiAgfSxcbiAgZXJhOiBmdW5jdGlvbiBlcmEoKSB7fSxcbiAgZXJhWWVhcjogZnVuY3Rpb24gZXJhWWVhcigpIHt9LFxuICBtb250aDogZnVuY3Rpb24gbW9udGgoZSkge1xuICAgIHJldHVybiBHZXRTbG90KGUsIHMpO1xuICB9LFxuICBtb250aENvZGU6IGZ1bmN0aW9uIG1vbnRoQ29kZShlKSB7XG4gICAgcmV0dXJuIGJ1aWxkTW9udGhDb2RlKEdldFNsb3QoZSwgcykpO1xuICB9LFxuICBkYXk6IGZ1bmN0aW9uIGRheShlKSB7XG4gICAgcmV0dXJuIEdldFNsb3QoZSwgbCk7XG4gIH0sXG4gIGRheU9mV2VlazogZnVuY3Rpb24gZGF5T2ZXZWVrKGUpIHtcbiAgICByZXR1cm4gRGF5T2ZXZWVrKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCkpO1xuICB9LFxuICBkYXlPZlllYXI6IGZ1bmN0aW9uIGRheU9mWWVhcihlKSB7XG4gICAgcmV0dXJuIERheU9mWWVhcihHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpKTtcbiAgfSxcbiAgd2Vla09mWWVhcjogZnVuY3Rpb24gd2Vla09mWWVhcihlKSB7XG4gICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSwgR2V0U2xvdChlLCBsKSkud2VlaztcbiAgfSxcbiAgeWVhck9mV2VlazogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSwgR2V0U2xvdChlLCBsKSkueWVhcjtcbiAgfSxcbiAgZGF5c0luV2VlazogZnVuY3Rpb24gZGF5c0luV2VlaygpIHtcbiAgICByZXR1cm4gNztcbiAgfSxcbiAgZGF5c0luTW9udGg6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUpIHtcbiAgICByZXR1cm4gSVNPRGF5c0luTW9udGgoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSk7XG4gIH0sXG4gIGRheXNJblllYXI6IGZ1bmN0aW9uIGRheXNJblllYXIoZSkge1xuICAgIHZhciB0ID0gZTtcbiAgICByZXR1cm4gSGFzU2xvdCh0LCBpKSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgTGVhcFllYXIoR2V0U2xvdCh0LCBpKSkgPyAzNjYgOiAzNjU7XG4gIH0sXG4gIG1vbnRoc0luWWVhcjogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKCkge1xuICAgIHJldHVybiAxMjtcbiAgfSxcbiAgaW5MZWFwWWVhcjogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgdmFyIHQgPSBlO1xuICAgIHJldHVybiBIYXNTbG90KHQsIGkpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBMZWFwWWVhcihHZXRTbG90KHQsIGkpKTtcbiAgfVxufTtcbnZhciBPbmVPYmplY3RDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9uZU9iamVjdENhY2hlKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT25lT2JqZWN0Q2FjaGUpO1xuICAgIGlmICh0aGlzLm1hcCA9IG5ldyBNYXAoKSwgdGhpcy5jYWxscyA9IDAsIHRoaXMuaGl0cyA9IDAsIHRoaXMubWlzc2VzID0gMCwgdGhpcy5ub3cgPSBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlID8gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCksIHZvaWQgMCAhPT0gZSkge1xuICAgICAgdmFyIF90NDMgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvcjE3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZS5tYXAuZW50cmllcygpKSxcbiAgICAgICAgX3N0ZXAxNztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTcucygpOyAhKF9zdGVwMTcgPSBfaXRlcmF0b3IxNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF90aGlzJG1hcDtcbiAgICAgICAgICB2YXIgX3I1OSA9IF9zdGVwMTcudmFsdWU7XG4gICAgICAgICAgaWYgKCsrX3Q0MyA+IE9uZU9iamVjdENhY2hlLk1BWF9DQUNIRV9FTlRSSUVTKSBicmVhaztcbiAgICAgICAgICAoX3RoaXMkbWFwID0gdGhpcy5tYXApLnNldC5hcHBseShfdGhpcyRtYXAsIF90b0NvbnN1bWFibGVBcnJheShfcjU5KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNy5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDbGFzcyhPbmVPYmplY3RDYWNoZSwgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubWFwLmdldChlKTtcbiAgICAgIHJldHVybiB0ICYmICh0aGlzLmhpdHMrKywgdGhpcy5yZXBvcnQoKSksIHRoaXMuY2FsbHMrKywgdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChlLCB0KSB7XG4gICAgICB0aGlzLm1hcC5zZXQoZSwgdCksIHRoaXMubWlzc2VzKyssIHRoaXMucmVwb3J0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBvcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNldE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPYmplY3QoZSkge1xuICAgICAgaWYgKE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQoZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib2JqZWN0IGFscmVhZHkgY2FjaGVkXCIpO1xuICAgICAgT25lT2JqZWN0Q2FjaGUub2JqZWN0TWFwLnNldChlLCB0aGlzKSwgdGhpcy5yZXBvcnQoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRDYWNoZUZvck9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZUZvck9iamVjdChlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQoZSk7XG4gICAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBPbmVPYmplY3RDYWNoZSgpLCBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuc2V0KGUsIHQpKSwgdDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9uZU9iamVjdENhY2hlO1xufSgpO1xuZnVuY3Rpb24gdG9VdGNJc29EYXRlU3RyaW5nKF9yZWY4KSB7XG4gIHZhciBlID0gX3JlZjguaXNvWWVhcixcbiAgICB0ID0gX3JlZjguaXNvTW9udGgsXG4gICAgciA9IF9yZWY4Lmlzb0RheTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KElTT1llYXJTdHJpbmcoZSksIFwiLVwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHQpLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhyKSwgXCJUMDA6MDBaXCIpO1xufVxuZnVuY3Rpb24gc2ltcGxlRGF0ZURpZmYoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHllYXJzOiBlLnllYXIgLSB0LnllYXIsXG4gICAgbW9udGhzOiBlLm1vbnRoIC0gdC5tb250aCxcbiAgICBkYXlzOiBlLmRheSAtIHQuZGF5XG4gIH07XG59XG5PbmVPYmplY3RDYWNoZS5vYmplY3RNYXAgPSBuZXcgV2Vha01hcCgpLCBPbmVPYmplY3RDYWNoZS5NQVhfQ0FDSEVfRU5UUklFUyA9IDFlMztcbnZhciBIZWxwZXJCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGVscGVyQmFzZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVscGVyQmFzZSk7XG4gICAgdGhpcy5lcmFMZW5ndGggPSBcInNob3J0XCIsIHRoaXMuaGFzRXJhID0gITAsIHRoaXMuZXJhc0JlZ2luTWlkWWVhciA9ICExO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhIZWxwZXJCYXNlLCBbe1xuICAgIGtleTogXCJnZXRGb3JtYXR0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5mb3JtYXR0ZXIgJiYgKHRoaXMuZm9ybWF0dGVyID0gbmV3IGZ0KFwiZW4tVVMtdS1jYS1cIi5jb25jYXQodGhpcy5pZCksIHtcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgZXJhOiB0aGlzLmVyYUxlbmd0aCxcbiAgICAgICAgdGltZVpvbmU6IFwiVVRDXCJcbiAgICAgIH0pKSwgdGhpcy5mb3JtYXR0ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzb1RvQ2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzb1RvQ2FsZW5kYXJEYXRlKGUsIHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgciA9IGUueWVhcixcbiAgICAgICAgbyA9IGUubW9udGgsXG4gICAgICAgIG4gPSBlLmRheSxcbiAgICAgICAgYSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBmdW5jOiBcImlzb1RvQ2FsZW5kYXJEYXRlXCIsXG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG4sXG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfSksXG4gICAgICAgIGkgPSB0LmdldChhKTtcbiAgICAgIGlmIChpKSByZXR1cm4gaTtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRGb3JtYXR0ZXIoKTtcbiAgICAgIHZhciBsLCBkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZCA9IHRvVXRjSXNvRGF0ZVN0cmluZyh7XG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG5cbiAgICAgICAgfSksIGwgPSBzLmZvcm1hdFRvUGFydHMobmV3IERhdGUoZCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSVNPIGRhdGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG5cbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0ge307XG4gICAgICB2YXIgX2l0ZXJhdG9yMTggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsKSxcbiAgICAgICAgX3N0ZXAxODtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTgucygpOyAhKF9zdGVwMTggPSBfaXRlcmF0b3IxOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTgkdmFsdWUgPSBfc3RlcDE4LnZhbHVlLFxuICAgICAgICAgICAgX2UzNyA9IF9zdGVwMTgkdmFsdWUudHlwZSxcbiAgICAgICAgICAgIF90NDUgPSBfc3RlcDE4JHZhbHVlLnZhbHVlO1xuICAgICAgICAgIGlmIChcInllYXJcIiA9PT0gX2UzNyAmJiAobS5lcmFZZWFyID0gK190NDUpLCBcInJlbGF0ZWRZZWFyXCIgPT09IF9lMzcgJiYgKG0uZXJhWWVhciA9ICtfdDQ1KSwgXCJtb250aFwiID09PSBfZTM3KSB7XG4gICAgICAgICAgICB2YXIgX2UzOCA9IC9eKFswLTldKikoLio/KSQvLmV4ZWMoX3Q0NSk7XG4gICAgICAgICAgICBpZiAoIV9lMzggfHwgMyAhPSBfZTM4Lmxlbmd0aCB8fCAhX2UzOFsxXSAmJiAhX2UzOFsyXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmV4cGVjdGVkIG1vbnRoOiBcIi5jb25jYXQoX3Q0NSkpO1xuICAgICAgICAgICAgaWYgKG0ubW9udGggPSBfZTM4WzFdID8gK19lMzhbMV0gOiAxLCBtLm1vbnRoIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoIFwiLmNvbmNhdChfdDQ1LCBcIiBmcm9tIFwiKS5jb25jYXQoZCwgXCJbdS1jYS1cIikuY29uY2F0KHRoaXMuaWQsIFwiXSAocHJvYmFibHkgZHVlIHRvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI3KVwiKSk7XG4gICAgICAgICAgICBpZiAobS5tb250aCA+IDEzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbW9udGggXCIuY29uY2F0KF90NDUsIFwiIGZyb20gXCIpLmNvbmNhdChkLCBcIlt1LWNhLVwiKS5jb25jYXQodGhpcy5pZCwgXCJdIChwcm9iYWJseSBkdWUgdG8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTA1MjkpXCIpKTtcbiAgICAgICAgICAgIF9lMzhbMl0gJiYgKG0ubW9udGhFeHRyYSA9IF9lMzhbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcImRheVwiID09PSBfZTM3ICYmIChtLmRheSA9ICtfdDQ1KSwgdGhpcy5oYXNFcmEgJiYgXCJlcmFcIiA9PT0gX2UzNyAmJiBudWxsICE9IF90NDUgJiYgXCJcIiAhPT0gX3Q0NSAmJiAoX3Q0NSA9IF90NDUuc3BsaXQoXCIgKFwiKVswXSwgbS5lcmEgPSBfdDQ1Lm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC8oPzpbXFwwLVxceDFGIS0sXFwuXFwvOi1AXFxbLWBcXHstXFx4QTlcXHhBQi1cXHhCNFxceEI2LVxceEI5XFx4QkItXFx4QkZcXHhEN1xceEY3XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDM2RlxcdTAzNzVcXHUwMzc4XFx1MDM3OVxcdTAzN0VcXHUwMzgwLVxcdTAzODVcXHUwMzg3XFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDNGNlxcdTA0ODItXFx1MDQ4OVxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NUEtXFx1MDU1RlxcdTA1ODktXFx1MDVDRlxcdTA1RUItXFx1MDVFRVxcdTA1RjMtXFx1MDYxRlxcdTA2NEItXFx1MDY2RFxcdTA2NzBcXHUwNkQ0XFx1MDZENi1cXHUwNkU0XFx1MDZFNy1cXHUwNkVEXFx1MDZGMC1cXHUwNkY5XFx1MDZGRFxcdTA2RkVcXHUwNzAwLVxcdTA3MEZcXHUwNzExXFx1MDczMC1cXHUwNzRDXFx1MDdBNi1cXHUwN0IwXFx1MDdCMi1cXHUwN0M5XFx1MDdFQi1cXHUwN0YzXFx1MDdGNi1cXHUwN0Y5XFx1MDdGQi1cXHUwN0ZGXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODNGXFx1MDg1OS1cXHUwODVGXFx1MDg2Qi1cXHUwODZGXFx1MDg4OFxcdTA4OEYtXFx1MDg5RlxcdTA4Q0EtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk3MFxcdTA5ODEtXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkEtXFx1MDlCQ1xcdTA5QkUtXFx1MDlDRFxcdTA5Q0YtXFx1MDlEQlxcdTA5REVcXHUwOUUyLVxcdTA5RUZcXHUwOUYyLVxcdTA5RkJcXHUwOUZELVxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBLVxcdTBBNThcXHUwQTVEXFx1MEE1Ri1cXHUwQTcxXFx1MEE3NS1cXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBLVxcdTBBQkNcXHUwQUJFLVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUUyLVxcdTBBRjhcXHUwQUZBLVxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQS1cXHUwQjNDXFx1MEIzRS1cXHUwQjVCXFx1MEI1RVxcdTBCNjItXFx1MEI3MFxcdTBCNzItXFx1MEI4MlxcdTBCODRcXHUwQjhCLVxcdTBCOERcXHUwQjkxXFx1MEI5Ni1cXHUwQjk4XFx1MEI5QlxcdTBCOURcXHUwQkEwLVxcdTBCQTJcXHUwQkE1LVxcdTBCQTdcXHUwQkFCLVxcdTBCQURcXHUwQkJBLVxcdTBCQ0ZcXHUwQkQxLVxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzNBLVxcdTBDM0NcXHUwQzNFLVxcdTBDNTdcXHUwQzVCXFx1MEM1Q1xcdTBDNUVcXHUwQzVGXFx1MEM2Mi1cXHUwQzdGXFx1MEM4MS1cXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkEtXFx1MENCQ1xcdTBDQkUtXFx1MENEQ1xcdTBDREZcXHUwQ0UyLVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDNcXHUwRDBEXFx1MEQxMVxcdTBEM0JcXHUwRDNDXFx1MEQzRS1cXHUwRDREXFx1MEQ0Ri1cXHUwRDUzXFx1MEQ1Ny1cXHUwRDVFXFx1MEQ2Mi1cXHUwRDc5XFx1MEQ4MC1cXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MEUwMFxcdTBFMzFcXHUwRTM0LVxcdTBFM0ZcXHUwRTQ3LVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFOEJcXHUwRUE0XFx1MEVBNlxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUJFXFx1MEVCRlxcdTBFQzVcXHUwRUM3LVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjAxLVxcdTBGM0ZcXHUwRjQ4XFx1MEY2RC1cXHUwRjg3XFx1MEY4RC1cXHUwRkZGXFx1MTAyQi1cXHUxMDNFXFx1MTA0MC1cXHUxMDRGXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4Ri1cXHUxMDlGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTBGQlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUItXFx1MTM3RlxcdTEzOTAtXFx1MTM5RlxcdTEzRjZcXHUxM0Y3XFx1MTNGRS1cXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjgwXFx1MTY5Qi1cXHUxNjlGXFx1MTZFQi1cXHUxNkYwXFx1MTZGOS1cXHUxNkZGXFx1MTcxMi1cXHUxNzFFXFx1MTczMi1cXHUxNzNGXFx1MTc1Mi1cXHUxNzVGXFx1MTc2RFxcdTE3NzEtXFx1MTc3RlxcdTE3QjQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQlxcdTE3REQtXFx1MTgxRlxcdTE4NzktXFx1MTg3RlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUYtXFx1MTk0RlxcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUZGXFx1MUExNy1cXHUxQTFGXFx1MUE1NS1cXHUxQUE2XFx1MUFBOC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI0RC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkZGXFx1MUMyNC1cXHUxQzRDXFx1MUM1MC1cXHUxQzU5XFx1MUM3RVxcdTFDN0ZcXHUxQzg5LVxcdTFDOEZcXHUxQ0JCXFx1MUNCQ1xcdTFDQzAtXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGNy1cXHUxQ0Y5XFx1MUNGQi1cXHUxQ0ZGXFx1MURDMC1cXHUxREZGXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZCRFxcdTFGQkYtXFx1MUZDMVxcdTFGQzVcXHUxRkNELVxcdTFGQ0ZcXHUxRkQ0XFx1MUZENVxcdTFGREMtXFx1MUZERlxcdTFGRUQtXFx1MUZGMVxcdTFGRjVcXHUxRkZELVxcdTIwNzBcXHUyMDcyLVxcdTIwN0VcXHUyMDgwLVxcdTIwOEZcXHUyMDlELVxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGLVxcdTIxODJcXHUyMTg1LVxcdTJCRkZcXHUyQ0U1LVxcdTJDRUFcXHUyQ0VGLVxcdTJDRjFcXHUyQ0Y0LVxcdTJDRkZcXHUyRDI2XFx1MkQyOC1cXHUyRDJDXFx1MkQyRVxcdTJEMkZcXHUyRDY4LVxcdTJENkVcXHUyRDcwLVxcdTJEN0ZcXHUyRDk3LVxcdTJEOUZcXHUyREE3XFx1MkRBRlxcdTJEQjdcXHUyREJGXFx1MkRDN1xcdTJEQ0ZcXHUyREQ3XFx1MkRERi1cXHUyRTJFXFx1MkUzMC1cXHUzMDA0XFx1MzAwNy1cXHUzMDMwXFx1MzAzNi1cXHUzMDNBXFx1MzAzRC1cXHUzMDQwXFx1MzA5Ny1cXHUzMDlDXFx1MzBBMFxcdTMwRkJcXHUzMTAwLVxcdTMxMDRcXHUzMTMwXFx1MzE4Ri1cXHUzMTlGXFx1MzFDMC1cXHUzMUVGXFx1MzIwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ4RC1cXHVBNENGXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjIwLVxcdUE2MjlcXHVBNjJDLVxcdUE2M0ZcXHVBNjZGLVxcdUE2N0VcXHVBNjlFXFx1QTY5RlxcdUE2RTYtXFx1QTcxNlxcdUE3MjBcXHVBNzIxXFx1QTc4OVxcdUE3OEFcXHVBN0NCLVxcdUE3Q0ZcXHVBN0QyXFx1QTdENFxcdUE3REEtXFx1QTdGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjMtXFx1QTgzRlxcdUE4NzQtXFx1QTg4MVxcdUE4QjQtXFx1QThGMVxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOEZGLVxcdUE5MDlcXHVBOTI2LVxcdUE5MkZcXHVBOTQ3LVxcdUE5NUZcXHVBOTdELVxcdUE5ODNcXHVBOUIzLVxcdUE5Q0VcXHVBOUQwLVxcdUE5REZcXHVBOUU1XFx1QTlGMC1cXHVBOUY5XFx1QTlGRlxcdUFBMjktXFx1QUEzRlxcdUFBNDNcXHVBQTRDLVxcdUFBNUZcXHVBQTc3LVxcdUFBNzlcXHVBQTdCLVxcdUFBN0RcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUMzLVxcdUFBREFcXHVBQURFXFx1QUFERlxcdUFBRUItXFx1QUFGMVxcdUFBRjUtXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNUJcXHVBQjZBLVxcdUFCNkZcXHVBQkUzLVxcdUFCRkZcXHVEN0E0LVxcdUQ3QUZcXHVEN0M3LVxcdUQ3Q0FcXHVEN0ZDLVxcdUQ3RkZcXHVFMDAwLVxcdUY4RkZcXHVGQTZFXFx1RkE2RlxcdUZBREEtXFx1RkFGRlxcdUZCMDctXFx1RkIxMlxcdUZCMTgtXFx1RkIxQ1xcdUZCMUVcXHVGQjI5XFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkIyLVxcdUZCRDJcXHVGRDNFLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZELVxcdUZGMjBcXHVGRjNCLVxcdUZGNDBcXHVGRjVCLVxcdUZGNjVcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGRkZdfFxcdUQ4MDBbXFx1REMwQ1xcdURDMjdcXHVEQzNCXFx1REMzRVxcdURDNEVcXHVEQzRGXFx1REM1RS1cXHVEQzdGXFx1RENGQi1cXHVERTdGXFx1REU5RC1cXHVERTlGXFx1REVEMS1cXHVERUZGXFx1REYyMC1cXHVERjJDXFx1REY0MVxcdURGNEEtXFx1REY0RlxcdURGNzYtXFx1REY3RlxcdURGOUVcXHVERjlGXFx1REZDNC1cXHVERkM3XFx1REZEMC1cXHVERkZGXXxcXHVEODAxW1xcdURDOUUtXFx1RENBRlxcdURDRDQtXFx1RENEN1xcdURDRkMtXFx1RENGRlxcdUREMjgtXFx1REQyRlxcdURENjQtXFx1REQ2RlxcdUREN0JcXHVERDhCXFx1REQ5M1xcdUREOTZcXHVEREEyXFx1RERCMlxcdUREQkFcXHVEREJELVxcdURERkZcXHVERjM3LVxcdURGM0ZcXHVERjU2LVxcdURGNUZcXHVERjY4LVxcdURGN0ZcXHVERjg2XFx1REZCMVxcdURGQkItXFx1REZGRl18XFx1RDgwMltcXHVEQzA2XFx1REMwN1xcdURDMDlcXHVEQzM2XFx1REMzOS1cXHVEQzNCXFx1REMzRFxcdURDM0VcXHVEQzU2LVxcdURDNUZcXHVEQzc3LVxcdURDN0ZcXHVEQzlGLVxcdURDREZcXHVEQ0YzXFx1RENGNi1cXHVEQ0ZGXFx1REQxNi1cXHVERDFGXFx1REQzQS1cXHVERDdGXFx1RERCOC1cXHVEREJEXFx1RERDMC1cXHVEREZGXFx1REUwMS1cXHVERTBGXFx1REUxNFxcdURFMThcXHVERTM2LVxcdURFNUZcXHVERTdELVxcdURFN0ZcXHVERTlELVxcdURFQkZcXHVERUM4XFx1REVFNS1cXHVERUZGXFx1REYzNi1cXHVERjNGXFx1REY1Ni1cXHVERjVGXFx1REY3My1cXHVERjdGXFx1REY5Mi1cXHVERkZGXXxcXHVEODAzW1xcdURDNDktXFx1REM3RlxcdURDQjMtXFx1RENCRlxcdURDRjMtXFx1RENGRlxcdUREMjQtXFx1REU3RlxcdURFQUEtXFx1REVBRlxcdURFQjItXFx1REVGRlxcdURGMUQtXFx1REYyNlxcdURGMjgtXFx1REYyRlxcdURGNDYtXFx1REY2RlxcdURGODItXFx1REZBRlxcdURGQzUtXFx1REZERlxcdURGRjctXFx1REZGRl18XFx1RDgwNFtcXHVEQzAwLVxcdURDMDJcXHVEQzM4LVxcdURDNzBcXHVEQzczXFx1REM3NFxcdURDNzYtXFx1REM4MlxcdURDQjAtXFx1RENDRlxcdURDRTktXFx1REQwMlxcdUREMjctXFx1REQ0M1xcdURENDVcXHVERDQ2XFx1REQ0OC1cXHVERDRGXFx1REQ3My1cXHVERDc1XFx1REQ3Ny1cXHVERDgyXFx1RERCMy1cXHVEREMwXFx1RERDNS1cXHVEREQ5XFx1REREQlxcdUREREQtXFx1RERGRlxcdURFMTJcXHVERTJDLVxcdURFM0VcXHVERTQxLVxcdURFN0ZcXHVERTg3XFx1REU4OVxcdURFOEVcXHVERTlFXFx1REVBOS1cXHVERUFGXFx1REVERi1cXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0EtXFx1REYzQ1xcdURGM0UtXFx1REY0RlxcdURGNTEtXFx1REY1Q1xcdURGNjItXFx1REZGRl18XFx1RDgwNVtcXHVEQzM1LVxcdURDNDZcXHVEQzRCLVxcdURDNUVcXHVEQzYyLVxcdURDN0ZcXHVEQ0IwLVxcdURDQzNcXHVEQ0M2XFx1RENDOC1cXHVERDdGXFx1RERBRi1cXHVEREQ3XFx1REREQy1cXHVEREZGXFx1REUzMC1cXHVERTQzXFx1REU0NS1cXHVERTdGXFx1REVBQi1cXHVERUI3XFx1REVCOS1cXHVERUZGXFx1REYxQi1cXHVERjNGXFx1REY0Ny1cXHVERkZGXXxcXHVEODA2W1xcdURDMkMtXFx1REM5RlxcdURDRTAtXFx1RENGRVxcdUREMDdcXHVERDA4XFx1REQwQVxcdUREMEJcXHVERDE0XFx1REQxN1xcdUREMzAtXFx1REQzRVxcdURENDBcXHVERDQyLVxcdUREOUZcXHVEREE4XFx1RERBOVxcdURERDEtXFx1RERFMFxcdURERTJcXHVEREU0LVxcdURERkZcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzlcXHVERTNCLVxcdURFNEZcXHVERTUxLVxcdURFNUJcXHVERThBLVxcdURFOUNcXHVERTlFLVxcdURFQUZcXHVERUY5LVxcdURGRkZdfFxcdUQ4MDdbXFx1REMwOVxcdURDMkYtXFx1REMzRlxcdURDNDEtXFx1REM3MVxcdURDOTAtXFx1RENGRlxcdUREMDdcXHVERDBBXFx1REQzMS1cXHVERDQ1XFx1REQ0Ny1cXHVERDVGXFx1REQ2NlxcdURENjlcXHVERDhBLVxcdUREOTdcXHVERDk5LVxcdURFREZcXHVERUYzLVxcdURGMDFcXHVERjAzXFx1REYxMVxcdURGMzQtXFx1REZBRlxcdURGQjEtXFx1REZGRl18XFx1RDgwOFtcXHVERjlBLVxcdURGRkZdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzdGXFx1REQ0NC1cXHVERkZGXXxbXFx1RDgwQVxcdUQ4MEUtXFx1RDgxMFxcdUQ4MTItXFx1RDgxOVxcdUQ4MjQtXFx1RDgyQVxcdUQ4MkRcXHVEODJFXFx1RDgzMC1cXHVEODM0XFx1RDgzNlxcdUQ4M0MtXFx1RDgzRlxcdUQ4N0NcXHVEODdEXFx1RDg3RlxcdUQ4ODktXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBCW1xcdURDMDAtXFx1REY4RlxcdURGRjEtXFx1REZGRl18XFx1RDgwRFtcXHVEQzMwLVxcdURDNDBcXHVEQzQ3LVxcdURGRkZdfFxcdUQ4MTFbXFx1REU0Ny1cXHVERkZGXXxcXHVEODFBW1xcdURFMzktXFx1REUzRlxcdURFNUYtXFx1REU2RlxcdURFQkYtXFx1REVDRlxcdURFRUUtXFx1REVGRlxcdURGMzAtXFx1REYzRlxcdURGNDQtXFx1REY2MlxcdURGNzgtXFx1REY3Q1xcdURGOTAtXFx1REZGRl18XFx1RDgxQltcXHVEQzAwLVxcdURFM0ZcXHVERTgwLVxcdURFRkZcXHVERjRCLVxcdURGNEZcXHVERjUxLVxcdURGOTJcXHVERkEwLVxcdURGREZcXHVERkUyXFx1REZFNC1cXHVERkZGXXxcXHVEODIxW1xcdURGRjgtXFx1REZGRl18XFx1RDgyM1tcXHVEQ0Q2LVxcdURDRkZcXHVERDA5LVxcdURGRkZdfFxcdUQ4MkJbXFx1REMwMC1cXHVERkVGXFx1REZGNFxcdURGRkNcXHVERkZGXXxcXHVEODJDW1xcdUREMjMtXFx1REQzMVxcdUREMzMtXFx1REQ0RlxcdURENTNcXHVERDU0XFx1REQ1Ni1cXHVERDYzXFx1REQ2OC1cXHVERDZGXFx1REVGQy1cXHVERkZGXXxcXHVEODJGW1xcdURDNkItXFx1REM2RlxcdURDN0QtXFx1REM3RlxcdURDODktXFx1REM4RlxcdURDOUEtXFx1REZGRl18XFx1RDgzNVtcXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNcXHVERkNDLVxcdURGRkZdfFxcdUQ4MzdbXFx1REMwMC1cXHVERUZGXFx1REYxRi1cXHVERjI0XFx1REYyQi1cXHVERkZGXXxcXHVEODM4W1xcdURDMDAtXFx1REMyRlxcdURDNkUtXFx1RENGRlxcdUREMkQtXFx1REQzNlxcdUREM0UtXFx1REQ0RFxcdURENEYtXFx1REU4RlxcdURFQUUtXFx1REVCRlxcdURFRUMtXFx1REZGRl18XFx1RDgzOVtcXHVEQzAwLVxcdURDQ0ZcXHVEQ0VDLVxcdURGREZcXHVERkU3XFx1REZFQ1xcdURGRUZcXHVERkZGXXxcXHVEODNBW1xcdURDQzUtXFx1RENGRlxcdURENDQtXFx1REQ0QVxcdURENEMtXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURERkZcXHVERTA0XFx1REUyMFxcdURFMjNcXHVERTI1XFx1REUyNlxcdURFMjhcXHVERTMzXFx1REUzOFxcdURFM0FcXHVERTNDLVxcdURFNDFcXHVERTQzLVxcdURFNDZcXHVERTQ4XFx1REU0QVxcdURFNENcXHVERTUwXFx1REU1M1xcdURFNTVcXHVERTU2XFx1REU1OFxcdURFNUFcXHVERTVDXFx1REU1RVxcdURFNjBcXHVERTYzXFx1REU2NVxcdURFNjZcXHVERTZCXFx1REU3M1xcdURFNzhcXHVERTdEXFx1REU3RlxcdURFOEFcXHVERTlDLVxcdURFQTBcXHVERUE0XFx1REVBQVxcdURFQkMtXFx1REZGRl18XFx1RDg2OVtcXHVERUUwLVxcdURFRkZdfFxcdUQ4NkRbXFx1REYzQS1cXHVERjNGXXxcXHVEODZFW1xcdURDMUVcXHVEQzFGXXxcXHVEODczW1xcdURFQTItXFx1REVBRl18XFx1RDg3QVtcXHVERkUxLVxcdURGRUZdfFxcdUQ4N0JbXFx1REU1RS1cXHVERkZGXXxcXHVEODdFW1xcdURFMUUtXFx1REZGRl18XFx1RDg4NFtcXHVERjRCLVxcdURGNEZdfFxcdUQ4ODhbXFx1REZCMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZywgXCJcIikucmVwbGFjZShcIiBcIiwgXCItXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZvaWQgMCA9PT0gbS5lcmFZZWFyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBsYWNrcyByZWxhdGVkWWVhciBpbiBcIi5jb25jYXQodGhpcy5pZCwgXCIgY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuXCIpKTtcbiAgICAgIGlmICh0aGlzLnJldmlzZUludGxFcmEpIHtcbiAgICAgICAgdmFyIF90aGlzJHJldmlzZUludGxFcmEgPSB0aGlzLnJldmlzZUludGxFcmEobSwgZSksXG4gICAgICAgICAgX3Q0NCA9IF90aGlzJHJldmlzZUludGxFcmEuZXJhLFxuICAgICAgICAgIF9yNjAgPSBfdGhpcyRyZXZpc2VJbnRsRXJhLmVyYVllYXI7XG4gICAgICAgIG0uZXJhID0gX3Q0NCwgbS5lcmFZZWFyID0gX3I2MDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tJY3VCdWdzICYmIHRoaXMuY2hlY2tJY3VCdWdzKGUpO1xuICAgICAgdmFyIGMgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShtLCB0LCBcImNvbnN0cmFpblwiLCAhMCk7XG4gICAgICBpZiAodm9pZCAwID09PSBjLnllYXIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWlzc2luZyB5ZWFyIGNvbnZlcnRpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpKSk7XG4gICAgICBpZiAodm9pZCAwID09PSBjLm1vbnRoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1pc3NpbmcgbW9udGggY29udmVydGluZyBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZSkpKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGMuZGF5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1pc3NpbmcgZGF5IGNvbnZlcnRpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpKSk7XG4gICAgICByZXR1cm4gdC5zZXQoYSwgYyksIFtcImNvbnN0cmFpblwiLCBcInJlamVjdFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBvID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGZ1bmM6IFwiY2FsZW5kYXJUb0lzb0RhdGVcIixcbiAgICAgICAgICB5ZWFyOiBjLnllYXIsXG4gICAgICAgICAgbW9udGg6IGMubW9udGgsXG4gICAgICAgICAgZGF5OiBjLmRheSxcbiAgICAgICAgICBvdmVyZmxvdzogcixcbiAgICAgICAgICBpZDogX3RoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHQuc2V0KG8sIGUpO1xuICAgICAgfSksIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlQ2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpIHtcbiAgICAgIHZhciB0ID0gZS5lcmEsXG4gICAgICAgIHIgPSBlLm1vbnRoLFxuICAgICAgICBvID0gZS55ZWFyLFxuICAgICAgICBuID0gZS5kYXksXG4gICAgICAgIGEgPSBlLmVyYVllYXIsXG4gICAgICAgIGkgPSBlLm1vbnRoQ29kZSxcbiAgICAgICAgcyA9IGUubW9udGhFeHRyYTtcbiAgICAgIGlmICh2b2lkIDAgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBgbW9udGhFeHRyYWAgdmFsdWVcIik7XG4gICAgICBpZiAodm9pZCAwID09PSBvICYmIHZvaWQgMCA9PT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInllYXIgb3IgZXJhWWVhciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHIgJiYgdm9pZCAwID09PSBpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9udGggb3IgbW9udGhDb2RlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNaXNzaW5nIGRheVwiKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGkpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIF90eXBlb2YoaSkpO1xuICAgICAgICBpZiAoIS9eTShbMDFdP1xcZCkoTD8pJC8udGVzdChpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoQ29kZTogXCIuY29uY2F0KGkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0YW50RXJhKSB7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IHQgJiYgdCAhPT0gdGhpcy5jb25zdGFudEVyYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJlcmEgbXVzdCBiZSBcIi5jb25jYXQodGhpcy5jb25zdGFudEVyYSwgXCIsIG5vdCBcIikuY29uY2F0KHQpKTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSAmJiB2b2lkIDAgIT09IG8gJiYgYSAhPT0gbykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJlcmFZZWFyIFwiLmNvbmNhdChhLCBcIiBkb2VzIG5vdCBtYXRjaCB5ZWFyIFwiKS5jb25jYXQobykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzRXJhICYmIHZvaWQgMCA9PT0gZS5lcmEgIT0gKHZvaWQgMCA9PT0gZS5lcmFZZWFyKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0aWVzICdlcmEnIGFuZCAnZXJhWWVhcicgbXVzdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0Q2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENhbGVuZGFyRGF0ZShlLCB0KSB7XG4gICAgICB2YXIgX3Jlc29sdmVOb25MdW5pc29sYXJNO1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICBpZiAoXCJsdW5pc29sYXJcIiA9PT0gdGhpcy5jYWxlbmRhclR5cGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT3ZlcnJpZGUgcmVxdWlyZWQgZm9yIGx1bmlzb2xhciBjYWxlbmRhcnNcIik7XG4gICAgICB2YXIgbiA9IGU7XG4gICAgICBpZiAodGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShuKSwgdGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICB2YXIgX24yMSA9IG4sXG4gICAgICAgICAgX2UzOSA9IF9uMjEueWVhcixcbiAgICAgICAgICBfdDQ2ID0gX24yMS5lcmFZZWFyO1xuICAgICAgICBuID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG4pLCB7fSwge1xuICAgICAgICAgIGVyYTogdGhpcy5jb25zdGFudEVyYSxcbiAgICAgICAgICB5ZWFyOiB2b2lkIDAgIT09IF9lMzkgPyBfZTM5IDogX3Q0NixcbiAgICAgICAgICBlcmFZZWFyOiB2b2lkIDAgIT09IF90NDYgPyBfdDQ2IDogX2UzOVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gdGhpcy5tb250aHNJblllYXIobiwgdCk7XG4gICAgICB2YXIgX24yMiA9IG4sXG4gICAgICAgIGkgPSBfbjIyLm1vbnRoLFxuICAgICAgICBzID0gX24yMi5tb250aENvZGU7XG4gICAgICByZXR1cm4gKF9yZXNvbHZlTm9uTHVuaXNvbGFyTSA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChuLCByLCBhKSwgaSA9IF9yZXNvbHZlTm9uTHVuaXNvbGFyTS5tb250aCwgcyA9IF9yZXNvbHZlTm9uTHVuaXNvbGFyTS5tb250aENvZGUpLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbiksIHt9LCB7XG4gICAgICAgIG1vbnRoOiBpLFxuICAgICAgICBtb250aENvZGU6IHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWd1bGF0ZU1vbnRoRGF5TmFpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVndWxhdGVNb250aERheU5haXZlKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gdGhpcy5tb250aHNJblllYXIoZSwgcik7XG4gICAgICB2YXIgbiA9IGUubW9udGgsXG4gICAgICAgIGEgPSBlLmRheTtcbiAgICAgIHJldHVybiBcInJlamVjdFwiID09PSB0ID8gKFJlamVjdFRvUmFuZ2UobiwgMSwgbyksIFJlamVjdFRvUmFuZ2UoYSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoZSkpKSA6IChuID0gQ29uc3RyYWluVG9SYW5nZShuLCAxLCBvKSwgYSA9IENvbnN0cmFpblRvUmFuZ2UoYSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICBtb250aDogblxuICAgICAgfSkpKSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBlKSwge30sIHtcbiAgICAgICAgbW9udGg6IG4sXG4gICAgICAgIGRheTogYVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGVuZGFyVG9Jc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGVuZGFyVG9Jc29EYXRlKGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG8gPSBlO1xuICAgICAgdmFyIG4gPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShlLCByLCB0LCAhMSk7XG4gICAgICBuID0gdGhpcy5yZWd1bGF0ZU1vbnRoRGF5TmFpdmUobiwgdCwgcik7XG4gICAgICB2YXIgX24yMyA9IG4sXG4gICAgICAgIGEgPSBfbjIzLnllYXIsXG4gICAgICAgIGkgPSBfbjIzLm1vbnRoLFxuICAgICAgICBzID0gX24yMy5kYXksXG4gICAgICAgIGwgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZnVuYzogXCJjYWxlbmRhclRvSXNvRGF0ZVwiLFxuICAgICAgICAgIHllYXI6IGEsXG4gICAgICAgICAgbW9udGg6IGksXG4gICAgICAgICAgZGF5OiBzLFxuICAgICAgICAgIG92ZXJmbG93OiB0LFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgdmFyIGQsXG4gICAgICAgIG0gPSByLmdldChsKTtcbiAgICAgIGlmIChtKSByZXR1cm4gbTtcbiAgICAgIGlmICh2b2lkIDAgIT09IG8ueWVhciAmJiB2b2lkIDAgIT09IG8ubW9udGggJiYgdm9pZCAwICE9PSBvLmRheSAmJiAoby55ZWFyICE9PSBuLnllYXIgfHwgby5tb250aCAhPT0gbi5tb250aCB8fCBvLmRheSAhPT0gbi5kYXkpICYmIChkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBmdW5jOiBcImNhbGVuZGFyVG9Jc29EYXRlXCIsXG4gICAgICAgIHllYXI6IG8ueWVhcixcbiAgICAgICAgbW9udGg6IG8ubW9udGgsXG4gICAgICAgIGRheTogby5kYXksXG4gICAgICAgIG92ZXJmbG93OiB0LFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSksIG0gPSByLmdldChkKSwgbSkpIHJldHVybiBtO1xuICAgICAgdmFyIGMgPSB0aGlzLmVzdGltYXRlSXNvRGF0ZSh7XG4gICAgICAgIHllYXI6IGEsXG4gICAgICAgIG1vbnRoOiBpLFxuICAgICAgICBkYXk6IHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChlKSB7XG4gICAgICAgIHZhciBvID0gX3RoaXMyLmFkZERheXNJc28oYywgZSk7XG4gICAgICAgIGlmIChuLmRheSA+IF90aGlzMi5taW5pbXVtTW9udGhMZW5ndGgobikpIHtcbiAgICAgICAgICB2YXIgX2U0MCA9IF90aGlzMi5pc29Ub0NhbGVuZGFyRGF0ZShvLCByKTtcbiAgICAgICAgICBmb3IgKDsgX2U0MC5tb250aCAhPT0gaSB8fCBfZTQwLnllYXIgIT09IGE7KSB7XG4gICAgICAgICAgICBpZiAoXCJyZWplY3RcIiA9PT0gdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJkYXkgXCIuY29uY2F0KHMsIFwiIGRvZXMgbm90IGV4aXN0IGluIG1vbnRoIFwiKS5jb25jYXQoaSwgXCIgb2YgeWVhciBcIikuY29uY2F0KGEpKTtcbiAgICAgICAgICAgIG8gPSBfdGhpczIuYWRkRGF5c0lzbyhvLCAtMSksIF9lNDAgPSBfdGhpczIuaXNvVG9DYWxlbmRhckRhdGUobywgcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcbiAgICAgIHZhciBoID0gMCxcbiAgICAgICAgdSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoYywgciksXG4gICAgICAgIFQgPSBzaW1wbGVEYXRlRGlmZihuLCB1KTtcbiAgICAgIGlmICgwICE9PSBULnllYXJzIHx8IDAgIT09IFQubW9udGhzIHx8IDAgIT09IFQuZGF5cykge1xuICAgICAgICB2YXIgX2U0MSA9IDM2NSAqIFQueWVhcnMgKyAzMCAqIFQubW9udGhzICsgVC5kYXlzO1xuICAgICAgICBjID0gdGhpcy5hZGREYXlzSXNvKGMsIF9lNDEpLCB1ID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShjLCByKSwgVCA9IHNpbXBsZURhdGVEaWZmKG4sIHUpLCAwID09PSBULnllYXJzICYmIDAgPT09IFQubW9udGhzID8gYyA9IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChULmRheXMpIDogaCA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMobiwgdSk7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IDg7XG4gICAgICBmb3IgKDsgaDspIHtcbiAgICAgICAgYyA9IHRoaXMuYWRkRGF5c0lzbyhjLCBoICogcCk7XG4gICAgICAgIHZhciBfZTQyID0gdTtcbiAgICAgICAgdSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoYywgcik7XG4gICAgICAgIHZhciBfYTE3ID0gaDtcbiAgICAgICAgaWYgKGggPSB0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKG4sIHUpLCBoKSBpZiAoVCA9IHNpbXBsZURhdGVEaWZmKG4sIHUpLCAwID09PSBULnllYXJzICYmIDAgPT09IFQubW9udGhzKSBjID0gY2FsY3VsYXRlU2FtZU1vbnRoUmVzdWx0KFQuZGF5cyksIGggPSAwO2Vsc2UgaWYgKF9hMTcgJiYgaCAhPT0gX2ExNykgaWYgKHAgPiAxKSBwIC89IDI7ZWxzZSB7XG4gICAgICAgICAgaWYgKFwicmVqZWN0XCIgPT09IHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgZmluZCBJU08gZGF0ZSBmcm9tIGNhbGVuZGFyIGRhdGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShfb2JqZWN0U3ByZWFkMih7fSwgbykpKSk7XG4gICAgICAgICAgdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyh1LCBfZTQyKSA+IDAgJiYgKGMgPSB0aGlzLmFkZERheXNJc28oYywgLTEpKSwgaCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLnNldChsLCBjKSwgZCAmJiByLnNldChkLCBjKSwgdm9pZCAwID09PSBuLnllYXIgfHwgdm9pZCAwID09PSBuLm1vbnRoIHx8IHZvaWQgMCA9PT0gbi5kYXkgfHwgdm9pZCAwID09PSBuLm1vbnRoQ29kZSB8fCB0aGlzLmhhc0VyYSAmJiAodm9pZCAwID09PSBuLmVyYSB8fCB2b2lkIDAgPT09IG4uZXJhWWVhcikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBtaXNzaW5nIHByb3BlcnR5XCIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRlbXBvcmFsVG9DYWxlbmRhckRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCB0KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeWVhcjogR2V0U2xvdChlLCBpKSxcbiAgICAgICAgbW9udGg6IEdldFNsb3QoZSwgcyksXG4gICAgICAgIGRheTogR2V0U2xvdChlLCBsKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlQ2FsZW5kYXJEYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlQ2FsZW5kYXJEYXRlcyhlLCB0KSB7XG4gICAgICB2YXIgciA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcInllYXJcIl0sIFtcImRheVwiLCBcIm1vbnRoXCIsIFwieWVhclwiXSksXG4gICAgICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJ5ZWFyXCJdLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcInllYXJcIl0pO1xuICAgICAgcmV0dXJuIHIueWVhciAhPT0gby55ZWFyID8gQ29tcGFyaXNvblJlc3VsdChyLnllYXIgLSBvLnllYXIpIDogci5tb250aCAhPT0gby5tb250aCA/IENvbXBhcmlzb25SZXN1bHQoci5tb250aCAtIG8ubW9udGgpIDogci5kYXkgIT09IG8uZGF5ID8gQ29tcGFyaXNvblJlc3VsdChyLmRheSAtIG8uZGF5KSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ3VsYXRlRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWd1bGF0ZURhdGUoZSkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG8gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGUsIHQsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUobywgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERheXNJc29cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGF5c0lzbyhlLCB0KSB7XG4gICAgICByZXR1cm4gQWRkSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCAwLCAwLCAwLCB0LCBcImNvbnN0cmFpblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRGF5c0NhbGVuZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERheXNDYWxlbmRhcihlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoZSwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgIG4gPSB0aGlzLmFkZERheXNJc28obywgdCk7XG4gICAgICByZXR1cm4gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShuLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTW9udGhzQ2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTW9udGhzQ2FsZW5kYXIoZSwgdCwgciwgbykge1xuICAgICAgdmFyIG4gPSBlO1xuICAgICAgdmFyIF9uMjQgPSBuLFxuICAgICAgICBhID0gX24yNC5kYXk7XG4gICAgICBmb3IgKHZhciBfZTQzID0gMCwgX3I2MSA9IEl0KHQpOyBfZTQzIDwgX3I2MTsgX2U0MysrKSB7XG4gICAgICAgIHZhciBfbjI1ID0gbixcbiAgICAgICAgICBfZTQ0ID0gX24yNS5tb250aCxcbiAgICAgICAgICBfcjYyID0gbixcbiAgICAgICAgICBfaTE4ID0gdCA8IDAgPyAtTWF0aC5tYXgoYSwgdGhpcy5kYXlzSW5QcmV2aW91c01vbnRoKG4sIG8pKSA6IHRoaXMuZGF5c0luTW9udGgobiwgbyksXG4gICAgICAgICAgX3M3ID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShuLCBcImNvbnN0cmFpblwiLCBvKTtcbiAgICAgICAgdmFyIF9sNyA9IHRoaXMuYWRkRGF5c0lzbyhfczcsIF9pMTgpO1xuICAgICAgICBpZiAobiA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoX2w3LCBvKSwgdCA+IDApIHtcbiAgICAgICAgICB2YXIgX3Q0NyA9IHRoaXMubW9udGhzSW5ZZWFyKF9yNjIsIG8pO1xuICAgICAgICAgIGZvciAoOyBuLm1vbnRoIC0gMSAhPSBfZTQ0ICUgX3Q0NzspIF9sNyA9IHRoaXMuYWRkRGF5c0lzbyhfbDcsIC0xKSwgbiA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoX2w3LCBvKTtcbiAgICAgICAgfVxuICAgICAgICBuLmRheSAhPT0gYSAmJiAobiA9IHRoaXMucmVndWxhdGVEYXRlKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuKSwge30sIHtcbiAgICAgICAgICBkYXk6IGFcbiAgICAgICAgfSksIFwiY29uc3RyYWluXCIsIG8pKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInJlamVjdFwiID09PSByICYmIG4uZGF5ICE9PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRheSBcIi5jb25jYXQoYSwgXCIgZG9lcyBub3QgZXhpc3QgaW4gcmVzdWx0aW5nIGNhbGVuZGFyIG1vbnRoXCIpKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDYWxlbmRhcihlLCBfcmVmOSwgYSwgaSkge1xuICAgICAgdmFyIF9yZWY5JHllYXJzID0gX3JlZjkueWVhcnMsXG4gICAgICAgIHQgPSBfcmVmOSR5ZWFycyA9PT0gdm9pZCAwID8gMCA6IF9yZWY5JHllYXJzLFxuICAgICAgICBfcmVmOSRtb250aHMgPSBfcmVmOS5tb250aHMsXG4gICAgICAgIHIgPSBfcmVmOSRtb250aHMgPT09IHZvaWQgMCA/IDAgOiBfcmVmOSRtb250aHMsXG4gICAgICAgIF9yZWY5JHdlZWtzID0gX3JlZjkud2Vla3MsXG4gICAgICAgIG8gPSBfcmVmOSR3ZWVrcyA9PT0gdm9pZCAwID8gMCA6IF9yZWY5JHdlZWtzLFxuICAgICAgICBfcmVmOSRkYXlzID0gX3JlZjkuZGF5cyxcbiAgICAgICAgbiA9IF9yZWY5JGRheXMgPT09IHZvaWQgMCA/IDAgOiBfcmVmOSRkYXlzO1xuICAgICAgdmFyIHMgPSBlLnllYXIsXG4gICAgICAgIGwgPSBlLmRheSxcbiAgICAgICAgZCA9IGUubW9udGhDb2RlLFxuICAgICAgICBtID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoe1xuICAgICAgICAgIHllYXI6IHMgKyB0LFxuICAgICAgICAgIG1vbnRoQ29kZTogZCxcbiAgICAgICAgICBkYXk6IGxcbiAgICAgICAgfSwgaSksXG4gICAgICAgIGMgPSB0aGlzLmFkZE1vbnRoc0NhbGVuZGFyKG0sIHIsIGEsIGkpLFxuICAgICAgICBoID0gbiArIDcgKiBvO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRGF5c0NhbGVuZGFyKGMsIGgsIGkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnRpbENhbGVuZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVudGlsQ2FsZW5kYXIoZSwgdCwgciwgbykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICBhID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHMgPSAwO1xuICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICBuID0gdGhpcy5jYWxlbmRhckRheXNVbnRpbChlLCB0LCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3I2MyA9IHRoaXMuY2FsZW5kYXJEYXlzVW50aWwoZSwgdCwgbyk7XG4gICAgICAgICAgICBuID0gX3I2MyAlIDcsIGEgPSAoX3I2MyAtIG4pIC8gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9hMTggPSB0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKHQsIGUpO1xuICAgICAgICAgICAgaWYgKCFfYTE4KSByZXR1cm4ge1xuICAgICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICAgICAgZGF5czogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfbDggPSB0LnllYXIgLSBlLnllYXIsXG4gICAgICAgICAgICAgIF9kMTAgPSB0LmRheSAtIGUuZGF5O1xuICAgICAgICAgICAgaWYgKFwieWVhclwiID09PSByICYmIF9sOCkge1xuICAgICAgICAgICAgICB2YXIgX3I2NCA9IDA7XG4gICAgICAgICAgICAgIHQubW9udGhDb2RlID4gZS5tb250aENvZGUgJiYgKF9yNjQgPSAxKSwgdC5tb250aENvZGUgPCBlLm1vbnRoQ29kZSAmJiAoX3I2NCA9IC0xKSwgX3I2NCB8fCAoX3I2NCA9IE1hdGguc2lnbihfZDEwKSk7XG4gICAgICAgICAgICAgIHMgPSBfcjY0ICogX2ExOCA8IDAgPyBfbDggLSBfYTE4IDogX2w4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9tOSxcbiAgICAgICAgICAgICAgX2M1ID0gcyA/IHRoaXMuYWRkQ2FsZW5kYXIoZSwge1xuICAgICAgICAgICAgICAgIHllYXJzOiBzXG4gICAgICAgICAgICAgIH0sIFwiY29uc3RyYWluXCIsIG8pIDogZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaSArPSBfYTE4LCBfbTkgPSBfYzUsIF9jNSA9IHRoaXMuYWRkTW9udGhzQ2FsZW5kYXIoX205LCBfYTE4LCBcImNvbnN0cmFpblwiLCBvKSwgX2M1LmRheSAhPT0gZS5kYXkgJiYgKF9jNSA9IHRoaXMucmVndWxhdGVEYXRlKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfYzUpLCB7fSwge1xuICAgICAgICAgICAgICAgIGRheTogZS5kYXlcbiAgICAgICAgICAgICAgfSksIFwiY29uc3RyYWluXCIsIG8pKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXModCwgX2M1KSAqIF9hMTggPj0gMCk7XG4gICAgICAgICAgICBpIC09IF9hMTg7XG4gICAgICAgICAgICBuID0gdGhpcy5jYWxlbmRhckRheXNVbnRpbChfbTksIHQsIG8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IHMsXG4gICAgICAgIG1vbnRoczogaSxcbiAgICAgICAgd2Vla3M6IGEsXG4gICAgICAgIGRheXM6IG5cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5kYXksXG4gICAgICAgIG8gPSB0aGlzLm1heGltdW1Nb250aExlbmd0aChlKSxcbiAgICAgICAgbiA9IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGUpO1xuICAgICAgaWYgKG4gPT09IG8pIHJldHVybiBuO1xuICAgICAgdmFyIGEgPSByIDw9IG8gLSBuID8gbyA6IG4sXG4gICAgICAgIGkgPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGUsIFwiY29uc3RyYWluXCIsIHQpLFxuICAgICAgICBzID0gdGhpcy5hZGREYXlzSXNvKGksIGEpLFxuICAgICAgICBsID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShzLCB0KSxcbiAgICAgICAgZCA9IHRoaXMuYWRkRGF5c0lzbyhzLCAtbC5kYXkpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoZCwgdCkuZGF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5QcmV2aW91c01vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJblByZXZpb3VzTW9udGgoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLmRheSxcbiAgICAgICAgbyA9IGUubW9udGgsXG4gICAgICAgIG4gPSBlLnllYXI7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgeWVhcjogbyA+IDEgPyBuIDogbiAtIDEsXG4gICAgICAgIG1vbnRoOiBvLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IG8gPiAxID8gbyAtIDEgOiB0aGlzLm1vbnRoc0luWWVhcihhLCB0KTtcbiAgICAgIGEgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYSksIHt9LCB7XG4gICAgICAgIG1vbnRoOiBpXG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoYSksXG4gICAgICAgIGwgPSB0aGlzLm1heGltdW1Nb250aExlbmd0aChhKTtcbiAgICAgIGlmIChzID09PSBsKSByZXR1cm4gbDtcbiAgICAgIHZhciBkID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShlLCBcImNvbnN0cmFpblwiLCB0KSxcbiAgICAgICAgbSA9IHRoaXMuYWRkRGF5c0lzbyhkLCAtcik7XG4gICAgICByZXR1cm4gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShtLCB0KS5kYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2ZDYWxlbmRhclllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkNhbGVuZGFyWWVhcihlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiBlLnllYXIsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBtb250aENvZGU6IFwiTTAxXCIsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZkNhbGVuZGFyTW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkNhbGVuZGFyTW9udGgoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogZS55ZWFyLFxuICAgICAgICBtb250aDogZS5tb250aCxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxlbmRhckRheXNVbnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxlbmRhckRheXNVbnRpbChlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoZSwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgIG4gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKHQsIFwiY29uc3RyYWluXCIsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvRGF5c1VudGlsKG8sIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc29EYXlzVW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNvRGF5c1VudGlsKGUsIHQpIHtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCB0LnllYXIsIHQubW9udGgsIHQuZGF5LCBcImRheVwiKS5kYXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aERheUZyb21GaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhEYXlGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICBuLFxuICAgICAgICBhLFxuICAgICAgICBpLFxuICAgICAgICBzLFxuICAgICAgICBsID0gZS5tb250aENvZGUsXG4gICAgICAgIGQgPSBlLmRheTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGwpIHtcbiAgICAgICAgdmFyIF9vMzcgPSBlLnllYXIsXG4gICAgICAgICAgX24yNiA9IGUuZXJhLFxuICAgICAgICAgIF9hMTkgPSBlLmVyYVllYXI7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IF9vMzcgJiYgKHZvaWQgMCA9PT0gX24yNiB8fCB2b2lkIDAgPT09IF9hMTkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwid2hlbiBgbW9udGhDb2RlYCBpcyBvbWl0dGVkLCBgeWVhcmAgKG9yIGBlcmFgIGFuZCBgZXJhWWVhcmApIGFuZCBgbW9udGhgIGFyZSByZXF1aXJlZFwiKTtcbiAgICAgICAgdmFyIF90aGlzJGlzb1RvQ2FsZW5kYXJEYSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUodGhpcy5jYWxlbmRhclRvSXNvRGF0ZShlLCB0LCByKSwgcik7XG4gICAgICAgIGwgPSBfdGhpcyRpc29Ub0NhbGVuZGFyRGEubW9udGhDb2RlO1xuICAgICAgICBkID0gX3RoaXMkaXNvVG9DYWxlbmRhckRhLmRheTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZSh7XG4gICAgICAgICAgeWVhcjogMTk3MixcbiAgICAgICAgICBtb250aDogMTIsXG4gICAgICAgICAgZGF5OiAzMVxuICAgICAgICB9LCByKSxcbiAgICAgICAgYyA9IG0ubW9udGhDb2RlID4gbCB8fCBtLm1vbnRoQ29kZSA9PT0gbCAmJiBtLmRheSA+PSBkID8gbS55ZWFyIDogbS55ZWFyIC0gMTtcbiAgICAgIGZvciAodmFyIF9lNDUgPSAwOyBfZTQ1IDwgMTAwOyBfZTQ1KyspIHtcbiAgICAgICAgdmFyIF9tMTAgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZSh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBtb250aENvZGU6IGwsXG4gICAgICAgICAgICB5ZWFyOiBjIC0gX2U0NVxuICAgICAgICAgIH0sIHIpLFxuICAgICAgICAgIF9oMyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoX20xMCwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgICAgX3UyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShfaDMsIHIpO1xuICAgICAgICBpZiAoKG8gPSBfaDMueWVhciwgbiA9IF9oMy5tb250aCwgYSA9IF9oMy5kYXkpLCBfdTIubW9udGhDb2RlID09PSBsICYmIF91Mi5kYXkgPT09IGQpIHJldHVybiB7XG4gICAgICAgICAgbW9udGg6IG4sXG4gICAgICAgICAgZGF5OiBhLFxuICAgICAgICAgIHllYXI6IG9cbiAgICAgICAgfTtcbiAgICAgICAgXCJjb25zdHJhaW5cIiA9PT0gdCAmJiAodm9pZCAwID09PSBpIHx8IF91Mi5tb250aENvZGUgPT09IGkubW9udGhDb2RlICYmIF91Mi5kYXkgPiBpLmRheSkgJiYgKGkgPSBfdTIsIHMgPSBfaDMpO1xuICAgICAgfVxuICAgICAgaWYgKFwiY29uc3RyYWluXCIgPT09IHQgJiYgdm9pZCAwICE9PSBzKSByZXR1cm4gcztcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gcmVjZW50IFwiLmNvbmNhdCh0aGlzLmlkLCBcIiB5ZWFyIHdpdGggbW9udGhDb2RlIFwiKS5jb25jYXQobCwgXCIgYW5kIGRheSBcIikuY29uY2F0KGQpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhlbHBlckJhc2U7XG59KCk7XG52YXIgSGVicmV3SGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZSkge1xuICBfaW5oZXJpdHMoSGVicmV3SGVscGVyLCBfSGVscGVyQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSGVicmV3SGVscGVyKTtcbiAgZnVuY3Rpb24gSGVicmV3SGVscGVyKCkge1xuICAgIHZhciBfdGhpczM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYnJld0hlbHBlcik7XG4gICAgX3RoaXMzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMy5pZCA9IFwiaGVicmV3XCIsIF90aGlzMy5jYWxlbmRhclR5cGUgPSBcImx1bmlzb2xhclwiLCBfdGhpczMubW9udGhzID0ge1xuICAgICAgVGlzaHJpOiB7XG4gICAgICAgIGxlYXA6IDEsXG4gICAgICAgIHJlZ3VsYXI6IDEsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDFcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBIZXNodmFuOiB7XG4gICAgICAgIGxlYXA6IDIsXG4gICAgICAgIHJlZ3VsYXI6IDIsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDJcIixcbiAgICAgICAgZGF5czoge1xuICAgICAgICAgIG1pbjogMjksXG4gICAgICAgICAgbWF4OiAzMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgS2lzbGV2OiB7XG4gICAgICAgIGxlYXA6IDMsXG4gICAgICAgIHJlZ3VsYXI6IDMsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDNcIixcbiAgICAgICAgZGF5czoge1xuICAgICAgICAgIG1pbjogMjksXG4gICAgICAgICAgbWF4OiAzMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgVGV2ZXQ6IHtcbiAgICAgICAgbGVhcDogNCxcbiAgICAgICAgcmVndWxhcjogNCxcbiAgICAgICAgbW9udGhDb2RlOiBcIk0wNFwiLFxuICAgICAgICBkYXlzOiAyOVxuICAgICAgfSxcbiAgICAgIFNoZXZhdDoge1xuICAgICAgICBsZWFwOiA1LFxuICAgICAgICByZWd1bGFyOiA1LFxuICAgICAgICBtb250aENvZGU6IFwiTTA1XCIsXG4gICAgICAgIGRheXM6IDMwXG4gICAgICB9LFxuICAgICAgQWRhcjoge1xuICAgICAgICBsZWFwOiB2b2lkIDAsXG4gICAgICAgIHJlZ3VsYXI6IDYsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDZcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBcIkFkYXIgSVwiOiB7XG4gICAgICAgIGxlYXA6IDYsXG4gICAgICAgIHJlZ3VsYXI6IHZvaWQgMCxcbiAgICAgICAgbW9udGhDb2RlOiBcIk0wNUxcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBcIkFkYXIgSUlcIjoge1xuICAgICAgICBsZWFwOiA3LFxuICAgICAgICByZWd1bGFyOiB2b2lkIDAsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDZcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBOaXNhbjoge1xuICAgICAgICBsZWFwOiA4LFxuICAgICAgICByZWd1bGFyOiA3LFxuICAgICAgICBtb250aENvZGU6IFwiTTA3XCIsXG4gICAgICAgIGRheXM6IDMwXG4gICAgICB9LFxuICAgICAgSXlhcjoge1xuICAgICAgICBsZWFwOiA5LFxuICAgICAgICByZWd1bGFyOiA4LFxuICAgICAgICBtb250aENvZGU6IFwiTTA4XCIsXG4gICAgICAgIGRheXM6IDI5XG4gICAgICB9LFxuICAgICAgU2l2YW46IHtcbiAgICAgICAgbGVhcDogMTAsXG4gICAgICAgIHJlZ3VsYXI6IDksXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDlcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBUYW11ejoge1xuICAgICAgICBsZWFwOiAxMSxcbiAgICAgICAgcmVndWxhcjogMTAsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMTBcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBBdjoge1xuICAgICAgICBsZWFwOiAxMixcbiAgICAgICAgcmVndWxhcjogMTEsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMTFcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBFbHVsOiB7XG4gICAgICAgIGxlYXA6IDEzLFxuICAgICAgICByZWd1bGFyOiAxMixcbiAgICAgICAgbW9udGhDb2RlOiBcIk0xMlwiLFxuICAgICAgICBkYXlzOiAyOVxuICAgICAgfVxuICAgIH0sIF90aGlzMy5oYXNFcmEgPSAhMTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhIZWJyZXdIZWxwZXIsIFt7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGUueWVhcjtcbiAgICAgIHJldHVybiAoNyAqIHQgKyAxKSAlIDE5IDwgNztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcihlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKGUpID8gMTMgOiAxMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChlLCBcIm1pblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4aW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heGltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChlLCBcIm1heFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluTWF4TW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluTWF4TW9udGhMZW5ndGgoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLm1vbnRoLFxuICAgICAgICBvID0gZS55ZWFyLFxuICAgICAgICBuID0gdGhpcy5nZXRNb250aENvZGUobywgciksXG4gICAgICAgIGEgPSB3dCh0aGlzLm1vbnRocykuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlWzFdLm1vbnRoQ29kZSA9PT0gbjtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodm9pZCAwID09PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInVubWF0Y2hlZCBIZWJyZXcgbW9udGg6IFwiLmNvbmNhdChyKSk7XG4gICAgICB2YXIgaSA9IGFbMV0uZGF5cztcbiAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiBpID8gaSA6IGlbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiB0IC0gMzc2MCxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TW9udGhDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vbnRoQ29kZShlLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgeWVhcjogZVxuICAgICAgfSkgPyA2ID09PSB0ID8gYnVpbGRNb250aENvZGUoNSwgITApIDogYnVpbGRNb250aENvZGUodCA8IDYgPyB0IDogdCAtIDEpIDogYnVpbGRNb250aENvZGUodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENhbGVuZGFyRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogITE7XG4gICAgICB2YXIgbiA9IGUueWVhcixcbiAgICAgICAgYSA9IGUuZXJhWWVhcixcbiAgICAgICAgaSA9IGUubW9udGgsXG4gICAgICAgIHMgPSBlLm1vbnRoQ29kZSxcbiAgICAgICAgbCA9IGUuZGF5LFxuICAgICAgICBkID0gZS5tb250aEV4dHJhO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gbiAmJiB2b2lkIDAgIT09IGEgJiYgKG4gPSBhKSwgdm9pZCAwID09PSBhICYmIHZvaWQgMCAhPT0gbiAmJiAoYSA9IG4pLCBvKSB7XG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgdmFyIF9lNDYgPSB0aGlzLm1vbnRoc1tkXTtcbiAgICAgICAgICBpZiAoIV9lNDYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5yZWNvZ25pemVkIG1vbnRoIGZyb20gZm9ybWF0VG9QYXJ0czogXCIuY29uY2F0KGQpKTtcbiAgICAgICAgICBpID0gdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KSA/IF9lNDYubGVhcCA6IF9lNDYucmVndWxhcjtcbiAgICAgICAgfVxuICAgICAgICBzID0gdGhpcy5nZXRNb250aENvZGUobiwgaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogbixcbiAgICAgICAgICBtb250aDogaSxcbiAgICAgICAgICBkYXk6IGwsXG4gICAgICAgICAgZXJhOiB2b2lkIDAsXG4gICAgICAgICAgZXJhWWVhcjogYSxcbiAgICAgICAgICBtb250aENvZGU6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpLCB2b2lkIDAgPT09IGkpIHtcbiAgICAgICAgaWYgKHMuZW5kc1dpdGgoXCJMXCIpKSB7XG4gICAgICAgICAgaWYgKFwiTTA1TFwiICE9PSBzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkhlYnJldyBsZWFwIG1vbnRoIG11c3QgaGF2ZSBtb250aENvZGUgTTA1TCwgbm90IFwiLmNvbmNhdChzKSk7XG4gICAgICAgICAgaWYgKGkgPSA2LCAhdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKFwicmVqZWN0XCIgPT09IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSGVicmV3IG1vbnRoQ29kZSBNMDVMIGlzIGludmFsaWQgaW4geWVhciBcIi5jb25jYXQobiwgXCIgd2hpY2ggaXMgbm90IGEgbGVhcCB5ZWFyXCIpKTtcbiAgICAgICAgICAgIGkgPSA2LCBzID0gXCJNMDZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IG1vbnRoQ29kZU51bWJlclBhcnQocyksIHRoaXMuaW5MZWFwWWVhcih7XG4gICAgICAgICAgICB5ZWFyOiBuXG4gICAgICAgICAgfSkgJiYgaSA+PSA2ICYmIGkrKztcbiAgICAgICAgICB2YXIgX2U0NyA9IHRoaXMubW9udGhzSW5ZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaSA8IDEgfHwgaSA+IF9lNDcpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aENvZGU6IFwiLmNvbmNhdChzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJyZWplY3RcIiA9PT0gciA/IChSZWplY3RUb1JhbmdlKGksIDEsIHRoaXMubW9udGhzSW5ZZWFyKHtcbiAgICAgICAgeWVhcjogblxuICAgICAgfSkpLCBSZWplY3RUb1JhbmdlKGwsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHtcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgbW9udGg6IGlcbiAgICAgIH0pKSkgOiAoaSA9IENvbnN0cmFpblRvUmFuZ2UoaSwgMSwgdGhpcy5tb250aHNJblllYXIoe1xuICAgICAgICB5ZWFyOiBuXG4gICAgICB9KSksIGwgPSBDb25zdHJhaW5Ub1JhbmdlKGwsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHtcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgbW9udGg6IGlcbiAgICAgIH0pKSksIHZvaWQgMCA9PT0gcykgcyA9IHRoaXMuZ2V0TW9udGhDb2RlKG4sIGkpO2Vsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRNb250aENvZGUobiwgaSkgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIFwiLmNvbmNhdChzLCBcIiBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gbW9udGggXCIpLmNvbmNhdChpLCBcIiBpbiBIZWJyZXcgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZSksIHt9LCB7XG4gICAgICAgIGRheTogbCxcbiAgICAgICAgbW9udGg6IGksXG4gICAgICAgIG1vbnRoQ29kZTogcyxcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgZXJhWWVhcjogYVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIZWJyZXdIZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIElzbGFtaWNCYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTIpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNCYXNlSGVscGVyLCBfSGVscGVyQmFzZTIpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihJc2xhbWljQmFzZUhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNCYXNlSGVscGVyKCkge1xuICAgIHZhciBfdGhpczQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNCYXNlSGVscGVyKTtcbiAgICBfdGhpczQgPSBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzNC5jYWxlbmRhclR5cGUgPSBcImx1bmFyXCIsIF90aGlzNC5EQVlTX1BFUl9JU0xBTUlDX1lFQVIgPSAzNTQgKyAxMSAvIDMwLCBfdGhpczQuREFZU19QRVJfSVNPX1lFQVIgPSAzNjUuMjQyNSwgX3RoaXM0LmNvbnN0YW50RXJhID0gXCJhaFwiO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKElzbGFtaWNCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSwgdCkge1xuICAgICAgcmV0dXJuIDMwID09PSB0aGlzLmRheXNJbk1vbnRoKHtcbiAgICAgICAgeWVhcjogZS55ZWFyLFxuICAgICAgICBtb250aDogMTIsXG4gICAgICAgIGRheTogMVxuICAgICAgfSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoKSB7XG4gICAgICByZXR1cm4gMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMjk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heGltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhpbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIF90aGlzJGFkanVzdENhbGVuZGFyRCA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICB0ID0gX3RoaXMkYWRqdXN0Q2FsZW5kYXJELnllYXI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiBTdCh0ICogdGhpcy5EQVlTX1BFUl9JU0xBTUlDX1lFQVIgLyB0aGlzLkRBWVNfUEVSX0lTT19ZRUFSKSArIDYyMixcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIElzbGFtaWNCYXNlSGVscGVyO1xufShIZWxwZXJCYXNlKTtcbnZhciBJc2xhbWljSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSXNsYW1pY0Jhc2VIZWxwZXIpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcik7XG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKElzbGFtaWNIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljSGVscGVyKCkge1xuICAgIHZhciBfdGhpczU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNIZWxwZXIpO1xuICAgIF90aGlzNSA9IF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXM1LmlkID0gXCJpc2xhbWljXCI7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgSXNsYW1pY1VtYWxxdXJhSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSXNsYW1pY0Jhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhJc2xhbWljVW1hbHF1cmFIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcjIpO1xuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihJc2xhbWljVW1hbHF1cmFIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljVW1hbHF1cmFIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzNjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSXNsYW1pY1VtYWxxdXJhSGVscGVyKTtcbiAgICBfdGhpczYgPSBfc3VwZXI0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzNi5pZCA9IFwiaXNsYW1pYy11bWFscXVyYVwiO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljVW1hbHF1cmFIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgSXNsYW1pY1RibGFIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Jc2xhbWljQmFzZUhlbHBlcjMpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNUYmxhSGVscGVyLCBfSXNsYW1pY0Jhc2VIZWxwZXIzKTtcbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoSXNsYW1pY1RibGFIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljVGJsYUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXM3O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljVGJsYUhlbHBlcik7XG4gICAgX3RoaXM3ID0gX3N1cGVyNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczcuaWQgPSBcImlzbGFtaWMtdGJsYVwiO1xuICAgIHJldHVybiBfdGhpczc7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljVGJsYUhlbHBlcik7XG59KElzbGFtaWNCYXNlSGVscGVyKTtcbnZhciBJc2xhbWljQ2l2aWxIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Jc2xhbWljQmFzZUhlbHBlcjQpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNDaXZpbEhlbHBlciwgX0lzbGFtaWNCYXNlSGVscGVyNCk7XG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKElzbGFtaWNDaXZpbEhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNDaXZpbEhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXM4O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljQ2l2aWxIZWxwZXIpO1xuICAgIF90aGlzOCA9IF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXM4LmlkID0gXCJpc2xhbWljLWNpdmlsXCI7XG4gICAgcmV0dXJuIF90aGlzODtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNDaXZpbEhlbHBlcik7XG59KElzbGFtaWNCYXNlSGVscGVyKTtcbnZhciBJc2xhbWljUmdzYUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lzbGFtaWNCYXNlSGVscGVyNSkge1xuICBfaW5oZXJpdHMoSXNsYW1pY1Jnc2FIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcjUpO1xuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihJc2xhbWljUmdzYUhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNSZ3NhSGVscGVyKCkge1xuICAgIHZhciBfdGhpczk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNSZ3NhSGVscGVyKTtcbiAgICBfdGhpczkgPSBfc3VwZXI3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzOS5pZCA9IFwiaXNsYW1pYy1yZ3NhXCI7XG4gICAgcmV0dXJuIF90aGlzOTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNSZ3NhSGVscGVyKTtcbn0oSXNsYW1pY0Jhc2VIZWxwZXIpO1xudmFyIElzbGFtaWNDY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lzbGFtaWNCYXNlSGVscGVyNikge1xuICBfaW5oZXJpdHMoSXNsYW1pY0NjSGVscGVyLCBfSXNsYW1pY0Jhc2VIZWxwZXI2KTtcbiAgdmFyIF9zdXBlcjggPSBfY3JlYXRlU3VwZXIoSXNsYW1pY0NjSGVscGVyKTtcbiAgZnVuY3Rpb24gSXNsYW1pY0NjSGVscGVyKCkge1xuICAgIHZhciBfdGhpczEwO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljQ2NIZWxwZXIpO1xuICAgIF90aGlzMTAgPSBfc3VwZXI4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMTAuaWQgPSBcImlzbGFtaWNjXCI7XG4gICAgcmV0dXJuIF90aGlzMTA7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljQ2NIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgUGVyc2lhbkhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hlbHBlckJhc2UzKSB7XG4gIF9pbmhlcml0cyhQZXJzaWFuSGVscGVyLCBfSGVscGVyQmFzZTMpO1xuICB2YXIgX3N1cGVyOSA9IF9jcmVhdGVTdXBlcihQZXJzaWFuSGVscGVyKTtcbiAgZnVuY3Rpb24gUGVyc2lhbkhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxMTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lhbkhlbHBlcik7XG4gICAgX3RoaXMxMSA9IF9zdXBlcjkuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXMxMS5pZCA9IFwicGVyc2lhblwiLCBfdGhpczExLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMS5jb25zdGFudEVyYSA9IFwiYXBcIjtcbiAgICByZXR1cm4gX3RoaXMxMTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUGVyc2lhbkhlbHBlciwgW3tcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkxlYXBZZWFyKGUsIHQpIHtcbiAgICAgIHJldHVybiBJc2xhbWljSGVscGVyLnByb3RvdHlwZS5pbkxlYXBZZWFyLmNhbGwodGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoKSB7XG4gICAgICByZXR1cm4gMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoZSkge1xuICAgICAgdmFyIHQgPSBlLm1vbnRoO1xuICAgICAgcmV0dXJuIDEyID09PSB0ID8gMjkgOiB0IDw9IDYgPyAzMSA6IDMwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHZhciB0ID0gZS5tb250aDtcbiAgICAgIHJldHVybiAxMiA9PT0gdCA/IDMwIDogdCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXN0aW1hdGVJc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzdGltYXRlSXNvRGF0ZShlKSB7XG4gICAgICB2YXIgX3RoaXMkYWRqdXN0Q2FsZW5kYXJEMiA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICB0ID0gX3RoaXMkYWRqdXN0Q2FsZW5kYXJEMi55ZWFyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogdCArIDYyMSxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBlcnNpYW5IZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIEluZGlhbkhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hlbHBlckJhc2U0KSB7XG4gIF9pbmhlcml0cyhJbmRpYW5IZWxwZXIsIF9IZWxwZXJCYXNlNCk7XG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihJbmRpYW5IZWxwZXIpO1xuICBmdW5jdGlvbiBJbmRpYW5IZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMTI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZGlhbkhlbHBlcik7XG4gICAgX3RoaXMxMiA9IF9zdXBlcjEwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMTIuaWQgPSBcImluZGlhblwiLCBfdGhpczEyLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMi5jb25zdGFudEVyYSA9IFwic2FrYVwiLCBfdGhpczEyLm1vbnRocyA9IHtcbiAgICAgIDE6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDMsXG4gICAgICAgIGRheTogMjIsXG4gICAgICAgIGxlYXA6IHtcbiAgICAgICAgICBsZW5ndGg6IDMxLFxuICAgICAgICAgIG1vbnRoOiAzLFxuICAgICAgICAgIGRheTogMjFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDI6IHtcbiAgICAgICAgbGVuZ3RoOiAzMSxcbiAgICAgICAgbW9udGg6IDQsXG4gICAgICAgIGRheTogMjFcbiAgICAgIH0sXG4gICAgICAzOiB7XG4gICAgICAgIGxlbmd0aDogMzEsXG4gICAgICAgIG1vbnRoOiA1LFxuICAgICAgICBkYXk6IDIyXG4gICAgICB9LFxuICAgICAgNDoge1xuICAgICAgICBsZW5ndGg6IDMxLFxuICAgICAgICBtb250aDogNixcbiAgICAgICAgZGF5OiAyMlxuICAgICAgfSxcbiAgICAgIDU6IHtcbiAgICAgICAgbGVuZ3RoOiAzMSxcbiAgICAgICAgbW9udGg6IDcsXG4gICAgICAgIGRheTogMjNcbiAgICAgIH0sXG4gICAgICA2OiB7XG4gICAgICAgIGxlbmd0aDogMzEsXG4gICAgICAgIG1vbnRoOiA4LFxuICAgICAgICBkYXk6IDIzXG4gICAgICB9LFxuICAgICAgNzoge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogOSxcbiAgICAgICAgZGF5OiAyM1xuICAgICAgfSxcbiAgICAgIDg6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDEwLFxuICAgICAgICBkYXk6IDIzXG4gICAgICB9LFxuICAgICAgOToge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMTEsXG4gICAgICAgIGRheTogMjJcbiAgICAgIH0sXG4gICAgICAxMDoge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMTIsXG4gICAgICAgIGRheTogMjJcbiAgICAgIH0sXG4gICAgICAxMToge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgbmV4dFllYXI6ICEwLFxuICAgICAgICBkYXk6IDIxXG4gICAgICB9LFxuICAgICAgMTI6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDIsXG4gICAgICAgIG5leHRZZWFyOiAhMCxcbiAgICAgICAgZGF5OiAyMFxuICAgICAgfVxuICAgIH0sIF90aGlzMTIudnVsbmVyYWJsZVRvQmNlQnVnID0gXCIxMC8xMS8tNzkgU2FrYVwiICE9PSBuZXcgRGF0ZShcIjAwMDAtMDEtMDFUMDA6MDBaXCIpLnRvTG9jYWxlRGF0ZVN0cmluZyhcImVuLVVTLXUtY2EtaW5kaWFuXCIsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMTI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEluZGlhbkhlbHBlciwgW3tcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkxlYXBZZWFyKGUpIHtcbiAgICAgIHJldHVybiBpc0dyZWdvcmlhbkxlYXBZZWFyKGUueWVhciArIDc4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcigpIHtcbiAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNb250aEluZm8oZSkubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoSW5mbyhlKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1vbnRoSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aEluZm8oZSkge1xuICAgICAgdmFyIHQgPSBlLm1vbnRoO1xuICAgICAgdmFyIHIgPSB0aGlzLm1vbnRoc1t0XTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aDogXCIuY29uY2F0KHQpKTtcbiAgICAgIHJldHVybiB0aGlzLmluTGVhcFllYXIoZSkgJiYgci5sZWFwICYmIChyID0gci5sZWFwKSwgcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXN0aW1hdGVJc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzdGltYXRlSXNvRGF0ZShlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICByID0gdGhpcy5nZXRNb250aEluZm8odCk7XG4gICAgICByZXR1cm4gQWRkSVNPRGF0ZSh0LnllYXIgKyA3OCArIChyLm5leHRZZWFyID8gMSA6IDApLCByLm1vbnRoLCByLmRheSwgMCwgMCwgMCwgdC5kYXkgLSAxLCBcImNvbnN0cmFpblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tJY3VCdWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrSWN1QnVncyhlKSB7XG4gICAgICBpZiAodGhpcy52dWxuZXJhYmxlVG9CY2VCdWcgJiYgZS55ZWFyIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMDAwMS0wMS0wMSAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5KVwiKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbmRpYW5IZWxwZXI7XG59KEhlbHBlckJhc2UpO1xuZnVuY3Rpb24gaXNHcmVnb3JpYW5MZWFwWWVhcihlKSB7XG4gIHJldHVybiBlICUgNCA9PSAwICYmIChlICUgMTAwICE9IDAgfHwgZSAlIDQwMCA9PSAwKTtcbn1cbnZhciBHcmVnb3JpYW5CYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTUpIHtcbiAgX2luaGVyaXRzKEdyZWdvcmlhbkJhc2VIZWxwZXIsIF9IZWxwZXJCYXNlNSk7XG4gIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihHcmVnb3JpYW5CYXNlSGVscGVyKTtcbiAgZnVuY3Rpb24gR3JlZ29yaWFuQmFzZUhlbHBlcihlLCB0KSB7XG4gICAgdmFyIF90aGlzMTM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xuICAgIF90aGlzMTMgPSBfc3VwZXIxMS5jYWxsKHRoaXMpLCBfdGhpczEzLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMy52OElzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gbmV3IERhdGUoXCIrMDAxMDAxLTAxLTAxVDAwOjAwWlwiKS50b0xvY2FsZURhdGVTdHJpbmcoXCJlbi1VUy11LWNhLWphcGFuZXNlXCIsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiXG4gICAgfSkuc3RhcnRzV2l0aChcIjEyXCIpLCBfdGhpczEzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSAhMSwgX3RoaXMxMy5pZCA9IGU7XG4gICAgdmFyIF9hZGp1c3RFcmFzID0gZnVuY3Rpb24gYWRqdXN0RXJhcyhlKSB7XG4gICAgICAgIHZhciB0LFxuICAgICAgICAgIHIgPSBlO1xuICAgICAgICBpZiAoMCA9PT0gci5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBlcmEgZGF0YTogZXJhcyBhcmUgcmVxdWlyZWRcIik7XG4gICAgICAgIGlmICgxID09PSByLmxlbmd0aCAmJiByWzBdLnJldmVyc2VPZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiBhbmNob3IgZXJhIGNhbm5vdCBjb3VudCB5ZWFycyBiYWNrd2FyZHNcIik7XG4gICAgICAgIGlmICgxID09PSByLmxlbmd0aCAmJiAhclswXS5uYW1lKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IGF0IGxlYXN0IG9uZSBuYW1lZCBlcmEgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGlmIChyLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBudWxsICE9IGUucmV2ZXJzZU9mO1xuICAgICAgICB9KS5sZW5ndGggPiAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IG9ubHkgb25lIGVyYSBjYW4gY291bnQgeWVhcnMgYmFja3dhcmRzXCIpO1xuICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS5pc0FuY2hvciB8fCAhZS5hbmNob3JFcG9jaCAmJiAhZS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgIGlmICh0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IGNhbm5vdCBoYXZlIG11bHRpcGxlIGFuY2hvciBlcmFzXCIpO1xuICAgICAgICAgICAgdCA9IGUsIGUuYW5jaG9yRXBvY2ggPSB7XG4gICAgICAgICAgICAgIHllYXI6IGUuaGFzWWVhclplcm8gPyAwIDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFlLm5hbWUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSWYgZXJhIG5hbWUgaXMgYmxhbmssIGl0IG11c3QgYmUgdGhlIGFuY2hvciBlcmFcIik7XG4gICAgICAgIH0pLCByID0gci5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5uYW1lO1xuICAgICAgICB9KSwgci5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSBlLnJldmVyc2VPZjtcbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdmFyIF9vMzggPSByLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gX28zOCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiB1bm1hdGNoZWQgcmV2ZXJzZU9mIGVyYTogXCIuY29uY2F0KHQpKTtcbiAgICAgICAgICAgIGUucmV2ZXJzZU9mID0gX28zOCwgZS5hbmNob3JFcG9jaCA9IF9vMzguYW5jaG9yRXBvY2gsIGUuaXNvRXBvY2ggPSBfbzM4Lmlzb0Vwb2NoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2b2lkIDAgPT09IGUuYW5jaG9yRXBvY2gubW9udGggJiYgKGUuYW5jaG9yRXBvY2gubW9udGggPSAxKSwgdm9pZCAwID09PSBlLmFuY2hvckVwb2NoLmRheSAmJiAoZS5hbmNob3JFcG9jaC5kYXkgPSAxKTtcbiAgICAgICAgfSksIHl0LmNhbGwociwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoZS5yZXZlcnNlT2YpIHJldHVybiAxO1xuICAgICAgICAgIGlmICh0LnJldmVyc2VPZikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICghZS5pc29FcG9jaCB8fCAhdC5pc29FcG9jaCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiBtaXNzaW5nIElTTyBlcG9jaFwiKTtcbiAgICAgICAgICByZXR1cm4gdC5pc29FcG9jaC55ZWFyIC0gZS5pc29FcG9jaC55ZWFyO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG8gPSByW3IubGVuZ3RoIC0gMV0ucmV2ZXJzZU9mO1xuICAgICAgICBpZiAobyAmJiBvICE9PSByW3IubGVuZ3RoIC0gMl0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBlcmEgZGF0YTogaW52YWxpZCByZXZlcnNlLXNpZ24gZXJhXCIpO1xuICAgICAgICByZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgZS5nZW5lcmljTmFtZSA9IFwiZXJhXCIgKyAoci5sZW5ndGggLSAxIC0gdCk7XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgZXJhczogcixcbiAgICAgICAgICBhbmNob3JFcmE6IHQgfHwgclswXVxuICAgICAgICB9O1xuICAgICAgfSh0KSxcbiAgICAgIHIgPSBfYWRqdXN0RXJhcy5lcmFzLFxuICAgICAgbyA9IF9hZGp1c3RFcmFzLmFuY2hvckVyYTtcbiAgICBfdGhpczEzLmFuY2hvckVyYSA9IG8sIF90aGlzMTMuZXJhcyA9IHI7XG4gICAgcmV0dXJuIF90aGlzMTM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEdyZWdvcmlhbkJhc2VIZWxwZXIsIFt7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgX3RoaXMkZXN0aW1hdGVJc29EYXRlID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoe1xuICAgICAgICAgIG1vbnRoOiAxLFxuICAgICAgICAgIGRheTogMSxcbiAgICAgICAgICB5ZWFyOiBlLnllYXJcbiAgICAgICAgfSksXG4gICAgICAgIHQgPSBfdGhpcyRlc3RpbWF0ZUlzb0RhdGUueWVhcjtcbiAgICAgIHJldHVybiBpc0dyZWdvcmlhbkxlYXBZZWFyKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKCkge1xuICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW5pbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluaW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHZhciB0ID0gZS5tb250aDtcbiAgICAgIHJldHVybiAyID09PSB0ID8gdGhpcy5pbkxlYXBZZWFyKGUpID8gMjkgOiAyOCA6IFs0LCA2LCA5LCAxMV0uaW5kZXhPZih0KSA+PSAwID8gMzAgOiAzMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4aW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heGltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBsZXRlRXJhWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZUVyYVllYXIoZSkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzLFxuICAgICAgICBfZXJhRnJvbVllYXI7XG4gICAgICB2YXIgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uIGNoZWNrRmllbGQodCwgcikge1xuICAgICAgICAgIHZhciBvID0gZVt0XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBvICYmIG8gIT0gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnB1dCBcIi5jb25jYXQodCwgXCIgXCIpLmNvbmNhdChvLCBcIiBkb2Vzbid0IG1hdGNoIGNhbGN1bGF0ZWQgdmFsdWUgXCIpLmNvbmNhdChyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVyYUZyb21ZZWFyID0gZnVuY3Rpb24gZXJhRnJvbVllYXIodCkge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgIHZhciBvID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICAgICAgICB5ZWFyOiB0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG4gPSBfdGhpczE0LmVyYXMuZmluZChmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICBpZiAobiA9PT0gX3RoaXMxNC5lcmFzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0ID4gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTaWduZWQgeWVhciBcIi5jb25jYXQodCwgXCIgaXMgaW52YWxpZCBmb3IgZXJhIFwiKS5jb25jYXQoZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gciA9IGUuYW5jaG9yRXBvY2gueWVhciAtIHQsICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gciA9IHQgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKSwgITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTQuY29tcGFyZUNhbGVuZGFyRGF0ZXMobywgZS5hbmNob3JFcG9jaCkgPj0gMCAmJiAociA9IHQgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKSwgITApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlllYXIgXCIuY29uY2F0KHQsIFwiIHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhXCIpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJhWWVhcjogcixcbiAgICAgICAgICAgIGVyYTogbi5uYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIHZhciB0ID0gZS55ZWFyLFxuICAgICAgICByID0gZS5lcmFZZWFyLFxuICAgICAgICBvID0gZS5lcmE7XG4gICAgICBpZiAobnVsbCAhPSB0KSAoX2VyYUZyb21ZZWFyID0gZXJhRnJvbVllYXIodCksIHIgPSBfZXJhRnJvbVllYXIuZXJhWWVhciwgbyA9IF9lcmFGcm9tWWVhci5lcmEpLCBjaGVja0ZpZWxkKFwiZXJhXCIsIG8pLCBjaGVja0ZpZWxkKFwiZXJhWWVhclwiLCByKTtlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT0gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgYHllYXJgIG9yIGBlcmFZZWFyYCBhbmQgYGVyYWAgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcmFGcm9tWWVhcjI7XG4gICAgICAgICAgdmFyIF9lNDggPSB2b2lkIDAgPT09IG8gPyB2b2lkIDAgOiB0aGlzLmVyYXMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gbyB8fCBlLmdlbmVyaWNOYW1lID09PSBvO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghX2U0OCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFcmEgXCIuY29uY2F0KG8sIFwiIChJU08geWVhciBcIikuY29uY2F0KHIsIFwiKSB3YXMgbm90IG1hdGNoZWQgYnkgYW55IGVyYVwiKSk7XG4gICAgICAgICAgaWYgKHIgPCAxICYmIF9lNDgucmV2ZXJzZU9mKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlllYXJzIGluIFwiLmNvbmNhdChvLCBcIiBlcmEgbXVzdCBiZSBwb3NpdGl2ZSwgbm90IFwiKS5jb25jYXQodCkpO1xuICAgICAgICAgIHQgPSBfZTQ4LnJldmVyc2VPZiA/IF9lNDguYW5jaG9yRXBvY2gueWVhciAtIHIgOiByICsgX2U0OC5hbmNob3JFcG9jaC55ZWFyIC0gKF9lNDguaGFzWWVhclplcm8gPyAwIDogMSksIGNoZWNrRmllbGQoXCJ5ZWFyXCIsIHQpLCAoX2VyYUZyb21ZZWFyMiA9IGVyYUZyb21ZZWFyKHQpLCByID0gX2VyYUZyb21ZZWFyMi5lcmFZZWFyLCBvID0gX2VyYUZyb21ZZWFyMi5lcmEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICB5ZWFyOiB0LFxuICAgICAgICBlcmFZZWFyOiByLFxuICAgICAgICBlcmE6IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RDYWxlbmRhckRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0Q2FsZW5kYXJEYXRlKGUsIHQpIHtcbiAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImNvbnN0cmFpblwiO1xuICAgICAgdmFyIG8gPSBlO1xuICAgICAgdmFyIF9vMzkgPSBvLFxuICAgICAgICBuID0gX28zOS5tb250aCxcbiAgICAgICAgYSA9IF9vMzkubW9udGhDb2RlO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbiAmJiAobyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvKSwge30sIHtcbiAgICAgICAgbW9udGg6IG1vbnRoQ29kZU51bWJlclBhcnQoYSlcbiAgICAgIH0pKSwgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShvKSwgbyA9IHRoaXMuY29tcGxldGVFcmFZZWFyKG8pLCBfZ2V0KF9nZXRQcm90b3R5cGVPZihHcmVnb3JpYW5CYXNlSGVscGVyLnByb3RvdHlwZSksIFwiYWRqdXN0Q2FsZW5kYXJEYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgbywgdCwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShlKSxcbiAgICAgICAgciA9IHQueWVhcixcbiAgICAgICAgbyA9IHQubW9udGgsXG4gICAgICAgIG4gPSB0LmRheSxcbiAgICAgICAgYSA9IHRoaXMuYW5jaG9yRXJhO1xuICAgICAgcmV0dXJuIFJlZ3VsYXRlSVNPRGF0ZShyICsgYS5pc29FcG9jaC55ZWFyIC0gKGEuaGFzWWVhclplcm8gPyAwIDogMSksIG8sIG4sIFwiY29uc3RyYWluXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0ljdUJ1Z3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tJY3VCdWdzKGUpIHtcbiAgICAgIGlmICh0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgJiYgdGhpcy52OElzVnVsbmVyYWJsZVRvSnVsaWFuQnVnKSB7XG4gICAgICAgIGlmIChDb21wYXJlSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCAxNTgyLCAxMCwgMTUpIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMTU4Mi0xMC0xNSAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExNzMxNTgpXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdyZWdvcmlhbkJhc2VIZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIE9ydGhvZG94QmFzZUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyZWdvcmlhbkJhc2VIZWxwZXIpIHtcbiAgX2luaGVyaXRzKE9ydGhvZG94QmFzZUhlbHBlciwgX0dyZWdvcmlhbkJhc2VIZWxwZXIpO1xuICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoT3J0aG9kb3hCYXNlSGVscGVyKTtcbiAgZnVuY3Rpb24gT3J0aG9kb3hCYXNlSGVscGVyKGUsIHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3J0aG9kb3hCYXNlSGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTIuY2FsbCh0aGlzLCBlLCB0KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoT3J0aG9kb3hCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXI7XG4gICAgICByZXR1cm4gKHQgKyAxKSAlIDQgPT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcigpIHtcbiAgICAgIHJldHVybiAxMztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICB2YXIgdCA9IGUubW9udGg7XG4gICAgICByZXR1cm4gMTMgPT09IHQgPyB0aGlzLmluTGVhcFllYXIoZSkgPyA2IDogNSA6IDMwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9ydGhvZG94QmFzZUhlbHBlcjtcbn0oR3JlZ29yaWFuQmFzZUhlbHBlcik7XG52YXIgRXRoaW9hYUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09ydGhvZG94QmFzZUhlbHBlcikge1xuICBfaW5oZXJpdHMoRXRoaW9hYUhlbHBlciwgX09ydGhvZG94QmFzZUhlbHBlcik7XG4gIHZhciBfc3VwZXIxMyA9IF9jcmVhdGVTdXBlcihFdGhpb2FhSGVscGVyKTtcbiAgZnVuY3Rpb24gRXRoaW9hYUhlbHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoaW9hYUhlbHBlcik7XG4gICAgcmV0dXJuIF9zdXBlcjEzLmNhbGwodGhpcywgXCJldGhpb2FhXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IC01NDkyLFxuICAgICAgICBtb250aDogNyxcbiAgICAgICAgZGF5OiAxN1xuICAgICAgfVxuICAgIH1dKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV0aGlvYWFIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIENvcHRpY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09ydGhvZG94QmFzZUhlbHBlcjIpIHtcbiAgX2luaGVyaXRzKENvcHRpY0hlbHBlciwgX09ydGhvZG94QmFzZUhlbHBlcjIpO1xuICB2YXIgX3N1cGVyMTQgPSBfY3JlYXRlU3VwZXIoQ29wdGljSGVscGVyKTtcbiAgZnVuY3Rpb24gQ29wdGljSGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3B0aWNIZWxwZXIpO1xuICAgIHJldHVybiBfc3VwZXIxNC5jYWxsKHRoaXMsIFwiY29wdGljXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTFcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDI4NCxcbiAgICAgICAgbW9udGg6IDgsXG4gICAgICAgIGRheTogMjlcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIHJldmVyc2VPZjogXCJlcmExXCJcbiAgICB9XSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb3B0aWNIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIEV0aGlvcGljSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT3J0aG9kb3hCYXNlSGVscGVyMykge1xuICBfaW5oZXJpdHMoRXRoaW9waWNIZWxwZXIsIF9PcnRob2RveEJhc2VIZWxwZXIzKTtcbiAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKEV0aGlvcGljSGVscGVyKTtcbiAgZnVuY3Rpb24gRXRoaW9waWNIZWxwZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGlvcGljSGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTUuY2FsbCh0aGlzLCBcImV0aGlvcGljXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IC01NDkyLFxuICAgICAgICBtb250aDogNyxcbiAgICAgICAgZGF5OiAxN1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiZXJhMVwiLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogOCxcbiAgICAgICAgbW9udGg6IDgsXG4gICAgICAgIGRheTogMjdcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiA1NTAxXG4gICAgICB9XG4gICAgfV0pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXRoaW9waWNIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIFJvY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyZWdvcmlhbkJhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhSb2NIZWxwZXIsIF9HcmVnb3JpYW5CYXNlSGVscGVyMik7XG4gIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihSb2NIZWxwZXIpO1xuICBmdW5jdGlvbiBSb2NIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMTU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvY0hlbHBlcik7XG4gICAgX3RoaXMxNSA9IF9zdXBlcjE2LmNhbGwodGhpcywgXCJyb2NcIiwgW3tcbiAgICAgIG5hbWU6IFwibWluZ3VvXCIsXG4gICAgICBpc29FcG9jaDoge1xuICAgICAgICB5ZWFyOiAxOTEyLFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJiZWZvcmUtcm9jXCIsXG4gICAgICByZXZlcnNlT2Y6IFwibWluZ3VvXCJcbiAgICB9XSksIF90aGlzMTUuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9ICEwO1xuICAgIHJldHVybiBfdGhpczE1O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUm9jSGVscGVyKTtcbn0oR3JlZ29yaWFuQmFzZUhlbHBlcik7XG52YXIgQnVkZGhpc3RIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HcmVnb3JpYW5CYXNlSGVscGVyMykge1xuICBfaW5oZXJpdHMoQnVkZGhpc3RIZWxwZXIsIF9HcmVnb3JpYW5CYXNlSGVscGVyMyk7XG4gIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihCdWRkaGlzdEhlbHBlcik7XG4gIGZ1bmN0aW9uIEJ1ZGRoaXN0SGVscGVyKCkge1xuICAgIHZhciBfdGhpczE2O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWRkaGlzdEhlbHBlcik7XG4gICAgX3RoaXMxNiA9IF9zdXBlcjE3LmNhbGwodGhpcywgXCJidWRkaGlzdFwiLCBbe1xuICAgICAgbmFtZTogXCJiZVwiLFxuICAgICAgaGFzWWVhclplcm86ICEwLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogLTU0MyxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfVxuICAgIH1dKSwgX3RoaXMxNi5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gITA7XG4gICAgcmV0dXJuIF90aGlzMTY7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhCdWRkaGlzdEhlbHBlcik7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIEdyZWdvcnlIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HcmVnb3JpYW5CYXNlSGVscGVyNCkge1xuICBfaW5oZXJpdHMoR3JlZ29yeUhlbHBlciwgX0dyZWdvcmlhbkJhc2VIZWxwZXI0KTtcbiAgdmFyIF9zdXBlcjE4ID0gX2NyZWF0ZVN1cGVyKEdyZWdvcnlIZWxwZXIpO1xuICBmdW5jdGlvbiBHcmVnb3J5SGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmVnb3J5SGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTguY2FsbCh0aGlzLCBcImdyZWdvcnlcIiwgW3tcbiAgICAgIG5hbWU6IFwiY2VcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDEsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImJjZVwiLFxuICAgICAgcmV2ZXJzZU9mOiBcImNlXCJcbiAgICB9XSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEdyZWdvcnlIZWxwZXIsIFt7XG4gICAga2V5OiBcInJldmlzZUludGxFcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2aXNlSW50bEVyYShlKSB7XG4gICAgICB2YXIgdCA9IGUuZXJhLFxuICAgICAgICByID0gZS5lcmFZZWFyO1xuICAgICAgcmV0dXJuIFwiYmNcIiAhPT0gdCAmJiBcImJcIiAhPT0gdCB8fCAodCA9IFwiYmNlXCIpLCBcImFkXCIgIT09IHQgJiYgXCJhXCIgIT09IHQgfHwgKHQgPSBcImNlXCIpLCB7XG4gICAgICAgIGVyYTogdCxcbiAgICAgICAgZXJhWWVhcjogclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdyZWdvcnlIZWxwZXI7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIEphcGFuZXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3JlZ29yaWFuQmFzZUhlbHBlcjUpIHtcbiAgX2luaGVyaXRzKEphcGFuZXNlSGVscGVyLCBfR3JlZ29yaWFuQmFzZUhlbHBlcjUpO1xuICB2YXIgX3N1cGVyMTkgPSBfY3JlYXRlU3VwZXIoSmFwYW5lc2VIZWxwZXIpO1xuICBmdW5jdGlvbiBKYXBhbmVzZUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxNztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSmFwYW5lc2VIZWxwZXIpO1xuICAgIF90aGlzMTcgPSBfc3VwZXIxOS5jYWxsKHRoaXMsIFwiamFwYW5lc2VcIiwgW3tcbiAgICAgIG5hbWU6IFwicmVpd2FcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDIwMTksXG4gICAgICAgIG1vbnRoOiA1LFxuICAgICAgICBkYXk6IDFcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiAyMDE5LFxuICAgICAgICBtb250aDogNSxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJoZWlzZWlcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDE5ODksXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDhcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiAxOTg5LFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgZGF5OiA4XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJzaG93YVwiLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkyNixcbiAgICAgICAgbW9udGg6IDEyLFxuICAgICAgICBkYXk6IDI1XG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkyNixcbiAgICAgICAgbW9udGg6IDEyLFxuICAgICAgICBkYXk6IDI1XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJ0YWlzaG9cIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDE5MTIsXG4gICAgICAgIG1vbnRoOiA3LFxuICAgICAgICBkYXk6IDMwXG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkxMixcbiAgICAgICAgbW9udGg6IDcsXG4gICAgICAgIGRheTogMzBcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIm1laWppXCIsXG4gICAgICBpc29FcG9jaDoge1xuICAgICAgICB5ZWFyOiAxODY4LFxuICAgICAgICBtb250aDogOSxcbiAgICAgICAgZGF5OiA4XG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTg2OCxcbiAgICAgICAgbW9udGg6IDksXG4gICAgICAgIGRheTogOFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiY2VcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDEsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImJjZVwiLFxuICAgICAgcmV2ZXJzZU9mOiBcImNlXCJcbiAgICB9XSksIF90aGlzMTcuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9ICEwLCBfdGhpczE3LmVyYUxlbmd0aCA9IFwibG9uZ1wiLCBfdGhpczE3LmVyYXNCZWdpbk1pZFllYXIgPSAhMDtcbiAgICByZXR1cm4gX3RoaXMxNztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoSmFwYW5lc2VIZWxwZXIsIFt7XG4gICAga2V5OiBcInJldmlzZUludGxFcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2aXNlSW50bEVyYShlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZXJhLFxuICAgICAgICBvID0gZS5lcmFZZWFyLFxuICAgICAgICBuID0gdC55ZWFyO1xuICAgICAgcmV0dXJuIHRoaXMuZXJhcy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLm5hbWUgPT09IHI7XG4gICAgICB9KSA/IHtcbiAgICAgICAgZXJhOiByLFxuICAgICAgICBlcmFZZWFyOiBvXG4gICAgICB9IDogbiA8IDEgPyB7XG4gICAgICAgIGVyYTogXCJiY2VcIixcbiAgICAgICAgZXJhWWVhcjogMSAtIG5cbiAgICAgIH0gOiB7XG4gICAgICAgIGVyYTogXCJjZVwiLFxuICAgICAgICBlcmFZZWFyOiBuXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSmFwYW5lc2VIZWxwZXI7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIENoaW5lc2VCYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTYpIHtcbiAgX2luaGVyaXRzKENoaW5lc2VCYXNlSGVscGVyLCBfSGVscGVyQmFzZTYpO1xuICB2YXIgX3N1cGVyMjAgPSBfY3JlYXRlU3VwZXIoQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICBmdW5jdGlvbiBDaGluZXNlQmFzZUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxODtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICAgIF90aGlzMTggPSBfc3VwZXIyMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczE4LmNhbGVuZGFyVHlwZSA9IFwibHVuaXNvbGFyXCIsIF90aGlzMTguaGFzRXJhID0gITE7XG4gICAgcmV0dXJuIF90aGlzMTg7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENoaW5lc2VCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0aGlzLmdldE1vbnRoTGlzdChlLnllYXIsIHQpO1xuICAgICAgcmV0dXJuIDEzID09PSB3dChyKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoZSwgdCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihlLCB0KSA/IDEzIDogMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMjk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heGltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhpbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1vbnRoTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aExpc3QoZSwgdCkge1xuICAgICAgdmFyIF90aGlzMTkgPSB0aGlzLFxuICAgICAgICBfZ2V0Q2FsZW5kYXJEYXRlMjtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHllYXJcIik7XG4gICAgICB2YXIgciA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBmdW5jOiBcImdldE1vbnRoTGlzdFwiLFxuICAgICAgICAgIGNhbGVuZGFyWWVhcjogZSxcbiAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9KSxcbiAgICAgICAgbyA9IHQuZ2V0KHIpO1xuICAgICAgaWYgKG8pIHJldHVybiBvO1xuICAgICAgdmFyIG4gPSB0aGlzLmdldEZvcm1hdHRlcigpLFxuICAgICAgICBnZXRDYWxlbmRhckRhdGUgPSBmdW5jdGlvbiBnZXRDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgICAgIHZhciByID0gdG9VdGNJc29EYXRlU3RyaW5nKHtcbiAgICAgICAgICAgICAgaXNvWWVhcjogZSxcbiAgICAgICAgICAgICAgaXNvTW9udGg6IDIsXG4gICAgICAgICAgICAgIGlzb0RheTogMVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvID0gbmV3IERhdGUocik7XG4gICAgICAgICAgby5zZXRVVENEYXRlKHQgKyAxKTtcbiAgICAgICAgICB2YXIgYSA9IG4uZm9ybWF0VG9QYXJ0cyhvKSxcbiAgICAgICAgICAgIGkgPSBhLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIiA9PT0gZS50eXBlO1xuICAgICAgICAgICAgfSkudmFsdWUsXG4gICAgICAgICAgICBzID0gK2EuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJkYXlcIiA9PT0gZS50eXBlO1xuICAgICAgICAgICAgfSkudmFsdWU7XG4gICAgICAgICAgdmFyIGwgPSBhLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcInJlbGF0ZWRZZWFyXCIgPT09IGUudHlwZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBsKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBsYWNrcyByZWxhdGVkWWVhciBpbiBcIi5jb25jYXQoX3RoaXMxOS5pZCwgXCIgY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuXCIpKTtcbiAgICAgICAgICByZXR1cm4gbCA9ICtsLnZhbHVlLCB7XG4gICAgICAgICAgICBjYWxlbmRhck1vbnRoU3RyaW5nOiBpLFxuICAgICAgICAgICAgY2FsZW5kYXJEYXk6IHMsXG4gICAgICAgICAgICBjYWxlbmRhclllYXJUb1ZlcmlmeTogbFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB2YXIgYSA9IDE3LFxuICAgICAgICBfZ2V0Q2FsZW5kYXJEYXRlID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLFxuICAgICAgICBpID0gX2dldENhbGVuZGFyRGF0ZS5jYWxlbmRhck1vbnRoU3RyaW5nLFxuICAgICAgICBzID0gX2dldENhbGVuZGFyRGF0ZS5jYWxlbmRhckRheSxcbiAgICAgICAgbCA9IF9nZXRDYWxlbmRhckRhdGUuY2FsZW5kYXJZZWFyVG9WZXJpZnk7XG4gICAgICBcIjFcIiAhPT0gaSAmJiAoYSArPSAyOSwgKF9nZXRDYWxlbmRhckRhdGUyID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLCBpID0gX2dldENhbGVuZGFyRGF0ZTIuY2FsZW5kYXJNb250aFN0cmluZywgcyA9IF9nZXRDYWxlbmRhckRhdGUyLmNhbGVuZGFyRGF5KSksIGEgLT0gcyAtIDU7XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIG0sXG4gICAgICAgIGMsXG4gICAgICAgIGggPSAxLFxuICAgICAgICB1ID0gITE7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBfZ2V0Q2FsZW5kYXJEYXRlMztcbiAgICAgICAgKF9nZXRDYWxlbmRhckRhdGUzID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLCBpID0gX2dldENhbGVuZGFyRGF0ZTMuY2FsZW5kYXJNb250aFN0cmluZywgcyA9IF9nZXRDYWxlbmRhckRhdGUzLmNhbGVuZGFyRGF5LCBsID0gX2dldENhbGVuZGFyRGF0ZTMuY2FsZW5kYXJZZWFyVG9WZXJpZnkpLCBtICYmIChkW2NdLmRheXNJbk1vbnRoID0gbSArIDMwIC0gcyksIGwgIT09IGUgPyB1ID0gITAgOiAoZFtpXSA9IHtcbiAgICAgICAgICBtb250aEluZGV4OiBoKytcbiAgICAgICAgfSwgYSArPSAzMCksIG0gPSBzLCBjID0gaTtcbiAgICAgIH0gd2hpbGUgKCF1KTtcbiAgICAgIHJldHVybiBkW2NdLmRheXNJbk1vbnRoID0gbSArIDMwIC0gcywgdC5zZXQociwgZCksIGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXIsXG4gICAgICAgIHIgPSBlLm1vbnRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogdCxcbiAgICAgICAgbW9udGg6IHIgPj0gMTIgPyAxMiA6IHIgKyAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENhbGVuZGFyRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogITE7XG4gICAgICB2YXIgbiA9IGUueWVhcixcbiAgICAgICAgYSA9IGUubW9udGgsXG4gICAgICAgIGkgPSBlLm1vbnRoRXh0cmEsXG4gICAgICAgIHMgPSBlLmRheSxcbiAgICAgICAgbCA9IGUubW9udGhDb2RlLFxuICAgICAgICBkID0gZS5lcmFZZWFyO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgaWYgKG4gPSBkLCBpICYmIFwiYmlzXCIgIT09IGkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBsZWFwIG1vbnRoIHN1ZmZpeDogXCIuY29uY2F0KGkpKTtcbiAgICAgICAgdmFyIF9lNDkgPSBidWlsZE1vbnRoQ29kZShhLCB2b2lkIDAgIT09IGkpLFxuICAgICAgICAgIF9yNjUgPSBcIlwiLmNvbmNhdChhKS5jb25jYXQoaSB8fCBcIlwiKSxcbiAgICAgICAgICBfbzQwID0gdGhpcy5nZXRNb250aExpc3QobiwgdClbX3I2NV07XG4gICAgICAgIGlmICh2b2lkIDAgPT09IF9vNDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5tYXRjaGVkIG1vbnRoIFwiLmNvbmNhdChfcjY1LCBcIiBpbiBDaGluZXNlIHllYXIgXCIpLmNvbmNhdChuKSk7XG4gICAgICAgIHJldHVybiBhID0gX280MC5tb250aEluZGV4LCB7XG4gICAgICAgICAgeWVhcjogbixcbiAgICAgICAgICBtb250aDogYSxcbiAgICAgICAgICBkYXk6IHMsXG4gICAgICAgICAgZXJhOiB2b2lkIDAsXG4gICAgICAgICAgZXJhWWVhcjogZCxcbiAgICAgICAgICBtb250aENvZGU6IF9lNDlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpLCB2b2lkIDAgPT09IG4gJiYgKG4gPSBkKSwgdm9pZCAwID09PSBkICYmIChkID0gbiksIHZvaWQgMCA9PT0gYSkge1xuICAgICAgICB2YXIgX2U1MCA9IHRoaXMuZ2V0TW9udGhMaXN0KG4sIHQpO1xuICAgICAgICB2YXIgX280MSA9IGwucmVwbGFjZShcIkxcIiwgXCJiaXNcIikuc2xpY2UoMSk7XG4gICAgICAgIFwiMFwiID09PSBfbzQxWzBdICYmIChfbzQxID0gX280MS5zbGljZSgxKSk7XG4gICAgICAgIHZhciBfaTE5ID0gX2U1MFtfbzQxXTtcbiAgICAgICAgaWYgKGEgPSBfaTE5ICYmIF9pMTkubW9udGhJbmRleCwgdm9pZCAwID09PSBhICYmIGwuZW5kc1dpdGgoXCJMXCIpICYmIFwiTTEzTFwiICE9IGwgJiYgXCJjb25zdHJhaW5cIiA9PT0gcikge1xuICAgICAgICAgIHZhciBfdDQ4ID0gbC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgXCIwXCIgPT09IF90NDhbMF0gJiYgKF90NDggPSBfdDQ4LnNsaWNlKDEpKSwgX2kxOSA9IF9lNTBbX3Q0OF0sIF9pMTkgJiYgKGEgPSBfaTE5Lm1vbnRoSW5kZXgsIGwgPSBidWlsZE1vbnRoQ29kZShfdDQ4KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbm1hdGNoZWQgbW9udGggXCIuY29uY2F0KGwsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH0gZWxzZSBpZiAodm9pZCAwID09PSBsKSB7XG4gICAgICAgIHZhciBfZTUxID0gdGhpcy5nZXRNb250aExpc3QobiwgdCksXG4gICAgICAgICAgX280MiA9IHd0KF9lNTEpLFxuICAgICAgICAgIF9pMjAgPSBfbzQyLmxlbmd0aDtcbiAgICAgICAgXCJyZWplY3RcIiA9PT0gciA/IChSZWplY3RUb1JhbmdlKGEsIDEsIF9pMjApLCBSZWplY3RUb1JhbmdlKHMsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKCkpKSA6IChhID0gQ29uc3RyYWluVG9SYW5nZShhLCAxLCBfaTIwKSwgcyA9IENvbnN0cmFpblRvUmFuZ2UocywgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoKSkpO1xuICAgICAgICB2YXIgX2QxMSA9IF9vNDIuZmluZChmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgICAgdmFyIF9yZWYxMSA9IF9zbGljZWRUb0FycmF5KF9yZWYxMCwgMiksXG4gICAgICAgICAgICBlID0gX3JlZjExWzFdO1xuICAgICAgICAgIHJldHVybiBlLm1vbnRoSW5kZXggPT09IGE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodm9pZCAwID09PSBfZDExKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbW9udGggXCIuY29uY2F0KGEsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgICAgbCA9IGJ1aWxkTW9udGhDb2RlKF9kMTFbMF0ucmVwbGFjZShcImJpc1wiLCBcIlwiKSwgLTEgIT09IF9kMTFbMF0uaW5kZXhPZihcImJpc1wiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2U1MiA9IHRoaXMuZ2V0TW9udGhMaXN0KG4sIHQpO1xuICAgICAgICB2YXIgX3I2NiA9IGwucmVwbGFjZShcIkxcIiwgXCJiaXNcIikuc2xpY2UoMSk7XG4gICAgICAgIFwiMFwiID09PSBfcjY2WzBdICYmIChfcjY2ID0gX3I2Ni5zbGljZSgxKSk7XG4gICAgICAgIHZhciBfbzQzID0gX2U1MltfcjY2XTtcbiAgICAgICAgaWYgKCFfbzQzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVubWF0Y2hlZCBtb250aENvZGUgXCIuY29uY2F0KGwsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgICAgaWYgKGEgIT09IF9vNDMubW9udGhJbmRleCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJtb250aENvZGUgXCIuY29uY2F0KGwsIFwiIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCBcIikuY29uY2F0KGEsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZSksIHt9LCB7XG4gICAgICAgIHllYXI6IG4sXG4gICAgICAgIGVyYVllYXI6IGQsXG4gICAgICAgIG1vbnRoOiBhLFxuICAgICAgICBtb250aENvZGU6IGwsXG4gICAgICAgIGRheTogc1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaGluZXNlQmFzZUhlbHBlcjtcbn0oSGVscGVyQmFzZSk7XG52YXIgQ2hpbmVzZUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoaW5lc2VCYXNlSGVscGVyKSB7XG4gIF9pbmhlcml0cyhDaGluZXNlSGVscGVyLCBfQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoQ2hpbmVzZUhlbHBlcik7XG4gIGZ1bmN0aW9uIENoaW5lc2VIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMjA7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoaW5lc2VIZWxwZXIpO1xuICAgIF90aGlzMjAgPSBfc3VwZXIyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczIwLmlkID0gXCJjaGluZXNlXCI7XG4gICAgcmV0dXJuIF90aGlzMjA7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDaGluZXNlSGVscGVyKTtcbn0oQ2hpbmVzZUJhc2VIZWxwZXIpO1xudmFyIERhbmdpSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hpbmVzZUJhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhEYW5naUhlbHBlciwgX0NoaW5lc2VCYXNlSGVscGVyMik7XG4gIHZhciBfc3VwZXIyMiA9IF9jcmVhdGVTdXBlcihEYW5naUhlbHBlcik7XG4gIGZ1bmN0aW9uIERhbmdpSGVscGVyKCkge1xuICAgIHZhciBfdGhpczIxO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYW5naUhlbHBlcik7XG4gICAgX3RoaXMyMSA9IF9zdXBlcjIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMjEuaWQgPSBcImRhbmdpXCI7XG4gICAgcmV0dXJuIF90aGlzMjE7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEYW5naUhlbHBlcik7XG59KENoaW5lc2VCYXNlSGVscGVyKTtcbnZhciBOb25Jc29DYWxlbmRhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vbklzb0NhbGVuZGFyKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9uSXNvQ2FsZW5kYXIpO1xuICAgIHRoaXMuaGVscGVyID0gZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTm9uSXNvQ2FsZW5kYXIsIFt7XG4gICAga2V5OiBcImRhdGVGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGVGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gbmV3IE9uZU9iamVjdENhY2hlKCksXG4gICAgICAgIG4gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgdGhpcy5maWVsZHMoW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLFxuICAgICAgICBhID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpLFxuICAgICAgICBfdGhpcyRoZWxwZXIkY2FsZW5kYXIgPSB0aGlzLmhlbHBlci5jYWxlbmRhclRvSXNvRGF0ZShuLCBhLCBvKSxcbiAgICAgICAgaSA9IF90aGlzJGhlbHBlciRjYWxlbmRhci55ZWFyLFxuICAgICAgICBzID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyLm1vbnRoLFxuICAgICAgICBsID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyLmRheSxcbiAgICAgICAgZCA9IENyZWF0ZVRlbXBvcmFsRGF0ZShpLCBzLCBsLCByKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck1vbnRoRnJvbUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5ZWFyTW9udGhGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gbmV3IE9uZU9iamVjdENhY2hlKCksXG4gICAgICAgIG4gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgdGhpcy5maWVsZHMoW1wibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLFxuICAgICAgICBhID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpLFxuICAgICAgICBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG4pLCB7fSwge1xuICAgICAgICAgIGRheTogMVxuICAgICAgICB9KSwgYSwgbyksXG4gICAgICAgIGkgPSBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyLnllYXIsXG4gICAgICAgIHMgPSBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyLm1vbnRoLFxuICAgICAgICBsID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyMi5kYXksXG4gICAgICAgIGQgPSBDcmVhdGVUZW1wb3JhbFllYXJNb250aChpLCBzLCByLCBsKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhEYXlGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoRGF5RnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IG5ldyBPbmVPYmplY3RDYWNoZSgpLFxuICAgICAgICBuID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIHRoaXMuZmllbGRzKFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSxcbiAgICAgICAgYSA9IFRvVGVtcG9yYWxPdmVyZmxvdyh0KSxcbiAgICAgICAgX3RoaXMkaGVscGVyJG1vbnRoRGF5ID0gdGhpcy5oZWxwZXIubW9udGhEYXlGcm9tRmllbGRzKG4sIGEsIG8pLFxuICAgICAgICBpID0gX3RoaXMkaGVscGVyJG1vbnRoRGF5LnllYXIsXG4gICAgICAgIHMgPSBfdGhpcyRoZWxwZXIkbW9udGhEYXkubW9udGgsXG4gICAgICAgIGwgPSBfdGhpcyRoZWxwZXIkbW9udGhEYXkuZGF5LFxuICAgICAgICBkID0gQ3JlYXRlVGVtcG9yYWxNb250aERheShzLCBsLCByLCBpKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpZWxkcyhlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICByZXR1cm4gVHQuY2FsbCh0LCBcInllYXJcIikgJiYgKHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHQpLCBbXCJlcmFcIiwgXCJlcmFZZWFyXCJdKSksIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkS2V5c1RvSWdub3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpZWxkS2V5c1RvSWdub3JlKGUpIHtcbiAgICAgIHZhciB0ID0gbmV3IER0KCk7XG4gICAgICBmb3IgKHZhciBfcjY3ID0gMDsgX3I2NyA8IGUubGVuZ3RoOyBfcjY3KyspIHtcbiAgICAgICAgdmFyIF9vNDQgPSBlW19yNjddO1xuICAgICAgICBzd2l0Y2ggKENhbGwodnQsIHQsIFtfbzQ0XSksIF9vNDQpIHtcbiAgICAgICAgICBjYXNlIFwiZXJhXCI6XG4gICAgICAgICAgICBDYWxsKHZ0LCB0LCBbXCJlcmFZZWFyXCJdKSwgQ2FsbCh2dCwgdCwgW1wieWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJhWWVhclwiOlxuICAgICAgICAgICAgQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wieWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAgQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIENhbGwodnQsIHQsIFtcIm1vbnRoQ29kZVwiXSksIHRoaXMuaGVscGVyLmVyYXNCZWdpbk1pZFllYXIgJiYgKENhbGwodnQsIHQsIFtcImVyYVwiXSksIENhbGwodnQsIHQsIFtcImVyYVllYXJcIl0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtb250aENvZGVcIjpcbiAgICAgICAgICAgIENhbGwodnQsIHQsIFtcIm1vbnRoXCJdKSwgdGhpcy5oZWxwZXIuZXJhc0JlZ2luTWlkWWVhciAmJiAoQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICAgICAgdGhpcy5oZWxwZXIuZXJhc0JlZ2luTWlkWWVhciAmJiAoQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KENhbGwoQ3QsIHQsIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVBZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZUFkZChlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gICAgICB2YXIgcyA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpLFxuICAgICAgICBsID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCBzKSxcbiAgICAgICAgZCA9IHRoaXMuaGVscGVyLmFkZENhbGVuZGFyKGwsIHtcbiAgICAgICAgICB5ZWFyczogdCxcbiAgICAgICAgICBtb250aHM6IHIsXG4gICAgICAgICAgd2Vla3M6IG8sXG4gICAgICAgICAgZGF5czogblxuICAgICAgICB9LCBhLCBzKSxcbiAgICAgICAgbSA9IHRoaXMuaGVscGVyLmNhbGVuZGFyVG9Jc29EYXRlKGQsIFwiY29uc3RyYWluXCIsIHMpLFxuICAgICAgICBjID0gbS55ZWFyLFxuICAgICAgICBoID0gbS5tb250aCxcbiAgICAgICAgdSA9IG0uZGF5LFxuICAgICAgICBUID0gQ3JlYXRlVGVtcG9yYWxEYXRlKGMsIGgsIHUsIGkpO1xuICAgICAgcmV0dXJuIG5ldyBPbmVPYmplY3RDYWNoZShzKS5zZXRPYmplY3QoVCksIFQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVVbnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlVW50aWwoZSwgdCwgcikge1xuICAgICAgdmFyIG8gPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgbiA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KHQpLFxuICAgICAgICBhID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCBvKSxcbiAgICAgICAgaSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUodCwgbik7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIudW50aWxDYWxlbmRhcihhLCBpLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5ZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZSk7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCB0KS55ZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aChlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkubW9udGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXkoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGUsIHQpLmRheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYShlKSB7XG4gICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGUsIHQpLmVyYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcmFZZWFyKGUpIHtcbiAgICAgIGlmICghdGhpcy5oZWxwZXIuaGFzRXJhKSByZXR1cm47XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkuZXJhWWVhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoQ29kZShlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkubW9udGhDb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5T2ZXZWVrKGUpIHtcbiAgICAgIHJldHVybiBPdC5pc284NjAxLmRheU9mV2VlayhlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheU9mWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpLFxuICAgICAgICByID0gdGhpcy5oZWxwZXIuaXNvVG9DYWxlbmRhckRhdGUoZSwgdCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLmNhbGVuZGFyRGF5c1VudGlsKG8sIHIsIHQpICsgMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3ZWVrT2ZZZWFyKGUpIHtcbiAgICAgIHJldHVybiBPdC5pc284NjAxLndlZWtPZlllYXIoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgICByZXR1cm4gT3QuaXNvODYwMS55ZWFyT2ZXZWVrKGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5XZWVrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbldlZWsoZSkge1xuICAgICAgcmV0dXJuIE90Lmlzbzg2MDEuZGF5c0luV2VlayhlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5c0luTW9udGgoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgciA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci5tYXhpbXVtTW9udGhMZW5ndGgocik7XG4gICAgICBpZiAobyA9PT0gdGhpcy5oZWxwZXIubWluaW11bU1vbnRoTGVuZ3RoKHIpKSByZXR1cm4gbztcbiAgICAgIHZhciBuID0gdGhpcy5oZWxwZXIuc3RhcnRPZkNhbGVuZGFyTW9udGgociksXG4gICAgICAgIGEgPSB0aGlzLmhlbHBlci5hZGRNb250aHNDYWxlbmRhcihuLCAxLCBcImNvbnN0cmFpblwiLCB0KTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChuLCBhLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIEhhc1Nsb3QodCwgaSkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSk7XG4gICAgICB2YXIgciA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KHQpLFxuICAgICAgICBvID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZSh0LCByKSxcbiAgICAgICAgbiA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhclllYXIobyksXG4gICAgICAgIGEgPSB0aGlzLmhlbHBlci5hZGRDYWxlbmRhcihuLCB7XG4gICAgICAgICAgeWVhcnM6IDFcbiAgICAgICAgfSwgXCJjb25zdHJhaW5cIiwgcik7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIuY2FsZW5kYXJEYXlzVW50aWwobiwgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgciA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCk7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIubW9udGhzSW5ZZWFyKHIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgSGFzU2xvdCh0LCBpKSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKTtcbiAgICAgIHZhciByID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QodCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKHQsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLmluTGVhcFllYXIobywgcik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb25Jc29DYWxlbmRhcjtcbn0oKTtcbmZvciAodmFyIF9pMjEgPSAwLCBfYXJyNyA9IFtIZWJyZXdIZWxwZXIsIFBlcnNpYW5IZWxwZXIsIEV0aGlvcGljSGVscGVyLCBFdGhpb2FhSGVscGVyLCBDb3B0aWNIZWxwZXIsIENoaW5lc2VIZWxwZXIsIERhbmdpSGVscGVyLCBSb2NIZWxwZXIsIEluZGlhbkhlbHBlciwgQnVkZGhpc3RIZWxwZXIsIEdyZWdvcnlIZWxwZXIsIEphcGFuZXNlSGVscGVyLCBJc2xhbWljSGVscGVyLCBJc2xhbWljVW1hbHF1cmFIZWxwZXIsIElzbGFtaWNUYmxhSGVscGVyLCBJc2xhbWljQ2l2aWxIZWxwZXIsIElzbGFtaWNSZ3NhSGVscGVyLCBJc2xhbWljQ2NIZWxwZXJdOyBfaTIxIDwgX2FycjcubGVuZ3RoOyBfaTIxKyspIHtcbiAgdmFyIF9lNTMgPSBfYXJyN1tfaTIxXTtcbiAgdmFyIF90NDkgPSBuZXcgX2U1MygpO1xuICBPdFtfdDQ5LmlkXSA9IG5ldyBOb25Jc29DYWxlbmRhcihfdDQ5KTtcbn1cbnZhciBQbGFpbkRhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpbkRhdGUoZSwgdCwgcikge1xuICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcImlzbzg2MDFcIjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5EYXRlKTtcbiAgICBDcmVhdGVUZW1wb3JhbERhdGVTbG90cyh0aGlzLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odCksIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHIpLCBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUobykpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpbkRhdGUsIFt7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRXJhWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoQ29kZShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZXZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJXZWVrT2ZZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5ZWFyT2ZXZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJPZldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbldlZWtcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBSZWplY3RUZW1wb3JhbExpa2VPYmplY3QoZSk7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBuID0gQ2FsZW5kYXJGaWVsZHMobywgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKTtcbiAgICAgIHZhciBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIG4sIFtdKTtcbiAgICAgIHJldHVybiBhID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhvLCBhLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgbiwgXCJwYXJ0aWFsXCIpKSwgYSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhhLCBuLCBbXSksIENhbGVuZGFyRGF0ZUZyb21GaWVsZHMobywgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlKEdldFNsb3QodGhpcywgaSksIEdldFNsb3QodGhpcywgcyksIEdldFNsb3QodGhpcywgbCksIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsRHVyYXRpb24oZSksXG4gICAgICAgIG8gPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIHApLCB0aGlzLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKFRvVGVtcG9yYWxEdXJhdGlvbihlKSksXG4gICAgICAgIG8gPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIHApLCB0aGlzLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlKFwidW50aWxcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmNlKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluRGF0ZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfYXJyOCA9IFtpLCBzLCBsXTsgX2kyMiA8IF9hcnI4Lmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgIHZhciBfZTU0ID0gX2FycjhbX2kyMl07XG4gICAgICAgIGlmIChHZXRTbG90KHRoaXMsIF9lNTQpICE9PSBHZXRTbG90KHQsIF9lNTQpKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBwKSwgR2V0U2xvdCh0LCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMsIFRvQ2FsZW5kYXJOYW1lT3B0aW9uKEdldE9wdGlvbnNPYmplY3QoZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBuZXcgaHQoZSwgdCkuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluRGF0ZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBpKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgcyksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBuID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHQsIHIsIG8sIDAsIDAsIDAsIDAsIDAsIDAsIG4pO1xuICAgICAgdmFyIGEgPSBUb1RlbXBvcmFsVGltZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHQsIHIsIG8sIEdldFNsb3QoYSwgZCksIEdldFNsb3QoYSwgbSksIEdldFNsb3QoYSwgYyksIEdldFNsb3QoYSwgaCksIEdldFNsb3QoYSwgdSksIEdldFNsb3QoYSwgVCksIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1pvbmVkRGF0ZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9ab25lZERhdGVUaW1lKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQsIHI7XG4gICAgICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lWm9uZShlKSkgdCA9IGU7ZWxzZSB7XG4gICAgICAgICAgdmFyIF9vNDUgPSBlLnRpbWVab25lO1xuICAgICAgICAgIHZvaWQgMCA9PT0gX280NSA/IHQgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSkgOiAodCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShfbzQ1KSwgciA9IGUucGxhaW5UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHQgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSk7XG4gICAgICB2YXIgbyA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIGEgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBmID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgeSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICB2YXIgSSA9IDAsXG4gICAgICAgIFMgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgdyA9IDAsXG4gICAgICAgIEQgPSAwLFxuICAgICAgICBHID0gMDtcbiAgICAgIHZvaWQgMCAhPT0gciAmJiAociA9IFRvVGVtcG9yYWxUaW1lKHIpLCBJID0gR2V0U2xvdChyLCBkKSwgUyA9IEdldFNsb3QociwgbSksIGcgPSBHZXRTbG90KHIsIGMpLCB3ID0gR2V0U2xvdChyLCBoKSwgRCA9IEdldFNsb3QociwgdSksIEcgPSBHZXRTbG90KHIsIFQpKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKHQsIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUobywgYSwgZiwgSSwgUywgZywgdywgRCwgRywgeSksIFwiY29tcGF0aWJsZVwiKSwgbiksIHQsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluWWVhck1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluTW9udGhEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbk1vbnRoRGF5KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBpc29EYXk6IEdldFNsb3QodGhpcywgbCksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIGkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxlbmRhcigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxEYXRlKGUpID8gKFRvVGVtcG9yYWxPdmVyZmxvdyhyKSwgQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QoZSwgcCkpKSA6IFRvVGVtcG9yYWxEYXRlKGUsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgbyA9IFRvVGVtcG9yYWxEYXRlKHQpO1xuICAgICAgcmV0dXJuIENvbXBhcmVJU09EYXRlKEdldFNsb3QociwgaSksIEdldFNsb3QociwgcyksIEdldFNsb3QociwgbCksIEdldFNsb3QobywgaSksIEdldFNsb3QobywgcyksIEdldFNsb3QobywgbCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGxhaW5EYXRlO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluRGF0ZSwgXCJUZW1wb3JhbC5QbGFpbkRhdGVcIik7XG52YXIgUGxhaW5EYXRlVGltZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYWluRGF0ZVRpbWUoZSwgdCwgcikge1xuICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICAgIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAwO1xuICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiAwO1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiAwO1xuICAgIHZhciBkID0gYXJndW1lbnRzLmxlbmd0aCA+IDkgJiYgYXJndW1lbnRzWzldICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOV0gOiBcImlzbzg2MDFcIjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5EYXRlVGltZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKHRoaXMsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0KSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24ociksIHZvaWQgMCA9PT0gbyA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihvKSwgdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKG4pLCB2b2lkIDAgPT09IGEgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24oYSksIHZvaWQgMCA9PT0gaSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihpKSwgdm9pZCAwID09PSBzID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHMpLCB2b2lkIDAgPT09IGwgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obCksIFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShkKSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFBsYWluRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5ZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoQ29kZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaG91clwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbnV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWljcm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIHUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYW5vc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZlllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhck9mV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd2l0aChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW10pO1xuICAgICAgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHMobywgYSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFwicGFydGlhbFwiKSksIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYSwgbiwgW10pO1xuICAgICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDQgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKG8sIGEsIHIpLFxuICAgICAgICBpID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC55ZWFyLFxuICAgICAgICBzID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5tb250aCxcbiAgICAgICAgbCA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDQuZGF5LFxuICAgICAgICBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5ob3VyLFxuICAgICAgICBtID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5taW51dGUsXG4gICAgICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ0LnNlY29uZCxcbiAgICAgICAgaCA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDQubWlsbGlzZWNvbmQsXG4gICAgICAgIHUgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ0Lm1pY3Jvc2Vjb25kLFxuICAgICAgICBUID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5uYW5vc2Vjb25kO1xuICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhQbGFpblRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFBsYWluVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIHIgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgbiA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh0LCByLCBvLCAwLCAwLCAwLCAwLCAwLCAwLCBuKTtcbiAgICAgIHZhciBhID0gVG9UZW1wb3JhbFRpbWUoZSk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh0LCByLCBvLCBHZXRTbG90KGEsIGQpLCBHZXRTbG90KGEsIG0pLCBHZXRTbG90KGEsIGMpLCBHZXRTbG90KGEsIGgpLCBHZXRTbG90KGEsIHUpLCBHZXRTbG90KGEsIFQpLCBuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFBsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIHIgPSBHZXRTbG90KHQsIGkpLFxuICAgICAgICBvID0gR2V0U2xvdCh0LCBzKSxcbiAgICAgICAgbiA9IEdldFNsb3QodCwgbCk7XG4gICAgICB2YXIgYSA9IEdldFNsb3QodCwgcCk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QodGhpcywgZCksXG4gICAgICAgIHkgPSBHZXRTbG90KHRoaXMsIG0pLFxuICAgICAgICBJID0gR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgUyA9IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIGcgPSBHZXRTbG90KHRoaXMsIHUpLFxuICAgICAgICB3ID0gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICAgIHJldHVybiBhID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBwKSwgYSksIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUociwgbywgbiwgZiwgeSwgSSwgUywgZywgdywgYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUoZSk7XG4gICAgICByZXR1cm4gbmV3IFBsYWluRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBpKSwgR2V0U2xvdCh0aGlzLCBzKSwgR2V0U2xvdCh0aGlzLCBsKSwgR2V0U2xvdCh0aGlzLCBkKSwgR2V0U2xvdCh0aGlzLCBtKSwgR2V0U2xvdCh0aGlzLCBjKSwgR2V0U2xvdCh0aGlzLCBoKSwgR2V0U2xvdCh0aGlzLCB1KSwgR2V0U2xvdCh0aGlzLCBUKSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShcInN1YnRyYWN0XCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnRpbChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlVGltZShcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlVGltZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZChlKSB7XG4gICAgICB2YXIgX1JvdW5kSVNPRGF0ZVRpbWUyO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHQgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgbiA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUsIFtcImRheVwiXSksXG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgIG1pbnV0ZTogNjAsXG4gICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICAgIH1bbl07XG4gICAgICBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQociwgYSwgMSA9PT0gYSk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIHkgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBJID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgUyA9IEdldFNsb3QodGhpcywgZCksXG4gICAgICAgIGcgPSBHZXRTbG90KHRoaXMsIG0pLFxuICAgICAgICB3ID0gR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgRCA9IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIEcgPSBHZXRTbG90KHRoaXMsIHUpLFxuICAgICAgICB2ID0gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICAgIHJldHVybiAoX1JvdW5kSVNPRGF0ZVRpbWUyID0gUm91bmRJU09EYXRlVGltZShmLCB5LCBJLCBTLCBnLCB3LCBELCBHLCB2LCByLCBuLCBvKSwgZiA9IF9Sb3VuZElTT0RhdGVUaW1lMi55ZWFyLCB5ID0gX1JvdW5kSVNPRGF0ZVRpbWUyLm1vbnRoLCBJID0gX1JvdW5kSVNPRGF0ZVRpbWUyLmRheSwgUyA9IF9Sb3VuZElTT0RhdGVUaW1lMi5ob3VyLCBnID0gX1JvdW5kSVNPRGF0ZVRpbWUyLm1pbnV0ZSwgdyA9IF9Sb3VuZElTT0RhdGVUaW1lMi5zZWNvbmQsIEQgPSBfUm91bmRJU09EYXRlVGltZTIubWlsbGlzZWNvbmQsIEcgPSBfUm91bmRJU09EYXRlVGltZTIubWljcm9zZWNvbmQsIHYgPSBfUm91bmRJU09EYXRlVGltZTIubmFub3NlY29uZCksIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoZiwgeSwgSSwgUywgZywgdywgRCwgRywgdiwgR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZVRpbWUoZSk7XG4gICAgICBmb3IgKHZhciBfaTIzID0gMCwgX2FycjkgPSBbaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVF07IF9pMjMgPCBfYXJyOS5sZW5ndGg7IF9pMjMrKykge1xuICAgICAgICB2YXIgX2U1NSA9IF9hcnI5W19pMjNdO1xuICAgICAgICBpZiAoR2V0U2xvdCh0aGlzLCBfZTU1KSAhPT0gR2V0U2xvdCh0LCBfZTU1KSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QodCwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0NhbGVuZGFyTmFtZU9wdGlvbih0KSxcbiAgICAgICAgbyA9IFRvRnJhY3Rpb25hbFNlY29uZERpZ2l0cyh0KSxcbiAgICAgICAgbiA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUodCwgXCJ0cnVuY1wiKSxcbiAgICAgICAgYSA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgdm9pZCAwKTtcbiAgICAgIGlmIChcImhvdXJcIiA9PT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBtdXN0IGJlIGEgdGltZSB1bml0IG90aGVyIHRoYW4gXCJob3VyXCInKTtcbiAgICAgIHZhciBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uUmVjb3JkKGEsIG8pLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMi5wcmVjaXNpb24sXG4gICAgICAgIHMgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyLnVuaXQsXG4gICAgICAgIGwgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyLmluY3JlbWVudDtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgaSwgciwge1xuICAgICAgICB1bml0OiBzLFxuICAgICAgICBpbmNyZW1lbnQ6IGwsXG4gICAgICAgIHJvdW5kaW5nTW9kZTogblxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKHRoaXMsIFwiYXV0b1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5EYXRlVGltZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9ab25lZERhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKHIsIHRoaXMsIFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihHZXRPcHRpb25zT2JqZWN0KHQpKSksIG4pLCByLCBHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvRGF0ZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpblllYXJNb250aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluWWVhck1vbnRoKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIGUgPSBHZXRTbG90KHRoaXMsIHApO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhck1vbnRoRnJvbUZpZWxkcyhlLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgQ2FsZW5kYXJGaWVsZHMoZSwgW1wibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5Nb250aERheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5UaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5UaW1lKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBpc29Ib3VyOiBHZXRTbG90KHRoaXMsIGQpLFxuICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCB1KSxcbiAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBtKSxcbiAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgcyksXG4gICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgVCksXG4gICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgaXNvWWVhcjogR2V0U2xvdCh0aGlzLCBpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyT2JqZWN0KEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlLCB0KSB7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbERhdGVUaW1lKGUpID8gKFRvVGVtcG9yYWxPdmVyZmxvdyhyKSwgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KGUsIGQpLCBHZXRTbG90KGUsIG0pLCBHZXRTbG90KGUsIGMpLCBHZXRTbG90KGUsIGgpLCBHZXRTbG90KGUsIHUpLCBHZXRTbG90KGUsIFQpLCBHZXRTbG90KGUsIHApKSkgOiBUb1RlbXBvcmFsRGF0ZVRpbWUoZSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShlLCB0KSB7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxEYXRlVGltZShlKSxcbiAgICAgICAgbyA9IFRvVGVtcG9yYWxEYXRlVGltZSh0KTtcbiAgICAgIGZvciAodmFyIF9pMjQgPSAwLCBfYXJyMTAgPSBbaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVF07IF9pMjQgPCBfYXJyMTAubGVuZ3RoOyBfaTI0KyspIHtcbiAgICAgICAgdmFyIF9lNTYgPSBfYXJyMTBbX2kyNF07XG4gICAgICAgIHZhciBfdDUwID0gR2V0U2xvdChyLCBfZTU2KSxcbiAgICAgICAgICBfbjI3ID0gR2V0U2xvdChvLCBfZTU2KTtcbiAgICAgICAgaWYgKF90NTAgIT09IF9uMjcpIHJldHVybiBDb21wYXJpc29uUmVzdWx0KF90NTAgLSBfbjI3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGxhaW5EYXRlVGltZTtcbn0oKTtcbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpbkRhdGVUaW1lLCBcIlRlbXBvcmFsLlBsYWluRGF0ZVRpbWVcIik7XG52YXIgRHVyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEdXJhdGlvbigpIHtcbiAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogMDtcbiAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogMDtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogMDtcbiAgICB2YXIgZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ICYmIGFyZ3VtZW50c1s5XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzldIDogMDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVyYXRpb24pO1xuICAgIHZhciBtID0gdm9pZCAwID09PSBlID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoZSksXG4gICAgICBjID0gdm9pZCAwID09PSB0ID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwodCksXG4gICAgICBoID0gdm9pZCAwID09PSByID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwociksXG4gICAgICB1ID0gdm9pZCAwID09PSBvID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobyksXG4gICAgICBUID0gdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobiksXG4gICAgICBwID0gdm9pZCAwID09PSBhID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoYSksXG4gICAgICBmID0gdm9pZCAwID09PSBpID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoaSksXG4gICAgICB5ID0gdm9pZCAwID09PSBzID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwocyksXG4gICAgICBJID0gdm9pZCAwID09PSBsID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobCksXG4gICAgICBTID0gdm9pZCAwID09PSBkID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoZCk7XG4gICAgUmVqZWN0RHVyYXRpb24obSwgYywgaCwgdSwgVCwgcCwgZiwgeSwgSSwgUyksIE4odGhpcyksIFNldFNsb3QodGhpcywgdywgbSksIFNldFNsb3QodGhpcywgRCwgYyksIFNldFNsb3QodGhpcywgRywgaCksIFNldFNsb3QodGhpcywgdiwgdSksIFNldFNsb3QodGhpcywgQywgVCksIFNldFNsb3QodGhpcywgTywgcCksIFNldFNsb3QodGhpcywgYiwgZiksIFNldFNsb3QodGhpcywgRSwgeSksIFNldFNsb3QodGhpcywgTSwgSSksIFNldFNsb3QodGhpcywgUiwgUyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKER1cmF0aW9uLCBbe1xuICAgIGtleTogXCJ5ZWFyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndlZWtzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBHKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhvdXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWludXRlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgTyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWNyb3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYW5vc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgUik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEdXJhdGlvblNpZ24oR2V0U2xvdCh0aGlzLCB3KSwgR2V0U2xvdCh0aGlzLCBEKSwgR2V0U2xvdCh0aGlzLCBHKSwgR2V0U2xvdCh0aGlzLCB2KSwgR2V0U2xvdCh0aGlzLCBDKSwgR2V0U2xvdCh0aGlzLCBPKSwgR2V0U2xvdCh0aGlzLCBiKSwgR2V0U2xvdCh0aGlzLCBFKSwgR2V0U2xvdCh0aGlzLCBNKSwgR2V0U2xvdCh0aGlzLCBSKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJsYW5rXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gMCA9PT0gRHVyYXRpb25TaWduKEdldFNsb3QodGhpcywgdyksIEdldFNsb3QodGhpcywgRCksIEdldFNsb3QodGhpcywgRyksIEdldFNsb3QodGhpcywgdiksIEdldFNsb3QodGhpcywgQyksIEdldFNsb3QodGhpcywgTyksIEdldFNsb3QodGhpcywgYiksIEdldFNsb3QodGhpcywgRSksIEdldFNsb3QodGhpcywgTSksIEdldFNsb3QodGhpcywgUikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIFtcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pY3Jvc2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiLCBcIm1pbnV0ZXNcIiwgXCJtb250aHNcIiwgXCJuYW5vc2Vjb25kc1wiLCBcInNlY29uZHNcIiwgXCJ3ZWVrc1wiLCBcInllYXJzXCJdLCBcInBhcnRpYWxcIiksXG4gICAgICAgIF90JHllYXJzID0gdC55ZWFycyxcbiAgICAgICAgciA9IF90JHllYXJzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIHcpIDogX3QkeWVhcnMsXG4gICAgICAgIF90JG1vbnRocyA9IHQubW9udGhzLFxuICAgICAgICBvID0gX3QkbW9udGhzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIEQpIDogX3QkbW9udGhzLFxuICAgICAgICBfdCR3ZWVrcyA9IHQud2Vla3MsXG4gICAgICAgIG4gPSBfdCR3ZWVrcyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCBHKSA6IF90JHdlZWtzLFxuICAgICAgICBfdCRkYXlzID0gdC5kYXlzLFxuICAgICAgICBhID0gX3QkZGF5cyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCB2KSA6IF90JGRheXMsXG4gICAgICAgIF90JGhvdXJzID0gdC5ob3VycyxcbiAgICAgICAgaSA9IF90JGhvdXJzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIEMpIDogX3QkaG91cnMsXG4gICAgICAgIF90JG1pbnV0ZXMgPSB0Lm1pbnV0ZXMsXG4gICAgICAgIHMgPSBfdCRtaW51dGVzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIE8pIDogX3QkbWludXRlcyxcbiAgICAgICAgX3Qkc2Vjb25kcyA9IHQuc2Vjb25kcyxcbiAgICAgICAgbCA9IF90JHNlY29uZHMgPT09IHZvaWQgMCA/IEdldFNsb3QodGhpcywgYikgOiBfdCRzZWNvbmRzLFxuICAgICAgICBfdCRtaWxsaXNlY29uZHMgPSB0Lm1pbGxpc2Vjb25kcyxcbiAgICAgICAgZCA9IF90JG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCBFKSA6IF90JG1pbGxpc2Vjb25kcyxcbiAgICAgICAgX3QkbWljcm9zZWNvbmRzID0gdC5taWNyb3NlY29uZHMsXG4gICAgICAgIG0gPSBfdCRtaWNyb3NlY29uZHMgPT09IHZvaWQgMCA/IEdldFNsb3QodGhpcywgTSkgOiBfdCRtaWNyb3NlY29uZHMsXG4gICAgICAgIF90JG5hbm9zZWNvbmRzID0gdC5uYW5vc2Vjb25kcyxcbiAgICAgICAgYyA9IF90JG5hbm9zZWNvbmRzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIFIpIDogX3QkbmFub3NlY29uZHM7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWdhdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZWQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ3JlYXRlTmVnYXRlZFRlbXBvcmFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFic1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKE1hdGguYWJzKEdldFNsb3QodGhpcywgdykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEQpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBHKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgdikpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBPKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgYikpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEUpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgUikpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21EdXJhdGlvbihcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tRHVyYXRpb24oXCJzdWJ0cmFjdFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQodCkge1xuICAgICAgdmFyIF9VbmJhbGFuY2VEdXJhdGlvblJlbCwgX1JvdW5kRHVyYXRpb244LCBfQWRqdXN0Um91bmRlZER1cmF0aW8yLCBfQmFsYW5jZUR1cmF0aW9uMTEsIF9CYWxhbmNlRHVyYXRpb25SZWxhdDtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIHZhciByID0gR2V0U2xvdCh0aGlzLCB3KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRCksXG4gICAgICAgIG4gPSBHZXRTbG90KHRoaXMsIEcpLFxuICAgICAgICBhID0gR2V0U2xvdCh0aGlzLCB2KSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgQyksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIE8pLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBiKSxcbiAgICAgICAgZCA9IEdldFNsb3QodGhpcywgRSksXG4gICAgICAgIG0gPSBHZXRTbG90KHRoaXMsIE0pLFxuICAgICAgICBjID0gR2V0U2xvdCh0aGlzLCBSKSxcbiAgICAgICAgaCA9IERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpO1xuICAgICAgdmFyIHUgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCB0KSA6IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICB2YXIgVCA9IEdldFRlbXBvcmFsVW5pdCh1LCBcImxhcmdlc3RVbml0XCIsIFwiZGF0ZXRpbWVcIiwgdm9pZCAwLCBbXCJhdXRvXCJdKSxcbiAgICAgICAgZiA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdCh1KTtcbiAgICAgIHZhciB5ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHUpLFxuICAgICAgICBJID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh1LCBcImhhbGZFeHBhbmRcIik7XG4gICAgICB2YXIgUyA9IEdldFRlbXBvcmFsVW5pdCh1LCBcInNtYWxsZXN0VW5pdFwiLCBcImRhdGV0aW1lXCIsIHZvaWQgMCksXG4gICAgICAgIGcgPSAhMDtcbiAgICAgIFMgfHwgKGcgPSAhMSwgUyA9IFwibmFub3NlY29uZFwiKSwgaCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhoLCBTKTtcbiAgICAgIHZhciBGID0gITA7XG4gICAgICBpZiAoVCB8fCAoRiA9ICExLCBUID0gaCksIFwiYXV0b1wiID09PSBUICYmIChUID0gaCksICFnICYmICFGKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImF0IGxlYXN0IG9uZSBvZiBzbWFsbGVzdFVuaXQgb3IgbGFyZ2VzdFVuaXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFQsIFMpICE9PSBUKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImxhcmdlc3RVbml0IFwiLmNvbmNhdChULCBcIiBjYW5ub3QgYmUgc21hbGxlciB0aGFuIHNtYWxsZXN0VW5pdCBcIikuY29uY2F0KFMpKTtcbiAgICAgIHZhciBZID0ge1xuICAgICAgICBob3VyOiAyNCxcbiAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDFlMyxcbiAgICAgICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICB9W1NdO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gWSAmJiBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQoeSwgWSwgITEpLCAoX1VuYmFsYW5jZUR1cmF0aW9uUmVsID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZShyLCBvLCBuLCBhLCBULCBmKSwgciA9IF9VbmJhbGFuY2VEdXJhdGlvblJlbC55ZWFycywgbyA9IF9VbmJhbGFuY2VEdXJhdGlvblJlbC5tb250aHMsIG4gPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwud2Vla3MsIGEgPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwuZGF5cyksIChfUm91bmREdXJhdGlvbjggPSBSb3VuZER1cmF0aW9uKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIHksIFMsIEksIGYpLCByID0gX1JvdW5kRHVyYXRpb244LnllYXJzLCBvID0gX1JvdW5kRHVyYXRpb244Lm1vbnRocywgbiA9IF9Sb3VuZER1cmF0aW9uOC53ZWVrcywgYSA9IF9Sb3VuZER1cmF0aW9uOC5kYXlzLCBpID0gX1JvdW5kRHVyYXRpb244LmhvdXJzLCBzID0gX1JvdW5kRHVyYXRpb244Lm1pbnV0ZXMsIGwgPSBfUm91bmREdXJhdGlvbjguc2Vjb25kcywgZCA9IF9Sb3VuZER1cmF0aW9uOC5taWxsaXNlY29uZHMsIG0gPSBfUm91bmREdXJhdGlvbjgubWljcm9zZWNvbmRzLCBjID0gX1JvdW5kRHVyYXRpb244Lm5hbm9zZWNvbmRzKSwgKF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIgPSBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIHksIFMsIEksIGYpLCByID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi55ZWFycywgbyA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIubW9udGhzLCBuID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi53ZWVrcywgYSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIuZGF5cywgaSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIuaG91cnMsIHMgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLm1pbnV0ZXMsIGwgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLnNlY29uZHMsIGQgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLm1pbGxpc2Vjb25kcywgbSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIubWljcm9zZWNvbmRzLCBjID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi5uYW5vc2Vjb25kcyksIChfQmFsYW5jZUR1cmF0aW9uMTEgPSBCYWxhbmNlRHVyYXRpb24oYSwgaSwgcywgbCwgZCwgbSwgYywgVCwgZiksIGEgPSBfQmFsYW5jZUR1cmF0aW9uMTEuZGF5cywgaSA9IF9CYWxhbmNlRHVyYXRpb24xMS5ob3VycywgcyA9IF9CYWxhbmNlRHVyYXRpb24xMS5taW51dGVzLCBsID0gX0JhbGFuY2VEdXJhdGlvbjExLnNlY29uZHMsIGQgPSBfQmFsYW5jZUR1cmF0aW9uMTEubWlsbGlzZWNvbmRzLCBtID0gX0JhbGFuY2VEdXJhdGlvbjExLm1pY3Jvc2Vjb25kcywgYyA9IF9CYWxhbmNlRHVyYXRpb24xMS5uYW5vc2Vjb25kcyksIChfQmFsYW5jZUR1cmF0aW9uUmVsYXQgPSBmdW5jdGlvbiBCYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh0LCByLCBvLCBuLCBhLCBpKSB7XG4gICAgICAgIHZhciBzID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICAgICAgICBsID0gRHVyYXRpb25TaWduKHQsIHIsIG8sIG4sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBpZiAoMCA9PT0gbCkgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyczogdCxcbiAgICAgICAgICBtb250aHM6IHIsXG4gICAgICAgICAgd2Vla3M6IG8sXG4gICAgICAgICAgZGF5czogblxuICAgICAgICB9O1xuICAgICAgICB2YXIgZCA9IEJpZ0ludChsKTtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgYyxcbiAgICAgICAgICBoID0gQmlnSW50KHQpLFxuICAgICAgICAgIHUgPSBCaWdJbnQociksXG4gICAgICAgICAgVCA9IEJpZ0ludChvKSxcbiAgICAgICAgICBmID0gQmlnSW50KG4pO1xuICAgICAgICBpICYmIChjID0gVG9UZW1wb3JhbERhdGUoaSksIG0gPSBHZXRTbG90KGMsIHApKTtcbiAgICAgICAgdmFyIHkgPSBuZXcgcyhsKSxcbiAgICAgICAgICBJID0gbmV3IHMoMCwgbCksXG4gICAgICAgICAgUyA9IG5ldyBzKDAsIDAsIGwpO1xuICAgICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgeWVhcnMgYmFsYW5jaW5nXCIpO1xuICAgICAgICAgICAgICB2YXIgX3Q1MSA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlQWRkXCIpIDogdm9pZCAwO1xuICAgICAgICAgICAgICB2YXIgX3I2OCwgX280NiwgX24yODtcbiAgICAgICAgICAgICAgZm9yIChfTW92ZVJlbGF0aXZlRGF0ZTExID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTEucmVsYXRpdmVUbywgX280NiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTEuZGF5cywgX01vdmVSZWxhdGl2ZURhdGUxMTsgYWJzKGYpID49IEJpZ0ludChhZShfbzQ2KSk7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMTEsIF9Nb3ZlUmVsYXRpdmVEYXRlMTI7XG4gICAgICAgICAgICAgICAgZiA9IGYgLSBCaWdJbnQoX280NiksIGggPSBoICsgZCwgYyA9IF9yNjgsIChfTW92ZVJlbGF0aXZlRGF0ZTEyID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTIucmVsYXRpdmVUbywgX280NiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTIuZGF5cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChfTW92ZVJlbGF0aXZlRGF0ZTEzID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCBJLCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTMucmVsYXRpdmVUbywgX24yOCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTMuZGF5cywgX01vdmVSZWxhdGl2ZURhdGUxMzsgYWJzKGYpID49IEJpZ0ludChhZShfbjI4KSk7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMTMsIF9Nb3ZlUmVsYXRpdmVEYXRlMTQ7XG4gICAgICAgICAgICAgICAgZiA9IGYgLSBCaWdJbnQoX24yOCksIHUgPSB1ICsgZCwgYyA9IF9yNjgsIChfTW92ZVJlbGF0aXZlRGF0ZTE0ID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCBJLCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTQucmVsYXRpdmVUbywgX24yOCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTQuZGF5cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3I2OCA9IENhbGVuZGFyRGF0ZUFkZChtLCBjLCB5LCB2b2lkIDAsIF90NTEpO1xuICAgICAgICAgICAgICB2YXIgX2EyMCA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlVW50aWxcIikgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgX2kyNSA9IFRlKG51bGwpO1xuICAgICAgICAgICAgICBfaTI1Lmxhcmdlc3RVbml0ID0gXCJtb250aFwiO1xuICAgICAgICAgICAgICB2YXIgX3M4ID0gQ2FsZW5kYXJEYXRlVW50aWwobSwgYywgX3I2OCwgX2kyNSwgX2EyMCksXG4gICAgICAgICAgICAgICAgX2w5ID0gR2V0U2xvdChfczgsIEQpO1xuICAgICAgICAgICAgICBmb3IgKDsgYWJzKHUpID49IEJpZ0ludChhZShfbDkpKTspIHtcbiAgICAgICAgICAgICAgICB1ID0gdSAtIEJpZ0ludChfbDkpLCBoID0gaCArIGQsIGMgPSBfcjY4LCBfcjY4ID0gQ2FsZW5kYXJEYXRlQWRkKG0sIGMsIHksIHZvaWQgMCwgX3Q1MSk7XG4gICAgICAgICAgICAgICAgdmFyIF9vNDcgPSBUZShudWxsKTtcbiAgICAgICAgICAgICAgICBfbzQ3Lmxhcmdlc3RVbml0ID0gXCJtb250aFwiLCBfczggPSBDYWxlbmRhckRhdGVVbnRpbChtLCBjLCBfcjY4LCBfbzQ3LCBfYTIwKSwgX2w5ID0gR2V0U2xvdChfczgsIEQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgbW9udGhzIGJhbGFuY2luZ1wiKTtcbiAgICAgICAgICAgICAgdmFyIF90NTIgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBtID8gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIF9yNjksIF9vNDg7XG4gICAgICAgICAgICAgIGZvciAoX01vdmVSZWxhdGl2ZURhdGUxNSA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3Q1MiksIF9yNjkgPSBfTW92ZVJlbGF0aXZlRGF0ZTE1LnJlbGF0aXZlVG8sIF9vNDggPSBfTW92ZVJlbGF0aXZlRGF0ZTE1LmRheXMsIF9Nb3ZlUmVsYXRpdmVEYXRlMTU7IGFicyhmKSA+PSBCaWdJbnQoYWUoX280OCkpOykge1xuICAgICAgICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTE1LCBfTW92ZVJlbGF0aXZlRGF0ZTE2O1xuICAgICAgICAgICAgICAgIGYgPSBmIC0gQmlnSW50KF9vNDgpLCB1ID0gdSArIGQsIGMgPSBfcjY5LCAoX01vdmVSZWxhdGl2ZURhdGUxNiA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3Q1MiksIF9yNjkgPSBfTW92ZVJlbGF0aXZlRGF0ZTE2LnJlbGF0aXZlVG8sIF9vNDggPSBfTW92ZVJlbGF0aXZlRGF0ZTE2LmRheXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyBiYWxhbmNpbmdcIik7XG4gICAgICAgICAgICAgIHZhciBfdDUzID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgbSA/IEdldE1ldGhvZChtLCBcImRhdGVBZGRcIikgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBfcjcwLCBfbzQ5O1xuICAgICAgICAgICAgICBmb3IgKF9Nb3ZlUmVsYXRpdmVEYXRlMTcgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90NTMpLCBfcjcwID0gX01vdmVSZWxhdGl2ZURhdGUxNy5yZWxhdGl2ZVRvLCBfbzQ5ID0gX01vdmVSZWxhdGl2ZURhdGUxNy5kYXlzLCBfTW92ZVJlbGF0aXZlRGF0ZTE3OyBhYnMoZikgPj0gQmlnSW50KGFlKF9vNDkpKTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGUxNywgX01vdmVSZWxhdGl2ZURhdGUxODtcbiAgICAgICAgICAgICAgICBmID0gZiAtIEJpZ0ludChfbzQ5KSwgVCA9IFQgKyBkLCBjID0gX3I3MCwgKF9Nb3ZlUmVsYXRpdmVEYXRlMTggPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90NTMpLCBfcjcwID0gX01vdmVSZWxhdGl2ZURhdGUxOC5yZWxhdGl2ZVRvLCBfbzQ5ID0gX01vdmVSZWxhdGl2ZURhdGUxOC5kYXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHllYXJzOiBOdW1iZXIoaCksXG4gICAgICAgICAgbW9udGhzOiBOdW1iZXIodSksXG4gICAgICAgICAgd2Vla3M6IE51bWJlcihUKSxcbiAgICAgICAgICBkYXlzOiBOdW1iZXIoZilcbiAgICAgICAgfTtcbiAgICAgIH0ociwgbywgbiwgYSwgVCwgZiksIHIgPSBfQmFsYW5jZUR1cmF0aW9uUmVsYXQueWVhcnMsIG8gPSBfQmFsYW5jZUR1cmF0aW9uUmVsYXQubW9udGhzLCBuID0gX0JhbGFuY2VEdXJhdGlvblJlbGF0LndlZWtzLCBhID0gX0JhbGFuY2VEdXJhdGlvblJlbGF0LmRheXMpLCBuZXcgRHVyYXRpb24ociwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdGFsKGUpIHtcbiAgICAgIHZhciBfVW5iYWxhbmNlRHVyYXRpb25SZWwyO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIHcpLFxuICAgICAgICByID0gR2V0U2xvdCh0aGlzLCBEKSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRyksXG4gICAgICAgIG4gPSBHZXRTbG90KHRoaXMsIHYpLFxuICAgICAgICBhID0gR2V0U2xvdCh0aGlzLCBDKSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgTyksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIGIpLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBFKSxcbiAgICAgICAgZCA9IEdldFNsb3QodGhpcywgTSksXG4gICAgICAgIG0gPSBHZXRTbG90KHRoaXMsIFIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgYXJndW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB2YXIgYyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KFwidW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIGggPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3QoYyksXG4gICAgICAgIHUgPSBHZXRUZW1wb3JhbFVuaXQoYywgXCJ1bml0XCIsIFwiZGF0ZXRpbWVcIiwgSGUpO1xuICAgICAgdmFyIFQ7XG4gICAgICAoX1VuYmFsYW5jZUR1cmF0aW9uUmVsMiA9IFVuYmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUodCwgciwgbywgbiwgdSwgaCksIHQgPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwyLnllYXJzLCByID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMi5tb250aHMsIG8gPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwyLndlZWtzLCBuID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMi5kYXlzKSwgSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaCkgJiYgKFQgPSBNb3ZlUmVsYXRpdmVab25lZERhdGVUaW1lKGgsIHQsIHIsIG8sIDApKTtcbiAgICAgIHZhciBwID0gQmFsYW5jZVBvc3NpYmx5SW5maW5pdGVEdXJhdGlvbihuLCBhLCBpLCBzLCBsLCBkLCBtLCB1LCBUKTtcbiAgICAgIGlmIChcInBvc2l0aXZlIG92ZXJmbG93XCIgPT09IHApIHJldHVybiAxIC8gMDtcbiAgICAgIGlmIChcIm5lZ2F0aXZlIG92ZXJmbG93XCIgPT09IHApIHJldHVybiAtMSAvIDA7XG4gICAgICBuID0gcC5kYXlzO1xuICAgICAgYSA9IHAuaG91cnM7XG4gICAgICBpID0gcC5taW51dGVzO1xuICAgICAgcyA9IHAuc2Vjb25kcztcbiAgICAgIGwgPSBwLm1pbGxpc2Vjb25kcztcbiAgICAgIGQgPSBwLm1pY3Jvc2Vjb25kcztcbiAgICAgIG0gPSBwLm5hbm9zZWNvbmRzO1xuICAgICAgdmFyIF9Sb3VuZER1cmF0aW9uOSA9IFJvdW5kRHVyYXRpb24odCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgMSwgdSwgXCJ0cnVuY1wiLCBoKSxcbiAgICAgICAgZiA9IF9Sb3VuZER1cmF0aW9uOS50b3RhbDtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0ZyYWN0aW9uYWxTZWNvbmREaWdpdHModCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwidHJ1bmNcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIHZvaWQgMCk7XG4gICAgICBpZiAoXCJob3VyXCIgPT09IG4gfHwgXCJtaW51dGVcIiA9PT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBtdXN0IGJlIGEgdGltZSB1bml0IG90aGVyIHRoYW4gXCJob3Vyc1wiIG9yIFwibWludXRlc1wiJyk7XG4gICAgICB2YXIgX1RvU2Vjb25kc1N0cmluZ1ByZWNpMyA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvblJlY29yZChuLCByKSxcbiAgICAgICAgYSA9IF9Ub1NlY29uZHNTdHJpbmdQcmVjaTMucHJlY2lzaW9uLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMy51bml0LFxuICAgICAgICBzID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMy5pbmNyZW1lbnQ7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMsIGEsIHtcbiAgICAgICAgdW5pdDogaSxcbiAgICAgICAgaW5jcmVtZW50OiBzLFxuICAgICAgICByb3VuZGluZ01vZGU6IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEludGwgJiYgdm9pZCAwICE9PSBJbnRsLkR1cmF0aW9uRm9ybWF0ID8gbmV3IEludGwuRHVyYXRpb25Gb3JtYXQoZSwgdCkuZm9ybWF0KHRoaXMpIDogKGNvbnNvbGUud2FybihcIlRlbXBvcmFsLkR1cmF0aW9uLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZygpIHJlcXVpcmVzIEludGwuRHVyYXRpb25Gb3JtYXQuXCIpLCBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSB0byBjb21wYXJlIFRlbXBvcmFsLkR1cmF0aW9uXCIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlKSB7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbER1cmF0aW9uKGUpID8gbmV3IER1cmF0aW9uKEdldFNsb3QoZSwgdyksIEdldFNsb3QoZSwgRCksIEdldFNsb3QoZSwgRyksIEdldFNsb3QoZSwgdiksIEdldFNsb3QoZSwgQyksIEdldFNsb3QoZSwgTyksIEdldFNsb3QoZSwgYiksIEdldFNsb3QoZSwgRSksIEdldFNsb3QoZSwgTSksIEdldFNsb3QoZSwgUikpIDogVG9UZW1wb3JhbER1cmF0aW9uKGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUodCwgciwgbykge1xuICAgICAgdmFyIF9VbmJhbGFuY2VEdXJhdGlvblJlbDMsIF9VbmJhbGFuY2VEdXJhdGlvblJlbDQ7XG4gICAgICB2YXIgbiA9IFRvVGVtcG9yYWxEdXJhdGlvbih0KSxcbiAgICAgICAgYSA9IFRvVGVtcG9yYWxEdXJhdGlvbihyKSxcbiAgICAgICAgaSA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChHZXRPcHRpb25zT2JqZWN0KG8pKSxcbiAgICAgICAgcyA9IEdldFNsb3QobiwgdyksXG4gICAgICAgIGwgPSBHZXRTbG90KG4sIEQpLFxuICAgICAgICBkID0gR2V0U2xvdChuLCBHKTtcbiAgICAgIHZhciBtID0gR2V0U2xvdChuLCB2KTtcbiAgICAgIHZhciBjID0gR2V0U2xvdChuLCBDKSxcbiAgICAgICAgaCA9IEdldFNsb3QobiwgTyksXG4gICAgICAgIHUgPSBHZXRTbG90KG4sIGIpLFxuICAgICAgICBUID0gR2V0U2xvdChuLCBFKSxcbiAgICAgICAgcCA9IEdldFNsb3QobiwgTSk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QobiwgUik7XG4gICAgICB2YXIgeSA9IEdldFNsb3QoYSwgdyksXG4gICAgICAgIEkgPSBHZXRTbG90KGEsIEQpLFxuICAgICAgICBTID0gR2V0U2xvdChhLCBHKTtcbiAgICAgIHZhciBnID0gR2V0U2xvdChhLCB2KTtcbiAgICAgIHZhciBGID0gR2V0U2xvdChhLCBDKSxcbiAgICAgICAgWSA9IEdldFNsb3QoYSwgTyksXG4gICAgICAgIFAgPSBHZXRTbG90KGEsIGIpLFxuICAgICAgICBaID0gR2V0U2xvdChhLCBFKSxcbiAgICAgICAgQiA9IEdldFNsb3QoYSwgTSk7XG4gICAgICB2YXIgTiA9IEdldFNsb3QoYSwgUik7XG4gICAgICB2YXIgaiA9IENhbGN1bGF0ZU9mZnNldFNoaWZ0KGksIHMsIGwsIGQsIG0pLFxuICAgICAgICAkID0gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQoaSwgeSwgSSwgUywgZyk7XG4gICAgICAwID09PSBzICYmIDAgPT09IHkgJiYgMCA9PT0gbCAmJiAwID09PSBJICYmIDAgPT09IGQgJiYgMCA9PT0gUyB8fCAoKF9VbmJhbGFuY2VEdXJhdGlvblJlbDMgPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHMsIGwsIGQsIG0sIFwiZGF5XCIsIGkpLCBtID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMy5kYXlzKSwgKF9VbmJhbGFuY2VEdXJhdGlvblJlbDQgPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHksIEksIFMsIGcsIFwiZGF5XCIsIGkpLCBnID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsNC5kYXlzKSk7XG4gICAgICB2YXIgayA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhtLCBjLCBoLCB1LCBULCBwLCBmLCBqKSxcbiAgICAgICAgVSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhnLCBGLCBZLCBQLCBaLCBCLCBOLCAkKTtcbiAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KE51bWJlcihrIC0gVSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRHVyYXRpb247XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoRHVyYXRpb24sIFwiVGVtcG9yYWwuRHVyYXRpb25cIik7XG52YXIgYnQgPSBPYmplY3QuY3JlYXRlO1xudmFyIFBsYWluTW9udGhEYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpbk1vbnRoRGF5KGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE5NzI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluTW9udGhEYXkpO1xuICAgIENyZWF0ZVRlbXBvcmFsTW9udGhEYXlTbG90cyh0aGlzLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odCksIFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShyKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obykpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpbk1vbnRoRGF5LCBbe1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoQ29kZShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXkoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgUmVqZWN0VGVtcG9yYWxMaWtlT2JqZWN0KGUpO1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgbiA9IENhbGVuZGFyRmllbGRzKG8sIFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSk7XG4gICAgICB2YXIgYSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyh0aGlzLCBuLCBbXSk7XG4gICAgICByZXR1cm4gYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHMobywgYSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFwicGFydGlhbFwiKSksIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYSwgbiwgW10pLCBDYWxlbmRhck1vbnRoRGF5RnJvbUZpZWxkcyhvLCBhLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxNb250aERheShlKTtcbiAgICAgIGZvciAodmFyIF9pMjYgPSAwLCBfYXJyMTEgPSBbcywgbCwgaV07IF9pMjYgPCBfYXJyMTEubGVuZ3RoOyBfaTI2KyspIHtcbiAgICAgICAgdmFyIF9lNTcgPSBfYXJyMTFbX2kyNl07XG4gICAgICAgIGlmIChHZXRTbG90KHRoaXMsIF9lNTcpICE9PSBHZXRTbG90KHQsIF9lNTcpKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBwKSwgR2V0U2xvdCh0LCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcodGhpcywgVG9DYWxlbmRhck5hbWVPcHRpb24oR2V0T3B0aW9uc09iamVjdChlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsTW9udGhEYXlUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbk1vbnRoRGF5XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluRGF0ZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgciA9IENhbGVuZGFyRmllbGRzKHQsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksXG4gICAgICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgciwgW10pLFxuICAgICAgICBuID0gQ2FsZW5kYXJGaWVsZHModCwgW1wieWVhclwiXSk7XG4gICAgICB2YXIgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHModCwgbywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFtdKSk7XG4gICAgICBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkociksIF90b0NvbnN1bWFibGVBcnJheShuKSkpKSwgW10pO1xuICAgICAgdmFyIGkgPSBidChudWxsKTtcbiAgICAgIHJldHVybiBpLm92ZXJmbG93ID0gXCJyZWplY3RcIiwgQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh0LCBhLCBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBpc29EYXk6IEdldFNsb3QodGhpcywgbCksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIGkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxlbmRhcigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJPYmplY3QoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUsIHQpIHtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsTW9udGhEYXkoZSkgPyAoVG9UZW1wb3JhbE92ZXJmbG93KHIpLCBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QoZSwgcCksIEdldFNsb3QoZSwgaSkpKSA6IFRvVGVtcG9yYWxNb250aERheShlLCByKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluTW9udGhEYXk7XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5Nb250aERheSwgXCJUZW1wb3JhbC5QbGFpbk1vbnRoRGF5XCIpO1xudmFyIGluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5JbnN0YW50JVwiKSkoVmUoKSk7XG4gIH0sXG4gIHBsYWluRGF0ZVRpbWUgPSBmdW5jdGlvbiBwbGFpbkRhdGVUaW1lKGUpIHtcbiAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgdmFyIHIgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUodCksXG4gICAgICBvID0gVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKGUpO1xuICAgIHJldHVybiBHZXRQbGFpbkRhdGVUaW1lRm9yKHIsIGluc3RhbnQoKSwgbyk7XG4gIH0sXG4gIHBsYWluRGF0ZVRpbWVJU08gPSBmdW5jdGlvbiBwbGFpbkRhdGVUaW1lSVNPKCkge1xuICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBEZWZhdWx0VGltZVpvbmUoKTtcbiAgICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcihUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSksIGluc3RhbnQoKSwgXCJpc284NjAxXCIpO1xuICB9LFxuICB6b25lZERhdGVUaW1lID0gZnVuY3Rpb24gem9uZWREYXRlVGltZShlKSB7XG4gICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERlZmF1bHRUaW1lWm9uZSgpO1xuICAgIHZhciByID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKHQpLFxuICAgICAgbyA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKFZlKCksIHIsIG8pO1xuICB9LFxuICBFdCA9IF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgaW5zdGFudDogaW5zdGFudCxcbiAgICBwbGFpbkRhdGVUaW1lOiBwbGFpbkRhdGVUaW1lLFxuICAgIHBsYWluRGF0ZVRpbWVJU086IHBsYWluRGF0ZVRpbWVJU08sXG4gICAgcGxhaW5EYXRlOiBmdW5jdGlvbiBwbGFpbkRhdGUoZSkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERlZmF1bHRUaW1lWm9uZSgpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocGxhaW5EYXRlVGltZShlLCB0KSk7XG4gICAgfSxcbiAgICBwbGFpbkRhdGVJU086IGZ1bmN0aW9uIHBsYWluRGF0ZUlTTygpIHtcbiAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBEZWZhdWx0VGltZVpvbmUoKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHBsYWluRGF0ZVRpbWVJU08oZSkpO1xuICAgIH0sXG4gICAgcGxhaW5UaW1lSVNPOiBmdW5jdGlvbiBwbGFpblRpbWVJU08oKSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvVGltZShwbGFpbkRhdGVUaW1lSVNPKGUpKTtcbiAgICB9LFxuICAgIHRpbWVab25lSWQ6IGZ1bmN0aW9uIHRpbWVab25lSWQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFRpbWVab25lKCk7XG4gICAgfSxcbiAgICB6b25lZERhdGVUaW1lOiB6b25lZERhdGVUaW1lLFxuICAgIHpvbmVkRGF0ZVRpbWVJU086IGZ1bmN0aW9uIHpvbmVkRGF0ZVRpbWVJU08oKSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgICByZXR1cm4gem9uZWREYXRlVGltZShcImlzbzg2MDFcIiwgZSk7XG4gICAgfVxuICB9LCBTeW1ib2wudG9TdHJpbmdUYWcsIFwiVGVtcG9yYWwuTm93XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgdmFsdWU6IFwiVGVtcG9yYWwuTm93XCIsXG4gIHdyaXRhYmxlOiAhMSxcbiAgZW51bWVyYWJsZTogITEsXG4gIGNvbmZpZ3VyYWJsZTogITBcbn0pO1xudmFyIE10ID0gT2JqZWN0LmFzc2lnbjtcbmZ1bmN0aW9uIFRlbXBvcmFsVGltZVRvU3RyaW5nKGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBHZXRTbG90KGUsIGQpLFxuICAgIG4gPSBHZXRTbG90KGUsIG0pLFxuICAgIGEgPSBHZXRTbG90KGUsIGMpLFxuICAgIGkgPSBHZXRTbG90KGUsIGgpLFxuICAgIHMgPSBHZXRTbG90KGUsIHUpLFxuICAgIGwgPSBHZXRTbG90KGUsIFQpO1xuICBpZiAocikge1xuICAgIHZhciBfZTU4ID0gci51bml0LFxuICAgICAgX3Q1NCA9IHIuaW5jcmVtZW50LFxuICAgICAgX2QxMiA9IHIucm91bmRpbmdNb2RlO1xuICAgIHZhciBfUm91bmRUaW1lMiA9IFJvdW5kVGltZShvLCBuLCBhLCBpLCBzLCBsLCBfdDU0LCBfZTU4LCBfZDEyKTtcbiAgICBvID0gX1JvdW5kVGltZTIuaG91cjtcbiAgICBuID0gX1JvdW5kVGltZTIubWludXRlO1xuICAgIGEgPSBfUm91bmRUaW1lMi5zZWNvbmQ7XG4gICAgaSA9IF9Sb3VuZFRpbWUyLm1pbGxpc2Vjb25kO1xuICAgIHMgPSBfUm91bmRUaW1lMi5taWNyb3NlY29uZDtcbiAgICBsID0gX1JvdW5kVGltZTIubmFub3NlY29uZDtcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG8pLCBcIjpcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhuKSkuY29uY2F0KEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KGEsIGksIHMsIGwsIHQpKTtcbn1cbnZhciBQbGFpblRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpblRpbWUoKSB7XG4gICAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluVGltZSk7XG4gICAgdmFyIGkgPSB2b2lkIDAgPT09IGUgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24oZSksXG4gICAgICBzID0gdm9pZCAwID09PSB0ID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHQpLFxuICAgICAgbCA9IHZvaWQgMCA9PT0gciA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihyKSxcbiAgICAgIHAgPSB2b2lkIDAgPT09IG8gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obyksXG4gICAgICBmID0gdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKG4pLFxuICAgICAgeSA9IHZvaWQgMCA9PT0gYSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihhKTtcbiAgICBSZWplY3RUaW1lKGksIHMsIGwsIHAsIGYsIHkpLCBOKHRoaXMpLCBTZXRTbG90KHRoaXMsIGQsIGkpLCBTZXRTbG90KHRoaXMsIG0sIHMpLCBTZXRTbG90KHRoaXMsIGMsIGwpLCBTZXRTbG90KHRoaXMsIGgsIHApLCBTZXRTbG90KHRoaXMsIHUsIGYpLCBTZXRTbG90KHRoaXMsIFQsIHkpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpblRpbWUsIFt7XG4gICAga2V5OiBcImhvdXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbnV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWljcm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hbm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dpdGgoZSwgdCkge1xuICAgICAgdmFyIF9SZWd1bGF0ZVRpbWU0O1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbE92ZXJmbG93KEdldE9wdGlvbnNPYmplY3QodCkpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQoZSwgXCJwYXJ0aWFsXCIpLFxuICAgICAgICBuID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQodGhpcyk7XG4gICAgICB2YXIgX010ID0gTXQobiwgbyksXG4gICAgICAgIGEgPSBfTXQuaG91cixcbiAgICAgICAgaSA9IF9NdC5taW51dGUsXG4gICAgICAgIHMgPSBfTXQuc2Vjb25kLFxuICAgICAgICBsID0gX010Lm1pbGxpc2Vjb25kLFxuICAgICAgICBkID0gX010Lm1pY3Jvc2Vjb25kLFxuICAgICAgICBtID0gX010Lm5hbm9zZWNvbmQ7XG4gICAgICByZXR1cm4gKF9SZWd1bGF0ZVRpbWU0ID0gUmVndWxhdGVUaW1lKGEsIGksIHMsIGwsIGQsIG0sIHIpLCBhID0gX1JlZ3VsYXRlVGltZTQuaG91ciwgaSA9IF9SZWd1bGF0ZVRpbWU0Lm1pbnV0ZSwgcyA9IF9SZWd1bGF0ZVRpbWU0LnNlY29uZCwgbCA9IF9SZWd1bGF0ZVRpbWU0Lm1pbGxpc2Vjb25kLCBkID0gX1JlZ3VsYXRlVGltZTQubWljcm9zZWNvbmQsIG0gPSBfUmVndWxhdGVUaW1lNC5uYW5vc2Vjb25kKSwgbmV3IFBsYWluVGltZShhLCBpLCBzLCBsLCBkLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVBsYWluVGltZShcImFkZFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblRpbWUoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5UaW1lKFwidW50aWxcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmNlKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluVGltZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZChlKSB7XG4gICAgICB2YXIgX1JvdW5kVGltZTM7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIHZhciB0ID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IENyZWF0ZU9uZVByb3BPYmplY3QoXCJzbWFsbGVzdFVuaXRcIiwgZSkgOiBHZXRPcHRpb25zT2JqZWN0KGUpLFxuICAgICAgICByID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHQpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcImhhbGZFeHBhbmRcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIEhlKTtcbiAgICAgIFZhbGlkYXRlVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChyLCB7XG4gICAgICAgIGhvdXI6IDI0LFxuICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICBzZWNvbmQ6IDYwLFxuICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICBtaWNyb3NlY29uZDogMWUzLFxuICAgICAgICBuYW5vc2Vjb25kOiAxZTNcbiAgICAgIH1bbl0sICExKTtcbiAgICAgIHZhciBhID0gR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIGMpLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBoKSxcbiAgICAgICAgcCA9IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIGYgPSBHZXRTbG90KHRoaXMsIFQpO1xuICAgICAgcmV0dXJuIChfUm91bmRUaW1lMyA9IFJvdW5kVGltZShhLCBpLCBzLCBsLCBwLCBmLCByLCBuLCBvKSwgYSA9IF9Sb3VuZFRpbWUzLmhvdXIsIGkgPSBfUm91bmRUaW1lMy5taW51dGUsIHMgPSBfUm91bmRUaW1lMy5zZWNvbmQsIGwgPSBfUm91bmRUaW1lMy5taWxsaXNlY29uZCwgcCA9IF9Sb3VuZFRpbWUzLm1pY3Jvc2Vjb25kLCBmID0gX1JvdW5kVGltZTMubmFub3NlY29uZCksIG5ldyBQbGFpblRpbWUoYSwgaSwgcywgbCwgcCwgZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lKGUpO1xuICAgICAgZm9yICh2YXIgX2kyNyA9IDAsIF9hcnIxMiA9IFtkLCBtLCBjLCBoLCB1LCBUXTsgX2kyNyA8IF9hcnIxMi5sZW5ndGg7IF9pMjcrKykge1xuICAgICAgICB2YXIgX2U1OSA9IF9hcnIxMltfaTI3XTtcbiAgICAgICAgaWYgKEdldFNsb3QodGhpcywgX2U1OSkgIT09IEdldFNsb3QodCwgX2U1OSkpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0ZyYWN0aW9uYWxTZWNvbmREaWdpdHModCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwidHJ1bmNcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIHZvaWQgMCk7XG4gICAgICBpZiAoXCJob3VyXCIgPT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgbXVzdCBiZSBhIHRpbWUgdW5pdCBvdGhlciB0aGFuIFwiaG91clwiJyk7XG4gICAgICB2YXIgX1RvU2Vjb25kc1N0cmluZ1ByZWNpNCA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvblJlY29yZChuLCByKSxcbiAgICAgICAgYSA9IF9Ub1NlY29uZHNTdHJpbmdQcmVjaTQucHJlY2lzaW9uLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNC51bml0LFxuICAgICAgICBzID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNC5pbmNyZW1lbnQ7XG4gICAgICByZXR1cm4gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgYSwge1xuICAgICAgICB1bml0OiBpLFxuICAgICAgICBpbmNyZW1lbnQ6IHMsXG4gICAgICAgIHJvdW5kaW5nTW9kZTogb1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbFRpbWVUb1N0cmluZyh0aGlzLCBcImF1dG9cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvTG9jYWxlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5UaW1lXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluRGF0ZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGVUaW1lKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgciA9IEdldFNsb3QodCwgaSksXG4gICAgICAgIG8gPSBHZXRTbG90KHQsIHMpLFxuICAgICAgICBuID0gR2V0U2xvdCh0LCBsKSxcbiAgICAgICAgYSA9IEdldFNsb3QodCwgcCk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShyLCBvLCBuLCBHZXRTbG90KHRoaXMsIGQpLCBHZXRTbG90KHRoaXMsIG0pLCBHZXRTbG90KHRoaXMsIGMpLCBHZXRTbG90KHRoaXMsIGgpLCBHZXRTbG90KHRoaXMsIHUpLCBHZXRTbG90KHRoaXMsIFQpLCBhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9ab25lZERhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgdmFyIHQgPSBlLnBsYWluRGF0ZTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIGRhdGUgcHJvcGVydHlcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxEYXRlKHQpLFxuICAgICAgICBvID0gZS50aW1lWm9uZTtcbiAgICAgIGlmICh2b2lkIDAgPT09IG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIHRpbWVab25lIHByb3BlcnR5XCIpO1xuICAgICAgdmFyIGEgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUobyksXG4gICAgICAgIGYgPSBHZXRTbG90KHIsIGkpLFxuICAgICAgICB5ID0gR2V0U2xvdChyLCBzKSxcbiAgICAgICAgSSA9IEdldFNsb3QociwgbCksXG4gICAgICAgIFMgPSBHZXRTbG90KHIsIHApLFxuICAgICAgICBnID0gR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgdyA9IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIEQgPSBHZXRTbG90KHRoaXMsIGMpLFxuICAgICAgICBHID0gR2V0U2xvdCh0aGlzLCBoKSxcbiAgICAgICAgdiA9IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIEMgPSBHZXRTbG90KHRoaXMsIFQpO1xuICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KEdldEluc3RhbnRGb3IoYSwgbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5EYXRlVGltZSVcIikpKGYsIHksIEksIGcsIHcsIEQsIEcsIHYsIEMsIFMpLCBcImNvbXBhdGlibGVcIiksIG4pLCBhLCBTKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgaXNvTWljcm9zZWNvbmQ6IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KHRoaXMsIGgpLFxuICAgICAgICBpc29NaW51dGU6IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgVCksXG4gICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBjKVxuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsT3ZlcmZsb3coR2V0T3B0aW9uc09iamVjdCh0KSk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFRpbWUoZSkgPyBuZXcgUGxhaW5UaW1lKEdldFNsb3QoZSwgZCksIEdldFNsb3QoZSwgbSksIEdldFNsb3QoZSwgYyksIEdldFNsb3QoZSwgaCksIEdldFNsb3QoZSwgdSksIEdldFNsb3QoZSwgVCkpIDogVG9UZW1wb3JhbFRpbWUoZSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShlLCB0KSB7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxUaW1lKGUpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFRpbWUodCk7XG4gICAgICBmb3IgKHZhciBfaTI4ID0gMCwgX2FycjEzID0gW2QsIG0sIGMsIGgsIHUsIFRdOyBfaTI4IDwgX2FycjEzLmxlbmd0aDsgX2kyOCsrKSB7XG4gICAgICAgIHZhciBfZTYwID0gX2FycjEzW19pMjhdO1xuICAgICAgICB2YXIgX3Q1NSA9IEdldFNsb3QociwgX2U2MCksXG4gICAgICAgICAgX24yOSA9IEdldFNsb3QobywgX2U2MCk7XG4gICAgICAgIGlmIChfdDU1ICE9PSBfbjI5KSByZXR1cm4gQ29tcGFyaXNvblJlc3VsdChfdDU1IC0gX24yOSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluVGltZTtcbn0oKTtcbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblRpbWUsIFwiVGVtcG9yYWwuUGxhaW5UaW1lXCIpO1xudmFyIFRpbWVab25lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVpvbmUoZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lWm9uZSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pc3NpbmcgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgdmFyIHQgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIoZSk7XG4gICAgTih0aGlzKSwgU2V0U2xvdCh0aGlzLCBhLCB0KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVGltZVpvbmUsIFt7XG4gICAga2V5OiBcImlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICByZXR1cm4gSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSA/IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcocikgOiBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMociwgR2V0U2xvdCh0LCBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9mZnNldFN0cmluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZzZXRTdHJpbmdGb3IoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldFN0cmluZ0Zvcih0aGlzLCBUb1RlbXBvcmFsSW5zdGFudChlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYWluRGF0ZVRpbWVGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxhaW5EYXRlVGltZUZvcihlKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJpc284NjAxXCI7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcih0aGlzLCBUb1RlbXBvcmFsSW5zdGFudChlKSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5zdGFudEZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW50Rm9yKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRJbnN0YW50Rm9yKHRoaXMsIFRvVGVtcG9yYWxEYXRlVGltZShlKSwgVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKEdldE9wdGlvbnNPYmplY3QodCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NzaWJsZUluc3RhbnRzRm9yKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbERhdGVUaW1lKHQpLFxuICAgICAgICBvID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpLFxuICAgICAgICBuID0gR2V0U2xvdCh0aGlzLCBhKTtcbiAgICAgIGlmIChJc1RpbWVab25lT2Zmc2V0U3RyaW5nKG4pKSB7XG4gICAgICAgIHZhciBfdDU2ID0gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyhHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIGQpLCBHZXRTbG90KHIsIG0pLCBHZXRTbG90KHIsIGMpLCBHZXRTbG90KHIsIGgpLCBHZXRTbG90KHIsIHUpLCBHZXRTbG90KHIsIFQpKTtcbiAgICAgICAgaWYgKG51bGwgPT09IF90NTYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2VcIik7XG4gICAgICAgIHZhciBfYTIxID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhuKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbyhfdDU2IC0gQmlnSW50KF9hMjEpKV07XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGZ1bmN0aW9uIEdldE5hbWVkVGltZVpvbmVFcG9jaE5hbm9zZWNvbmRzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pIHtcbiAgICAgICAgdmFyIGMgPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pO1xuICAgICAgICBpZiAobnVsbCA9PT0gYykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgICAgICAgdmFyIGggPSBjIC0gRWU7XG4gICAgICAgIGggPCBNZSAmJiAoaCA9IGMpO1xuICAgICAgICB2YXIgdSA9IGMgKyBFZTtcbiAgICAgICAgdSA+IFJlICYmICh1ID0gYyk7XG4gICAgICAgIHZhciBUID0gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIGgpLFxuICAgICAgICAgIHAgPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgdSk7XG4gICAgICAgIHJldHVybiAoVCA9PT0gcCA/IFtUXSA6IFtULCBwXSkubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgdmFyIHUgPSBjIC0gQmlnSW50KGgpLFxuICAgICAgICAgICAgVCA9IEdldE5hbWVkVGltZVpvbmVEYXRlVGltZVBhcnRzKHQsIHUpO1xuICAgICAgICAgIGlmIChyID09PSBULnllYXIgJiYgbyA9PT0gVC5tb250aCAmJiBuID09PSBULmRheSAmJiBhID09PSBULmhvdXIgJiYgaSA9PT0gVC5taW51dGUgJiYgcyA9PT0gVC5zZWNvbmQgJiYgbCA9PT0gVC5taWxsaXNlY29uZCAmJiBkID09PSBULm1pY3Jvc2Vjb25kICYmIG0gPT09IFQubmFub3NlY29uZCkgcmV0dXJuIHU7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGU7XG4gICAgICAgIH0pO1xuICAgICAgfShuLCBHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIGQpLCBHZXRTbG90KHIsIG0pLCBHZXRTbG90KHIsIGMpLCBHZXRTbG90KHIsIGgpLCBHZXRTbG90KHIsIHUpLCBHZXRTbG90KHIsIFQpKTtcbiAgICAgIHJldHVybiBwLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IG8oZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmV4dFRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV4dFRyYW5zaXRpb24oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSB8fCBcIlVUQ1wiID09PSByKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBvID0gR2V0U2xvdCh0LCBuKTtcbiAgICAgIHZhciBpID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpO1xuICAgICAgcmV0dXJuIG8gPSBHZXROYW1lZFRpbWVab25lTmV4dFRyYW5zaXRpb24ociwgbyksIG51bGwgPT09IG8gPyBudWxsIDogbmV3IGkobyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByZXZpb3VzVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmV2aW91c1RyYW5zaXRpb24oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSB8fCBcIlVUQ1wiID09PSByKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBvID0gR2V0U2xvdCh0LCBuKTtcbiAgICAgIHZhciBpID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpO1xuICAgICAgcmV0dXJuIG8gPSBHZXROYW1lZFRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKHIsIG8pLCBudWxsID09PSBvID8gbnVsbCA6IG5ldyBpKG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgYSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUpIHtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsVGltZVpvbmVPYmplY3QoVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKGUpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRpbWVab25lO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFRpbWVab25lLCBcIlRlbXBvcmFsLlRpbWVab25lXCIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5UaW1lWm9uZS5wcm90b3R5cGUuZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIiwgVGltZVpvbmUucHJvdG90eXBlLmdldE9mZnNldE5hbm9zZWNvbmRzRm9yKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuVGltZVpvbmUucHJvdG90eXBlLmdldFBvc3NpYmxlSW5zdGFudHNGb3JcIiwgVGltZVpvbmUucHJvdG90eXBlLmdldFBvc3NpYmxlSW5zdGFudHNGb3IpO1xudmFyIFJ0ID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBQbGFpblllYXJNb250aCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYWluWWVhck1vbnRoKGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluWWVhck1vbnRoKTtcbiAgICBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHRoaXMsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0KSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHIpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihvKSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFBsYWluWWVhck1vbnRoLCBbe1xuICAgIGtleTogXCJ5ZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxlbmRhcklkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aHNJblllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW10pO1xuICAgICAgcmV0dXJuIGEgPSBDYWxlbmRhck1lcmdlRmllbGRzKG8sIGEsIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBuLCBcInBhcnRpYWxcIikpLCBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIG4sIFtdKSwgQ2FsZW5kYXJZZWFyTW9udGhGcm9tRmllbGRzKG8sIGEsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblllYXJNb250aChcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVBsYWluWWVhck1vbnRoKFwic3VidHJhY3RcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVudGlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVudGlsKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5ZZWFyTW9udGgoXCJ1bnRpbFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2luY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2luY2UoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpblllYXJNb250aChcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxZZWFyTW9udGgoZSk7XG4gICAgICBmb3IgKHZhciBfaTI5ID0gMCwgX2FycjE0ID0gW2ksIHMsIGxdOyBfaTI5IDwgX2FycjE0Lmxlbmd0aDsgX2kyOSsrKSB7XG4gICAgICAgIHZhciBfZTYxID0gX2FycjE0W19pMjldO1xuICAgICAgICBpZiAoR2V0U2xvdCh0aGlzLCBfZTYxKSAhPT0gR2V0U2xvdCh0LCBfZTYxKSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QodCwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcodGhpcywgVG9DYWxlbmRhck5hbWVPcHRpb24oR2V0T3B0aW9uc09iamVjdChlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5ZZWFyTW9udGhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgciA9IENhbGVuZGFyRmllbGRzKHQsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLFxuICAgICAgICBvID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIHIsIFtdKSxcbiAgICAgICAgbiA9IENhbGVuZGFyRmllbGRzKHQsIFtcImRheVwiXSk7XG4gICAgICB2YXIgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHModCwgbywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFtdKSk7XG4gICAgICBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkociksIF90b0NvbnN1bWFibGVBcnJheShuKSkpKSwgW10pO1xuICAgICAgdmFyIGkgPSBSdChudWxsKTtcbiAgICAgIHJldHVybiBpLm92ZXJmbG93ID0gXCJyZWplY3RcIiwgQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh0LCBhLCBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBpc29Nb250aDogR2V0U2xvdCh0aGlzLCBzKSxcbiAgICAgICAgaXNvWWVhcjogR2V0U2xvdCh0aGlzLCBpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgoZSkgPyAoVG9UZW1wb3JhbE92ZXJmbG93KHIpLCBDcmVhdGVUZW1wb3JhbFllYXJNb250aChHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIHApLCBHZXRTbG90KGUsIGwpKSkgOiBUb1RlbXBvcmFsWWVhck1vbnRoKGUsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsWWVhck1vbnRoKGUpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFllYXJNb250aCh0KTtcbiAgICAgIHJldHVybiBDb21wYXJlSVNPRGF0ZShHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KG8sIGkpLCBHZXRTbG90KG8sIHMpLCBHZXRTbG90KG8sIGwpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluWWVhck1vbnRoO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluWWVhck1vbnRoLCBcIlRlbXBvcmFsLlBsYWluWWVhck1vbnRoXCIpO1xudmFyIEZ0ID0gaHQucHJvdG90eXBlLnJlc29sdmVkT3B0aW9ucyxcbiAgWXQgPSBPYmplY3QuY3JlYXRlO1xudmFyIFpvbmVkRGF0ZVRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvbmVkRGF0ZVRpbWUpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1pc3NpbmcgYXJndW1lbnQ6IGVwb2NoTmFub3NlY29uZHMgaXMgcmVxdWlyZWRcIik7XG4gICAgQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHModGhpcywgVG9CaWdJbnQoZSksIFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZSh0KSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHIpKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoWm9uZWREYXRlVGltZSwgW3tcbiAgICBrZXk6IFwiY2FsZW5kYXJJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZVpvbmVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihHZXRTbG90KHRoaXMsIGcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhvdXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW51dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIG0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgaCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pY3Jvc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KGRhdGVUaW1lKHRoaXMpLCB1KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFub3NlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcmFZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaFNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIG4pO1xuICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnRGbG9vckRpdih0LCB2ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE1pbGxpc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldFNsb3QodGhpcywgbik7XG4gICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludEZsb29yRGl2KHQsIEdlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVwb2NoTWljcm9zZWNvbmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEJpZ0ludEZsb29yRGl2KEdldFNsb3QodGhpcywgbiksIERlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVwb2NoTmFub3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoR2V0U2xvdCh0aGlzLCBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZlllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJXZWVrT2ZZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyT2ZXZWVrKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaG91cnNJbkRheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IGRhdGVUaW1lKHRoaXMpLFxuICAgICAgICByID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpLFxuICAgICAgICBvID0gR2V0U2xvdCh0LCBpKSxcbiAgICAgICAgYSA9IEdldFNsb3QodCwgcyksXG4gICAgICAgIGQgPSBHZXRTbG90KHQsIGwpLFxuICAgICAgICBtID0gbmV3IHIobywgYSwgZCwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgICAgIGMgPSBBZGRJU09EYXRlKG8sIGEsIGQsIDAsIDAsIDAsIDEsIFwicmVqZWN0XCIpLFxuICAgICAgICBoID0gbmV3IHIoYy55ZWFyLCBjLm1vbnRoLCBjLmRheSwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgICAgIHUgPSBHZXRTbG90KHRoaXMsIGcpLFxuICAgICAgICBUID0gR2V0U2xvdChHZXRJbnN0YW50Rm9yKHUsIG0sIFwiY29tcGF0aWJsZVwiKSwgbiksXG4gICAgICAgIHAgPSBHZXRTbG90KEdldEluc3RhbnRGb3IodSwgaCwgXCJjb21wYXRpYmxlXCIpLCBuKTtcbiAgICAgIHJldHVybiBCaWdJbnREaXZpZGVUb051bWJlcihwIC0gVCwgT2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5XZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5Nb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5Nb250aChHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aHNJblllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckluTGVhcFllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldFN0cmluZ0ZvcihHZXRTbG90KHRoaXMsIGcpLCBHZXRTbG90KHRoaXMsIFMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0TmFub3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEdldFNsb3QodGhpcywgZyksIEdldFNsb3QodGhpcywgUykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgem9uZWQtZGF0ZS10aW1lLWxpa2VcIik7XG4gICAgICBSZWplY3RUZW1wb3JhbExpa2VPYmplY3QoZSk7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIHApO1xuICAgICAgdmFyIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pO1xuICAgICAgbi5wdXNoKFwib2Zmc2V0XCIpO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW1wib2Zmc2V0XCJdKTtcbiAgICAgIGEgPSBDYWxlbmRhck1lcmdlRmllbGRzKG8sIGEsIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBuLCBcInBhcnRpYWxcIikpLCBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIG4sIFtcIm9mZnNldFwiXSk7XG4gICAgICB2YXIgaSA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihyKSxcbiAgICAgICAgcyA9IFRvVGVtcG9yYWxPZmZzZXQociwgXCJwcmVmZXJcIik7XG4gICAgICB2YXIgX0ludGVycHJldFRlbXBvcmFsRGF0NSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMobywgYSwgciksXG4gICAgICAgIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1LnllYXIsXG4gICAgICAgIGQgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm1vbnRoLFxuICAgICAgICBtID0gX0ludGVycHJldFRlbXBvcmFsRGF0NS5kYXksXG4gICAgICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1LmhvdXIsXG4gICAgICAgIGggPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm1pbnV0ZSxcbiAgICAgICAgdSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDUuc2Vjb25kLFxuICAgICAgICBUID0gX0ludGVycHJldFRlbXBvcmFsRGF0NS5taWxsaXNlY29uZCxcbiAgICAgICAgZiA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDUubWljcm9zZWNvbmQsXG4gICAgICAgIHkgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm5hbm9zZWNvbmQ7XG4gICAgICB2YXIgSSA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoYS5vZmZzZXQpLFxuICAgICAgICBTID0gR2V0U2xvdCh0aGlzLCBnKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoSW50ZXJwcmV0SVNPRGF0ZVRpbWVPZmZzZXQobCwgZCwgbSwgYywgaCwgdSwgVCwgZiwgeSwgXCJvcHRpb25cIiwgSSwgUywgaSwgcywgITEpLCBTLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFBsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgciA9IEdldFNsb3QodCwgaSksXG4gICAgICAgIG8gPSBHZXRTbG90KHQsIHMpLFxuICAgICAgICBhID0gR2V0U2xvdCh0LCBsKTtcbiAgICAgIHZhciBmID0gR2V0U2xvdCh0LCBwKTtcbiAgICAgIHZhciB5ID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIEkgPSBHZXRTbG90KHksIGQpLFxuICAgICAgICBTID0gR2V0U2xvdCh5LCBtKSxcbiAgICAgICAgdyA9IEdldFNsb3QoeSwgYyksXG4gICAgICAgIEQgPSBHZXRTbG90KHksIGgpLFxuICAgICAgICBHID0gR2V0U2xvdCh5LCB1KSxcbiAgICAgICAgdiA9IEdldFNsb3QoeSwgVCk7XG4gICAgICBmID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBwKSwgZik7XG4gICAgICB2YXIgQyA9IEdldFNsb3QodGhpcywgZyk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoR2V0SW5zdGFudEZvcihDLCBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSkociwgbywgYSwgSSwgUywgdywgRCwgRywgdiwgZiksIFwiY29tcGF0aWJsZVwiKSwgbiksIEMsIGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUGxhaW5UaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhQbGFpblRpbWUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpblRpbWUlXCIpLFxuICAgICAgICByID0gdm9pZCAwID09PSBlID8gbmV3IHQoKSA6IFRvVGVtcG9yYWxUaW1lKGUpLFxuICAgICAgICBvID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIGEgPSBHZXRTbG90KG8sIGkpLFxuICAgICAgICBmID0gR2V0U2xvdChvLCBzKSxcbiAgICAgICAgeSA9IEdldFNsb3QobywgbCksXG4gICAgICAgIEkgPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBTID0gR2V0U2xvdChyLCBkKSxcbiAgICAgICAgdyA9IEdldFNsb3QociwgbSksXG4gICAgICAgIEQgPSBHZXRTbG90KHIsIGMpLFxuICAgICAgICBHID0gR2V0U2xvdChyLCBoKSxcbiAgICAgICAgdiA9IEdldFNsb3QociwgdSksXG4gICAgICAgIEMgPSBHZXRTbG90KHIsIFQpLFxuICAgICAgICBPID0gR2V0U2xvdCh0aGlzLCBnKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKE8sIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpKShhLCBmLCB5LCBTLCB3LCBELCBHLCB2LCBDLCBJKSwgXCJjb21wYXRpYmxlXCIpLCBuKSwgTywgSSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhUaW1lWm9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoVGltZVpvbmUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgdCwgR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgR2V0U2xvdCh0aGlzLCBnKSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21ab25lZERhdGVUaW1lKFwiYWRkXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVpvbmVkRGF0ZVRpbWUoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsWm9uZWREYXRlVGltZShcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxab25lZERhdGVUaW1lKFwic2luY2VcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHIgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCB0KSA6IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQociksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHIsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgZiA9IEdldFRlbXBvcmFsVW5pdChyLCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUsIFtcImRheVwiXSksXG4gICAgICAgIHkgPSB7XG4gICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgIG1pbnV0ZTogNjAsXG4gICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICAgIH1bZl07XG4gICAgICBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQobywgeSwgMSA9PT0geSk7XG4gICAgICB2YXIgSSA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgdmFyIHcgPSBHZXRTbG90KEksIGkpLFxuICAgICAgICBEID0gR2V0U2xvdChJLCBzKSxcbiAgICAgICAgRyA9IEdldFNsb3QoSSwgbCksXG4gICAgICAgIHYgPSBHZXRTbG90KEksIGQpLFxuICAgICAgICBDID0gR2V0U2xvdChJLCBtKSxcbiAgICAgICAgTyA9IEdldFNsb3QoSSwgYyksXG4gICAgICAgIGIgPSBHZXRTbG90KEksIGgpLFxuICAgICAgICBFID0gR2V0U2xvdChJLCB1KSxcbiAgICAgICAgTSA9IEdldFNsb3QoSSwgVCk7XG4gICAgICB2YXIgUiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgRiA9IEdldFNsb3QodGhpcywgZyksXG4gICAgICAgIFkgPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBQID0gR2V0SW5zdGFudEZvcihGLCBuZXcgUihHZXRTbG90KEksIGkpLCBHZXRTbG90KEksIHMpLCBHZXRTbG90KEksIGwpLCAwLCAwLCAwLCAwLCAwLCAwKSwgXCJjb21wYXRpYmxlXCIpLFxuICAgICAgICBaID0gQWRkWm9uZWREYXRlVGltZShQLCBGLCBZLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgQiA9IFogLSBCaWdJbnQoR2V0U2xvdChQLCBuKSk7XG4gICAgICBpZiAoQiA8PSBJZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYW5ub3Qgcm91bmQgYSBab25lZERhdGVUaW1lIGluIGEgY2FsZW5kYXIgd2l0aCB6ZXJvIG9yIG5lZ2F0aXZlIGxlbmd0aCBkYXlzXCIpO1xuICAgICAgdmFyIF9Sb3VuZElTT0RhdGVUaW1lMyA9IFJvdW5kSVNPRGF0ZVRpbWUodywgRCwgRywgdiwgQywgTywgYiwgRSwgTSwgbywgZiwgYSwgTnVtYmVyKEIpKTtcbiAgICAgIHcgPSBfUm91bmRJU09EYXRlVGltZTMueWVhcjtcbiAgICAgIEQgPSBfUm91bmRJU09EYXRlVGltZTMubW9udGg7XG4gICAgICBHID0gX1JvdW5kSVNPRGF0ZVRpbWUzLmRheTtcbiAgICAgIHYgPSBfUm91bmRJU09EYXRlVGltZTMuaG91cjtcbiAgICAgIEMgPSBfUm91bmRJU09EYXRlVGltZTMubWludXRlO1xuICAgICAgTyA9IF9Sb3VuZElTT0RhdGVUaW1lMy5zZWNvbmQ7XG4gICAgICBiID0gX1JvdW5kSVNPRGF0ZVRpbWUzLm1pbGxpc2Vjb25kO1xuICAgICAgRSA9IF9Sb3VuZElTT0RhdGVUaW1lMy5taWNyb3NlY29uZDtcbiAgICAgIE0gPSBfUm91bmRJU09EYXRlVGltZTMubmFub3NlY29uZDtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoSW50ZXJwcmV0SVNPRGF0ZVRpbWVPZmZzZXQodywgRCwgRywgdiwgQywgTywgYiwgRSwgTSwgXCJvcHRpb25cIiwgR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoRiwgR2V0U2xvdCh0aGlzLCBTKSksIEYsIFwiY29tcGF0aWJsZVwiLCBcInByZWZlclwiLCAhMSksIEYsIEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZSh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgbiksXG4gICAgICAgIGEgPSBHZXRTbG90KHIsIG4pO1xuICAgICAgcmV0dXJuICEhKEJpZ0ludChvKSA9PT0gQmlnSW50KGEpKSAmJiAhIVRpbWVab25lRXF1YWxzKEdldFNsb3QodGhpcywgZyksIEdldFNsb3QociwgZykpICYmIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QociwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gR2V0T3B0aW9uc09iamVjdChlKSxcbiAgICAgICAgciA9IFRvQ2FsZW5kYXJOYW1lT3B0aW9uKHQpLFxuICAgICAgICBvID0gVG9GcmFjdGlvbmFsU2Vjb25kRGlnaXRzKHQpLFxuICAgICAgICBuID0gZnVuY3Rpb24gVG9TaG93T2Zmc2V0T3B0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gR2V0T3B0aW9uKGUsIFwib2Zmc2V0XCIsIFtcImF1dG9cIiwgXCJuZXZlclwiXSwgXCJhdXRvXCIpO1xuICAgICAgICB9KHQpLFxuICAgICAgICBhID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpLFxuICAgICAgICBpID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIFwidGltZVwiLCB2b2lkIDApO1xuICAgICAgaWYgKFwiaG91clwiID09PSBpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3QgYmUgYSB0aW1lIHVuaXQgb3RoZXIgdGhhbiBcImhvdXJcIicpO1xuICAgICAgdmFyIHMgPSBmdW5jdGlvbiBUb1RpbWVab25lTmFtZU9wdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIEdldE9wdGlvbihlLCBcInRpbWVab25lTmFtZVwiLCBbXCJhdXRvXCIsIFwibmV2ZXJcIiwgXCJjcml0aWNhbFwiXSwgXCJhdXRvXCIpO1xuICAgICAgICB9KHQpLFxuICAgICAgICBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uUmVjb3JkKGksIG8pLFxuICAgICAgICBsID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNS5wcmVjaXNpb24sXG4gICAgICAgIGQgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1LnVuaXQsXG4gICAgICAgIG0gPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1LmluY3JlbWVudDtcbiAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCBsLCByLCBzLCBuLCB7XG4gICAgICAgIHVuaXQ6IGQsXG4gICAgICAgIGluY3JlbWVudDogbSxcbiAgICAgICAgcm91bmRpbmdNb2RlOiBhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBZdChudWxsKTtcbiAgICAgIGlmIChDb3B5RGF0YVByb3BlcnRpZXMobywgciwgW1widGltZVpvbmVcIl0pLCB2b2lkIDAgIT09IHIudGltZVpvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJab25lZERhdGVUaW1lIHRvTG9jYWxlU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhIHRpbWVab25lIG9wdGlvblwiKTtcbiAgICAgIHZvaWQgMCA9PT0gby55ZWFyICYmIHZvaWQgMCA9PT0gby5tb250aCAmJiB2b2lkIDAgPT09IG8uZGF5ICYmIHZvaWQgMCA9PT0gby53ZWVrZGF5ICYmIHZvaWQgMCA9PT0gby5kYXRlU3R5bGUgJiYgdm9pZCAwID09PSBvLmhvdXIgJiYgdm9pZCAwID09PSBvLm1pbnV0ZSAmJiB2b2lkIDAgPT09IG8uc2Vjb25kICYmIHZvaWQgMCA9PT0gby50aW1lU3R5bGUgJiYgdm9pZCAwID09PSBvLmRheVBlcmlvZCAmJiB2b2lkIDAgPT09IG8udGltZVpvbmVOYW1lICYmIChvLnRpbWVab25lTmFtZSA9IFwic2hvcnRcIik7XG4gICAgICB2YXIgbiA9IFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBnKSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhuKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0b0xvY2FsZVN0cmluZyBkb2VzIG5vdCBzdXBwb3J0IG9mZnNldCBzdHJpbmcgdGltZSB6b25lc1wiKTtcbiAgICAgIG4gPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIobiksIG8udGltZVpvbmUgPSBuO1xuICAgICAgdmFyIGEgPSBuZXcgaHQoZSwgbyksXG4gICAgICAgIGkgPSBDYWxsKEZ0LCBhLCBbXSkuY2FsZW5kYXIsXG4gICAgICAgIHMgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgICAgaWYgKFwiaXNvODYwMVwiICE9PSBzICYmIFwiaXNvODYwMVwiICE9PSBpICYmIGkgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IGZvcm1hdCBab25lZERhdGVUaW1lIHdpdGggY2FsZW5kYXIgXCIuY29uY2F0KHMsIFwiIGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyIFwiKS5jb25jYXQoaSkpO1xuICAgICAgcmV0dXJuIGEuZm9ybWF0KEdldFNsb3QodGhpcywgUykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcodGhpcywgXCJhdXRvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2ZEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkRheSgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIGUgPSBkYXRlVGltZSh0aGlzKSxcbiAgICAgICAgdCA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG8gPSBuZXcgdChHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCAwLCAwLCAwLCAwLCAwLCAwLCByKSxcbiAgICAgICAgYSA9IEdldFNsb3QodGhpcywgZyk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoR2V0SW5zdGFudEZvcihhLCBvLCBcImNvbXBhdGlibGVcIiksIG4pLCBhLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9JbnN0YW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSW5zdGFudCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShHZXRTbG90KHRoaXMsIG4pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpblRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpblRpbWUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlVGltZSgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIGRhdGVUaW1lKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluWWVhck1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluTW9udGhEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbk1vbnRoRGF5KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIHQgPSBHZXRTbG90KHRoaXMsIGcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIGlzb0RheTogR2V0U2xvdChlLCBsKSxcbiAgICAgICAgaXNvSG91cjogR2V0U2xvdChlLCBkKSxcbiAgICAgICAgaXNvTWljcm9zZWNvbmQ6IEdldFNsb3QoZSwgdSksXG4gICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KGUsIGgpLFxuICAgICAgICBpc29NaW51dGU6IEdldFNsb3QoZSwgbSksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KGUsIHMpLFxuICAgICAgICBpc29OYW5vc2Vjb25kOiBHZXRTbG90KGUsIFQpLFxuICAgICAgICBpc29TZWNvbmQ6IEdldFNsb3QoZSwgYyksXG4gICAgICAgIGlzb1llYXI6IEdldFNsb3QoZSwgaSksXG4gICAgICAgIG9mZnNldDogR2V0T2Zmc2V0U3RyaW5nRm9yKHQsIEdldFNsb3QodGhpcywgUykpLFxuICAgICAgICB0aW1lWm9uZTogdFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJPYmplY3QoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWVab25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpbWVab25lKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWVab25lT2JqZWN0KEdldFNsb3QodGhpcywgZykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlLCB0KSB7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkgPyAoVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKHIpLCBUb1RlbXBvcmFsT2Zmc2V0KHIsIFwicmVqZWN0XCIpLCBUb1RlbXBvcmFsT3ZlcmZsb3cociksIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGUsIG4pLCBHZXRTbG90KGUsIGcpLCBHZXRTbG90KGUsIHApKSkgOiBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShlLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKHQsIHIpIHtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUodCksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShyKSxcbiAgICAgICAgaSA9IEdldFNsb3QobywgbiksXG4gICAgICAgIHMgPSBHZXRTbG90KGEsIG4pO1xuICAgICAgcmV0dXJuIEJpZ0ludChpKSA8IEJpZ0ludChzKSA/IC0xIDogQmlnSW50KGkpID4gQmlnSW50KHMpID8gMSA6IDA7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBab25lZERhdGVUaW1lO1xufSgpO1xuZnVuY3Rpb24gZGF0ZVRpbWUoZSkge1xuICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGUsIGcpLCBHZXRTbG90KGUsIFMpLCBHZXRTbG90KGUsIHApKTtcbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhab25lZERhdGVUaW1lLCBcIlRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIik7XG52YXIgUHQgPSBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDYWxlbmRhcjogQ2FsZW5kYXIsXG4gIER1cmF0aW9uOiBEdXJhdGlvbixcbiAgSW5zdGFudDogSW5zdGFudCxcbiAgTm93OiBFdCxcbiAgUGxhaW5EYXRlOiBQbGFpbkRhdGUsXG4gIFBsYWluRGF0ZVRpbWU6IFBsYWluRGF0ZVRpbWUsXG4gIFBsYWluTW9udGhEYXk6IFBsYWluTW9udGhEYXksXG4gIFBsYWluVGltZTogUGxhaW5UaW1lLFxuICBQbGFpblllYXJNb250aDogUGxhaW5ZZWFyTW9udGgsXG4gIFRpbWVab25lOiBUaW1lWm9uZSxcbiAgWm9uZWREYXRlVGltZTogWm9uZWREYXRlVGltZVxufSk7XG5mdW5jdGlvbiB0b1RlbXBvcmFsSW5zdGFudCgpIHtcbiAgdmFyIHQgPSBCaWdJbnQoK3RoaXMpICogR2U7XG4gIHJldHVybiBuZXcgSW5zdGFudCh0KTtcbn1cbnZhciBadCA9IFtJbnN0YW50LCBDYWxlbmRhciwgUGxhaW5EYXRlLCBQbGFpbkRhdGVUaW1lLCBEdXJhdGlvbiwgUGxhaW5Nb250aERheSwgUGxhaW5UaW1lLCBUaW1lWm9uZSwgUGxhaW5ZZWFyTW9udGgsIFpvbmVkRGF0ZVRpbWVdO1xuZm9yICh2YXIgX2kzMCA9IDAsIF9adCA9IFp0OyBfaTMwIDwgX1p0Lmxlbmd0aDsgX2kzMCsrKSB7XG4gIHZhciBfZTYyID0gX1p0W19pMzBdO1xuICB2YXIgX3Q1NyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2U2MiwgXCJwcm90b3R5cGVcIik7XG4gIChfdDU3LmNvbmZpZ3VyYWJsZSB8fCBfdDU3LmVudW1lcmFibGUgfHwgX3Q1Ny53cml0YWJsZSkgJiYgKF90NTcuY29uZmlndXJhYmxlID0gITEsIF90NTcuZW51bWVyYWJsZSA9ICExLCBfdDU3LndyaXRhYmxlID0gITEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZTYyLCBcInByb3RvdHlwZVwiLCBfdDU3KSk7XG59XG5cbnZhciBUZW1wb3JhbFBvbHlmaWxsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEludGw6IHV0LFxuICBUZW1wb3JhbDogUHQsXG4gIHRvVGVtcG9yYWxJbnN0YW50OiB0b1RlbXBvcmFsSW5zdGFudFxufSk7XG5cbmdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbCA9IFRlbXBvcmFsUG9seWZpbGw7XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQodikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvcyh4KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2NhbWxfZXhuX2lzX21vc3RfcmVjZW50X2V4biBjb25zdFxuZnVuY3Rpb24gQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG4oeCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHogY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpIHtcbiAgdmFyIG4gPSAzMjtcbiAgdmFyIHk7XG4gIHkgPSB4ID4+IDE2OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gMTY7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDg7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0geCA+PiA0OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gNDsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDE7IGlmICh5ICE9IDApIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSB4O1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NselxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfdG9faW50MzJcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfY2x6KHgpIHtcbiAgdmFyIG4gPSA2NDtcbiAgdmFyIHk7XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDMyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSAzMjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMTYpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDE2OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA4KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA4OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAyKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHsgbiA9IG4gLSAyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxKTtcbiAgaWYgKCFjYW1sX2ludDY0X2lzX3plcm8oeSkpIHJldHVybiBuIC0gMjtcbiAgcmV0dXJuIG4gLSBjYW1sX2ludDY0X3RvX2ludDMyKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCkge1xuICBpZiAoeCA9PT0gMCkgeyByZXR1cm4gMzI7IH1cbiAgdmFyIG4gPSAxO1xuICBpZiAoKHggJiAweDAwMDBGRkZGKSA9PT0gMCkgeyBuID0gbiArIDE2OyB4ID0geCA+PiAxNjsgfVxuICBpZiAoKHggJiAweDAwMDAwMEZGKSA9PT0gMCkgeyBuID0gbiArIDg7IHggPSB4ID4+IDg7IH1cbiAgaWYgKCh4ICYgMHgwMDAwMDAwRikgPT09IDApIHsgbiA9IG4gKyA0OyB4ID0geCA+PiA0OyB9XG4gIGlmICgoeCAmIDB4MDAwMDAwMDMpID09PSAwKSB7IG4gPSBuICsgMjsgeCA9IHggPj4gMjsgfVxuICByZXR1cm4gbiAtICh4ICYgMSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2N0eiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2N0eih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hbmQsIGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X2N0eih4KSB7XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8oeCkpIHsgcmV0dXJuIDY0OyB9XG4gIHZhciBuID0gMTtcbiAgZnVuY3Rpb24gaXNfemVybyh4KSB7IHJldHVybiBjYW1sX2ludDY0X2lzX3plcm8oeCk7IH1cbiAgZnVuY3Rpb24gbGFuZCh4LCB5KSB7IHJldHVybiBjYW1sX2ludDY0X2FuZCh4LCB5KTsgfVxuICBmdW5jdGlvbiBzbWFsbF9pbnQ2NCh4KSB7IHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSh4LCAwLCAwKTsgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4RkZGRkZGLCAweDAwMDBGRiwgMHgwMDAwKSkpKSB7XG4gICAgbiA9IG4gKyAzMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMEZGRkYpKSkpIHtcbiAgICBuID0gbiArIDE2OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDBGRikpKSkge1xuICAgIG4gPSBuICsgODsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgOCk7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwRikpKSkge1xuICAgIG4gPSBuICsgNDsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgNCk7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwMykpKSkge1xuICAgIG4gPSBuICsgMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMik7XG4gIH1cbiAgcmV0dXJuIG4gLSAoY2FtbF9pbnQ2NF90b19pbnQzMihjYW1sX2ludDY0X2FuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwMSkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gMTtcbiAgdmFyIG11bCA9IFtvbmUsIGJhc2UsIG9uZSwgb25lXTtcbiAgdmFyIHJlcyA9IG9uZTtcbiAgd2hpbGUgKCFleHBvbmVudCA9PSAwKSB7XG4gICAgbXVsWzFdID0gKG11bFsxXSAqIG11bFszXSkgfCAwO1xuICAgIG11bFsyXSA9IChtdWxbMV0gKiBtdWxbMV0pIHwgMDtcbiAgICBtdWxbM10gPSAobXVsWzJdICogbXVsWzFdKSB8IDA7XG4gICAgcmVzID0gKHJlcyAqIG11bFtleHBvbmVudCAmIDNdKSB8IDA7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCA+PiAyO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfcG93X3N0dWIoYmFzZSwgZXhwb25lbnQpIHtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKDEsIDApO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWNhbWxfaW50NjRfaXNfemVybyhleHBvbmVudCkpIHtcbiAgICBtdWxbMV0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFszXSk7XG4gICAgbXVsWzJdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzFdLCBtdWxbMV0pO1xuICAgIG11bFszXSA9IGNhbWxfaW50NjRfbXVsKG11bFsyXSwgbXVsWzFdKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X211bChyZXMsIG11bFtjYW1sX2ludDY0X2xvMzIoZXhwb25lbnQpICYgM10pO1xuICAgIGV4cG9uZW50ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZChleHBvbmVudCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9oYXNoX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsIDEsIDAsIHMpXG59XG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfZG91YmxlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9kb3VibGUoZCkge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsIDEsIDAsIGQpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2FtX3Rlc3RpbmcgY29uc3Rcbi8vV2Vha2RlZlxuZnVuY3Rpb24gQmFzZV9hbV90ZXN0aW5nKHgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfdW5zYWZlX2NyZWF0ZV9sb2NhbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXNcbmZ1bmN0aW9uIEJhc2VfdW5zYWZlX2NyZWF0ZV9sb2NhbF9ieXRlcyh2X2xlbikge1xuICAvLyBUaGlzIGRvZXMgYSByZWR1bmRhbnQgYm91bmRzIGNoZWNrIGFuZCAoc2luY2UgdGhpcyBpc1xuICAvLyBqYXZhc2NyaXB0KSBkb2Vzbid0IGFsbG9jYXRlIGxvY2FsbHksIGJ1dCB0aGF0J3MgZmluZS5cbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2J5dGVzKHZfbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2xvY2FsX3ZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV92ZWN0XG5mdW5jdGlvbiBjYW1sX21ha2VfbG9jYWxfdmVjdCh2X2xlbiwgdl9lbHQpIHtcbiAgLy8gSW4gamF2YXNjcmlwdCB0aGVyZSdzIG5vIGxvY2FsIGFsbG9jYXRpb24uXG4gIHJldHVybiBjYW1sX21ha2VfdmVjdCh2X2xlbiwgdl9lbHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2R1bW15X29ial9pc19zdGFja1xuZnVuY3Rpb24gY2FtbF9kdW1teV9vYmpfaXNfc3RhY2soeCkge1xuICB0aHJvdyBuZXcgRXJyb3IoYEJVRzogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdW5yZWFjaGFibGU7IHBsZWFzZSByZXBvcnQgdG8gY29tcGlsZXIgb3IgYmFzZSBkZXZzLmApO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15KHgsIHkpIHtcbiAgaWYgKHkuZnVuKSB7XG4gICAgeC5mdW4gPSB5LmZ1bjtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHguZnVuID0geTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgaSA9IHkubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2NfZHVtbXlfaW5maXhcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbi8vVmVyc2lvbjogPCA1LjRcbmZ1bmN0aW9uIGNhbWxfYWxsb2NfZHVtbXlfaW5maXgoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmKHgpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgW3hdKTtcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19kdW1teV9sYXp5XG4vL1ZlcnNpb246ID49IDUuNFxuZnVuY3Rpb24gY2FtbF9hbGxvY19kdW1teV9sYXp5KF91bml0KSB7XG4gIHJldHVybiBbMCwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15X2xhenlcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF91cGRhdGVfZHVtbXlcbi8vVmVyc2lvbjogPj0gNS40XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teV9sYXp5KGR1bW15LCBuZXd2YWwpIHtcbiAgc3dpdGNoIChjYW1sX29ial90YWcobmV3dmFsKSkge1xuICAgIGNhc2UgMjQ2OiAvLyBMYXp5XG4gICAgY2FzZSAyNDQ6IC8vIEZvcmNpbmdcbiAgICBjYXNlIDI1MDogLy8gRm9yd2FyZFxuICAgICAgY2FtbF91cGRhdGVfZHVtbXkoZHVtbXksIG5ld3ZhbCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZHVtbXlbMV0gPSBuZXd2YWw7XG4gICAgICBkdW1teVswXSA9IDI1MDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcoeCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJiB4WzBdID09PSB4WzBdID4+PiAwKSByZXR1cm4geFswXTtcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSkgcmV0dXJuIDI1MjtcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpIHJldHVybiAyNTI7XG4gIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMjQ3O1xuICBlbHNlIGlmICh4Py5jYW1sX2N1c3RvbSkgcmV0dXJuIDI1NTtcbiAgZWxzZSByZXR1cm4gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnKHgsIHRhZykge1xuICB4WzBdID0gdGFnO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrKHRhZywgc2l6ZSkge1xuICAvLyBUT0RPOiBmYWlsIGZvciB2YWx1ZSB0aGF0IGFyZSBub3QgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXlcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSArIDEpO1xuICBvWzBdID0gdGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZywgeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsOyBpKyspIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyB4IDogeC5zbGljZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlKHgsIHMpIHtcbiAgaWYgKHMgPD0gMCB8fCBzICsgMSA+IHgubGVuZ3RoKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZChiLCB2KSB7XG4gIGJbMF0gPSAyNTA7XG4gIGJbMV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCwgaSwgb2xkLCBuKSB7XG4gIGlmICh4W2kgKyAxXSA9PT0gb2xkKSB7XG4gICAgeFtpICsgMV0gPSBuO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19zaGFyZWRcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoX3gpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkKHYpIHtcbiAgcmV0dXJuIFsyNTAsIHZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ldGhvZF9jYWNoZVxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fY2FjaGVfaWQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWV0aG9kX2NhY2hlXG5mdW5jdGlvbiBjYW1sX29vX2NhY2hlX2lkKCkge1xuICB2YXIgY2FjaGVpZCA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDtcbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSAwO1xuICBjYWNoZWlkO1xufVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jYWNoZWRfbWV0aG9kIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21ldGhvZF9jYWNoZVxuZnVuY3Rpb24gY2FtbF9nZXRfY2FjaGVkX21ldGhvZChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG1ldGhzW29mcyArIDRdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzICsgM107XG4gIH1cbiAgdmFyIGxpID0gMyxcbiAgICBoaSA9IG1ldGhzWzFdICogMiArIDEsXG4gICAgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpICsgaGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkgKyAxXSkgaGkgPSBtaSAtIDI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgLSAzO1xuICByZXR1cm4gbWV0aHNbbGldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kKG9iaiwgdGFnKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIGxpID0gMyxcbiAgICBoaSA9IG1ldGhzWzFdICogMiArIDEsXG4gICAgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpICsgaGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkgKyAxXSkgaGkgPSBtaSAtIDI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuIHRhZyA9PT0gbWV0aHNbbGkgKyAxXSA/IG1ldGhzW2xpXSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkKGIpIHtcbiAgYlsyXSA9IGNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8sIGkpIHtcbiAgcmV0dXJuIG9baSArIDFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8sIGksIHYpIHtcbiAgcmV0dXJuIChvW2kgKyAxXSA9IHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yZWFjaGFibGVfd29yZHNcbmZ1bmN0aW9uIGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkcyhfbykge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldChfdiwgX29mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfb2JqX3VwZGF0ZV90YWcoYiwgbywgbikge1xuICBpZiAoYlswXSA9PT0gbykge1xuICAgIGJbMF0gPSBuO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmdcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmcobykge1xuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShvKSAmJlxuICAgIG9bMF0gPT09IG9bMF0gPj4+IDAgJiZcbiAgICBjYW1sX29ial91cGRhdGVfdGFnKG8sIDI0NiwgMjQ0KVxuICApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmQobykge1xuICBjYW1sX29ial91cGRhdGVfdGFnKG8sIDI0NCwgMjUwKTtcbiAgcmV0dXJuIDA7IC8vIHVuaXRcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenlcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eShvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywgMjQ0LCAyNDYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3JlYWRfcmVzdWx0XG4vL1JlcXVpcmVzOiBjYW1sX29ial90YWdcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVhZF9yZXN1bHQobykge1xuICByZXR1cm4gY2FtbF9vYmpfdGFnKG8pID09PSAyNTAgPyBvWzFdIDogbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246IDwgNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKF90KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKHQpIHtcbiAgcmV0dXJuIHQgPT09IDI0NSA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9pZGVudGlmaWVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jdXN0b21faWRlbnRpZmllcihvKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhvLmNhbWxfY3VzdG9tKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9nY19yYW1wX3VwXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246ID49IDUuNFxuZnVuY3Rpb24gY2FtbF9tbF9nY19yYW1wX3VwKGYpIHtcbiAgdmFyIGEgPSBjYW1sX2NhbGxiYWNrKGYsIFswXSk7XG4gIHZhciBzdXNwZW5kZWQgPSAwO1xuICByZXR1cm4gWzAsIGEsIHN1c3BlbmRlZF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZ2NfcmFtcF9kb3duXG4vL1ZlcnNpb246ID49IDUuNFxuZnVuY3Rpb24gY2FtbF9tbF9nY19yYW1wX2Rvd24oX3N1c3BlbmRlZF9jb2xsZWN0aW9uX3dvcmspIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vQWxpYXM6IGNhbWxfaW50MzJfZm9ybWF0XG4vL0FsaWFzOiBjYW1sX25hdGl2ZWludF9mb3JtYXRcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PT0gXCIlZFwiKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIgKyBpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHtcbiAgICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgICBmLnNpZ24gPSAtMTtcbiAgICAgIGkgPSAtaTtcbiAgICB9IGVsc2UgaSA+Pj49IDA7XG4gIH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gXCIgXCI7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQobiwgXCIwXCIpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZShzKSB7XG4gIHZhciBpID0gMCxcbiAgICBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksXG4gICAgYmFzZSA9IDEwLFxuICAgIHNpZ24gPSAxLFxuICAgIHNpZ25lZG5lc3MgPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSkge1xuICAgICAgY2FzZSA0NTpcbiAgICAgICAgaSsrO1xuICAgICAgICBzaWduID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0MzpcbiAgICAgICAgaSsrO1xuICAgICAgICBzaWduID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgICBjYXNlIDEyMDpcbiAgICAgIGNhc2UgODg6XG4gICAgICAgIHNpZ25lZG5lc3MgPSAwO1xuICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExMTpcbiAgICAgIGNhc2UgNzk6XG4gICAgICAgIHNpZ25lZG5lc3MgPSAwO1xuICAgICAgICBiYXNlID0gODtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTg6XG4gICAgICBjYXNlIDY2OlxuICAgICAgICBzaWduZWRuZXNzID0gMDtcbiAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExNzpcbiAgICAgIGNhc2UgODU6XG4gICAgICAgIHNpZ25lZG5lc3MgPSAwO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlLCBzaWduZWRuZXNzXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogY2FtbF9pbnQzMl9vZl9zdHJpbmdcbi8vQWxpYXM6IGNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Uocyk7XG4gIHZhciBpID0gclswXSxcbiAgICBzaWduID0gclsxXSxcbiAgICBiYXNlID0gclsyXSxcbiAgICBzaWduZWRuZXNzID0gclszXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IGkgPCBsZW4gPyBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpIDogMDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9PSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKHNpZ25lZG5lc3MgJiYgKHJlcyB8IDApICE9PSByZXMpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuLy9BbGlhczogY2FtbF9pbnQzMl9tdWxcbi8vQWxpYXM6IGNhbWxfbmF0aXZlaW50X211bFxuLy9BbGlhczogJWludF9tdWxcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguaW11bChhLCBiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vQWxpYXM6IGNhbWxfaW50MzJfZGl2XG4vL0FsaWFzOiBjYW1sX25hdGl2ZWludF9kaXZcbi8vQWxpYXM6ICVpbnRfZGl2XG5mdW5jdGlvbiBjYW1sX2Rpdih4LCB5KSB7XG4gIGlmICh5ID09PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIHJldHVybiAoeCAvIHkpIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vQWxpYXM6IGNhbWxfaW50MzJfbW9kXG4vL0FsaWFzOiBjYW1sX25hdGl2ZWludF9tb2Rcbi8vQWxpYXM6ICVpbnRfbW9kXG5mdW5jdGlvbiBjYW1sX21vZCh4LCB5KSB7XG4gIGlmICh5ID09PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gIHJldHVybiB4ICUgeTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCh4ICYgMHgwMGZmKSA8PCA4KSB8ICgoeCAmIDB4ZmYwMCkgPj4gOCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXAgY29uc3Rcbi8vQWxpYXM6IGNhbWxfbmF0aXZlaW50X2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuIChcbiAgICAoKHggJiAweDAwMDAwMGZmKSA8PCAyNCkgfFxuICAgICgoeCAmIDB4MDAwMGZmMDApIDw8IDgpIHxcbiAgICAoKHggJiAweDAwZmYwMDAwKSA+Pj4gOCkgfFxuICAgICgoeCAmIDB4ZmYwMDAwMDApID4+PiAyNClcbiAgKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXAgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCwgZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MSB8IDApO1xuICBkID0gKGQgPDwgMTUpIHwgKGQgPj4+ICgzMiAtIDE1KSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKGggPDwgMTMpIHwgKGggPj4+ICgzMiAtIDEzKSk7IC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSkgfCAwKSArICgweGU2NTQ2YjY0IHwgMCkpIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwoaCwgMHg4NWViY2E2YiB8IDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwoaCwgMHhjMmIyYWUzNSB8IDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQoaGFzaCwgdjApIHtcbiAgdmFyIGk2NCA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2MCk7XG4gIHZhciBsID0gY2FtbF9pbnQ2NF9sbzMyKGk2NCk7XG4gIHZhciBoID0gY2FtbF9pbnQ2NF9oaTMyKGk2NCk7XG4gIC8qIE5vcm1hbGl6ZSBOYU5zICovXG4gIGlmICgoaCAmIDB4N2ZmMDAwMDApID09PSAweDdmZjAwMDAwICYmIChsIHwgKGggJiAweGZmZmZmKSkgIT09IDApIHtcbiAgICBoID0gMHg3ZmYwMDAwMDtcbiAgICBsID0gMHgwMDAwMDAwMTtcbiAgfSBlbHNlIGlmIChoID09PSAoMHg4MDAwMDAwMCB8IDApICYmIGwgPT09IDApIHtcbiAgICAvKiBOb3JtYWxpemUgLTAgaW50byArMCAqL1xuICAgIC8vIFRoaXMgY29kZSBwYXRoIGlzIG5vdCB1c2VkIGJ5IGNhbWxfaGFzaCBiZWNhdXNlIDAgYW5kIC0wIGxvb2tcbiAgICAvLyBsaWtlIGludGVnZXJzXG4gICAgaCA9IDA7XG4gIH1cbiAgaGFzaCA9IGNhbWxfaGFzaF9taXhfaW50KGhhc2gsIGwpO1xuICBoYXNoID0gY2FtbF9oYXNoX21peF9pbnQoaGFzaCwgaCk7XG4gIHJldHVybiBoYXNoO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLFxuICAgIGksXG4gICAgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID1cbiAgICAgIHMuY2hhckNvZGVBdChpKSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAxKSA8PCA4KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAyKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpICsgMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gICAgY2FzZSAzOlxuICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgdyA9IHMuY2hhckNvZGVBdChpICsgMikgPDwgMTY7XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIDI6XG4gICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICB3IHw9IHMuY2hhckNvZGVBdChpICsgMSkgPDwgODtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMTpcbiAgICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCxcbiAgICBpLFxuICAgIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV0gfCAoc1tpICsgMV0gPDwgOCkgfCAoc1tpICsgMl0gPDwgMTYpIHwgKHNbaSArIDNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICAgIGNhc2UgMzpcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIHcgPSBzW2kgKyAyXSA8PCAxNjtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMjpcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIHcgfD0gc1tpICsgMV0gPDwgODtcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgMTpcbiAgICAgIHcgfD0gc1tpXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY29udGVudCk7XG4gIC8qIEFSUkFZICovIGVsc2UgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG5mdW5jdGlvbiBjYW1sX2hhc2goY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTtcbiAgcmQgPSAwO1xuICB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHY/LmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJlxuICAgICAgICBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaFxuICAgICAgKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgaGgpO1xuICAgICAgICBudW0tLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikgJiYgdlswXSA9PT0gKHZbMF0gfCAwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAgIC8vIE9iamVjdFxuICAgICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgICBudW0tLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTA6XG4gICAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgICAvKiBBbGwgY29udGludWF0aW9ucyBoYXNoIHRvIHRoZSBzYW1lIHZhbHVlLFxuICAgICAgICAgICAgIHNpbmNlIHdlIGhhdmUgbm8gaWRlYSBob3cgdG8gZGlzdGluZ3Vpc2ggdGhlbS4gKi9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgdik7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2IHwgMCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2ICsgdiArIDEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M2ZmZmZmZmY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfaGFzaChoLCB2KSB7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNmZmZmZmZmO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuY2xhc3MgTWxJbnQ2NCB7XG4gIGNvbnN0cnVjdG9yKGxvLCBtaSwgaGkpIHtcbiAgICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG4gICAgdGhpcy5jYW1sX2N1c3RvbSA9IFwiX2pcIjtcbiAgfVxuXG4gIHN0YXRpYyBVTlNJR05FRF9NQVggPSBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmYsIDB4ZmZmZik7XG4gIHN0YXRpYyBTSUdORURfTUFYID0gbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmLCAweDdmZmYpO1xuICBzdGF0aWMgU0lHTkVEX01JTiA9IG5ldyBNbEludDY0KDB4MDAwMDAwLCAweDAwMDAwMCwgMHg4MDAwKTtcblxuICBzbGljZSgpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbywgdGhpcy5taSwgdGhpcy5oaSk7XG4gIH1cblxuICB1Y29tcGFyZSh4KSB7XG4gICAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb21wYXJlKHgpIHtcbiAgICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICAgIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICAgIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gICAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgbmVnKCkge1xuICAgIHZhciBsbyA9IC10aGlzLmxvO1xuICAgIHZhciBtaSA9IC10aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgICB2YXIgaGkgPSAtdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xuICB9XG5cbiAgYWRkKHgpIHtcbiAgICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gICAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbiAgfVxuXG4gIHN1Yih4KSB7XG4gICAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gICAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICAgIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG4gIH1cblxuICBtdWwoeCkge1xuICAgIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICAgIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gICAgdmFyIGhpID1cbiAgICAgICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArXG4gICAgICB0aGlzLmhpICogeC5sbyArXG4gICAgICB0aGlzLm1pICogeC5taSArXG4gICAgICB0aGlzLmxvICogeC5oaTtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG4gIH1cblxuICBpc1plcm8oKSB7XG4gICAgcmV0dXJuICh0aGlzLmxvIHwgdGhpcy5taSB8IHRoaXMuaGkpID09PSAwO1xuICB9XG5cbiAgaXNOZWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGkgPDwgMTYgPCAwO1xuICB9XG5cbiAgYW5kKHgpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG4gIH1cblxuICBvcih4KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gfCB4LmxvLCB0aGlzLm1pIHwgeC5taSwgdGhpcy5oaSB8IHguaGkpO1xuICB9XG5cbiAgeG9yKHgpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyBeIHgubG8sIHRoaXMubWkgXiB4Lm1pLCB0aGlzLmhpIF4geC5oaSk7XG4gIH1cblxuICBzaGlmdF9sZWZ0KHMpIHtcbiAgICBzID0gcyAmIDYzO1xuICAgIGlmIChzID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAocyA8IDI0KSB7XG4gICAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAgIHRoaXMubG8gPDwgcyxcbiAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHMgPCA0OClcbiAgICAgIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpLFxuICAgICAgKTtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSk7XG4gIH1cblxuICBzaGlmdF9yaWdodF91bnNpZ25lZChzKSB7XG4gICAgcyA9IHMgJiA2MztcbiAgICBpZiAocyA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHMgPCAyNClcbiAgICAgIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgICB0aGlzLmhpID4+IHMsXG4gICAgICApO1xuICAgIGlmIChzIDwgNDgpXG4gICAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICAgdGhpcy5oaSA+PiAocyAtIDI0KSxcbiAgICAgICAgMCxcbiAgICAgICk7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xuICB9XG5cbiAgc2hpZnRfcmlnaHQocykge1xuICAgIHMgPSBzICYgNjM7XG4gICAgaWYgKHMgPT09IDApIHJldHVybiB0aGlzO1xuICAgIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICAgIGlmIChzIDwgMjQpXG4gICAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYsXG4gICAgICApO1xuICAgIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICAgIGlmIChzIDwgNDgpXG4gICAgICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSkgPj4gMTYsXG4gICAgICAgIHNpZ24gJiAweGZmZmYsXG4gICAgICApO1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xuICB9XG5cbiAgbHNsMSgpIHtcbiAgICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gICAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbiAgfVxuXG4gIGxzcjEoKSB7XG4gICAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gICAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gICAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG4gIH1cblxuICB1ZGl2bW9kKHgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbW9kdWx1cyA9IHRoaXMuc2xpY2UoKTtcbiAgICB2YXIgZGl2aXNvciA9IHguc2xpY2UoKTtcbiAgICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLCAwLCAwKTtcbiAgICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICAgIG9mZnNldCsrO1xuICAgICAgZGl2aXNvci5sc2wxKCk7XG4gICAgfVxuICAgIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgICAgb2Zmc2V0LS07XG4gICAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICAgIHF1b3RpZW50LmxvKys7XG4gICAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICAgIH1cbiAgICAgIGRpdmlzb3IubHNyMSgpO1xuICAgIH1cbiAgICByZXR1cm4geyBxdW90aWVudDogcXVvdGllbnQsIG1vZHVsdXM6IG1vZHVsdXMgfTtcbiAgfVxuXG4gIGRpdih5KSB7XG4gICAgdmFyIHggPSB0aGlzO1xuICAgIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gICAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gICAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICAgIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICAgIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgICByZXR1cm4gcTtcbiAgfVxuXG4gIG1vZCh5KSB7XG4gICAgdmFyIHggPSB0aGlzO1xuICAgIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlKCk7XG4gICAgdmFyIHNpZ24gPSB4LmhpO1xuICAgIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gICAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICB0b0ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbiAgfVxuXG4gIHRvRmxvYXQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkgKyB0aGlzLmxvXG4gICAgKTtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuaGkgPj4gOCxcbiAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgIHRoaXMubG8gJiAweGZmLFxuICAgIF07XG4gIH1cblxuICBsbzMyKCkge1xuICAgIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xuICB9XG5cbiAgaGkzMigpIHtcbiAgICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgsIHkpIHtcbiAgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LCB5LCBfdG90YWwpIHtcbiAgcmV0dXJuIHguY29tcGFyZSh5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnKHgpIHtcbiAgcmV0dXJuIHgubmVnKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCh4LCB5KSB7XG4gIHJldHVybiB4LmFkZCh5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViKHgsIHkpIHtcbiAgcmV0dXJuIHguc3ViKHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgsIHkpIHtcbiAgcmV0dXJuIHgubXVsKHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7XG4gIHJldHVybiAreC5pc1plcm8oKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7XG4gIHJldHVybiAreC5pc05lZygpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQoeCwgeSkge1xuICByZXR1cm4geC5hbmQoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IoeCwgeSkge1xuICByZXR1cm4geC5vcih5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yKHgsIHkpIHtcbiAgcmV0dXJuIHgueG9yKHkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCh4LCBzKSB7XG4gIHJldHVybiB4LnNoaWZ0X2xlZnQocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgcykge1xuICByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCh4LCBzKSB7XG4gIHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdlxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYoeCwgeSkge1xuICByZXR1cm4geC5kaXYoeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kXG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCh4LCB5KSB7XG4gIHJldHVybiB4Lm1vZCh5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuLy9BbGlhczogY2FtbF9pbnQ2NF9vZl9pbnRcbi8vQWxpYXM6IGNhbWxfaW50NjRfb2ZfbmF0aXZlaW50XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3Rcbi8vQWxpYXM6IGNhbWxfaW50NjRfdG9faW50XG4vL0FsaWFzOiBjYW1sX2ludDY0X3RvX25hdGl2ZWludFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMih4KSB7XG4gIHJldHVybiB4LnRvSW50KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQoeCkge1xuICByZXR1cm4geC50b0Zsb2F0KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0KHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7XG4gICAgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSBcIiBcIjtcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQobiwgXCIwXCIpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZShzKTtcbiAgdmFyIGkgPSByWzBdLFxuICAgIHNpZ24gPSByWzFdLFxuICAgIGJhc2UgPSByWzJdLFxuICAgIHNpZ25lZG5lc3MgPSByWzNdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9IE1sSW50NjQuVU5TSUdORURfTUFYLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJJbnQ2NC5vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiSW50NjQub2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcIkludDY0Lm9mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiSW50NjQub2Zfc3RyaW5nXCIpO1xuICBpZiAoXG4gICAgc2lnbmVkbmVzcyAmJlxuICAgIGNhbWxfaW50NjRfdWx0KHNpZ24gPCAwID8gTWxJbnQ2NC5TSUdORURfTUlOIDogTWxJbnQ2NC5TSUdORURfTUFYLCByZXMpXG4gIClcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW50NjQub2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZixcbiAgKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpIHtcbiAgcmV0dXJuIHYubG8zMigpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KSB7XG4gIHJldHVybiB2LmhpMzIoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICAoYVs3XSA8PCAwKSB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgIChhWzRdIDw8IDApIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgKGFbMV0gPDwgMCkgfCAoYVswXSA8PCA4KSxcbiAgKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkge1xuICByZXR1cm4geC50b0FycmF5KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpIHtcbiAgcmV0dXJuIHYubG8zMigpIF4gdi5oaTMyKCk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19kYXRhdmlld1xudmFyIGpzb29fZGF0YXZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuLy9SZXF1aXJlczoganNvb19kYXRhdmlld1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpIHtcbiAganNvb19kYXRhdmlldy5zZXRGbG9hdDY0KDAsIHgsIHRydWUpO1xuICB2YXIgbG8zMiA9IGpzb29fZGF0YXZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICB2YXIgaGkzMiA9IGpzb29fZGF0YXZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICB2YXIgcjEgPSBsbzMyICYgMHhmZmZmZmY7XG4gIHZhciByMiA9IChsbzMyID4+PiAyNCkgfCAoKGhpMzIgPDwgOCkgJiAweGZmZmZmZik7XG4gIHZhciByMyA9IChoaTMyID4+PiAxNikgJiAweGZmZmY7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2RhdGF2aWV3XG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoeCkge1xuICBqc29vX2RhdGF2aWV3LnNldEZsb2F0MzIoMCwgeCwgdHJ1ZSk7XG4gIHJldHVybiBqc29vX2RhdGF2aWV3LmdldFVpbnQzMigwLCB0cnVlKSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0KHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyh4ID4gMCA/IFwiaW5maW5pdHlcIiA6IFwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0geCA9PT0gMCAmJiAxIC8geCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID8gMSA6IHggPj0gMCA/IDAgOiAxO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT09IDApIHtcbiAgfSBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikge1xuICAgICAgeCAqPSAyO1xuICAgICAgZXhwLS07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHtcbiAgICAgIHggLz0gMjtcbiAgICAgIGV4cCsrO1xuICAgIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gXCJcIiA6IFwiK1wiO1xuICB2YXIgc2lnbl9zdHIgPSBcIlwiO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSBcIi1cIjtcbiAgZWxzZSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSA0MyAvKiAnKycgKi86XG4gICAgICAgIHNpZ25fc3RyID0gXCIrXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMiAvKiAnICcgKi86XG4gICAgICAgIHNpZ25fc3RyID0gXCIgXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMiwgcHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZiAocHJlYyA+PSAwKSB7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICB4X3N0ciArPSBcIi5cIiArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCBcIjBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4ICsgMSArIHByZWM7XG4gICAgICBpZiAoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsIFwiMFwiKTtcbiAgICAgIGVsc2UgeF9zdHIgPSB4X3N0ci5zbGljZSgwLCBzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFxuICAgIHNpZ25fc3RyICsgXCIweFwiICsgeF9zdHIgKyBcInBcIiArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2RhdGF2aWV3XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICBqc29vX2RhdGF2aWV3LnNldFVpbnQzMigwLCBsbyB8IChtaSA8PCAyNCksIHRydWUpO1xuICBqc29vX2RhdGF2aWV3LnNldFVpbnQzMig0LCAobWkgPj4+IDgpIHwgKGhpIDw8IDE2KSwgdHJ1ZSk7XG4gIHJldHVybiBqc29vX2RhdGF2aWV3LmdldEZsb2F0NjQoMCwgdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0KHgsIHkpIHtcbiAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeSkpIHJldHVybiBOdW1iZXIuTmFOO1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIHk7XG4gIGlmICh4ID09PSAwKSB7XG4gICAgaWYgKHkgPCAwKSByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KTtcbiAgICBlbHNlIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NCk7XG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoeCA8IHkgPT09IHggPiAwKSBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKTtcbiAgZWxzZSBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KSB7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZGF0YXZpZXdcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyh4KSB7XG4gIGpzb29fZGF0YXZpZXcuc2V0VWludDMyKDAsIHgsIHRydWUpO1xuICByZXR1cm4ganNvb19kYXRhdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0KHgpIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT09IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBOdW1iZXIuaXNOYU4oeCkgPyA0IDogMztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0KHgpIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHZhciBuZWcgPSAxIC8geCA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vcih4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHtcbiAgICAgIGkgPSAtaTtcbiAgICAgIGYgPSAtZjtcbiAgICB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gWzAsIE51bWJlci5OYU4sIE51bWJlci5OYU5dO1xuICByZXR1cm4gWzAsIDEgLyB4LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQoeCwgZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICAgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQoeCkge1xuICBpZiAoeCA9PT0gMCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAteDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBNYXRoLmZsb29yKE1hdGgubG9nMih4KSkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLCAtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAteDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICghTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gMTtcbiAgaWYgKCFOdW1iZXIuaXNOYU4oeSkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQoeCwgeSkge1xuICBpZiAoeSA9PT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiB5IDwgMCA/IC14IDogeDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG4vL0FsaWFzOiBjYW1sX3NpZ25iaXRcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiB4IDwgMCA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwbTEoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2V4cDJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwMl9mbG9hdCh4KSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCB4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5sb2cxcCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nMih4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQoeCwgeSkge1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguY29zaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYWNvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYWNvc2hfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hY29zaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGguc2luaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYXNpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXNpbmhfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hc2luaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIE1hdGgudGFuaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYXRhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXRhbmhfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5hdGFuaCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQoeCkge1xuICBpZiAoeCA+PSAwKSB7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKHgpO1xuICAgIHJldHVybiB4IC0geSA+PSAwLjUgPyB5ICsgMSA6IHk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHkgPSBNYXRoLmNlaWwoeCk7XG4gICAgcmV0dXJuIHkgLSB4ID49IDAuNSA/IHkgLSAxIDogeTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jYnJ0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NicnRfZmxvYXQoeCkge1xuICByZXR1cm4gTWF0aC5jYnJ0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9lcmZfZmxvYXQoeCkge1xuICB2YXIgYTEgPSAwLjI1NDgyOTU5MjtcbiAgdmFyIGEyID0gLTAuMjg0NDk2NzM2O1xuICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcbiAgdmFyIGE0ID0gLTEuNDUzMTUyMDI3O1xuICB2YXIgYTUgPSAxLjA2MTQwNTQyOTtcbiAgdmFyIHAgPSAwLjMyNzU5MTE7XG5cbiAgdmFyIHNpZ24gPSAxO1xuICBpZiAoeCA8IDApIHtcbiAgICBzaWduID0gLTE7XG4gIH1cbiAgeCA9IE1hdGguYWJzKHgpO1xuICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHZhciB5ID1cbiAgICAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZtYV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbWFfZmxvYXQoeCwgeSwgeikge1xuICB2YXIgU1BMSVQgPSBNYXRoLnBvdygyLCAyNykgKyAxO1xuICB2YXIgTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEwMjIpO1xuICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gIHZhciBDID0gNDE2O1xuICB2YXIgQSA9IE1hdGgucG93KDIsICtDKTtcbiAgdmFyIEIgPSBNYXRoLnBvdygyLCAtQyk7XG5cbiAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9IGFoaSAqIGJoaSAtIHAgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIHYgPSBzIC0gYTtcbiAgICB2YXIgZSA9IGEgLSAocyAtIHYpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGUsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdCh4LCB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgJiYgeSAhPT0gMCAmJiBTUExJVCAqIHggLSAoU1BMSVQgKiB4IC0geCkgPT09IHhcbiAgICAgID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pXG4gICAgICA6IHg7XG4gIH1cblxuICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwIHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDE7XG4gIHdoaWxlIChNYXRoLmFicyh4KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHggKj0gQjtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB5ICo9IEI7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAxIC8gMCkge1xuICAgIHJldHVybiB4ICogeSAqIHNjYWxlO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh4KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHggKj0gQTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB5ICo9IEE7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgeHMgPSB4O1xuICB2YXIgeXMgPSB5O1xuICB2YXIgenMgPSB6IC8gc2NhbGU7XG5cbiAgaWYgKE1hdGguYWJzKHpzKSA+IChNYXRoLmFicyh4cyAqIHlzKSAqIDQpIC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCAoKChNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04pIC8gNCkgKiBFUFNJTE9OKSAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0KGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsIGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBOdW1iZXIucGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KFwiK1wiKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsIGUpO1xuICAgICAgICB4ICs9IGNhbWxfc3RyX3JlcGVhdChlLCBcIjBcIik7XG4gICAgICAgIGlmIChkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArIFwiLlwiICsgY2FtbF9zdHJfcmVwZWF0KGRwLCBcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfVxuICB9XG4gIHZhciBzLFxuICAgIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IGYucHJlYyA8IDAgPyA2IDogZi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT09IDAgJiYgMSAvIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkpIHtcbiAgICBmLnNpZ24gPSAtMTtcbiAgICB4ID0gLXg7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgIHMgPSBcIm5hblwiO1xuICAgIGYuZmlsbGVyID0gXCIgXCI7XG4gIH0gZWxzZSBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHMgPSBcImluZlwiO1xuICAgIGYuZmlsbGVyID0gXCIgXCI7XG4gIH0gZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PT0gXCJlXCIpXG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSAtIDEpICsgXCIwXCIgKyBzLnNsaWNlKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICBwcmVjID0gcHJlYyA/IHByZWMgOiAxO1xuICAgICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgICAgdmFyIGogPSBzLmluZGV4T2YoXCJlXCIpO1xuICAgICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gaiAtIDE7XG4gICAgICAgICAgd2hpbGUgKHMuY2hhckF0KGkpID09PSBcIjBcIikgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PT0gXCIuXCIpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09PSBcImVcIilcbiAgICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgLSAxKSArIFwiMFwiICsgcy5zbGljZShpIC0gMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICAgIGlmIChleHAgPCAwKSB7XG4gICAgICAgICAgICBwIC09IGV4cCArIDE7XG4gICAgICAgICAgICBzID0geC50b0ZpeGVkKHApO1xuICAgICAgICAgIH0gZWxzZSB3aGlsZSAoKChzID0geC50b0ZpeGVkKHApKSwgcy5sZW5ndGggPiBwcmVjICsgMSkpIHAtLTtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAocy5jaGFyQXQoaSkgPT09IFwiMFwiKSBpLS07XG4gICAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT09IFwiLlwiKSBpLS07XG4gICAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgdmFyIHJfZmxvYXQgPSAvXiAqWy0rXT8oPzpcXGQqXFwuP1xcZCt8XFxkK1xcLj9cXGQqKSg/OltlRV1bLStdP1xcZCspPyQvO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgcmVzID0gK3M7XG4gIC8vRmFzdCBwYXRoXG4gIGlmICghTnVtYmVyLmlzTmFOKHJlcykgJiYgcl9mbG9hdC50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csIFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCghTnVtYmVyLmlzTmFOKHJlcykgJiYgcl9mbG9hdC50ZXN0KHMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpXG4gICAgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKikocChbKy1dP1swLTldKykpPyQvaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYgKG0pIHtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sIFwiXCIpO1xuICAgIHZhciBtYW50aXNzYSA9IE51bWJlci5wYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKCttWzVdIHx8IDApIC0gNCAqIG0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICgvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBpZiAoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCh0YWcpIHtcbiAgdGhyb3cgdGFnO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyh0YWcsIGFyZykge1xuICB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsIHRhZywgYXJnXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzIChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZ3ModGFnLCBhcmdzKSB7XG4gIHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnXS5jb25jYXQoYXJncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGgobXNnKSB7XG4gIGlmICghY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlKVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSA9IFsyNDgsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJGYWlsdXJlXCIpLCAtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50KG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiAhZWZmZWN0c1xuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09PSAwKSByZXR1cm4gZiguLi5hcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgZyA9IGYoLi4uYXJncy5zbGljZSgwLCBuKSk7XG4gICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBnO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsIGFyZ3Muc2xpY2UobikpO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDEpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICAgIHJldHVybiBmKC4uLm5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKyspIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgICByZXR1cm4gZiguLi5uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncy5jb25jYXQoZXh0cmFfYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBnLmwgPSBkO1xuICAgIHJldHVybiBnO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgdmFyIG4gPSBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIGYoLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UobiAtIDEpO1xuICAgIHZhciBrID0gYXJnc1thcmdzTGVuIC0gMV07XG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgbik7XG4gICAgYXJnc1tuIC0gMV0gPSBmdW5jdGlvbiAoZykge1xuICAgICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBrKGcpO1xuICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBrO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZiguLi5hcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzTGVuLS07XG4gICAgdmFyIGsgPSBhcmdzW2FyZ3NMZW5dO1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDIpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgICAgcmV0dXJuIGYoLi4ubmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAzKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKykgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAyXSA9IHo7XG4gICAgICAgICAgcmV0dXJuIGYoLi4ubmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgYXJncy5sZW5ndGggPSBhcmdzTGVuO1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncy5jb25jYXQoZXh0cmFfYXJncykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBnLmwgPSBkICsgMTtcbiAgICByZXR1cm4gayhnKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX2Nwc1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG52YXIgY2FtbF9jYWxsX2dlbl9jcHMgPSBjYW1sX2NhbGxfZ2VuO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX3R1cGxlIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfY3BzX2Nsb3N1cmVcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuLy9XZWFrZGVmXG52YXIgY2FtbF9jYWxsX2dlbl90dXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGNhbWxfY2FsbF9nZW5fZGlyZWN0KGYsIGFyZ3MpIHtcbiAgICB2YXIgbiA9IGYubCA+PSAwID8gZi5sIDogKGYubCA9IGYubGVuZ3RoKTtcbiAgICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gICAgaWYgKGQgPT09IDApIHtcbiAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICAgIHZhciBnID0gZiguLi5hcmdzLnNsaWNlKDAsIG4pKTtcbiAgICAgIGlmICh0eXBlb2YgZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZztcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2RpcmVjdChnLCBhcmdzLnNsaWNlKG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IFJlc3RvcmUgdGhlIG9wdGltaXphdGlvbiBvZiBoYW5kbGluZyBzcGVjaWFsbHkgZCA9IDEgb3IgMlxuICAgICAgdmFyIGFyZ3NfID0gYXJncy5zbGljZSgpO1xuICAgICAgYXJnc18ubGVuZ3RoID0gYXJnc0xlbjtcbiAgICAgIHZhciByZXQgPSBjYW1sX2Nwc19jbG9zdXJlKFxuICAgICAgICBmdW5jdGlvbiAoLi4uZXh0cmFfYXJncykge1xuICAgICAgICAgIGlmIChleHRyYV9hcmdzLmxlbmd0aCA9PT0gMCkgZXh0cmFfYXJncyA9IFt1bmRlZmluZWRdO1xuICAgICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2RpcmVjdChmLCBhcmdzLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fY3BzKGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmV0LmwgPSBkO1xuICAgICAgcmV0LmNwcy5sID0gZCArIDE7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW1sX2NhbGxfZ2VuX2NwcyhmLCBhcmdzKSB7XG4gICAgaWYgKCFmLmNwcykge1xuICAgICAgdmFyIGsgPSBhcmdzLnBvcCgpO1xuICAgICAgcmV0dXJuIGsoY2FtbF9jYWxsX2dlbl9kaXJlY3QoZiwgYXJncykpO1xuICAgIH1cbiAgICB2YXIgbiA9IGYuY3BzLmwgPj0gMCA/IGYuY3BzLmwgOiAoZi5jcHMubCA9IGYuY3BzLmxlbmd0aCk7XG4gICAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgICB2YXIgZCA9IG4gLSBhcmdzTGVuO1xuICAgIGlmIChkID09PSAwKSB7XG4gICAgICByZXR1cm4gZi5jcHMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChkIDwgMCkge1xuICAgICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKG4gLSAxKTtcbiAgICAgIHZhciBrID0gYXJnc1thcmdzTGVuIC0gMV07XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBuKTtcbiAgICAgIGFyZ3NbbiAtIDFdID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGs7XG4gICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuX2NwcyhnLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZi5jcHMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NMZW4tLTtcbiAgICAgIHZhciBhcmdzXyA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgIGFyZ3NfLmxlbmd0aCA9IGFyZ3NMZW47XG4gICAgICB2YXIgY29udCA9IGNhbWxfY3BzX2Nsb3N1cmUoXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fZGlyZWN0KGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICguLi5leHRyYV9hcmdzKSB7XG4gICAgICAgICAgaWYgKGV4dHJhX2FyZ3MubGVuZ3RoID09PSAwKSBleHRyYV9hcmdzID0gW3VuZGVmaW5lZF07XG4gICAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW5fY3BzKGYsIGFyZ3NfLmNvbmNhdChleHRyYV9hcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdmFyIGsgPSBhcmdzW2FyZ3NMZW5dO1xuICAgICAgY29udC5sID0gZDtcbiAgICAgIGNvbnQuY3BzLmwgPSBkICsgMTtcbiAgICAgIHJldHVybiBrKGNvbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2NhbWxfY2FsbF9nZW5fZGlyZWN0LCBjYW1sX2NhbGxfZ2VuX2Nwc107XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuX3R1cGxlXG4vL0lmOiBlZmZlY3RzXG4vL0lmOiBkb3VibGV0cmFuc2xhdGVcbi8vV2Vha2RlZlxudmFyIGNhbWxfY2FsbF9nZW4gPSBjYW1sX2NhbGxfZ2VuX3R1cGxlWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuX2Nwc1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbl90dXBsZVxuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG4vL1dlYWtkZWZcbnZhciBjYW1sX2NhbGxfZ2VuX2NwcyA9IGNhbWxfY2FsbF9nZW5fdHVwbGVbMV07XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLCB2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9idWlsZF9zeW1ib2xzXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9idWlsZF9zeW1ib2xzKHN5bWIpIHtcbiAgdmFyIHIgPSB7fTtcbiAgdmFyIG1heCA9IC0xO1xuICBpZiAoc3ltYikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3ltYi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkeCA9IHN5bWJbaV1bMl07XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGlkeCk7XG4gICAgICByW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN5bWJbaV1bMV0pXSA9IGlkeDtcbiAgICB9XG4gIH1cbiAgci5uZXh0X2lkeCA9IG1heCArIDE7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3RvcGxldmVsX3JlbG9jXG52YXIganNvb190b3BsZXZlbF9yZWxvYyA9IHVuZGVmaW5lZDtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfY2FsbGJhY2ssIGNhbWxfYnVpbGRfc3ltYm9sc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczoganNvb190b3BsZXZlbF9yZWxvY1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYgKG5hbWVfb3B0KSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lX29wdDtcbiAgICBpZiAoanNvb190b3BsZXZlbF9yZWxvYykge1xuICAgICAgbiA9IGNhbWxfY2FsbGJhY2soanNvb190b3BsZXZlbF9yZWxvYywgW25hbWVdKTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scykge1xuICAgICAgaWYgKCFjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCkge1xuICAgICAgICBjYW1sX2dsb2JhbF9kYXRhLnN5bWlkeCA9IGNhbWxfYnVpbGRfc3ltYm9scyhjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHMpO1xuICAgICAgfVxuICAgICAgdmFyIG5pZCA9IGNhbWxfZ2xvYmFsX2RhdGEuc3ltaWR4W25hbWVdO1xuICAgICAgaWYgKG5pZCA+PSAwKSBuID0gbmlkO1xuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSB1bml0IGlzIHVua25vd24sIHRoaXMgY2FuIGhhcHBlbiB3aGVuIGR5bmxpbmtpbmcgYSBwcmVjb21waWxlZCBqcyxcbiAgICAgICAgLy8gbGV0J3MgYWxsb2NhdGUgYSBmcmVzaCBpZHguXG4gICAgICAgIHZhciBuID0gY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHgubmV4dF9pZHgrKztcbiAgICAgICAgY2FtbF9nbG9iYWxfZGF0YS5zeW1pZHhbbmFtZV0gPSBuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmIChuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YShfdW5pdCkge1xuICByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykge1xuICByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWF5YmVfcHJpbnRfc3RhdHNcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfcHJpbnRfc3RhdHMoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIHJldHVybiBzLnJlcGVhdChuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseShudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LCBsZW4gLT0gMTAyNClcbiAgICBzICs9IGYuYXBwbHkobnVsbCwgYS5zbGljZShpLCBpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1Yl91aW50OF9hcnJheV90b19qc2J5dGVzKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5KG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsIGxlbiAtPSAxMDI0KVxuICAgIHMgKz0gZi5hcHBseShudWxsLCBhLnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Db250cm9sQ2hhcmFjdGVyc0luUmVnZXg6IGV4cGVjdGVkXG4gIGVsc2UgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgICBjYXNlIDAgLyogQllURVMgKi86XG4gICAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gICAgY2FzZSAyIC8qIFBBUlRJQUwgKi86XG4gICAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgICBjYXNlIDQgLyogQVJSQVkgKi86XG4gICAgICByZXR1cm4gcy5jW2ldO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT09IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICBpZiAoaSArIDEgPT09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSksXG4gICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4KSB8IGIxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSxcbiAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCkgfCBiMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSxcbiAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpLFxuICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMiksXG4gICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCkgfCAoYjMgPDwgMTYpIHwgKGIyIDw8IDgpIHwgYjE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpLFxuICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSxcbiAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMiksXG4gICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0KSB8IChiMyA8PCAxNikgfCAoYjIgPDwgOCkgfCBiMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0KHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQoX3MsIF9pLCBfYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0KHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocywgaSwgaTE2KSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhmZiAmIChpMTYgPj4gOCksXG4gICAgYjEgPSAweGZmICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocywgaSwgaTMyKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhmZiAmIChpMzIgPj4gMjQpLFxuICAgIGIzID0gMHhmZiAmIChpMzIgPj4gMTYpLFxuICAgIGIyID0gMHhmZiAmIChpMzIgPj4gOCksXG4gICAgYjEgPSAweGZmICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLCBpLCBpNjQpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczoganNvb190ZXh0X2VuY29kZXJcbnZhciBqc29vX3RleHRfZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4vL1Byb3ZpZGVzOiBqc29vX3RleHRfZGVjb2RlclxudmFyIGpzb29fdGV4dF9kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGpzb29fdGV4dF9lbmNvZGVyXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpIHtcbiAgICByZXR1cm4gbmV3IE1sQnl0ZXMoOSwgcywgcy5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0ganNvb190ZXh0X2VuY29kZXIuZW5jb2RlKHMpO1xuICAgIHJldHVybiBuZXcgTWxCeXRlcyg0LCBhLCBhLmxlbmd0aCk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaVxuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczoganNvb190ZXh0X2RlY29kZXJcbmNsYXNzIE1sQnl0ZXMge1xuICBjb25zdHJ1Y3Rvcih0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgICB0aGlzLnQgPSB0YWc7XG4gICAgdGhpcy5jID0gY29udGVudHM7XG4gICAgdGhpcy5sID0gbGVuZ3RoO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgc3dpdGNoICh0aGlzLnQpIHtcbiAgICAgIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIGNhc2UgOCAvKkJZVEVTIHwgTk9UX0FTQ0lJKi86XG4gICAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICBjYXNlIDIgLyogUEFSVElBTCAqLzpcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGNhc2UgMCAvKkJZVEVTIHwgVU5LT1dOKi86XG4gICAgICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICAgIGVsc2UgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICB9XG5cbiAgdG9VdGYxNigpIHtcbiAgICBpZiAodGhpcy50ID09PSA5KSByZXR1cm4gdGhpcy5jO1xuICAgIHZhciBhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyh0aGlzKTtcbiAgICByZXR1cm4ganNvb190ZXh0X2RlY29kZXIuZGVjb2RlKGEpO1xuICB9XG5cbiAgc2xpY2UoKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LCBjb250ZW50LCB0aGlzLmwpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT09IDIgLyogUEFSVElBTCAqLykgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCBcIlxcMFwiKTtcbiAgZWxzZSBzLmMgPSBjYW1sX3N1Yl91aW50OF9hcnJheV90b19qc2J5dGVzKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkocy5sKTtcbiAgdmFyIGIgPSBzLmMsXG4gICAgbCA9IGIubGVuZ3RoLFxuICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHMpIHtcbiAgaWYgKHMudCAhPT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4gPyAyIDogOSwgXCJcIiwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKF9sZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbiA/IDIgOiA5LCBcIlwiLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheShhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLCAwLCBhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheShhKSB7XG4gIHJldHVybiBjYW1sX3N1Yl91aW50OF9hcnJheV90b19qc2J5dGVzKGEsIDAsIGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGEpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoYS5zbGljZSgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheShhKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCwgYSwgYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGEpIHtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsIGEsIGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgczEudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIHMyLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gczEuYyA8IHMyLmMgPyAtMSA6IHMxLmMgPiBzMi5jID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYgKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHMxLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICBzMi50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIHMxLmMgPT09IHMyLmMgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gMSAtIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIDEgLSBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICBzMS50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgczIudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiBzMS5jIDw9IHMyLmMgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICBzMS50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgczIudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiBzMS5jIDwgczIuYyA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLCBzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09PSAwICYmIChsID49IHMubCB8fCAocy50ID09PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gbCA9PT0gcy5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChcbiAgICBpMiA9PT0gMCAmJlxuICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpXG4gICkge1xuICAgIHMyLmMgPVxuICAgICAgczEudCA9PT0gNCAvKiBBUlJBWSAqL1xuICAgICAgICA/IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbilcbiAgICAgICAgOiBpMSA9PT0gMCAmJiBzMS5jLmxlbmd0aCA9PT0gbGVuXG4gICAgICAgICAgPyBzMS5jXG4gICAgICAgICAgOiBzMS5jLnNsaWNlKGkxLCBpMSArIGxlbik7XG4gICAgczIudCA9IHMyLmMubGVuZ3RoID09PSBzMi5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPVxuICAgICAgczEudCA9PT0gNCAvKiBBUlJBWSAqL1xuICAgICAgICA/IGNhbWxfc3ViX3VpbnQ4X2FycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbilcbiAgICAgICAgOiBpMSA9PT0gMCAmJiBzMS5jLmxlbmd0aCA9PT0gbGVuXG4gICAgICAgICAgPyBzMS5jXG4gICAgICAgICAgOiBzMS5jLnNsaWNlKGkxLCBpMSArIGxlbik7XG4gICAgczIudCA9IHMyLmMubGVuZ3RoID09PSBzMi5sID8gMCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6IDI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLFxuICAgICAgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzJbaTIgKyBpXSA9IGMxW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyW2kyICsgaV0gPSBjMVtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMltpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSwgYiwgYywgZCwgZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksIGIsIGMsIGQsIGUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbmNhdChhLCBiKSB7XG4gIHJldHVybiBhICsgYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29uY2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBNbEJ5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb25jYXQoczEsIHMyKSB7XG4gIHMxLnQgJiA2ICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICBzMi50ICYgNiAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDAsIHMxLmMgKyBzMi5jLCBzMS5sICsgczIubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIHMxIDwgczIgPyAtMSA6IHMxID4gczIgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmIChzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIHMxIDw9IHMyID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gczEgPCBzMiA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIHMudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkge1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczoganNvb190ZXh0X2RlY29kZXJfYnVmZlxudmFyIGpzb29fdGV4dF9kZWNvZGVyX2J1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoMTAyNCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL1JlcXVpcmVzOiBqc29vX3RleHRfZGVjb2RlclxuLy9SZXF1aXJlczoganNvb190ZXh0X2RlY29kZXJfYnVmZlxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKSByZXR1cm4gcztcbiAgdmFyIGEgPVxuICAgIHMubGVuZ3RoIDw9IGpzb29fdGV4dF9kZWNvZGVyX2J1ZmYubGVuZ3RoXG4gICAgICA/IG5ldyBVaW50OEFycmF5KGpzb29fdGV4dF9kZWNvZGVyX2J1ZmYsIDAsIHMubGVuZ3RoKVxuICAgICAgOiBuZXcgVWludDhBcnJheShzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgIGFbaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGpzb29fdGV4dF9kZWNvZGVyLmRlY29kZShhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBqc29vX3RleHRfZW5jb2RlclxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIGEgPSBqc29vX3RleHRfZW5jb2Rlci5lbmNvZGUocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoMCwgcywgcy5sZW5ndGgpO1xufVxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0KHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHMudCAmIDYgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBzLnRvVXRmMTYoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIE1sQnl0ZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXR1cm5zIGEgKGZ1bGwpIHN0cmluZyBvZiBieXRlcyBvciBhbiBhcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgY2FzZSAyIC8qIFBBUlRJQUwgKi86XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgICAgcmV0dXJuIHMuYztcbiAgICBkZWZhdWx0OiAvKiBCWVRFUyBvciBBUlJBWSAqL1xuICAgICAgcmV0dXJuIHMuYztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Db250cm9sQ2hhcmFjdGVyc0luUmVnZXg6IGV4cGVjdGVkXG4gIHJldHVybiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiAhL1teXFx4MDAtXFx4ZmZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0RlcHJlY2F0ZWQ6IFVzZSBbY2FtbF9zdHJpbmdfb2ZfanNieXRlc10gaW5zdGVhZFxuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX2pzc3RyaW5nX29mX3N0cmluZ10gaW5zdGVhZFxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9EZXByZWNhdGVkOiBVc2UgW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXSBpbnN0ZWFkXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL0RlcHJlY2F0ZWQ6IFVzZSBbY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmddIGluc3RlYWRcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ10gaW5zdGVhZFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcoeCkge1xuICByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXSBpbnN0ZWFkXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzKHgpIHtcbiAgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9EZXByZWNhdGVkOiBVc2UgW2NhbWxfc3RyaW5nX29mX2pzYnl0ZXNdIGluc3RlYWRcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VucGFja0Zsb2F0MTZcbnZhciBjYW1sX3VucGFja0Zsb2F0MTYgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcG93ID0gTWF0aC5wb3c7XG5cbiAgdmFyIEVYUF9NQVNLMTYgPSAzMTsgLy8gMiAqKiA1IC0gMVxuICB2YXIgU0lHTklGSUNBTkRfTUFTSzE2ID0gMTAyMzsgLy8gMiAqKiAxMCAtIDFcbiAgdmFyIE1JTl9TVUJOT1JNQUwxNiA9IHBvdygyLCAtMjQpOyAvLyAyICoqIC0xMCAqIDIgKiogLTE0XG4gIHZhciBTSUdOSUZJQ0FORF9ERU5PTTE2ID0gMC4wMDA5NzY1NjI1OyAvLyAyICoqIC0xMFxuXG4gIHJldHVybiBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICB2YXIgc2lnbiA9IGJ5dGVzID4+PiAxNTtcbiAgICB2YXIgZXhwb25lbnQgPSAoYnl0ZXMgPj4+IDEwKSAmIEVYUF9NQVNLMTY7XG4gICAgdmFyIHNpZ25pZmljYW5kID0gYnl0ZXMgJiBTSUdOSUZJQ0FORF9NQVNLMTY7XG4gICAgaWYgKGV4cG9uZW50ID09PSBFWFBfTUFTSzE2KVxuICAgICAgcmV0dXJuIHNpZ25pZmljYW5kID09PSAwXG4gICAgICAgID8gc2lnbiA9PT0gMFxuICAgICAgICAgID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgICAgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgOiBOdW1iZXIuTmFOO1xuICAgIGlmIChleHBvbmVudCA9PT0gMClcbiAgICAgIHJldHVybiBzaWduaWZpY2FuZCAqIChzaWduID09PSAwID8gTUlOX1NVQk5PUk1BTDE2IDogLU1JTl9TVUJOT1JNQUwxNik7XG4gICAgdmFyIHIgPVxuICAgICAgcG93KDIsIGV4cG9uZW50IC0gMTUpICpcbiAgICAgIChzaWduID09PSAwXG4gICAgICAgID8gMSArIHNpZ25pZmljYW5kICogU0lHTklGSUNBTkRfREVOT00xNlxuICAgICAgICA6IC0xIC0gc2lnbmlmaWNhbmQgKiBTSUdOSUZJQ0FORF9ERU5PTTE2KTtcbiAgICByZXR1cm4gcjtcbiAgfTtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFja0Zsb2F0MTZcbnZhciBjYW1sX3BhY2tGbG9hdDE2ID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgSU5WRVJTRV9PRl9FUFNJTE9OID0gMSAvIE51bWJlci5FUFNJTE9OO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVGllc1RvRXZlbihudW0pIHtcbiAgICByZXR1cm4gbnVtICsgSU5WRVJTRV9PRl9FUFNJTE9OIC0gSU5WRVJTRV9PRl9FUFNJTE9OO1xuICB9XG5cbiAgY29uc3QgRkxPQVQxNl9NSU5fVkFMVUUgPSA2LjEwMzUxNTYyNWUtNTtcbiAgY29uc3QgRkxPQVQxNl9NQVhfVkFMVUUgPSA2NTUwNDtcbiAgY29uc3QgRkxPQVQxNl9FUFNJTE9OID0gMC4wMDA5NzY1NjI1O1xuXG4gIGNvbnN0IEZMT0FUMTZfRVBTSUxPTl9NVUxUSVBMSUVEX0JZX0ZMT0FUMTZfTUlOX1ZBTFVFID1cbiAgICBGTE9BVDE2X0VQU0lMT04gKiBGTE9BVDE2X01JTl9WQUxVRTtcbiAgY29uc3QgRkxPQVQxNl9FUFNJTE9OX0RFVklERURfQllfRVBTSUxPTiA9XG4gICAgRkxPQVQxNl9FUFNJTE9OICogSU5WRVJTRV9PRl9FUFNJTE9OO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9GbG9hdDE2KG51bSkge1xuICAgIGNvbnN0IG51bWJlciA9ICtudW07XG5cbiAgICAvLyBOYU4sIEluZmluaXR5LCAtSW5maW5pdHksIDAsIC0wXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtYmVyKSB8fCBudW1iZXIgPT09IDApIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLy8gZmluaXRlIGV4Y2VwdCAwLCAtMFxuICAgIGNvbnN0IHNpZ24gPSBudW1iZXIgPiAwID8gMSA6IC0xO1xuICAgIGNvbnN0IGFic29sdXRlID0gTWF0aC5hYnMobnVtYmVyKTtcblxuICAgIC8vIHNtYWxsIG51bWJlclxuICAgIGlmIChhYnNvbHV0ZSA8IEZMT0FUMTZfTUlOX1ZBTFVFKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzaWduICpcbiAgICAgICAgcm91bmRUaWVzVG9FdmVuKFxuICAgICAgICAgIGFic29sdXRlIC8gRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUsXG4gICAgICAgICkgKlxuICAgICAgICBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wID0gKDEgKyBGTE9BVDE2X0VQU0lMT05fREVWSURFRF9CWV9FUFNJTE9OKSAqIGFic29sdXRlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRlbXAgLSAodGVtcCAtIGFic29sdXRlKTtcblxuICAgIC8vIGxhcmdlIG51bWJlclxuICAgIGlmIChyZXN1bHQgPiBGTE9BVDE2X01BWF9WQUxVRSB8fCBOdW1iZXIuaXNOYU4ocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHNpZ24gKiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ24gKiByZXN1bHQ7XG4gIH1cblxuICAvLyBiYXNlIGFsZ29yaXRobTogaHR0cDovL2ZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbiAgY29uc3QgYmFzZVRhYmxlID0gbmV3IFVpbnQxNkFycmF5KDUxMik7XG4gIGNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgVWludDhBcnJheSg1MTIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICBjb25zdCBlID0gaSAtIDEyNztcblxuICAgIC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcbiAgICBpZiAoZSA8IC0yNCkge1xuICAgICAgYmFzZVRhYmxlW2ldID0gMHgwMDAwO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweDgwMDA7XG4gICAgICBzaGlmdFRhYmxlW2ldID0gMjQ7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcblxuICAgICAgLy8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG4gICAgfSBlbHNlIGlmIChlIDwgLTE0KSB7XG4gICAgICBiYXNlVGFibGVbaV0gPSAweDA0MDAgPj4gKC1lIC0gMTQpO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoMHgwNDAwID4+ICgtZSAtIDE0KSkgfCAweDgwMDA7XG4gICAgICBzaGlmdFRhYmxlW2ldID0gLWUgLSAxO1xuICAgICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gLWUgLSAxO1xuXG4gICAgICAvLyBub3JtYWwgbnVtYmVyXG4gICAgfSBlbHNlIGlmIChlIDw9IDE1KSB7XG4gICAgICBiYXNlVGFibGVbaV0gPSAoZSArIDE1KSA8PCAxMDtcbiAgICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gKChlICsgMTUpIDw8IDEwKSB8IDB4ODAwMDtcbiAgICAgIHNoaWZ0VGFibGVbaV0gPSAxMztcbiAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuXG4gICAgICAvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG4gICAgfSBlbHNlIGlmIChlIDwgMTI4KSB7XG4gICAgICBiYXNlVGFibGVbaV0gPSAweDdjMDA7XG4gICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ZmMwMDtcbiAgICAgIHNoaWZ0VGFibGVbaV0gPSAyNDtcbiAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDI0O1xuXG4gICAgICAvLyBzdGF5IChOYU4sIEluZmluaXR5LCAtSW5maW5pdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VUYWJsZVtpXSA9IDB4N2MwMDtcbiAgICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSA9IDEzO1xuICAgICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMTM7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICBjb25zdCBmbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gIGNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG51bSkge1xuICAgIGZsb2F0Vmlld1swXSA9IHJvdW5kVG9GbG9hdDE2KG51bSk7XG4gICAgY29uc3QgZiA9IHVpbnQzMlZpZXdbMF07XG4gICAgY29uc3QgZSA9IChmID4+IDIzKSAmIDB4MWZmO1xuICAgIHJldHVybiBiYXNlVGFibGVbZV0gKyAoKGYgJiAweDAwN2ZmZmZmKSA+PiBzaGlmdFRhYmxlW2VdKTtcbiAgfTtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkge1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIDc6XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDExOlxuICAgICAgcmV0dXJuIDI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSkge1xuICB2YXIgdmlldztcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdmlldyA9IEZsb2F0MzJBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHZpZXcgPSBGbG9hdDY0QXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICB2aWV3ID0gSW50OEFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgdmlldyA9IFVpbnQ4QXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICB2aWV3ID0gSW50MTZBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHZpZXcgPSBVaW50MTZBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjpcbiAgICAgIHZpZXcgPSBJbnQzMkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA3OlxuICAgICAgdmlldyA9IEludDMyQXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDg6XG4gICAgICB2aWV3ID0gSW50MzJBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgOTpcbiAgICAgIHZpZXcgPSBJbnQzMkFycmF5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMDpcbiAgICAgIHZpZXcgPSBGbG9hdDMyQXJyYXk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOlxuICAgICAgdmlldyA9IEZsb2F0NjRBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICB2aWV3ID0gVWludDhBcnJheTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICB2aWV3ID0gVWludDE2QXJyYXk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCI7XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuLy9SZXF1aXJlczogY2FtbF9wYWNrRmxvYXQxNiwgY2FtbF91bnBhY2tGbG9hdDE2XG5jbGFzcyBNbF9CaWdhcnJheSB7XG4gIGNvbnN0cnVjdG9yKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbiAgICB0aGlzLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcbiAgfVxuXG4gIG9mZnNldChhcmcpIHtcbiAgICB2YXIgb2ZzID0gMDtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gICAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT09IGFyZy5sZW5ndGgpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gICAgaWYgKHRoaXMubGF5b3V0ID09PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICAgIG9mcyA9IG9mcyAqIHRoaXMuZGltc1tpXSArIGFyZ1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pIHtcbiAgICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgb2ZzID0gb2ZzICogdGhpcy5kaW1zW2ldICsgKGFyZ1tpXSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2ZzO1xuICB9XG5cbiAgZ2V0KG9mcykge1xuICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIEludDY0XG4gICAgICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICAgICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCwgaCk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICAgICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgICAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiBjYW1sX3VucGFja0Zsb2F0MTYodGhpcy5kYXRhW29mc10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xuICAgIH1cbiAgfVxuXG4gIHNldChvZnMsIHYpIHtcbiAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyBJbnQ2NFxuICAgICAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgICAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6XG4gICAgICBjYXNlIDExOlxuICAgICAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgICAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICAgICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgdGhpcy5kYXRhW29mc10gPSBjYW1sX3BhY2tGbG9hdDE2KHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZmlsbCh2KSB7XG4gICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gSW50NjRcbiAgICAgICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBpICUgMiA9PT0gMCA/IGEgOiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6XG4gICAgICBjYXNlIDExOlxuICAgICAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgICAgICB2YXIgaW0gPSB2WzFdO1xuICAgICAgICB2YXIgcmUgPSB2WzJdO1xuICAgICAgICBpZiAoaW0gPT09IHJlKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBpICUgMiA9PT0gMCA/IGltIDogcmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwoY2FtbF9wYWNrRmxvYXQxNih2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBhcmUoYiwgdG90YWwpIHtcbiAgICBpZiAodGhpcy5sYXlvdXQgIT09IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPT0gYi5raW5kKSB7XG4gICAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgICB2YXIgazIgPSBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgICByZXR1cm4gazIgLSBrMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT09IGIuZGltcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAodGhpcy5kaW1zW2ldICE9PSBiLmRpbXNbaV0pIHJldHVybiB0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0gPyAtMSA6IDE7XG4gICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMTA6XG4gICAgICBjYXNlIDExOlxuICAgICAgICAvLyBGbG9hdHNcbiAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKHggIT09IHkpIHtcbiAgICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oeCkpIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oeSkpIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIEludDY0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPCBiLmRhdGFbaSArIDFdKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPiBiLmRhdGFbaSArIDFdKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID4+PiAwIDwgYi5kYXRhW2ldID4+PiAwKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+Pj4gMCA+IGIuZGF0YVtpXSA+Pj4gMCkgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBhYSA9IGNhbWxfdW5wYWNrRmxvYXQxNih0aGlzLmRhdGFbaV0pO1xuICAgICAgICAgIHZhciBiYiA9IGNhbWxfdW5wYWNrRmxvYXQxNihiLmRhdGFbaV0pO1xuICAgICAgICAgIGlmIChhYSA8IGJiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKGFhID4gYmIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA4OlxuICAgICAgY2FzZSA5OlxuICAgICAgY2FzZSAxMjpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSkgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5jbGFzcyBNbF9CaWdhcnJheV9jXzFfMSBleHRlbmRzIE1sX0JpZ2FycmF5IHtcbiAgb2Zmc2V0KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggPT09IDEpIGFyZyA9IGFyZ1swXTtcbiAgICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICAgIH1cbiAgICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxuXG4gIGdldChvZnMpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc107XG4gIH1cblxuICBzZXQob2ZzLCB2KSB7XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZmlsbCh2KSB7XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSwgYiwgdG90YWwpIHtcbiAgcmV0dXJuIGEuY29tcGFyZShiLCB0b3RhbCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpIHtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZiAoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZiAoXG4gICAgbGF5b3V0ID09PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgZGltcy5sZW5ndGggPT09IDEgJiYgLy8gQXJyYXkxXG4gICAgc2l6ZV9wZXJfZWxlbWVudCA9PT0gMSAmJlxuICAgIGtpbmQgIT09IDEzIC8vIGZsb2F0MTZcbiAgKVxuICAgIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZiAoYmEubGF5b3V0ID09PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gYjEgfCAoYjIgPDwgOCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzICsgMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcyArIDIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzICsgMyk7XG4gIHJldHVybiAoYjEgPDwgMCkgfCAoYjIgPDwgOCkgfCAoYjMgPDwgMTYpIHwgKGI0IDw8IDI0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmIChvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMgKyAwKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzICsgMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMgKyAzKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcyArIDQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzICsgNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMgKyA2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcyArIDcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsIGI3LCBiNiwgYjUsIGI0LCBiMywgYjIsIGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsIGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCwgaTEsIGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZiAob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzICsgMCwgdiAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYgKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyArIDAsIHYgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyArIDEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzICsgMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmIChvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMgKyBpLCB2WzcgLSBpXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsIGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCwgaTEsIGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT09IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIDE7IGkrKykgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKykgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKykgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkoXG4gICAgb2ZzICogc2l6ZV9wZXJfZWxlbWVudCxcbiAgICAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50LFxuICApO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT09IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFja0Zsb2F0MTZcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKTtcbiAgaWYgKGJhLmNhbWxfY3VzdG9tID09PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJhLmRpbXNbaV0gPCAweGZmZmYpIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gIHN3aXRjaCAoYmEua2luZCkge1xuICAgIGNhc2UgMjogLy9JbnQ4QXJyYXlcbiAgICBjYXNlIDM6IC8vVWludDhBcnJheVxuICAgIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gSW50MTZBcnJheVxuICAgIGNhc2UgNTogLy8gVWludDE2QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA2OiAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OiAvLyBJbnQzMkFycmF5IChpbnQpXG4gICAgY2FzZSA5OiAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNzogLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOiAvLyBGbG9hdDY0QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzogLy8gRmxvYXQxNkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDogLy8gRmxvYXQzMkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlKDgsIGJbal0pO1xuICAgICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSg4LCBiW2pdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX3VucGFja0Zsb2F0MTZcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSkge1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZjtcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdO1xuICBpZiAobmFtZSA9PT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZiAoc2l6ZV9kaW0gPT09IDB4ZmZmZikge1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZiAoc2l6ZV9kaW1faGkgIT09IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgMjogLy9JbnQ4QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vVWludDhBcnJheVxuICAgIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gSW50MTZBcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6IC8vIFVpbnQxNkFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjogLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgODogLy8gSW50MzJBcnJheSAoaW50KVxuICAgIGNhc2UgOTogLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgaWYgKHNpeHR5KVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgIFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIixcbiAgICAgICAgKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgICBiYS5zZXQoaSwgaW50NjQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOiAvLyBGbG9hdDY0QXJyYXlcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgICBiYS5zZXQoaSwgZik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEzOiAvLyBGbG9hdDE2QXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAwOiAvLyBGbG9hdDMyQXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgICBiYS5zZXQoaSwgZik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgICBiYS5zZXQoaSwgWzI1NCwgcmUsIGltXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgICAgYmEuc2V0KGksIFsyNTQsIHJlLCBpbV0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vRGVwcmVjYXRlZDogVXNlIFtjYW1sX2JhX2NyZWF0ZV91bnNhZmVdIGluc3RlYWRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBfanN0eXAsIGtpbmQsIGxheW91dCwgZGltcykge1xuICBpZiAoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PT0gMikge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcbiAgICAgIFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIixcbiAgICApO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfdW5wYWNrRmxvYXQxNiwgY2FtbF9oYXNoX21peF9mbG9hdDE2LCBjYW1sX2hhc2hfbWl4X2Zsb2F0MzJcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSkge1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaCAoYmEua2luZCkge1xuICAgIGNhc2UgMjogLy9JbnQ4QXJyYXlcbiAgICBjYXNlIDM6IC8vVWludDhBcnJheVxuICAgIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgICAgaWYgKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICAgIHZhciB3ID0gMCxcbiAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgNCA8PSBudW1fZWx0czsgaSArPSA0KSB7XG4gICAgICAgIHcgPVxuICAgICAgICAgIChiYS5kYXRhW2kgKyAwXSAmIDB4ZmYpIHxcbiAgICAgICAgICAoKGJhLmRhdGFbaSArIDFdICYgMHhmZikgPDwgOCkgfFxuICAgICAgICAgICgoYmEuZGF0YVtpICsgMl0gJiAweGZmKSA8PCAxNikgfFxuICAgICAgICAgIChiYS5kYXRhW2kgKyAzXSA8PCAyNCk7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICAgIH1cbiAgICAgIHcgPSAwO1xuICAgICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgICB3ID0gYmEuZGF0YVtpICsgMl0gPDwgMTY7XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICAgICAgdyB8PSBiYS5kYXRhW2kgKyAxXSA8PCA4O1xuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdyB8PSBiYS5kYXRhW2kgKyAwXTtcbiAgICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8vIEludDE2QXJyYXlcbiAgICBjYXNlIDU6IC8vIFVpbnQxNkFycmF5XG4gICAgICBpZiAobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgICAgdmFyIHcgPSAwLFxuICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgKyAyIDw9IG51bV9lbHRzOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IChiYS5kYXRhW2kgKyAwXSAmIDB4ZmZmZikgfCAoYmEuZGF0YVtpICsgMV0gPDwgMTYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgICB9XG4gICAgICBpZiAoKG51bV9lbHRzICYgMSkgIT09IDApIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjogLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OiAvLyBJbnQzMkFycmF5IChpbnQpXG4gICAgY2FzZSA5OiAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA3OiAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgICAgbnVtX2VsdHMgKj0gMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIG51bV9lbHRzICo9IDI7XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIDA6IC8vIEZsb2F0MzJBcnJheVxuICAgICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspXG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0MzIoaCwgYmEuZGF0YVtpXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgIG51bV9lbHRzICo9IDI7XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIDE6IC8vIEZsb2F0NjRBcnJheVxuICAgICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIGlmIChudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQxNihoLCBiYS5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0MTZcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0MTYoaGFzaCwgZCkge1xuICAvKiBOb3JtYWxpemUgTmFOcyAqL1xuICBpZiAoKGQgJiAweDdjMDApID09PSAweDdjMDAgJiYgKGQgJiAweDAzZmYpICE9PSAwKSB7XG4gICAgZCA9IDB4N2MwMTtcbiAgfSBlbHNlIGlmIChkID09PSAweDgwMDApIHtcbiAgICAvKiBOb3JtYWxpemUgLTAgaW50byArMCAqL1xuICAgIGQgPSAwO1xuICB9XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludChoYXNoLCBkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0MzIoaGFzaCwgdikge1xuICB2YXIgaSA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCh2KTtcbiAgLyogTm9ybWFsaXplIE5hTnMgKi9cbiAgaWYgKChpICYgMHg3ZjgwMDAwMCkgPT09IDB4N2Y4MDAwMDAgJiYgKGkgJiAweDdmZmZmZikgIT09IDApIHtcbiAgICBpID0gMHg3ZjgwMDAwMTtcbiAgfSBlbHNlIGlmIChpID09PSAoMHg4MDAwMDAwMCB8IDApKSB7XG4gICAgLyogTm9ybWFsaXplIC0wIGludG8gKzAgKi9cbiAgICAvLyBUaGlzIGNvZGUgcGF0aCBpcyBub3QgdXNlZCBieSBjYW1sX2hhc2ggYmVjYXVzZSAwIGFuZCAtMCBsb29rXG4gICAgLy8gbGlrZSBpbnRlZ2Vyc1xuICAgIGkgPSAwO1xuICB9XG4gIGhhc2ggPSBjYW1sX2hhc2hfbWl4X2ludChoYXNoLCBpKTtcbiAgcmV0dXJuIGhhc2g7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSkge1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKSB7XG4gIHZhciBraW5kO1xuICBpZiAodGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkga2luZCA9IDQ7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXk6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHJldHVybiBraW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSh0YSkge1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHZhciB0YSA9XG4gICAgLyogTmVlZGVkIHRvIGF2b2lkIHVuc2lnbmVkIHNldHRlcnMgb3ZlcmZsb3dpbmdcbiAgICAgICAgIHRoZSByYW5nZSBvZiBPQ2FtbCBbaW50MzJdIHZhbHVlcy4gKi9cbiAgICB0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgICA/IG5ldyBJbnQzMkFycmF5KHRhLmJ1ZmZlciwgdGEuYnl0ZU9mZnNldCwgdGEubGVuZ3RoKVxuICAgICAgOiB0YTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3VuaXhfZXhpdFxuLy9BbGlhczogdW5peF9leGl0XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0KGNvZGUpIHtcbiAgaWYgKGdsb2JhbFRoaXMucXVpdCkgZ2xvYmFsVGhpcy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZiAoZ2xvYmFsVGhpcy5wcm9jZXNzPy5leGl0KSBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG4pIHtcbiAgc3dpdGNoIChleG5bMl0pIHtcbiAgICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gICAgY2FzZSAtMTE6IC8vIEFzc2VydF9mYWlsdXJlXG4gICAgY2FzZSAtMTI6IC8vIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG4gICAgICByZXR1cm4gMTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXhuKSB7XG4gIHZhciByID0gXCJcIjtcbiAgaWYgKGV4blswXSA9PT0gMCkge1xuICAgIHIgKz0gZXhuWzFdWzFdO1xuICAgIGlmIChcbiAgICAgIGV4bi5sZW5ndGggPT09IDMgJiZcbiAgICAgIGV4blsyXVswXSA9PT0gMCAmJlxuICAgICAgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG5bMV0pXG4gICAgKSB7XG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMjtcbiAgICAgIHZhciBidWNrZXQgPSBleG47XG4gICAgfVxuICAgIHIgKz0gXCIoXCI7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IHN0YXJ0KSByICs9IFwiLCBcIjtcbiAgICAgIHZhciB2ID0gYnVja2V0W2ldO1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSByICs9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgIHIgKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHIgKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9IGVsc2UgciArPSBcIl9cIjtcbiAgICB9XG4gICAgciArPSBcIilcIjtcbiAgfSBlbHNlIGlmIChleG5bMF0gPT09IDI0OCkge1xuICAgIHIgKz0gZXhuWzFdO1xuICB9XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9mb3JtYXRfZXhjZXB0aW9uLCBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyKSAmJiAoZXJyWzBdID09PSAwIHx8IGVyclswXSA9PT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYgKGhhbmRsZXIpIGNhbWxfY2FsbGJhY2soaGFuZGxlciwgW2VyciwgZmFsc2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmIChhdF9leGl0KSBjYW1sX2NhbGxiYWNrKGF0X2V4aXQsIFswXSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIiArIG1zZyk7XG4gICAgICBpZiAoZXJyLmpzX2Vycm9yKSB0aHJvdyBlcnIuanNfZXJyb3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3N0YXRpY19lbnZcbnZhciBqc29vX3N0YXRpY19lbnYgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuLy9SZXF1aXJlczoganNvb19zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssIHYpIHtcbiAganNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc29vX3N0YXRpY19lbnZcbmZ1bmN0aW9uIGpzb29fc3lzX2dldGVudihuKSB7XG4gIGlmIChqc29vX3N0YXRpY19lbnZbbl0pIHJldHVybiBqc29vX3N0YXRpY19lbnZbbl07XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICAvL25vZGVqcyBlbnZcbiAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnZbbl0gIT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbl07XG4gIGlmIChnbG9iYWxUaGlzLmpzb29fZW52ICYmIHR5cGVvZiBnbG9iYWxUaGlzLmpzb29fZW52W25dID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuanNvb19lbnZbbl07XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52KG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudl9vcHQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX3N5c19nZXRlbnZcbi8vVmVyc2lvbjogPj0gNS40XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnZfb3B0KG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhyKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnZcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfdW5zYWZlX2dldGVudihuYW1lKSB7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYobmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX2FyZ3YgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2VzcztcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW107XG5cbiAgaWYgKHByb2Nlc3M/LmFyZ3Y/Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IHByb2Nlc3MuYXJndjtcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXTtcblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YoX3VuaXQpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndihfdW5pdCkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpIHtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKF91bml0KSB7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpIHtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiKTtcbiAgICBpZiAoY2hpbGRfcHJvY2Vzcz8uZXhlY1N5bmMpXG4gICAgICB0cnkge1xuICAgICAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNtZCwgeyBzdGRpbzogXCJpbmhlcml0XCIgfSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgfSBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoX2NtZCkge1xuICByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lKCkge1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihfYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCgpIHtcbiAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdmFyIGEgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IEludDMyQXJyYXkoNCkpO1xuICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgICB2YXIgYSA9IG5ldyBJbnQzMkFycmF5KGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS5idWZmZXIpO1xuICAgICAgcmV0dXJuIFswLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdXTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vdyBeICgweGZmZmZmZmZmICogTWF0aC5yYW5kb20oKSk7XG4gIHJldHVybiBbMCwgeF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4oKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSgpIHtcbiAgcmV0dXJuIDMyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUoKSB7XG4gIHJldHVybiAzMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplKCkge1xuICByZXR1cm4gKDB4N2ZmZmZmZmYgLyA0KSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCgpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiVW5peFwiID8gMSA6IDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMigpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiV2luMzJcIiA/IDEgOiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbigpIHtcbiAgcmV0dXJuIG9zX3R5cGUgPT09IFwiQ3lnd2luXCIgPyAxIDogMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogb3NfdHlwZVxudmFyIG9zX3R5cGUgPSBnbG9iYWxUaGlzLnByb2Nlc3M/LnBsYXRmb3JtID09PSBcIndpbjMyXCIgPyBcIldpbjMyXCIgOiBcIlVuaXhcIjtcblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZygpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF94ZGdfZGVmYXVsdHNcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX3hkZ19kZWZhdWx0cyhfdW5pdCkge1xuICByZXR1cm4gMDsgLy8gZW1wdHkgbGlzdFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGVcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1ZlcnNpb246ID49IDUuMVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmlzRmlsZShyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lvX2J1ZmZlcl9zaXplXG52YXIgY2FtbF9pb19idWZmZXJfc2l6ZSA9IDY1NTM2O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pb19idWZmZXJfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pb19idWZmZXJfc2l6ZVxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfc3lzX2lvX2J1ZmZlcl9zaXplKF91bml0KSB7XG4gIHJldHVybiBjYW1sX2lvX2J1ZmZlcl9zaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190ZW1wX2Rpcl9uYW1lXG4vL1JlcXVpcmVzOiBvc190eXBlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfc3lzX3RlbXBfZGlyX25hbWUoX3VuaXQpIHtcbiAgaWYgKG9zX3R5cGUgPT09IFwiV2luMzJcIikge1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhyZXF1aXJlKFwibm9kZTpvc1wiKS50bXBkaXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwiXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnZlcnRfc2lnbmFsX251bWJlclxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnZlcnRfc2lnbmFsX251bWJlcihzaWdubykge1xuICByZXR1cm4gc2lnbm87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Jldl9jb252ZXJ0X3NpZ25hbF9udW1iZXJcbi8vVmVyc2lvbjogPj0gNS40XG5mdW5jdGlvbiBjYW1sX3N5c19yZXZfY29udmVydF9zaWduYWxfbnVtYmVyKHNpZ25vKSB7XG4gIHJldHVybiBzaWdubztcbn1cblxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL0lmOiAhd2FzbVxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIGlmIChwcm9jZXNzPy5vbikge1xuICAgIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBmdW5jdGlvbiAoZXJyLCBvcmlnaW4pIHtcbiAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycik7XG4gICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZXJyb3IpIHtcbiAgICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZyA9IEZMQUcoXCJ3aXRoLWpzLWVycm9yXCIpO1xuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IGpzb29fc3lzX2dldGVudihcIk9DQU1MUlVOUEFSQU1cIik7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbCA9IHIuc3BsaXQoXCIsXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxbaV0gPT09IFwiYlwiKSB7XG4gICAgICAgIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZyA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChsW2ldLnN0YXJ0c1dpdGgoXCJiPVwiKSkge1xuICAgICAgICBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWcgPSArbFtpXS5zbGljZSgyKTtcbiAgICAgIH0gZWxzZSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWdcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9lbnZfZmxhZ1xudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcgPSBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWc7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfcnVudGltZV9mbGFnXG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcgPyAxIDogMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlKF91bml0KSB7XG4gIHJldHVybiBbMF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZShiKSB7XG4gIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcgPSBiO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSgpIHtcbiAgcmV0dXJuIFswXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdChfc2xvdCkge1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90KF9idCwgX2lkeCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKF9leG4sIF9idCkge1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjaygpIHtcbiAgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdChfcmJ0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwcihmKSB7XG4gIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFswXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgbXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sIGYsIHYpIHtcbiAgb1tmXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobywgZikge1xuICByZXR1cm4gb1tmXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sIGYpIHtcbiAgZGVsZXRlIG9bZl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLCBjKSB7XG4gIHJldHVybiBvIGluc3RhbmNlb2YgYyA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7XG4gIHJldHVybiB0eXBlb2Ygbztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZSAocmVzPy5qb29fdHJhbXApIHtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLCBhcmdzLCBkaXJlY3QpIHtcbiAgcmV0dXJuIHsgam9vX3RyYW1wOiBmLCBqb29fYXJnczogYXJncywgam9vX2RpcmVjdDogZGlyZWN0IH07XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF9zdGFja19kZXB0aFxuLy9JZjogZWZmZWN0c1xudmFyIGNhbWxfc3RhY2tfZGVwdGggPSAwO1xuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfY2hlY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbi8vUmVxdWlyZXM6Y2FtbF9zdGFja19kZXB0aFxuZnVuY3Rpb24gY2FtbF9zdGFja19jaGVja19kZXB0aCgpIHtcbiAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdGFja19kZXB0aCwgY2FtbF9jYWxsX2dlbiwgY2FtbF93cmFwX2V4Y2VwdGlvblxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X3N0YWNrXG4vL0FsaWFzOiBjYW1sX2Nwc190cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpIHtcbiAgdmFyIHNhdmVkX3N0YWNrX2RlcHRoID0gY2FtbF9zdGFja19kZXB0aDtcbiAgdmFyIHNhdmVkX2N1cnJlbnRfc3RhY2sgPSBjYW1sX2N1cnJlbnRfc3RhY2s7XG4gIHRyeSB7XG4gICAgY2FtbF9jdXJyZW50X3N0YWNrID0geyBrOiAwLCB4OiAwLCBoOiAwLCBlOiAwIH07XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGpvb190cmFtcDogZixcbiAgICAgIGpvb19hcmdzOiBhcmdzLmNvbmNhdChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pLFxuICAgIH07XG4gICAgZG8ge1xuICAgICAgY2FtbF9zdGFja19kZXB0aCA9IDQwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gY2FtbF9jYWxsX2dlbihyZXMuam9vX3RyYW1wLCByZXMuam9vX2FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBIYW5kbGUgZXhjZXB0aW9uIGNvbWluZyBmcm9tIEphdmFTY3JpcHQgb3IgZnJvbSB0aGUgcnVudGltZS4gKi9cbiAgICAgICAgaWYgKCFjYW1sX2N1cnJlbnRfc3RhY2sueCkgdGhyb3cgZTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYW1sX2N1cnJlbnRfc3RhY2sueC5oO1xuICAgICAgICBjYW1sX2N1cnJlbnRfc3RhY2sueCA9IGNhbWxfY3VycmVudF9zdGFjay54LnQ7XG4gICAgICAgIHJlcyA9IHsgam9vX3RyYW1wOiBoYW5kbGVyLCBqb29fYXJnczogW2NhbWxfd3JhcF9leGNlcHRpb24oZSldIH07XG4gICAgICB9XG4gICAgfSB3aGlsZSAocmVzPy5qb29fYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgY2FtbF9zdGFja19kZXB0aCA9IHNhdmVkX3N0YWNrX2RlcHRoO1xuICAgIGNhbWxfY3VycmVudF9zdGFjayA9IHNhdmVkX2N1cnJlbnRfc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG52YXIgY2FtbF9jYWxsYmFjayA9IGNhbWxfY2FsbF9nZW47XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmcoX3VuaXQpIHtcbiAgcmV0dXJuIEZMQUcoXCJ1c2UtanMtc3RyaW5nXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0c1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNvb19mbGFnc19lZmZlY3RzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhDT05GSUcoXCJlZmZlY3RzXCIpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAobXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmIChGTEFHKFwiZXhjd3JhcFwiKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSByZXR1cm4gZTtcbiAgICB2YXIgZXhuO1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gICAgaWYgKFxuICAgICAgZ2xvYmFsVGhpcy5SYW5nZUVycm9yICYmXG4gICAgICBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yICYmXG4gICAgICBlLm1lc3NhZ2UgJiZcbiAgICAgIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpXG4gICAgKVxuICAgICAgZXhuID0gY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdztcbiAgICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gICAgZWxzZSBpZiAoXG4gICAgICBnbG9iYWxUaGlzLkludGVybmFsRXJyb3IgJiZcbiAgICAgIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3IgJiZcbiAgICAgIGUubWVzc2FnZSAmJlxuICAgICAgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSlcbiAgICApXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgICBlbHNlIGlmIChlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICAgIGV4biA9IFswLCBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSwgZV07XG4gICAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gICAgZWxzZVxuICAgICAgZXhuID0gWzAsIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoU3RyaW5nKGUpKV07XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGF0IGhhbmQsIGxldCdzIHVzZSBpdC5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpIGV4bi5qc19lcnJvciA9IGU7XG4gICAgcmV0dXJuIGV4bjtcbiAgfSBlbHNlIHJldHVybiBlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZW52X2ZsYWdcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWdcbmZ1bmN0aW9uIGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vIEJhY2t0cmFjZXMgYXJlIHZlcnkgZXhwZW5zaXZlLCB3ZSBvbmx5IGVuYWJsZSB0aGVtIHdoZW4gZXhwbGljaXRseSByZXF1ZXN0ZWRcbiAgLy8gYXQgY29tcGlsZS10aW1lICgtLWVuYWJsZSB3aXRoLWpzLWVycm9yKSBvciBhdCBzdGFydHVwIHdpdGggT0NBTUxSVU5QQVJBTT1iPTEuXG4gIC8vIExpYnJhcmllcyBzdWNoIGFzIEJhc2UgdW5jb25kaXRpb25hbGx5IGVuYWJsZSBiYWNrdHJhY2VzIChwcm9ncmFtbWF0aWNhbGx5KSBidXRcbiAgLy8gaXQncyB3YXkgdG8gc2xvdy4gSGVyZSwgd2UgZm9yY2UgdGhlIGVuZC11c2VyIHRvIG9wdC1pbiB0byBiYWNrdHJhY2VzLlxuICBpZiAoY2FtbF9yZWNvcmRfYmFja3RyYWNlX2Vudl9mbGFnICYmIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9ydW50aW1lX2ZsYWcpXG4gICAgcmV0dXJuIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpO1xuICBlbHNlIHJldHVybiBleG47XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYgKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09PSAyNDgpXG4gICAgZXhuLmpzX2Vycm9yID0gbmV3IGdsb2JhbFRoaXMuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZiAoZXhuLmpzX2Vycm9yKSB7XG4gICAgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Rocm93X2pzX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF90aHJvd19qc19leGNlcHRpb24oZXhuKSB7XG4gIHRocm93IGV4bjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkge1xuICByZXR1cm4gISF4O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7XG4gIHJldHVybiAreDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG4vL0FsaWFzOiBjYW1sX2pzX2Zyb21faW50MzJcbi8vQWxpYXM6IGNhbWxfanNfZnJvbV9uYXRpdmVpbnRcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2ludDMyIGNvbnN0IChjb25zdClcbi8vQWxpYXM6IGNhbWxfanNfdG9fbmF0aXZlaW50XG5mdW5jdGlvbiBjYW1sX2pzX3RvX2ludDMyKHgpIHtcbiAgcmV0dXJuIHggfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7XG4gIHJldHVybiBhLnNsaWNlKDEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBiW2kgKyAxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSkge1xuICB2YXIgbCA9IDA7XG4gIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCwgZSwgbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKSB7XG4gIHZhciBhID0gW107XG4gIGZvciAoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZiAoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ2NhbWxfanNfdmFyOiBcIicgK1xuICAgICAgICB4ICtcbiAgICAgICAgJ1wiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi4nLFxuICAgICk7XG4gICAgLy9jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc2VjdXJpdHkvbm9HbG9iYWxFdmFsOlxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7XG4gIHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZigpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmKGFbMV0pO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0pO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0pO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0pO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gbmV3IGMoKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gbmV3IGMoYVsxXSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMV0sIGFbMl0pO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBuZXcgYyhhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gbmV3IGMoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSk7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBuZXcgYyhhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdKTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gbmV3IGMoYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHtcbiAgICByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xuICB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRigpO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIG5ldyBjKCk7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMF0pO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBuZXcgYyhhWzBdLCBhWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gbmV3IGMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBuZXcgYyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdKTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gbmV3IGMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIG5ldyBjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7XG4gIH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGKCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcmdzID0gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICAgIHJldHVybiByZXMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpIDogcmVzO1xuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgW2FyZ3NdKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncy5sZW5ndGggPSBhcml0eTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIHZhciBsZW4gPSBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpO1xuICAgIGFyZ3MubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBjYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKSA6IHJlcztcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbdGhpcywgYXJnc10pO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncy5sZW5ndGggPSBhcml0eTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZik7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGFyZ3MubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiAhZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIHJldHVybiBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIHJldHVybiBmLmwgPj0gMCA/IGYubCA6IChmLmwgPSBmLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6IGVmZmVjdHNcbi8vSWY6ICFkb3VibGV0cmFuc2xhdGVcbmZ1bmN0aW9uIGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikge1xuICAvLyBGdW5jdGlvbnMgaGF2ZSBhbiBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBwYXJhbWV0ZXIuIFRoaXMgc2hvdWxkXG4gIC8vIG5vdCBiZSB2aXNpYmxlIHdoZW4gY2FsbGluZyB0aGVtIGZyb20gSmF2YVNjcmlwdFxuICByZXR1cm4gKGYubCA+PSAwID8gZi5sIDogKGYubCA9IGYubGVuZ3RoKSkgLSAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyh4LCB5KSB7XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9Eb3VibGVFcXVhbHM6XG4gIHJldHVybiArKHggPT0geSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc3RyaWN0X2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3N0cmljdF9lcXVhbHMoeCwgeSkge1xuICByZXR1cm4gKyh4ID09PSB5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyhzKSB7XG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3NlY3VyaXR5L25vR2xvYmFsRXZhbDpcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc2VjdXJpdHkvbm9HbG9iYWxFdmFsOlxuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwcihzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICAvLyBiaW9tZS1pZ25vcmUgbGludC9zZWN1cml0eS9ub0dsb2JhbEV2YWw6XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0KGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAweDIwLFxuICBDT0RFX0lOVDg6IDB4MDAsXG4gIENPREVfSU5UMTY6IDB4MDEsXG4gIENPREVfSU5UMzI6IDB4MDIsXG4gIENPREVfSU5UNjQ6IDB4MDMsXG4gIENPREVfU0hBUkVEODogMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAweDA4LFxuICBDT0RFX0JMT0NLNjQ6IDB4MTMsXG4gIENPREVfU1RSSU5HODogMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogMHgwYSxcbiAgQ09ERV9ET1VCTEVfQklHOiAweDBiLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6IDB4MGMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6IDB4MGQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6IDB4MGUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAweDBmLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6IDB4MTEsXG4gIENPREVfQ1VTVE9NOiAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46IDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAweDE5LFxufTtcblxuLy9Qcm92aWRlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXlcbmNsYXNzIFVJbnQ4QXJyYXlSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzLCBpKSB7XG4gICAgdGhpcy5zID0gcztcbiAgICB0aGlzLmkgPSBpO1xuICB9XG5cbiAgcmVhZDh1KCkge1xuICAgIHJldHVybiB0aGlzLnNbdGhpcy5pKytdO1xuICB9XG5cbiAgcmVhZDhzKCkge1xuICAgIHJldHVybiAodGhpcy5zW3RoaXMuaSsrXSA8PCAyNCkgPj4gMjQ7XG4gIH1cblxuICByZWFkMTZ1KCkge1xuICAgIHZhciBzID0gdGhpcy5zLFxuICAgICAgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHNbaV0gPDwgOCkgfCBzW2kgKyAxXTtcbiAgfVxuXG4gIHJlYWQxNnMoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoKHNbaV0gPDwgMjQpID4+IDE2KSB8IHNbaSArIDFdO1xuICB9XG5cbiAgcmVhZDMydSgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoc1tpXSA8PCAyNCkgfCAoc1tpICsgMV0gPDwgMTYpIHwgKHNbaSArIDJdIDw8IDgpIHwgc1tpICsgM10pID4+PiAwO1xuICB9XG5cbiAgcmVhZDMycygpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzW2ldIDw8IDI0KSB8IChzW2kgKyAxXSA8PCAxNikgfCAoc1tpICsgMl0gPDwgOCkgfCBzW2kgKyAzXTtcbiAgfVxuXG4gIHJlYWRzdHIobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXkodGhpcy5zLnN1YmFycmF5KGksIGkgKyBsZW4pKTtcbiAgfVxuXG4gIHJlYWR1aW50OGFycmF5KGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIHRoaXMucy5zdWJhcnJheShpLCBpICsgbGVuKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBKc1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuY2xhc3MgSnNTdHJpbmdSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzLCBpKSB7XG4gICAgdGhpcy5zID0gcztcbiAgICB0aGlzLmkgPSBpO1xuICB9XG5cbiAgcmVhZDh1KCkge1xuICAgIHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7XG4gIH1cblxuICByZWFkOHMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQpID4+IDI0O1xuICB9XG5cbiAgcmVhZDE2dSgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9XG5cbiAgcmVhZDE2cygpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9XG5cbiAgcmVhZDMydSgpIHtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChcbiAgICAgICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8XG4gICAgICAgIChzLmNoYXJDb2RlQXQoaSArIDEpIDw8IDE2KSB8XG4gICAgICAgIChzLmNoYXJDb2RlQXQoaSArIDIpIDw8IDgpIHxcbiAgICAgICAgcy5jaGFyQ29kZUF0KGkgKyAzKSkgPj4+XG4gICAgICAwXG4gICAgKTtcbiAgfVxuXG4gIHJlYWQzMnMoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoXG4gICAgICAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkgKyAxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpICsgMikgPDwgOCkgfFxuICAgICAgcy5jaGFyQ29kZUF0KGkgKyAzKVxuICAgICk7XG4gIH1cblxuICByZWFkc3RyKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnNsaWNlKGksIGkgKyBsZW4pKTtcbiAgfVxuXG4gIHJlYWR1aW50OGFycmF5KGxlbikge1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICB2YXIgcyA9IHRoaXMucztcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBiW2pdID0gcy5jaGFyQ29kZUF0KGkgKyBqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gYjtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogSnNTdHJpbmdSZWFkZXIsIFVJbnQ4QXJyYXlSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsIG9mcykge1xuICB2YXIgYyA9IGNhbWxfbWxfYnl0ZXNfY29udGVudChzKTtcbiAgdmFyIG9mcyA9IHR5cGVvZiBvZnMgPT09IFwibnVtYmVyXCIgPyBvZnMgOiBvZnNbMF07XG4gIHZhciByZWFkZXIgPVxuICAgIGMgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICA/IG5ldyBVSW50OEFycmF5UmVhZGVyKGMsIG9mcylcbiAgICAgIDogbmV3IEpzU3RyaW5nUmVhZGVyKGMsIG9mcyk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpIHtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7XG4gIHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSkge1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSkge1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUoKSkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNpemVbMF0gPSA0O1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzKCk7XG4gICAgY2FzZSAyOlxuICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9IHtcbiAgX2o6IHtcbiAgICBkZXNlcmlhbGl6ZTogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgc2VyaWFsaXplOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgZml4ZWRfbGVuZ3RoOiA4LFxuICAgIGNvbXBhcmU6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICBoYXNoOiBjYW1sX2ludDY0X2hhc2gsXG4gIH0sXG4gIF9pOiB7XG4gICAgZGVzZXJpYWxpemU6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgIGZpeGVkX2xlbmd0aDogNCxcbiAgfSxcbiAgX246IHtcbiAgICBkZXNlcmlhbGl6ZTogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgIGZpeGVkX2xlbmd0aDogNCxcbiAgfSxcbiAgX2JpZ2FycmF5OiB7XG4gICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7XG4gICAgICByZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBcIl9iaWdhcnJheVwiKTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgY29tcGFyZTogY2FtbF9iYV9jb21wYXJlLFxuICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgfSxcbiAgX2JpZ2FycjAyOiB7XG4gICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7XG4gICAgICByZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBcIl9iaWdhcnIwMlwiKTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgY29tcGFyZTogY2FtbF9iYV9jb21wYXJlLFxuICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgfSxcbn07XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2V0X29vX2lkXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlcikge1xuICBmdW5jdGlvbiByZWFkdmxxKG92ZXJmbG93KSB7XG4gICAgdmFyIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3ZjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPT0gMCkge1xuICAgICAgYyA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9PSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N2YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICB2YXIgbWFnaWMgPSByZWFkZXIucmVhZDMydSgpO1xuICBzd2l0Y2ggKG1hZ2ljKSB7XG4gICAgY2FzZSAweDg0OTVhNmJlIC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSAwO1xuICAgICAgdmFyIGRhdGFfbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgIHZhciB1bmNvbXByZXNzZWRfZGF0YV9sZW4gPSBkYXRhX2xlbjtcbiAgICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZCAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IHJlYWRlci5yZWFkOHUoKSAmIDB4M2Y7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IDE7XG4gICAgICB2YXIgb3ZlcmZsb3cgPSBbZmFsc2VdO1xuICAgICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICB2YXIgdW5jb21wcmVzc2VkX2RhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICB2YXIgbnVtX29iamVjdHMgPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICAgIHZhciBfc2l6ZV8zMiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgICAgdmFyIF9zaXplXzY0ID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgICBpZiAob3ZlcmZsb3dbMF0pIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcbiAgICAgICAgICBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqLzpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgIFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gYSAzMi1iaXQgcGxhdGZvcm1cIixcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IGJhZCBvYmplY3RcIik7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoaGVhZGVyX2xlbiAhPT0gcmVhZGVyLmkgLSBvbGRfcG9zKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IGludmFsaWQgaGVhZGVyXCIpO1xuICB9XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgb2JqZWN0cyA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IG51bV9vYmplY3RzID4gMCA/IFtdIDogbnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyhyZWFkZXIpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4ZjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIGlmICh0YWcgPT09IDI0OCkgb2JqZWN0cy5wdXNoKHYpO1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSByZXR1cm4gY29kZSAmIDB4M2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MWY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMoKTtcbiAgICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc2VkID09PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhmZjtcbiAgICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IDI0OCkgb2JqZWN0cy5wdXNoKHYpO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIobGVuKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgwYTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0cihsZW4pO1xuICAgICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgY2FzZSAweDBjOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyh0KTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgwYjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgdFtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyh0KTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgwZTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MGQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXModCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIDB4MGY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgICAgcyA9IFwiXCI7XG4gICAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1KCkpICE9PSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgICBpZiAoIW9wcylcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgICAgIGlmICghb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkX3NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRfc2l6ZSAhPT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgICAgICAgICAgXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY2FtbF9kZWNvbXByZXNzX2lucHV0KSB7XG4gICAgICB2YXIgZGF0YSA9IHJlYWRlci5yZWFkdWludDhhcnJheShkYXRhX2xlbik7XG4gICAgICB2YXIgcmVzID0gbmV3IFVpbnQ4QXJyYXkodW5jb21wcmVzc2VkX2RhdGFfbGVuKTtcbiAgICAgIHZhciByZXMgPSBjYW1sX2RlY29tcHJlc3NfaW5wdXQoZGF0YSwgcmVzKTtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgVUludDhBcnJheVJlYWRlcihyZXMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNvbXByZXNzZWQgb2JqZWN0LCBjYW5ub3QgZGVjb21wcmVzc1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMocmVhZGVyKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMocmVhZGVyKTtcbiAgfVxuICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHggPSBvYmplY3RzLnBvcCgpO1xuICAgIGlmICh4WzJdID49IDApIGNhbWxfc2V0X29vX2lkKHgpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA8IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMjA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA+PSA1LjEuMFxudmFyIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSA9IDE2O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplKHMsIG9mcykge1xuICB2YXIgciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyksIG9mcyk7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3ZjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPT0gMCkge1xuICAgICAgYyA9IHIucmVhZDh1KCk7XG4gICAgICB2YXIgbjcgPSBuIDw8IDc7XG4gICAgICBpZiAobiAhPT0gbjcgPj4gNykgb3ZlcmZsb3dbMF0gPSB0cnVlO1xuICAgICAgbiA9IG43IHwgKGMgJiAweDdmKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBzd2l0Y2ggKHIucmVhZDMydSgpKSB7XG4gICAgY2FzZSAweDg0OTVhNmJlIC8qIEludGV4dF9tYWdpY19udW1iZXJfc21hbGwgKi86XG4gICAgICB2YXIgaGVhZGVyX2xlbiA9IDIwO1xuICAgICAgdmFyIGRhdGFfbGVuID0gci5yZWFkMzJ1KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4ODQ5NWE2YmQgLyogSW50ZXh0X21hZ2ljX251bWJlcl9jb21wcmVzc2VkICovOlxuICAgICAgdmFyIGhlYWRlcl9sZW4gPSByLnJlYWQ4dSgpICYgMHgzZjtcbiAgICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgICB2YXIgZGF0YV9sZW4gPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICAgIGlmIChvdmVyZmxvd1swXSkge1xuICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgIFwiTWFyc2hhbC5kYXRhX3NpemU6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHg4NDk1YTZiZiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqLzpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgIFwiTWFyc2hhbC5kYXRhX3NpemU6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIGEgMzItYml0IHBsYXRmb3JtXCIsXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoZWFkZXJfbGVuIC0gY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplICsgZGF0YV9sZW47XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbmNsYXNzIE1sT2JqZWN0VGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ianMgPSBbXTtcbiAgICB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLk1hcCgpO1xuICB9XG5cbiAgc3RvcmUodikge1xuICAgIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgICB0aGlzLm9ianMucHVzaCh2KTtcbiAgfVxuXG4gIHJlY2FsbCh2KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gICAgcmV0dXJuIGkgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7IC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9pc19jb250aW51YXRpb25fdGFnXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMjA7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IDA7XG4gICAgICB0aGlzLm9ial9jb3VudGVyID0gMDtcbiAgICAgIHRoaXMuc2l6ZV8zMiA9IDA7XG4gICAgICB0aGlzLnNpemVfNjQgPSAwO1xuICAgIH1cblxuICAgIHdyaXRlKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7IGkgPj0gMDsgaSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhmZjtcbiAgICB9XG5cbiAgICB3cml0ZV9hdChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4OyBpID49IDA7IGkgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweGZmO1xuICAgIH1cblxuICAgIHdyaXRlX2NvZGUoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4OyBpID49IDA7IGkgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgd3JpdGVfc2hhcmVkKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8IDEgPDwgOClcbiAgICAgICAgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAxIDw8IDE2KVxuICAgICAgICB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHBvcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rX2lkeDtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUoMzIsIDB4ODQ5NWE2YmUpO1xuICAgICAgdGhpcy53cml0ZSgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSBmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xLFxuICAgICAgY2xvc3VyZXMgPSBmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMTtcbiAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiLFxuICAgICAgKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7XG4gICAgICAgIHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLCAwXTtcbiAgICAgICAgaWYgKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9PSBzel8zMl82NFswXSlcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXG4gICAgICAgICAgICAgIFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2WzBdID09PSAodlswXSB8IDApKSB7XG4gICAgICAgIGlmICh2WzBdID09PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodlswXSkpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlKFxuICAgICAgICAgICAgOCxcbiAgICAgICAgICAgIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpIDw8IDQpLFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZShcbiAgICAgICAgICAgIDMyLFxuICAgICAgICAgICAgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLyxcbiAgICAgICAgICAgICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdLFxuICAgICAgICAgICk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZiAoIWNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFxuICAgICAgICAgICAgXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMCkgd3JpdGVyLndyaXRlKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwOSAvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZSB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwYSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LCBpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpIHwgMCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpIHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKSB3cml0ZXIud3JpdGUoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDA5IC8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDBhIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LCBpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpIHwgMCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPT0gKHYgfCAwKSkge1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICBpZiAodHlwZV9vZl92ICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiICsgdHlwZV9vZl92ICsgXCIpXCIpO1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuXG4gICAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMHgwYyAvKmNzdC5DT0RFX0RPVUJMRV9MSVRUTEUqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCB0WzcgLSBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXRlci5zaXplXzMyICs9IDM7XG4gICAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8IDEgPDwgNylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgMSA8PCAxNSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZSB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWModik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2godiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdyaXRlci5jaHVuayk7XG4gIH07XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheShjYW1sX291dHB1dF92YWwodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91aW50OF9hcnJheShjYW1sX291dHB1dF92YWwodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl91aW50OF9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyKHMsIG9mcywgbGVuLCB2LCBmbGFncykge1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KHQpLCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NCA9IGNhbWxfaGFzaF9taXhfaW50NjQ7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCA9IGNhbWxfaGFzaF9taXhfaW50O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXQgPSBjYW1sX2hhc2hfbWl4X2Zsb2F0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmcgPSBjYW1sX2hhc2hfbWl4X3N0cmluZztcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG5mdW5jdGlvbiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZShzZWVkKSB7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChzZWVkKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19mZHNcbnZhciBjYW1sX3N5c19mZHMgPSBuZXcgQXJyYXkoMyk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIHZhciB4ID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYgKHgpIHtcbiAgICB4LmZpbGUuY2xvc2UoKTtcbiAgICBkZWxldGUgY2FtbF9zeXNfZmRzW2ZkXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxDaGFuaWRcbmZ1bmN0aW9uIE1sQ2hhbmlkKGlkKSB7XG4gIHRoaXMuaWQgPSBpZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vUmVxdWlyZXM6IE1sQ2hhbmlkXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUsIGlkeCkge1xuICB2YXIgY2hhbmlkO1xuICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZHggPSBjYW1sX3N5c19mZHMubGVuZ3RoO1xuICAgIGNoYW5pZCA9IG5ldyBNbENoYW5pZChpZHgpO1xuICB9IGVsc2UgaWYgKGNhbWxfc3lzX2Zkc1tpZHhdKSB7XG4gICAgY2hhbmlkID0gY2FtbF9zeXNfZmRzW2lkeF0uY2hhbmlkO1xuICB9IGVsc2UgY2hhbmlkID0gbmV3IE1sQ2hhbmlkKGlkeCk7XG4gIGNhbWxfc3lzX2Zkc1tpZHhdID0geyBmaWxlOiBmaWxlLCBjaGFuaWQ6IGNoYW5pZCB9O1xuICByZXR1cm4gaWR4IHwgMDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4obmFtZSwgZmxhZ3MsIHBlcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlIChmbGFncykge1xuICAgIHN3aXRjaCAoZmxhZ3NbMV0pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZi5yZG9ubHkgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgZi53cm9ubHkgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZi5hcHBlbmQgPSAxO1xuICAgICAgICBmLndyaXRlb25seSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmLmNyZWF0ZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBmLnRydW5jYXRlID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIGYuZXhjbCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICBmLmJpbmFyeSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3OlxuICAgICAgICBmLnRleHQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgODpcbiAgICAgICAgZi5ub25ibG9jayA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmbGFncyA9IGZsYWdzWzJdO1xuICB9XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsIGYsIHBlcm1zKTtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSwgdW5kZWZpbmVkKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBpc19ub2RlID0gZnNfbm9kZV9zdXBwb3J0ZWQoKTtcbiAgZnVuY3Rpb24gZmlsZShmZCwgZmxhZ3MpIHtcbiAgICBpZiAoaXNfbm9kZSkge1xuICAgICAgcmV0dXJuIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKTtcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBNbEZha2VGZF9vdXQoZmQsIGZsYWdzKTtcbiAgfVxuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKFxuICAgIGZpbGUoMCwgeyByZG9ubHk6IDEsIGFsdG5hbWU6IFwiL2Rldi9zdGRpblwiLCBpc0NoYXJhY3RlckRldmljZTogdHJ1ZSB9KSxcbiAgICAwLFxuICApO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKFxuICAgIGZpbGUoMSwgeyBidWZmZXJlZDogaXNfbm9kZSA/IDEgOiAyLCB3cm9ubHk6IDEsIGlzQ2hhcmFjdGVyRGV2aWNlOiB0cnVlIH0pLFxuICAgIDEsXG4gICk7XG4gIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoXG4gICAgZmlsZSgyLCB7IGJ1ZmZlcmVkOiBpc19ub2RlID8gMSA6IDIsIHdyb25seTogMSwgaXNDaGFyYWN0ZXJEZXZpY2U6IHRydWUgfSksXG4gICAgMixcbiAgKTtcbn0pKCk7XG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKGNoYW5pZCwgbmFtZSkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IE1sQ2hhbmlkXG5jbGFzcyBjYW1sX21sX2NoYW5uZWxzX3N0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgZ2xvYmFsVGhpcy5XZWFrTWFwKCk7XG4gICAgdGhpcy5vcGVuZWQgPSBuZXcgZ2xvYmFsVGhpcy5TZXQoKTtcbiAgfVxuXG4gIGNsb3NlKGNoYW5pZCkge1xuICAgIHRoaXMub3BlbmVkLmRlbGV0ZShjaGFuaWQpO1xuICB9XG5cbiAgZ2V0KGNoYW5pZCkge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoY2hhbmlkKTtcbiAgfVxuXG4gIHNldChjaGFuaWQsIHZhbCkge1xuICAgIGlmICh2YWwub3BlbmVkKSB0aGlzLm9wZW5lZC5hZGQoY2hhbmlkKTtcbiAgICByZXR1cm4gdGhpcy5tYXAuc2V0KGNoYW5pZCwgdmFsKTtcbiAgfVxuXG4gIGFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVuZWQudmFsdWVzKCk7XG4gIH1cbn1cblxudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgY2FtbF9tbF9jaGFubmVsc19zdGF0ZSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfZ2V0KGlkKSB7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzLmdldChpZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9yZWRpcmVjdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3JlZGlyZWN0KGNhcHR1cmVkLCBpbnRvKSB7XG4gIHZhciB0b19yZXN0b3JlID0gY2FtbF9tbF9jaGFubmVsX2dldChjYXB0dXJlZCk7XG4gIHZhciBuZXdfID0gY2FtbF9tbF9jaGFubmVsX2dldChpbnRvKTtcbiAgY2FtbF9tbF9jaGFubmVscy5zZXQoY2FwdHVyZWQsIG5ld18pO1xuICByZXR1cm4gdG9fcmVzdG9yZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9yZXN0b3JlKGNhcHR1cmVkLCB0b19yZXN0b3JlKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHMuc2V0KGNhcHR1cmVkLCB0b19yZXN0b3JlKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QoKSB7XG4gIHZhciBsID0gMDtcbiAgdmFyIGtleXMgPSBjYW1sX21sX2NoYW5uZWxzLmFsbCgpO1xuICBmb3IgKHZhciBrIG9mIGtleXMpIHtcbiAgICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoayk7XG4gICAgaWYgKGNoYW4ub3BlbmVkICYmIGNoYW4ub3V0KSBsID0gWzAsIGssIGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfaW9fYnVmZmVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dChmZCkge1xuICB2YXIgZmRfZGVzYyA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmIChmZF9kZXNjID09PSB1bmRlZmluZWQpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIiArIGZkICsgXCIgZG9lc24ndCBleGlzdFwiKTtcbiAgdmFyIGZpbGUgPSBmZF9kZXNjLmZpbGU7XG4gIHZhciBjaGFuaWQgPSBmZF9kZXNjLmNoYW5pZDtcbiAgdmFyIGJ1ZmZlcmVkID0gZmlsZS5mbGFncy5idWZmZXJlZCAhPT0gdW5kZWZpbmVkID8gZmlsZS5mbGFncy5idWZmZXJlZCA6IDE7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6IGZpbGUsXG4gICAgb2Zmc2V0OiBmaWxlLm9mZnNldCxcbiAgICBmZDogZmQsXG4gICAgb3BlbmVkOiB0cnVlLFxuICAgIG91dDogdHJ1ZSxcbiAgICBidWZmZXJfY3VycjogMCxcbiAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGNhbWxfaW9fYnVmZmVyX3NpemUpLFxuICAgIGJ1ZmZlcmVkOiBidWZmZXJlZCxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVscy5zZXQoY2hhbmlkLCBjaGFubmVsKTtcbiAgcmV0dXJuIGNoYW5pZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfaW9fYnVmZmVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luKGZkKSB7XG4gIHZhciBmZF9kZXNjID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYgKGZkX2Rlc2MgPT09IHVuZGVmaW5lZClcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiICsgZmQgKyBcIiBkb2Vzbid0IGV4aXN0XCIpO1xuICB2YXIgZmlsZSA9IGZkX2Rlc2MuZmlsZTtcbiAgdmFyIGNoYW5pZCA9IGZkX2Rlc2MuY2hhbmlkO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTogZmlsZSxcbiAgICBvZmZzZXQ6IGZpbGUub2Zmc2V0LFxuICAgIGZkOiBmZCxcbiAgICBvcGVuZWQ6IHRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICBidWZmZXJfY3VycjogMCxcbiAgICBidWZmZXJfbWF4OiAwLFxuICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoY2FtbF9pb19idWZmZXJfc2l6ZSksXG4gICAgcmVmaWxsOiByZWZpbGwsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHMuc2V0KGNoYW5pZCwgY2hhbm5lbCk7XG4gIHJldHVybiBjaGFuaWQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1ZlcnNpb246ID49IDUuMVxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5fd2l0aF9mbGFncyhmZCwgX2ZsYWdzKSB7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRfd2l0aF9mbGFncyhmZCwgX2ZsYWdzKSB7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQoZmQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuLy9BbGlhczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLCBtb2RlKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBjaGFuLmZpbGUuZmxhZ3MudGV4dCA9ICFtb2RlO1xuICBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5ID0gbW9kZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaXNfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX21sX2lzX2JpbmFyeV9tb2RlKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5mbGFncy5iaW5hcnk7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsX2dldFxuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9wZW5lZCkge1xuICAgIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gICAgY2FtbF9tbF9jaGFubmVscy5jbG9zZShjaGFuaWQpO1xuICAgIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpO1xuICAgIGNoYW4uZmQgPSAtMTtcbiAgICBjaGFuLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCkgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGgoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsIGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGNoYW4ub3V0cHV0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICBmKHMpO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCwgZikge1xuICBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCkucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yZWZpbGwoY2hhbikge1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkge1xuICAgIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICAgIHZhciBzdHJfYSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHN0cik7XG4gICAgaWYgKHN0cl9hLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2hhbi5yZWZpbGwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhbi5idWZmZXIubGVuZ3RoIDwgY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKSB7XG4gICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKTtcbiAgICAgICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgICAgICBjaGFuLmJ1ZmZlciA9IGI7XG4gICAgICB9XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoc3RyX2EsIGNoYW4uYnVmZmVyX21heCk7XG4gICAgICBjaGFuLm9mZnNldCArPSBzdHJfYS5sZW5ndGg7XG4gICAgICBjaGFuLmJ1ZmZlcl9tYXggKz0gc3RyX2EubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoY2hhbi5mZCA9PT0gLTEpIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQmFkIGZpbGUgZGVzY3JpcHRvclwiKTtcbiAgICB9XG4gICAgdmFyIG5yZWFkID0gY2hhbi5maWxlLnJlYWQoXG4gICAgICBjaGFuLmJ1ZmZlcixcbiAgICAgIGNoYW4uYnVmZmVyX21heCxcbiAgICAgIGNoYW4uYnVmZmVyLmxlbmd0aCAtIGNoYW4uYnVmZmVyX21heCxcbiAgICApO1xuICAgIGNoYW4ub2Zmc2V0ICs9IG5yZWFkO1xuICAgIGNoYW4uYnVmZmVyX21heCArPSBucmVhZDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0KGNoYW5pZCwgYiwgaSwgbCkge1xuICB2YXIgYmEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGIpO1xuICByZXR1cm4gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsIGJhLCBpLCBsKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheVxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfYmlnYXJyYXkoY2hhbmlkLCBiLCBpLCBsKSB7XG4gIHZhciBiYSA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYik7XG4gIHJldHVybiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3JlZmlsbCwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsIGJhLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgbiA9IGw7XG4gIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gIGlmIChsIDw9IGF2YWlsKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsIGNoYW4uYnVmZmVyX2N1cnIgKyBsKSwgaSk7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBsO1xuICB9IGVsc2UgaWYgKGF2YWlsID4gMCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLCBjaGFuLmJ1ZmZlcl9jdXJyICsgYXZhaWwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGF2YWlsO1xuICAgIG4gPSBhdmFpbDtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgaWYgKG4gPiBhdmFpbCkgbiA9IGF2YWlsO1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLCBjaGFuLmJ1ZmZlcl9jdXJyICsgbiksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbjtcbiAgfVxuICByZXR1cm4gbiB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICB2YXIgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKTtcbiAgZnVuY3Rpb24gYmxvY2soYnVmZmVyLCBvZmZzZXQsIG4pIHtcbiAgICB2YXIgciA9IDA7XG4gICAgd2hpbGUgKHIgPCBuKSB7XG4gICAgICBpZiAoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KSBicmVhaztcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyByXSA9IGNoYW4uYnVmZmVyW2NoYW4uYnVmZmVyX2N1cnJdO1xuICAgICAgY2hhbi5idWZmZXJfY3VycisrO1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB2YXIgciA9IGJsb2NrKGhlYWRlciwgMCwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKTtcbiAgaWYgKHIgPT09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgZWxzZSBpZiAociA8IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3RcIik7XG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplKGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoaGVhZGVyKSwgMCk7XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4gKyBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBidWYuc2V0KGhlYWRlciwgMCk7XG4gIHZhciByID0gYmxvY2soYnVmLCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUsIGxlbik7XG4gIGlmIChyIDwgbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3QgXCIgKyByICsgXCIgIFwiICsgbGVuKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGJ1ZiksIDApO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcFxuLy9SZXF1aXJlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcChjKSB7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlKGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfcmVmaWxsXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZiAoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICB9XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5idWZmZXJbY2hhbi5idWZmZXJfY3Vycl07XG4gIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQoY2hhbmlkKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHJlcyA9ICgocmVzIDw8IDgpICsgY2FtbF9tbF9pbnB1dF9jaGFyKGNoYW5pZCkpIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsX2dldChjaGFuaWQpO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmIChcbiAgICBwb3MgPj0gY2hhbi5vZmZzZXQgLSBjaGFuLmJ1ZmZlcl9tYXggJiZcbiAgICBwb3MgPD0gY2hhbi5vZmZzZXQgJiZcbiAgICBjaGFuLmZpbGUuZmxhZ3MuYmluYXJ5XG4gICkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uZmlsZS5zZWVrKHBvcywgMCk7XG4gICAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQsIHBvcykge1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3NlZWtfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQsIHBvcykge1xuICB2YXIgcG9zID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXRcbmZ1bmN0aW9uIGNhbWxfcG9zX2luKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgcmV0dXJuIGNoYW4ub2Zmc2V0IC0gKGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19pblxuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfcG9zX2luKGNoYW5pZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9yZWZpbGxcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBkbyB7XG4gICAgaWYgKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZiAoY2hhbi5idWZmZXJfY3VyciA+IDApIHtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIpLCAwKTtcbiAgICAgICAgcCAtPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLWNoYW4uYnVmZmVyX21heCB8IDA7XG4gICAgICB9XG4gICAgICB2YXIgcHJldl9tYXggPSBjaGFuLmJ1ZmZlcl9tYXg7XG4gICAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICAgIGlmIChwcmV2X21heCA9PT0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICAgIHJldHVybiAtY2hhbi5idWZmZXJfbWF4IHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT09IDEwKTtcbiAgcmV0dXJuIChwIC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmICghY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmICghY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXJfY3VyciA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChjaGFuLm91dHB1dCkge1xuICAgIGNoYW4ub3V0cHV0KFxuICAgICAgY2FtbF9zdWJfdWludDhfYXJyYXlfdG9fanNieXRlcyhjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3VyciksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBjaGFuLmJ1ZmZlcl9jdXJyOyApIHtcbiAgICAgIHBvcyArPSBjaGFuLmZpbGUud3JpdGUoY2hhbi5idWZmZXIsIHBvcywgY2hhbi5idWZmZXJfY3VyciAtIHBvcyk7XG4gICAgfVxuICB9XG4gIGNoYW4ub2Zmc2V0ICs9IGNoYW4uYnVmZmVyX2N1cnI7XG4gIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfdGFcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxfZ2V0XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIGlmICghY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBpZiAoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGggPiBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgY2hhbi5idWZmZXIgPSBiO1xuICB9XG4gIHN3aXRjaCAoY2hhbi5idWZmZXJlZCkge1xuICAgIGNhc2UgMDogLy8gVW5idWZmZXJlZFxuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6IC8vIEJ1ZmZlcmVkICh0aGUgZGVmYXVsdClcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKSBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6IC8vIEJ1ZmZlcmVkIChvbmx5IGZvciBzdGRvdXQgYW5kIHN0ZGVycilcbiAgICAgIHZhciBpZCA9IGJ1ZmZlci5sYXN0SW5kZXhPZigxMCk7XG4gICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aCkgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBpZCArIDE7XG4gICAgICAgIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoIC0gaWQgLSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLCBidWZmZXIsIG9mZnNldCwgbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF9tbF9vdXRwdXRfdGFcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9iaWdhcnJheShjaGFuaWQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW4pIHtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCwgYnVmZmVyLCBvZmZzZXQsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCwgYnVmZmVyLCBvZmZzZXQsIGxlbikge1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoXG4gICAgY2hhbmlkLFxuICAgIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksXG4gICAgb2Zmc2V0LFxuICAgIGxlbixcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIoY2hhbmlkLCBjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLCBzLCAwLCAxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUoY2hhbmlkLCB2LCBmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKTtcbiAgY2hhbi5maWxlLnNlZWsocG9zLCAwKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3NlZWtfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKSB7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLCBwb3MpIHtcbiAgdmFyIHBvcyA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbF9nZXQsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfcG9zX291dChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxfZ2V0KGNoYW5pZCk7XG4gIHJldHVybiBjaGFuLm9mZnNldCArIGNoYW4uYnVmZmVyX2N1cnI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50KGNoYW5pZCwgaSkge1xuICB2YXIgYXJyID0gWyhpID4+IDI0KSAmIDB4ZmYsIChpID4+IDE2KSAmIDB4ZmYsIChpID4+IDgpICYgMHhmZiwgaSAmIDB4ZmZdO1xuICBjYW1sX21sX291dHB1dF90YShjaGFuaWQsIG5ldyBVaW50OEFycmF5KGFyciksIDAsIDQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA/IDEgOiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldCwgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYnVmZmVyZWQoY2hhbmlkLCB2KSB7XG4gIGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbmlkKS5idWZmZXJlZCA9IHY7XG4gIGlmICghdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5KCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF90aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZSgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FtbF91bml4X2dldHRpbWVvZmRheSgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3RpbWVzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3RpbWVzXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZXMoKSB7XG4gIGlmIChnbG9iYWxUaGlzLnByb2Nlc3M/LmNwdVVzYWdlKSB7XG4gICAgdmFyIHQgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3B1VXNhZ2UoKTtcbiAgICByZXR1cm4gQkxPQ0soMCwgdC51c2VyIC8gMWU2LCB0LnN5c3RlbSAvIDFlNiwgMCwgMCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZT8ubm93KSB7XG4gICAgcmV0dXJuIEJMT0NLKDAsIGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwLCAwLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3RpbWVzOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dtdGltZVxuLy9BbGlhczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9nbXRpbWUodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSBuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIGQuZ2V0VVRDTWludXRlcygpLFxuICAgIGQuZ2V0VVRDSG91cnMoKSxcbiAgICBkLmdldFVUQ0RhdGUoKSxcbiAgICBkLmdldFVUQ01vbnRoKCksXG4gICAgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICBkLmdldFVUQ0RheSgpLFxuICAgIGRveSxcbiAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8sXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbG9jYWx0aW1lKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgamFuLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAganVsLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICk7XG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGQuZ2V0U2Vjb25kcygpLFxuICAgIGQuZ2V0TWludXRlcygpLFxuICAgIGQuZ2V0SG91cnMoKSxcbiAgICBkLmdldERhdGUoKSxcbiAgICBkLmdldE1vbnRoKCksXG4gICAgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICBkLmdldERheSgpLFxuICAgIGRveSxcbiAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHxcbiAgICAgIDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8sXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbWt0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWt0aW1lKHRtKSB7XG4gIHZhciBkID0gbmV3IERhdGUodG1bNl0gKyAxOTAwLCB0bVs1XSwgdG1bNF0sIHRtWzNdLCB0bVsyXSwgdG1bMV0pLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IGNhbWxfdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLCB0LCB0bTIpO1xufVxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXJ0dXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9zdGFydHVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbGVhbnVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fY2xlYW51cFxuZnVuY3Rpb24gY2FtbF91bml4X2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIGNvbnN0XG4vL0FsaWFzOiB3aW5faGFuZGxlX2ZkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkLCBjYW1sX3VuaXhfbG9va3VwX2ZpbGVcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZkKSB7XG4gIGlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoXCJub2RlOnR0eVwiKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQpLmZkKSA/IDEgOiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KF9maWxlRGVzY3JpcHRvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF9lcnJvclxudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLFxuICBcIkVBQ0NFU1wiLFxuICBcIkVBR0FJTlwiLFxuICBcIkVCQURGXCIsXG4gIFwiRUJVU1lcIixcbiAgXCJFQ0hJTERcIixcbiAgXCJFREVBRExLXCIsXG4gIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLFxuICBcIkVGQVVMVFwiLFxuICBcIkVGQklHXCIsXG4gIFwiRUlOVFJcIixcbiAgXCJFSU5WQUxcIixcbiAgXCJFSU9cIixcbiAgXCJFSVNESVJcIixcbiAgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIixcbiAgXCJFTkFNRVRPT0xPTkdcIixcbiAgXCJFTkZJTEVcIixcbiAgXCJFTk9ERVZcIixcbiAgXCJFTk9FTlRcIixcbiAgXCJFTk9FWEVDXCIsXG4gIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsXG4gIFwiRU5PU1BDXCIsXG4gIFwiRU5PU1lTXCIsXG4gIFwiRU5PVERJUlwiLFxuICBcIkVOT1RFTVBUWVwiLFxuICBcIkVOT1RUWVwiLFxuICBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIixcbiAgXCJFUElQRVwiLFxuICBcIkVSQU5HRVwiLFxuICBcIkVST0ZTXCIsXG4gIFwiRVNQSVBFXCIsXG4gIFwiRVNSQ0hcIixcbiAgXCJFWERFVlwiLFxuICBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIixcbiAgXCJFQUxSRUFEWVwiLFxuICBcIkVOT1RTT0NLXCIsXG4gIFwiRURFU1RBRERSUkVRXCIsXG4gIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsXG4gIFwiRU5PUFJPVE9PUFRcIixcbiAgXCJFUFJPVE9OT1NVUFBPUlRcIixcbiAgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsXG4gIFwiRVBGTk9TVVBQT1JUXCIsXG4gIFwiRUFGTk9TVVBQT1JUXCIsXG4gIFwiRUFERFJJTlVTRVwiLFxuICBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLFxuICBcIkVORVRVTlJFQUNIXCIsXG4gIFwiRU5FVFJFU0VUXCIsXG4gIFwiRUNPTk5BQk9SVEVEXCIsXG4gIFwiRUNPTk5SRVNFVFwiLFxuICBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsXG4gIFwiRU5PVENPTk5cIixcbiAgXCJFU0hVVERPV05cIixcbiAgXCJFVE9PTUFOWVJFRlNcIixcbiAgXCJFVElNRURPVVRcIixcbiAgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIixcbiAgXCJFSE9TVFVOUkVBQ0hcIixcbiAgXCJFTE9PUFwiLFxuICBcIkVPVkVSRkxPV1wiLFxuXTtcblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiB1bml4X2Vycm9yLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5O1xuICAgIH1cbiAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSB2YXJpYW50cywgZmFsbGJhY2sgdG8gRVVOS05PV05FUlIoaW50KVxuICAgIC8vIGVycm5vIGlzIGV4cGVjdGVkIHRvIGJlIHBvc2l0aXZlXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIC1lcnJubyk7XG4gIH1cbiAgdmFyIGFyZ3MgPSBbXG4gICAgdmFyaWFudCxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzeXNjYWxsIHx8IFwiXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGggfHwgXCJcIiksXG4gIF07XG4gIHJldHVybiBhcmdzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmVycm9yXG4vL1JlcXVpcmVzOiB1bml4X2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmVycm9yKGVycm5vKSB7XG4gIGNvbnN0IHV0aWwgPSByZXF1aXJlKFwibm9kZTp1dGlsXCIpO1xuICBpZiAoZXJybm8gPj0gMCkge1xuICAgIGNvbnN0IGNvZGUgPSB1bml4X2Vycm9yW2Vycm5vXTtcbiAgICByZXR1cm4gdXRpbFxuICAgICAgLmdldFN5c3RlbUVycm9yTWFwKClcbiAgICAgIC5lbnRyaWVzKClcbiAgICAgIC5maW5kKCh4KSA9PiB4WzFdWzBdID09PSBjb2RlKVsxXVsxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXRpbC5nZXRTeXN0ZW1FcnJvck1lc3NhZ2UoZXJybm8pO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZXJyb3JfbWVzc2FnZVxuLy9BbGlhczogY2FtbF91bml4X2Vycm9yX21lc3NhZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyZXJyb3IsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiB1bml4X2Vycm9yX21lc3NhZ2UoZXJyKSB7XG4gIGNvbnN0IGVycm5vID0gdHlwZW9mIGVyciA9PT0gXCJudW1iZXJcIiA/IGVyciA6IC1lcnJbMV07XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjYW1sX3N0cmVycm9yKGVycm5vKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jaGRpclxuLy9SZXF1aXJlczogY2FtbF9zeXNfY2hkaXJcbi8vQWxpYXM6IHVuaXhfY2hkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9jaGRpcihkaXIpIHtcbiAgcmV0dXJuIGNhbWxfc3lzX2NoZGlyKGRpciwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQoXG4gICAgcm9vdC5yZXN0LFxuICAgIC8qIGxhcmdlICovIGZhbHNlLFxuICAgIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRfNjRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zdGF0XzY0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQoXG4gICAgcm9vdC5yZXN0LFxuICAgIC8qIGxhcmdlICovIHRydWUsXG4gICAgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X2xzdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmxzdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9sc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChcbiAgICByb290LnJlc3QsXG4gICAgLyogbGFyZ2UgKi8gZmFsc2UsXG4gICAgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRfNjRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X2xzdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXRfNjQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmxzdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9sc3RhdF82NDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChcbiAgICByb290LnJlc3QsXG4gICAgLyogbGFyZ2UgKi8gdHJ1ZSxcbiAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUsXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jaG1vZFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfY2htb2RcbmZ1bmN0aW9uIGNhbWxfdW5peF9jaG1vZChuYW1lLCBwZXJtcykge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmNobW9kKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9jaG1vZDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5jaG1vZChyb290LnJlc3QsIHBlcm1zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG4vL0FsaWFzOiB1bml4X3JlbmFtZVxuZnVuY3Rpb24gY2FtbF91bml4X3JlbmFtZShvLCBuKSB7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZiAob19yb290LmRldmljZSAhPT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcigvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIFwiRVhERVZcIiwgXCJyZW5hbWVcIik7XG4gIGlmICghb19yb290LmRldmljZS5yZW5hbWUpIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbWtkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X21rZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCwgcGVybSwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ybWRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcm1kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG4vL0FsaWFzOiB1bml4X2xpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9saW5rKGZvbGxvdywgc3JjLCBkc3QpIHtcbiAgdmFyIHNyY19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uoc3JjKTtcbiAgdmFyIGRzdF9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZHN0KTtcbiAgaWYgKCFzcmNfcm9vdC5kZXZpY2UubGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8vIFdlIGNhbid0IGNvbnRyb2wgd2hldGhlciBhICdzcmMnIHN5bWxpbmsgaXMgZm9sbG93ZWQgb3Igbm90LlxuICAvLyBTbyB3ZSBmYWlsIHdoZW4gJ2ZvbGxvdycgaXMgc2V0LCBhcyBkb2N1bWVudGVkIGluIHRoZSBVbml4IG1vZHVsZS5cbiAgaWYgKHR5cGVvZiBmb2xsb3cgIT09IFwibnVtYmVyXCIpXG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoLyogcmFpc2UgVW5peF9lcnJvciAqLyAxLCBcIkVOT1NZU1wiLCBcImxpbmtcIik7XG4gIGlmIChzcmNfcm9vdC5kZXZpY2UgIT09IGRzdF9yb290LmRldmljZSlcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcigvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIFwiRVhERVZcIiwgXCJsaW5rXCIpO1xuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLmxpbmsoXG4gICAgc3JjX3Jvb3QucmVzdCxcbiAgICBkc3Rfcm9vdC5yZXN0LFxuICAgIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N5bWxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9BbGlhczogdW5peF9zeW1saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3ltbGluayh0b19kaXIsIHNyYywgZHN0KSB7XG4gIHZhciBkc3Rfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRzdCk7XG4gIGlmICghZHN0X3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gZHN0X3Jvb3QuZGV2aWNlLnN5bWxpbmsoXG4gICAgdG9fZGlyLFxuICAgIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHNyYyksXG4gICAgZHN0X3Jvb3QucmVzdCxcbiAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUsXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZWFkbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfcmVhZGxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkbGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVhZGxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3JlYWRsaW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJlYWRsaW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3VubGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfdW5saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfdW5saW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS51bmxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3VubGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdXRpbWVzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF91dGltZXNcbmZ1bmN0aW9uIGNhbWxfdW5peF91dGltZXMobmFtZSwgYXRpbWUsIG10aW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudXRpbWVzKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF91dGltZXM6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByb290LmRldmljZS51dGltZXMocm9vdC5yZXN0LCBhdGltZSwgbXRpbWUsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdHJ1bmNhdGVcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3RydW5jYXRlXG5mdW5jdGlvbiBjYW1sX3VuaXhfdHJ1bmNhdGUobmFtZSwgbGVuKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudHJ1bmNhdGUpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3RydW5jYXRlOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcm9vdC5kZXZpY2UudHJ1bmNhdGUocm9vdC5yZXN0LCBsZW4sIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdHJ1bmNhdGVfNjRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2ludDY0X3RvX2Zsb2F0XG4vL0FsaWFzOiB1bml4X3RydW5jYXRlXzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfdHJ1bmNhdGVfNjQobmFtZSwgbGVuKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudHJ1bmNhdGUpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3RydW5jYXRlXzY0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcm9vdC5kZXZpY2UudHJ1bmNhdGUoXG4gICAgcm9vdC5yZXN0LFxuICAgIGNhbWxfaW50NjRfdG9fZmxvYXQobGVuKSxcbiAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUsXG4gICk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfYWNjZXNzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9hY2Nlc3NcbmZ1bmN0aW9uIGNhbWxfdW5peF9hY2Nlc3MobmFtZSwgZmxhZ3MpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUgKGZsYWdzKSB7XG4gICAgc3dpdGNoIChmbGFnc1sxXSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmLnIgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgZi53ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGYueCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmLmYgPSAxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZmxhZ3MgPSBmbGFnc1syXTtcbiAgfVxuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmFjY2Vzcykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfYWNjZXNzOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcm9vdC5kZXZpY2UuYWNjZXNzKHJvb3QucmVzdCwgZiwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vcGVuXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9zeXNfZmRzLCBNbENoYW5pZFxuLy9BbGlhczogdW5peF9vcGVuXG5mdW5jdGlvbiBjYW1sX3VuaXhfb3BlbihuYW1lLCBmbGFncywgcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUgKGZsYWdzKSB7XG4gICAgc3dpdGNoIChmbGFnc1sxXSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmLnJkb25seSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBmLndyb25seSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBmLnJkd3IgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZi5ub25ibG9jayA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBmLmFwcGVuZCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBmLmNyZWF0ZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICBmLnRydW5jYXRlID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIGYuZXhjbCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgICBmLm5vY3R0eSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OlxuICAgICAgICBmLmRzeW5jID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBmLnN5bmMgPSAxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZmxhZ3MgPSBmbGFnc1syXTtcbiAgfVxuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LCBmLCBwZXJtcywgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbiAgdmFyIGlkeCA9IGNhbWxfc3lzX2Zkcy5sZW5ndGg7XG4gIHZhciBjaGFuaWQgPSBuZXcgTWxDaGFuaWQoaWR4KTtcbiAgY2FtbF9zeXNfZmRzW2lkeF0gPSB7IGZpbGU6IGZpbGUsIGNoYW5pZDogY2hhbmlkIH07XG4gIHJldHVybiBpZHggfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2ZkcywgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmZ1bmN0aW9uIGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgY21kKSB7XG4gIHZhciBmZF9kZXNjID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYgKGZkX2Rlc2MgPT09IHVuZGVmaW5lZClcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcigvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIFwiRUJBREZcIiwgY21kKTtcbiAgcmV0dXJuIGZkX2Rlc2MuZmlsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZzdGF0XG4vL0FsaWFzOiB1bml4X2ZzdGF0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfdW5peF9mc3RhdChmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJmc3RhdFwiKTtcbiAgaWYgKCFmaWxlLnN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2ZzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGZpbGUuc3RhdCgvKiBsYXJnZSAqLyBmYWxzZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9mc3RhdF82NFxuLy9BbGlhczogdW5peF9mc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3VuaXhfZnN0YXRfNjQoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQsIFwiZnN0YXRcIik7XG4gIGlmICghZmlsZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9mc3RhdDY0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGZpbGUuc3RhdCgvKiBsYXJnZSAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZjaG1vZFxuLy9BbGlhczogdW5peF9mY2htb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF91bml4X2ZjaG1vZChmZCwgcGVybXMpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQsIFwiZmNobW9kXCIpO1xuICBpZiAoIWZpbGUuY2htb2QpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2ZjaG1vZDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiBmaWxlLmNobW9kKHBlcm1zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZzeW5jXG4vL0FsaWFzOiB1bml4X2ZzeW5jXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfdW5peF9mc3luYyhmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJmc3luY1wiKTtcbiAgaWYgKCFmaWxlLnN5bmMpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2ZzeW5jOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGZpbGUuc3luYygpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfd3JpdGVcbi8vQWxpYXM6IHVuaXhfd3JpdGVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF91bml4X3dyaXRlKGZkLCBidWYsIHBvcywgbGVuKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIndyaXRlXCIpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgdmFyIHdyaXR0ZW4gPSAwO1xuICB3aGlsZSAobGVuID4gMCkge1xuICAgIHZhciBuID0gZmlsZS53cml0ZShhLCBwb3MsIGxlbiwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbiAgICB3cml0dGVuICs9IG47XG4gICAgcG9zICs9IG47XG4gICAgbGVuIC09IG47XG4gIH1cbiAgcmV0dXJuIHdyaXR0ZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zaW5nbGVfd3JpdGVcbi8vQWxpYXM6IHVuaXhfc2luZ2xlX3dyaXRlXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfdW5peF9zaW5nbGVfd3JpdGUoZmQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQsIFwid3JpdGVcIik7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gZmlsZS53cml0ZShcbiAgICBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZiksXG4gICAgcG9zLFxuICAgIGxlbixcbiAgICAvKiByYWlzZSB1bml4X2Vycm9yICovIDEsXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF93cml0ZV9iaWdhcnJheVxuLy9BbGlhczogY2FtbF91bml4X2xvb2t1cF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX3VuaXhfbG9va3VwX2ZpbGVcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX3VuaXhfd3JpdGVfYmlnYXJyYXkoZmQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgdmFyIGEgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1Zik7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIndyaXRlXCIpO1xuICB2YXIgd3JpdHRlbiA9IDA7XG4gIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgdmFyIG4gPSBmaWxlLndyaXRlKGEsIHBvcywgbGVuLCAvKiByYWlzZSB1bml4X2Vycm9yICovIDEpO1xuICAgIHdyaXR0ZW4gKz0gbjtcbiAgICBwb3MgKz0gbjtcbiAgICBsZW4gLT0gbjtcbiAgfVxuICByZXR1cm4gd3JpdHRlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRcbi8vQWxpYXM6IHVuaXhfcmVhZFxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZChmZCwgYnVmLCBwb3MsIGxlbikge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJyZWFkXCIpO1xuICByZXR1cm4gZmlsZS5yZWFkKFxuICAgIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmKSxcbiAgICBwb3MsXG4gICAgbGVuLFxuICAgIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSxcbiAgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRfYmlnYXJyYXlcbi8vQWxpYXM6IHVuaXhfcmVhZF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheSwgY2FtbF91bml4X2xvb2t1cF9maWxlXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRfYmlnYXJyYXkoZmQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgdmFyIGEgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1Zik7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcInJlYWRcIik7XG4gIHJldHVybiBmaWxlLnJlYWQoYSwgcG9zLCBsZW4sIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc2Vla1xuLy9BbGlhczogdW5peF9sc2Vla1xuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlXG5mdW5jdGlvbiBjYW1sX3VuaXhfbHNlZWsoZmQsIGxlbiwgd2hlbmNlKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImxzZWVrXCIpO1xuICByZXR1cm4gZmlsZS5zZWVrKGxlbiwgd2hlbmNlLCAvKiByYWlzZSB1bml4X2Vycm9yICovIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHNlZWtfNjRcbi8vQWxpYXM6IHVuaXhfbHNlZWtfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9pbnQ2NF90b19mbG9hdFxuZnVuY3Rpb24gY2FtbF91bml4X2xzZWVrXzY0KGZkLCBsZW4sIHdoZW5jZSkge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJsc2Vla1wiKTtcbiAgcmV0dXJuIGZpbGUuc2VlayhjYW1sX2ludDY0X3RvX2Zsb2F0KGxlbiksIHdoZW5jZSwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2Z0cnVuY2F0ZVxuLy9BbGlhczogdW5peF9mdHJ1bmNhdGVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF91bml4X2Z0cnVuY2F0ZShmZCwgbGVuKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImZ0cnVuY2F0ZVwiKTtcbiAgaWYgKCFmaWxlLnRydW5jYXRlKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9mdHJ1bmNhdGU6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBmaWxlLnRydW5jYXRlKGxlbiwgLyogcmFpc2UgdW5peF9lcnJvciAqLyAxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9mdHJ1bmNhdGVfNjRcbi8vQWxpYXM6IHVuaXhfZnRydW5jYXRlXzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfZmFpbHdpdGgsIGNhbWxfaW50NjRfdG9fZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9mdHJ1bmNhdGVfNjQoZmQsIGxlbikge1xuICB2YXIgZmlsZSA9IGNhbWxfdW5peF9sb29rdXBfZmlsZShmZCwgXCJmdHJ1bmNhdGVcIik7XG4gIGlmICghZmlsZS50cnVuY2F0ZSkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfZnRydW5jYXRlXzY0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZmlsZS50cnVuY2F0ZShjYW1sX2ludDY0X3RvX2Zsb2F0KGxlbiksIC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xvc2Vcbi8vQWxpYXM6IHVuaXhfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb29rdXBfZmlsZVxuZnVuY3Rpb24gY2FtbF91bml4X2Nsb3NlKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcImNsb3NlXCIpO1xuICBmaWxlLmNsb3NlKC8qIHJhaXNlIHVuaXhfZXJyb3IgKi8gMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaW5jaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogdW5peF9pbmNoYW5uZWxfb2ZfZmlsZWRlc2NyXG4vL0FsaWFzOiB3aW5faW5jaGFubmVsX29mX2ZpbGVkZXNjclxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvb2t1cF9maWxlLCBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuZnVuY3Rpb24gY2FtbF91bml4X2luY2hhbm5lbF9vZl9maWxlZGVzY3IoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3VuaXhfbG9va3VwX2ZpbGUoZmQsIFwib3V0X2NoYW5uZWxfb2ZfZGVzY3JcIik7XG4gIGZpbGUuY2hlY2tfc3RyZWFtX3NlbWFudGljcyhcImluX2NoYW5uZWxfb2ZfZGVzY3JcIik7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vdXRjaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogdW5peF9vdXRjaGFubmVsX29mX2ZpbGVkZXNjclxuLy9BbGlhczogd2luX291dGNoYW5uZWxfb2ZfZmlsZWRlc2NyXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9va3VwX2ZpbGUsIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuZnVuY3Rpb24gY2FtbF91bml4X291dGNoYW5uZWxfb2ZfZmlsZWRlc2NyKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF91bml4X2xvb2t1cF9maWxlKGZkLCBcIm91dF9jaGFubmVsX29mX2Rlc2NyXCIpO1xuICBmaWxlLmNoZWNrX3N0cmVhbV9zZW1hbnRpY3MoXCJvdXRfY2hhbm5lbF9vZl9kZXNjclwiKTtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dChmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR1aWRcbi8vQWxpYXM6IHVuaXhfZ2V0dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dWlkKF91bml0KSB7XG4gIGlmIChnbG9iYWxUaGlzLnByb2Nlc3M/LmdldHVpZCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXRldWlkXG4vL0FsaWFzOiB1bml4X2dldGV1aWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXRldWlkKF91bml0KSB7XG4gIGlmIChnbG9iYWxUaGlzLnByb2Nlc3M/LmdldGV1aWQpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldGV1aWQoKTtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldGdpZFxuLy9BbGlhczogdW5peF9nZXRnaWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXRnaWQoX3VuaXQpIHtcbiAgaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8uZ2V0Z2lkKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXRnaWQoKTtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldGVnaWRcbi8vQWxpYXM6IHVuaXhfZ2V0ZWdpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldGVnaWQoX3VuaXQpIHtcbiAgaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8uZ2V0ZWdpZCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0ZWdpZCgpO1xuICB9XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0cHduYW1cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL0FsaWFzOiB1bml4X2dldHB3bmFtXG4vL0FsaWFzOiBjYW1sX3VuaXhfZ2V0cHd1aWRcbi8vQWxpYXM6IHVuaXhfZ2V0cHd1aWRcbi8vQWxpYXM6IGNhbWxfdW5peF9nZXRncm5hbVxuLy9BbGlhczogdW5peF9nZXRncm5hbVxuLy9BbGlhczogY2FtbF91bml4X2dldGdyZ2lkXG4vL0FsaWFzOiB1bml4X2dldGdyZ2lkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0cHduYW0oX3VuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9oYXNfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X2hhc19zeW1saW5rKF91bml0KSB7XG4gIHJldHVybiBmc19ub2RlX3N1cHBvcnRlZCgpID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vcGVuZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9vcGVuZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UocGF0aCk7XG4gIGlmICghcm9vdC5kZXZpY2Uub3BlbmRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfb3BlbmRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHZhciBkaXJfaGFuZGxlID0gcm9vdC5kZXZpY2Uub3BlbmRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiB7IHBvaW50ZXI6IGRpcl9oYW5kbGUsIHBhdGg6IHBhdGggfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvclxuLy9BbGlhczogdW5peF9yZWFkZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKSB7XG4gIHZhciBlbnRyeTtcbiAgdHJ5IHtcbiAgICBlbnRyeSA9IGRpcl9oYW5kbGUucG9pbnRlci5yZWFkU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoLyogcmFpc2UgVW5peF9lcnJvciAqLyAxLCBcIkVCQURGXCIsIFwicmVhZGRpclwiKTtcbiAgfVxuICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGVudHJ5Lm5hbWUpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3Jcbi8vQWxpYXM6IHVuaXhfY2xvc2VkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKSB7XG4gIHRyeSB7XG4gICAgZGlyX2hhbmRsZS5wb2ludGVyLmNsb3NlU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoLyogcmFpc2UgVW5peF9lcnJvciAqLyAxLCBcIkVCQURGXCIsIFwiY2xvc2VkaXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3Jld2luZGRpclxuLy9SZXF1aXJlczogY2FtbF91bml4X2Nsb3NlZGlyLCBjYW1sX3VuaXhfb3BlbmRpclxuLy9BbGlhczogdW5peF9yZXdpbmRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZXdpbmRkaXIoZGlyX2hhbmRsZSkge1xuICBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG4gIHZhciBuZXdfZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKGRpcl9oYW5kbGUucGF0aCk7XG4gIGRpcl9oYW5kbGUucG9pbnRlciA9IG5ld19kaXJfaGFuZGxlLnBvaW50ZXI7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGZpcnN0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9vcGVuZGlyLCBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRmaXJzdFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRmaXJzdChwYXRoKSB7XG4gIC8vIFRoZSBXaW5kb3dzIGNvZGUgYWRkcyB0aGlzIGdsb2IgdG8gdGhlIHBhdGgsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIGl0XG4gIHZhciBwYXRoX2pzID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCk7XG4gIHBhdGhfanMgPSBwYXRoX2pzLnJlcGxhY2UoLyhefFtcXFxcL10pXFwqXFwuXFwqJC8sIFwiXCIpO1xuICBwYXRoID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aF9qcyk7XG4gIC8vICouKiBpcyBub3cgc3RyaXBwZWRcbiAgdmFyIGRpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKTtcbiAgdmFyIGZpcnN0X2VudHJ5ID0gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG4gIC8vIFRoZSBXaW5kb3dzIGJpbmRpbmdzIHR5cGUgZGlyX2hhbmRsZSBhcyBhbiBgaW50YCBidXQgaXQncyBub3QgaW4gSlNcbiAgcmV0dXJuIFswLCBmaXJzdF9lbnRyeSwgZGlyX2hhbmRsZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kbmV4dFxuLy9SZXF1aXJlczogY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kbmV4dFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRuZXh0KGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGNsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vQWxpYXM6IHdpbl9maW5kY2xvc2VcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kY2xvc2UoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyBjb25zdFxuLy9BbGlhczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZygpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncywgbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IocmFpc2VfdW5peCwgY29kZSwgY21kLCBtc2csIHBhdGgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKVxuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhjb2RlLCBjbWQsIHBhdGgpKTtcbiAgZWxzZSB7XG4gICAgdmFyIG1zZyA9IGNvZGUgKyBcIjogXCIgKyBtc2cgKyBcIiwgXCIgKyBjbWQ7XG4gICAgaWYgKHBhdGggIT09IHVuZGVmaW5lZCkgbXNnICs9IFwiICdcIiArIHBhdGggKyBcIidcIjtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihtc2cpO1xuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKSB7XG4gIHJldHVybiBuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIgPyBuYW1lICsgXCIvXCIgOiBuYW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuZWxzZSB2YXIgY2FtbF9jdXJyZW50X2RpciA9IFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCkge1xuICB2YXIgeCA9IHBhdGhfaXNfYWJzb2x1dGUocGF0aCk7XG4gIGlmICgheCkgcmV0dXJuO1xuICByZXR1cm4geFswXSArIFwiL1wiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X3Jvb3QsIGNhbWxfY3VycmVudF9kaXIsIGNhbWxfZmFpbHdpdGhcbnZhciBjYW1sX3Jvb3QgPVxuICBjYW1sX2dldF9yb290KGNhbWxfY3VycmVudF9kaXIpIHx8XG4gIGNhbWxfZmFpbHdpdGgoXCJ1bmFibGUgdG8gY29tcHV0ZSBjYW1sX3Jvb3RcIik7XG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCkge31cblxuLy9Qcm92aWRlczogcGF0aF9pc19hYnNvbHV0ZVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpIHtcbiAgZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHJldHVybiBbXCJcIiwgcGF0aC5zbGljZSgxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPVxuICAgICAgL14oW2EtekEtWl06fFtcXFxcL117Mn1bXlxcXFwvXStbXFxcXC9dK1teXFxcXC9dKyk/KFtcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG4gICAgdmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCBcIlwiO1xuICAgIHZhciBpc1VuYyA9IGRldmljZS5sZW5ndGggPiAwICYmIGRldmljZS5jaGFyQXQoMSkgIT09IFwiOlwiO1xuXG4gICAgLy8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcbiAgICBpZiAocmVzdWx0WzJdIHx8IGlzVW5jKSB7XG4gICAgICB2YXIgcm9vdCA9IHJlc3VsdFsxXSB8fCBcIlwiO1xuICAgICAgdmFyIHNlcCA9IHJlc3VsdFsyXSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIFtyb290LCBwYXRoLnNsaWNlKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKFxuICAgIGZzX25vZGVfc3VwcG9ydGVkKCkgJiZcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MgJiZcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm1cbiAgKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiID8gd2luMzIgOiBwb3NpeDtcbiAgfSBlbHNlIHJldHVybiBwb3NpeDtcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGgobmFtZSkge1xuICBuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmICghcGF0aF9pc19hYnNvbHV0ZShuYW1lKSkgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcDAgPSBwYXRoX2lzX2Fic29sdXRlKG5hbWUpO1xuICB2YXIgY29tcCA9IGNvbXAwWzFdLnNwbGl0KC9bL1xcXFxdLyk7XG4gIHZhciBuY29tcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXAubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGNvbXBbaV0pIHtcbiAgICAgIGNhc2UgXCIuLlwiOlxuICAgICAgICBuY29tcC5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiLlwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuY29tcC5wdXNoKGNvbXBbaV0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbmNvbXAudW5zaGlmdChjb21wMFswXSk7XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW107XG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe1xuICAgIHBhdGg6IGNhbWxfcm9vdCxcbiAgICBkZXZpY2U6IG5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KSxcbiAgfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe1xuICAgIHBhdGg6IGNhbWxfcm9vdCxcbiAgICBkZXZpY2U6IG5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KSxcbiAgfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe1xuICBwYXRoOiBcIi9zdGF0aWMvXCIsXG4gIGRldmljZTogbmV3IE1sRmFrZURldmljZShcIi9zdGF0aWMvXCIpLFxufSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCkge1xuICB2YXIgcHJldiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXTtcbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSkge1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmIChcbiAgICAgIG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT09IDAgJiZcbiAgICAgICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpXG4gICAgKVxuICAgICAgcmVzID0ge1xuICAgICAgICBwYXRoOiBtLnBhdGgsXG4gICAgICAgIGRldmljZTogbS5kZXZpY2UsXG4gICAgICAgIHJlc3Q6IG5hbWUuc2xpY2UobS5wYXRoLmxlbmd0aCwgbmFtZS5sZW5ndGgpLFxuICAgICAgfTtcbiAgfVxuICBpZiAoIXJlcyAmJiBmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHJvb3QgPSBjYW1sX2dldF9yb290KG5hbWUpO1xuICAgIGlmIChyb290Py5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSkge1xuICAgICAgdmFyIG0gPSB7IHBhdGg6IHJvb3QsIGRldmljZTogbmV3IE1sTm9kZURldmljZShyb290KSB9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge1xuICAgICAgICBwYXRoOiBtLnBhdGgsXG4gICAgICAgIGRldmljZTogbS5kZXZpY2UsXG4gICAgICAgIHJlc3Q6IG5hbWUuc2xpY2UobS5wYXRoLmxlbmd0aCwgbmFtZS5sZW5ndGgpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSwgZikge1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7IHBhdGg6IG5hbWUsIGRldmljZTogbmV3IE1sRmFrZURldmljZShuYW1lLCBmKSB9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKSB7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYgKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYgKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsIDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9BbGlhczogY2FtbF91bml4X2dldGN3ZFxuLy9BbGlhczogdW5peF9nZXRjd2RcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpciwgcmFpc2VfdW5peCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmIChyb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KSkge1xuICAgIGlmIChyb290LnJlc3QpXG4gICAgICBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgcmFpc2VfdW5peCxcbiAgICAgIFwiRU5PVERJUlwiLFxuICAgICAgXCJjaGRpclwiLFxuICAgICAgXCJub3QgYSBkaXJlY3RvcnlcIixcbiAgICAgIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGRpciksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhkaXIpLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgcmFpc2VfdW5peCxcbiAgICBcIkVOT0VOVFwiLFxuICAgIFwibm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiLFxuICAgIG5hbWUsXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGxbaSArIDFdID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhID8gMSA6IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLCBuKSB7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZiAob19yb290LmRldmljZSAhPT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmICghb19yb290LmRldmljZS5yZW5hbWUpIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX21rZGlyKG5hbWUsIHBlcm0pIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcm1kaXIobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZShfdmZkLCBfa2luZCwgX2xheW91dCwgX3NoYXJlZCwgX2RpbXMsIF9wb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX3N5c19mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsIF9hcmduKSB7XG4gIC8vIGFyZ24gPT09IDZcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSwgYXJndlsxXSwgYXJndlsyXSwgYXJndlszXSwgYXJndls0XSwgYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLCBjb250ZW50KSB7XG4gIGlmIChnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUpIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYgKCFnbG9iYWxUaGlzLmpzb29fZnNfdG1wKSBnbG9iYWxUaGlzLmpzb29fZnNfdG1wID0gW107XG4gICAgZ2xvYmFsVGhpcy5qc29vX2ZzX3RtcC5wdXNoKHsgbmFtZTogbmFtZSwgY29udGVudDogY29udGVudCB9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBqc29vX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQoKSB7XG4gIHZhciB0bXAgPSBnbG9iYWxUaGlzLmpzb29fZnNfdG1wO1xuICBpZiAodG1wKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGpzb29fY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsIHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlID0ganNvb19jcmVhdGVfZmlsZTtcbiAgZ2xvYmFsVGhpcy5qc29vX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCwgY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KSB7XG4gIHZhciBuYW1lID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobmFtZSk7XG4gIHZhciBjb250ZW50ID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTtcbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudChuYW1lKSB7XG4gIHZhciBuYW1lID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhuYW1lKSA6IG5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmIChyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsIHsgcmRvbmx5OiAxIH0pO1xuICAgIHZhciBsZW4gPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZpbGUucmVhZChidWYsIDAsIGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGJ1Zik7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBNbEZha2VGZCwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvclxuY2xhc3MgTWxGYWtlRGV2aWNlIHtcbiAgY29uc3RydWN0b3Iocm9vdCwgZikge1xuICAgIHRoaXMuY29udGVudCA9IHt9O1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5sb29rdXBGdW4gPSBmO1xuICB9XG5cbiAgbm0obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJvb3QgKyBuYW1lO1xuICB9XG5cbiAgY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSkge1xuICAgIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgdmFyIHJlcyA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgICB0aGlzLmNvbnRlbnRbcmVzXSA9IFN5bWJvbChcImRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cblxuICBzbGFzaChuYW1lKSB7XG4gICAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpID8gbmFtZSA6IG5hbWUgKyBcIi9cIjtcbiAgfVxuXG4gIGxvb2t1cChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihcbiAgICAgICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcodGhpcy5yb290KSxcbiAgICAgICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobmFtZSksXG4gICAgICApO1xuICAgICAgaWYgKHJlcyAhPT0gMCkge1xuICAgICAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgICAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleGlzdHMobmFtZSwgZG9fbm90X2xvb2t1cCkge1xuICAgIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gICAgaWYgKG5hbWUgPT09IFwiXCIpIHJldHVybiAxO1xuICAgIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICAgIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgICBpZiAodGhpcy5jb250ZW50W25hbWVfc2xhc2hdKSByZXR1cm4gMTtcbiAgICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gICAgaWYgKCFkb19ub3RfbG9va3VwKSB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdID8gMSA6IDA7XG4gIH1cblxuICBpc0ZpbGUobmFtZSkge1xuICAgIGlmICh0aGlzLmV4aXN0cyhuYW1lKSAmJiAhdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZW5hbWVfZGlyKG9sZG5hbWUsIG5ld25hbWUpIHtcbiAgICBpZiAodGhpcy5leGlzdHMobmV3bmFtZSkpIHtcbiAgICAgIGlmICghdGhpcy5pc19kaXIobmV3bmFtZSkpIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXG4gICAgICAgICAgdGhpcy5ubShuZXduYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0cyBhbmQgaXMgbm90IGEgZGlyZWN0b3J5XCIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkZGlyKG5ld25hbWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuZXduYW1lKSArIFwiIDogZGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9sZF9zbGFzaCA9IHRoaXMuc2xhc2gob2xkbmFtZSk7XG4gICAgdmFyIG5ld19zbGFzaCA9IHRoaXMuc2xhc2gobmV3bmFtZSk7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuZXdfc2xhc2gpO1xuICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLnJlYWRkaXIob2xkbmFtZSkpIHtcbiAgICAgIHRoaXMucmVuYW1lKG9sZF9zbGFzaCArIGYsIG5ld19zbGFzaCArIGYpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5jb250ZW50W29sZF9zbGFzaF07XG4gIH1cblxuICByZW5hbWUob2xkbmFtZSwgbmV3bmFtZSkge1xuICAgIGlmICghdGhpcy5leGlzdHMob2xkbmFtZSkpXG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG9sZG5hbWUpICsgXCIgOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIGlmICh0aGlzLmlzX2RpcihvbGRuYW1lKSkge1xuICAgICAgdGhpcy5yZW5hbWVfZGlyKG9sZG5hbWUsIG5ld25hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5leGlzdHMobmV3bmFtZSkgJiYgdGhpcy5pc19kaXIobmV3bmFtZSkpIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXG4gICAgICAgICAgdGhpcy5ubShuZXduYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0cyBhbmQgaXMgYSBkaXJlY3RvcnlcIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudFtuZXduYW1lXSA9IHRoaXMuY29udGVudFtvbGRuYW1lXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRbb2xkbmFtZV07XG4gICAgfVxuICB9XG5cbiAgbWtkaXIobmFtZSwgX21vZGUsIHJhaXNlX3VuaXgpIHtcbiAgICBpZiAodGhpcy5leGlzdHMobmFtZSkpXG4gICAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgXCJFRVhJU1RcIixcbiAgICAgICAgXCJta2RpclwiLFxuICAgICAgICBcImZpbGUgYWxyZWFkeSBleGlzdHNcIixcbiAgICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICAgICk7XG4gICAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICAgIHBhcmVudCA9IHBhcmVudD8uWzFdIHx8IFwiXCI7XG4gICAgaWYgKCF0aGlzLmV4aXN0cyhwYXJlbnQpKVxuICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgIFwiRU5PRU5UXCIsXG4gICAgICAgIFwibWtkaXJcIixcbiAgICAgICAgXCJubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIsXG4gICAgICAgIHRoaXMubm0obmFtZSksXG4gICAgICApO1xuICAgIGlmICghdGhpcy5pc19kaXIocGFyZW50KSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVOT1RESVJcIixcbiAgICAgICAgXCJta2RpclwiLFxuICAgICAgICBcIm5vdCBhIGRpcmVjdG9yeVwiLFxuICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgKTtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xuICB9XG5cbiAgcm1kaXIobmFtZSwgcmFpc2VfdW5peCkge1xuICAgIHZhciBuYW1lX3NsYXNoID0gbmFtZSA9PT0gXCJcIiA/IFwiXCIgOiB0aGlzLnNsYXNoKG5hbWUpO1xuICAgIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gICAgaWYgKCF0aGlzLmV4aXN0cyhuYW1lKSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVOT0VOVFwiLFxuICAgICAgICBcInJtZGlyXCIsXG4gICAgICAgIFwibm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiLFxuICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgKTtcbiAgICBpZiAoIXRoaXMuaXNfZGlyKG5hbWUpKVxuICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgIFwiRU5PVERJUlwiLFxuICAgICAgICBcInJtZGlyXCIsXG4gICAgICAgIFwibm90IGEgZGlyZWN0b3J5XCIsXG4gICAgICAgIHRoaXMubm0obmFtZSksXG4gICAgICApO1xuICAgIGZvciAodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgICBpZiAobi5tYXRjaChyKSlcbiAgICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgICBcIkVOT1RFTVBUWVwiLFxuICAgICAgICAgIFwicm1kaXJcIixcbiAgICAgICAgICBcImRpcmVjdG9yeSBub3QgZW1wdHlcIixcbiAgICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgICApO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVfc2xhc2hdO1xuICB9XG5cbiAgcmVhZGRpcihuYW1lKSB7XG4gICAgdmFyIG5hbWVfc2xhc2ggPSBuYW1lID09PSBcIlwiID8gXCJcIiA6IHRoaXMuc2xhc2gobmFtZSk7XG4gICAgaWYgKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gICAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgICB2YXIgc2VlbiA9IHt9O1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICAgIGlmIChtICYmICFzZWVuW21bMV1dKSB7XG4gICAgICAgIHNlZW5bbVsxXV0gPSB0cnVlO1xuICAgICAgICBhLnB1c2gobVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgb3BlbmRpcihuYW1lLCByYWlzZV91bml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLnJlYWRkaXIobmFtZSk7XG4gICAgdmFyIGMgPSBmYWxzZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlYWRTeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgICAgIFwiRUJBREZcIixcbiAgICAgICAgICAgIFwicmVhZGRpclwiLFxuICAgICAgICAgICAgXCJiYWQgZmlsZSBkZXNjcmlwdG9yXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKGkgPT09IGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGVudHJ5ID0gYVtpXTtcbiAgICAgICAgaSsrO1xuICAgICAgICByZXR1cm4geyBuYW1lOiBlbnRyeSB9O1xuICAgICAgfSxcbiAgICAgIGNsb3NlU3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgICAgICBcIkVCQURGXCIsXG4gICAgICAgICAgICBcInJlYWRkaXJcIixcbiAgICAgICAgICAgIFwiYmFkIGZpbGUgZGVzY3JpcHRvclwiLFxuICAgICAgICAgICk7XG4gICAgICAgIGMgPSB0cnVlO1xuICAgICAgICBhID0gW107XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBpc19kaXIobmFtZSkge1xuICAgIGlmIChuYW1lID09PSBcIlwiKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXSA/IDEgOiAwO1xuICB9XG5cbiAgdW5saW5rKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKG5hbWUsIHRydWUpKSB7XG4gICAgICAvLyBbdHJ1ZV0gbWVhbnMgbm8gXCJsb29rdXBcIiBpZiBub3QgZm91bmQuXG4gICAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgXCJFTk9FTlRcIixcbiAgICAgICAgXCJ1bmxpbmtcIixcbiAgICAgICAgXCJubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIsXG4gICAgICAgIG5hbWUsXG4gICAgICApO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgYWNjZXNzKG5hbWUsIF9mbGFncywgcmFpc2VfdW5peCkge1xuICAgIHRoaXMubG9va3VwKG5hbWUpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSlcbiAgICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgICBcIkVBQ0NFU1NcIixcbiAgICAgICAgICBcImFjY2Vzc1wiLFxuICAgICAgICAgIFwicGVybWlzc2lvbiBkZW5pZWQsXCIsXG4gICAgICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUodGhpcy5ubShuYW1lKSwgcmFpc2VfdW5peCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgb3BlbihuYW1lLCBmLCBfcGVybXMsIHJhaXNlX3VuaXgpIHtcbiAgICB2YXIgZmlsZTtcbiAgICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpXG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgICAgXCJFSVNESVJcIixcbiAgICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgICBcImlsbGVnYWwgb3BlcmF0aW9uIG9uIGEgZGlyZWN0b3J5XCIsXG4gICAgICAgICAgdGhpcy5ubShuYW1lKSxcbiAgICAgICAgKTtcbiAgICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpXG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgICAgXCJFRVhJU1RcIixcbiAgICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgICBcImZpbGUgYWxyZWFkeSBleGlzdHNcIixcbiAgICAgICAgICB0aGlzLm5tKG5hbWUpLFxuICAgICAgICApO1xuICAgICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICAgIGlmIChmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gICAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKHRoaXMubm0obmFtZSksIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xuICB9XG5cbiAgdHJ1bmNhdGUobmFtZSwgbGVuLCByYWlzZV91bml4KSB7XG4gICAgdmFyIGZpbGU7XG4gICAgdGhpcy5sb29rdXAobmFtZSk7XG4gICAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKVxuICAgICAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgICAgICByYWlzZV91bml4LFxuICAgICAgICAgIFwiRUlTRElSXCIsXG4gICAgICAgICAgXCJvcGVuXCIsXG4gICAgICAgICAgXCJpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeVwiLFxuICAgICAgICAgIHRoaXMubm0obmFtZSksXG4gICAgICAgICk7XG4gICAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgICAgZmlsZS50cnVuY2F0ZShsZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSh0aGlzLm5tKG5hbWUpLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RlcihuYW1lLCBjb250ZW50KSB7XG4gICAgdmFyIGZpbGU7XG4gICAgaWYgKHRoaXMuY29udGVudFtuYW1lXSlcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgICBpZiAoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpXG4gICAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgICBlbHNlIGlmIChjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhcbiAgICAgICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSxcbiAgICAgICk7XG4gICAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICAgIH1cbiAgICBpZiAoZmlsZSkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXSA9IGZpbGU7XG4gICAgfSBlbHNlXG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihcbiAgICAgICAgdGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIsXG4gICAgICApO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXlcbmNsYXNzIE1sRmFrZUZpbGUgZXh0ZW5kcyBNbEZpbGUge1xuICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBjb250ZW50O1xuICB9XG5cbiAgdHJ1bmNhdGUobGVuKSB7XG4gICAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4gfCAwKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG4gIH1cblxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG4gIH1cblxuICB3cml0ZShvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgaWYgKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICAgIH1cbiAgICBjYW1sX2JsaXRfYnl0ZXMoXG4gICAgICBjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KGJ1ZiksXG4gICAgICBwb3MsXG4gICAgICB0aGlzLmRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICBsZW4sXG4gICAgKTtcbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgcmVhZChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gICAgaWYgKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgICBsZW4gPSBjbGVuIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAobGVuKSB7XG4gICAgICB2YXIgZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbiB8IDApO1xuICAgICAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBkYXRhLCAwLCBsZW4pO1xuICAgICAgYnVmLnNldChjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGRhdGEpLCBwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmNsYXNzIE1sRmFrZUZkX291dCBleHRlbmRzIE1sRmFrZUZpbGUge1xuICBjb25zdHJ1Y3RvcihmZCwgZmxhZ3MpIHtcbiAgICBzdXBlcihjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgdGhpcy5sb2cgPSBmdW5jdGlvbiAoX3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaWYgKGZkID09PSAxICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmxvZyA9IGNvbnNvbGUubG9nO1xuICAgIGVsc2UgaWYgKGZkID09PSAyICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aGlzLmxvZyA9IGNvbnNvbGUuZXJyb3I7XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIpIHRoaXMubG9nID0gY29uc29sZS5sb2c7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdHJ1bmNhdGUoX2xlbiwgcmFpc2VfdW5peCkge1xuICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgcmFpc2VfdW5peCxcbiAgICAgIFwiRUlOVkFMXCIsXG4gICAgICBcImZ0cnVuY2F0ZVwiLFxuICAgICAgXCJpbnZhbGlkIGFyZ3VtZW50XCIsXG4gICAgKTtcbiAgfVxuXG4gIHdyaXRlKGJ1ZiwgcG9zLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGxlbjtcbiAgICBpZiAodGhpcy5sb2cpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGVuID4gMCAmJlxuICAgICAgICBwb3MgPj0gMCAmJlxuICAgICAgICBwb3MgKyBsZW4gPD0gYnVmLmxlbmd0aCAmJlxuICAgICAgICBidWZbcG9zICsgbGVuIC0gMV0gPT09IDEwXG4gICAgICApXG4gICAgICAgIGxlbi0tO1xuICAgICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICAgIHZhciBzcmMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfdWludDhfYXJyYXkoYnVmKSwgcG9zLCBzcmMsIDAsIGxlbik7XG4gICAgICB0aGlzLmxvZyhzcmMudG9VdGYxNigpKTtcbiAgICAgIHJldHVybiB3cml0dGVuO1xuICAgIH1cbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihcbiAgICAgIHJhaXNlX3VuaXgsXG4gICAgICBcIkVCQURGXCIsXG4gICAgICBcIndyaXRlXCIsXG4gICAgICBcImJhZCBmaWxlIGRlc2NyaXB0b3JcIixcbiAgICApO1xuICB9XG5cbiAgcmVhZChfYnVmLCBfcG9zLCBfbGVuLCByYWlzZV91bml4KSB7XG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IocmFpc2VfdW5peCwgXCJFQkFERlwiLCBcInJlYWRcIiwgXCJiYWQgZmlsZSBkZXNjcmlwdG9yXCIpO1xuICB9XG5cbiAgc2VlayhfbGVuLCBfd2hlbmNlLCByYWlzZV91bml4KSB7XG4gICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IocmFpc2VfdW5peCwgXCJFU1BJUEVcIiwgXCJsc2Vla1wiLCBcImlsbGVnYWwgc2Vla1wiKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMubG9nID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY2hlY2tfc3RyZWFtX3NlbWFudGljcyhfY21kKSB7fVxufVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3JcbmNsYXNzIE1sRmFrZUZkIHtcbiAgY29uc3RydWN0b3IobmFtZSwgZmlsZSwgZmxhZ3MpIHtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB0aGlzLnNlZWtlZCA9IGZhbHNlO1xuICB9XG5cbiAgZXJyX2Nsb3NlZChjbWQsIHJhaXNlX3VuaXgpIHtcbiAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihyYWlzZV91bml4LCBcIkVCQURGXCIsIGNtZCwgXCJiYWQgZmlsZSBkZXNjcmlwdG9yXCIpO1xuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLmZpbGUpIHJldHVybiB0aGlzLmZpbGUubGVuZ3RoKCk7XG4gICAgdGhpcy5lcnJfY2xvc2VkKFwibGVuZ3RoXCIpO1xuICB9XG5cbiAgdHJ1bmNhdGUobGVuLCByYWlzZV91bml4KSB7XG4gICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgaWYgKCEodGhpcy5mbGFncy53cm9ubHkgfHwgdGhpcy5mbGFncy5yZHdyKSlcbiAgICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgICAgcmFpc2VfdW5peCxcbiAgICAgICAgICBcIkVJTlZBTFwiLFxuICAgICAgICAgIFwidHJ1bmNhdGVcIixcbiAgICAgICAgICBcImludmFsaWQgYXJndW1lbnRcIixcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbGUudHJ1bmNhdGUobGVuKTtcbiAgICB9XG4gICAgdGhpcy5lcnJfY2xvc2VkKFwidHJ1bmNhdGVcIiwgcmFpc2VfdW5peCk7XG4gIH1cblxuICB3cml0ZShidWYsIHBvcywgbGVuLCByYWlzZV91bml4KSB7XG4gICAgaWYgKHRoaXMuZmlsZSAmJiAodGhpcy5mbGFncy53cm9ubHkgfHwgdGhpcy5mbGFncy5yZHdyKSkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgbGVuID0gdGhpcy5maWxlLndyaXRlKG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gICAgICB0aGlzLm9mZnNldCArPSBsZW47XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICB0aGlzLmVycl9jbG9zZWQoXCJ3cml0ZVwiLCByYWlzZV91bml4KTtcbiAgfVxuXG4gIHJlYWQoYnVmLCBwb3MsIGxlbiwgcmFpc2VfdW5peCkge1xuICAgIGlmICh0aGlzLmZpbGUgJiYgIXRoaXMuZmxhZ3Mud3Jvbmx5KSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICBsZW4gPSB0aGlzLmZpbGUucmVhZChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG4gICAgdGhpcy5lcnJfY2xvc2VkKFwicmVhZFwiLCByYWlzZV91bml4KTtcbiAgfVxuXG4gIHNlZWsob2Zmc2V0LCB3aGVuY2UsIHJhaXNlX3VuaXgpIHtcbiAgICBzd2l0Y2ggKHdoZW5jZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMub2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICByYWlzZV91bml4LFxuICAgICAgICBcIkVJTlZBTFwiLFxuICAgICAgICBcImxzZWVrXCIsXG4gICAgICAgIFwiaW52YWxpZCBhcmd1bWVudFwiLFxuICAgICAgKTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnNlZWtlZCA9IHRydWU7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZSkgdGhpcy5lcnJfY2xvc2VkKFwiY2xvc2VcIik7XG4gICAgdGhpcy5maWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY2hlY2tfc3RyZWFtX3NlbWFudGljcyhjbWQpIHtcbiAgICBpZiAoIXRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZXJyX2Nsb3NlZChjbWQsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gMSk7XG4gIH1cbn1cbiIsIi8vUHJvdmlkZXM6IE1sTXV0ZXhcbmNsYXNzIE1sTXV0ZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbmV3XG4vL1JlcXVpcmVzOiBNbE11dGV4XG5mdW5jdGlvbiBjYW1sX21sX211dGV4X25ldyhfdW5pdCkge1xuICByZXR1cm4gbmV3IE1sTXV0ZXgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF9sb2NrXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X2xvY2sodCkge1xuICBpZiAodC5sb2NrZWQpIGNhbWxfZmFpbHdpdGgoXCJNdXRleC5sb2NrOiBtdXRleCBhbHJlYWR5IGxvY2tlZC4gQ2Fubm90IHdhaXQuXCIpO1xuICBlbHNlIHQubG9ja2VkID0gdHJ1ZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2sodCkge1xuICBpZiAoIXQubG9ja2VkKSB7XG4gICAgdC5sb2NrZWQgPSB0cnVlO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF91bmxvY2sodCkge1xuICB0LmxvY2tlZCA9IGZhbHNlO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wcy5fbmF0ID0ge1xuICAgIGRlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgc2VyaWFsaXplOiBzZXJpYWxpemVfbmF0LFxuICAgIGhhc2g6IGNhbWxfaGFzaF9uYXQsXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5jbGFzcyBNbE5hdCB7XG4gIGNvbnN0cnVjdG9yKHgpIHtcbiAgICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheSh4KTtcbiAgICAvLyBGb3IgbnVtIDwgMS41XG4gICAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAgIC8vIHdvcmsgb3V0IHJpZ2h0LlxuICAgIC8vIFdlIGFkZCArMiB0byB0aGUgYXJyYXkgbGVuZ3RoOlxuICAgIC8vIC0gKzEgZm9yIHRoZSB0YWdcbiAgICAvLyAtICsxIGZvciB0aGUgY3VzdG9tX29wcyBzbG90XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoICsgMjtcbiAgICB0aGlzLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogbGVuZ3RoX25hdFxuZnVuY3Rpb24gbGVuZ3RoX25hdCh4KSB7XG4gIHJldHVybiB4LmRhdGEubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCkge1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMgKyBpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSBuYXQyLmRhdGFbb2ZzMiArIGldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG5hdC5kYXRhW29mcyArIGldICE9PSAwKSByZXR1cm4gaSArIDE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmIChhICYgMHhmZmZmMDAwMCkge1xuICAgIGIgKz0gMTY7XG4gICAgYSA+Pj49IDE2O1xuICB9XG4gIGlmIChhICYgMHhmZjAwKSB7XG4gICAgYiArPSA4O1xuICAgIGEgPj4+PSA4O1xuICB9XG4gIGlmIChhICYgMHhmMCkge1xuICAgIGIgKz0gNDtcbiAgICBhID4+Pj0gNDtcbiAgfVxuICBpZiAoYSAmIDEyKSB7XG4gICAgYiArPSAyO1xuICAgIGEgPj4+PSAyO1xuICB9XG4gIGlmIChhICYgMikge1xuICAgIGIgKz0gMTtcbiAgICBhID4+Pj0gMTtcbiAgfVxuICBpZiAoYSAmIDEpIHtcbiAgICBiICs9IDE7XG4gIH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID09PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X25vcm1hbGl6ZWRcbmZ1bmN0aW9uIGlzX2RpZ2l0X25vcm1hbGl6ZWQoX25hdCwgX29mcykge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcyArIGldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcyArIGldID0geCB8IDA7XG4gICAgaWYgKHggPT09IHggPj4+IDApIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMSArIGldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMiArIGldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxICsgaV0gPSB4O1xuICAgIGlmICh4ID09PSB4ID4+PiAwKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczEgKyBsZW4yLCBsZW4xIC0gbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzICsgaV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcyArIGldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSBjYXJyeV9pbiA9PT0gMSA/IDAgOiAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzICsgaV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcyArIGldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3Jyb3cgPT09IDEgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IGNhcnJ5X2luID09PSAxID8gMCA6IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIgKyBpXSA+Pj4gMCkgLSBib3Jyb3c7XG4gICAgbmF0MS5kYXRhW29mczEgKyBpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczEgKyBsZW4yLCBsZW4xIC0gbGVuMiwgYm9ycm93ID09PSAxID8gMCA6IDEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSBuYXQzLmRhdGFbb2ZzM10gPj4+IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID1cbiAgICAgIChuYXQxLmRhdGFbb2ZzMSArIGldID4+PiAwKSArXG4gICAgICAobmF0Mi5kYXRhW29mczIgKyBpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMGZmZmYpICtcbiAgICAgIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMiArIGldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyIC8gNjU1MzYpO1xuICAgIHZhciB4MyA9IHgxICsgKHgyICUgNjU1MzYpICogNjU1MzY7XG4gICAgbmF0MS5kYXRhW29mczEgKyBpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMgLyA0Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmIChsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KFxuICAgICAgbmF0MSxcbiAgICAgIG9mczEgKyBsZW4yLFxuICAgICAgbGVuMSAtIGxlbjIsXG4gICAgICBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH1cbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1xuLy8gbGVuMSA+PSBsZW4yICsgbGVuMy5cbi8vUHJvdmlkZXM6IG11bHRfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X2RpZ2l0X25hdFxuZnVuY3Rpb24gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMywgbGVuMykge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KFxuICAgICAgbmF0MSxcbiAgICAgIG9mczEgKyBpLFxuICAgICAgbGVuMSAtIGksXG4gICAgICBuYXQyLFxuICAgICAgb2ZzMixcbiAgICAgIGxlbjIsXG4gICAgICBuYXQzLFxuICAgICAgb2ZzMyArIGksXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfbGVmdF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmIChuYml0cyA9PT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMDtcbiAgICBuYXQxLmRhdGFbb2ZzMSArIGldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGIgPj4+IDE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHggLyBjKSAqIDY1NTM2O1xuICB2YXIgeiA9ICh4ICUgYykgKiA2NTUzNjtcbiAgdmFyIHcgPSB6ICsgKGIgJiAweDAwMDBmZmZmKTtcbiAgcmV0dXJuIFt5ICsgTWF0aC5mbG9vcih3IC8gYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gbmF0MS5kYXRhW29mczEgKyBsZW4gLSAxXSA+Pj4gMDtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yICh2YXIgaSA9IGxlbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgbmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCwgbmF0Mi5kYXRhW29mczJdID4+PiAwKTtcbiAgICBuYXRxLmRhdGFbb2ZzcSArIGldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmIChsZW4yID09PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxICsgMSwgbmF0MSwgb2ZzMSwgbmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcyA9IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQyLCBvZnMyICsgbGVuMiAtIDEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMiArIGxlbjIgLSAxXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMiArIDEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPVxuICAgICAgZCA9PT0gNDI5NDk2NzI5NlxuICAgICAgICA/IG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDBcbiAgICAgICAgOiBkaXZfaGVscGVyKFxuICAgICAgICAgICAgbmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCxcbiAgICAgICAgICAgIG5hdDEuZGF0YVtvZnMxICsgaSAtIDFdID4+PiAwLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICApWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yICsgMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMiArIDEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbcXVvXSksIDApO1xuICAgIHN1Yl9uYXQobmF0MSwgb2ZzMSArIGkgLSBsZW4yLCBsZW4yICsgMSwgYSwgMCwgbGVuMiArIDEsIDEpO1xuXG4gICAgd2hpbGUgKFxuICAgICAgbmF0MS5kYXRhW29mczEgKyBpXSAhPT0gMCB8fFxuICAgICAgY29tcGFyZV9uYXQobmF0MSwgb2ZzMSArIGkgLSBsZW4yLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKSA+PSAwXG4gICAgKSB7XG4gICAgICBxdW8gPSBxdW8gKyAxO1xuICAgICAgc3ViX25hdChuYXQxLCBvZnMxICsgaSAtIGxlbjIsIGxlbjIgKyAxLCBuYXQyLCBvZnMyLCBsZW4yLCAxKTtcbiAgICB9XG5cbiAgICBuYXQxLmRhdGFbb2ZzMSArIGldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfcmlnaHRfbmF0XG5mdW5jdGlvbiBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYgKG5iaXRzID09PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvciAodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEgKyBpXSA9IChhID4+PiBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhIDw8ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBpZiAobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYgKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG5hdDEuZGF0YVtvZnMxICsgaV0gPj4+IDAgPiBuYXQyLmRhdGFbb2ZzMiArIGldID4+PiAwKSByZXR1cm4gMTtcbiAgICBpZiAobmF0MS5kYXRhW29mczEgKyBpXSA+Pj4gMCA8IG5hdDIuZGF0YVtvZnMyICsgaV0gPj4+IDApIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHNlcmlhbGl6ZV9uYXRcbmZ1bmN0aW9uIHNlcmlhbGl6ZV9uYXQod3JpdGVyLCBuYXQsIHN6KSB7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlci53cml0ZSgzMiwgbmF0LmRhdGFbaV0pO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgc3pbMV0gPSBsZW4gKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBkZXNlcmlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZV9uYXQocmVhZGVyLCBzeikge1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgcmV0dXJuIG5hdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUgIT09IHVuZGVmaW5lZDtcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZkLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yLCBmc19ub2RlX3N0YXRzX2Zyb21fanNcbmNsYXNzIE1sTm9kZURldmljZSB7XG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICB0aGlzLmZzID0gcmVxdWlyZShcIm5vZGU6ZnNcIik7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgfVxuXG4gIG5tKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yb290ICsgbmFtZTtcbiAgfVxuXG4gIGV4aXN0cyhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSkgPyAxIDogMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlzRmlsZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRmlsZSgpID8gMSA6IDA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgbWtkaXIobmFtZSwgbW9kZSwgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLCB7IG1vZGU6IG1vZGUgfSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gICAgfVxuICB9XG5cbiAgcm1kaXIobmFtZSwgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICByZWFkZGlyKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIGlzX2RpcihuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCkgPyAxIDogMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICB1bmxpbmsobmFtZSwgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gICAgfVxuICB9XG5cbiAgdXRpbWVzKG5hbWUsIGF0aW1lLCBtdGltZSwgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXRpbWUgPT09IDAgJiYgbXRpbWUgPT09IDApIHtcbiAgICAgICAgYXRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgIG10aW1lID0gYXRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLmZzLnV0aW1lc1N5bmModGhpcy5ubShuYW1lKSwgYXRpbWUsIG10aW1lKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICB0cnVuY2F0ZShuYW1lLCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mcy50cnVuY2F0ZVN5bmModGhpcy5ubShuYW1lKSwgbGVuIHwgMCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gICAgfVxuICB9XG5cbiAgYWNjZXNzKG5hbWUsIGYsIHJhaXNlX3VuaXgpIHtcbiAgICB2YXIgY29uc3RzID0gcmVxdWlyZShcIm5vZGU6ZnNcIikuY29uc3RhbnRzO1xuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBmKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgIHJlcyB8PSBjb25zdHMuUl9PSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLldfT0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgcmVzIHw9XG4gICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3M/LnBsYXRmb3JtID09PSBcIndpbjMyXCJcbiAgICAgICAgICAgICAgPyBjb25zdHMuUl9PS1xuICAgICAgICAgICAgICA6IGNvbnN0cy5YX09LO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgIHJlcyB8PSBjb25zdHMuRl9PSztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZnMuYWNjZXNzU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4obmFtZSwgZiwgcGVybXMsIHJhaXNlX3VuaXgpIHtcbiAgICB2YXIgY29uc3RzID0gcmVxdWlyZShcIm5vZGU6ZnNcIikuY29uc3RhbnRzO1xuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBmKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwicmRvbmx5XCI6XG4gICAgICAgICAgcmVzIHw9IGNvbnN0cy5PX1JET05MWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndyb25seVwiOlxuICAgICAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZHdyXCI6XG4gICAgICAgICAgcmVzIHw9IGNvbnN0cy5PX1JEV1I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcHBlbmRcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fQVBQRU5EO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3JlYXRlXCI6XG4gICAgICAgICAgcmVzIHw9IGNvbnN0cy5PX0NSRUFUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHJ1bmNhdGVcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fVFJVTkM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJleGNsXCI6XG4gICAgICAgICAgcmVzIHw9IGNvbnN0cy5PX0VYQ0w7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fQklOQVJZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgIHJlcyB8PSBjb25zdHMuT19URVhUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9uYmxvY2tcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub2N0dHlcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fTk9DVFRZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZHN5bmNcIjpcbiAgICAgICAgICByZXMgfD0gY29uc3RzLk9fRFNZTkM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeW5jXCI6XG4gICAgICAgICAgcmVzIHw9IGNvbnN0cy5PX1NZTkM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcywgcGVybXMpO1xuICAgICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZCwgZik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIHNsYXNoKG5hbWUpIHtcbiAgICByZXR1cm4gL1xcLyQvLnRlc3QobmFtZSkgPyBuYW1lIDogbmFtZSArIFwiL1wiO1xuICB9XG5cbiAgcmVuYW1lKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5wcm9jZXNzPy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5ubShuKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMubm0obyk7XG4gICAgICAgIHZhciB0YXJnZXRfc3RhdHMsIHNvdXJjZV9zdGF0cztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICh0YXJnZXRfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRhcmdldCwge1xuICAgICAgICAgICAgdGhyb3dJZk5vRW50cnk6IGZhbHNlLFxuICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgIChzb3VyY2Vfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHNvdXJjZSwge1xuICAgICAgICAgICAgdGhyb3dJZk5vRW50cnk6IGZhbHNlLFxuICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgIHNvdXJjZV9zdGF0cy5pc0RpcmVjdG9yeSgpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh0YXJnZXRfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNsYXNoKHRhcmdldCkuc3RhcnRzV2l0aCh0aGlzLnNsYXNoKHNvdXJjZSkpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnMucm1kaXJTeW5jKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEVOT1RESVI6IG5vdCBhIGRpcmVjdG9yeSwgcmVuYW1lICcke3NvdXJjZX0nIC0+ICcke3RhcmdldH0nYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKGVyciwge1xuICAgICAgICAgICAgICBlcnJubzogLTIwLFxuICAgICAgICAgICAgICBjb2RlOiBcIkVOT1RESVJcIixcbiAgICAgICAgICAgICAgc3lzY2FsbDogXCJyZW5hbWVcIixcbiAgICAgICAgICAgICAgcGF0aDogdGFyZ2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0KG5hbWUsIGxhcmdlLCByYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgICByZXR1cm4gZnNfbm9kZV9zdGF0c19mcm9tX2pzKGpzX3N0YXRzLCBsYXJnZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIGxzdGF0KG5hbWUsIGxhcmdlLCByYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgICAgcmV0dXJuIGZzX25vZGVfc3RhdHNfZnJvbV9qcyhqc19zdGF0cywgbGFyZ2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICBjaG1vZChuYW1lLCBwZXJtcywgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmZzLmNobW9kU3luYyh0aGlzLm5tKG5hbWUpLCBwZXJtcyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gICAgfVxuICB9XG5cbiAgbGluayh0YXJnZXQsIHBhdGgsIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mcy5saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCkpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIHN5bWxpbmsodG9fZGlyLCB0YXJnZXQsIHBhdGgsIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mcy5zeW1saW5rU3luYyhcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0aGlzLm5tKHBhdGgpLFxuICAgICAgICB0b19kaXIgPT09IDAgPyBudWxsIDogdG9fZGlyWzFdID8gXCJkaXJcIiA6IFwiZmlsZVwiLFxuICAgICAgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICByZWFkbGluayhuYW1lLCByYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBsaW5rID0gdGhpcy5mcy5yZWFkbGlua1N5bmModGhpcy5ubShuYW1lKSwgXCJ1dGY4XCIpO1xuICAgICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICBvcGVuZGlyKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZnMub3BlbmRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N0YXRzX2Zyb21fanNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXRcbmZ1bmN0aW9uIGZzX25vZGVfc3RhdHNfZnJvbV9qcyhqc19zdGF0cywgbGFyZ2UpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyB8IDAsXG4gICAgZmlsZV9raW5kLFxuICAgIGpzX3N0YXRzLm1vZGUsXG4gICAganNfc3RhdHMubmxpbmssXG4gICAganNfc3RhdHMudWlkLFxuICAgIGpzX3N0YXRzLmdpZCxcbiAgICBqc19zdGF0cy5yZGV2LFxuICAgIGxhcmdlID8gY2FtbF9pbnQ2NF9vZl9mbG9hdChqc19zdGF0cy5zaXplKSA6IGpzX3N0YXRzLnNpemUgfCAwLFxuICAgIGpzX3N0YXRzLmF0aW1lTXMgLyAxMDAwLFxuICAgIGpzX3N0YXRzLm10aW1lTXMgLyAxMDAwLFxuICAgIGpzX3N0YXRzLmN0aW1lTXMgLyAxMDAwLFxuICApO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vSWY6IGJyb3dzZXJcbmNsYXNzIE1sTm9kZURldmljZSB7fVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vZGVqc19lcnJvciwgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IsIGZzX25vZGVfc3RhdHNfZnJvbV9qc1xuY2xhc3MgTWxOb2RlRmQgZXh0ZW5kcyBNbEZpbGUge1xuICBjb25zdHJ1Y3RvcihmZCwgZmxhZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZnMgPSByZXF1aXJlKFwibm9kZTpmc1wiKTtcbiAgICB0aGlzLmZkID0gZmQ7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIHRyeSB7XG4gICAgICB2YXIgc3RhdHMgPSB0aGlzLmZzLmZzdGF0U3luYyhmZCk7XG4gICAgICBmbGFncy5ub1NlZWsgPVxuICAgICAgICBzdGF0cy5pc0NoYXJhY3RlckRldmljZSgpIHx8IHN0YXRzLmlzRklGTygpIHx8IHN0YXRzLmlzU29ja2V0KCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUaGUgZnN0YXQgd2lsbCBmYWlsIG9uIHN0YW5kYXJkIHN0cmVhbXMgdW5kZXIgV2luZG93cyB3aXRoIG5vZGVcbiAgICAgIC8vIDE4IChhbmQgbG93ZXIpLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpYnV2L2xpYnV2L3B1bGwvMzgxMS5cbiAgICAgIGZsYWdzLm5vU2VlayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5mbGFncy5hcHBlbmQgPyBzdGF0cy5zaXplIDogMDtcbiAgICB0aGlzLnNlZWtlZCA9IGZhbHNlO1xuICB9XG5cbiAgdHJ1bmNhdGUobGVuLCByYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLCBsZW4gfCAwKTtcbiAgICAgIGlmICh0aGlzLm9mZnNldCA+IGxlbikgdGhpcy5vZmZzZXQgPSBsZW47XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgd3JpdGUoYnVmLCBidWZfb2Zmc2V0LCBsZW4sIHJhaXNlX3VuaXgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZmxhZ3Mubm9TZWVrIHx8ICF0aGlzLnNlZWtlZCkge1xuICAgICAgICB2YXIgd3JpdHRlbiA9IHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3cml0dGVuID0gdGhpcy5mcy53cml0ZVN5bmMoXG4gICAgICAgICAgdGhpcy5mZCxcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgYnVmX29mZnNldCxcbiAgICAgICAgICBsZW4sXG4gICAgICAgICAgdGhpcy5vZmZzZXQsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLm9mZnNldCArPSB3cml0dGVuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH1cblxuICByZWFkKGEsIGJ1Zl9vZmZzZXQsIGxlbiwgcmFpc2VfdW5peCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5mbGFncy5ub1NlZWsgfHwgIXRoaXMuc2Vla2VkKSB7XG4gICAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYWQgPSB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGEsIGJ1Zl9vZmZzZXQsIGxlbiwgdGhpcy5vZmZzZXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5vZmZzZXQgKz0gcmVhZDtcbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgICB9XG4gIH1cblxuICBzZWVrKG9mZnNldCwgd2hlbmNlLCByYWlzZV91bml4KSB7XG4gICAgaWYgKHRoaXMuZmxhZ3Mubm9TZWVrKSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c3RlbV9lcnJvcihyYWlzZV91bml4LCBcIkVTUElQRVwiLCBcImxzZWVrXCIsIFwiaWxsZWdhbCBzZWVrXCIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHdoZW5jZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMub2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgY2FtbF9yYWlzZV9zeXN0ZW1fZXJyb3IoXG4gICAgICAgIHJhaXNlX3VuaXgsXG4gICAgICAgIFwiRUlOVkFMXCIsXG4gICAgICAgIFwibHNlZWtcIixcbiAgICAgICAgXCJpbnZhbGlkIGFyZ3VtZW50XCIsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnNlZWtlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICB9XG5cbiAgc3RhdChsYXJnZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKTtcbiAgICAgIHJldHVybiBmc19ub2RlX3N0YXRzX2Zyb21fanMoanNfc3RhdHMsIGxhcmdlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgLyogcmFpc2UgVW5peF9lcnJvciAqLyAxKTtcbiAgICB9XG4gIH1cblxuICBjaG1vZChwZXJtcykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmZzLmZjaG1vZFN5bmModGhpcy5mZCwgcGVybXMpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gMSk7XG4gICAgfVxuICB9XG5cbiAgc3luYygpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5mcy5mc3luY1N5bmModGhpcy5mZCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgLyogcmFpc2UgVW5peF9lcnJvciAqLyAxKTtcbiAgICB9XG4gIH1cblxuICBjbG9zZShyYWlzZV91bml4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYW1sX3JhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrX3N0cmVhbV9zZW1hbnRpY3MoY21kKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCAvKiByYWlzZSBVbml4X2Vycm9yICovIDEsIGNtZCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIGpzX3N0YXRzLmlzRmlsZSgpIHx8XG4gICAgICAgIGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAganNfc3RhdHMuaXNGSUZPKCkgfHxcbiAgICAgICAganNfc3RhdHMuaXNTb2NrZXQoKVxuICAgICAgKVxuICAgIClcbiAgICAgIGNhbWxfcmFpc2Vfc3lzdGVtX2Vycm9yKFxuICAgICAgICAvKiByYWlzZSBVbml4X2Vycm9yICovIDEsXG4gICAgICAgIFwiRUlOVkFMXCIsXG4gICAgICAgIGNtZCxcbiAgICAgICAgXCJpbnZhbGlkIGFyZ3VtZW50XCIsXG4gICAgICApO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL0lmOiBicm93c2VyXG5jbGFzcyBNbE5vZGVGZCB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL1JlcXVpcmVzOiBNbE5vZGVGZFxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpIHtcbiAgaWYgKGZsYWdzLmFsdG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZzID0gcmVxdWlyZShcIm5vZGU6ZnNcIik7XG4gICAgICB2YXIgZmQyID0gZnMub3BlblN5bmMoZmxhZ3MuYWx0bmFtZSwgXCJyc1wiKTtcbiAgICAgIHJldHVybiBuZXcgTWxOb2RlRmQoZmQyLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmbGFncyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoX2ZkLCBfZmxhZ3MpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9kZWpzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncywgbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4LCBjbWQpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoXG4gICAgICBlcnIuY29kZSxcbiAgICAgIGNtZCB8fCBlcnIuc3lzY2FsbCxcbiAgICAgIGVyci5wYXRoLFxuICAgICAgZXJyLmVycm5vLFxuICAgICk7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY192MlxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19hbGxvY192MihzaXplKXtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlKDEyLCAwLCBbMCxzaXplXSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWIoeCl7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHViKHMxLCBpMSwgczIsIGkyLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShzMSxpMSxzMixpMixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YihzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViKHNyYywgc3JjX3BvcywgZHN0LCBkc3RfcG9zLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbXNldF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtc2V0X3N0dWIoYmlnc3RyaW5nLCB2X3Bvcywgdl9sZW4sIHZfY2hhcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIHtcbiAgICBjYW1sX2JhX3NldF8xKGJpZ3N0cmluZywgdl9wb3MgKyBpLCB2X2NoYXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1jbXBfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbWNtcF9zdHViKHZfczEsIHZfczFfcG9zLCB2X3MyLCB2X3MyX3Bvcywgdl9sZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEodl9zMSx2X3MxX3BvcyArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMSh2X3MyLHZfczJfcG9zICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbWNtcF9ieXRlc19zdHViKHZfczEsIHZfczFfcG9zLCB2X3MyLCB2X3MyX3Bvcywgdl9sZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsIHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2J5dGVzX2dldCh2X3MyLCB2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW50ZXJuYWxoYXNoX2ZvbGRfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xudmFyIGludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZyA9IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19maW5kXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfZmluZChicywgY2hyLCBwb3MsIGxlbil7XG4gIHdoaWxlKGxlbiA+IDApe1xuICAgIGlmKGNhbWxfYmFfZ2V0XzEoYnMscG9zKSA9PSBjaHIpIHJldHVybiBwb3M7XG4gICAgcG9zKys7XG4gICAgbGVuLS07XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtbWVtX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtbWVtX2J5dGVjb2RlKGhheXN0YWNrLCBuZWVkbGUsIGhheXN0YWNrX3BvcywgaGF5c3RhY2tfbGVuLCBuZWVkbGVfcG9zLCBuZWVkbGVfbGVuKXtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGltID0gaGF5c3RhY2tfbGVuIC0gbmVlZGxlX2xlbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8PSBsaW07ICsraSkge1xuICAgIHZhciBtYXRjaGVzID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lZWRsZV9sZW47ICsraikge1xuICAgICAgaWYgKGNhbWxfYmFfZ2V0XzEoaGF5c3RhY2ssIGhheXN0YWNrX3BvcyArIGkgKyBqKSAhPSBjYW1sX2JhX2dldF8xKG5lZWRsZSxuZWVkbGVfcG9zICsgaikpIHtcbiAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMpIHJldHVybiAoaGF5c3RhY2tfcG9zICsgaSk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlcjtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgYmEuYnVmZmVyLFxuICAgIGJhLmJ5dGVPZmZzZXQsXG4gICAgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQsXG4gICk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEsIHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIsIHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbikge1xuICBpZiAoMTIgIT09IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmICgxMiAhPT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZiAob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZiAob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLCBvZnMxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLCBwb3MyKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKSB7XG4gIGlmICgxMiAhPT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmIChwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmIChvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnN1YmFycmF5KHBvczEsIHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UsIG9mczIpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbikge1xuICBpZiAoMTIgIT09IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZiAocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmIChvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc3ViYXJyYXkocG9zMSwgcG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSwgb2ZzMik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbikge1xuICBpZiAoMTIgIT09IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZiAob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZiAocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSwgb2ZzMSArIGxlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3VpbnQ4X2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vLy8vLy8vLyBDT1JFXG5cbi8vUHJvdmlkZXM6IGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9pbnRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG52YXIgY29yZV9hcnJheV91bnNhZmVfZmxvYXRfYmxpdCA9IGNhbWxfYXJyYXlfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjb3JlX3RpbWVfbnNfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjb3JlX3RpbWVfbnNfZm9ybWF0KHRpbWUsZm9ybWF0KXtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gIHZhciBmb3JtYXRqcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm9ybWF0KTtcbiAgdmFyIGpzdHJpbmcgPSBqb29fZ2xvYmFsX29iamVjdC5zdHJmdGltZShmb3JtYXRqcywgZCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzdHJpbmcpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb3JlX2djX2NvbXBhY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2djX2NvbXBhY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19oZWFwX2NodW5rc1xuZnVuY3Rpb24gY29yZV9nY19oZWFwX2NodW5rcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfaGVhcF93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY19oZWFwX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19tYWpvcl9jb2xsZWN0aW9uc1xuZnVuY3Rpb24gY29yZV9nY19tYWpvcl9jb2xsZWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfbWFqb3JfcGx1c19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19tYWpvcl93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY19tYWpvcl93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfbWlub3JfY29sbGVjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfZ2NfbWlub3JfY29sbGVjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX21pbm9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19wcm9tb3RlZF93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY19wcm9tb3RlZF93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfdG9wX2hlYXBfd29yZHNcbmZ1bmN0aW9uIGNvcmVfZ2NfdG9wX2hlYXBfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX3J1bl9tZW1wcm9mX2NhbGxiYWNrc1xuZnVuY3Rpb24gY29yZV9nY19ydW5fbWVtcHJvZl9jYWxsYmFja3MgKCkgeyByZXR1cm4gMCB9XG5cbi8vUHJvdmlkZXM6IGNvcmVfbWQ1X2ZkXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiwgY2FtbF9tZDVfY2hhbiwgY2FtbF9tbF9jbG9zZV9jaGFubmVsXG5mdW5jdGlvbiBjb3JlX21kNV9mZChmZCl7XG4gICAgdmFyIGljID0gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4oZmQpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYW1sX21kNV9jaGFuKGljLCAtMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY2FtbF9tbF9jbG9zZV9jaGFubmVsKGljKTtcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9ibGl0X3N0cmluZywgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZyhidWYsIG9mcywgbGVuLCByZXMpe1xuICAgIHZhciBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIoYnVmLCBvZnMsIGJ5dGVzLCAwLCBsZW4pO1xuICAgIHZhciByZXMyID0gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKSwgMCwgbGVuKTtcbiAgICBjYW1sX2JsaXRfc3RyaW5nKHJlczIsIDAsIHJlcywgMCwgMTYpO1xuICAgIHJldHVybiAwO1xufVxuXG4vL0JpZ3N0cmluZ1xuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIodl9ic3RyKSB7XG4gIGlmICh2X2JzdHIuaGFzT3duUHJvcGVydHkoJ19faXNfZGVhbGxvY2F0ZWQnKSkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19kZXN0cm95OiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgfVxuICAvLyBNdXRhdGUgdGhlIG9yaWdpbmFsIGJpZ3N0cmluZyBpbi1wbGFjZSwgdG8gc2ltdWxhdGUgd2hhdCB0aGUgQyB2ZXJzaW9uIGRvZXNcbiAgdl9ic3RyLl9faXNfZGVhbGxvY2F0ZWQgPSB0cnVlO1xuICB2X2JzdHIuZGF0YSA9IG5ldyB2X2JzdHIuZGF0YS5fX3Byb3RvX18uY29uc3RydWN0b3IoMCk7XG4gIHZfYnN0ci5kaW1zID0gWyAwIF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfcmVhbGxvY1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19yZWFsbG9jKGJpZ3N0cmluZywgc2l6ZSkge1xuICAgIGlmIChiaWdzdHJpbmcuaGFzT3duUHJvcGVydHkoJ19faXNfZGVhbGxvY2F0ZWQnKSkge1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdzdHJpbmdfcmVhbGxvYzogYmlnc3RyaW5nIGlzIGFscmVhZHkgZGVhbGxvY2F0ZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIG5ld19kYXRhID0gbmV3IGJpZ3N0cmluZy5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcihzaXplKTtcbiAgICBuZXdfZGF0YS5zZXQoYmlnc3RyaW5nLmRhdGEuc2xpY2UoMCwgc2l6ZSkpO1xuICAgIHZhciBuZXdfYmlnc3RyaW5nID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJpZ3N0cmluZy5raW5kLCBiaWdzdHJpbmcubGF5b3V0LCBbc2l6ZV0sIG5ld19kYXRhKTtcbiAgICBiaWdzdHJpbmdfZGVzdHJveV9zdHViKGJpZ3N0cmluZyk7XG5cbiAgICByZXR1cm4gbmV3X2JpZ3N0cmluZztcbn1cbiIsIi8vLy8vLy8vLyBCSU5fUFJPVFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoYmlnc3RyaW5nLCBpKXtcbiAgaWYgKGkgPj4+IDAgPj0gYmlnc3RyaW5nLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX2Zsb2F0X2FycmF5X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfY2hlY2tfYm91bmQsIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViKHNyY19wb3MsIHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGNhbWxfY2hlY2tfYm91bmQoZHN0LGRzdF9wb3MpOyAvLyBmaXJzdCBwb3NcbiAgY2FtbF9jaGVja19ib3VuZChkc3QsZHN0X3BvcytsZW4tMSk7IC8vIGxhc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKHNyYywgc3JjX3Bvcyk7ICAvKiBmaXJzdCBwb3MgKi9cbiAgY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoc3JjLCBzcmNfcG9zICsgbGVuICogOCAtIDEpOyAvKiBsYXN0IHBvcyAqL1xuICB2YXIgdmlldyA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDY0QXJyYXkobGVuKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHZpZXcuYnVmZmVyKTtcbiAgYnVmZmVyLnNldChzcmMuZGF0YS5zdWJhcnJheShzcmNfcG9zLCBzcmNfcG9zICsgKGxlbiAqIDgpKSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgLy8gWysgMV0gYmVjYXVzZSB0aGUgdGFnIGlzIGF0IHBvcyAwIFxuICAgIGRzdFtkc3RfcG9zK2krMV0gPSB2aWV3W2ldO1xuICB9XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9ieXRlc19zdHViKHNyY19wb3MsIHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfZmxvYXRfYXJyYXlfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfY2hlY2tfYm91bmQsIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViKHNyY19wb3Msc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMCBcbiAgY2FtbF9jaGVja19ib3VuZCAoc3JjLCBzcmNfcG9zKTsgLy8gZmlyc3QgcG9zIFxuICBjYW1sX2NoZWNrX2JvdW5kIChzcmMsIHNyY19wb3MgKyBsZW4gLSAxKTsgLy8gbGFzdCBwb3NcbiAgY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmcoZHN0LCBkc3RfcG9zKTsgLyogZmlyc3QgcG9zICovXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGRzdCwgZHN0X3BvcyArIGxlbiAqIDggLSAxKTsgLyogbGFzdCBwb3MgKi9cbiAgLy8gWysgMV0gYmVjYXVzZSB0aGUgdGFnIGlzIGF0IHBvcyAwXG4gIHNyY19wb3MgPSBzcmNfcG9zICsgMVxuICB2YXIgZmxvYXQ2NCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDY0QXJyYXkoc3JjLnNsaWNlKHNyY19wb3Msc3JjX3BvcyArIGxlbikpO1xuICB2YXIgZmxvYXQ2NF91aW50OCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGZsb2F0NjQuYnVmZmVyKTtcbiAgdmFyIHZpZXcgPSBkc3QuZGF0YS5zdWJhcnJheShkc3RfcG9zLCBkc3RfcG9zICsgKGxlbiAqIDgpKTtcbiAgdmlldy5zZXQoZmxvYXQ2NF91aW50OCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbmZ1bmN0aW9uIGJpbl9wcm90X2JsaXRfc3RyaW5nX2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLCBkc3QsIGRzdF9wb3MsbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnl0ZXNfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYyxzcmNfcG9zLCBkc3QsIGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSwgYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5XG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X2J1Zl9zdHViIChzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgLy8gW2Jpbl9wcm90X2JsaXRfYnVmX3N0dWJdIGlzIHVzZWQgd2l0aCBtaXhlZCBiaWdhcnJheSBraW5kcy5cbiAgLy8gQ29udmVydGVyIGV2ZXJ5dGhpbmcgdG8gYmlnYXJyYXkgb2YgY2hhciBiZWZvcmUgdGhlIGJsaXQuXG4gIGlmKHNyYy5raW5kICE9IDEyKSAvLyAxMiBpcyB0aGUgY2hhciBraW5kXG4gICAgc3JjID0gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KHNyYy5kYXRhKTtcbiAgaWYoZHN0LmtpbmQgIT0gMTIpIC8vIDEyIGlzIHRoZSBjaGFyIGtpbmRcbiAgICBkc3QgPSBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoZHN0LmRhdGEpO1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShzcmMsc3JjX3Bvcyxkc3QsZHN0X3BvcyxsZW4pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YihhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICBhMlswXSA9IDA7XG4gIGZvciAodmFyIGkyID0gMSwgaTEgPSBpICsgMTsgaTIgPD0gbGVuOyBpMisrLCBpMSsrKSB7XG4gICAgYTJbaTJdID0gYVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfc3ViIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfc3ViXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X3N1YihhLCBpLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfc3ViKGEsIGksIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5pZm9ybV9hcnJheV9zdWIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9zdWJcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX3VuaWZvcm1fYXJyYXlfc3ViKGEsIGksIGxlbikge1xuICByZXR1cm4gY2FtbF9hcnJheV9zdWIoYSwgaSwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCxcbiAgICBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMSArIGwyIC0gMTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsXG4gICAgaiA9IDE7XG4gIGZvciAoOyBpIDwgbDE7IGkrKykgYVtpXSA9IGExW2ldO1xuICBmb3IgKDsgaSA8IGw7IGkrKywgaisrKSBhW2ldID0gYTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYXBwZW5kIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYXBwZW5kXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5pZm9ybV9hcnJheV9hcHBlbmQgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9hcHBlbmRcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX3VuaWZvcm1fYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICByZXR1cm4gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jb25jYXQgbXV0YWJsZVxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5pZm9ybV9hcnJheV9jb25jYXQgbXV0YWJsZVxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfdW5pZm9ybV9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICByZXR1cm4gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaWZvcm1fYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF91bmlmb3JtX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICByZXR1cm4gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pO1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9BbGlhczogY2FtbF9hcnJheV9zZXRfZmxvYXRcbi8vQWxpYXM6IGNhbWxfZmxvYXRhcnJheV9zZXRcbi8vQWxpYXM6IGNhbWxfYXJyYXlfc2V0X2FkZHJcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0KGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCArIDFdID0gbmV3dmFsO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL0FsaWFzOiBjYW1sX2FycmF5X2dldF9mbG9hdFxuLy9BbGlhczogY2FtbF9mbG9hdGFycmF5X2dldFxuLy9BbGlhczogY2FtbF9hcnJheV9nZXRfYWRkclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXggKyAxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheVtvZnMgKyBpICsgMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfZmlsbFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9maWxsXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KSB7XG4gIHJldHVybiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2ZpbGxfdW5ib3hlZFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9maWxsXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2ZpbGxfdW5ib3hlZChhcnJheSwgb2ZzLCBsZW4sIHYpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaWZvcm1fYXJyYXlfZmlsbFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9maWxsXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF91bmlmb3JtX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KSB7XG4gIHJldHVybiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL0FsaWFzOiBjYW1sX2NoZWNrX2JvdW5kX2dlblxuLy9BbGlhczogY2FtbF9jaGVja19ib3VuZF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4+PiAwID49IGFycmF5Lmxlbmd0aCAtIDEpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X21ha2UgY29uc3QgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9tYWtlKGxlbiwgaW5pdCkge1xuICBpZiAobGVuID4+PiAwID49ICgoMHg3ZmZmZmZmZiAvIDQpIHwgMCkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IChsZW4gKyAxKSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF0gPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfbWFrZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QobGVuLCBpbml0KSB7XG4gIHJldHVybiBjYW1sX2FycmF5X21ha2UobGVuLCBpbml0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKSB7XG4gIGlmIChsZW4gPj4+IDAgPj0gKCgweDdmZmZmZmZmIC8gOCkgfCAwKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gKGxlbiArIDEpIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXSA9IDI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NyZWF0ZV9mbG9hdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9hcnJheV9jcmVhdGVfZmxvYXQobGVuKSB7XG4gIGlmIChsZW4gPj4+IDAgPj0gKCgweDdmZmZmZmZmIC8gOCkgfCAwKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gKGxlbiArIDEpIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXSA9IDI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiO1xufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbikge1xuICBpZiAobGVuID4+PiAwID49ICgoMHg3ZmZmZmZmZiAvIDgpIHwgMCkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IChsZW4gKyAxKSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF0gPSAyNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X21ha2UgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9tYWtlKGxlbiwgaW5pdCkge1xuICBpZiAobGVuID4+PiAwID49ICgoMHg3ZmZmZmZmZiAvIDgpIHwgMCkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IChsZW4gKyAxKSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF0gPSAyNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X21ha2VfdW5ib3hlZCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0YXJyYXlfbWFrZVxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9tYWtlX3VuYm94ZWQobGVuLCBpbml0KSB7XG4gIHJldHVybiBjYW1sX2Zsb2F0YXJyYXlfbWFrZShsZW4sIGluaXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaWZvcm1fYXJyYXlfbWFrZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X21ha2Vcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX3VuaWZvcm1fYXJyYXlfbWFrZShsZW4sIGluaXQpIHtcbiAgcmV0dXJuIGNhbWxfYXJyYXlfbWFrZShsZW4sIGluaXQpO1xufVxuIiwiLy9Qcm92aWRlczogYmxha2UyYlxuLy9WZXJzaW9uOiA+PSA1LjJcbnZhciBibGFrZTJiID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQmxha2UyQiBpbiBwdXJlIEphdmFzY3JpcHRcbiAgLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuICAvLyBQb3J0ZWQgdG8gSmF2YXNjcmlwdCBieSBEQyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kY3Bvc2NoXG5cbiAgLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4gIC8vIFNldHMgdlthLGErMV0gKz0gdltiLGIrMV1cbiAgLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuICBmdW5jdGlvbiBBREQ2NEFBKHYsIGEsIGIpIHtcbiAgICBjb25zdCBvMCA9IHZbYV0gKyB2W2JdO1xuICAgIGxldCBvMSA9IHZbYSArIDFdICsgdltiICsgMV07XG4gICAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgICBvMSsrO1xuICAgIH1cbiAgICB2W2FdID0gbzA7XG4gICAgdlthICsgMV0gPSBvMTtcbiAgfVxuXG4gIC8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuICAvLyBTZXRzIHZbYSxhKzFdICs9IGJcbiAgLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuICBmdW5jdGlvbiBBREQ2NEFDKHYsIGEsIGIwLCBiMSkge1xuICAgIGxldCBvMCA9IHZbYV0gKyBiMDtcbiAgICBpZiAoYjAgPCAwKSB7XG4gICAgICBvMCArPSAweDEwMDAwMDAwMDtcbiAgICB9XG4gICAgbGV0IG8xID0gdlthICsgMV0gKyBiMTtcbiAgICBpZiAobzAgPj0gMHgxMDAwMDAwMDApIHtcbiAgICAgIG8xKys7XG4gICAgfVxuICAgIHZbYV0gPSBvMDtcbiAgICB2W2EgKyAxXSA9IG8xO1xuICB9XG5cbiAgLy8gTGl0dGxlLWVuZGlhbiBieXRlIGFjY2Vzc1xuICBmdW5jdGlvbiBCMkJfR0VUMzIoYXJyLCBpKSB7XG4gICAgcmV0dXJuIGFycltpXSBeIChhcnJbaSArIDFdIDw8IDgpIF4gKGFycltpICsgMl0gPDwgMTYpIF4gKGFycltpICsgM10gPDwgMjQpO1xuICB9XG5cbiAgLy8gRyBNaXhpbmcgZnVuY3Rpb25cbiAgLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuICBmdW5jdGlvbiBCMkJfRyhhLCBiLCBjLCBkLCBpeCwgaXkpIHtcbiAgICBjb25zdCB4MCA9IG1baXhdO1xuICAgIGNvbnN0IHgxID0gbVtpeCArIDFdO1xuICAgIGNvbnN0IHkwID0gbVtpeV07XG4gICAgY29uc3QgeTEgPSBtW2l5ICsgMV07XG5cbiAgICBBREQ2NEFBKHYsIGEsIGIpOyAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICAgIEFERDY0QUModiwgYSwgeDAsIHgxKTsgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IDMyIGJpdHNcbiAgICBsZXQgeG9yMCA9IHZbZF0gXiB2W2FdO1xuICAgIGxldCB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXTtcbiAgICB2W2RdID0geG9yMTtcbiAgICB2W2QgKyAxXSA9IHhvcjA7XG5cbiAgICBBREQ2NEFBKHYsIGMsIGQpO1xuXG4gICAgLy8gdltiLGIrMV0gPSAodltiLGIrMV0geG9yIHZbYyxjKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDI0IGJpdHNcbiAgICB4b3IwID0gdltiXSBeIHZbY107XG4gICAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV07XG4gICAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KTtcbiAgICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KTtcblxuICAgIEFERDY0QUEodiwgYSwgYik7XG4gICAgQURENjRBQyh2LCBhLCB5MCwgeTEpO1xuXG4gICAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgICB4b3IwID0gdltkXSBeIHZbYV07XG4gICAgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV07XG4gICAgdltkXSA9ICh4b3IwID4+PiAxNikgXiAoeG9yMSA8PCAxNik7XG4gICAgdltkICsgMV0gPSAoeG9yMSA+Pj4gMTYpIF4gKHhvcjAgPDwgMTYpO1xuXG4gICAgQURENjRBQSh2LCBjLCBkKTtcblxuICAgIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSA2MyBiaXRzXG4gICAgeG9yMCA9IHZbYl0gXiB2W2NdO1xuICAgIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdO1xuICAgIHZbYl0gPSAoeG9yMSA+Pj4gMzEpIF4gKHhvcjAgPDwgMSk7XG4gICAgdltiICsgMV0gPSAoeG9yMCA+Pj4gMzEpIF4gKHhvcjEgPDwgMSk7XG4gIH1cblxuICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbiAgY29uc3QgQkxBS0UyQl9JVjMyID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweGYzYmNjOTA4LCAweDZhMDllNjY3LCAweDg0Y2FhNzNiLCAweGJiNjdhZTg1LCAweGZlOTRmODJiLCAweDNjNmVmMzcyLFxuICAgIDB4NWYxZDM2ZjEsIDB4YTU0ZmY1M2EsIDB4YWRlNjgyZDEsIDB4NTEwZTUyN2YsIDB4MmIzZTZjMWYsIDB4OWIwNTY4OGMsXG4gICAgMHhmYjQxYmQ2YiwgMHgxZjgzZDlhYiwgMHgxMzdlMjE3OSwgMHg1YmUwY2QxOSxcbiAgXSk7XG5cbiAgY29uc3QgU0lHTUE4ID0gW1xuICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE0LCAxMCwgNCwgOCwgOSwgMTUsXG4gICAgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgMywgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNixcbiAgICA3LCAxLCA5LCA0LCA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LCA5LCAwLCA1LFxuICAgIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsXG4gICAgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSwgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LFxuICAgIDExLCAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLCA2LCAxNSwgMTQsIDksIDExLFxuICAgIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LFxuICAgIDMsIDEyLCAxMywgMCwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTQsIDEwLFxuICAgIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICBdO1xuXG4gIC8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuICAvLyBNdWx0aXBseSB0aGVtIGFsbCBieSAyIHRvIG1ha2UgdGhlbSBvZmZzZXRzIGludG8gYSB1aW50MzIgYnVmZmVyLFxuICAvLyBiZWNhdXNlIHRoaXMgaXMgSmF2YXNjcmlwdCBhbmQgd2UgZG9uJ3QgaGF2ZSB1aW50NjRzXG4gIGNvbnN0IFNJR01BODIgPSBuZXcgVWludDhBcnJheShcbiAgICBTSUdNQTgubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCAqIDI7XG4gICAgfSksXG4gICk7XG5cbiAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24uICdsYXN0JyBmbGFnIGluZGljYXRlcyBsYXN0IGJsb2NrLlxuICAvLyBOb3RlIHdlJ3JlIHJlcHJlc2VudGluZyAxNiB1aW50NjRzIGFzIDMyIHVpbnQzMnNcbiAgY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheSgzMik7XG4gIGNvbnN0IG0gPSBuZXcgVWludDMyQXJyYXkoMzIpO1xuICBmdW5jdGlvbiBibGFrZTJiQ29tcHJlc3MoY3R4LCBsYXN0KSB7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgLy8gaW5pdCB3b3JrIHZhcmlhYmxlc1xuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB2W2ldID0gY3R4LmhbaV07XG4gICAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV07XG4gICAgfVxuXG4gICAgLy8gbG93IDY0IGJpdHMgb2Ygb2Zmc2V0XG4gICAgdlsyNF0gPSB2WzI0XSBeIGN0eC50O1xuICAgIHZbMjVdID0gdlsyNV0gXiAoY3R4LnQgLyAweDEwMDAwMDAwMCk7XG4gICAgLy8gaGlnaCA2NCBiaXRzIG5vdCBzdXBwb3J0ZWQsIG9mZnNldCBtYXkgbm90IGJlIGhpZ2hlciB0aGFuIDIqKjUzLTFcblxuICAgIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICAgIGlmIChsYXN0KSB7XG4gICAgICB2WzI4XSA9IH52WzI4XTtcbiAgICAgIHZbMjldID0gfnZbMjldO1xuICAgIH1cblxuICAgIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIG1baV0gPSBCMkJfR0VUMzIoY3R4LmIsIDQgKiBpKTtcbiAgICB9XG5cbiAgICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICAgIC8vIHVuY29tbWVudCB0aGUgRGVidWdQcmludCBjYWxscyB0byBsb2cgdGhlIGNvbXB1dGF0aW9uXG4gICAgLy8gYW5kIG1hdGNoIHRoZSBSRkMgc2FtcGxlIGRvY3VtZW50YXRpb25cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgQjJCX0coMCwgOCwgMTYsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDBdLCBTSUdNQTgyW2kgKiAxNiArIDFdKTtcbiAgICAgIEIyQl9HKDIsIDEwLCAxOCwgMjYsIFNJR01BODJbaSAqIDE2ICsgMl0sIFNJR01BODJbaSAqIDE2ICsgM10pO1xuICAgICAgQjJCX0coNCwgMTIsIDIwLCAyOCwgU0lHTUE4MltpICogMTYgKyA0XSwgU0lHTUE4MltpICogMTYgKyA1XSk7XG4gICAgICBCMkJfRyg2LCAxNCwgMjIsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDZdLCBTSUdNQTgyW2kgKiAxNiArIDddKTtcbiAgICAgIEIyQl9HKDAsIDEwLCAyMCwgMzAsIFNJR01BODJbaSAqIDE2ICsgOF0sIFNJR01BODJbaSAqIDE2ICsgOV0pO1xuICAgICAgQjJCX0coMiwgMTIsIDIyLCAyNCwgU0lHTUE4MltpICogMTYgKyAxMF0sIFNJR01BODJbaSAqIDE2ICsgMTFdKTtcbiAgICAgIEIyQl9HKDQsIDE0LCAxNiwgMjYsIFNJR01BODJbaSAqIDE2ICsgMTJdLCBTSUdNQTgyW2kgKiAxNiArIDEzXSk7XG4gICAgICBCMkJfRyg2LCA4LCAxOCwgMjgsIFNJR01BODJbaSAqIDE2ICsgMTRdLCBTSUdNQTgyW2kgKiAxNiArIDE1XSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGN0eC5oW2ldID0gY3R4LmhbaV0gXiB2W2ldIF4gdltpICsgMTZdO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJldXNhYmxlIHBhcmFtZXRlckJsb2NrXG4gIGNvbnN0IHBhcmFtZXRlckJsb2NrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsIC8vICAwOiBvdXRsZW4sIGtleWxlbiwgZmFub3V0LCBkZXB0aFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsIC8vICA0OiBsZWFmIGxlbmd0aCwgc2VxdWVudGlhbCBtb2RlXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gIDg6IG5vZGUgb2Zmc2V0XG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gMTI6IG5vZGUgb2Zmc2V0XG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gMTY6IG5vZGUgZGVwdGgsIGlubmVyIGxlbmd0aCwgcmZ1XG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gMjA6IHJmdVxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsIC8vIDI0OiByZnVcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyAyODogcmZ1XG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gMzI6IHNhbHRcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyAzNjogc2FsdFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsIC8vIDQwOiBzYWx0XG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCwgLy8gNDQ6IHNhbHRcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyA0ODogcGVyc29uYWxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyA1MjogcGVyc29uYWxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyA1NjogcGVyc29uYWxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLCAvLyA2MDogcGVyc29uYWxcbiAgXSk7XG5cbiAgLy8gQ3JlYXRlcyBhIEJMQUtFMmIgaGFzaGluZyBjb250ZXh0XG4gIC8vIFJlcXVpcmVzIGFuIG91dHB1dCBsZW5ndGggYmV0d2VlbiAxIGFuZCA2NCBieXRlc1xuICAvLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuICBmdW5jdGlvbiBibGFrZTJiSW5pdChvdXRsZW4sIGtleSkge1xuICAgIGlmIChvdXRsZW4gPT09IDAgfHwgb3V0bGVuID4gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgb3V0cHV0IGxlbmd0aCwgZXhwZWN0ZWQgMCA8IGxlbmd0aCA8PSA2NFwiKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPiA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBrZXksIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCAwIDwgbGVuZ3RoIDw9IDY0XCIpO1xuICAgIH1cblxuICAgIC8vIHN0YXRlLCAncGFyYW0gYmxvY2snXG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgYjogbmV3IFVpbnQ4QXJyYXkoMTI4KSxcbiAgICAgIGg6IG5ldyBVaW50MzJBcnJheSgxNiksXG4gICAgICB0OiAwLCAvLyBpbnB1dCBjb3VudFxuICAgICAgYzogMCwgLy8gcG9pbnRlciB3aXRoaW4gYnVmZmVyXG4gICAgICBvdXRsZW46IG91dGxlbiwgLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICAgIH07XG5cbiAgICAvLyBpbml0aWFsaXplIHBhcmFtZXRlckJsb2NrIGJlZm9yZSB1c2FnZVxuICAgIHBhcmFtZXRlckJsb2NrLmZpbGwoMCk7XG4gICAgcGFyYW1ldGVyQmxvY2tbMF0gPSBvdXRsZW47XG4gICAgcGFyYW1ldGVyQmxvY2tbMV0gPSBrZXkubGVuZ3RoO1xuICAgIHBhcmFtZXRlckJsb2NrWzJdID0gMTsgLy8gZmFub3V0XG4gICAgcGFyYW1ldGVyQmxvY2tbM10gPSAxOyAvLyBkZXB0aFxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBjdHguaFtpXSA9IEJMQUtFMkJfSVYzMltpXSBeIEIyQl9HRVQzMihwYXJhbWV0ZXJCbG9jaywgaSAqIDQpO1xuICAgIH1cblxuICAgIGlmIChrZXkubGVuZ3RoID4gMCkge1xuICAgICAgYmxha2UyYlVwZGF0ZShjdHgsIGtleSk7XG4gICAgICAvLyBhdCB0aGUgZW5kXG4gICAgICBjdHguYyA9IDEyODtcbiAgICB9XG5cbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbiAgLy8gUmVxdWlyZXMgaGFzaCBjb250ZXh0IGFuZCBVaW50OEFycmF5IChieXRlIGFycmF5KVxuICBmdW5jdGlvbiBibGFrZTJiVXBkYXRlKGN0eCwgaW5wdXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY3R4LmMgPT09IDEyOCkge1xuICAgICAgICAvLyBidWZmZXIgZnVsbCA/XG4gICAgICAgIGN0eC50ICs9IGN0eC5jOyAvLyBhZGQgY291bnRlcnNcbiAgICAgICAgYmxha2UyYkNvbXByZXNzKGN0eCwgZmFsc2UpOyAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICAgIGN0eC5jID0gMDsgLy8gY291bnRlciB0byB6ZXJvXG4gICAgICB9XG4gICAgICBjdHguYltjdHguYysrXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBsZXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbiAgLy8gUmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgbWVzc2FnZSBkaWdlc3RcbiAgZnVuY3Rpb24gYmxha2UyYkZpbmFsKGN0eCkge1xuICAgIGN0eC50ICs9IGN0eC5jOyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG5cbiAgICB3aGlsZSAoY3R4LmMgPCAxMjgpIHtcbiAgICAgIC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgICAgY3R4LmJbY3R4LmMrK10gPSAwO1xuICAgIH1cbiAgICBibGFrZTJiQ29tcHJlc3MoY3R4LCB0cnVlKTsgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICAgIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShjdHgub3V0bGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gY3R4LmhbaSA+PiAyXSA+PiAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHJldHVybiB7IEluaXQ6IGJsYWtlMmJJbml0LCBVcGRhdGU6IGJsYWtlMmJVcGRhdGUsIEZpbmFsOiBibGFrZTJiRmluYWwgfTtcbn0pKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxha2UyX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGJsYWtlMmJcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX2JsYWtlMl9jcmVhdGUoaGFzaGxlbiwga2V5KSB7XG4gIGtleSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKGtleSk7XG4gIGlmIChrZXkubGVuZ3RoID4gNjQpIHtcbiAgICBrZXkuc3ViYXJyYXkoMCwgNjQpO1xuICB9XG4gIHJldHVybiBibGFrZTJiLkluaXQoaGFzaGxlbiwga2V5KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGFrZTJfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBibGFrZTJiXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9ibGFrZTJfZmluYWwoY3R4LCBfaGFzaGxlbikge1xuICAvLyBjdHgub3V0bGVuID09PSBoYXNobGVuXG4gIHZhciByID0gYmxha2UyYi5GaW5hbChjdHgpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfdWludDhfYXJyYXkocik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxha2UyX3VwZGF0ZVxuLy9SZXF1aXJlczogYmxha2UyYlxuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vVmVyc2lvbjogPj0gNS4yLCA8IDUuM1xuZnVuY3Rpb24gY2FtbF9ibGFrZTJfdXBkYXRlKGN0eCwgYnVmLCBvZnMsIGxlbikge1xuICB2YXIgaW5wdXQgPSBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpbnB1dCA9IGlucHV0LnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKTtcbiAgYmxha2UyYi5VcGRhdGUoY3R4LCBpbnB1dCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsYWtlMl91cGRhdGVcbi8vUmVxdWlyZXM6IGJsYWtlMmJcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vVmVyc2lvbjogPj0gNS4zXG5mdW5jdGlvbiBjYW1sX2JsYWtlMl91cGRhdGUoY3R4LCBidWYsIG9mcywgbGVuKSB7XG4gIHZhciBpbnB1dCA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgaW5wdXQgPSBpbnB1dC5zdWJhcnJheShvZnMsIG9mcyArIGxlbik7XG4gIGJsYWtlMmIuVXBkYXRlKGN0eCwgaW5wdXQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGFrZTJfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsYWtlMl9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfYmxha2UyX3VwZGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ibGFrZTJfZmluYWxcbi8vVmVyc2lvbjogPj0gNS4yLCA8IDUuM1xuZnVuY3Rpb24gY2FtbF9ibGFrZTJfc3RyaW5nKGhhc2hsZW4sIGtleSwgYnVmLCBvZnMsIGxlbikge1xuICB2YXIgY3R4ID0gY2FtbF9ibGFrZTJfY3JlYXRlKGhhc2hsZW4sIGtleSk7XG4gIGNhbWxfYmxha2UyX3VwZGF0ZShjdHgsIGJ1Ziwgb2ZzLCBsZW4pO1xuICByZXR1cm4gY2FtbF9ibGFrZTJfZmluYWwoY3R4LCBoYXNobGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGFrZTJfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsYWtlMl9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfYmxha2UyX3VwZGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ibGFrZTJfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gY2FtbF9ibGFrZTJfc3RyaW5nKGhhc2hsZW4sIGtleSwgYnVmX3N0ciwgb2ZzLCBsZW4pIHtcbiAgdmFyIGN0eCA9IGNhbWxfYmxha2UyX2NyZWF0ZShoYXNobGVuLCBrZXkpO1xuICB2YXIgYnVmID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmX3N0cik7XG4gIGNhbWxfYmxha2UyX3VwZGF0ZShjdHgsIGJ1Ziwgb2ZzLCBsZW4pO1xuICByZXR1cm4gY2FtbF9ibGFrZTJfZmluYWwoY3R4LCBoYXNobGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGFrZTJfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYmxha2UyX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ibGFrZTJfdXBkYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2JsYWtlMl9maW5hbFxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfYmxha2UyX2J5dGVzKGhhc2hsZW4sIGtleSwgYnVmLCBvZnMsIGxlbikge1xuICB2YXIgY3R4ID0gY2FtbF9ibGFrZTJfY3JlYXRlKGhhc2hsZW4sIGtleSk7XG4gIGNhbWxfYmxha2UyX3VwZGF0ZShjdHgsIGJ1Ziwgb2ZzLCBsZW4pO1xuICByZXR1cm4gY2FtbF9ibGFrZTJfZmluYWwoY3R4LCBoYXNobGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmxha2UyX2pzX2Zvcl93YXNtX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ibGFrZTJfY3JlYXRlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiB3YXNtXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gYmxha2UyX2pzX2Zvcl93YXNtX2NyZWF0ZShoYXNobGVuLCBrZXkpIHtcbiAgY29uc3Qga2V5X2pzb29fc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhrZXkpO1xuICByZXR1cm4gY2FtbF9ibGFrZTJfY3JlYXRlKGhhc2hsZW4sIGtleV9qc29vX3N0cmluZyk7XG59XG5cbi8vUHJvdmlkZXM6IGJsYWtlMl9qc19mb3Jfd2FzbV9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9ibGFrZTJfZmluYWwsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IHdhc21cbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBibGFrZTJfanNfZm9yX3dhc21fZmluYWwoY3R4LCBoYXNobGVuKSB7XG4gIHJldHVybiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfYmxha2UyX2ZpbmFsKGN0eCwgaGFzaGxlbikpO1xufVxuXG4vL1Byb3ZpZGVzOiBibGFrZTJfanNfZm9yX3dhc21fdXBkYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2JsYWtlMl91cGRhdGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IHdhc21cbi8vVmVyc2lvbjogPj0gNS4yLCA8IDUuM1xuZnVuY3Rpb24gYmxha2UyX2pzX2Zvcl93YXNtX3VwZGF0ZShjdHgsIGJ1Ziwgb2ZzLCBsZW4pIHtcbiAgY29uc3QgYnVmX2pzb29fc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWYpO1xuICByZXR1cm4gY2FtbF9ibGFrZTJfdXBkYXRlKGN0eCwgYnVmX2pzb29fc3RyaW5nLCBvZnMsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJsYWtlMl9qc19mb3Jfd2FzbV91cGRhdGVcbi8vUmVxdWlyZXM6IGNhbWxfYmxha2UyX3VwZGF0ZSwgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiB3YXNtXG4vL1ZlcnNpb246ID49IDUuM1xuZnVuY3Rpb24gYmxha2UyX2pzX2Zvcl93YXNtX3VwZGF0ZShjdHgsIGJ1Ziwgb2ZzLCBsZW4pIHtcbiAgY29uc3QgYnVmX2pzb29fc3RyaW5nID0gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGJ1Zik7XG4gIHJldHVybiBjYW1sX2JsYWtlMl91cGRhdGUoY3R4LCBidWZfanNvb19zdHJpbmcsIG9mcywgbGVuKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl91aW50OF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsIHRvcmVhZCkge1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0MDk2KTtcbiAgaWYgKHRvcmVhZCA8IDApIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlYWQgPSBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoKTtcbiAgICAgIGlmIChyZWFkID09PSAwKSBicmVhaztcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCwgYnVmZmVyLnN1YmFycmF5KDAsIHJlYWQpLCByZWFkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHRvcmVhZCA+IDApIHtcbiAgICAgIHZhciByZWFkID0gY2FtbF9tbF9pbnB1dF9ibG9jayhcbiAgICAgICAgY2hhbmlkLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIHRvcmVhZCA+IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIubGVuZ3RoIDogdG9yZWFkLFxuICAgICAgKTtcbiAgICAgIGlmIChyZWFkID09PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gICAgICBjYW1sX01ENVVwZGF0ZShjdHgsIGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgICB0b3JlYWQgLT0gcmVhZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLCBvZnMsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG52YXIgY2FtbF9NRDVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQoeCwgeSkge1xuICAgIHJldHVybiAoeCArIHkpIHwgMDtcbiAgfVxuICBmdW5jdGlvbiB4eChxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICh+YiAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmIH5kKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4geHgoYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodywgYnVmZmVyKSB7XG4gICAgdmFyIGEgPSB3WzBdLFxuICAgICAgYiA9IHdbMV0sXG4gICAgICBjID0gd1syXSxcbiAgICAgIGQgPSB3WzNdO1xuXG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclswXSwgNywgMHhkNzZhYTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxXSwgMTIsIDB4ZThjN2I3NTYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMl0sIDE3LCAweDI0MjA3MGRiKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzNdLCAyMiwgMHhjMWJkY2VlZSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcls0XSwgNywgMHhmNTdjMGZhZik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcls1XSwgMTIsIDB4NDc4N2M2MmEpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbNl0sIDE3LCAweGE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzddLCAyMiwgMHhmZDQ2OTUwMSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcls4XSwgNywgMHg2OTgwOThkOCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcls5XSwgMTIsIDB4OGI0NGY3YWYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNywgMHhmZmZmNWJiMSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMV0sIDIyLCAweDg5NWNkN2JlKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNywgMHg2YjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxM10sIDEyLCAweGZkOTg3MTkzKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTcsIDB4YTY3OTQzOGUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTVdLCAyMiwgMHg0OWI0MDgyMSk7XG5cbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzFdLCA1LCAweGY2MWUyNTYyKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzZdLCA5LCAweGMwNDBiMzQwKTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWzExXSwgMTQsIDB4MjY1ZTVhNTEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbMF0sIDIwLCAweGU5YjZjN2FhKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzVdLCA1LCAweGQ2MmYxMDVkKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzEwXSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE0LCAweGQ4YTFlNjgxKTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWzRdLCAyMCwgMHhlN2QzZmJjOCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcls5XSwgNSwgMHgyMWUxY2RlNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNF0sIDksIDB4YzMzNzA3ZDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbM10sIDE0LCAweGY0ZDUwZDg3KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWzhdLCAyMCwgMHg0NTVhMTRlZCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDUsIDB4YTllM2U5MDUpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbMl0sIDksIDB4ZmNlZmEzZjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbN10sIDE0LCAweDY3NmYwMmQ5KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWzEyXSwgMjAsIDB4OGQyYTRjOGEpO1xuXG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcls1XSwgNCwgMHhmZmZhMzk0Mik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcls4XSwgMTEsIDB4ODc3MWY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNiwgMHg2ZDlkNjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNF0sIDIzLCAweGZkZTUzODBjKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWzFdLCA0LCAweGE0YmVlYTQ0KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzRdLCAxMSwgMHg0YmRlY2ZhOSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcls3XSwgMTYsIDB4ZjZiYjRiNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTBdLCAyMywgMHhiZWJmYmM3MCk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDQsIDB4Mjg5YjdlYzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbMF0sIDExLCAweGVhYTEyN2ZhKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWzNdLCAxNiwgMHhkNGVmMzA4NSk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcls2XSwgMjMsIDB4MDQ4ODFkMDUpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbOV0sIDQsIDB4ZDlkNGQwMzkpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbMTJdLCAxMSwgMHhlNmRiOTllNSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE2LCAweDFmYTI3Y2Y4KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzJdLCAyMywgMHhjNGFjNTY2NSk7XG5cbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzBdLCA2LCAweGY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzddLCAxMCwgMHg0MzJhZmY5Nyk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNF0sIDE1LCAweGFiOTQyM2E3KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzVdLCAyMSwgMHhmYzkzYTAzOSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsxMl0sIDYsIDB4NjU1YjU5YzMpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbM10sIDEwLCAweDhmMGNjYzkyKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTUsIDB4ZmZlZmY0N2QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbMV0sIDIxLCAweDg1ODQ1ZGQxKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzhdLCA2LCAweDZmYTg3ZTRmKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzE1XSwgMTAsIDB4ZmUyY2U2ZTApO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbNl0sIDE1LCAweGEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzEzXSwgMjEsIDB4NGUwODExYTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbNF0sIDYsIDB4Zjc1MzdlODIpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTFdLCAxMCwgMHhiZDNhZjIzNSk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsyXSwgMTUsIDB4MmFkN2QyYmIpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbOV0sIDIxLCAweGViODZkMzkxKTtcblxuICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gIH07XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENUluaXRcbmZ1bmN0aW9uIGNhbWxfTUQ1SW5pdCgpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig2NCk7XG4gIHZhciBiMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgdmFyIGI4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIHtcbiAgICBsZW46IDAsXG4gICAgdzogbmV3IFVpbnQzMkFycmF5KFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XSksXG4gICAgYjMyOiBiMzIsXG4gICAgYjg6IGI4LFxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENVVwZGF0ZVxuLy9SZXF1aXJlczogY2FtbF9NRDVUcmFuc2Zvcm1cbmZ1bmN0aW9uIGNhbWxfTUQ1VXBkYXRlKGN0eCwgaW5wdXQsIGlucHV0X2xlbikge1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIHZhciBpbnB1dF9wb3MgPSAwO1xuICBjdHgubGVuICs9IGlucHV0X2xlbjtcbiAgaWYgKGluX2J1Zikge1xuICAgIHZhciBtaXNzaW5nID0gNjQgLSBpbl9idWY7XG4gICAgaWYgKGlucHV0X2xlbiA8IG1pc3NpbmcpIHtcbiAgICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCwgaW5wdXRfbGVuKSwgaW5fYnVmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLCBtaXNzaW5nKSwgaW5fYnVmKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IG1pc3Npbmc7XG4gICAgaW5wdXRfcG9zICs9IG1pc3Npbmc7XG4gIH1cbiAgd2hpbGUgKGlucHV0X2xlbiA+PSA2NCkge1xuICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoaW5wdXRfcG9zLCBpbnB1dF9wb3MgKyA2NCksIDApO1xuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBpbnB1dF9sZW4gLT0gNjQ7XG4gICAgaW5wdXRfcG9zICs9IDY0O1xuICB9XG4gIGlmIChpbnB1dF9sZW4pXG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsIGlucHV0X3BvcyArIGlucHV0X2xlbiksIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENUZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX01ENVRyYW5zZm9ybVxuZnVuY3Rpb24gY2FtbF9NRDVGaW5hbChjdHgpIHtcbiAgdmFyIGluX2J1ZiA9IGN0eC5sZW4gJiAweDNmO1xuICBjdHguYjhbaW5fYnVmXSA9IDB4ODA7XG4gIGluX2J1ZisrO1xuICBpZiAoaW5fYnVmID4gNTYpIHtcbiAgICBmb3IgKHZhciBqID0gaW5fYnVmOyBqIDwgNjQ7IGorKykge1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTY7IGorKykge1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGluX2J1ZjsgaiA8IDU2OyBqKyspIHtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICB9XG4gIGN0eC5iMzJbMTRdID0gY3R4LmxlbiA8PCAzO1xuICBjdHguYjMyWzE1XSA9IChjdHgubGVuID4+IDI5KSAmIDB4MWZmZmZmZmY7XG4gIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKSB0W2kgKiA0ICsgal0gPSAoY3R4LndbaV0gPj4gKDggKiBqKSkgJiAweGZmO1xuICByZXR1cm4gdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9ieXRlcyhzLCBvZnMsIGxlbikge1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKTtcbiAgY2FtbF9NRDVVcGRhdGUoY3R4LCBhLnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKSwgbGVuKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX3VpbnQ4X2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG4iLCIvKlxuVG8gZGVhbCB3aXRoIGVmZmVjdHMsIHRoZSBleGVjdXRpb24gY29udGV4dCBpcyBpbnR1aXRpdmVseSBjb21wb3NlZCBvZlxuYSBzdGFjayBvZiBmaWJlcnMuIEVhY2ggZmliZXIgaGFzIGEgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4ob25lLWFyZ3VtZW50IEphdmFTY3JpcHQgZnVuY3Rpb24pLCBhIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmRcbmEgdHJpcGxlIG9mIGhhbmRsZXJzLCB3aGljaCBhcmUgaW52b2tlZCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzXG4oZWl0aGVyIHdpdGggYSB2YWx1ZSBvciBhbiBleGNlcHRpb24pIG9yIHdoZW4gYW4gZWZmZWN0IGlzIHBlcmZvcm1lZC5cblRoZSBsb3ctbGV2ZWwgY29udGludWF0aW9uIG9mIHRoZSB0b3Btb3N0IGZpYmVyICh3aGljaCBpcyBjdXJyZW50bHlcbmV4ZWN1dGluZykgaXMgcGFzc2VkIGZyb20gZnVuY3Rpb24gdG8gZnVuY3Rpb24gYXMgYW4gYWRkaXRpb25hbFxuYXJndW1lbnQuIEl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgaXMgc3RvcmVkIGluXG5bY2FtbF9jdXJyZW50X3N0YWNrLnhdLlxuRXhjZXB0aW9uIGhhbmRsZXJzIGFyZSBwdXNoZWQgaW50byB0aGlzIHN0YWNrXG53aGVuIGVudGVyaW5nIGEgW3RyeSAuLi4gd2l0aCAuLi5dIGFuZCBwb3BwZWQgb24gZXhpdC5cbkhhbmRsZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfY3VycmVudF9zdGFjay5oXVxuYW5kIHRoZSByZW1haW5pbmcgZmliZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfY3VycmVudF9zdGFjay5lXS5cblRvIGluc3RhbGwgYW4gZWZmZWN0IGhhbmRsZXIsIHdlIHB1c2ggYSBuZXcgZmliZXIgaW50byB0aGUgZXhlY3V0aW9uIGNvbnRleHQuXG5cbldlIGhhdmUgYmFzaWNhbGx5IHRoZSBmb2xsb3dpbmcgdHlwZSBmb3IgcmVpZmllZCBjb250aW51YXRpb25zICh0eXBlXG5bY29udGludWF0aW9uXSBpbiBtb2R1bGUgW0VmZmVjdF0gb2YgdGhlIHN0YW5kYXJkIGxpYnJhcnkpOlxuXG4gIHR5cGUgKCdhLCAnYikgY29udGludWF0aW9uID0gKCdhLCAnYikgc3RhY2sgcmVmXG5cbiAgYW5kIChfLCBfKSBzdGFjayA9XG4gICAgICBDb25zIDogKCdiIC0+IHVuaXQpICogICAgICAgICAgICAgKCogbG93LWxldmVsIGNvbnRpbnVhdGlvbiAqKVxuICAgICAgICAgICAgIChleG4gLT4gdW5pdCkgbGlzdCAqICAgICAgICgqIGV4Y2VwdGlvbiBoYW5kbGVycyAqKVxuICAgICAgICAgICAgICgnYiwgJ2MpIGhhbmRsZXIgKlxuICAgICAgICAgICAgICgnYSwgJ2IpIHN0YWNrXG4gICAgICAgICAgICAgLT4gKCdhLCAnYykgc3RhY2tcbiAgICB8IEVtcHR5IDogKCdhLCAnYSkgc3RhY2tcblxuICBhbmQgKCdhLCdiKSBoYW5kbGVyID0gICAoKiBBcyBpbiBtb2R1bGUgRWZmZWN0IGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgRWZmZWN0LnQgLT4gKCgnYywnYikgY29udGludWF0aW9uIC0+ICdiKSBvcHRpb24gfVxuXG5Db250aW51YXRpb25zIGFyZSBvbmUtc2hvdC4gQSBjb250aW51YXRpb24gW3JlZiBFbXB0eV0gaGFzIGFscmVhZHlcbmJlZW4gcmVzdW1lZC5cblxuQSBjb250aW51YXRpb24gaXMgYmFzaWNhbGx5IGNvbXBvc2VkIG9mIGEgbGlzdCBvZiBmaWJlcnMsIHdoaWNoIGVhY2hcbmhhcyBpdHMgbG93LWxldmVsIGNvbnRpbnVhdGlvbiwgaXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmQgYVxudHJpcGxlIG9mIGhhbmRsZXJzIHRvIGRlYWwgd2l0aCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzIG9yIGFuXG5lZmZlY3QgaXMgcGVyZm9ybWVkLiBXaGVuIHJlc3VtaW5nIGEgY29udGludWF0aW9uLCB0aGUgaW5uZXJtb3N0IGZpYmVyXG5pcyByZXN1bWVkIGZpcnN0LlxuXG5UaGUgaGFuZGxlcnMgYXJlIENQUy10cmFuc2Zvcm1lZCBmdW5jdGlvbnM6IHRoZXkgYWN0dWFsbHkgdGFrZSBhblxuYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIGN1cnJlbnQgbG93LWxldmVsIGNvbnRpbnVhdGlvbi5cbiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBoYXMgdGhlIHNoYXBlIHtrLCB4LCBoLCBlfSB3aGVyZVxuLy8gLSBoIGlzIGEgdHJpcGxlIG9mIGhhbmRsZXJzIChzZWUgZWZmZWN0Lm1sKVxuLy8gLSBrIGlzIHRoZSBsb3cgbGV2ZWwgY29udGludWF0aW9uXG4vLyAtIHggaXMgdGhlIGV4Y2VwdGlvbiBzdGFja1xuLy8gLSBlIGlzIHRoZSBmaWJlciBzdGFjayBvZiB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNhbWxfY3VycmVudF9zdGFjayA9IHsgazogMCwgeDogMCwgaDogMCwgZTogMCB9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1c2hfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3B1c2hfdHJhcChoYW5kbGVyKSB7XG4gIGNhbWxfY3VycmVudF9zdGFjay54ID0geyBoOiBoYW5kbGVyLCB0OiBjYW1sX2N1cnJlbnRfc3RhY2sueCB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX3RyYXAoKSB7XG4gIGlmICghY2FtbF9jdXJyZW50X3N0YWNrLngpXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aHJvdyB4O1xuICAgIH07XG4gIHZhciBoID0gY2FtbF9jdXJyZW50X3N0YWNrLnguaDtcbiAgY2FtbF9jdXJyZW50X3N0YWNrLnggPSBjYW1sX2N1cnJlbnRfc3RhY2sueC50O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV91bmhhbmRsZWRcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV91bmhhbmRsZWRfZWZmZWN0X2V4blxuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfdW5oYW5kbGVkKGVmZikge1xuICB2YXIgZXhuID0gY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuKGVmZik7XG4gIHRocm93IGV4bjtcbn1cblxuLy9Qcm92aWRlczpjYW1sX3Jlc3VtZV9zdGFja1xuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV9jb25zdGFudFxuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcmVzdW1lX3N0YWNrKHN0YWNrLCBsYXN0LCBrKSB7XG4gIGlmICghc3RhY2spXG4gICAgY2FtbF9yYWlzZV9jb25zdGFudChcbiAgICAgIGNhbWxfbmFtZWRfdmFsdWUoXCJFZmZlY3QuQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFwiKSxcbiAgICApO1xuICBpZiAobGFzdCA9PT0gMCkge1xuICAgIGxhc3QgPSBzdGFjaztcbiAgICAvLyBQcmUgT0NhbWwgNS4yLCBsYXN0IHdhcyBub3QgcG9wdWxhdGVkLlxuICAgIHdoaWxlIChsYXN0LmUgIT09IDApIGxhc3QgPSBsYXN0LmU7XG4gIH1cbiAgY2FtbF9jdXJyZW50X3N0YWNrLmsgPSBrO1xuICBsYXN0LmUgPSBjYW1sX2N1cnJlbnRfc3RhY2s7XG4gIGNhbWxfY3VycmVudF9zdGFjayA9IHN0YWNrO1xuICByZXR1cm4gc3RhY2suaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfZmliZXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcG9wX2ZpYmVyKCkge1xuICAvLyBNb3ZlIHRvIHRoZSBwYXJlbnQgZmliZXIsIHJldHVybmluZyB0aGUgcGFyZW50J3MgbG93LWxldmVsIGNvbnRpbnVhdGlvblxuICB2YXIgYyA9IGNhbWxfY3VycmVudF9zdGFjay5lO1xuICBjYW1sX2N1cnJlbnRfc3RhY2suZSA9IDA7XG4gIGNhbWxfY3VycmVudF9zdGFjayA9IGM7XG4gIHJldHVybiBjLms7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV91bmhhbmRsZWRfZWZmZWN0X2V4blxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9mcmVzaF9vb19pZFxuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbWFrZV91bmhhbmRsZWRfZWZmZWN0X2V4bihlZmYpIHtcbiAgdmFyIGV4biA9IGNhbWxfbmFtZWRfdmFsdWUoXCJFZmZlY3QuVW5oYW5kbGVkXCIpO1xuICBpZiAoZXhuKSBleG4gPSBbMCwgZXhuLCBlZmZdO1xuICBlbHNlIHtcbiAgICBleG4gPSBbXG4gICAgICAyNDgsXG4gICAgICBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSxcbiAgICAgIGNhbWxfZnJlc2hfb29faWQoMCksXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BlcmZvcm1fZWZmZWN0XG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVyblxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuLCBjYW1sX2N1cnJlbnRfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X2Nwc19mdW5cbi8vSWY6IGVmZmVjdHNcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX3BlcmZvcm1fZWZmZWN0KGVmZiwgazApIHtcbiAgaWYgKGNhbWxfY3VycmVudF9zdGFjay5lID09PSAwKSB7XG4gICAgdmFyIGV4biA9IGNhbWxfbWFrZV91bmhhbmRsZWRfZWZmZWN0X2V4bihlZmYpO1xuICAgIHRocm93IGV4bjtcbiAgfVxuICAvLyBHZXQgY3VycmVudCBlZmZlY3QgaGFuZGxlclxuICB2YXIgaGFuZGxlciA9IGNhbWxfY3VycmVudF9zdGFjay5oWzNdO1xuICB2YXIgbGFzdF9maWJlciA9IGNhbWxfY3VycmVudF9zdGFjaztcbiAgbGFzdF9maWJlci5rID0gazA7XG4gIHZhciBjb250ID0gWzI0NSAvKmNvbnRpbnVhdGlvbiovLCBsYXN0X2ZpYmVyLCBsYXN0X2ZpYmVyXTtcbiAgLy8gTW92ZSB0byBwYXJlbnQgZmliZXIgYW5kIGV4ZWN1dGUgdGhlIGVmZmVjdCBoYW5kbGVyIHRoZXJlXG4gIC8vIFRoZSBoYW5kbGVyIGlzIGRlZmluZWQgaW4gU3RkbGliLkVmZmVjdCwgc28gd2Uga25vdyB0aGF0IHRoZSBhcml0eSBtYXRjaGVzXG4gIHZhciBrMSA9IGNhbWxfcG9wX2ZpYmVyKCk7XG4gIHJldHVybiBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoKClcbiAgICA/IGNhbWxfZ2V0X2Nwc19mdW4oaGFuZGxlcikoZWZmLCBjb250LCBsYXN0X2ZpYmVyLCBrMSlcbiAgICA6IGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oaGFuZGxlciwgW2VmZiwgY29udCwgbGFzdF9maWJlciwgazFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZXBlcmZvcm1fZWZmZWN0XG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVyblxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuLCBjYW1sX2N1cnJlbnRfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfcmVzdW1lX3N0YWNrLCBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X2Nwc19mdW5cbi8vSWY6IGVmZmVjdHNcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX3JlcGVyZm9ybV9lZmZlY3QoZWZmLCBjb250LCBsYXN0LCBrMCkge1xuICBpZiAoY2FtbF9jdXJyZW50X3N0YWNrLmUgPT09IDApIHtcbiAgICB2YXIgZXhuID0gY2FtbF9tYWtlX3VuaGFuZGxlZF9lZmZlY3RfZXhuKGVmZik7XG4gICAgdmFyIHN0YWNrID0gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpO1xuICAgIGNhbWxfcmVzdW1lX3N0YWNrKHN0YWNrLCBsYXN0LCBrMCk7XG4gICAgdGhyb3cgZXhuO1xuICB9XG4gIC8vIEdldCBjdXJyZW50IGVmZmVjdCBoYW5kbGVyXG4gIHZhciBoYW5kbGVyID0gY2FtbF9jdXJyZW50X3N0YWNrLmhbM107XG4gIHZhciBsYXN0X2ZpYmVyID0gY2FtbF9jdXJyZW50X3N0YWNrO1xuICBsYXN0X2ZpYmVyLmsgPSBrMDtcbiAgbGFzdC5lID0gbGFzdF9maWJlcjtcbiAgY29udFsyXSA9IGxhc3RfZmliZXI7XG4gIC8vIE1vdmUgdG8gcGFyZW50IGZpYmVyIGFuZCBleGVjdXRlIHRoZSBlZmZlY3QgaGFuZGxlciB0aGVyZVxuICAvLyBUaGUgaGFuZGxlciBpcyBkZWZpbmVkIGluIFN0ZGxpYi5FZmZlY3QsIHNvIHdlIGtub3cgdGhhdCB0aGUgYXJpdHkgbWF0Y2hlc1xuICB2YXIgazEgPSBjYW1sX3BvcF9maWJlcigpO1xuICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpXG4gICAgPyBjYW1sX2dldF9jcHNfZnVuKGhhbmRsZXIpKGVmZiwgY29udCwgbGFzdF9maWJlciwgazEpXG4gICAgOiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGhhbmRsZXIsIFtlZmYsIGNvbnQsIGxhc3RfZmliZXIsIGsxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2Nwc19mdW5cbi8vSWY6IGVmZmVjdHNcbi8vSWY6ICFkb3VibGV0cmFuc2xhdGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X2Nwc19mdW4oZikge1xuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3BzX2Z1blxuLy9JZjogZWZmZWN0c1xuLy9JZjogZG91YmxldHJhbnNsYXRlXG5mdW5jdGlvbiBjYW1sX2dldF9jcHNfZnVuKGYpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgdG8gZ2V0IHRoZSBlZmZlY3QgaGFuZGxlci4gSWYgdGhlXG4gIC8vIGVmZmVjdCBoYW5kbGVyIGhhcyBubyBDUFMgZnVuY3Rpb24sIHdlIGtub3cgdGhhdCB3ZSBjYW4gZGlyZWN0bHlcbiAgLy8gY2FsbCB0aGUgZGlyZWN0IHZlcnNpb24gaW5zdGVhZC5cbiAgcmV0dXJuIGYuY3BzID8gZi5jcHMgOiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FsbG9jX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9jYWxsX2dlbiwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVyblxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbl9jcHMsIGNhbWxfY3VycmVudF9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2tfY2FsbChmLCB4KSB7XG4gIHZhciBhcmdzID0gW3gsIGNhbWxfcG9wX2ZpYmVyKCldO1xuICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpXG4gICAgPyBjYW1sX2NhbGxfZ2VuX2NwcyhmLCBhcmdzKVxuICAgIDogY2FtbF90cmFtcG9saW5lX3JldHVybihmLCBhcmdzLCAwKTtcbn1cbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2tfaHZhbCh4KSB7XG4gIC8vIENhbGwgW2h2XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gIHZhciBmID0gY2FtbF9jdXJyZW50X3N0YWNrLmhbMV07XG4gIHJldHVybiBjYW1sX2FsbG9jX3N0YWNrX2NhbGwoZiwgeCk7XG59XG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrX2hleG4oZSkge1xuICAvLyBDYWxsIFtoeF0gaW4gdGhlIHBhcmVudCBmaWJlclxuICB2YXIgZiA9IGNhbWxfY3VycmVudF9zdGFjay5oWzJdO1xuICByZXR1cm4gY2FtbF9hbGxvY19zdGFja19jYWxsKGYsIGUpO1xufVxuZnVuY3Rpb24gY2FtbF9hbGxvY19zdGFjayhodiwgaHgsIGhmKSB7XG4gIHZhciBoYW5kbGVycyA9IFswLCBodiwgaHgsIGhmXTtcbiAgcmV0dXJuIHtcbiAgICBrOiBjYW1sX2FsbG9jX3N0YWNrX2h2YWwsXG4gICAgeDogeyBoOiBjYW1sX2FsbG9jX3N0YWNrX2hleG4sIHQ6IDAgfSxcbiAgICBoOiBoYW5kbGVycyxcbiAgICBlOiAwLFxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FsbG9jX3N0YWNrXG4vL0lmOiAhZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soX2h2LCBfaHgsIF9oZikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpIHtcbiAgdmFyIHN0YWNrID0gY29udFsxXTtcbiAgY29udFsxXSA9IDA7XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4Y1xuLy9SZXF1aXJlczogY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4YyhcbiAgY29udCxcbiAgaHZhbCxcbiAgaGV4bixcbiAgaGVmZixcbikge1xuICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gIGlmIChzdGFjayA9PT0gMCkgcmV0dXJuIHN0YWNrO1xuICB2YXIgbGFzdCA9IGNvbnRbMl07XG4gIGxhc3QuaFsxXSA9IGh2YWw7XG4gIGxhc3QuaFsyXSA9IGhleG47XG4gIGxhc3QuaFszXSA9IGhlZmY7XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2soKSB7XG4gIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX25ld1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX25ldyhfdW5pdCkge1xuICByZXR1cm4geyBjb25kaXRpb246IDEgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fd2FpdFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX3dhaXQoX3QsIF9tdXRleHQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdChfdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKF90KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyFJZjogZWZmZWN0c1xuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWQoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJFZmZlY3QgaGFuZGxlcnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdW1lXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGgsIGNhbWxfY2FsbF9nZW5fY3BzLCBjYW1sX2N1cnJlbnRfc3RhY2ssIGNhbWxfd3JhcF9leGNlcHRpb24sIGNhbWxfcmVzdW1lX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG4vL0lmOiBkb3VibGV0cmFuc2xhdGVcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX3Jlc3VtZShmLCBhcmcsIHN0YWNrLCBsYXN0KSB7XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9jdXJyZW50X3N0YWNrID0gY2FtbF9jdXJyZW50X3N0YWNrO1xuICB0cnkge1xuICAgIGNhbWxfY3VycmVudF9zdGFjayA9IHsgazogMCwgeDogMCwgaDogMCwgZTogMCB9O1xuICAgIHZhciBrID0gY2FtbF9yZXN1bWVfc3RhY2soc3RhY2ssIGxhc3QsIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9KTtcbiAgICAvKiBOb3RlOiBmIGlzIG5vdCBhbiBvcmRpbmFyeSBmdW5jdGlvbiBidXQgYSAoZGlyZWN0LXN0eWxlLCBDUFMpIGNsb3N1cmUgcGFpciAqL1xuICAgIHZhciByZXMgPSB7IGpvb190cmFtcDogZiwgam9vX2FyZ3M6IFthcmcsIGtdLCBqb29fZGlyZWN0OiAwIH07XG4gICAgZG8ge1xuICAgICAgLyogQXZvaWRzIHRyYW1wb2xpbmluZyB0b28gb2Z0ZW4gd2hpbGUgc3RpbGwgYXZvaWRpbmcgc3RhY2sgb3ZlcmZsb3cuIFNlZVxuICAgICAgICAgW2NhbWxfY2FsbGJhY2tdLiAqL1xuICAgICAgY2FtbF9zdGFja19kZXB0aCA9IDQwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gcmVzLmpvb19kaXJlY3RcbiAgICAgICAgICA/IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKVxuICAgICAgICAgIDogY2FtbF9jYWxsX2dlbl9jcHMocmVzLmpvb190cmFtcCwgcmVzLmpvb19hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogSGFuZGxlIGV4Y2VwdGlvbiBjb21pbmcgZnJvbSBKYXZhU2NyaXB0IG9yIGZyb20gdGhlIHJ1bnRpbWUuICovXG4gICAgICAgIGlmICghY2FtbF9jdXJyZW50X3N0YWNrLngpIHRocm93IGU7XG4gICAgICAgIHZhciBoYW5kbGVyID0gY2FtbF9jdXJyZW50X3N0YWNrLnguaDtcbiAgICAgICAgY2FtbF9jdXJyZW50X3N0YWNrLnggPSBjYW1sX2N1cnJlbnRfc3RhY2sueC50O1xuICAgICAgICByZXMgPSB7XG4gICAgICAgICAgam9vX3RyYW1wOiBoYW5kbGVyLFxuICAgICAgICAgIGpvb19hcmdzOiBbY2FtbF93cmFwX2V4Y2VwdGlvbihlKV0sXG4gICAgICAgICAgam9vX2RpcmVjdDogMSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChyZXM/Lmpvb19hcmdzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGZpbmFsbHkge1xuICAgIGNhbWxfc3RhY2tfZGVwdGggPSBzYXZlZF9zdGFja19kZXB0aDtcbiAgICBjYW1sX2N1cnJlbnRfc3RhY2sgPSBzYXZlZF9jdXJyZW50X3N0YWNrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3BzX2Nsb3N1cmVcbi8vSWY6IGVmZmVjdHNcbi8vSWY6IGRvdWJsZXRyYW5zbGF0ZVxuZnVuY3Rpb24gY2FtbF9jcHNfY2xvc3VyZShkaXJlY3RfZiwgY3BzX2YpIHtcbiAgZGlyZWN0X2YuY3BzID0gY3BzX2Y7XG4gIHJldHVybiBkaXJlY3RfZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hc3N1bWVfbm9fcGVyZm9ybVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9JZjogIWRvdWJsZXRyYW5zbGF0ZVxuZnVuY3Rpb24gY2FtbF9hc3N1bWVfbm9fcGVyZm9ybShmKSB7XG4gIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFswXSk7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNcbi8vVmVyc2lvbjogPj0gNVxudmFyIGNhbWxfZG9tYWluX2RscyA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX3NldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19zZXQoYSkge1xuICBjYW1sX2RvbWFpbl9kbHMgPSBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfY29tcGFyZV9hbmRfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9kbHNfY29tcGFyZV9hbmRfc2V0KG9sZCwgbikge1xuICBpZiAoY2FtbF9kb21haW5fZGxzICE9PSBvbGQpIHJldHVybiAwO1xuICBjYW1sX2RvbWFpbl9kbHMgPSBuO1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX2dldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19nZXQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfZG9tYWluX2Rscztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfbG9hZFxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2F0b21pY19sb2FkKHJlZikge1xuICByZXR1cm4gcmVmWzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19sb2FkX2ZpZWxkXG4vL1ZlcnNpb246ID49IDUuNFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfbG9hZF9maWVsZChiLCBpKSB7XG4gIHJldHVybiBiW2kgKyAxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2NhcyhyZWYsIG8sIG4pIHtcbiAgaWYgKHJlZlsxXSA9PT0gbykge1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2Nhc19maWVsZFxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2Nhc19maWVsZChiLCBpLCBvLCBuKSB7XG4gIGlmIChiW2kgKyAxXSA9PT0gbykge1xuICAgIGJbaSArIDFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZmV0Y2hfYWRkXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2ZldGNoX2FkZChyZWYsIGkpIHtcbiAgdmFyIG9sZCA9IHJlZlsxXTtcbiAgcmVmWzFdICs9IGk7XG4gIHJldHVybiBvbGQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZF9maWVsZFxuLy9WZXJzaW9uOiA+PSA1LjRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2ZldGNoX2FkZF9maWVsZChiLCBpLCBuKSB7XG4gIHZhciBvbGQgPSBiW2kgKyAxXTtcbiAgYltpICsgMV0gKz0gbjtcbiAgcmV0dXJuIG9sZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2Vcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZXhjaGFuZ2UocmVmLCB2KSB7XG4gIHZhciByID0gcmVmWzFdO1xuICByZWZbMV0gPSB2O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2VfZmllbGRcbi8vVmVyc2lvbjogPj0gNS40XG5mdW5jdGlvbiBjYW1sX2F0b21pY19leGNoYW5nZV9maWVsZChiLCBpLCB2KSB7XG4gIHZhciByID0gYltpICsgMV07XG4gIGJbaSArIDFdID0gdjtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9hdG9taWNfbWFrZV9jb250ZW5kZWQoYSkge1xuICByZXR1cm4gWzAsIGFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5cbi8vVmVyc2lvbjogPj0gNS4wLCA8IDUuMlxudmFyIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl8gPSBbMF07XG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW4oX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50XG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50KF91bml0KSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9pbmRleFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vVmVyc2lvbjogPj0gNS4wM1xuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5faW5kZXgoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfZG9tYWluX2lkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9pZFxuLy9WZXJzaW9uOiA+PSA1XG52YXIgY2FtbF9kb21haW5faWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246ID49IDUuMlxudmFyIGNhbWxfZG9tYWluX2xhdGVzdF9pZHggPSAxO1xuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZiwgdGVybV9zeW5jKSB7XG4gIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgdmFyIG9sZCA9IGNhbWxfZG9tYWluX2lkO1xuICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLCBbMF0pO1xuICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgY2FtbF9tbF9tdXRleF91bmxvY2sodGVybV9zeW5jWzJdKTtcbiAgLy9UT0RPOiBmaXggZXhuIGNhc2VcbiAgdGVybV9zeW5jWzFdID0gWzAsIFswLCByZXNdXTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246ID49IDUuMCwgPCA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMTtcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX3NwYXduKGYsIG11dGV4KSB7XG4gIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgdmFyIG9sZCA9IGNhbWxfZG9tYWluX2lkO1xuICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICB2YXIgX3JlcyA9IGNhbWxfY2FsbGJhY2soZiwgWzBdKTtcbiAgY2FtbF9kb21haW5faWQgPSBvbGQ7XG4gIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKG11dGV4KTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl9pZFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vVmVyc2lvbjogPj0gNS4wXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9pZChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9kb21haW5faWQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheFxuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKVxuICAgIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpXG4gICAgcmV0dXJuIDEyNTI7IC8vIG9jYW1sIHN0cmluZyAoaWYgZGlmZmVyZW50IGZyb20gYnl0ZXMpXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgYVswXSA9PT0gYVswXSA+Pj4gMCAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiB0YWcgPT09IDI1NCA/IDAgOiB0YWc7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZylcbiAgICByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpXG4gICAgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGE/LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYT8uY29tcGFyZSlcbiAgICByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3ltYm9sXCIpIHJldHVybiAxMjUxO1xuICByZXR1cm4gMTAwMTsgLy9vdXRfb2ZfaGVhcF90YWdcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKSB7XG4gIHJldHVybiAoXG4gICAgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlXG4gICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmIChjb21wKSB7XG4gICAgdmFyIHggPSBzd2FwID4gMCA/IGNvbXAoY3VzdG9tLCBudW0sIHRvdGFsKSA6IGNvbXAobnVtLCBjdXN0b20sIHRvdGFsKTtcbiAgICBpZiAodG90YWwgJiYgTnVtYmVyLmlzTmFOKHgpKSByZXR1cm4gc3dhcDsgLy8gdG90YWwgJiYgbmFuXG4gICAgaWYgKE51bWJlci5pc05hTigreCkpIHJldHVybiAreDsgLy8gbmFuXG4gICAgaWYgKCh4IHwgMCkgIT09IDApIHJldHVybiB4IHwgMDsgLy8gIW5hblxuICB9XG4gIHJldHVybiBzd2FwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCEodG90YWwgJiYgYSA9PT0gYikpIHtcbiAgICAgIHZhciB0YWdfYSA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGEpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYgKHRhZ19hID09PSAyNTApIHtcbiAgICAgICAgYSA9IGFbMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmICh0YWdfYiA9PT0gMjUwKSB7XG4gICAgICAgIGIgPSBiWzFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZiAodGFnX2EgIT09IHRhZ19iKSB7XG4gICAgICAgIGlmICh0YWdfYSA9PT0gMTAwMCkge1xuICAgICAgICAgIGlmICh0YWdfYiA9PT0gMTI1NSkge1xuICAgICAgICAgICAgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdfYiA9PT0gMTAwMCkge1xuICAgICAgICAgIGlmICh0YWdfYSA9PT0gMTI1NSkge1xuICAgICAgICAgICAgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnX2EgPCB0YWdfYiA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIHRhZ19hID0gdGFnX2JcbiAgICAgIHN3aXRjaCAodGFnX2EpIHtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgICBjYXNlIDI0NzogLy8gQ2xvc3VyZV90YWdcbiAgICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDg6IC8vIE9iamVjdFxuICAgICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKSB8IDA7XG4gICAgICAgICAgaWYgKHggIT09IDApIHJldHVybiB4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1MTogLy9BYnN0cmFjdFxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTI6IC8vIE9DYW1sIGJ5dGVzXG4gICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpIHwgMDtcbiAgICAgICAgICAgIGlmICh4ICE9PSAwKSByZXR1cm4geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlfdGFnXG4gICAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBpbiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcbiAgICAgICAgICAgIFwiZXF1YWw6IGdvdCBEb3VibGVfYXJyYXlfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU1OiAvLyBDdXN0b21fdGFnXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjQ3OiAvLyBGdW5jdGlvblxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI1NTogLy8gQ3VzdG9tXG4gICAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgICAgaWYgKGNvbXAgIT09IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuY2FtbF9jdXN0b20gPCBiLmNhbWxfY3VzdG9tID8gLTEgOiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbXApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICAgIHZhciB4ID0gY29tcChhLCBiLCB0b3RhbCk7XG4gICAgICAgICAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgICByZXR1cm4gdG90YWwgPyAtMSA6IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4ICE9PSAoeCB8IDApKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHggIT09IDApIHJldHVybiB4IHwgMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYiwgdG90YWwpO1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsID8gLTEgOiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeCAhPT0gKHggfCAwKSkge1xuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4ICE9PSAwKSByZXR1cm4geCB8IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgICAgYSA9ICthO1xuICAgICAgICAgIGIgPSArYjtcbiAgICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGEpKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGIpKSByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMDE6IC8vIFRoZSByZXN0XG4gICAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAgIC8vIDIuIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICgzKSB3aWxsIHJhaXNlIGEgW1R5cGVFcnJvcl1cbiAgICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgICAgLy8gLSBpZiBhIGFuZCBiIGFyZSBzdHJpbmdzLCBhcHBseSBsZXhpY29ncmFwaGljIGNvbXBhcmlzb25cbiAgICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsID8gMSA6IE51bWJlci5OYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsID8gMSA6IE51bWJlci5OYU47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgICAgdmFyIGIgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGIpO1xuICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyNTIwOiAvLyBqYXZhc2NyaXB0IHN0cmluZ3NcbiAgICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gTGF6eV90YWcgb3IgQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgICBpZiAoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHRhZ19hKSkge1xuICAgICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBhLmxlbmd0aCA8IGIubGVuZ3RoID8gLTEgOiAxO1xuICAgICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUoYSwgYikge1xuICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbChhLCBiLCB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBjb25zdFxuLy9BbGlhczogY2FtbF9pbnQzMl9jb21wYXJlXG4vL0FsaWFzOiBjYW1sX25hdGl2ZWludF9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gIGlmIChhID09PSBiKSByZXR1cm4gMDtcbiAgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwoeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSA9PT0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwoeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSAhPT0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCh4LCB5KSB7XG4gIHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCwgeSwgZmFsc2UpID49IDApO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuKHgsIHkpIHtcbiAgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LCB5LCBmYWxzZSkgPiAwKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsKHgsIHkpIHtcbiAgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LCB5LCBmYWxzZSkgPD0gMCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4oeCwgeSkge1xuICByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgsIHksIGZhbHNlKSA8IDApO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9jc2VsX3ZhbHVlXG5mdW5jdGlvbiBjYW1sX2NzZWxfdmFsdWUodl9jb25kLCB2X3RydWUsIHZfZmFsc2UpIHtcbiAgaWYgKHZfY29uZClcbiAgICByZXR1cm4gdl90cnVlO1xuICBlbHNlXG4gICAgcmV0dXJuIHZfZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3NlMl9mbG9hdDY0X21pbl9ieXRlY29kZVxuZnVuY3Rpb24gY2FtbF9zc2UyX2Zsb2F0NjRfbWluX2J5dGVjb2RlKHgsIHkpIHtcbiAgcmV0dXJuIHggPCB5ID8geCA6IHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3NlMl9mbG9hdDY0X21heF9ieXRlY29kZVxuZnVuY3Rpb24gY2FtbF9zc2UyX2Zsb2F0NjRfbWF4X2J5dGVjb2RlKHgsIHkpIHtcbiAgcmV0dXJuIHggPiB5ID8geCA6IHk7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9ldmVudF9pbmRleFxuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZWdpc3RlclxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fZXZlbnRfaW5kZXhcbi8vVmVyc2lvbjogPj0gNS4xXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVnaXN0ZXIoZXZlbnRfbmFtZSwgZXZlbnRfdGFnLCBldmVudF90eXBlKSB7XG4gIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4ICs9IDE7XG4gIHJldHVybiBbMCwgY2FtbF9jdXN0b21fZXZlbnRfaW5kZXgsIGV2ZW50X25hbWUsIGV2ZW50X3R5cGUsIGV2ZW50X3RhZ107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZVxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZShfZXZlbnQsIF9ldmVudF9jb250ZW50KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZVxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX2V2ZW50c19zdGFydFxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfc3RhcnQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3N0YXJ0XG4vL1ZlcnNpb246ID49IDUuMCwgPCA1LjJcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfc3RhcnQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3BhdXNlXG4vL1ZlcnNpb246ID49IDUuMlxuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX2V2ZW50c19wYXVzZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfcGF1c2Vcbi8vVmVyc2lvbjogPj0gNS4wLCA8IDUuMlxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19wYXVzZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZVxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfYXJlX2FjdGl2ZSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfcmVzdW1lXG4vL1ZlcnNpb246ID49NS4wLCA8IDUuMlxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZVxuLy9WZXJzaW9uOiA+PSA1LjJcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfcmVzdW1lKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19jcmVhdGVfY3Vyc29yXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19jcmVhdGVfY3Vyc29yKF90YXJnZXQpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yXG4vL1ZlcnNpb246ID49IDUuMFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19mcmVlX2N1cnNvcihfY3Vyc29yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3JlYWRfcG9sbFxuLy9WZXJzaW9uOiA+PSA1LjBcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKF9jdXJzb3IsIF9jYWxsYmFja3MsIF9udW0pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV9ldmVudHNfcGF0aCBjb25zdFxuLy9WZXJzaW9uOiA+PSA1LjNcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV9ldmVudHNfcGF0aChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vUHJvdmlkZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxuICB2YXIgYWIgPSBBcnJheUJ1ZmZlcixcbiAgICB1OCA9IFVpbnQ4QXJyYXksXG4gICAgdTE2ID0gVWludDE2QXJyYXksXG4gICAgaTE2ID0gSW50MTZBcnJheSxcbiAgICBpMzIgPSBJbnQzMkFycmF5O1xuICB2YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLnNsaWNlKSByZXR1cm4gdTgucHJvdG90eXBlLnNsaWNlLmNhbGwodiwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMCkgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpIGUgPSB2Lmxlbmd0aDtcbiAgICB2YXIgbiA9IG5ldyB1OChlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG4gIH07XG4gIHZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKSBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xuICB9O1xuICB2YXIgY3B3ID0gZnVuY3Rpb24gKHYsIHQsIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmNvcHlXaXRoaW4pXG4gICAgICByZXR1cm4gdTgucHJvdG90eXBlLmNvcHlXaXRoaW4uY2FsbCh2LCB0LCBzLCBlKTtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKSBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aCkgZSA9IHYubGVuZ3RoO1xuICAgIHdoaWxlIChzIDwgZSkge1xuICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAgICovXG4gIC8vIGVycm9yIGNvZGVzXG4gIHZhciBlYyA9IFtcbiAgICBcImludmFsaWQgenN0ZCBkYXRhXCIsXG4gICAgXCJ3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpXCIsXG4gICAgXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcbiAgICBcIkZTRSBhY2N1cmFjeSB0b28gaGlnaFwiLFxuICAgIFwibWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrXCIsXG4gICAgXCJ1bmV4cGVjdGVkIEVPRlwiLFxuICBdO1xuICB2YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKCFudCkgdGhyb3cgZTtcbiAgICByZXR1cm4gZTtcbiAgfTtcbiAgdmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICBvID0gMDtcbiAgICBmb3IgKDsgaSA8IG47ICsraSkgbyB8PSBkW2IrK10gPDwgKGkgPDwgMyk7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgcmV0dXJuIChkW2JdIHwgKGRbYiArIDFdIDw8IDgpIHwgKGRbYiArIDJdIDw8IDE2KSB8IChkW2IgKyAzXSA8PCAyNCkpID4+PiAwO1xuICB9O1xuICAvLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbiAgdmFyIHJ6ZmggPSBmdW5jdGlvbiAoZGF0LCB3KSB7XG4gICAgdmFyIG4zID0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSB8IChkYXRbMl0gPDwgMTYpO1xuICAgIGlmIChuMyA9PT0gMHgyZmI1MjggJiYgZGF0WzNdID09PSAyNTMpIHtcbiAgICAgIC8vIFpzdGFuZGFyZFxuICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgIC8vICAgIHNpbmdsZSBzZWdtZW50ICAgICAgIGNoZWNrc3VtICAgICAgICAgICAgIGRpY3QgZmxhZyAgICAgZnJhbWUgY29udGVudCBmbGFnXG4gICAgICB2YXIgc3MgPSAoZmxnID4+IDUpICYgMSxcbiAgICAgICAgY2MgPSAoZmxnID4+IDIpICYgMSxcbiAgICAgICAgZGYgPSBmbGcgJiAzLFxuICAgICAgICBmY2YgPSBmbGcgPj4gNjtcbiAgICAgIGlmIChmbGcgJiA4KSBlcnIoMCk7XG4gICAgICAvLyBieXRlXG4gICAgICB2YXIgYnQgPSA2IC0gc3M7XG4gICAgICAvLyBkaWN0IGJ5dGVzXG4gICAgICB2YXIgZGIgPSBkZiA9PT0gMyA/IDQgOiBkZjtcbiAgICAgIC8vIGRpY3Rpb25hcnkgaWRcbiAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgIGJ0ICs9IGRiO1xuICAgICAgLy8gZnJhbWUgc2l6ZSBieXRlc1xuICAgICAgdmFyIGZzYiA9IGZjZiA/IDEgPDwgZmNmIDogc3M7XG4gICAgICAvLyBmcmFtZSBzb3VyY2Ugc2l6ZVxuICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoZmNmID09PSAxICYmIDI1Nik7XG4gICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgdmFyIHdzID0gZnNzO1xuICAgICAgaWYgKCFzcykge1xuICAgICAgICAvLyB3aW5kb3cgZGVzY3JpcHRvclxuICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICB3cyA9IHdiICsgKHdiID4+IDMpICogKGRhdFs1XSAmIDcpO1xuICAgICAgfVxuICAgICAgaWYgKHdzID4gMjE0NTM4NjQ5NikgZXJyKDEpO1xuICAgICAgdmFyIGJ1ZiA9IG5ldyB1OCgodyA9PT0gMSA/IGZzcyB8fCB3cyA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgKGJ1ZlswXSA9IDEpLCAoYnVmWzRdID0gNCksIChidWZbOF0gPSA4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGI6IGJ0ICsgZnNiLFxuICAgICAgICB5OiAwLFxuICAgICAgICBsOiAwLFxuICAgICAgICBkOiBkaSxcbiAgICAgICAgdzogdyAmJiB3ICE9PSAxID8gdyA6IGJ1Zi5zdWJhcnJheSgxMiksXG4gICAgICAgIGU6IHdzLFxuICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICB1OiBmc3MsXG4gICAgICAgIGM6IGNjLFxuICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09PSAweDE4NGQyYTUpIHtcbiAgICAgIC8vIHNraXBwYWJsZVxuICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG4gIH07XG4gIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGZvciBub256ZXJvXG4gIHZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAxIDw8IGJpdHMgPD0gdmFsOyArK2JpdHMpO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbiAgfTtcbiAgLy8gcmVhZCBmaW5pdGUgc3RhdGUgZW50cm9weVxuICB2YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbCkgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LFxuICAgICAgc3ltID0gLTEsXG4gICAgICByZSA9IC0xLFxuICAgICAgaSA9IC0xLFxuICAgICAgaHQgPSBzejtcbiAgICAvLyBvcHRpbWl6YXRpb246IHNpbmdsZSBhbGxvY2F0aW9uIGlzIG11Y2ggZmFzdGVyXG4gICAgdmFyIGJ1ZiA9IG5ldyBhYig1MTIgKyAoc3ogPDwgMikpO1xuICAgIHZhciBmcmVxID0gbmV3IGkxNihidWYsIDAsIDI1Nik7XG4gICAgLy8gc2FtZSB2aWV3IGFzIGZyZXFcbiAgICB2YXIgZHN0YXRlID0gbmV3IHUxNihidWYsIDAsIDI1Nik7XG4gICAgdmFyIG5zdGF0ZSA9IG5ldyB1MTYoYnVmLCA1MTIsIHN6KTtcbiAgICB2YXIgYmIxID0gNTEyICsgKHN6IDw8IDEpO1xuICAgIHZhciBzeW1zID0gbmV3IHU4KGJ1ZiwgYmIxLCBzeik7XG4gICAgdmFyIG5iaXRzID0gbmV3IHU4KGJ1ZiwgYmIxICsgc3opO1xuICAgIHdoaWxlIChzeW0gPCAyNTUgJiYgcHJvYnMgPiAwKSB7XG4gICAgICB2YXIgYml0cyA9IG1zYihwcm9icyArIDEpO1xuICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgIC8vIG1hc2tcbiAgICAgIHZhciBtc2sgPSAoMSA8PCAoYml0cyArIDEpKSAtIDE7XG4gICAgICB2YXIgdmFsID1cbiAgICAgICAgKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj5cbiAgICAgICAgICAodHBvcyAmIDcpKSAmXG4gICAgICAgIG1zaztcbiAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgdmFyIG1zazFmYiA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICAgIC8vIG1heCBzbWFsbCB2YWx1ZVxuICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgIC8vIHNtYWxsIHZhbHVlXG4gICAgICB2YXIgc3ZhbCA9IHZhbCAmIG1zazFmYjtcbiAgICAgIGlmIChzdmFsIDwgbXN2KSAodHBvcyArPSBiaXRzKSwgKHZhbCA9IHN2YWwpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgIGlmICh2YWwgPiBtc2sxZmIpIHZhbCAtPSBtc3Y7XG4gICAgICB9XG4gICAgICBmcmVxWysrc3ltXSA9IC0tdmFsO1xuICAgICAgaWYgKHZhbCA9PT0gLTEpIHtcbiAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICBzeW1zWy0taHRdID0gc3ltO1xuICAgICAgfSBlbHNlIHByb2JzIC09IHZhbDtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyByZXBlYXQgYnl0ZVxuICAgICAgICAgIHZhciByYnQgPSB0cG9zID4+IDM7XG4gICAgICAgICAgcmUgPSAoKGRhdFtyYnRdIHwgKGRhdFtyYnQgKyAxXSA8PCA4KSkgPj4gKHRwb3MgJiA3KSkgJiAzO1xuICAgICAgICAgIHRwb3MgKz0gMjtcbiAgICAgICAgICBzeW0gKz0gcmU7XG4gICAgICAgIH0gd2hpbGUgKHJlID09PSAzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icykgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgdmFyIHNmID0gZnJlcVtzXTtcbiAgICAgIGlmIChzZiA8IDEpIHtcbiAgICAgICAgZHN0YXRlW3NdID0gLXNmO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgc3BsaXQgaW50byB0d28gbG9vcHMgaW4genN0ZCB0byBhdm9pZCBicmFuY2hpbmcsIGJ1dCBhcyBKUyBpcyBoaWdoZXItbGV2ZWwgdGhhdCBpcyB1bm5lY2Vzc2FyeVxuICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgc3ltc1tzeW1wb3NdID0gcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN5bXBvcyA9IChzeW1wb3MgKyBzc3RlcCkgJiBzbWFzaztcbiAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWZ0ZXIgc3ByZWFkaW5nIHN5bWJvbHMsIHNob3VsZCBiZSB6ZXJvIGFnYWluXG4gICAgaWYgKHN5bXBvcykgZXJyKDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzejsgKytpKSB7XG4gICAgICAvLyBuZXh0IHN0YXRlXG4gICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgIC8vIG51bSBiaXRzXG4gICAgICB2YXIgbmIgPSAobmJpdHNbaV0gPSBhbCAtIG1zYihucykpO1xuICAgICAgbnN0YXRlW2ldID0gKG5zIDw8IG5iKSAtIHN6O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgKHRwb3MgKyA3KSA+PiAzLFxuICAgICAge1xuICAgICAgICBiOiBhbCxcbiAgICAgICAgczogc3ltcyxcbiAgICAgICAgbjogbmJpdHMsXG4gICAgICAgIHQ6IG5zdGF0ZSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfTtcbiAgLy8gcmVhZCBodWZmbWFuXG4gIHZhciByaHUgPSBmdW5jdGlvbiAoZGF0LCBidCkge1xuICAgIC8vICBpbmRleCAgd2VpZ2h0IGNvdW50XG4gICAgdmFyIGkgPSAwLFxuICAgICAgd2MgPSAtMTtcbiAgICAvLyAgICBidWZmZXIgICAgICAgICAgICAgaGVhZGVyIGJ5dGVcbiAgICB2YXIgYnVmID0gbmV3IHU4KDI5MiksXG4gICAgICBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAvLyBlbmQgYnl0ZSwgZnNlIGRlY29kZSB0YWJsZVxuICAgICAgdmFyIF9hID0gcmZzZShkYXQsIGJ0ICsgMSwgNiksXG4gICAgICAgIGVidCA9IF9hWzBdLFxuICAgICAgICBmZHQgPSBfYVsxXTtcbiAgICAgIGJ0ICs9IGhiO1xuICAgICAgdmFyIGVwb3MgPSBlYnQgPDwgMztcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgIGlmICghbGIpIGVycigwKTtcbiAgICAgIC8vICBzdGF0ZTEgICBzdGF0ZTIgICBzdGF0ZTEgYml0cyAgIHN0YXRlMiBiaXRzXG4gICAgICB2YXIgc3QxID0gMCxcbiAgICAgICAgc3QyID0gMCxcbiAgICAgICAgYnRyMSA9IGZkdC5iLFxuICAgICAgICBidHIyID0gYnRyMTtcbiAgICAgIC8vIGZzZSBwb3NcbiAgICAgIC8vIHByZS1pbmNyZW1lbnQgdG8gYWNjb3VudCBmb3Igb3JpZ2luYWwgZGVmaWNpdCBvZiAxXG4gICAgICB2YXIgZnBvcyA9ICgrK2J0IDw8IDMpIC0gOCArIG1zYihsYik7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGZwb3MgLT0gYnRyMTtcbiAgICAgICAgaWYgKGZwb3MgPCBlcG9zKSBicmVhaztcbiAgICAgICAgdmFyIGNidCA9IGZwb3MgPj4gMztcbiAgICAgICAgc3QxICs9XG4gICAgICAgICAgKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChmcG9zICYgNykpICYgKCgxIDw8IGJ0cjEpIC0gMSk7XG4gICAgICAgIGh3Wysrd2NdID0gZmR0LnNbc3QxXTtcbiAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICBpZiAoZnBvcyA8IGVwb3MpIGJyZWFrO1xuICAgICAgICBjYnQgPSBmcG9zID4+IDM7XG4gICAgICAgIHN0MiArPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICBod1srK3djXSA9IGZkdC5zW3N0Ml07XG4gICAgICAgIGJ0cjEgPSBmZHQubltzdDFdO1xuICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICBidHIyID0gZmR0Lm5bc3QyXTtcbiAgICAgICAgc3QyID0gZmR0LnRbc3QyXTtcbiAgICAgIH1cbiAgICAgIGlmICgrK3djID4gMjU1KSBlcnIoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdjID0gaGIgLSAxMjc7XG4gICAgICBmb3IgKDsgaSA8IHdjOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBkYXRbKytidF07XG4gICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICBod1tpICsgMV0gPSBieXRlICYgMTU7XG4gICAgICB9XG4gICAgICArK2J0O1xuICAgIH1cbiAgICAvLyB3ZWlnaHQgZXhwb25lbnRpYWwgc3VtXG4gICAgdmFyIHdlcyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICAgIHZhciB3dCA9IGh3W2ldO1xuICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICBpZiAod3QgPiAxMSkgZXJyKDApO1xuICAgICAgd2VzICs9IHd0ICYmIDEgPDwgKHd0IC0gMSk7XG4gICAgfVxuICAgIC8vIG1heCBiaXRzXG4gICAgdmFyIG1iID0gbXNiKHdlcykgKyAxO1xuICAgIC8vIHRhYmxlIHNpemVcbiAgICB2YXIgdHMgPSAxIDw8IG1iO1xuICAgIC8vIHJlbWFpbmluZyBzdW1cbiAgICB2YXIgcmVtID0gdHMgLSB3ZXM7XG4gICAgLy8gbXVzdCBiZSBwb3dlciBvZiAyXG4gICAgaWYgKHJlbSAmIChyZW0gLSAxKSkgZXJyKDApO1xuICAgIGh3W3djKytdID0gbXNiKHJlbSkgKyAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICsrcmNbKGh3W2ldID0gd3QgJiYgbWIgKyAxIC0gd3QpXTtcbiAgICB9XG4gICAgLy8gaHVmIGJ1ZlxuICAgIHZhciBoYnVmID0gbmV3IHU4KHRzIDw8IDEpO1xuICAgIC8vICAgIHN5bWJvbHMgICAgICAgICAgICAgICAgICAgICAgbnVtIGJpdHNcbiAgICB2YXIgc3ltcyA9IGhidWYuc3ViYXJyYXkoMCwgdHMpLFxuICAgICAgbmIgPSBoYnVmLnN1YmFycmF5KHRzKTtcbiAgICByaVttYl0gPSAwO1xuICAgIGZvciAoaSA9IG1iOyBpID4gMDsgLS1pKSB7XG4gICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgIGZpbGwobmIsIGksIHB2LCAocmlbaSAtIDFdID0gcHYgKyByY1tpXSAqICgxIDw8IChtYiAtIGkpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT09IHRzKSBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICAgIHZhciBiaXRzID0gaHdbaV07XG4gICAgICBpZiAoYml0cykge1xuICAgICAgICB2YXIgY29kZSA9IHJpW2JpdHNdO1xuICAgICAgICBmaWxsKHN5bXMsIGksIGNvZGUsIChyaVtiaXRzXSA9IGNvZGUgKyAoMSA8PCAobWIgLSBiaXRzKSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGJ0LFxuICAgICAge1xuICAgICAgICBuOiBuYixcbiAgICAgICAgYjogbWIsXG4gICAgICAgIHM6IHN5bXMsXG4gICAgICB9LFxuICAgIF07XG4gIH07XG4gIC8vIFRhYmxlcyBnZW5lcmF0ZWQgdXNpbmcgdGhpczpcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAxYXJyb3d6L2E5Nzk0NTJkNDM1NTk5MmNiZjhmMjU3Y2JmZmM5ZWRkXG4gIC8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbiAgdmFyIGRsbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgICAgODEsIDE2LCA5OSwgMTQwLCA0OSwgMTk4LCAyNCwgOTksIDEyLCAzMywgMTk2LCAyNCwgOTksIDEwMiwgMTAyLCAxMzQsIDcwLFxuICAgICAgMTQ2LCA0LFxuICAgIF0pLFxuICAgIDAsXG4gICAgNixcbiAgKVsxXTtcbiAgLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbiAgdmFyIGRtbHQgPSAvKiNfX1BVUkVfXyovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoW1xuICAgICAgMzMsIDIwLCAxOTYsIDI0LCA5OSwgMTQwLCAzMywgMTMyLCAxNiwgNjYsIDgsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDY4LFxuICAgICAgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA5LFxuICAgIF0pLFxuICAgIDAsXG4gICAgNixcbiAgKVsxXTtcbiAgLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxuICB2YXIgZG9jdCA9IC8qI19fUFVSRV9fICovIHJmc2UoXG4gICAgLyojX19QVVJFX18qLyBuZXcgdTgoWzMyLCAxMzIsIDE2LCA2NiwgMTAyLCA3MCwgNjgsIDY4LCA2OCwgNjgsIDM2LCA3MywgMl0pLFxuICAgIDAsXG4gICAgNSxcbiAgKVsxXTtcbiAgLy8gYml0cyB0byBiYXNlbGluZVxuICB2YXIgYjJibCA9IGZ1bmN0aW9uIChiLCBzKSB7XG4gICAgdmFyIGxlbiA9IGIubGVuZ3RoLFxuICAgICAgYmwgPSBuZXcgaTMyKGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgYmxbaV0gPSBzO1xuICAgICAgcyArPSAxIDw8IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBibDtcbiAgfTtcbiAgLy8gbGl0ZXJhbCBsZW5ndGggYml0c1xuICB2YXIgbGxiID0gLyojX19QVVJFX18gKi8gbmV3IHU4KFxuICAgIC8qI19fUFVSRV9fICovIG5ldyBpMzIoW1xuICAgICAgMCwgMCwgMCwgMCwgMTY4NDMwMDksIDUwNTI4NzcwLCAxMzQ2NzgwMjAsIDIwMjA1MDA1NywgMjY5NDIyMDkzLFxuICAgIF0pLmJ1ZmZlcixcbiAgICAwLFxuICAgIDM2LFxuICApO1xuICAvLyBsaXRlcmFsIGxlbmd0aCBiYXNlbGluZVxuICB2YXIgbGxibCA9IC8qI19fUFVSRV9fICovIGIyYmwobGxiLCAwKTtcbiAgLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbiAgdmFyIG1sYiA9IC8qI19fUFVSRV9fICovIG5ldyB1OChcbiAgICAvKiNfX1BVUkVfXyAqLyBuZXcgaTMyKFtcbiAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsXG4gICAgICAyNTI1NzkwODQsIDE2LFxuICAgIF0pLmJ1ZmZlcixcbiAgICAwLFxuICAgIDUzLFxuICApO1xuICAvLyBtYXRjaCBsZW5ndGggYmFzZWxpbmVcbiAgdmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4gIC8vIGRlY29kZSBodWZmbWFuIHN0cmVhbVxuICB2YXIgZGh1ID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBodSkge1xuICAgIHZhciBsZW4gPSBkYXQubGVuZ3RoLFxuICAgICAgc3MgPSBvdXQubGVuZ3RoLFxuICAgICAgbGIgPSBkYXRbbGVuIC0gMV0sXG4gICAgICBtc2sgPSAoMSA8PCBodS5iKSAtIDEsXG4gICAgICBlYiA9IC1odS5iO1xuICAgIGlmICghbGIpIGVycigwKTtcbiAgICB2YXIgc3QgPSAwLFxuICAgICAgYnRyID0gaHUuYixcbiAgICAgIHBvcyA9IChsZW4gPDwgMykgLSA4ICsgbXNiKGxiKSAtIGJ0cixcbiAgICAgIGkgPSAtMTtcbiAgICB3aGlsZSAocG9zID4gZWIgJiYgaSA8IHNzKSB7XG4gICAgICB2YXIgY2J0ID0gcG9zID4+IDM7XG4gICAgICB2YXIgdmFsID1cbiAgICAgICAgKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICBzdCA9ICgoc3QgPDwgYnRyKSB8IHZhbCkgJiBtc2s7XG4gICAgICBvdXRbKytpXSA9IGh1LnNbc3RdO1xuICAgICAgcG9zIC09IGJ0ciA9IGh1Lm5bc3RdO1xuICAgIH1cbiAgICBpZiAocG9zICE9PSBlYiB8fCBpICsgMSAhPT0gc3MpIGVycigwKTtcbiAgfTtcbiAgLy8gZGVjb2RlIGh1ZmZtYW4gc3RyZWFtIDR4XG4gIC8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG4gIHZhciBkaHU0ID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBodSkge1xuICAgIHZhciBidCA9IDY7XG4gICAgdmFyIHNzID0gb3V0Lmxlbmd0aCxcbiAgICAgIHN6MSA9IChzcyArIDMpID4+IDIsXG4gICAgICBzejIgPSBzejEgPDwgMSxcbiAgICAgIHN6MyA9IHN6MSArIHN6MjtcbiAgICBkaHUoXG4gICAgICBkYXQuc3ViYXJyYXkoYnQsIChidCArPSBkYXRbMF0gfCAoZGF0WzFdIDw8IDgpKSksXG4gICAgICBvdXQuc3ViYXJyYXkoMCwgc3oxKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KFxuICAgICAgZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSkpLFxuICAgICAgb3V0LnN1YmFycmF5KHN6MSwgc3oyKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KFxuICAgICAgZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gZGF0WzRdIHwgKGRhdFs1XSA8PCA4KSkpLFxuICAgICAgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSxcbiAgICAgIGh1LFxuICAgICk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCksIG91dC5zdWJhcnJheShzejMpLCBodSk7XG4gIH07XG4gIC8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG4gIHZhciByemIgPSBmdW5jdGlvbiAoZGF0LCBzdCwgb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBidCA9IHN0LmI7XG4gICAgLy8gICAgYnl0ZSAwICAgICAgICBibG9jayB0eXBlXG4gICAgdmFyIGIwID0gZGF0W2J0XSxcbiAgICAgIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGJ0ID49IGRhdC5sZW5ndGgpIHJldHVybjtcbiAgICAgIHN0LmIgPSBidCArIDE7XG4gICAgICBpZiAob3V0KSB7XG4gICAgICAgIGZpbGwob3V0LCBkYXRbYnRdLCBzdC55LCAoc3QueSArPSBzeikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGwobmV3IHU4KHN6KSwgZGF0W2J0XSk7XG4gICAgfVxuICAgIGlmIChlYnQgPiBkYXQubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKGJ0eXBlID09PSAwKSB7XG4gICAgICBzdC5iID0gZWJ0O1xuICAgICAgaWYgKG91dCkge1xuICAgICAgICBvdXQuc2V0KGRhdC5zdWJhcnJheShidCwgZWJ0KSwgc3QueSk7XG4gICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xjKGRhdCwgYnQsIGVidCk7XG4gICAgfVxuICAgIGlmIChidHlwZSA9PT0gMikge1xuICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICB2YXIgYjMgPSBkYXRbYnRdLFxuICAgICAgICBsYnQgPSBiMyAmIDMsXG4gICAgICAgIHNmID0gKGIzID4+IDIpICYgMztcbiAgICAgIC8vIGxpdCBzcmMgc2l6ZSAgbGl0IGNtcCBzeiA0IHN0cmVhbXNcbiAgICAgIHZhciBsc3MgPSBiMyA+PiA0LFxuICAgICAgICBsY3MgPSAwLFxuICAgICAgICBzNCA9IDA7XG4gICAgICBpZiAobGJ0IDwgMikge1xuICAgICAgICBpZiAoc2YgJiAxKSBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8IChzZiAmIDIgJiYgZGF0WysrYnRdIDw8IDEyKTtcbiAgICAgICAgZWxzZSBsc3MgPSBiMyA+PiAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBzZjtcbiAgICAgICAgaWYgKHNmIDwgMilcbiAgICAgICAgICAobHNzIHw9IChkYXRbKytidF0gJiA2MykgPDwgNCksXG4gICAgICAgICAgICAobGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpKTtcbiAgICAgICAgZWxzZSBpZiAoc2YgPT09IDIpXG4gICAgICAgICAgKGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMikpLFxuICAgICAgICAgICAgKGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAobHNzIHw9IChkYXRbKytidF0gPDwgNCkgfCAoKGRhdFsrK2J0XSAmIDYzKSA8PCAxMikpLFxuICAgICAgICAgICAgKGxjcyA9IChkYXRbYnRdID4+IDYpIHwgKGRhdFsrK2J0XSA8PCAyKSB8IChkYXRbKytidF0gPDwgMTApKTtcbiAgICAgIH1cbiAgICAgICsrYnQ7XG4gICAgICAvLyBhZGQgbGl0ZXJhbHMgdG8gZW5kIC0gY2FuIG5ldmVyIG92ZXJsYXAgd2l0aCBiYWNrcmVmZXJlbmNlcyBiZWNhdXNlIHVudXNlZCBsaXRlcmFscyBhbHdheXMgYXBwZW5kZWRcbiAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgLy8gc3RhcnRpbmcgcG9pbnQgZm9yIGxpdGVyYWxzXG4gICAgICB2YXIgc3BsID0gYnVmLmxlbmd0aCAtIGxzcztcbiAgICAgIGlmIChsYnQgPT09IDApIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gbHNzKSksIHNwbCk7XG4gICAgICBlbHNlIGlmIChsYnQgPT09IDEpIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICB2YXIgaHUgPSBzdC5oO1xuICAgICAgICBpZiAobGJ0ID09PSAyKSB7XG4gICAgICAgICAgdmFyIGh1ZCA9IHJodShkYXQsIGJ0KTtcbiAgICAgICAgICAvLyBzdWJ0cmFjdCBkZXNjcmlwdGlvbiBsZW5ndGhcbiAgICAgICAgICBsY3MgKz0gYnQgLSAoYnQgPSBodWRbMF0pO1xuICAgICAgICAgIHN0LmggPSBodSA9IGh1ZFsxXTtcbiAgICAgICAgfSBlbHNlIGlmICghaHUpIGVycigwKTtcbiAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCAoYnQgKz0gbGNzKSksIGJ1Zi5zdWJhcnJheShzcGwpLCBodSk7XG4gICAgICB9XG4gICAgICAvLyBudW0gc2VxdWVuY2VzXG4gICAgICB2YXIgbnMgPSBkYXRbYnQrK107XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgaWYgKG5zID09PSAyNTUpIG5zID0gKGRhdFtidCsrXSB8IChkYXRbYnQrK10gPDwgOCkpICsgMHg3ZjAwO1xuICAgICAgICBlbHNlIGlmIChucyA+IDEyNykgbnMgPSAoKG5zIC0gMTI4KSA8PCA4KSB8IGRhdFtidCsrXTtcbiAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgIHZhciBzY20gPSBkYXRbYnQrK107XG4gICAgICAgIGlmIChzY20gJiAzKSBlcnIoMCk7XG4gICAgICAgIHZhciBkdHMgPSBbZG1sdCwgZG9jdCwgZGxsdF07XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICBpZiAobWQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHJsZSBidWZcbiAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgIGR0c1tpXSA9IHtcbiAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgbjogcmJ1Zi5zdWJhcnJheSgwLCAxKSxcbiAgICAgICAgICAgICAgdDogbmV3IHUxNihyYnVmLmJ1ZmZlciwgMCwgMSksXG4gICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAobWQgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGFjY3VyYWN5IGxvZyA4IGZvciBvZmZzZXRzLCA5IGZvciBvdGhlcnNcbiAgICAgICAgICAgIChfYSA9IHJmc2UoZGF0LCBidCwgOSAtIChpICYgMSkpKSwgKGJ0ID0gX2FbMF0pLCAoZHRzW2ldID0gX2FbMV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWQgPT09IDMpIHtcbiAgICAgICAgICAgIGlmICghc3QudCkgZXJyKDApO1xuICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gKHN0LnQgPSBkdHMpLFxuICAgICAgICAgIG1sdCA9IF9iWzBdLFxuICAgICAgICAgIG9jdCA9IF9iWzFdLFxuICAgICAgICAgIGxsdCA9IF9iWzJdO1xuICAgICAgICB2YXIgbGIgPSBkYXRbZWJ0IC0gMV07XG4gICAgICAgIGlmICghbGIpIGVycigwKTtcbiAgICAgICAgdmFyIHNwb3MgPSAoZWJ0IDw8IDMpIC0gOCArIG1zYihsYikgLSBsbHQuYixcbiAgICAgICAgICBjYnQgPSBzcG9zID4+IDMsXG4gICAgICAgICAgb3VidCA9IDA7XG4gICAgICAgIHZhciBsc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2N0LmIpID4+IDM7XG4gICAgICAgIHZhciBvc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWx0LmIpID4+IDM7XG4gICAgICAgIHZhciBtc3QgPVxuICAgICAgICAgICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgZm9yICgrK25zOyAtLW5zOyApIHtcbiAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgIHZhciBvZmYgPVxuICAgICAgICAgICAgb2ZwICtcbiAgICAgICAgICAgICgoKGRhdFtjYnRdIHxcbiAgICAgICAgICAgICAgKGRhdFtjYnQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAgIChkYXRbY2J0ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgKGRhdFtjYnQgKyAzXSA8PCAyNCkpID4+PlxuICAgICAgICAgICAgICAoc3BvcyAmIDcpKSAmXG4gICAgICAgICAgICAgIChvZnAgLSAxKSk7XG4gICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWxiW21sY10pID4+IDM7XG4gICAgICAgICAgdmFyIG1sID1cbiAgICAgICAgICAgIG1sYmxbbWxjXSArXG4gICAgICAgICAgICAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj5cbiAgICAgICAgICAgICAgKHNwb3MgJiA3KSkgJlxuICAgICAgICAgICAgICAoKDEgPDwgbWxiW21sY10pIC0gMSkpO1xuICAgICAgICAgIGNidCA9IChzcG9zIC09IGxsYltsbGNdKSA+PiAzO1xuICAgICAgICAgIHZhciBsbCA9XG4gICAgICAgICAgICBsbGJsW2xsY10gK1xuICAgICAgICAgICAgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+XG4gICAgICAgICAgICAgIChzcG9zICYgNykpICZcbiAgICAgICAgICAgICAgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgIGxzdCA9XG4gICAgICAgICAgICBsbHQudFtsc3RdICtcbiAgICAgICAgICAgICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJlxuICAgICAgICAgICAgICAoKDEgPDwgbGJ0cikgLSAxKSk7XG4gICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbWJ0cikgPj4gMztcbiAgICAgICAgICBtc3QgPVxuICAgICAgICAgICAgbWx0LnRbbXN0XSArXG4gICAgICAgICAgICAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICZcbiAgICAgICAgICAgICAgKCgxIDw8IG1idHIpIC0gMSkpO1xuICAgICAgICAgIGNidCA9IChzcG9zIC09IG9idHIpID4+IDM7XG4gICAgICAgICAgb3N0ID1cbiAgICAgICAgICAgIG9jdC50W29zdF0gK1xuICAgICAgICAgICAgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmXG4gICAgICAgICAgICAgICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgc3Qub1syXSA9IHN0Lm9bMV07XG4gICAgICAgICAgICBzdC5vWzFdID0gc3Qub1swXTtcbiAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkeCA9IG9mZiAtIChsbCAhPT0gMCk7XG4gICAgICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICAgIG9mZiA9IGlkeCA9PT0gMyA/IHN0Lm9bMF0gLSAxIDogc3Qub1tpZHhdO1xuICAgICAgICAgICAgICBpZiAoaWR4ID4gMSkgc3Qub1syXSA9IHN0Lm9bMV07XG4gICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICBzdC5vWzBdID0gb2ZmO1xuICAgICAgICAgICAgfSBlbHNlIG9mZiA9IHN0Lm9bMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGw7ICsraSkge1xuICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKG91YnQgKz0gbGwpLCAoc3BsICs9IGxsKTtcbiAgICAgICAgICB2YXIgc3RpbiA9IG91YnQgLSBvZmY7XG4gICAgICAgICAgaWYgKHN0aW4gPCAwKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gLXN0aW47XG4gICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgIGlmIChsZW4gPiBtbCkgbGVuID0gbWw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAob3VidCArPSBsZW4pLCAobWwgLT0gbGVuKSwgKHN0aW4gPSAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbDsgKytpKSB7XG4gICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3VidCAhPT0gc3BsKSB7XG4gICAgICAgICAgd2hpbGUgKHNwbCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBvdWJ0ID0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKG91dCkgc3QueSArPSBvdWJ0O1xuICAgICAgICBlbHNlIGJ1ZiA9IHNsYyhidWYsIDAsIG91YnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgIHN0LnkgKz0gbHNzO1xuICAgICAgICAgIGlmIChzcGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgYnVmW2ldID0gYnVmW3NwbCArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzcGwpIGJ1ZiA9IHNsYyhidWYsIHNwbCk7XG4gICAgICB9XG4gICAgICBzdC5iID0gZWJ0O1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZXJyKDIpO1xuICB9O1xuICAvLyBjb25jYXRcbiAgdmFyIGNjdCA9IGZ1bmN0aW9uIChidWZzLCBvbCkge1xuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoayA9IGJ1ZnNbaV07XG4gICAgICBidWYuc2V0KGNoaywgYik7XG4gICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH07XG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAgICogQHBhcmFtIGRhdCBUaGUgaW5wdXQgZGF0YVxuICAgKiBAcGFyYW0gYnVmIFRoZSBvdXRwdXQgYnVmZmVyLiBJZiB1bnNwZWNpZmllZCwgdGhlIGZ1bmN0aW9uIHdpbGwgYWxsb2NhdGVcbiAgICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICAgKiAgICAgICAgICAgIGRhdGEgaGFzIG11bHRpcGxlIGZyYW1lcyBhbmQgeW91IGtub3cgdGhlIG91dHB1dCBzaXplLCBzcGVjaWZ5aW5nXG4gICAqICAgICAgICAgICAgaXQgd2lsbCB5aWVsZCBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0LCBidWYpIHtcbiAgICB2YXIgYnQgPSAwLFxuICAgICAgYnVmcyA9IFtdLFxuICAgICAgbmIgPSArIWJ1ZixcbiAgICAgIG9sID0gMDtcbiAgICB3aGlsZSAoZGF0Lmxlbmd0aCkge1xuICAgICAgdmFyIHN0ID0gcnpmaChkYXQsIG5iIHx8IGJ1Zik7XG4gICAgICBpZiAodHlwZW9mIHN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChuYikge1xuICAgICAgICAgIGJ1ZiA9IG51bGw7XG4gICAgICAgICAgaWYgKHN0LncubGVuZ3RoID09PSBzdC51KSB7XG4gICAgICAgICAgICBidWZzLnB1c2goKGJ1ZiA9IHN0LncpKTtcbiAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZnMucHVzaChidWYpO1xuICAgICAgICAgIHN0LmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghc3QubCkge1xuICAgICAgICAgIHZhciBibGsgPSByemIoZGF0LCBzdCwgYnVmKTtcbiAgICAgICAgICBpZiAoIWJsaykgZXJyKDUpO1xuICAgICAgICAgIGlmIChidWYpIHN0LmUgPSBzdC55O1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmcy5wdXNoKGJsayk7XG4gICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgY3B3KHN0LncsIDAsIGJsay5sZW5ndGgpO1xuICAgICAgICAgICAgc3Qudy5zZXQoYmxrLCBzdC53Lmxlbmd0aCAtIGJsay5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidCA9IHN0LmIgKyBzdC5jICogNDtcbiAgICAgIH0gZWxzZSBidCA9IHN0O1xuICAgICAgZGF0ID0gZGF0LnN1YmFycmF5KGJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNjdChidWZzLCBvbCk7XG4gIH07XG59KSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGw7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjEuMFxuLy9WZXJzaW9uOiA8IDUuMS4xXG4vL1JlcXVpcmVzOiB6c3RkX2RlY29tcHJlc3NcbnZhciBjYW1sX2RlY29tcHJlc3NfaW5wdXQgPSB6c3RkX2RlY29tcHJlc3M7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjEuMVxuLy9WZXJzaW9uOiA8IDUuMi4wXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0gbnVsbDtcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMlxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG52YXIgY2FtbF9kZWNvbXByZXNzX2lucHV0ID0genN0ZF9kZWNvbXByZXNzO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3pzdGRfaW5pdGlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1JlcXVpcmVzOiB6c3RkX2RlY29tcHJlc3Ncbi8vVmVyc2lvbjogPj0gNS4xLjFcbmZ1bmN0aW9uIGNhbWxfenN0ZF9pbml0aWFsaXplKF91bml0KSB7XG4gIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcbiAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUElcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDM7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ub25lXG52YXIgY2FtbF9lcGhlX25vbmUgPSB7IGNhbWxfZXBoZV9ub25lOiAwIH07XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2RhdGFfb3B0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHZhciBvbGQgPSBjYW1sX2VwaGVfZ2V0X2RhdGEoeCk7XG4gIGlmIChnbG9iYWxUaGlzLldlYWtSZWYgJiYgdiBpbnN0YW5jZW9mIE9iamVjdCkgdiA9IG5ldyBnbG9iYWxUaGlzLldlYWtSZWYodik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIGNhbWxfZXBoZV9zZXRfZGF0YV9vcHQoeCwgb2xkKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9zZXRfZGF0YV9vcHRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgdmFyIG9sZCA9IGNhbWxfZXBoZV9nZXRfZGF0YSh4KTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gY2FtbF9lcGhlX25vbmU7XG4gIGNhbWxfZXBoZV9zZXRfZGF0YV9vcHQoeCwgb2xkKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jcmVhdGUobikge1xuICByZXR1cm4gY2FtbF93ZWFrX2NyZWF0ZShuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9ub25lXG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlKG4pIHtcbiAgdmFyIGFsZW4gPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHZhciB4ID0gbmV3IEFycmF5KGFsZW4pO1xuICB4WzBdID0gMjUxO1xuICB4WzFdID0gXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCI7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYWxlbjsgaSsrKSB7XG4gICAgeFtpXSA9IGNhbWxfZXBoZV9ub25lO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2tleSwgY2FtbF9lcGhlX3Vuc2V0X2tleVxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmICh2ID09PSAwKSBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHZbMV0pO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfbm9uZVxuLy9BbGlhczogY2FtbF93ZWFrX2dldFxuXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKSB7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xuICBpZiAod2VhayA9PT0gY2FtbF9lcGhlX25vbmUpIHJldHVybiAwO1xuICBpZiAoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICB3ZWFrID0gd2Vhay5kZXJlZigpO1xuICAgIGlmICh3ZWFrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IGNhbWxfZXBoZV9ub25lO1xuICAgICAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gY2FtbF9lcGhlX25vbmU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFswLCB3ZWFrXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9nZXRfa2V5LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRfY29weVxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9rZXlfY29weSh4LCBpKSB7XG4gIHZhciB5ID0gY2FtbF9lcGhlX2dldF9rZXkoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoQXJyYXkuaXNBcnJheSh6KSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfbm9uZVxuLy9BbGlhczogY2FtbF93ZWFrX2NoZWNrXG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfa2V5KHgsIGkpIHtcbiAgdmFyIHdlYWsgPSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG4gIGlmICh3ZWFrID09PSBjYW1sX2VwaGVfbm9uZSkgcmV0dXJuIDA7XG4gIGlmIChnbG9iYWxUaGlzLldlYWtSZWYgJiYgd2VhayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gICAgaWYgKHdlYWsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gY2FtbF9lcGhlX25vbmU7XG4gICAgICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9zZXRfZGF0YV9vcHRcbi8vQWxpYXM6IGNhbWxfd2Vha19ibGl0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9rZXkoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICB2YXIgb2xkID0gY2FtbF9lcGhlX2dldF9kYXRhKGExKTtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChcbiAgICBhMSxcbiAgICBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICBhMixcbiAgICBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICBsZW4sXG4gICk7XG4gIGNhbWxfZXBoZV9zZXRfZGF0YV9vcHQoYTIsIG9sZCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGEsIGNhbWxfZXBoZV9zZXRfZGF0YV9vcHRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3QpIHtcbiAgdmFyIG9sZCA9IGNhbWxfZXBoZV9nZXRfZGF0YShzcmMpO1xuICBjYW1sX2VwaGVfc2V0X2RhdGFfb3B0KGRzdCwgb2xkKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX25vbmVcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KSB7XG4gIHZhciBkYXRhID0geFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICBpZiAoZGF0YSA9PT0gY2FtbF9lcGhlX25vbmUpIHJldHVybiAwO1xuICBmb3IgKHZhciBpID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGsgPSB4W2ldO1xuICAgIGlmIChnbG9iYWxUaGlzLldlYWtSZWYgJiYgayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgdmFyIGQgPSBrLmRlcmVmKCk7XG4gICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHhbaV0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgICAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gY2FtbF9lcGhlX25vbmU7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGdsb2JhbFRoaXMuV2Vha01hcCkge1xuICAgICAgICBkYXRhID0gZGF0YS5nZXQoayk7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWzAsIGRhdGFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpIHtcbiAgdmFyIHIgPSBjYW1sX2VwaGVfZ2V0X2RhdGEoeCk7XG4gIGlmIChyID09PSAwKSByZXR1cm4gMDtcbiAgdmFyIHogPSByWzFdO1xuICBpZiAoQXJyYXkuaXNBcnJheSh6KSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfbm9uZVxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IHgubGVuZ3RoIC0gMTsgaSA+PSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaS0tKSB7XG4gICAgdmFyIGsgPSB4W2ldO1xuICAgIGlmIChnbG9iYWxUaGlzLldlYWtSZWYgJiYgayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgdmFyIGQgPSBrLmRlcmVmKCk7XG4gICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHhbaV0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5XZWFrTWFwKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgZ2xvYmFsVGhpcy5XZWFrTWFwKCkuc2V0KGssIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhX29wdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhX29wdCh4LCBkYXRhX29wdCkge1xuICBpZiAoZGF0YV9vcHQgPT09IDApIGNhbWxfZXBoZV91bnNldF9kYXRhKHgpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhX29wdFsxXSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfbm9uZVxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCkge1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBjYW1sX2VwaGVfbm9uZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2VwaGVfZ2V0X2RhdGEoeCk7XG4gIGlmIChkYXRhID09PSAwKSByZXR1cm4gMDtcbiAgZWxzZSByZXR1cm4gMTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoX3VuaXQpIHtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09PSBcImZ1bmN0aW9uXCIpIGdsb2JhbFRoaXMuZ2ModHJ1ZSk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcihfdW5pdCkge1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT09IFwiZnVuY3Rpb25cIikgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKF91bml0KSB7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PT0gXCJmdW5jdGlvblwiKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKF91bml0KSB7XG4gIHJldHVybiBbMjU0LCAwLCAwLCAwXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KF91bml0KSB7XG4gIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuLy9SZXF1aXJlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQodW5pdCkge1xuICByZXR1cm4gY2FtbF9nY19xdWlja19zdGF0KHVuaXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldChfdW5pdCkge1xuICByZXR1cm4gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyKF9mLCBfeCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVxudmFyIGFsbF9maW5hbGl6ZXJzID0gbmV3IGdsb2JhbFRoaXMuU2V0KCk7XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlKGNiLCBhKSB7XG4gIGlmIChnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgeCA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICh4KSB7XG4gICAgICBhbGxfZmluYWxpemVycy5kZWxldGUoeCk7XG4gICAgICBjYigwKTtcbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgICB4LnJlZ2lzdGVyKGEsIHgpO1xuICAgIGFsbF9maW5hbGl6ZXJzLmFkZCh4KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KF9yYXRlLCBfc3RhY2tfc2l6ZSwgX3RyYWNrZXIpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX2Rpc2NhcmRcbi8vVmVyc2lvbjogPj0gNS4yXG5mdW5jdGlvbiBjYW1sX21lbXByb2ZfZGlzY2FyZChfdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19yZXN1bWVcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcmVzdW1lKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3BhdXNlXG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3BhdXNlKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbi8vVmVyc2lvbjogPCA1LjBcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvcl9zbGljZVxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcl9zbGljZShfd29yaykge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY2FtbF9nY19taW5vcl93b3JkcyhfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZShfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfYnVja2V0XG4vL1ZlcnNpb246IDwgNS4wXG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9idWNrZXQoX24pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2NyZWRpdFxuLy9WZXJzaW9uOiA8IDUuMFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfY3JlZGl0KF9uKSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9IHtcbiAgICBqdXN0aWZ5OiBcIitcIixcbiAgICBzaWduc3R5bGU6IFwiLVwiLFxuICAgIGZpbGxlcjogXCIgXCIsXG4gICAgYWx0ZXJuYXRlOiBmYWxzZSxcbiAgICBiYXNlOiAwLFxuICAgIHNpZ25lZGNvbnY6IGZhbHNlLFxuICAgIHdpZHRoOiAwLFxuICAgIHVwcGVyY2FzZTogZmFsc2UsXG4gICAgc2lnbjogMSxcbiAgICBwcmVjOiAtMSxcbiAgICBjb252OiBcImZcIixcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGYuanVzdGlmeSA9IFwiLVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICBjYXNlIFwiIFwiOlxuICAgICAgICBmLnNpZ25zdHlsZSA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgZi5maWxsZXIgPSBcIjBcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiI1wiOlxuICAgICAgICBmLmFsdGVybmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjFcIjpcbiAgICAgIGNhc2UgXCIyXCI6XG4gICAgICBjYXNlIFwiM1wiOlxuICAgICAgY2FzZSBcIjRcIjpcbiAgICAgIGNhc2UgXCI1XCI6XG4gICAgICBjYXNlIFwiNlwiOlxuICAgICAgY2FzZSBcIjdcIjpcbiAgICAgIGNhc2UgXCI4XCI6XG4gICAgICBjYXNlIFwiOVwiOlxuICAgICAgICBmLndpZHRoID0gMDtcbiAgICAgICAgd2hpbGUgKCgoYyA9IGZtdC5jaGFyQ29kZUF0KGkpIC0gNDgpLCBjID49IDAgJiYgYyA8PSA5KSkge1xuICAgICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgZi5wcmVjID0gMDtcbiAgICAgICAgaSsrO1xuICAgICAgICB3aGlsZSAoKChjID0gZm10LmNoYXJDb2RlQXQoaSkgLSA0OCksIGMgPj0gMCAmJiBjIDw9IDkpKSB7XG4gICAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRcIjpcbiAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7XG4gICAgICAgIGYuYmFzZSA9IDEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgIGYuYmFzZSA9IDEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgIGYuYmFzZSA9IDE2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgIGYuYmFzZSA9IDE2O1xuICAgICAgICBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgZi5iYXNlID0gODtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgY2FzZSBcImZcIjpcbiAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7XG4gICAgICAgIGYuY29udiA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJGXCI6XG4gICAgICBjYXNlIFwiR1wiOlxuICAgICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlO1xuICAgICAgICBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPT0gXCItXCIpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09PSBcIitcIiAmJiBmLmZpbGxlciA9PT0gXCIgXCIpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9IFwiIFwiO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSBcIi1cIjtcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPT0gXCItXCIpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09PSA4KSBidWZmZXIgKz0gXCIwXCI7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT09IDE2KSBidWZmZXIgKz0gZi51cHBlcmNhc2UgPyBcIjBYXCIgOiBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT09IFwiK1wiICYmIGYuZmlsbGVyID09PSBcIjBcIilcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gXCIwXCI7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT09IFwiLVwiKSBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gXCIgXCI7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmIChjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFtcbiAgICAwLFxuICAgIGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKSxcbiAgXSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlID0gY3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pIHtcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIiArIG5hbWUgKyBcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZiAoIShpbmZvID09PSBcIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IFwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmICghc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIik7XG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHcgPyBOdW1iZXIucGFyc2VJbnQodykgOiAyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIiArIHcpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaCA/IE51bWJlci5wYXJzZUludChoKSA6IDIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIiArIGgpO1xuXG4gIHZhciB3aW4gPSBnbG9iYWxUaGlzLm9wZW4oXCJhYm91dDpibGFua1wiLCB0YXJnZXQsIHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYgKCF3aW4pIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKTtcbiAgfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLCB3LCBoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpIHtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LCBjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCwgY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsIHcsIGgpIHtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICBsaW5lX3dpZHRoOiAxLFxuICAgIGZvbnQ6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemU6IDI2LFxuICAgIGNvbG9yOiAweDAwMDAwMCxcbiAgICB0aXRsZTogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSxcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudCkgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZiAocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codywgaCkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3IpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSBcIlwiICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9IFwiMFwiICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgICBnID0gKGNvbG9yID4+IDgpICYgMHhmZixcbiAgICBiID0gKGNvbG9yID4+IDApICYgMHhmZjtcbiAgcy5jb2xvciA9IGNvbG9yO1xuICB2YXIgY19zdHIgPSBcIiNcIiArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9IGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCwgeSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwgMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgKGRbMV0gPVxuICAgIChjb2xvciA+PiA4KSAmXG4gICAgMHhmZiksIC8vZ1xuICAgIChkWzJdID0gKGNvbG9yID4+IDApICYgMHhmZik7IC8vYlxuICBkWzNdID0gMHhmZjsgLy9hXG4gIHMueCA9IHg7XG4gIHMueSA9IHk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0sIHgsIHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LCBzLmhlaWdodCAtIHksIDEsIDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgsIHkpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnggPSB4O1xuICBzLnkgPSB5O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54O1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55O1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCwgcy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgsIHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54ID0geDtcbiAgcy55ID0geTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgsIHksIHcsIGgpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LCBzLmhlaWdodCAtIHksIHcsIC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCwgY3gsIGN5LCByeSwgcngsIGExLCBhMikge1xuICB3aGlsZSAoYTEgPiBhMikgYTIgKz0gMzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAsXG4gICAgeFBvcyxcbiAgICB5UG9zLFxuICAgIHhQb3NfcHJldixcbiAgICB5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4ICsgcnkpIC8gMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKChhMiAtIGExKSAqIE1hdGguUEkpIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gbnVtOyBqKyspIHtcbiAgICB4UG9zID1cbiAgICAgIGN4IC1cbiAgICAgIHJ4ICogTWF0aC5zaW4oaSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArXG4gICAgICByeSAqIE1hdGguY29zKGkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID1cbiAgICAgIGN5ICtcbiAgICAgIHJ5ICogTWF0aC5jb3MoaSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArXG4gICAgICByeCAqIE1hdGguc2luKGkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiAhPT0geFBvcyB8fCB5UG9zX3ByZXYgIT09IHlQb3MpIHtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldiA9IHhQb3M7XG4gICAgeVBvc19wcmV2ID0geVBvcztcbiAgICBpIC09IGRlbHRhOyAvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgsIHksIHJ4LCByeSwgYTEsIGEyKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LCB4LCBzLmhlaWdodCAtIHksIHJ4LCByeSwgYTEsIGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodykge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LCB5LCB3LCBoKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgsIHMuaGVpZ2h0IC0geSwgdywgLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0sIHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0sIHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLCBzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCwgeSwgcngsIHJ5LCBhMSwgYTIpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQsIHgsIHMuaGVpZ2h0IC0geSwgcngsIHJ5LCBhMSwgYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0ciwgcy54LCBzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYykge1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKSB7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZikge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSkge1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCwgdywgcy50ZXh0X3NpemVdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMTtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LCBoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHc7IGorKykge1xuICAgICAgdmFyIGMgPSBhcnJbaSArIDFdW2ogKyAxXTtcbiAgICAgIHZhciBvID0gaSAqICh3ICogNCkgKyBqICogNDtcbiAgICAgIGlmIChjID09PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IChjID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gKGMgPj4gOCkgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IChjID4+IDApICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pIHtcbiAgdmFyIGRhdGEgPSBbMF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0uaGVpZ2h0OyBpKyspIHtcbiAgICBkYXRhW2kgKyAxXSA9IFswXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGltLndpZHRoOyBqKyspIHtcbiAgICAgIHZhciBvID0gaSAqIChpbS53aWR0aCAqIDQpICsgaiAqIDQsXG4gICAgICAgIHIgPSBpbS5kYXRhW28gKyAwXSxcbiAgICAgICAgZyA9IGltLmRhdGFbbyArIDFdLFxuICAgICAgICBiID0gaW0uZGF0YVtvICsgMl07XG4gICAgICBkYXRhW2kgKyAxXVtqICsgMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLCB4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYgKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLCAwLCAwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgZ2xvYmFsVGhpcy5JbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH07XG4gICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgfSBlbHNlIHtcbiAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltLmltYWdlLCB4LCBzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LCB5KSB7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCwgeSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0sIHgsIHkpIHtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICB4LFxuICAgIHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxcbiAgICBpbS53aWR0aCxcbiAgICBpbS5oZWlnaHQsXG4gICk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpICsgMV0gPSBpbTIuZGF0YVtpICsgMV07XG4gICAgaW0uZGF0YVtpICsgMl0gPSBpbTIuZGF0YVtpICsgMl07XG4gICAgaW0uZGF0YVtpICsgM10gPSBpbTIuZGF0YVtpICsgM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpIHtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19zaWduYWwoKSB7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93YWl0X2V2ZW50IG5vdCBJbXBsZW1lbnRlZDogdXNlIEdyYXBoaWNzX2pzIGluc3RlYWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3luY2hyb25pemVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3luY2hyb25pemUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKF9hKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coX2EsIF9iLCBfYywgX2QpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3coX2EpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDogLyYvZywgbHQ6IC88L2csIHF1b3Q6IC9cIi9nLCBhbGw6IC9bJjxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICB2YXIgZW50aXR5ID0gL14mIz9bMC05YS16QS1aXSs7JC87XG4gIGlmIChzLm1hdGNoKGVudGl0eSkpIHtcbiAgICB2YXIgc3RyLFxuICAgICAgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHRlbXAuaW5uZXJIVE1MID0gcztcbiAgICBzdHIgPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXAgPSBudWxsO1xuICAgIHJldHVybiBzdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSgpIHtcbiAgdmFyIGMgPSBjb25zb2xlO1xuICB2YXIgbSA9IFtcbiAgICBcImxvZ1wiLFxuICAgIFwiZGVidWdcIixcbiAgICBcImluZm9cIixcbiAgICBcIndhcm5cIixcbiAgICBcImVycm9yXCIsXG4gICAgXCJhc3NlcnRcIixcbiAgICBcImRpclwiLFxuICAgIFwiZGlyeG1sXCIsXG4gICAgXCJ0cmFjZVwiLFxuICAgIFwiZ3JvdXBcIixcbiAgICBcImdyb3VwQ29sbGFwc2VkXCIsXG4gICAgXCJncm91cEVuZFwiLFxuICAgIFwidGltZVwiLFxuICAgIFwidGltZUVuZFwiLFxuICBdO1xuICBmdW5jdGlvbiBmKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV0gPSBmO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUoX3VuaXQpIHtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJYTUxIdHRwUmVxdWVzdCBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9IGNhdGNoIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiRmFpbGVkIHRvIGNyZWF0ZSBYTUxIdHRwUmVxdWVzdFwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmIChleG4uanNfZXJyb3IpIHtcbiAgICByZXR1cm4gZXhuLmpzX2Vycm9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAoKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2KSA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLFxuICAgIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGxleGJ1ZltsZXhfYnVmZmVyXTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvciAoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UgLSAxO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pIHtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PT0gMCkgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlIGMgPSAyNTY7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0KGJ1ZmZlciwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10rKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT09IHN0YXRlKSBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2Ugc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09PSAtMSkgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpKys7XG4gICAgaWYgKGRzdCA9PT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaSsrO1xuICAgIGlmIChzcmMgPT09IDB4ZmYpIG1lbVtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2UgbWVtW2RzdCArIDFdID0gbWVtW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGkrKztcbiAgICBpZiAoZHN0ID09PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpKys7XG4gICAgaWYgKHNyYyA9PT0gMHhmZikgbWVtW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZSBtZW1bZHN0ICsgMV0gPSBtZW1bc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSBjYW1sX2xleF9hcnJheSh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5KHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKVxuICAgIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsXG4gICAgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gbGV4YnVmW2xleF9idWZmZXJdO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yICg7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlIC0gMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKSB7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT09IDApIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZSBjID0gMjU2O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldChidWZmZXIsIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PT0gc3RhdGUpIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZSBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT09IC0xKSBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2UgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLFxuICAgICAgICBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2UgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtKFxuICAgICAgICAgIHRibC5sZXhfY29kZSxcbiAgICAgICAgICBwY19vZmYsXG4gICAgICAgICAgbGV4YnVmW2xleF9tZW1dLFxuICAgICAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdLFxuICAgICAgICApO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy9Qcm92aWRlczogY2FtbF9seG1fTVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1ZlcnNpb246ID49IDVcbnZhciBjYW1sX2x4bV9NID0gY2FtbF9pbnQ2NF9vZl9zdHJpbmcoXG4gIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwiMHhkMTM0MjU0M2RlODJlZjk1XCIpLFxuKTtcblxuLy9Qcm92aWRlczogY2FtbF9seG1fZGFiYVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1ZlcnNpb246ID49IDVcbnZhciBjYW1sX2x4bV9kYWJhID0gY2FtbF9pbnQ2NF9vZl9zdHJpbmcoXG4gIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwiMHhkYWJhMGI2ZWIwOTMyMmUzXCIpLFxuKTtcblxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfeG9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2V0XzFcbi8vUmVxdWlyZXM6IGNhbWxfbHhtX01cbi8vUmVxdWlyZXM6IGNhbWxfbHhtX2RhYmFcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9seG1fbmV4dCh2KSB7XG4gIGZ1bmN0aW9uIHNoaWZ0X2woeCwgaykge1xuICAgIHJldHVybiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQoeCwgayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgayk7XG4gIH1cbiAgZnVuY3Rpb24gb3IoYSwgYikge1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfeG9yKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfYWRkKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIHJvdGwoeCwgaykge1xuICAgIHJldHVybiBvcihzaGlmdF9sKHgsIGspLCBzaGlmdF9yKHgsIDY0IC0gaykpO1xuICB9XG4gIGZ1bmN0aW9uIGdldChhLCBpKSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfZ2V0XzEoYSwgaSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0KGEsIGksIHgpIHtcbiAgICByZXR1cm4gY2FtbF9iYV9zZXRfMShhLCBpLCB4KTtcbiAgfVxuICB2YXIgTSA9IGNhbWxfbHhtX007XG4gIHZhciBkYWJhID0gY2FtbF9seG1fZGFiYTtcbiAgdmFyIHosIHEwLCBxMTtcbiAgdmFyIHN0ID0gdjtcbiAgdmFyIGEgPSBnZXQoc3QsIDApO1xuICB2YXIgcyA9IGdldChzdCwgMSk7XG4gIHZhciB4MCA9IGdldChzdCwgMik7XG4gIHZhciB4MSA9IGdldChzdCwgMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LCBzaGlmdF9yKHosIDMyKSksIGRhYmEpO1xuICB6ID0gbXVsKHhvcih6LCBzaGlmdF9yKHosIDMyKSksIGRhYmEpO1xuICB6ID0geG9yKHosIHNoaWZ0X3IoeiwgMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZChtdWwocywgTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MDtcbiAgdmFyIHExID0geDE7XG4gIHExID0geG9yKHExLCBxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgc2hpZnRfbChxMSwgMTYpKTtcbiAgcTEgPSByb3RsKHExLCAzNyk7XG4gIHNldChzdCwgMiwgcTApO1xuICBzZXQoc3QsIDMsIHExKTtcbiAgLyogUmV0dXJuIHJlc3VsdCAqL1xuICByZXR1cm4gejtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZW5naW5lKHRhYmxlcywgZW52LCBjbWQsIGFyZykge1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIHZhciB0YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgdmFyIHRibF9uYW1lc19ibG9jayA9IDE2O1xuXG4gIGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHggKyBcIlxcblwiKTtcbiAgICBjYW1sX21sX291dHB1dChjYW1sX3N5c19mZHNbMl0uY2hhbmlkLCBzLCAwLCBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5fbmFtZShuYW1lcywgbnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWVzKTtcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceDAwXCIpIHJldHVybiBcIjx1bmtub3duIHRva2VuPlwiO1xuICAgIHJldHVybiBzdHIuc3BsaXQoXCJcXHgwMFwiKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaykge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2spKSB7XG4gICAgICB0b2tlbiA9IHRva2VuX25hbWUodGFibGVzW3RibF9uYW1lc19ibG9ja10sIHRva1swXSk7XG4gICAgICBpZiAodHlwZW9mIHRva1sxXSA9PT0gXCJudW1iZXJcIikga2luZCA9IFwiXCIgKyB0b2tbMV07XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdG9rWzFdID09PSBcInN0cmluZ1wiKSBraW5kID0gdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodG9rWzFdIGluc3RhbmNlb2YgTWxCeXRlcykga2luZCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodG9rWzFdKTtcbiAgICAgIGVsc2Uga2luZCA9IFwiX1wiO1xuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSh0YWJsZXNbdGJsX2RlZnJlZF0pO1xuICAgIHRhYmxlcy5zaW5kZXggPSBjYW1sX2xleF9hcnJheSh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfY2hlY2tdKTtcbiAgICB0YWJsZXMucmluZGV4ID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgPSBjYW1sX2xleF9hcnJheSh0YWJsZXNbdGJsX3RhYmxlXSk7XG4gICAgdGFibGVzLmxlbiA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5KHRhYmxlc1t0YmxfZ2luZGV4XSk7XG4gICAgdGFibGVzLmRnb3RvID0gY2FtbF9sZXhfYXJyYXkodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsXG4gICAgbixcbiAgICBuMSxcbiAgICBuMixcbiAgICBzdGF0ZTE7XG5cbiAgLy8gUkVTVE9SRVxuICB2YXIgc3AgPSBlbnZbZW52X3NwXTtcbiAgdmFyIHN0YXRlID0gZW52W2Vudl9zdGF0ZV07XG4gIHZhciBlcnJmbGFnID0gZW52W2Vudl9lcnJmbGFnXTtcblxuICB0aGVfbG9vcDogZm9yICg7Oykge1xuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIDA6IC8vU1RBUlQ6XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgNjogLy9sb29wOlxuICAgICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICAgY21kID0gcmVkdWNlO1xuICAgICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkge1xuICAgICAgICAgIGNtZCA9IHRlc3RzaGlmdDtcbiAgICAgICAgICBjb250aW51ZSB0aGVfbG9vcDtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgICBicmVhayB0aGVfbG9vcDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICAgIGNhc2UgMTogLy9UT0tFTl9SRUFEOlxuICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKSBwcmludF90b2tlbihzdGF0ZSwgYXJnKTtcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgNzogLy90ZXN0c2hpZnQ6XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9GYWxsdGhyb3VnaFN3aXRjaENsYXVzZTpcbiAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG4xICE9PSAwICYmXG4gICAgICAgICAgbjIgPj0gMCAmJlxuICAgICAgICAgIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT09IGVudltlbnZfY3Vycl9jaGFyXVxuICAgICAgICApIHtcbiAgICAgICAgICBjbWQgPSBzaGlmdDtcbiAgICAgICAgICBjb250aW51ZSB0aGVfbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbjEgIT09IDAgJiZcbiAgICAgICAgICBuMiA+PSAwICYmXG4gICAgICAgICAgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PT0gZW52W2Vudl9jdXJyX2NoYXJdXG4gICAgICAgICkge1xuICAgICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICAgIGNtZCA9IHJlZHVjZTtcbiAgICAgICAgICBjb250aW51ZSB0aGVfbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgICBicmVhayB0aGVfbG9vcDtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgICAgY2FzZSA1OiAvL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuMSAhPT0gMCAmJlxuICAgICAgICAgICAgICBuMiA+PSAwICYmXG4gICAgICAgICAgICAgIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09PSBFUlJDT0RFXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKSBsb2coXCJSZWNvdmVyaW5nIGluIHN0YXRlIFwiICsgc3RhdGUxKTtcbiAgICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjtcbiAgICAgICAgICAgICAgY29udGludWUgdGhlX2xvb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKSBsb2coXCJObyBtb3JlIHN0YXRlcyB0byBkaXNjYXJkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgaWYgKGNhbWxfcGFyc2VyX3RyYWNlKSBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgICAgICBjbWQgPSBsb29wO1xuICAgICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAvLyBVbnJlYWNoYWJsZVxuICAgICAgY2FzZSA4OiAvL3NoaWZ0OlxuICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vRmFsbHRocm91Z2hTd2l0Y2hDbGF1c2U6XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBjYXNlIDk6IC8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIHNwKys7XG4gICAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICAgIGJyZWFrIHRoZV9sb29wO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgICBjYXNlIDI6IC8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICAgIGNtZCA9IGxvb3A7XG4gICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuXG4gICAgICBjYXNlIDEwOiAvL3JlZHVjZTpcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0ZhbGx0aHJvdWdoU3dpdGNoQ2xhdXNlOlxuICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVkdWNlIGJ5IHJ1bGUgXCIgKyBuKTtcbiAgICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuMSAhPT0gMCAmJlxuICAgICAgICAgIG4yID49IDAgJiZcbiAgICAgICAgICBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09PSBzdGF0ZTFcbiAgICAgICAgKVxuICAgICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgZWxzZSBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgICAgYnJlYWsgdGhlX2xvb3A7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICAgIGNhc2UgMzogLy9TVEFDS1NfR1JPV05fMjpcbiAgICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICAgIGJyZWFrIHRoZV9sb29wO1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgICAgY2FzZSA0OiAvL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNtZCA9IGxvb3A7XG4gICAgICAgIGNvbnRpbnVlIHRoZV9sb29wO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlcl90cmFjZVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKGJvb2wpIHtcbiAgdmFyIG9sZGZsYWcgPSBjYW1sX3BhcnNlcl90cmFjZTtcbiAgY2FtbF9wYXJzZXJfdHJhY2UgPSBib29sO1xuICByZXR1cm4gb2xkZmxhZztcbn1cbiIsIi8vUHJvdmlkZXM6IGNvcmVfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrXG5mdW5jdGlvbiBjb3JlX2hlYXBfYmxvY2tfaXNfaGVhcF9ibG9jayh4KXtcbiAgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTtcbn1cblxuIiwiLy8vLy8vLy8vIFRJTUVfTk9XXG5cbi8vUHJvdmlkZXM6IHRpbWVfbm93X25hbm9zZWNvbmRzX3NpbmNlX3VuaXhfZXBvY2hfb3JfemVyb1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbnZhciBtc190b19uYW5vID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxMDAwKjEwMDApO1xuZnVuY3Rpb24gdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvKCl7XG4gICAgdmFyIG1zID0gRGF0ZS5ub3coKTtcbiAgICAvLyBtdWx0aXBsZSBieSB0d28gLSBpbnQ2MyBpbnRlZ2VycyBhcmUgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgIHZhciBtc19pNjMgPSBjYW1sX2ludDY0X29mX2Zsb2F0KG1zKjIpO1xuICAgIC8vIGRvaW5nIHRoZSBtdWx0aXBsaWNhdGlvbiBpbiBpbnQ2NCBzcGFjZSB3b3VsZCBkcm9wIGFsbCB0aGUgdmFsdWVzXG4gICAgLy8gYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGJ1dCBiZWNhdXNlIFtEYXRlLm5vdygpXSBvbmx5IHByb3ZpZGVzXG4gICAgLy8gMW1zIHJlc29sdXRpb24gYW55d2F5LCB0aGVyZSdzIG5ldmVyIGFueSB2YWx1ZSBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC5cbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9tdWwobXNfaTYzLG1zX3RvX25hbm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBtc19mbG9hdF90b19uc19pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdFxuZnVuY3Rpb24gbXNfZmxvYXRfdG9fbnNfaW50NjQobXMpIHtcbiAgLy8gbXVsdGlwbHkgYnkgMV8wMDBfMDAwIHdoaWxlIHN0aWxsIGEgZmxvYXQgc28gdGhhdCBzdWItbWlsbGlzZWNvbmRcbiAgLy8gdmFsdWVzIGRvbid0IGdldCB0cnVuY2F0ZWQgYnkgdGhlIGZsb2F0LT5pbnQgY29udmVyc2lvbi5cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQobXMgKiAoMTAwMC4wICogMTAwMC4wKSk7XG59XG5cbi8qIFRoZSByZWFzb24gd2UgY2FuJ3Qgc2hhcmUgYWxsIHRoZSBjb2RlIGJldHdlZW4gWypfY291bnRlcl9mb3JfdGltaW5nXSBhbmRcbiAqIFsqX3VuaXhfZXBvY2hdIGlzIGJlY2F1c2UgW3BlcmZvcm1hbmNlLm5vdygpXSBicmVha3Mgd2hlbiB0aGUgY29tcHV0ZXIgZ29lc1xuICogdG8gc2xlZXAsIGFuZCB3aGVuIGEgdGFiIGlzIGJhY2tncm91bmRlZC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvaHItdGltZS9pc3N1ZXMvMTE1ICovXG5cbi8vUHJvdmlkZXM6IHRpbWVfbm93X25hbm9zZWNvbmRfY291bnRlcl9mb3JfdGltaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgbXNfZmxvYXRfdG9fbnNfaW50NjQsIGNhbWxfaW50NjRfc2hpZnRfbGVmdFxuZnVuY3Rpb24gdGltZV9ub3dfbmFub3NlY29uZF9jb3VudGVyX2Zvcl90aW1pbmcoKXtcbiAgICB2YXIgbXNfc2luY2VfcHJvZ3JhbV9zdGFydGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIG5zX3NpbmNlX3Byb2dyYW1fc3RhcnRlZCA9IG1zX2Zsb2F0X3RvX25zX2ludDY0KG1zX3NpbmNlX3Byb2dyYW1fc3RhcnRlZCk7XG4gICAgLy8gc2hpZnQgbGVmdCBieSAxIGJlY2F1c2UgaW4gamF2YXNjcmlwdCwgYW4gaW50NjMgaXMgaW1wbGVtZW50ZWQgYXMgYW5cbiAgICAvLyBpbnQ2NCB3aXRoIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgc2V0IHRvIHplcm9cbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KG5zX3NpbmNlX3Byb2dyYW1fc3RhcnRlZCwgMSk7XG59XG4iLCIvL1Byb3ZpZGVzOiBwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3Rkb3V0XG52YXIgcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZG91dFxuLy9Qcm92aWRlczogcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZGVyclxudmFyIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnJcblxuLy9Qcm92aWRlczogcHB4X2V4cGVjdF9ydW50aW1lX2JlZm9yZV90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3Rcbi8vUmVxdWlyZXM6IHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnIsIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRvdXRcbmZ1bmN0aW9uIHBweF9leHBlY3RfcnVudGltZV9iZWZvcmVfdGVzdCAodm91dHB1dCwgdnN0ZG91dCwgdnN0ZGVycil7XG4gIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnIgPSBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3QodnN0ZGVyciwgdm91dHB1dCk7XG4gIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRvdXQgPSBjYW1sX21sX2NoYW5uZWxfcmVkaXJlY3QodnN0ZG91dCwgdm91dHB1dCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBwcHhfZXhwZWN0X3J1bnRpbWVfYWZ0ZXJfdGVzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmVcbi8vUmVxdWlyZXM6IHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnIsIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRvdXRcbmZ1bmN0aW9uIHBweF9leHBlY3RfcnVudGltZV9hZnRlcl90ZXN0ICh2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUodnN0ZG91dCxwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3Rkb3V0KTtcbiAgY2FtbF9tbF9jaGFubmVsX3Jlc3RvcmUodnN0ZGVycixwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3RkZXJyKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHBweF9leHBlY3RfcnVudGltZV9vdXRfY2hhbm5lbF9wb3NpdGlvblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsX2dldFxuZnVuY3Rpb24gcHB4X2V4cGVjdF9ydW50aW1lX291dF9jaGFubmVsX3Bvc2l0aW9uKGNoYW4pe1xuICB2YXIgaW5mbyA9IGNhbWxfbWxfY2hhbm5lbF9nZXQoY2hhbik7XG4gIHJldHVybiBpbmZvLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBwcHhfZXhwZWN0X3J1bnRpbWVfZmx1c2hfc3R1YnNfc3RyZWFtc1xuZnVuY3Rpb24gcHB4X2V4cGVjdF9ydW50aW1lX2ZsdXNoX3N0dWJzX3N0cmVhbXModnVuaXQpe1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLyogMHgwMC0weDFGOiBub25lICovLCAweDAwLCAweDAwLCAweGZmLFxuICAgIDB4MDMgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovLCAweGZlLCAweGZmLCAweGZmLFxuICAgIDB4ODcgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi8sIDB4ZmUsIDB4ZmYsIDB4ZmYsXG4gICAgMHgwNyAvKiAweDYwLTB4N0Y6IGEgdG8geiAqLywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvKiAweDgwLTB4OUY6IG5vbmUgKi8sXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvKiAweEEwLTB4QkY6IG5vbmUgKi8sIDB4ZmYsIDB4ZmYsIDB4N2YsXG4gICAgMHhmZiAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovLCAweGZmLCAweGZmLCAweDdmLFxuICAgIDB4ZmYgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqLyxcbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLFxuICAgIENIQVJOT1JNOiAxLFxuICAgIFNUUklORzogMixcbiAgICBTVFJJTkdOT1JNOiAzLFxuICAgIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsXG4gICAgRU9MOiA2LFxuICAgIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCxcbiAgICBFTkRHUk9VUDogOSxcbiAgICBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLFxuICAgIFNJTVBMRVNUQVI6IDEzLFxuICAgIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LFxuICAgIFBVU0hCQUNLOiAxNixcbiAgICBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOCxcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbYyA+PiAzXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocywgaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsIGkgPj4gMykgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG4gICAgdmFyIHByb2cgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgY3Bvb2wgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgbm9ybXRhYmxlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICBudW1ncm91cHMgPSByZVs0XSB8IDAsXG4gICAgICBudW1yZWdpc3RlcnMgPSByZVs1XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgIHN0YWNrID0gW10sXG4gICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ3JvdXBzW2ldID0geyBzdGFydDogLTEsIGVuZDogLTEgfTtcbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc3RhY2sucHVzaChpdGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoICogMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZiAoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIgKiBpICsgMV0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMiAqIGkgKyAxICsgMV0gPSBnLmVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFydGlhbCkgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICB9O1xuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgICBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgICBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJlZml4X21hdGNoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwO1xuICAgICAgICAgICAgaSA8IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSkgYyA9IHNbKytwb3NdO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwO1xuICAgICAgICAgICAgaSA8IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmVmaXhfbWF0Y2goKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgcG9zKys7XG4gICAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkJPTDpcbiAgICAgICAgICBpZiAocG9zID4gMCAmJiBzW3BvcyAtIDFdICE9PSAxMCAvKiBcXG4gKi8pIHtcbiAgICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgICBpZiAocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9PSAxMCAvKiBcXG4gKi8pIHtcbiAgICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwcmVmaXhfbWF0Y2goKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPT0gaXNfd29yZF9sZXR0ZXIoc1twb3NdKSkgYnJlYWs7XG4gICAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgICBwdXNoKHsgdW5kbzogeyBvYmo6IGdyb3VwLCBwcm9wOiBcInN0YXJ0XCIsIHZhbHVlOiBncm91cC5zdGFydCB9IH0pO1xuICAgICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgICAgcHVzaCh7IHVuZG86IHsgb2JqOiBncm91cCwgcHJvcDogXCJlbmRcIiwgdmFsdWU6IGdyb3VwLmVuZCB9IH0pO1xuICAgICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICAgIGlmIChncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge1xuICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGdyb3VwLnN0YXJ0OyBpIDwgZ3JvdXAuZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzW2ldICE9PSBzW3Bvc10pIHtcbiAgICAgICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuU0lNUExFT1BUOlxuICAgICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVNUQVI6XG4gICAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgICAgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZWZpeF9tYXRjaCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICAgIH0gZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5HT1RPOlxuICAgICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuUFVTSEJBQ0s6XG4gICAgICAgICAgcHVzaCh7IHBvczogeyBwYzogcGMgKyBzYXJnLCB0eHQ6IHBvcyB9IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgICBwdXNoKHtcbiAgICAgICAgICAgIHVuZG86IHsgb2JqOiByZV9yZWdpc3RlciwgcHJvcDogdWFyZywgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVfcmVnaXN0ZXJbdWFyZ10gPSBwb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICAgIGlmIChyZV9yZWdpc3Rlclt1YXJnXSA9PT0gcG9zKSBiYWNrdHJhY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGVjb2RlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiByZV9tYXRjaF9pbXBsO1xufSkoKTtcblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmIChwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIik7XG4gIHZhciBzdGFydGNoYXJzID0gcmVbNl0gfCAwO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICBpZiAoc3RhcnRjaGFycyA+PSAwKSB7XG4gICAgc3RhcnRjaGFycyA9IHJlWzJdW3N0YXJ0Y2hhcnMgKyAxXTtcbiAgICBkbyB7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBvcyA8IGxlbiAmJlxuICAgICAgICBjYW1sX3N0cmluZ19nZXQoc3RhcnRjaGFycywgY2FtbF9zdHJpbmdfZ2V0KHMsIHBvcykpID09PSAwXG4gICAgICApXG4gICAgICAgIHBvcysrO1xuICAgICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICAgIHBvcysrO1xuICAgIH0gd2hpbGUgKHBvcyA8PSBsZW4pO1xuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgICBwb3MrKztcbiAgICB9IHdoaWxlIChwb3MgPD0gbGVuKTtcbiAgfVxuICByZXR1cm4gWzBdOyAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmIChwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpO1xuICB2YXIgc3RhcnRjaGFycyA9IHJlWzZdIHwgMDtcbiAgaWYgKHN0YXJ0Y2hhcnMgPj0gMCkge1xuICAgIHN0YXJ0Y2hhcnMgPSByZVsyXVtzdGFydGNoYXJzICsgMV07XG4gICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgICBkbyB7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBvcyA+IDAgJiZcbiAgICAgICAgcG9zIDwgbGVuICYmXG4gICAgICAgIGNhbWxfc3RyaW5nX2dldChzdGFydGNoYXJzLCBjYW1sX3N0cmluZ19nZXQocywgcG9zKSkgPT09IDBcbiAgICAgIClcbiAgICAgICAgcG9zLS07XG4gICAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgICAgcG9zLS07XG4gICAgfSB3aGlsZSAocG9zID49IDApO1xuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgICBwb3MtLTtcbiAgICB9IHdoaWxlIChwb3MgPj0gMCk7XG4gIH1cbiAgcmV0dXJuIFswXTsgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLCBzLCBwb3MpIHtcbiAgaWYgKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zdHJpbmdfbWF0Y2hcIik7XG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUsIHMsIHBvcykge1xuICBpZiAocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIik7XG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAxKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9yZXBsYWNlbWVudF90ZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2dldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy8gZXh0ZXJuYWwgcmVfcmVwbGFjZW1lbnRfdGV4dDogc3RyaW5nIC0+IGludCBhcnJheSAtPiBzdHJpbmcgLT4gc3RyaW5nXG5mdW5jdGlvbiByZV9yZXBsYWNlbWVudF90ZXh0KHJlcGwsIGdyb3Vwcywgb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZSAobiA8IGxlbikge1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYgKGN1ciAhPT0gXCJcXFxcXCIpIHtcbiAgICAgIHJlcyArPSBjdXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuID09PSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogaWxsZWdhbCBiYWNrc2xhc2ggc2VxdWVuY2VcIik7XG4gICAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgICAgc3dpdGNoIChjdXIpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICBjYXNlIFwiOVwiOlxuICAgICAgICAgIGMgPSArY3VyO1xuICAgICAgICAgIGlmIChjICogMiA+PSBncm91cHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgICBzdGFydCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyAqIDIpO1xuICAgICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyAqIDIgKyAxKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICAgIHJlcyArPSBvcmlnLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlcyArPSBcIlxcXFxcIiArIGN1cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTtcbn1cbiIsIi8vUHJvdmlkZXM6c2hvdWxkX3VzZV90aW1lem9uZV9qc19sb2FkZXIgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gc2hvdWxkX3VzZV90aW1lem9uZV9qc19sb2FkZXIoeWVzLCBfcGxhdGZvcm1fbm90X3N1cHBvcnRlZCwgZGlzYWJsZWQpIHtcbiAgaWYgKGdsb2JhbFRoaXMuRElTQUJMRV9USU1FWk9ORV9KU19MT0FERVIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB5ZXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpc2FibGVkO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfZGlzYWJsZV9mb3JfdGVzdGluZ1xuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2Rpc2FibGVfZm9yX3Rlc3RpbmcoKSB7XG4gIGdsb2JhbFRoaXMuRElTQUJMRV9USU1FWk9ORV9KU19MT0FERVIgPSB0cnVlO1xufVxuXG4vL1Byb3ZpZGVzOnRpbWV6b25lX2pzX2xvYWRlcl9lbmFibGVfZm9yX3Rlc3RpbmdcbmZ1bmN0aW9uIHRpbWV6b25lX2pzX2xvYWRlcl9lbmFibGVfZm9yX3Rlc3RpbmcoKSB7XG4gIGdsb2JhbFRoaXMuRElTQUJMRV9USU1FWk9ORV9KU19MT0FERVIgPSB1bmRlZmluZWQ7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2NyZWF0ZV96b25lXG4vL1JlcXVpcmVzOmNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfY3JlYXRlX3pvbmUoem9uZV9uYW1lKSB7XG4gIHpvbmVfbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHpvbmVfbmFtZSk7XG4gIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5UZW1wb3JhbFBvbHlmaWxsLlRlbXBvcmFsLlRpbWVab25lKHpvbmVfbmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2dldF9uZXh0X3RyYW5zaXRpb25fb3JfdGhpc190aW1lX2lmX25vbmVcbmZ1bmN0aW9uIHRpbWV6b25lX2pzX2xvYWRlcl9nZXRfbmV4dF90cmFuc2l0aW9uX29yX3RoaXNfdGltZV9pZl9ub25lKHpvbmUsIGluc3RhbnQpIHtcbiAgdmFyIHJldCA9IHpvbmUuZ2V0TmV4dFRyYW5zaXRpb24oaW5zdGFudCk7XG4gIGlmIChyZXQpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnN0YW50O1xuICB9XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2Zyb21fZXBvY2hfc2Vjb25kc1xuLy9SZXF1aXJlczpjYW1sX2ludDY0X3RvX2Zsb2F0XG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfZnJvbV9lcG9jaF9zZWNvbmRzKHNlY29uZHMpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbC5UZW1wb3JhbC5JbnN0YW50LmZyb21FcG9jaFNlY29uZHMoY2FtbF9pbnQ2NF90b19mbG9hdChzZWNvbmRzKSk7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2NvbXBhcmVfaW5zdGFudHNcbmZ1bmN0aW9uIHRpbWV6b25lX2pzX2xvYWRlcl9jb21wYXJlX2luc3RhbnRzKGEsIGIpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbC5UZW1wb3JhbC5JbnN0YW50LmNvbXBhcmUoYSwgYik7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2Vwb2NoX3NlY29uZHNcbi8vUmVxdWlyZXM6Y2FtbF9pbnQ2NF9vZl9mbG9hdFxuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2Vwb2NoX3NlY29uZHMoaW5zdGFudCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChpbnN0YW50LmVwb2NoU2Vjb25kcyk7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX25vd1xuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX25vdygpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbC5UZW1wb3JhbC5Ob3cuaW5zdGFudCgpO1xufVxuXG4vL1Byb3ZpZGVzOnRpbWV6b25lX2pzX2xvYWRlcl9pbnN0YW50X3BsdXNfaG91cnNcbi8vUmVxdWlyZXM6Y2FtbF9pbnQ2NF90b19mbG9hdFxuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2luc3RhbnRfcGx1c19ob3VycyhpbnN0YW50LCBob3Vycykge1xuICBob3VycyA9IGNhbWxfaW50NjRfdG9fZmxvYXQoaG91cnMpO1xuICB2YXIgZHVyYXRpb24gPSBnbG9iYWxUaGlzLlRlbXBvcmFsUG9seWZpbGwuVGVtcG9yYWwuRHVyYXRpb24uZnJvbSh7IGhvdXJzOiBob3VycyB9KTtcbiAgcmV0dXJuIGluc3RhbnQuYWRkKGR1cmF0aW9uKTtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfZ2V0X29mZnNldF9uYW5vc19mb3Jcbi8vUmVxdWlyZXM6Y2FtbF9pbnQ2NF9vZl9mbG9hdFxuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2dldF9vZmZzZXRfbmFub3NfZm9yKHpvbmUsIGluc3RhbnQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoem9uZS5nZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihpbnN0YW50KSk7XG59XG4iXSwibmFtZXMiOlsiY3N0X0Fzc2VydF9mYWlsdXJlIiwiY3N0X0RpdmlzaW9uX2J5X3plcm8iLCJjc3RfRW5kX29mX2ZpbGUiLCJjc3RfRmFpbHVyZSIsImNzdF9JbnZhbGlkX2FyZ3VtZW50IiwiY3N0X01hdGNoX2ZhaWx1cmUiLCJjc3RfTm90X2ZvdW5kIiwiY3N0X091dF9vZl9tZW1vcnkiLCJjc3RfU3RhY2tfb3ZlcmZsb3ciLCJjc3RfU3lzX2Jsb2NrZWRfaW8iLCJjc3RfU3lzX2Vycm9yIiwiY3N0X1VuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIl0sIm1hcHBpbmdzIjoiQUFBQSxDQUFBO0FBQUE7QUFBQSxHQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUE7QUFBQSxTQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQTtBQUFBLEdBQUE7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0NXQyxDQUFDO0FBQUE7QUFBQTtBQUFBLFNBRW9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEseUJBcUJJO0FBQUEsb0JBQ1A7QUFBQTtBQUFBLE1BSWY7QUFBQSxPQUNJO0FBQUEsT0FDQTtBQUFBLE9BQ0Esc0JBQXNCO0FBQUE7QUFBQTtBQUFBLE9BS3RCO0FBQUEsNkJBQWtDLFdBQWEsZUFBZSxpQkFBZ0IsQ0FBNUM7QUFBQSxPQUNsQztBQUFBO0FBQUE7QUFBQSxrQkFJUztBQUFBLDhCQUNZO0FBQUE7QUFBQSxPQUVyQjtBQUFBLFFBQ0k7QUFBQTtBQUFBLFNBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFFSjtBQUFBO0FBQUEsTUFFUjtBQUFBLE1BRUE7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBO0FBQUEsT0FJSSxjQUFjO0FBQUEsT0FDZCxjQUFjO0FBQUEsT0FDZCxTQUFTO0FBQUEsTUFDYjtBQUFBLE1BRUE7QUFBQTtBQUFBLE9BR0ksZ0JBQ0ksWUFDQTtBQUFBLE9BRUo7QUFBQSxRQUNJO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBRVMsU0FBVztBQUFBLE9BQ3hCLE9BQU8sZ0JBQWdCO0FBQUEsTUFDM0I7QUFBQSxNQUVBO0FBQUE7QUFBQSxPQUVJO0FBQUEsUUFDSTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFFUyxTQUFXO0FBQUEsT0FDeEIsT0FBTyxnQkFBZ0I7QUFBQSxNQUMzQjtBQUFBO0FBQUEsT0FJSTtBQUFBO0FBQUE7QUFBQSxRQUNJO0FBQUEsUUFDQTtBQUFBO0FBQUEsT0FHSjtBQUFBLFFBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFHVyxVQUFVO0FBQUEsV0FBVjtBQUFBLE9BQ2YsT0FBTyxnQkFBZ0I7QUFBQSxNQUMzQjtBQUFBLHdCQUVrQjtBQUFBO0FBQUEsT0FFZDtBQUFBLFFBQ0k7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUdBO0FBQUE7QUFBQTtBQUFBLHNCQUVTLFNBQVc7QUFBQSxPQUN4QixPQUFPLGdCQUFnQjtBQUFBLE1BQzNCO0FBQUE7QUFBQSxPQUdJO0FBQUE7QUFBQTtBQUFBLE9BQ0EsT0FBTyxnQ0FBZ0M7QUFBQSxNQUMzQztBQUFBLE1BSUE7QUFBQSxPQUFvQyxzQkFFOUIsU0FBUSxVQUFVLENBRFQ7QUFBQTtBQUFBO0FBQUEsa0JBTUM7QUFBQSxnQ0FDYztBQUFBLDJCQUNMO0FBQUEsK0JBTUk7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQU1yQjtBQUFBLGdDQUMyQjtBQUFBLFNBQ3ZCO0FBQUEsVUFDSTtBQUFBLFVBQ0EsY0FBYztBQUFBLFVBRWQ7QUFBQSxVQUVBO0FBQUEsV0FBc0I7QUFBQSxZQUdKO0FBQUE7QUFBQSxxQ0FBZ0M7QUFBQTtBQUFBO0FBQUEsU0FHdEQ7QUFBQTtBQUFBO0FBQUEsU0FHQSxZQUFZO0FBQUEsU0FFWjtBQUFBLFVBQXNCO0FBQUEsV0FDWDtBQUFBO0FBQUEsYUFBUyxpQkFBaUI7QUFBQTtBQUFBO0FBQUEsUUFJekMsT0FBTyxnREFBZ0Q7QUFBQSxPQUMzRDtBQUFBO0FBQUE7QUFBQSx3QkFHcUI7QUFBQSxtQkFDTDtBQUFBLHFCQUNFO0FBQUEsa0JBQ0g7QUFBQSxzQkFDSTtBQUFBLFFBRWYsWUFBVztBQUFBLCtCQUVlO0FBQUEsU0FFdEI7QUFBQSxVQUVJLDJCQUNJLGNBQ0E7QUFBQSwwQ0FJQSxlQUNBO0FBQUEsMENBSUEsZUFDQTtBQUFBO0FBQUEsV0FJRjtBQUFBLFlBQWdCO0FBQUE7QUFBQTtBQUFBLGFBRVo7QUFBQTtBQUFBLFdBR0o7QUFBQSxXQUNBO0FBQUE7QUFBQSxVQUdGO0FBQUE7QUFBQSxhQU9RLDRCQUE0QixnQkFDNUI7QUFBQTtBQUFBLGFBS0EsOEJBQThCLGtCQUM5QjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCLFNBQVMsV0FBVztBQUFBLGFBQ3BDO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBZ0I7QUFBQSxhQUNoQjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCO0FBQUEsYUFDaEI7QUFBQTtBQUFBLGFBS0EsZ0JBQWdCLFNBQVMsMkJBQ3pCO0FBQUE7QUFBQSxhQUtBLGdCQUFnQixTQUFTLFFBQVE7QUFBQSxhQUNqQztBQUFBO0FBQUEsYUFLQSxnQkFBZ0IsU0FBUywrQkFDekI7QUFBQTtBQUFBLGFBS0EsZ0JBQWdCLFNBQVMsNkJBQ3pCO0FBQUE7QUFBQSxhQUtBLGdCQUFnQjtBQUFBLGFBQ2hCO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBZ0I7QUFBQSxhQUNoQjtBQUFBO0FBQUEsYUFLQSxnQkFBZ0IsU0FBUyw2QkFDekI7QUFBQTtBQUFBLGFBS0E7QUFBQSxjQUFnQjtBQUFBLGFBQ2hCO0FBQUE7QUFBQSxhQUtBLGdCQUFnQixTQUFTO0FBQUEsYUFDekI7QUFBQTtBQUFBLGFBS0EsZ0JBQWdCLFNBQVM7QUFBQSxhQUN6QjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCO0FBQUEsYUFDaEI7QUFBQTtBQUFBLGFBS0EsZ0JBQWdCLG9CQUNoQjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQXFEO0FBQUE7QUFBQSw2QkFLbEM7QUFBQSxjQUNmO0FBQUE7QUFBQSxhQUVKO0FBQUE7QUFBQSxhQUtBLGlDQUFpQyxnQkFDakM7QUFBQTtBQUFBLGFBS0EsbUNBQW1DLGtCQUNuQztBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCO0FBQUEsYUFDaEI7QUFBQTtBQUFBLGFBS0EsZ0JBQWdCLFNBQVMsMEJBQ3pCO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBZ0IsU0FBUztBQUFBLGFBQ3pCO0FBQUE7QUFBQSxhQUtBLG1DQUFtQyxrQkFDbkM7QUFBQTtBQUFBO0FBQUEsa0JBS1EsU0FBUztBQUFBO0FBQUEsZ0JBQ1A7QUFBQSxtQkFBVyxpQkFBaUI7QUFBQSxhQUN0QyxnQkFBZ0I7QUFBQSxhQUNoQjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCLFNBQVM7QUFBQSxhQUN6QjtBQUFBO0FBQUEsYUFLQTtBQUFBLGNBQWdCO0FBQUEsZ0JBQVMsUUFBUTtBQUFBLGFBQ2pDO0FBQUE7QUFBQSxhQUtBLGdCQUFnQixTQUFTLCtCQUN6QjtBQUFBO0FBQUEsYUFLQSxzQkFDQTtBQUFBO0FBQUEsYUFLQSxnQkFBZ0IsT0FBTyxrQkFBa0IsUUFBUTtBQUFBLGFBQ2pEO0FBQUE7QUFBQSxhQUtBLGdCQUFnQjtBQUFBLGFBQ2hCO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBZ0I7QUFBQSxhQUNoQjtBQUFBO0FBQUEsYUFLQSxnQkFBZ0IsOEJBQ2hCO0FBQUE7QUFBQSxhQUtBLHNCQUNBO0FBQUE7QUFBQSx1QkFLVTtBQUFBLGFBQ1Y7QUFBQSxhQUNBO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBZ0I7QUFBQSxhQUNoQjtBQUFBO0FBQUEsYUFLQSxnQkFBZ0IsZUFDaEI7QUFBQTtBQUFBLGFBS0E7QUFBQSxjQUFnQjtBQUFBLGFBQ2hCO0FBQUE7QUFBQSxhQUtBLGdCQUFnQixNQUFNLHlCQUFOLEtBQ2hCO0FBQUE7QUFBQSxhQUtBO0FBQUEsY0FBcUQ7QUFBQTtBQUFBO0FBQUEsY0FLakQ7QUFBQSxlQUFpQztBQUFBO0FBQUEsZUFHNUIsUUFDTTtBQUFBO0FBQUEsc0JBRUY7QUFBQSxxQkFDRDtBQUFBLHVCQUNJLFdBQVc7QUFBQSxzQkFDWjtBQUFBLGNBQ1gsdUJBQXVCLHdCQUF3QjtBQUFBO0FBQUEsYUFFbkQ7QUFBQSxxQkFHQSwyQkFDQTtBQUFBO0FBQUEsVUFHUjtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUE7QUFBQSxTQUlKLDJCQUNJLGtCQUNBO0FBQUEsU0FHSjtBQUFBO0FBQUEsUUFHSixtQkFBbUI7QUFBQSxPQUN2QjtBQUFBLHNCQUVhO0FBQUEsT0FFYjtBQUFBO0FBQUEsU0FDSSxPQUFPO0FBQUE7QUFBQSw2RUFBd0U7QUFBQSxRQUQvRDtBQUFBLE9BSXBCO0FBQUE7QUFBQTtBQUFBLGlDQUM2QjtBQUFBLDRCQUNMO0FBQUEseUJBRUg7QUFBQSxTQUNqQjtBQUFBLFVBQ0k7QUFBQSxVQUdBO0FBQUE7QUFBQSxtQkFDYTtBQUFBLG9CQUNHLFNBQVM7QUFBQSxzQkFDUCxTQUFTO0FBQUEsV0FFdkI7QUFBQTtBQUFBO0FBQUEsV0FHZ0M7QUFBQTtBQUFBLFNBS3hDLE9BQU8sNERBQTREO0FBQUEsUUF0Qm5EO0FBQUEsT0F5QnBCO0FBQUEsbUJBQ0ksT0FBTyxrREFBa0QsQ0FEOUM7QUFBQSxPQUlmLGVBQWU7QUFBQSxNQUNuQjtBQUFBO0FBQUEsT0FHSSwwQ0FBMkMsa0JBQ3JCO0FBQUEsT0FFdEIsd0JBQXlCO0FBQUEsT0FHekIsZ0NBQWdDO0FBQUEsTUFDcEM7QUFBQTtBQUFBLE9BR0kscUJBQXNCLGtCQUNBO0FBQUEsT0FFdEIsb0JBQXFCLHdCQUNPO0FBQUEsT0FFNUIseUJBQXlCO0FBQUEsTUFDN0I7QUFBQTtBQUFBLE9BR0ksZUFBZ0IsU0FDSCxxQkFFTyxnQkFDQTtBQUFBLE9BRXBCLFdBQVc7QUFBQSxNQUNmO0FBQUE7QUFBQSxPQU1JO0FBQUEscUJBSWM7QUFBQSxPQUNkO0FBQUEsUUFBK0Isa0JBRXZCLGtCQUVBO0FBQUE7QUFBQSw0QkFHZ0IsU0FBUztBQUFBO0FBQUEsVUFDbkIsU0FBUyxvQkFBb0IsaUJBQWlCO0FBQUEsZUFDakQ7QUFBQSxrQkFDQztBQUFBLE9BRVosT0FBTyxtQkFBbUI7QUFBQSxNQUM5QjtBQUFBO0FBQUEsZUFJVSxrQkFDQztBQUFBLE9BRVAsOENBQWlELFdBQ2xDO0FBQUEsT0FFZixrQkFDWSxXQUFXLFNBQ1gsV0FBVyxTQUNYLFdBQVc7QUFBQTtBQUFBLE1BRTNCO0FBQUE7QUFBQSxPQUdJLFFBQVEsc0NBQXNDO0FBQUEsTUFDbEQ7QUFBQSxLQXJtQkY7QUFBQTtBQUFBLEVEWEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0VDUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUNOO0FBQUEseUJBS00sUUFDQSxTQUNBO0FBQUEsS0FDSjtBQUFBLE1BQ0UsWUFBYSwwQkFDWCxHQUFJLGlCQUFpQixNQUFNLEVBQzNCO0FBQUE7QUFBQTtBQUFBLE9BQ0s7QUFBQTtBQUFBLG9CQUFrQixxQkFBcUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUU5QztBQUFBO0FBQUEsTUFFQTtBQUFBLE9BQ0UsbUNBQW1DLFlBQVk7QUFBQSxRQUFrQixNQUFNO0FBQUE7QUFBQSxjQUV2RSxNQUFPO0FBQUE7QUFBQSxLQUdYLFFBQVE7QUFBQTtBQUFBLEdBRVo7QUFBQTtBQUFBLFlBRVU7QUFBQSxJQUNSO0FBQUEsYUFDVTtBQUFBLEtBQ1I7QUFBQTtBQUFBO0FBQUEsT0FBVTtBQUFBLHFCQUNSLE9BQU8sZ0RBQWdELENBRHRDO0FBQUEsS0FFZDtBQUFBO0FBQUEsSUFFUCxRQUFRO0FBQUEsR0FDVjtBQUFBO0FBQUEsSUFFRSxZQUFXO0FBQUEsYUFDSDtBQUFBLEtBQ047QUFBQSxRQUFRO0FBQUEsVUFBUTtBQUFBLFFBQVIsYUFDTiw0QkFEcUM7QUFBQTtBQUFBLFVBRUMsMkJBQTJCO0FBQUEsVUFBdUM7QUFBQSxZQUFRO0FBQUEsVUFBUjtBQUFBLFlBQ3hHLDRCQUE0QjtBQUFBLFdBRHVHO0FBQUE7QUFBQSxJQUl2SSxRQUFRO0FBQUEsR0FDVjtBQUFBO0FBQUEsSUFFRSxnQ0FBZ0MsUUFBUTtBQUFBLFlBQ2xDO0FBQUEsSUFDTjtBQUFBLGFBQ1U7QUFBQSxLQUNSLHlCQUEwQixRQUFRO0FBQUEsS0FDbEMsTUFBTTtBQUFBO0FBQUEsSUFFUixPQUFPLHFDQUFxQztBQUFBLEdBQzlDO0FBQUE7QUFBQSxZQUVVO0FBQUEsSUFDUixrQ0FBa0MsU0FBUztBQUFBLEdBQzdDO0FBQUE7QUFBQSxJQUVFO0FBQUEsSUFFQTtBQUFBO0FBQUEsMkJBQ0UsZUFBZSxDQURvRTtBQUFBO0FBQUE7QUFBQSxlQUduRjtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUFtSDtBQUFBLGNBRGpIO0FBQUEsV0FFRCxVQUFVO0FBQUEsR0FDZjtBQUFBO0FBQUEsSUFFRTtBQUFBLEtBQXdDLE1BQ2hDO0FBQUEsR0FFVjtBQUFBO0FBQUEsSUFFRSxZQUFXO0FBQUEsc0JBQ007QUFBQSxLQUNmO0FBQUEsS0FDQTtBQUFBLEtBQ0EsMEJBQTJCO0FBQUEsS0FDM0IsOEJBQThCO0FBQUE7QUFBQSxHQUVsQztBQUFBO0FBQUEsSUFFRSxlQUFnQjtBQUFBLElBQ2hCLGdCQUFpQjtBQUFBLElBQ2pCO0FBQUEsSUFHQSxrQkFBa0I7QUFBQSxHQUNwQjtBQUFBO0FBQUEsSUFFRSxNQUFNO0FBQUEsSUFDTjtBQUFBLEtBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBTUs7QUFBQSxJQUdQLFVBQVU7QUFBQSxHQUNaO0FBQUE7QUFBQSxJQUVFO0FBQUEsS0FBNkQsTUFDckQ7QUFBQSxJQUVSO0FBQUEsS0FBcUI7QUFBQTtBQUFBO0FBQUEsSUFPckI7QUFBQSxJQUdBLGVBQWdCO0FBQUEsR0FDbEI7QUFBQTtBQUFBLElBRUU7QUFBQTtBQUFBLFFBQTBDO0FBQUEsb0JBQ3hDLHNCQUFzQix3QkFBd0IsQ0FEeUI7QUFBQSxJQUd6RSxPQUFPLGtCQUFrQjtBQUFBLEdBQzNCO0FBQUE7QUFBQSxJQUVFO0FBQUE7QUFBQSxRQUEwQztBQUFBLHVCQUN4QyxpQkFDQSxRQUFRLENBRitEO0FBQUEsSUFJekUsT0FBTyxxQkFBcUI7QUFBQSxHQUM5QjtBQUFBO0FBQUEsSUFFRSwwREFBMEQsWUFBWTtBQUFBLElBQ3RFLDJCQUE0QixZQUFZO0FBQUEsSUFDeEMsZ0NBQWlDLFdBQVc7QUFBQSxJQUM1QztBQUFBLEtBQ0U7QUFBQSxPQUErQiwwQ0FBK0I7QUFBQSxLQUM5RCxXQUFXO0FBQUE7QUFBQSxhQUVYLFlBQVk7QUFBQSxHQUVoQjtBQUFBO0FBQUEsSUFFRTtBQUFBLEtBQXFCLE1BQ2I7QUFBQTtBQUFBO0FBQUEsSUFFUixXQUFXO0FBQUEsR0FDYjtBQUFBO0FBQUEsSUFFRTtBQUFBLEtBQXNFLFdBQ3pEO0FBQUE7QUFBQSxLQUNlLE1BQ3BCO0FBQUE7QUFBQTtBQUFBLElBRVIsT0FBTyw0QkFBNEI7QUFBQSxHQUNyQztBQUFBO0FBQUEsb0NBRWtDO0FBQUEsSUFDaEM7QUFBQSxpQkFDYztBQUFBLEtBRVo7QUFBQSxzQkFDa0I7QUFBQSxNQUNoQixTQUFTO0FBQUE7QUFBQTtBQUFBLE1BQ0osU0FDSTtBQUFBLEtBRVgsT0FBTyx3Q0FBd0MsQ0FUMUMsQ0FVTjtBQUFBLEdBQ0g7QUFBQTtBQUFBLElBRUUsUUFBUSx3REFDTixTQUFTLHlCQUNULG9CQUFxQjtBQUFBLElBRXZCLGFBQWE7QUFBQSxHQUNmO0FBQUE7QUFBQSxJQUVFO0FBQUEsS0FBbUQsT0FDMUM7QUFBQTtBQUFBLEtBQ0Y7QUFBQTtBQUFBLGtCQUVRO0FBQUEsT0FDWCxXQUFXLE1BQU07QUFBQSxrQkFDTjtBQUFBLE9BQ1g7QUFBQSxRQUFjLE9BQ0wsdURBQXVEO0FBQUEsT0FFaEUsaUJBQWlCO0FBQUEsTUFQWjtBQUFBLElBVVQsT0FBTywyQkFBMkI7QUFBQSxHQUNwQztBQUFBO0FBQUEsSUFFRSxPQUFPLHdCQUF3QjtBQUFBLGNBQWlDO0FBQUEsY0FBdUMsa0JBQWtCO0FBQUEsR0FDM0g7QUFBQTtBQUFBLElBRUUsT0FBTywyQkFBMkI7QUFBQSxjQUF5QjtBQUFBLGNBQW9DLG9CQUFvQjtBQUFBLEdBQ3JIO0FBQUE7QUFBQSxJQUVFLEdBQUksb0JBQW9CLE9BQU8sc0JBQXNCO0FBQUEsR0FDdkQ7QUFBQSxpQ0FFRSxHQUFJLG9CQUFvQixVQUFVLENBQ3BDO0FBQUE7QUFBQSxJQUVFO0FBQUE7QUFBQTtBQUFBLEtBQWtHLE9BQU8sZ0JBQWdCO0FBQUEsR0FDM0g7QUFBQTtBQUFBLElBRUUsUUFBUSxNQUFNO0FBQUEsSUFDZCwwQkFBMkIsT0FBTyw0QkFBNEI7QUFBQSxZQUN0RDtBQUFBLElBQ1Isb0NBQXFDO0FBQUEsSUFDckMsK0JBQWdDLE9BQU8sYUFBYTtBQUFBLElBQ3BEO0FBQUEsMkJBQXlCO0FBQUEsS0FBb0QsT0FBTyw0QkFBNEI7QUFBQSxHQUNsSDtBQUFBO0FBQUEsSUFFRSxvQ0FBcUM7QUFBQSxJQUNyQyxZQUFXLFVBQVksOEJBQThCO0FBQUEsSUFDckQsV0FBVztBQUFBLEdBQ2I7QUFBQTtBQUFBLElBRUUsTUFBTTtBQUFBO0FBQUE7QUFBQSxHQUNSO0FBQUE7QUFBQSxJQUVFLE1BQU07QUFBQTtBQUFBO0FBQUEsR0FDUjtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BRVM7QUFBQSxJQUNQO0FBQUEsS0FDRTtBQUFBLE9BQUksMEJBQTBCO0FBQUE7QUFBQSxNQUM1QixPQUFRO0FBQUEsY0FDRixPQUNBLFdBQUU7QUFBQSxNQUNSO0FBQUE7QUFBQTtBQUFBLGVBR0ksa0JBQW1CLG1CQUVsQjtBQUFBLGVBQ0QsbUNBR0M7QUFBQSxjQVBBO0FBQUEsNkJBVUQsUUFEQztBQUFBLG1CQUlKO0FBQUE7QUFBQSxLQUVILE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQSwyQkFFYSxlQUNaO0FBQUEsSUFFVCxzQkFFSSxLQUFLLFdBREo7QUFBQTtBQUFBO0FBQUEsd0JBSVU7QUFBQSxhQUNYO0FBQUEsYUFDQSxXQUFXO0FBQUEsWUFIVjtBQUFBLDJCQU1ELGVBQ0EsUUFGQztBQUFBO0FBQUE7QUFBQSxhQUtELElBQ0UsNENBQTRDO0FBQUEscUJBRTVDLFdBQVk7QUFBQSxZQUpiLEVBT0o7QUFBQSxHQUNIO0FBQUEsV0FFTTtBQUFBO0FBQUEsSUFFSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBTWdCLDJCQUEyQjtBQUFBO0FBQUEsSUFFM0M7QUFBQSxLQUNFLElBQUssMEJBQXlCO0FBQUEsZUFDckIsa0JBQ0U7QUFBQSxNQUNUO0FBQUEsK0JBQXlEO0FBQUE7QUFBQTtBQUFBLGVBRzNEO0FBQUEsWUFFQTtBQUFBO0FBQUE7QUFBQSxPQUVlLDJCQUEyQjtBQUFBO0FBQUEsSUFFNUM7QUFBQSxLQUNFLElBQUssNEJBQTJCO0FBQUE7QUFBQSxhQUN0QjtBQUFBLGFBQ0U7QUFBQSxNQUNWO0FBQUEsZ0NBQTREO0FBQUE7QUFBQTtBQUFBLGVBRzlEO0FBQUEsWUFFQTtBQUFBLElBRUY7QUFBQSxJQUF1QixnQkFBZ0I7QUFBQSxHQUN6QztBQUFBO0FBQUEsWUFFVTtBQUFBLElBQ1I7QUFBQSxLQUFxQixNQUFNLFVBQVU7QUFBQSxJQUNyQztBQUFBLEdBQ0Y7QUFBQSw0QkFFRSxXQUFXLENBQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUVNO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDRTtBQUFBLFFBQ0U7QUFBQSxHQUNSLDJDQUNFLE9BQU8sUUFBUSxDQURjO0FBQUEsV0FHekIsbUJBQ0U7QUFBQSxHQUNSLDJDQUNFLFNBQVMscUJBRG9CO0FBQUEsV0FHekI7QUFBQTtBQUFBLElBRUosc0JBQXNCLFlBQVksVUFBUztBQUFBLFlBQ25DO0FBQUEsSUFDUjtBQUFBO0FBQUEsYUFBYztBQUFBLFVBQXdCO0FBQUEsYUFBeUM7QUFBQTtBQUFBO0FBQUEsS0FBMEI7QUFBQSxJQUd6RyxnQkFBYyxvQkFDWixhQUFhLENBRE8sRUFFcEI7QUFBQSxHQUNKO0FBQUE7QUFBQSxnQkFHUSxNQUFRO0FBQUEsSUFDZCxpQkFBa0IsTUFBTSxjQUFjO0FBQUEsSUFDdEMsUUFBUTtBQUFBLEdBQ1Y7QUFBQTtBQUFBLFlBRVU7QUFBQSxJQUNSO0FBQUEsS0FBa0IsTUFBTTtBQUFBLElBQ3hCLFNBQVUsTUFBTSxjQUFjO0FBQUEsSUFDOUI7QUFBQSxHQUNGO0FBQUE7QUFBQTtBQUFBLE1BQ007QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFtQixDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFEO0FBQUE7QUFBQSxRQUNyQjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFBQSxNQUNFO0FBQUE7QUFBQSxRQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUNiO0FBQUE7QUFBQSxNQUNBO0FBQUEsUUFDRSxXQUFXO0FBQUEsUUFDYjtBQUFBO0FBQUEsTUFDRTtBQUFBO0FBQUEsUUFBVyxDQUFDO0FBQUEsVUFBc0I7QUFBQSxVQUFrRTtBQUFBLFVBQXdDO0FBQUEsU0FBakk7QUFBQTtBQUFBO0FBQUEsTUFDWDtBQUFBO0FBQUEsUUFBVyxDQUFDO0FBQUEsVUFBd0I7QUFBQSxVQUE4QjtBQUFBLFVBQXNDO0FBQUEsU0FBN0Y7QUFBQTtBQUFBO0FBQUEsTUFDWDtBQUFBO0FBQUEsUUFBVztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQ1g7QUFBQTtBQUFBLFFBQVc7QUFBQTtBQUFBO0FBQUEsUUFDYjtBQUFBO0FBQUEsTUFDRTtBQUFBO0FBQUEsUUFBVztBQUFBO0FBQUE7QUFBQSxNQUNYO0FBQUE7QUFBQSxRQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FDWjtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0U7QUFBQSxTQUNGO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNFO0FBQUEsU0FDRjtB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eEU7QUFBQTtBQUFBO0FBQUEsTUVoRGM7QUFBQTtBQUFBLG9CQVNEO0FBQUEsa0JBQ0Y7QUFBQSxTQUNQLHNCQUF1QjtBQUFBLFNBR3ZCO0FBQUEsU0FDQTtBQUFBLFFBQ0Y7QUFBQTtBQUFBLGtCQU1TO0FBQUEsU0FDUCxXQUFZO0FBQUEsa0JBR0w7QUFBQSxTQUNQLHNCQUF1QjtBQUFBLFNBR3ZCO0FBQUEsU0FDQTtBQUFBLFFBQ0Y7QUFBQTtBQUFBLFNBSUUscUVBQTJFO0FBQUEsUUFDN0U7QUFBQTtBQUFBLG9CQUtXLFlBQ0EsZ0JBQ0EsWUFDQTtBQUFBLFNBRVQ7QUFBQSxTQUNBO0FBQUEsb0JBR1Msb0JBQ0E7QUFBQSxTQUNUO0FBQUEsU0FDQTtBQUFBLFNBRUE7QUFBQSxTQUdBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FFQTtBQUFBLFNBQ0E7QUFBQSxTQUdBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUEsU0FFQTtBQUFBLFNBR0E7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBLFNBQ0E7QUFBQSxRQUNGO0FBQUE7QUFBQTtBQUFBLFdBR3FCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FNUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFlRyxlQUNkLHVCQUNFLFlBQVksQ0FESDtBQUFBLGFBT0g7QUFBQSxhQUNBO0FBQUE7QUFBQSxpQkFFRjtBQUFBLFNBR047QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBO0FBQUEsU0FJRjtBQUFBLFNBQ0E7QUFBQSxTQUlBLFNBQ0UsaUJBQ0E7QUFBQSxTQUlGLHdCQUF5QixPQUNoQjtBQUFBLFNBTVQ7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxV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RTtBQUFBLFNBQ0E7QUFBQSxTQUNBO0FBQUE7QUFBQSxRQUVGLGlCQUNFLDJCQUNBO0FBQUE7QUFBQSxRQUtGO0FBQUEsU0FDRTtBQUFBLFNBQ0E7QUFBQSxVQUNFO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUE7QUFBQTtBQUFBLFdBTUUsc0JBQXVCO0FBQUEsV0FDdkI7QUFBQSxXQUNBO0FBQUE7QUFBQTtBQUFBLFdBRUEsc0JBQXVCO0FBQUEsV0FDdkI7QUFBQSxZQUNFLHNCQUF1QjtBQUFBLFlBQ3ZCLHdCQUF3QjtBQUFBO0FBQUEsV0FHMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBSUosNkJBQ0Usd0JBQXdCO0FBQUEsU0FDMUIsc0JBQXVCO0FBQUEsU0FDdkI7QUFBQSxTQUNBO0FBQUEsU0FDQTtBQUFBO0FBQUE7QUFBQSxRQUtGLDBCQUNBLGdCQUFpQjtBQUFBO0FBQUEsUUFJakI7QUFBQSxTQUNFO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxRQUNBLDZCQUNFLHFCQUNBO0FBQUE7QUFBQSxRQUtGO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQTtBQUFBLFFBSUEsc0JBQXVCO0FBQUEsZ0JBQ2pCO0FBQUEsUUFDTjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUE7QUFBQTtBQUFBLFNBTUU7QUFBQTtBQUFBLFNBQ0c7QUFBQSxRQUNMLDZCQUNFLHFCQUNBO0FBQUE7QUFBQSxRQUtGLCtCQUNBO0FBQUE7QUFBQSxRQUdBO0FBQUEsUUFDQTtBQUFBLGtCQUNRO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxTQUFjO0FBQUEsUUFJZDtBQUFBLFFBQ0E7QUFBQSxnQkFHQSx3QkFBd0I7QUFBQTtBQUFBLElBSTlCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLFVBQVU7QUFBQSxHQUNaO0FBQUE7QUFBQSxJOUIy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QUN0RDtBQUFBO0FBQUEsa0JOc0tjO0FBQUEsSUFDWjtBQUFBLEtBQ0U7QUFBQTtBQUFBO0FBQUEsUUFDRTtBQUFBLFFBQ0E7QUFBQSxPQUY4QjtBQUFBO0FBQUEsS0FLaEM7QUFBQTtBQUFBO0FBQUEsUUFDRSxnQkFDRTtBQUFBLE9BRmlDO0FBQUEsR0FNekM7QUFBQSxHQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxxQmJoYUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsaUNBQUEiLCJpZ25vcmVMaXN0IjpbMCw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxOCwxOSwyMCwyMSwyMiwyMywyNCwyNiwyOSwzMCwzMSwzMiwzMywzNCwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0OV19fV19
