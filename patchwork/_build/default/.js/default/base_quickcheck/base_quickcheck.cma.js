// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Base_quickcheck__
//# shape: Base_quickcheck__:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck = [0],
    Base_quickcheck$0 = [0, Base_quickcheck];
   runtime.caml_register_global(0, Base_quickcheck$0, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
//# shape: Base_quickcheck__With_basic_types:[]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
//# shape: Base_quickcheck__Bigarray_helpers:[[F(1)*],N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     offset$0 = offset(caml_ba_layout(t)),
     a = caml_ba_dim_1(t) - 1 | 0,
     b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      caml_call2(f, i + offset$0 | 0, caml_ba_get_1(t, i + offset$0 | 0));
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[20][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var a = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], a);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var offset$0 = offset(caml_ba_layout(t)), a = caml_ba_dim_1(t);
    return Base_Array[41].call
            (null, a, function(i){return caml_ba_get_1(t, i + offset$0 | 0);});
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return Base[95].call(null, sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var a = caml_ba_dim_1(t), state$0 = caml_call2(Base[133], state, a);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     offset$0 = offset(caml_ba_layout(t)),
     a = caml_ba_dim_1(t) - 1 | 0,
     c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var b = caml_ba_dim_2(t) - 1 | 0, d = 0;
      if(b >= 0){
       var j = d;
       for(;;){
        caml_call3
         (f,
          i + offset$0 | 0,
          j + offset$0 | 0,
          caml_ba_get_2(t, i + offset$0 | 0, j + offset$0 | 0));
        var g = j + 1 | 0;
        if(b === j) break;
        j = g;
       }
      }
      var e = i + 1 | 0;
      if(a === i) break;
      i = e;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[21][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(a, param, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var offset$0 = offset(caml_ba_layout(t)), a = caml_ba_dim_1(t);
    return Base_Array[41].call
            (null,
             a,
             function(i){
              var a = caml_ba_dim_2(t);
              return Base_Array[41].call
                      (null,
                       a,
                       function(j){
                        return caml_ba_get_2(t, i + offset$0 | 0, j + offset$0 | 0);
                       });
             });
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), a = Base[95];
    return Base[95].call(null, function(b){return a(sexp_of_elt, b);}, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     a = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[133], state, a),
     b = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[133], state$0, b);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
//# shape: Base_quickcheck__Observer0:[F(3)*,F(1)*,F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    a = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     b = [0, [1, [0, a, [0, caml_call1(Base[136], size), 0]]], 0],
     c =
       [1,
        [0,
         Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Observer_o),
         b]];
    return Base[246].call(null, c);
   }
   function opaque(a, param, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random, Stdlib
//# shape: Base_quickcheck__Generator:[N,N,N,N,N,N,N,N,N,N,N,N,F(1),F(1),F(1),F(1)*,F(1)*,F(2),F(2),N,N,N,N,N,F(2)*,F(3),F(2),F(3),F(2),F(1),F(1),N,N,N,N,F(2)*,N,N,N,N,N,N,F(2)*,F(1)*,F(2)*,N,N,F(1)*,F(1)*,N,N,F(2)*,F(3)*,F(2)*,F(2)*,F(2),F(1),F(1)*,F(1),F(1),F(2),N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,F(2),F(2),N,N,N,N,N,N,F(1)*,N,N,N,N,N,N,N,F(2)*,N,F(1),F(1)*,F(1)*,F(2),F(1),F(1),F(1),F(2),F(1),F(1)*,F(4),F(1),F(1),F(1),F(2)*,F(1)*,F(3),[F(2),F(2)*]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Stdlib = global_data.Stdlib,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    g = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return Base_Staged[1].call(null, f);}
   function generate(t, size, random){
    if(0 <= size)
     return caml_call2(Base_Staged[2].call(null, t), size, random);
    var
     a = [0, [1, [0, g, [0, caml_call1(Base[136], size), 0]]], 0],
     b =
       [1,
        [0,
         Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Generator_),
         a]];
    return Base[246].call(null, b);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = Splittable_random[5].call(null, random);
              return function(x){
               var
                a = Base_Hash[7].call(null, 0),
                hash =
                  Base_quickcheck_Observer0[3].call(null, dom, x, size, a),
                random = Splittable_random[4].call(null, random$0),
                b = Base_Hash[9].call(null, hash);
               Splittable_random[3].call(null, random, b);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              Splittable_random[3].call(null, random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size$1, random){
     var size = size$1;
     for(;;){
      var x = generate(t, size, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$0 = size + 1 | 0;
      size = size$0;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$(x){return create(function(a, param){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              return Base_List[53].call
                      (null, list, function(a){return generate(a, size, random);});
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              return Base_List[19].call
                      (null, list, function(a){return generate(a, size, random);});
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      Base_Applicative[7].call(null, [0, return$, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = Base_Monad[1].call(null, [0, bind, return$, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2],
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    h = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    i = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    j = [0, cst_src_generator_ml, 160, 14],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    k = [0, cst_src_generator_ml, 225, 6],
    l = [0, cst_src_generator_ml, 198, 4];
   function of_list(list){
    if(Base_List[18].call(null, list)){
     var
      a = Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Generator_$0);
     Base_Error[32].call(null, a);
    }
    var
     array = Base_Array[9].call(null, list),
     hi = array.length - 2 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = Splittable_random[8].call(null, random, lo, hi);
              return caml_check_bound(array, index)[index + 1];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(Base_List[18].call(null, alist)){
     var
      a = Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Generator_$1);
     Base_Error[32].call(null, a);
    }
    var
     match = Base_List[107].call(null, alist),
     values = match[2],
     weights = match[1],
     value_array = Base_Array[9].call(null, values),
     array =
       Base_Array[41].call
        (null, value_array.length - 1, function(param){return 0.;}),
     sum =
       Base_List[33].call
        (null,
         weights,
         0.,
         function(index, acc, weight){
          if(1 - Base_Float[80].call(null, weight)){
           var
            a = [0, [1, [0, h, [0, Base[126].call(null, weight), 0]]], 0],
            b =
              [1,
               [0,
                Sexplib0_Sexp_conv[7].call
                 (null, cst_Base_quickcheck_Generator_$2),
                a]];
           Base_Error[32].call(null, b);
          }
          if(weight < 0.){
           var
            c = [0, [1, [0, i, [0, Base[126].call(null, weight), 0]]], 0],
            d =
              [1,
               [0,
                Sexplib0_Sexp_conv[7].call
                 (null, cst_Base_quickcheck_Generator_$3),
                c]];
           Base_Error[32].call(null, d);
          }
          var cumulative = caml_call2(Base[234], acc, weight);
          caml_check_bound(array, index)[index + 1] = cumulative;
          return cumulative;
         });
    if(sum <= 0.){
     var
      b = Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Generator_$4);
     Base_Error[32].call(null, b);
    }
    return create
            (function(param, random){
              var
               choice = Splittable_random[13].call(null, random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[7],
                   0,
                   0,
                   array,
                   runtime.caml_float_compare,
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[index + 1];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var a = caml_obj_tag(lazy_t);
              a:
              if(250 === a)
               var b = lazy_t[1];
              else{
               if(246 !== a && 244 !== a){var b = lazy_t; break a;}
               var b = CamlinternalLazy[2].call(null, lazy_t);
              }
              return generate(b, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var a = caml_obj_tag(lazy_t);
    if(250 === a) return lazy_t[1];
    if(246 !== a && 244 !== a) return lazy_t;
    return CamlinternalLazy[2].call(null, lazy_t);
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              var
               a = caml_call1(f, self),
               rec_list =
                 Base_List[53].call
                  (null,
                   a,
                   function(param){
                    var t = param[2], w = param[1];
                    return [0,
                            w,
                            caml_call2
                             (For_monad[11][4][2],
                              size,
                              function(n){return with_size(t, n - 1 | 0);})];
                   }),
               b = Base_List[18].call(null, nonrec_list),
               c = b || Base_List[18].call(null, rec_list);
              if(c){
               var
                d =
                  Sexplib0_Sexp_conv[7].call
                   (null, cst_Base_quickcheck_Generator_$5);
               Base[246].call(null, d);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(Base[222].call(null, nonrec_list, rec_list));
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(param){return 0 === param ? nonrec_gen : rec_gen;});
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     return Base_List[53].call(null, list, function(t){return [0, 1., t];});
    }
    return weighted_recursive_union
            (weighted(nonrec_list),
             function(self){return weighted(caml_call1(f, self));});
   }
   function sizes(a, opt, param){
    var min_length = a ? a[1] : 0, max_length = opt ? opt[1] : Base_Int[65];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, l], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? Base[233].call(null, max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[15][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              var
               sizes =
                 Base_Array[41].call(null, len, function(param){return 0;}),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               b = 1;
              if(remaining >= 1){
               var for$ = b;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[15][1], random, 0, max_index);
                sizes[index + 1] =
                 caml_check_bound(sizes, index)[index + 1] + 1 | 0;
                var e = for$ + 1 | 0;
                if(remaining === for$) break;
                for$ = e;
               }
              }
              var a = max_index - 1 | 0, c = 0;
              if(a >= 0){
               var i = c;
               for(;;){
                var j = Splittable_random[8].call(null, random, i, max_index);
                Base_Array[81].call(null, sizes, i, j);
                var d = i + 1 | 0;
                if(a === i) break;
                i = d;
               }
              }
              if
               ((Base_Array[27].call
                 (null,
                  [0, Base_Int[79], function(b, a){return b + a | 0;}],
                  sizes,
                  function(a){return a;})
                + (len - min_length | 0)
                | 0)
                === size)
               return Base_Array[30].call(null, sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return Splittable_random[7].call(null, random);
        }),
    m = [0, 1],
    n = [0, 0];
   function option(value_t){
    var a = [0, map(value_t, Base_Option[23]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), a]);
   }
   function either(fst_t, snd_t){
    var a = [0, map(snd_t, Base_Either[20]), 0];
    return union([0, map(fst_t, Base_Either[19]), a]);
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function list_generic(min_length, max_length, elt_gen){
    var a = sizes(min_length, max_length, 0);
    return caml_call2
            (For_monad[11][4][2],
             a,
             function(sizes){
              return all
                      (Base_List[53].call
                        (null,
                         sizes,
                         function(size){return with_size(elt_gen, size);}));
             });
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(m, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = Base_Array[9].call(null, elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 Splittable_random[8].call(null, random, 0, length_of_input),
               indices =
                 Base_Array[41].call
                  (null, length_of_input, function(a){return a;}),
               a = length_of_output - 1 | 0,
               b = 0;
              if(a >= 0){
               var i = b;
               for(;;){
                var
                 j =
                   Splittable_random[8].call
                    (null, random, i, length_of_input - 1 | 0);
                Base_Array[81].call(null, indices, i, j);
                var c = i + 1 | 0;
                if(a === i) break;
                i = c;
               }
              }
              caml_call4
               (Base_Array[66],
                n,
                [0, length_of_output],
                indices,
                Base_Int[14]);
              return Base_List[40].call
                      (null,
                       length_of_output,
                       function(i){
                        var a = caml_check_bound(indices, i)[i + 1];
                        return caml_check_bound(elts$0, a)[a + 1];
                       });
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = Base_Array[9].call(null, list),
               a = array.length - 2 | 0,
               b = 1;
              if(a >= 1){
               var i = b;
               for(;;){
                var j = Splittable_random[8].call(null, random, 0, i);
                Base_Array[81].call(null, array, i, j);
                var c = i + 1 | 0;
                if(a === i) break;
                i = c;
               }
              }
              return Base_Array[30].call(null, array);
             });
   }
   function array(t){var a = Base_Array[9]; return map(list(t), a);}
   function ref(t){return map(t, function(a){return [0, a];});}
   function lazy_t(t){return map(t, Base_Lazy[24]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               a = Base_Char[32].call(null, hi),
               b = Base_Char[32].call(null, lo),
               c = Splittable_random[8].call(null, random, b, a);
              return Base_Char[35].call(null, c);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[53], Base_Char[54]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(Base_List[12].call(null, Base_Char[1], Base_Char[45])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    o = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[54])], 0],
    char =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[53])], o]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[15][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0),
    p = [0, "p"],
    cst_geometric_distribution_p_m =
      "geometric distribution: p must be between 0 and 1",
    dummy = 0;
   function For_integer(Integer){
    function geometric(lo, p$0){
     if(p$0 === 1.) return caml_call1(For_monad[11][1], lo);
     if(p$0 === 0.) return caml_call1(For_monad[11][1], Integer[88]);
     if(! (p$0 < 0.) && ! (1. < p$0) && ! Base_Float[78].call(null, p$0)){
      var denominator = runtime.caml_log1p_float(caml_call1(Base[240], p$0));
      return create
              (function(param, random){
                var
                 uniform = Splittable_random[14].call(null, random),
                 exponential =
                   caml_call2(Base[237], Math.log(uniform), denominator),
                 float = Base_Float[57].call(null, exponential);
                try{var int = caml_call1(Integer[2], float);}
                catch(exn$0){
                 var exn = caml_wrap_exception(exn$0), tag = exn[1];
                 if(tag === Stdlib[6]) return Integer[88];
                 throw caml_maybe_attach_backtrace(exn, 0);
                }
                var int$0 = caml_call2(Integer[45], lo, int);
                return caml_call2(Integer[16], int$0, lo)
                        ? Integer[88]
                        : int$0;
               });
     }
     var
      a = [0, [1, [0, p, [0, Base[126].call(null, p$0), 0]]], 0],
      b =
        [1,
         [0,
          Sexplib0_Sexp_conv[7].call(null, cst_geometric_distribution_p_m),
          a]];
     return Base[246].call(null, b);
    }
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[100], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[101], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      a = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      b = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], a];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], b]);
    }
    function inclusive(a, b){return non_uniform(uniform_inclusive, a, b);}
    function log_inclusive(a, b){
     return non_uniform(log_uniform_inclusive, a, b);
    }
    var
     uniform_all = uniform_inclusive(Integer[89], Integer[88]),
     let_syntax_004 =
       non_uniform(log_uniform_inclusive, Integer[42], Integer[88]),
     a = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all =
       caml_call2
        (For_monad[11][4][3],
         a,
         function(param){
          var magnitude = param[2], negative = param[1];
          return negative ? caml_call1(Integer[74], magnitude) : magnitude;
         });
    return [0,
            geometric,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    floor_log2 = Base_Int[71],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol$2 = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$3 = Base_Int[80],
    symbol$4 = Base_Int[81],
    symbol$5 = Base_Int[82],
    uniform = Splittable_random[8],
    log_uniform = Splittable_random[15][1],
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(b, a){return a <= b ? 1 : 0;},
         function(b, a){return b <= a ? 1 : 0;},
         function(b, a){return b === a ? 1 : 0;},
         function(b, a){return a < b ? 1 : 0;},
         function(b, a){return b < a ? 1 : 0;},
         function(b, a){return b !== a ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         compare_local,
         equal_local,
         invariant,
         Hex,
         Binary,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(b, a){return b + a | 0;},
         function(b, a){return b - a | 0;},
         caml_mul,
         symbol$2,
         function(a){return - a | 0;},
         function(a){return - a | 0;},
         symbol$4,
         symbol$3,
         caml_div,
         rem,
         symbol$5,
         function(b, a){return b & a;},
         function(b, a){return b | a;},
         function(b, a){return b ^ a;},
         lnot,
         function(b, a){return b << a;},
         function(b, a){return b >> a;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         function(b, a){return b >>> a | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         [0,
          function(b, a){return b + a | 0;},
          function(b, a){return b - a | 0;},
          caml_mul,
          caml_div,
          function(a){return - a | 0;},
          O[1],
          function(b, a){return a <= b ? 1 : 0;},
          function(b, a){return b <= a ? 1 : 0;},
          function(b, a){return b === a ? 1 : 0;},
          function(b, a){return a < b ? 1 : 0;},
          function(b, a){return b < a ? 1 : 0;},
          function(b, a){return b !== a ? 1 : 0;},
          O[3],
          function(a){return - a | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(b, a){return b & a;},
          function(b, a){return b | a;},
          function(b, a){return b ^ a;},
          O[2],
          function(b, a){return b << a;},
          function(b, a){return b >> a;},
          function(b, a){return b >>> a | 0;}],
         uniform,
         log_uniform]),
    int = For_int[8],
    int_uniform = For_int[7],
    int_inclusive = For_int[5],
    int_uniform_inclusive = For_int[2],
    int_log_inclusive = For_int[6],
    int_log_uniform_inclusive = For_int[3],
    int_geometric = For_int[1],
    t_sexp_grammar$0 = Base_Int32[2],
    of_float$0 = Base_Int32[3],
    to_float$0 = Base_Int32[4],
    of_int_exn$0 = Base_Int32[5],
    to_int_exn$0 = Base_Int32[6],
    hash_fold_t$0 = Base_Int32[7],
    hash$0 = Base_Int32[8],
    t_of_sexp$0 = Base_Int32[9],
    sexp_of_t$0 = Base_Int32[10],
    of_string$0 = Base_Int32[11],
    to_string$0 = Base_Int32[12],
    symbol$6 = Base_Int32[13],
    symbol$7 = Base_Int32[14],
    symbol$8 = Base_Int32[15],
    symbol$9 = Base_Int32[16],
    symbol$10 = Base_Int32[17],
    symbol$11 = Base_Int32[18],
    equal$0 = Base_Int32[19],
    compare$0 = Base_Int32[20],
    min$0 = Base_Int32[21],
    max$0 = Base_Int32[22],
    ascending$0 = Base_Int32[23],
    descending$0 = Base_Int32[24],
    between$0 = Base_Int32[25],
    clamp_exn$0 = Base_Int32[26],
    clamp$0 = Base_Int32[27],
    comparator$0 = Base_Int32[28],
    pp$0 = Base_Int32[29],
    hashable$0 = Base_Int32[30],
    is_positive$0 = Base_Int32[31],
    is_non_negative$0 = Base_Int32[32],
    is_negative$0 = Base_Int32[33],
    is_non_positive$0 = Base_Int32[34],
    sign$0 = Base_Int32[35],
    compare_local$0 = Base_Int32[36],
    equal_local$0 = Base_Int32[37],
    invariant$0 = Base_Int32[38],
    Hex$0 = Base_Int32[39],
    Binary$0 = Base_Int32[40],
    of_string_opt$0 = Base_Int32[41],
    to_string_hum$0 = Base_Int32[42],
    zero$0 = Base_Int32[43],
    one$0 = Base_Int32[44],
    minus_one$0 = Base_Int32[45],
    symbol$12 = Base_Int32[46],
    symbol$13 = Base_Int32[47],
    symbol$14 = Base_Int32[48],
    symbol$15 = Base_Int32[49],
    neg = Base_Int32[50],
    symbol$16 = Base_Int32[51],
    symbol$17 = Base_Int32[52],
    symbol$18 = Base_Int32[53],
    symbol$19 = Base_Int32[54],
    rem$0 = Base_Int32[55],
    symbol$20 = Base_Int32[56],
    land = Base_Int32[57],
    lor = Base_Int32[58],
    lxor = Base_Int32[59],
    lnot$0 = Base_Int32[60],
    lsl = Base_Int32[61],
    asr = Base_Int32[62],
    round$0 = Base_Int32[63],
    round_towards_zero$0 = Base_Int32[64],
    round_down$0 = Base_Int32[65],
    round_up$0 = Base_Int32[66],
    round_nearest$0 = Base_Int32[67],
    abs$0 = Base_Int32[68],
    succ$0 = Base_Int32[69],
    pred$0 = Base_Int32[70],
    pow$0 = Base_Int32[71],
    bit_and$0 = Base_Int32[72],
    bit_or$0 = Base_Int32[73],
    bit_xor$0 = Base_Int32[74],
    bit_not$0 = Base_Int32[75],
    popcount$0 = Base_Int32[76],
    shift_left$0 = Base_Int32[77],
    shift_right$0 = Base_Int32[78],
    decr$0 = Base_Int32[79],
    incr$0 = Base_Int32[80],
    of_int32_exn$0 = Base_Int32[81],
    to_int32_exn$0 = Base_Int32[82],
    of_int64_exn$0 = Base_Int32[83],
    to_int64$0 = Base_Int32[84],
    of_nativeint_exn$0 = Base_Int32[85],
    to_nativeint_exn$0 = Base_Int32[86],
    of_float_unchecked$0 = Base_Int32[87],
    num_bits$0 = Base_Int32[88],
    max_value$0 = Base_Int32[89],
    min_value$0 = Base_Int32[90],
    lsr = Base_Int32[91],
    shift_right_logical$0 = Base_Int32[92],
    ceil_pow2$0 = Base_Int32[93],
    floor_pow2$0 = Base_Int32[94],
    ceil_log2$0 = Base_Int32[95],
    floor_log2$0 = Base_Int32[96],
    is_pow2$0 = Base_Int32[97],
    clz$0 = Base_Int32[98],
    ctz$0 = Base_Int32[99],
    O$0 = Base_Int32[100],
    uniform$0 = Splittable_random[9],
    log_uniform$0 = Splittable_random[15][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         compare_local$0,
         equal_local$0,
         invariant$0,
         Hex$0,
         Binary$0,
         of_string_opt$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[8],
    int32_uniform = For_int32[7],
    int32_inclusive = For_int32[5],
    int32_uniform_inclusive = For_int32[2],
    int32_log_inclusive = For_int32[6],
    int32_log_uniform_inclusive = For_int32[3],
    int32_geometric = For_int32[1],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    compare_local$1 = Base_Int63[35],
    equal_local$1 = Base_Int63[36],
    invariant$1 = Base_Int63[37],
    Hex$1 = Base_Int63[38],
    Binary$1 = Base_Int63[39],
    of_string_opt$1 = Base_Int63[40],
    to_string_hum$1 = Base_Int63[41],
    zero$1 = Base_Int63[42],
    one$1 = Base_Int63[43],
    minus_one$1 = Base_Int63[44],
    symbol$27 = Base_Int63[45],
    symbol$28 = Base_Int63[46],
    symbol$29 = Base_Int63[47],
    symbol$30 = Base_Int63[48],
    neg$0 = Base_Int63[49],
    symbol$31 = Base_Int63[50],
    symbol$32 = Base_Int63[51],
    symbol$33 = Base_Int63[52],
    symbol$34 = Base_Int63[53],
    rem$1 = Base_Int63[54],
    symbol$35 = Base_Int63[55],
    land$0 = Base_Int63[56],
    lor$0 = Base_Int63[57],
    lxor$0 = Base_Int63[58],
    lnot$1 = Base_Int63[59],
    lsl$0 = Base_Int63[60],
    asr$0 = Base_Int63[61],
    round$1 = Base_Int63[62],
    round_towards_zero$1 = Base_Int63[63],
    round_down$1 = Base_Int63[64],
    round_up$1 = Base_Int63[65],
    round_nearest$1 = Base_Int63[66],
    abs$1 = Base_Int63[67],
    succ$1 = Base_Int63[68],
    pred$1 = Base_Int63[69],
    pow$1 = Base_Int63[70],
    bit_and$1 = Base_Int63[71],
    bit_or$1 = Base_Int63[72],
    bit_xor$1 = Base_Int63[73],
    bit_not$1 = Base_Int63[74],
    popcount$1 = Base_Int63[75],
    shift_left$1 = Base_Int63[76],
    shift_right$1 = Base_Int63[77],
    decr$1 = Base_Int63[78],
    incr$1 = Base_Int63[79],
    of_int32_exn$1 = Base_Int63[80],
    to_int32_exn$1 = Base_Int63[81],
    of_int64_exn$1 = Base_Int63[82],
    to_int64$1 = Base_Int63[83],
    of_nativeint_exn$1 = Base_Int63[84],
    to_nativeint_exn$1 = Base_Int63[85],
    of_float_unchecked$1 = Base_Int63[86],
    num_bits$1 = Base_Int63[87],
    max_value$1 = Base_Int63[88],
    min_value$1 = Base_Int63[89],
    lsr$0 = Base_Int63[90],
    shift_right_logical$1 = Base_Int63[91],
    ceil_pow2$1 = Base_Int63[92],
    floor_pow2$1 = Base_Int63[93],
    ceil_log2$1 = Base_Int63[94],
    is_pow2$1 = Base_Int63[95],
    clz$1 = Base_Int63[96],
    ctz$1 = Base_Int63[97],
    O$1 = Base_Int63[98],
    floor_log2$1 = Base_Int63[117],
    uniform$1 = Splittable_random[10],
    log_uniform$1 = Splittable_random[15][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         compare_local$1,
         equal_local$1,
         invariant$1,
         Hex$1,
         Binary$1,
         of_string_opt$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[8],
    int63_uniform = For_int63[7],
    int63_inclusive = For_int63[5],
    int63_uniform_inclusive = For_int63[2],
    int63_log_inclusive = For_int63[6],
    int63_log_uniform_inclusive = For_int63[3],
    int63_geometric = For_int63[1],
    t_sexp_grammar$2 = Base_Int64[2],
    of_float$2 = Base_Int64[3],
    to_float$2 = Base_Int64[4],
    of_int_exn$2 = Base_Int64[5],
    to_int_exn$2 = Base_Int64[6],
    hash_fold_t$2 = Base_Int64[7],
    hash$2 = Base_Int64[8],
    t_of_sexp$2 = Base_Int64[9],
    sexp_of_t$2 = Base_Int64[10],
    of_string$2 = Base_Int64[11],
    to_string$2 = Base_Int64[12],
    equal$2 = Base_Int64[13],
    compare$2 = Base_Int64[14],
    min$2 = Base_Int64[15],
    max$2 = Base_Int64[16],
    ascending$2 = Base_Int64[17],
    descending$2 = Base_Int64[18],
    between$2 = Base_Int64[19],
    clamp_exn$2 = Base_Int64[20],
    clamp$2 = Base_Int64[21],
    comparator$2 = Base_Int64[22],
    pp$2 = Base_Int64[23],
    hashable$2 = Base_Int64[24],
    is_positive$2 = Base_Int64[25],
    is_non_negative$2 = Base_Int64[26],
    is_negative$2 = Base_Int64[27],
    is_non_positive$2 = Base_Int64[28],
    sign$2 = Base_Int64[29],
    compare_local$2 = Base_Int64[30],
    equal_local$2 = Base_Int64[31],
    invariant$2 = Base_Int64[32],
    Hex$2 = Base_Int64[33],
    Binary$2 = Base_Int64[34],
    of_string_opt$2 = Base_Int64[35],
    to_string_hum$2 = Base_Int64[36],
    one$2 = Base_Int64[37],
    minus_one$2 = Base_Int64[38],
    rem$2 = Base_Int64[39],
    round$2 = Base_Int64[40],
    round_towards_zero$2 = Base_Int64[41],
    round_down$2 = Base_Int64[42],
    round_up$2 = Base_Int64[43],
    round_nearest$2 = Base_Int64[44],
    succ$2 = Base_Int64[45],
    pred$2 = Base_Int64[46],
    pow$2 = Base_Int64[47],
    bit_and$2 = Base_Int64[48],
    bit_or$2 = Base_Int64[49],
    bit_xor$2 = Base_Int64[50],
    bit_not$2 = Base_Int64[51],
    popcount$2 = Base_Int64[52],
    shift_left$2 = Base_Int64[53],
    shift_right$2 = Base_Int64[54],
    decr$2 = Base_Int64[55],
    incr$2 = Base_Int64[56],
    of_int32_exn$2 = Base_Int64[57],
    to_int32_exn$2 = Base_Int64[58],
    of_int64_exn$2 = Base_Int64[59],
    to_int64$2 = Base_Int64[60],
    of_nativeint_exn$2 = Base_Int64[61],
    to_nativeint_exn$2 = Base_Int64[62],
    of_float_unchecked$2 = Base_Int64[63],
    num_bits$2 = Base_Int64[64],
    max_value$2 = Base_Int64[65],
    min_value$2 = Base_Int64[66],
    shift_right_logical$2 = Base_Int64[67],
    ceil_pow2$2 = Base_Int64[68],
    floor_pow2$2 = Base_Int64[69],
    ceil_log2$2 = Base_Int64[70],
    floor_log2$2 = Base_Int64[71],
    is_pow2$2 = Base_Int64[72],
    clz$2 = Base_Int64[73],
    ctz$2 = Base_Int64[74],
    O$2 = Base_Int64[75],
    symbol$36 = Base_Int64[76],
    lnot$2 = Base_Int64[77],
    abs$2 = Base_Int64[78],
    zero$2 = Base_Int64[79],
    symbol$37 = Base_Int64[80],
    symbol$38 = Base_Int64[81],
    symbol$39 = Base_Int64[82],
    uniform$2 = Splittable_random[11],
    log_uniform$2 = Splittable_random[15][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         compare_local$2,
         equal_local$2,
         invariant$2,
         Hex$2,
         Binary$2,
         of_string_opt$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[8],
    int64_uniform = For_int64[7],
    int64_inclusive = For_int64[5],
    int64_uniform_inclusive = For_int64[2],
    int64_log_inclusive = For_int64[6],
    int64_log_uniform_inclusive = For_int64[3],
    int64_geometric = For_int64[1],
    t_sexp_grammar$3 = Base_Nativeint[2],
    of_float$3 = Base_Nativeint[3],
    to_float$3 = Base_Nativeint[4],
    of_int_exn$3 = Base_Nativeint[5],
    to_int_exn$3 = Base_Nativeint[6],
    hash_fold_t$3 = Base_Nativeint[7],
    hash$3 = Base_Nativeint[8],
    t_of_sexp$3 = Base_Nativeint[9],
    sexp_of_t$3 = Base_Nativeint[10],
    of_string$3 = Base_Nativeint[11],
    to_string$3 = Base_Nativeint[12],
    symbol$40 = Base_Nativeint[13],
    symbol$41 = Base_Nativeint[14],
    symbol$42 = Base_Nativeint[15],
    symbol$43 = Base_Nativeint[16],
    symbol$44 = Base_Nativeint[17],
    symbol$45 = Base_Nativeint[18],
    equal$3 = Base_Nativeint[19],
    compare$3 = Base_Nativeint[20],
    min$3 = Base_Nativeint[21],
    max$3 = Base_Nativeint[22],
    ascending$3 = Base_Nativeint[23],
    descending$3 = Base_Nativeint[24],
    between$3 = Base_Nativeint[25],
    clamp_exn$3 = Base_Nativeint[26],
    clamp$3 = Base_Nativeint[27],
    comparator$3 = Base_Nativeint[28],
    pp$3 = Base_Nativeint[29],
    hashable$3 = Base_Nativeint[30],
    is_positive$3 = Base_Nativeint[31],
    is_non_negative$3 = Base_Nativeint[32],
    is_negative$3 = Base_Nativeint[33],
    is_non_positive$3 = Base_Nativeint[34],
    sign$3 = Base_Nativeint[35],
    compare_local$3 = Base_Nativeint[36],
    equal_local$3 = Base_Nativeint[37],
    invariant$3 = Base_Nativeint[38],
    Hex$3 = Base_Nativeint[39],
    Binary$3 = Base_Nativeint[40],
    of_string_opt$3 = Base_Nativeint[41],
    to_string_hum$3 = Base_Nativeint[42],
    zero$3 = Base_Nativeint[43],
    one$3 = Base_Nativeint[44],
    minus_one$3 = Base_Nativeint[45],
    symbol$46 = Base_Nativeint[46],
    symbol$47 = Base_Nativeint[47],
    symbol$48 = Base_Nativeint[48],
    symbol$49 = Base_Nativeint[49],
    neg$1 = Base_Nativeint[50],
    symbol$50 = Base_Nativeint[51],
    symbol$51 = Base_Nativeint[52],
    symbol$52 = Base_Nativeint[53],
    symbol$53 = Base_Nativeint[54],
    rem$3 = Base_Nativeint[55],
    symbol$54 = Base_Nativeint[56],
    land$1 = Base_Nativeint[57],
    lor$1 = Base_Nativeint[58],
    lxor$1 = Base_Nativeint[59],
    lnot$3 = Base_Nativeint[60],
    lsl$1 = Base_Nativeint[61],
    asr$1 = Base_Nativeint[62],
    round$3 = Base_Nativeint[63],
    round_towards_zero$3 = Base_Nativeint[64],
    round_down$3 = Base_Nativeint[65],
    round_up$3 = Base_Nativeint[66],
    round_nearest$3 = Base_Nativeint[67],
    abs$3 = Base_Nativeint[68],
    succ$3 = Base_Nativeint[69],
    pred$3 = Base_Nativeint[70],
    pow$3 = Base_Nativeint[71],
    bit_and$3 = Base_Nativeint[72],
    bit_or$3 = Base_Nativeint[73],
    bit_xor$3 = Base_Nativeint[74],
    bit_not$3 = Base_Nativeint[75],
    popcount$3 = Base_Nativeint[76],
    shift_left$3 = Base_Nativeint[77],
    shift_right$3 = Base_Nativeint[78],
    decr$3 = Base_Nativeint[79],
    incr$3 = Base_Nativeint[80],
    of_int32_exn$3 = Base_Nativeint[81],
    to_int32_exn$3 = Base_Nativeint[82],
    of_int64_exn$3 = Base_Nativeint[83],
    to_int64$3 = Base_Nativeint[84],
    of_nativeint_exn$3 = Base_Nativeint[85],
    to_nativeint_exn$3 = Base_Nativeint[86],
    of_float_unchecked$3 = Base_Nativeint[87],
    num_bits$3 = Base_Nativeint[88],
    max_value$3 = Base_Nativeint[89],
    min_value$3 = Base_Nativeint[90],
    lsr$1 = Base_Nativeint[91],
    shift_right_logical$3 = Base_Nativeint[92],
    ceil_pow2$3 = Base_Nativeint[93],
    floor_pow2$3 = Base_Nativeint[94],
    ceil_log2$3 = Base_Nativeint[95],
    floor_log2$3 = Base_Nativeint[96],
    is_pow2$3 = Base_Nativeint[97],
    clz$3 = Base_Nativeint[98],
    ctz$3 = Base_Nativeint[99],
    O$3 = Base_Nativeint[100],
    uniform$3 = Splittable_random[12],
    log_uniform$3 = Splittable_random[15][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         compare_local$3,
         equal_local$3,
         invariant$3,
         Hex$3,
         Binary$3,
         of_string_opt$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[8],
    nativeint_uniform = For_nativeint[7],
    nativeint_inclusive = For_nativeint[5],
    nativeint_uniform_inclusive = For_nativeint[2],
    nativeint_log_inclusive = For_nativeint[6],
    nativeint_log_uniform_inclusiv = For_nativeint[3],
    nativeint_geometric = For_nativeint[1],
    float_zero_exponent = Base_Float[117].call(null, 0.),
    float_zero_mantissa = Base_Float[118].call(null, 0.),
    float_max_positive_subnormal_v =
      Base_Float[47].call(null, 759637122, Base_Float[43]),
    float_subnormal_exponent = Base_Float[117].call(null, Base_Float[42]),
    float_min_subnormal_mantissa = Base_Float[118].call(null, Base_Float[42]),
    float_max_subnormal_mantissa =
      Base_Float[118].call(null, float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[41],
    float_min_normal_exponent = Base_Float[117].call(null, Base_Float[43]),
    float_max_normal_exponent =
      Base_Float[117].call(null, float_max_positive_normal_valu),
    float_max_normal_mantissa =
      Base_Float[118].call(null, float_max_positive_normal_valu),
    float_inf_exponent = Base_Float[117].call(null, Base_Float[29]),
    float_inf_mantissa = Base_Float[118].call(null, Base_Float[29]),
    float_nan_exponent = Base_Float[117].call(null, Base_Float[28]),
    float_min_nan_mantissa = Base_Int63[68].call(null, float_inf_mantissa),
    q = For_int[2].call(null, 0, 52),
    float_normal_mantissa =
      caml_call2
       (For_monad[11][4][2],
        q,
        function(num_bits){
         var
          a = Base_Int63[76].call(null, Base_Int63[43], num_bits),
          b = Base_Int63[69].call(null, a),
          c = For_int63[5].call(null, Base_Int63[42], b);
         return caml_call2
                 (For_monad[11][4][3],
                  c,
                  function(bits){
                   return Base_Int63[76].call(null, bits, 52 - num_bits | 0);
                  });
        }),
    lower_bound = Base_Float[117].call(null, 1.),
    r = For_int[6].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    t =
      [0,
       caml_call2
        (For_monad[11][4][3],
         r,
         function(offset){return lower_bound + offset | 0;}),
       0],
    s = For_int[6].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union
       ([0,
         caml_call2
          (For_monad[11][4][3],
           s,
           function(offset){return lower_bound - offset | 0;}),
         t]),
    float_zero =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return Base_Float[115].call
                 (null, negative, float_zero_exponent, float_zero_mantissa);
        }),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[6].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa),
    u = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    v = caml_call2(For_monad[11][4][4], bool, u),
    float_subnormal =
      caml_call2
       (For_monad[11][4][3],
        v,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return Base_Float[115].call(null, negative, exponent, mantissa);
        }),
    w = caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    x = caml_call2(For_monad[11][4][4], bool, w),
    float_normal =
      caml_call2
       (For_monad[11][4][3],
        x,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return Base_Float[115].call(null, negative, exponent, mantissa);
        }),
    float_infinite =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return Base_Float[115].call
                 (null, negative, float_inf_exponent, float_inf_mantissa);
        }),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[5].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa),
    y = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    z = caml_call2(For_monad[11][4][4], bool, y),
    float_nan =
      caml_call2
       (For_monad[11][4][3],
        z,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return Base_Float[115].call(null, negative, exponent, mantissa);
        });
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    return weighted_union
            (Base_List[13].call
              (null,
               Base_Float[109][3],
               function(c){
                if(! caml_call1(filter, c)) return 0;
                var b = float_of_class(c);
                switch(c){
                  case 2:
                   var a = 100.; break;
                  case 3:
                   var a = 10.; break;
                  default: var a = 1.;
                }
                return [0, [0, a, b]];
               }));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;}),
    float_strictly_positive =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){return Base_Float[98].call(null, t);}),
    float_strictly_negative =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){
         var a = Base_Float[98].call(null, t);
         return caml_call1(Base[240], a);
        }),
    float_positive_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){return Base_Float[98].call(null, t);}),
    float_negative_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){
         var a = Base_Float[98].call(null, t);
         return caml_call1(Base[240], a);
        }),
    A = [0, cst_upper_bound],
    B = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    C = [0, cst_upper_bound],
    D = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty";
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     a = 1 - Base_Float[80].call(null, lower_bound),
     b = a || 1 - Base_Float[80].call(null, upper_bound);
    if(b){
     var
      c = [0, [1, [0, A, [0, Base[126].call(null, upper_bound), 0]]], 0],
      d = [0, [1, [0, B, [0, Base[126].call(null, lower_bound), 0]]], c],
      e =
        [1,
         [0,
          Sexplib0_Sexp_conv[7].call(null, cst_Float_uniform_exclusive_bo),
          d]];
     Base[246].call(null, e);
    }
    var
     lower_inclusive = Base_Float[47].call(null, 19067, lower_bound),
     upper_inclusive = Base_Float[47].call(null, 759637122, upper_bound);
    if(caml_call2(Base_Float[99][11], lower_inclusive, upper_inclusive)){
     var
      f = [0, [1, [0, C, [0, Base[126].call(null, upper_bound), 0]]], 0],
      g = [0, [1, [0, D, [0, Base[126].call(null, lower_bound), 0]]], f],
      h =
        [1,
         [0,
          Sexplib0_Sexp_conv[7].call(null, cst_Float_uniform_exclusive_re),
          g]];
     Base[246].call(null, h);
    }
    return create
            (function(param, random){
              return Splittable_random[13].call
                      (null, random, lower_inclusive, upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(lower_bound === upper_bound)
     return caml_call1(For_monad[11][1], lower_bound);
    if(Base_Float[47].call(null, 19067, lower_bound) === upper_bound){
     var a = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), a]);
    }
    var
     b = [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     c = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], b];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], c]);
   }
   function string_with_length_of(char_gen, length){
    var a = list_with_length(char_gen, length);
    return map(a, Base_String[137]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var string = string_of(char), string_non_empty = string_non_empty_of(char);
   function string_with_length(length){
    return string_with_length_of(char, length);
   }
   function edit_insert(string){
    var a = int_uniform_inclusive(0, caml_ml_string_length(string));
    return caml_call2
            (For_monad[11][4][2],
             a,
             function(pos){
              var a = int_geometric(1, 0.5);
              return caml_call2
                      (For_monad[11][4][2],
                       a,
                       function(length){
                        var a = string_with_length_of(char, length);
                        return caml_call2
                                (For_monad[11][4][2],
                                 a,
                                 function(str){
                                  var
                                   a =
                                     [0, str, [0, Base_String[123].call(null, string, pos), 0]],
                                   b = [0, Base_String[121].call(null, string, pos), a],
                                   c = Base_String[68].call(null, 0, b);
                                  return caml_call1(For_monad[11][1], c);
                                 });
                       });
             });
   }
   function edit(string, n_times){
    if(0 >= n_times) return caml_call1(For_monad[11][1], string);
    function h(string){return edit(string, n_times - 1 | 0);}
    if(Base_String[14].call(null, string))
     var a = edit_insert(string);
    else
     var
      d = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      e =
        [0,
         caml_call2
          (For_monad[11][4][2],
           d,
           function(len){
            var
             a =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - len | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     a,
                     function(pos){
                      var
                       a = [0, Base_String[123].call(null, string, pos), 0],
                       b =
                         [0, Base_String[121].call(null, string, pos + len | 0), a],
                       c = Base_String[68].call(null, 0, b);
                      return caml_call1(For_monad[11][1], c);
                     });
           }),
         0],
      c = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      f =
        [0,
         caml_call2
          (For_monad[11][4][2],
           c,
           function(length){
            var
             a =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - length | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     a,
                     function(pos){
                      var a = string_with_length_of(char, length);
                      return caml_call2
                              (For_monad[11][4][2],
                               a,
                               function(str){
                                var
                                 a =
                                   [0,
                                    str,
                                    [0,
                                     Base_String[123].call(null, string, pos + length | 0),
                                     0]],
                                 b = [0, Base_String[121].call(null, string, pos), a],
                                 c = Base_String[68].call(null, 0, b);
                                return caml_call1(For_monad[11][1], c);
                               });
                     });
           }),
         e],
      b = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      g =
        [0,
         caml_call2
          (For_monad[11][4][2],
           b,
           function(len){
            var
             a =
               int_uniform_inclusive
                (0, caml_ml_string_length(string) - len | 0);
            return caml_call2
                    (For_monad[11][4][2],
                     a,
                     function(pos){
                      var
                       a =
                         [0, Base_String[123].call(null, string, pos + len | 0), 0],
                       b = [0, Base_String[121].call(null, string, pos), a],
                       c = Base_String[68].call(null, 0, b);
                      return caml_call1(For_monad[11][1], c);
                     });
           }),
         f],
      a = union([0, edit_insert(string), g]);
    return caml_call2(For_monad[11][4][2], a, h);
   }
   function string_like(string){
    var a = int_geometric(0, 0.5);
    return caml_call2
            (For_monad[11][4][2],
             a,
             function(n_times){return edit(string, n_times);});
   }
   var bytes = map(string, Base_Bytes[28]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(size){
                        var a = For_int[3].call(null, 0, size + 1 | 0);
                        return caml_call2
                                (For_monad[11][4][2],
                                 a,
                                 function(param){
                                  if(0 === param)
                                   return caml_call2
                                           (For_monad[11][4][3],
                                            atom,
                                            function(atom){return [0, atom];});
                                  var a = list(self);
                                  return caml_call2
                                          (For_monad[11][4][3], a, function(list){return [1, list];});
                                 });
                       });
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    var a = list(key_gen);
    return caml_call2
            (For_monad[11][4][2],
             a,
             function(keys){
              var
               keys$0 = Base_List[126].call(null, keys, comparator[1]),
               a =
                 list_with_length(data_gen, Base_List[45].call(null, keys$0));
              return caml_call2
                      (For_monad[11][4][2],
                       a,
                       function(data){
                        var
                         a = Base_List[110].call(null, keys$0, data),
                         b = caml_call2(Base_Map[118][3][13], comparator, a);
                        return caml_call1(For_monad[11][1], b);
                       });
             });
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var a = caml_call1(Base_Set[75][3][56], comparator);
    return map(list(elt_gen), a);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     a = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(a, caml_call1(Base_Map[118][33], comparator));
   }
   function set_t_m(m, elt_gen){
    var comparator = m[1], a = set_tree_using_comparator(comparator, elt_gen);
    return map(a, caml_call1(Base_Set[75][66], comparator));
   }
   function bigarray1(t, kind, layout, length){
    function b(elts){
     var
      elts$0 = Base_Array[9].call(null, elts),
      dim = elts$0.length - 1,
      offset = Base_quickcheck_Bigarray_helpe[1][1].call(null, layout);
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2],
              kind,
              layout,
              dim,
              function(i){
               var a = i - offset | 0;
               return caml_check_bound(elts$0, a)[a + 1];
              });
    }
    if(length)
     var length$0 = length[1], a = list_with_length(t, length$0);
    else
     var a = list(t);
    return caml_call2(For_monad[11][4][3], a, b);
   }
   var
    a = 0,
    b = 12,
    c = 1,
    d = 0,
    e = 1,
    f = 1,
    bigstring = bigarray1(char, b, a, 0),
    float32_vec = bigarray1(float, d, c, 0),
    float64_vec = bigarray1(float, f, e, 0),
    E = [0, 0, 0];
   function bigstring_with_length(length){
    return bigarray1(char, b, a, [0, length]);
   }
   function float32_vec_with_length(length){
    return bigarray1(float, d, c, [0, length]);
   }
   function float64_vec_with_length(length){
    return bigarray1(float, f, e, [0, length]);
   }
   var
    bigarray2_dim =
      caml_call2
       (For_monad[11][4][2],
        size,
        function(max_total_size){
         if(0 === max_total_size) return caml_call1(For_monad[11][1], E);
         var a = int_log_uniform_inclusive(1, max_total_size);
         return caml_call2
                 (For_monad[11][4][2],
                  a,
                  function(a){
                   var
                    max_b = caml_div(max_total_size, a),
                    b = int_log_uniform_inclusive(0, max_b),
                    c =
                      caml_call2
                       (For_monad[11][4][3],
                        b,
                        function(b_weighted_low){return max_b - b_weighted_low | 0;});
                   return caml_call2
                           (For_monad[11][4][2],
                            c,
                            function(b){
                             return caml_call2
                                     (For_monad[11][4][3],
                                      bool,
                                      function(param){return param ? [0, a, b] : [0, b, a];});
                            });
                  });
        });
   function bigarray2(t, kind, layout){
    return caml_call2
            (For_monad[11][4][2],
             bigarray2_dim,
             function(param){
              var
               dim2 = param[2],
               dim1 = param[1],
               a = list_with_length(list_with_length(t, dim2), dim1);
              return caml_call2
                      (For_monad[11][4][3],
                       a,
                       function(elts){
                        var
                         elts$0 = Base_Array[85].call(null, elts, Base_Array[9]),
                         offset =
                           Base_quickcheck_Bigarray_helpe[1][1].call(null, layout);
                        return caml_call5
                                (Base_quickcheck_Bigarray_helpe[3][2],
                                 kind,
                                 layout,
                                 dim1,
                                 dim2,
                                 function(i, j){
                                  var a = j - offset | 0, b = i - offset | 0;
                                  return caml_check_bound
                                           (caml_check_bound(elts$0, b)[b + 1], a)
                                          [a + 1];
                                 });
                       });
             });
   }
   var
    float32_mat = bigarray2(float, 0, 1),
    float64_mat = bigarray2(float, 1, 1);
   function coverage(Cmp, sample){
    var a = Base_Map[6].call(null, Cmp);
    return Base_Sequence[11].call
            (null,
             sample,
             a,
             function(counts, value){
              return Base_Map[41].call
                      (null,
                       counts,
                       value,
                       function(param){
                        if(! param) return 1;
                        var prev = param[1];
                        return prev + 1 | 0;
                       });
             });
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char,
       string,
       bytes,
       int,
       int32,
       int63,
       int64,
       nativeint,
       float,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       int_geometric,
       int32_geometric,
       int63_geometric,
       int64_geometric,
       nativeint_geometric,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       string_like,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       bigarray1,
       bigstring_with_length,
       float32_vec_with_length,
       float64_vec_with_length,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (88, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
//# shape: Base_quickcheck__Shrinker:[F(1)*,F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,F(1)*->F(1),F(1),F(1),F(1)*,F(1)*,F(2)*->F(1),F(2)*->F(1),F(2)*,F(1),F(1),F(1),F(1),F(1),F(2)*->F(1),F(1)*->F(1),F(3)*->F(1),F(2)*->F(1),F(3)*->F(1),F(2)*->F(1),F(3)*->F(1),F(1),F(1)*->F(1)*,F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes;
   function atomic(param){return Base_Sequence[41];}
   function create(a){return a;}
   function shrink(a){return a;}
   function map(t, f, f_inverse){
    return function(x){
     var a = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[35], a, f);};
   }
   function filter(t, f){
    return function(x){
     var a = caml_call1(t, x);
     return Base_Sequence[54].call(null, a, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var a = caml_call1(t, caml_call1(f_inverse, x));
     return Base_Sequence[80].call(null, a, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     return Base_Sequence[107].call
             (null,
              [246,
               function(param){
                var a = caml_obj_tag(lazy_t);
                a:
                if(250 === a)
                 var b = lazy_t[1];
                else{
                 if(246 !== a && 244 !== a){var b = lazy_t; break a;}
                 var b = CamlinternalLazy[2].call(null, lazy_t);
                }
                return caml_call1(b, x);
               }]);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var
      snd = param[2],
      fst = param[1],
      a = caml_call1(snd_t, snd),
      b =
        [0,
         caml_call2
          (Base_Sequence[35], a, function(snd){return [0, fst, snd];}),
         0],
      c = caml_call1(fst_t, fst),
      d =
        [0,
         caml_call2
          (Base_Sequence[35], c, function(fst){return [0, fst, snd];}),
         b];
     return Base_Sequence[70].call(null, d);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[41];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = Base_quickcheck_Bigarray_helpe[1][1].call(null, layout);
    return Base_Sequence[79].call
            (null,
             dim,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim - 1 | 0,
                       function(i){
                        var i$0 = i < to_skip$0 ? i : i + 1 | 0;
                        return runtime.caml_ba_get_1(src, i$0);
                       });
             });
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   var
    dim2$0 =
      [0,
       function(param){return 0;},
       "dim2",
       0,
       dim2,
       function(r, v){return [0, r[1], v];}],
    dim1$0 =
      [0,
       function(param){return 0;},
       "dim1",
       0,
       dim1,
       function(r, v){return [0, v, r[2]];}];
   function shrink$0(field, src){
    var a = runtime.caml_ba_dim_2(src), dims = [0, caml_ba_dim_1(src), a];
    if(0 === Base_Field[3].call(null, field, dims)) return Base_Sequence[41];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = Base_quickcheck_Bigarray_helpe[1][1].call(null, layout),
     match = Base_Field[6].call(null, field, dims, Base_Int[46]),
     dim2 = match[2],
     dim1 = match[1],
     b = Base_Field[3].call(null, field, dims);
    return Base_Sequence[79].call
            (null,
             b,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
              return caml_call5
                      (Base_quickcheck_Bigarray_helpe[3][2],
                       kind,
                       layout,
                       dim1,
                       dim2,
                       function(dim1, dim2){
                        var
                         match =
                           Base_Field[6].call(null, field, [0, dim1, dim2], skip),
                         dim2$0 = match[2],
                         dim1$0 = match[1];
                        return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
                       });
             });
   }
   function float32_mat(src){
    var a = [0, shrink$0(dim2$0, src), 0], b = [0, shrink$0(dim1$0, src), a];
    return Base_Sequence[70].call(null, b);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[41];
     var
      value = param[1],
      a = Base_Option[23],
      b = caml_call1(value_t, value),
      c = caml_call2(Base_Sequence[35], b, a),
      d = Base_Sequence[101].call(null, 0);
     return Base_Sequence[65].call(null, d, c);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[41];
               var
                tail = param[2],
                head = param[1],
                a = caml_call1(list_t, tail),
                b =
                  [0,
                   caml_call2
                    (Base_Sequence[35],
                     a,
                     function(tail){return [0, head, tail];}),
                   0],
                c = caml_call1(elt_t, head),
                d =
                  [0,
                   caml_call2
                    (Base_Sequence[35],
                     c,
                     function(head){return [0, head, tail];}),
                   b],
                e = [0, Base_Sequence[101].call(null, tail), d];
               return Base_Sequence[70].call(null, e);};
             });
   }
   var
    a = Base_String[25],
    b = Base_String[137],
    string = map(list(atomic), b, a),
    bytes = map(string, Base_Bytes[28], Base_Bytes[29]);
   function array(t){
    var a = Base_Array[30], b = Base_Array[9];
    return map(list(t), b, a);
   }
   function ref(t){
    return map(t, function(a){return [0, a];}, function(a){return a[1];});
   }
   function lazy_t(t){
    return map
            (t,
             Base_Lazy[24],
             function(a){
              var b = caml_obj_tag(a);
              if(250 === b) return a[1];
              if(246 !== b && 244 !== b) return a;
              return CamlinternalLazy[2].call(null, a);
             });
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[41];
          var
           l = param[1],
           a = list(shrinker)(l),
           shrink_list =
             caml_call2(Base_Sequence[35], a, function(l){return [1, l];}),
           shrink_tree = Base_Sequence[106].call(null, l);
          return Base_Sequence[70].call
                  (null, [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var fst = either[1], a = Base_Either[19], b = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[35], b, a);
     }
     var snd = either[1], c = Base_Either[20], d = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[35], d, c);};
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             },
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var
      alist = caml_call2(Base_Map[118][3][74], 0, tree),
      a = Base_Sequence[106].call(null, alist),
      drop_keys =
        caml_call2
         (Base_Sequence[35],
          a,
          function(param){
           var k = param[1];
           return caml_call3(Base_Map[118][3][46], comparator, tree, k);
          }),
      b =
        Base_List[53].call
         (null,
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            tree$0 = caml_call3(Base_Map[118][3][46], comparator, tree, key),
            a = caml_call1(key_t, key);
           return Base_Sequence[80].call
                   (null,
                    a,
                    function(smaller_key){
                     var
                      match =
                        caml_call4
                         (Base_Map[118][3][36],
                          comparator,
                          tree$0,
                          smaller_key,
                          data);
                     if(typeof match === "number") return 0;
                     var tree = match[2];
                     return [0, tree];
                    });
          }),
      shrink_keys = Base_Sequence[70].call(null, b),
      c =
        Base_List[53].call
         (null,
          alist,
          function(param){
           var data = param[2], key = param[1], a = caml_call1(data_t, data);
           return caml_call2
                   (Base_Sequence[35],
                    a,
                    function(smaller_data){
                     return caml_call4
                             (Base_Map[118][3][38], comparator, tree, key, smaller_data);
                    });
          }),
      shrink_data = Base_Sequence[70].call(null, c);
     return Base_Sequence[70].call
             (null, [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var
      list = caml_call1(Base_Set[75][3][14], tree),
      a = Base_Sequence[106].call(null, list),
      drop_elts =
        caml_call2
         (Base_Sequence[35],
          a,
          function(elt){
           return caml_call3(Base_Set[75][3][19], comparator, tree, elt);
          }),
      b =
        Base_List[53].call
         (null,
          list,
          function(elt){
           var
            tree$0 = caml_call3(Base_Set[75][3][19], comparator, tree, elt),
            a = caml_call1(elt_t, elt);
           return Base_Sequence[80].call
                   (null,
                    a,
                    function(smaller_elt){
                     return caml_call3
                              (Base_Set[75][3][17], comparator, tree$0, smaller_elt)
                             ? 0
                             : [0,
                               caml_call3
                                (Base_Set[75][3][18], comparator, tree$0, smaller_elt)];
                    });
          }),
      shrink_elts = Base_Sequence[70].call(null, b);
     return Base_Sequence[70].call(null, [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = Base_Map[5].call(null, map_t),
      a = Base_Map[118][104],
      b = caml_call1(Base_Map[118][33], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), b, a);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = Base_Set[4].call(null, set_t),
      a = Base_Set[75][49],
      b = caml_call1(Base_Set[75][66], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), b, a);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (16, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
//# shape: Base_quickcheck__Test_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base__Word_size, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
//# shape: Base_quickcheck__Test:[N,N,F(4),F(4),F(4),F(4),F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_test_count = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_List = global_data.Base__List,
    Base_Word_size = global_data.Base__Word_size,
    a = [0, "Deterministic"],
    b = [0, "Nondeterministic"];
   function sexp_of_t(param){
    if(! param) return b;
    var arg0_001 = param[1], res0_002 = Base[202].call(null, arg0_001);
    return [1, [0, a, [0, res0_002, 0]]];
   }
   var
    Seed = [0, sexp_of_t],
    c = [0, "sizes"],
    d = [0, "shrink_count"],
    e = [0, cst_test_count],
    f = [0, "seed"];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[136],
     match = Base_Sequence[90].call(null, sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = Base_List[53].call(null, prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       Base_Sequence[9].call(null, suffix)
        ? 0
        : [0, Sexplib0_Sexp_conv[7].call(null, cst), 0],
     arg_011 = [1, Base[222].call(null, prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, c, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[136], shrink_count_008),
     bnds_003$1 = [0, [1, [0, d, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[136], test_count_006),
     bnds_003$2 = [0, [1, [0, e, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = sexp_of_t(seed_004),
     bnds_003$3 = [0, [1, [0, f, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    g = Base_List[132].call(null, 0, [0, 104758188], [0, 104758188], 0, 30),
    h = Base_Sequence[99].call(null, g),
    q = [0, "error"],
    r = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed",
    p = [0, 0],
    n = [0, 0],
    o = [0, 0],
    l = [0, "number_of_size_values"],
    m = [0, cst_test_count],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    k = [0, "an arbitrary but deterministic string"],
    i = 10000,
    j = Base_Word_size[3] ? 10000 : 1000,
    default_config = [0, k, j, i, h],
    lazy_nondeterministic_state =
      [246, function(a){return caml_call2(Base_Random[19][3], 0, 0);}];
   function with_sample(f, h, opt, generator){
    var
     config = h ? h[1] : default_config,
     examples = opt ? opt[1] : 0,
     match = config[1];
    if(match)
     var
      string = match[1],
      c = runtime.Base_hash_string(string),
      random = Splittable_random[2].call(null, c);
    else{
     var a = runtime.caml_obj_tag(lazy_nondeterministic_state);
     a:
     if(250 === a)
      var b = lazy_nondeterministic_state[1];
     else{
      if(246 !== a && 244 !== a){
       var b = lazy_nondeterministic_state;
       break a;
      }
      var b = CamlinternalLazy[2].call(null, lazy_nondeterministic_state);
     }
     var random = Splittable_random[1].call(null, b);
    }
    var
     d =
       Base_Sequence[45].call
        (null,
         [0, config[4], 0],
         function(param){
          var number_of_size_values = param[2], sizes = param[1];
          if(config[2] <= number_of_size_values) return 0;
          var match = Base_Sequence[42].call(null, sizes);
          if(match){
           var
            match$0 = match[1],
            remaining_sizes = match$0[2],
            size = match$0[1];
           return [0,
                   [0,
                    size,
                    [0, remaining_sizes, number_of_size_values + 1 | 0]]];
          }
          var
           a =
             [0,
              [1,
               [0, l, [0, caml_call1(Base[136], number_of_size_values), 0]]],
              0],
           b = [0, [1, [0, m, [0, caml_call1(Base[136], config[2]), 0]]], a],
           c =
             [1,
              [0,
               Sexplib0_Sexp_conv[7].call
                (null, cst_Base_quickcheck_Test_run_i),
               b]];
          return Base[246].call(null, c);
         }),
     e =
       caml_call2
        (Base_Sequence[35],
         d,
         function(size){
          return Base_quickcheck_Generator[128].call
                  (null, generator, size, random);
         }),
     g = Base_Sequence[106].call(null, examples),
     sequence = Base_Sequence[65].call(null, g, e);
    return caml_call1(f, sequence);
   }
   function result(f, a, opt, m){
    var config = a ? a[1] : default_config, examples = opt ? opt[1] : 0;
    return with_sample
            (function(sequence){
              var
               match$2 =
                 Base_Sequence[12].call
                  (null,
                   sequence,
                   0,
                   function(param, input){
                    var match = caml_call1(f, input);
                    if(0 === match[0]) return n;
                    var error = match[1];
                    return [1, [0, input, error]];
                   });
              if(0 === match$2[0]) return o;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count = config[3],
               alternates$2 =
                 caml_call1
                  (Base_quickcheck_Shrinker[37].call(null, shrinker), input$0),
               shrink_count$0 = shrink_count,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count$0){
                var
                 shrink_count$1 = shrink_count$0 - 1 | 0,
                 match = Base_Sequence[42].call(null, alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  shrink_count$0 = shrink_count$1;
                  alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call1
                     (Base_quickcheck_Shrinker[37].call(null, shrinker),
                      alternate);
                 shrink_count$0 = shrink_count$1;
                 alternates = alternates$1;
                 input = alternate;
                 error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             [0, config],
             [0, examples],
             m[2]);
   }
   function run(f, config, examples, M){
    function f$0(x){
     var a = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return Base_Or_error[32].call
             (null, a, function(param){return caml_call1(f, x);});
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return p;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     a = [0, [1, [0, q, [0, Base_Error[9].call(null, error), 0]]], 0],
     b = [0, [1, [0, r, [0, caml_call1(M[1], input), 0]]], a],
     c =
       [1,
        [0,
         Sexplib0_Sexp_conv[7].call(null, cst_Base_quickcheck_Test_run_t),
         b]];
    return Base_Or_error[39].call(null, c);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     return Base_Or_error[31].call
             (null, 0, function(param){return caml_call1(f, x);});
    }
    var a = with_sample(f$0, config, examples, generator);
    return Base_Or_error[34].call(null, a);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     var a = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return Base_Or_error[31].call
             (null, a, function(param){return caml_call1(f, x);});
    }
    var a = run(f$0, config, examples, testable);
    return Base_Or_error[34].call(null, a);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0, Seed, sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (32, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
//# shape: Base_quickcheck__Observer:[F(3)*,F(3)*,N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(2)*,F(2)*,F(2)*,N,N,N,N,N,F(2)*,F(2)*,F(1)*,F(2)*,F(1)*,F(1)*,F(2)*,F(1),F(1)*,F(1)*,F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3];
   function unmap(t, f){
    return create
            (function(x, size, hash){
              return observe(t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return create(function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return create
            (function(x, size, hash){
              var a = caml_obj_tag(lazy_t);
              a:
              if(250 === a)
               var b = lazy_t[1];
              else{
               if(246 !== a && 244 !== a){var b = lazy_t; break a;}
               var b = CamlinternalLazy[2].call(null, lazy_t);
              }
              return observe(b, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[4]),
    char = of_hash_fold(Base_Char[4]),
    int = of_hash_fold(Base_Int[7]),
    int32 = of_hash_fold(Base_Int32[7]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[7]),
    nativeint = of_hash_fold(Base_Nativeint[7]),
    float = of_hash_fold(Base_Float[5]),
    string = of_hash_fold(Base_String[40]),
    sexp = of_hash_fold(Base[85][2]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[112])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[123])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[123])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[123])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[123])),
    bytes = unmap(string, Base_Bytes[29]),
    a = [0, 0];
   function either(fst_t, snd_t){
    return create
            (function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return observe
                       (fst_t, fst, size, caml_call2(Base[133], hash, 1));
              }
              var snd = either[1];
              return observe(snd_t, snd, size, caml_call2(Base[133], hash, 2));
             });
   }
   function result(ok_t, err_t){
    return unmap
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function both(fst_t, snd_t){
    return create
            (function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = observe(fst_t, fst, size, hash),
               hash$1 = observe(snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    return unmap
            (either(opaque, value_t),
             function(param){
              if(! param) return a;
              var value = param[1];
              return [1, value];
             });
   }
   function list(elt_t){
    return create
            (function(list, size, hash){
              var
               a = Base_Hash[9].call(null, hash),
               random = Splittable_random[2].call(null, a),
               length = Base_List[45].call(null, list),
               b =
                 Base_quickcheck_Generator[53].call
                  (null, [0, length], [0, length], 0),
               sizes =
                 Base_quickcheck_Generator[128].call(null, b, size, random),
               c = caml_call2(Base[133], hash, 0);
              return Base_List[71].call
                      (null,
                       list,
                       sizes,
                       c,
                       function(hash, elt, size){
                        return observe
                                (elt_t, elt, size, caml_call2(Base[133], hash, 1));
                       });
             });
   }
   function array(t){var a = Base_Array[30]; return unmap(list(t), a);}
   function ref(t){return unmap(t, function(a){return a[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(a){
              var b = caml_obj_tag(a);
              if(250 === b) return a[1];
              if(246 !== b && 244 !== b) return a;
              return CamlinternalLazy[2].call(null, a);
             });
   }
   function fn(dom, rng){
    return create
            (function(f, size, hash){
              var
               a = Base_Hash[9].call(null, hash),
               random = Splittable_random[2].call(null, a),
               b = Base_quickcheck_Generator[53].call(null, 0, 0, 0),
               sizes =
                 Base_quickcheck_Generator[128].call
                  (null, b, size * 2 | 0, random);
              return Base_List[20].call
                      (null,
                       sizes,
                       hash,
                       function(hash, size){
                        var
                         x =
                           Base_quickcheck_Generator[128].call(null, dom, size, random);
                        return observe(rng, caml_call1(f, x), size, hash);
                       });
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[118][3][74];
    return unmap
            (list(both(key_obs, data_obs)),
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function set_tree(elt_obs){
    var a = Base_Set[75][3][14];
    return unmap(list(elt_obs), a);
   }
   function map_t(key_obs, data_obs){
    var a = Base_Map[118][104];
    return unmap(map_tree(key_obs, data_obs), a);
   }
   function set_t(elt_obs){
    var a = Base_Set[75][49];
    return unmap(set_tree(elt_obs), a);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char,
       string,
       bytes,
       int,
       int32,
       int63,
       int64,
       nativeint,
       float,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
//# shape: Base_quickcheck__Export:[N,N,N,N,N,N,N,N,N,N,F(3)*,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*->F(1),F(1),F(1),F(1)*,F(1)*]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
//# shape: Base_quickcheck:[N,N,N,N,N,N,N,N,N,N,F(3)*,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(1),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*->F(1),F(1),F(1),F(1)*,F(1)*,[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9xdWlja2NoZWNrIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUEsb0JBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9xdWlja2NoZWNrX1dpdGhfYmFzaWNfdHlwIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGlDQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZV9xdWlja2NoZWNrL2JpZ2FycmF5X2hlbHBlcnMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBMYXlvdXQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgQmlnYXJyYXkubGF5b3V0XG5cbiAgbGV0IG9mZnNldCA6IHR5cGUgYS4gYSB0IC0+IGludCA9IGZ1bmN0aW9uXG4gICAgfCBCaWdhcnJheS5Gb3J0cmFuX2xheW91dCAtPiAxXG4gICAgfCBCaWdhcnJheS5DX2xheW91dCAtPiAwXG4gIDs7XG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEJpZ2FycmF5LkFycmF5MS50XG5cbiAgbGV0IGl0ZXJpIHQgfmYgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgZm9yIGkgPSAwIHRvIEJpZ2FycmF5LkFycmF5MS5kaW0gdCAtIDEgZG9cbiAgICAgIGYgKGkgKyBvZmZzZXQpIHQue2kgKyBvZmZzZXR9XG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBpbml0ICh0eXBlIGVsdCkgKGtpbmQgOiAoZWx0LCBfKSBCaWdhcnJheS5raW5kKSBsYXlvdXQgZGltIH5mID1cbiAgICBsZXQgdCA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IHQue2l9IDwtIGYgaSk7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIChfIDogZWx0KSAtPiBpbml0IDo9IGYgIWluaXQgdC57aX0pO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkxLmRpbSB0KSB+ZjooZnVuIGkgLT4gdC57aSArIG9mZnNldH0pXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBfc2V4cF9vZl9wYWNrIF9zZXhwX29mX2xheW91dCB0ID1cbiAgICBbJXNleHAgKHRvX2FycmF5IHQgOiBlbHQgYXJyYXkpXVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGQgaGFzaF9mb2xkX2VsdCBzdGF0ZSB0ID1cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTEuZGltIHQpIGluXG4gICAgZm9sZCB0IH5pbml0OnN0YXRlIH5mOmhhc2hfZm9sZF9lbHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkyLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5Mi5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCAtIDEgZG9cbiAgICAgIGZvciBqID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMiB0IC0gMSBkb1xuICAgICAgICBmIChpICsgb2Zmc2V0KSAoaiArIG9mZnNldCkgdC57aSArIG9mZnNldCwgaiArIG9mZnNldH1cbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0xIGRpbTIgfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkyLmNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSBqIChfIDogZWx0KSAtPiB0LntpLCBqfSA8LSBmIGkgaik7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biAoXyA6IGludCkgKF8gOiBpbnQpIGVsdCAtPiBpbml0IDo9IGYgIWluaXQgZWx0KTtcbiAgICAhaW5pdFxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIEFycmF5LmluaXQgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIH5mOihmdW4gaSAtPlxuICAgICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgfmY6KGZ1biBqIC0+IHQue2kgKyBvZmZzZXQsIGogKyBvZmZzZXR9KSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIGluXG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfYmFfZGltXzEiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmFfZ2V0XzIiLCJjYW1sX2JhX2xheW91dCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJnbG9iYWxfZGF0YSIsIkJhc2UiLCJCYXNlX0FycmF5IiwiU3RkbGliX0JpZ2FycmF5Iiwib2Zmc2V0IiwicGFyYW0iLCJMYXlvdXQiLCJpdGVyaSIsInQiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJqIiwiZGltMSIsImRpbTIiLCJlbHQiLCJ4XzAwMiIsIkJhc2VfcXVpY2tjaGVja19CaWdhcnJheV9oZWxwZSJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxZQUFBQyxPQUFBQyxPQ0tNLG9CQUVzQjtBQUFBLE9BQUFDLFNEUDVCO0FBQUEsWUFBQUMsTUFBQUMsR0FBQWhCO0FBQUFBO0FBQUFBLEtBQUFZLFdDZWlCLE9BQWM7QUFBQSxTQUNkO0FBQUEsU0FBcUI7QUFBQTtBQUFBLFNBQUFLLElBQUE7QUFBQTtBQUFBLE1BQ2hDLGdDQUFlO0FBQUEsY0FBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFERztBQUFBLEdBRTlCO0FBQUEsWUFBQUMsS0FBQUMsTUFBQUMsUUFBQUMsS0FBQXJCO0FBQUFBLFFBQUFnQixJQUlJO0FBQUEsSUFDUjtBQUFBO0FBQUEsZUFBQUMsR0FBQUo7QUFBQUEsT0FBd0MsT0FBVCw0QkFBUyxpQkFBRztBQUFBO0FBQUEsSUFBQztBQUFBLEdBQzNDO0FBQUEsWUFBQVMsS0FBQU4sR0FBQUUsTUFBQWxCO0FBQUFBLFFBQUFrQixTQUlEO0FBQUEsSUFDQTtBQUFBO0FBQUEsZUFBQUQsR0FBQUo7QUFBQUEsV0FBQSxJQUErQztBQUFBLE9BQVI7QUFBQSxPQUFhO0FBQUE7QUFBQSxJQUFDO0FBQUEsR0FDaEQ7QUFBQSxZQUFBVSxTQUFBUDtBQUFBQSxRQUFBSixXQUlRLE9BQWMsd0JBQ2hCO0FBQUEsSUFBdUI7QUFBQSwrQkFBQUssR0FBYyx5Q0FBYyxHQUFDO0FBQUE7QUFBQSxZQUFBTyxVQUFBQyxhQUFBQyxjQUFBQyxnQkFBQVg7QUFBQUEsUUFBQVksUUFJdkQ7QUFBQSxJQUFhLDhDQUFVO0FBQUE7QUFBQSxZQUFBQyxVQUFBQyxlQUFBQyxPQUFBZjtBQUFBQSxRQUFBLElBSUMsa0JBQUFlLFVBQXBCO0FBQUEsSUFDWixzQ0FBbUM7QUFBQTtBQUFBLFlBQUFoQixRQUFBQyxHQUFBaEI7QUFBQUE7QUFBQUEsS0FBQVksV0FRdEIsT0FBYztBQUFBLFNBQ2Q7QUFBQSxTQUFzQjtBQUFBO0FBQUEsU0FBQUssSUFBQTtBQUFBO0FBQUEsY0FDcEIsOEJBQXNCO0FBQUE7QUFBQSxXQUFBZSxJQUFBO0FBQUE7QUFBQSxRQUNqQztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQTRCO0FBQUEsZ0JBQTBCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQURyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFERjtBQUFBLEdBSS9CO0FBQUEsWUFBQWQsT0FBQUMsTUFBQUMsUUFBQWEsTUFBQUMsTUFBQWxDO0FBQUFBLFFBQUFnQixJQUlJO0FBQUEsSUFDUjtBQUFBO0FBQUEsZUFBQUMsR0FBQWUsR0FBQW5CO0FBQUFBLE9BQTZDLE9BQVosK0JBQVksb0JBQUs7QUFBQTtBQUFBLElBQUM7QUFBQSxHQUNsRDtBQUFBLFlBQUFTLE9BQUFOLEdBQUFFLE1BQUFsQjtBQUFBQSxRQUFBa0IsU0FJRDtBQUFBLElBQ0E7QUFBQTtBQUFBLGtCQUFBTCxPQUFBc0I7QUFBQUEsT0FBbUQ7QUFBQSxPQUFXO0FBQUE7QUFBQSxJQUFDO0FBQUEsR0FDMUQ7QUFBQSxZQUFBWixXQUFBUDtBQUFBQSxRQUFBSixXQUlRLE9BQWMsd0JBQ2hCO0FBQUEsSUFBd0I7QUFBQTtBQUFBO0FBQUEsc0JBQUFLO0FBQUFBLGtCQUFBLElBQ3RCO0FBQUEsY0FBd0I7QUFBQTtBQUFBO0FBQUEsZ0NBQUFlO0FBQUFBLHdCQUFjLDJEQUEwQjtBQUFBLHlCQUFDO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQVIsWUFBQUMsYUFBQUMsY0FBQUMsZ0JBQUFYO0FBQUFBLFFBQUFvQixRQUl2RSxtQkFBYTtBQUFBLElBQWUsdUNBQWYsa0NBQWdCO0FBQUE7QUFBQSxZQUFBUCxZQUFBQyxlQUFBQyxPQUFBZjtBQUFBQTtBQUFBQSxLQUFBLElBSUw7QUFBQSxLQUFBZSxVQUFwQjtBQUFBLFNBQ29CO0FBQUEsS0FBQUEsVUFBcEI7QUFBQSxJQUNaLHdDQUFtQztBQUFBO0FBQUE7QUFBQSxJQUFBTTtBQUFBQSxNRHJGdkMiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyMTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZV9xdWlja2NoZWNrL29ic2VydmVyMC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2VcblxudHlwZSAnYSB0ID0gJ2EgLT4gc2l6ZTppbnQgLT4gaGFzaDpIYXNoLnN0YXRlIC0+IEhhc2guc3RhdGVcblxubGV0IGNyZWF0ZSBmIDogXyB0ID0gZlxuXG5sZXQgb2JzZXJ2ZSAodCA6IF8gdCkgeCB+c2l6ZSB+aGFzaCA9XG4gIGlmIHNpemUgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suT2JzZXJ2ZXIub2JzZXJ2ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gIGVsc2UgdCB4IH5zaXplIH5oYXNoXG47O1xuXG5sZXQgb3BhcXVlIF8gfnNpemU6XyB+aGFzaCA9IGhhc2hcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDMiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiY3N0X0Jhc2VfcXVpY2tjaGVja19PYnNlcnZlcl9vIiwiY3JlYXRlIiwib2JzZXJ2ZSIsInQiLCJ4Iiwic2l6ZSIsImhhc2giLCJvcGFxdWUiLCJwYXJhbSIsIkJhc2VfcXVpY2tjaGVja19PYnNlcnZlcjAiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxPQUFBVCxHQ0lxQixTQUFDO0FBQUEsWUFBQVUsUUFBQUMsR0FBQUMsR0FBQUMsTUFBQUM7QUFBQUEsSUFHcEIsY0FFSyxtQ0FBZTtBQUFBO0FBQUEsU0FEZ0Q7QUFBQTtBQUFBLE9BQTdDO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBeUQsOEJBQzVEO0FBQUE7QUFBQSxZQUFBQyxPQUFBLEdBQUFDLE9BQUFGLE1BR08sWUFBSTtBQUFBLE9BQUFHLDRCRFpqQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlX3F1aWNrY2hlY2svZ2VuZXJhdG9yLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgVCA6IHNpZ1xuICB0eXBlICsnYSB0XG5cbiAgdmFsIGNyZWF0ZSA6IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20udCAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZ2VuZXJhdGUgOiAnYSB0IC0+IHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS50IC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS50IC0+ICdhKSBTdGFnZWQudFxuXG4gIGxldCBjcmVhdGUgZiA6IF8gdCA9IFN0YWdlZC5zdGFnZSBmXG5cbiAgbGV0IGdlbmVyYXRlICh0IDogXyB0KSB+c2l6ZSB+cmFuZG9tID1cbiAgICBpZiBzaXplIDwgMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLmdlbmVyYXRlOiBzaXplIDwgMFwiIChzaXplIDogaW50KV1cbiAgICBlbHNlIFN0YWdlZC51bnN0YWdlIHQgfnNpemUgfnJhbmRvbVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgc2l6ZSA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb206XyAtPiBzaXplKVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uc3BsaXQgcmFuZG9tIGluXG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBoYXNoID0gT2JzZXJ2ZXIwLm9ic2VydmUgZG9tIHggfnNpemUgfmhhc2g6KEhhc2guYWxsb2MgKCkpIGluXG4gICAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uY29weSByYW5kb20gaW5cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLnBlcnR1cmIgcmFuZG9tIChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpO1xuICAgICAgZ2VuZXJhdGUgcm5nIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgd2l0aF9zaXplIHQgfnNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgcGVydHVyYiB0IHNhbHQgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20ucGVydHVyYiByYW5kb20gc2FsdDtcbiAgICBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIH5zaXplIH5yYW5kb20gPVxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbWF0Y2ggZiB4IHdpdGhcbiAgICB8IFNvbWUgeSAtPiB5XG4gICAgfCBOb25lIC0+IGxvb3AgfnNpemU6KHNpemUgKyAxKSB+cmFuZG9tXG4gIGluXG4gIGNyZWF0ZSBsb29wXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5sZXQgcmV0dXJuIHggPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb206XyAtPiB4KVxubGV0IG1hcCB0IH5mID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBmIChnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYXBwbHkgdGYgdHggPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGYgPSBnZW5lcmF0ZSB0ZiB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0eCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgZiB4KVxuOztcblxubGV0IGJpbmQgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIGdlbmVyYXRlIChmIHgpIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgYWxsIGxpc3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QubWFwIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYWxsX3VuaXQgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gTGlzdC5pdGVyIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuOztcblxubW9kdWxlIEZvcl9hcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCByZXR1cm4gPSByZXR1cm5cbiAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5lbmQpXG5cbmxldCBib3RoID0gRm9yX2FwcGxpY2F0aXZlLmJvdGhcbmxldCBtYXAyID0gRm9yX2FwcGxpY2F0aXZlLm1hcDJcbmxldCBtYXAzID0gRm9yX2FwcGxpY2F0aXZlLm1hcDNcblxubW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gRm9yX2FwcGxpY2F0aXZlLkFwcGxpY2F0aXZlX2luZml4XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2luZml4XG5cbm1vZHVsZSBGb3JfbW9uYWQgPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGxldCBiaW5kID0gYmluZFxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxubGV0IGlnbm9yZV9tID0gRm9yX21vbmFkLmlnbm9yZV9tXG5sZXQgam9pbiA9IEZvcl9tb25hZC5qb2luXG5cbm1vZHVsZSBNb25hZF9pbmZpeCA9IEZvcl9tb25hZC5Nb25hZF9pbmZpeFxuaW5jbHVkZSBNb25hZF9pbmZpeFxubW9kdWxlIExldF9zeW50YXggPSBGb3JfbW9uYWQuTGV0X3N5bnRheFxub3BlbiBMZXRfc3ludGF4XG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxpc3RcbiAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2ZfbGlzdDogZW1wdHkgbGlzdFwiXTtcbiAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gIGxldCBsbyA9IDAgaW5cbiAgbGV0IGhpID0gQXJyYXkubGVuZ3RoIGFycmF5IC0gMSBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbyB+aGkgaW5cbiAgICBhcnJheS4oaW5kZXgpKVxuOztcblxubGV0IHVuaW9uIGxpc3QgPSBqb2luIChvZl9saXN0IGxpc3QpXG5cbmxldCBvZl93ZWlnaHRlZF9saXN0IGFsaXN0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSBhbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgd2VpZ2h0cywgdmFsdWVzID0gTGlzdC51bnppcCBhbGlzdCBpblxuICBsZXQgdmFsdWVfYXJyYXkgPSBBcnJheS5vZl9saXN0IHZhbHVlcyBpblxuICBsZXQgdG90YWxfd2VpZ2h0LCBjdW11bGF0aXZlX3dlaWdodF9hcnJheSA9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHZhbHVlX2FycmF5KSB+ZjooZnVuIF8gLT4gMC4pIGluXG4gICAgbGV0IHN1bSA9XG4gICAgICBMaXN0LmZvbGRpIHdlaWdodHMgfmluaXQ6MC4gfmY6KGZ1biBpbmRleCBhY2Mgd2VpZ2h0IC0+XG4gICAgICAgIGlmIG5vdCAoRmxvYXQuaXNfZmluaXRlIHdlaWdodClcbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5vdCBmaW5pdGVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBpZiBGbG9hdC4oIDwgKSB3ZWlnaHQgMC5cbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5lZ2F0aXZlXCJcbiAgICAgICAgICAgICAgICAod2VpZ2h0IDogZmxvYXQpXTtcbiAgICAgICAgbGV0IGN1bXVsYXRpdmUgPSBhY2MgKy4gd2VpZ2h0IGluXG4gICAgICAgIGFycmF5LihpbmRleCkgPC0gY3VtdWxhdGl2ZTtcbiAgICAgICAgY3VtdWxhdGl2ZSlcbiAgICBpblxuICAgIGlmIEZsb2F0LiggPD0gKSBzdW0gMC5cbiAgICB0aGVuXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogdG90YWwgd2VpZ2h0IGlzIHplcm9cIl07XG4gICAgc3VtLCBhcnJheVxuICBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgY2hvaWNlID0gU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzowLiB+aGk6dG90YWxfd2VpZ2h0IGluXG4gICAgbWF0Y2hcbiAgICAgIEFycmF5LmJpbmFyeV9zZWFyY2hcbiAgICAgICAgY3VtdWxhdGl2ZV93ZWlnaHRfYXJyYXlcbiAgICAgICAgfmNvbXBhcmU6RmxvYXQuY29tcGFyZVxuICAgICAgICBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgICAgIGNob2ljZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgaW5kZXggLT4gdmFsdWVfYXJyYXkuKGluZGV4KVxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgd2VpZ2h0ZWRfdW5pb24gYWxpc3QgPSBqb2luIChvZl93ZWlnaHRlZF9saXN0IGFsaXN0KVxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBnZW5lcmF0ZSAoZm9yY2UgbGF6eV90KSB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2ZfZ2VuZXJhdG9yID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9nZW5lcmF0b3IgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgZm9yY2UgbGF6eV90XG47O1xuXG5sZXQgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0IHJlY19saXN0ID1cbiAgICAgIExpc3QubWFwIChmIHNlbGYpIH5mOihmdW4gKHcsIHQpIC0+XG4gICAgICAgICggd1xuICAgICAgICAsIGxldCViaW5kIG4gPSBzaXplIGluXG4gICAgICAgICAgd2l0aF9zaXplIH5zaXplOihuIC0gMSkgdCApKVxuICAgIGluXG4gICAgaWYgTGlzdC5pc19lbXB0eSBub25yZWNfbGlzdCB8fCBMaXN0LmlzX2VtcHR5IHJlY19saXN0XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iud2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uOiBsaXN0cyBtdXN0IGJlIG5vbi1lbXB0eVwiXTtcbiAgICBsZXQgbm9ucmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIG5vbnJlY19saXN0IGluXG4gICAgbGV0IHJlY19nZW4gPSB3ZWlnaHRlZF91bmlvbiAobm9ucmVjX2xpc3QgQCByZWNfbGlzdCkgaW5cbiAgICBtYXRjaCViaW5kIHNpemUgd2l0aFxuICAgIHwgMCAtPiBub25yZWNfZ2VuXG4gICAgfCBfIC0+IHJlY19nZW4pXG47O1xuXG5sZXQgcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgbGV0IHdlaWdodGVkIGxpc3QgPSBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gdCAtPiAxLiwgdCkgaW5cbiAgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uICh3ZWlnaHRlZCBub25yZWNfbGlzdCkgfmY6KGZ1biBzZWxmIC0+IHdlaWdodGVkIChmIHNlbGYpKVxuOztcblxubGV0IHNpemVzID8obWluX2xlbmd0aCA9IDApID8obWF4X2xlbmd0aCA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGFzc2VydCAobWluX2xlbmd0aCA8PSBtYXhfbGVuZ3RoKTtcbiAgICBsZXQgdXBwZXJfYm91bmQgPSBtaW5fbGVuZ3RoICsgc2l6ZSBpblxuICAgIGxldCBtYXhfbGVuZ3RoID1cbiAgICAgIGlmIHVwcGVyX2JvdW5kID49IG1pbl9sZW5ndGggKCogZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdyAqKVxuICAgICAgdGhlbiBtaW4gbWF4X2xlbmd0aCB1cHBlcl9ib3VuZFxuICAgICAgZWxzZSBtYXhfbGVuZ3RoXG4gICAgaW5cbiAgICAoKiBwaWNrIGEgbGVuZ3RoLCB3ZWlnaHRlZCBsb3cgc28gdGhhdCBtb3N0IG9mIHRoZSBzaXplIGlzIHNwZW50IG9uIGVsZW1lbnRzICopXG4gICAgbGV0IGxlbiA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOm1pbl9sZW5ndGggfmhpOm1heF9sZW5ndGggaW5cbiAgICAoKiBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgcmV0dXJuIGFuIGVtcHR5IGFycmF5LCBvdGhlcndpc2UgcmV0dXJuIGEgbm9uLWVtcHR5IGFycmF5XG4gICAgICAgd2l0aCB0aGUgc2l6ZSBkaXN0cmlidXRlZCBhbW9uZyB0aGUgZWxlbWVudHMgKilcbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNpemVzID0gQXJyYXkuaW5pdCBsZW4gfmY6KGZ1biBfIC0+IDApIGluXG4gICAgICBsZXQgcmVtYWluaW5nID0gc2l6ZSAtIChsZW4gLSBtaW5fbGVuZ3RoKSBpblxuICAgICAgbGV0IG1heF9pbmRleCA9IGxlbiAtIDEgaW5cbiAgICAgIGZvciBfID0gMSB0byByZW1haW5pbmcgZG9cbiAgICAgICAgKCogcGljayBhbiBpbmRleCwgd2VpZ2h0ZWQgbG93IHNvIHRoYXQgd2Ugc2VlIHVuYmFsYW5jZWQgZGlzdHJpYnV0aW9ucyBvZnRlbiAqKVxuICAgICAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzowIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgc2l6ZXMuKGluZGV4KSA8LSBzaXplcy4oaW5kZXgpICsgMVxuICAgICAgZG9uZTtcbiAgICAgICgqIHBlcm11dGUgdGhlIGFycmF5IHNvIHRoYXQgbm8gaW5kZXggaXMgZmF2b3JlZCBvdmVyIGFub3RoZXIgKilcbiAgICAgIGZvciBpID0gMCB0byBtYXhfaW5kZXggLSAxIGRvXG4gICAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86aSB+aGk6bWF4X2luZGV4IGluXG4gICAgICAgIEFycmF5LnN3YXAgc2l6ZXMgaSBqXG4gICAgICBkb25lO1xuICAgICAgYXNzZXJ0IChBcnJheS5zdW0gKG1vZHVsZSBJbnQpIHNpemVzIH5mOkZuLmlkICsgKGxlbiAtIG1pbl9sZW5ndGgpID0gc2l6ZSk7XG4gICAgICBBcnJheS50b19saXN0IHNpemVzKSlcbjs7XG5cbmxldCB1bml0ID0gcmV0dXJuICgpXG5sZXQgYm9vbCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBTcGxpdHRhYmxlX3JhbmRvbS5ib29sIHJhbmRvbSlcbmxldCBvcHRpb24gdmFsdWVfdCA9IHVuaW9uIFsgcmV0dXJuIE5vbmU7IG1hcCB2YWx1ZV90IH5mOk9wdGlvbi5yZXR1cm4gXVxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9IHVuaW9uIFsgbWFwIGZzdF90IH5mOkVpdGhlci5maXJzdDsgbWFwIHNuZF90IH5mOkVpdGhlci5zZWNvbmQgXVxuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgfCBTZWNvbmQgZXJyIC0+IEVycm9yIGVycilcbjs7XG5cbmxldCBsaXN0X2dlbmVyaWMgP21pbl9sZW5ndGggP21heF9sZW5ndGggZWx0X2dlbiA9XG4gIGxldCViaW5kIHNpemVzID0gc2l6ZXMgP21pbl9sZW5ndGggP21heF9sZW5ndGggKCkgaW5cbiAgTGlzdC5tYXAgc2l6ZXMgfmY6KGZ1biBzaXplIC0+IHdpdGhfc2l6ZSB+c2l6ZSBlbHRfZ2VuKSB8PiBhbGxcbjs7XG5cbmxldCBsaXN0IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgZWx0X2dlblxubGV0IGxpc3Rfbm9uX2VtcHR5IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgfm1pbl9sZW5ndGg6MSBlbHRfZ2VuXG5cbmxldCBsaXN0X3dpdGhfbGVuZ3RoIGVsdF9nZW4gfmxlbmd0aCA9XG4gIGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDpsZW5ndGggfm1heF9sZW5ndGg6bGVuZ3RoIGVsdF9nZW5cbjs7XG5cbmxldCBsaXN0X2ZpbHRlcmVkIGVsdHMgPVxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgbGVuZ3RoX29mX2lucHV0ID0gQXJyYXkubGVuZ3RoIGVsdHMgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGxlbmd0aF9vZl9vdXRwdXQgPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzowIH5oaTpsZW5ndGhfb2ZfaW5wdXQgaW5cbiAgICBsZXQgaW5kaWNlcyA9IEFycmF5LmluaXQgbGVuZ3RoX29mX2lucHV0IH5mOkZuLmlkIGluXG4gICAgKCogQ2hvb3NlIFtsZW5ndGhfb2Zfb3V0cHV0XSByYW5kb20gdmFsdWVzIGluIHRoZSBwcmVmaXggb2YgW2luZGljZXNdLiAqKVxuICAgIGZvciBpID0gMCB0byBsZW5ndGhfb2Zfb3V0cHV0IC0gMSBkb1xuICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaToobGVuZ3RoX29mX2lucHV0IC0gMSkgaW5cbiAgICAgIEFycmF5LnN3YXAgaW5kaWNlcyBpIGpcbiAgICBkb25lO1xuICAgICgqIFNvcnQgdGhlIGNob3NlbiBpbmRpY2VzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byByZW9yZGVyIHRoZW0uICopXG4gICAgQXJyYXkuc29ydCBpbmRpY2VzIH5wb3M6MCB+bGVuOmxlbmd0aF9vZl9vdXRwdXQgfmNvbXBhcmU6SW50LmNvbXBhcmU7XG4gICAgKCogUmV0dXJuIHRoZSBjaG9zZW4gZWxlbWVudHMuICopXG4gICAgTGlzdC5pbml0IGxlbmd0aF9vZl9vdXRwdXQgfmY6KGZ1biBpIC0+IGVsdHMuKGluZGljZXMuKGkpKSkpXG47O1xuXG5sZXQgbGlzdF9wZXJtdXRhdGlvbnMgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBhcnJheSA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmkgaW5cbiAgICAgIEFycmF5LnN3YXAgYXJyYXkgaSBqXG4gICAgZG9uZTtcbiAgICBBcnJheS50b19saXN0IGFycmF5KVxuOztcblxubGV0IGFycmF5IHQgPSBtYXAgKGxpc3QgdCkgfmY6QXJyYXkub2ZfbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbFxuXG5sZXQgY2hhcl91bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOihDaGFyLnRvX2ludCBsbykgfmhpOihDaGFyLnRvX2ludCBoaSlcbiAgICB8PiBDaGFyLnVuc2FmZV9vZl9pbnQpXG47O1xuXG5sZXQgY2hhcl91cHBlcmNhc2UgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICdBJyAnWidcbmxldCBjaGFyX2xvd2VyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ2EnICd6J1xubGV0IGNoYXJfZGlnaXQgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcwJyAnOSdcbmxldCBjaGFyX3ByaW50X3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcgJyAnfidcbmxldCBjaGFyX3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIENoYXIubWluX3ZhbHVlIENoYXIubWF4X3ZhbHVlXG5sZXQgY2hhcl9hbHBoYSA9IHVuaW9uIFsgY2hhcl9sb3dlcmNhc2U7IGNoYXJfdXBwZXJjYXNlIF1cblxubGV0IGNoYXJfYWxwaGFudW0gPVxuICB3ZWlnaHRlZF91bmlvblxuICAgICgqIE1vc3QgcGVvcGxlIHByb2JhYmx5IGV4cGVjdCB0aGlzIHRvIGJlIGEgdW5pZm9ybSBkaXN0cmlidXRpb24sIG5vdCB3ZWlnaHRlZFxuICAgICAgIHRvd2FyZCBkaWdpdHMgbGlrZSB3ZSB3b3VsZCBnZXQgd2l0aCBbdW5pb25dIChzaW5jZSB0aGVyZSBhcmUgZmV3ZXIgZGlnaXRzIHRoYW5cbiAgICAgICBsZXR0ZXJzKS4gKilcbiAgICBbIDUyLiwgY2hhcl9hbHBoYTsgMTAuLCBjaGFyX2RpZ2l0IF1cbjs7XG5cbmxldCBjaGFyX3doaXRlc3BhY2UgPSBvZl9saXN0IChMaXN0LmZpbHRlciBDaGFyLmFsbCB+ZjpDaGFyLmlzX3doaXRlc3BhY2UpXG5sZXQgY2hhcl9wcmludCA9IHdlaWdodGVkX3VuaW9uIFsgMTAuLCBjaGFyX2FscGhhbnVtOyAxLiwgY2hhcl9wcmludF91bmlmb3JtIF1cblxubGV0IGNoYXIgPVxuICB3ZWlnaHRlZF91bmlvblxuICAgIFsgMTAwLiwgY2hhcl9wcmludFxuICAgIDsgMTAuLCBjaGFyX3VuaWZvcm1cbiAgICA7IDEuLCByZXR1cm4gQ2hhci5taW5fdmFsdWVcbiAgICA7IDEuLCByZXR1cm4gQ2hhci5tYXhfdmFsdWVcbiAgICBdXG47O1xuXG4oKiBQcm9kdWNlcyBhIG51bWJlciBmcm9tIDAgb3IgMSB0byBzaXplICsgMSwgd2VpZ2h0ZWQgaGlnaC4gV2UgaGF2ZSBmb3VuZCB0aGlzXG4gICBkaXN0cmlidXRpb24gZW1waXJpY2FsbHkgdXNlZnVsIGZvciBzdHJpbmcgbGVuZ3Rocy4gKilcbmxldCBzbWFsbF9pbnQgfmFsbG93X3plcm8gPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGxvd2VyX2JvdW5kID0gaWYgYWxsb3dfemVybyB0aGVuIDAgZWxzZSAxIGluXG4gICAgbGV0IHVwcGVyX2JvdW5kID0gc2l6ZSArIDEgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfbG93ID1cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOih1cHBlcl9ib3VuZCAtIGxvd2VyX2JvdW5kKVxuICAgIGluXG4gICAgbGV0IHdlaWdodGVkX2hpZ2ggPSB1cHBlcl9ib3VuZCAtIHdlaWdodGVkX2xvdyBpblxuICAgIHdlaWdodGVkX2hpZ2gpXG47O1xuXG5sZXQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgPSBzbWFsbF9pbnQgfmFsbG93X3plcm86dHJ1ZVxubGV0IHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzpmYWxzZVxuXG5tb2R1bGUgdHlwZSBJbnRfd2l0aF9yYW5kb20gPSBzaWdcbiAgaW5jbHVkZSBJbnQuU1xuXG4gIHZhbCB1bmlmb3JtIDogU3BsaXR0YWJsZV9yYW5kb20udCAtPiBsbzp0IC0+IGhpOnQgLT4gdFxuICB2YWwgbG9nX3VuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG5lbmRcblxubW9kdWxlIEZvcl9pbnRlZ2VyIChJbnRlZ2VyIDogSW50X3dpdGhfcmFuZG9tKSA9IHN0cnVjdFxuICBsZXQgZ2VvbWV0cmljIGxvIH5wID1cbiAgICBpZiBGbG9hdC5lcXVhbCBwIDEuXG4gICAgdGhlbiByZXR1cm4gbG9cbiAgICBlbHNlIGlmIEZsb2F0LmVxdWFsIHAgMC5cbiAgICB0aGVuIHJldHVybiBJbnRlZ2VyLm1heF92YWx1ZVxuICAgIGVsc2UgaWYgRmxvYXQuKCA8ICkgcCAwLiB8fCBGbG9hdC4oID4gKSBwIDEuIHx8IEZsb2F0LmlzX25hbiBwXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJnZW9tZXRyaWMgZGlzdHJpYnV0aW9uOiBwIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIgKHAgOiBmbG9hdCldXG4gICAgZWxzZSAoXG4gICAgICAoKiBXZSBzdGFydCB3aXRoIGEgdW5pZm9ybSBkaXN0cmlidXRpb24uIFdlIGNvbnZlcnQgdG8gZXhwb25lbnRpYWwgZGlzdHJpYnV0aW9uXG4gICAgICAgICB1c2luZyBbbG9nXS4gV2UgY29udmVydCB0byBnZW9tZXRyaWMgd2l0aCBbcm91bmRfZG93bl0uIFRoZW4gd2UgYm91bmRzIGNoZWNrIGFuZFxuICAgICAgICAgcmV0dXJuLiAqKVxuICAgICAgbGV0IGRlbm9taW5hdG9yID0gRmxvYXQubG9nMXAgKC0ucCkgaW5cbiAgICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgICAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLnVuaXRfZmxvYXQgcmFuZG9tIGluXG4gICAgICAgIGxldCBleHBvbmVudGlhbCA9IEZsb2F0LmxvZyB1bmlmb3JtIC8uIGRlbm9taW5hdG9yIGluXG4gICAgICAgIGxldCBmbG9hdCA9IEZsb2F0LnJvdW5kX2Rvd24gZXhwb25lbnRpYWwgaW5cbiAgICAgICAgbWF0Y2ggSW50ZWdlci5vZl9mbG9hdCBmbG9hdCB3aXRoXG4gICAgICAgIHwgZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgXyAtPiBJbnRlZ2VyLm1heF92YWx1ZVxuICAgICAgICB8IGludCAtPlxuICAgICAgICAgIGxldCBpbnQgPSBJbnRlZ2VyLiggKyApIGxvIGludCBpblxuICAgICAgICAgIGlmIEludGVnZXIuKCA8ICkgaW50IGxvIHRoZW4gSW50ZWdlci5tYXhfdmFsdWUgZWxzZSBpbnQpKVxuICA7O1xuXG4gIGxldCB1bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IEludGVnZXIudW5pZm9ybSByYW5kb20gfmxvIH5oaSlcbiAgOztcblxuICBsZXQgbG9nX3VuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gSW50ZWdlci5sb2dfdW5pZm9ybSByYW5kb20gfmxvIH5oaSlcbiAgOztcblxuICBsZXQgbm9uX3VuaWZvcm0gZiBsbyBoaSA9XG4gICAgd2VpZ2h0ZWRfdW5pb24gWyAwLjA1LCByZXR1cm4gbG87IDAuMDUsIHJldHVybiBoaTsgMC45LCBmIGxvIGhpIF1cbiAgOztcblxuICBsZXQgaW5jbHVzaXZlID0gbm9uX3VuaWZvcm0gdW5pZm9ybV9pbmNsdXNpdmVcbiAgbGV0IGxvZ19pbmNsdXNpdmUgPSBub25fdW5pZm9ybSBsb2dfdW5pZm9ybV9pbmNsdXNpdmVcbiAgbGV0IHVuaWZvcm1fYWxsID0gdW5pZm9ybV9pbmNsdXNpdmUgSW50ZWdlci5taW5fdmFsdWUgSW50ZWdlci5tYXhfdmFsdWVcblxuICBsZXQgYWxsID1cbiAgICBbJW1hcFxuICAgICAgbGV0IG5lZ2F0aXZlID0gYm9vbFxuICAgICAgYW5kIG1hZ25pdHVkZSA9IGxvZ19pbmNsdXNpdmUgSW50ZWdlci56ZXJvIEludGVnZXIubWF4X3ZhbHVlIGluXG4gICAgICBpZiBuZWdhdGl2ZSB0aGVuIEludGVnZXIuYml0X25vdCBtYWduaXR1ZGUgZWxzZSBtYWduaXR1ZGVdXG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl9pbnQgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gIGluY2x1ZGUgSW50XG5cbiAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnRcbiAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50XG5lbmQpXG5cbmxldCBpbnQgPSBGb3JfaW50LmFsbFxubGV0IGludF91bmlmb3JtID0gRm9yX2ludC51bmlmb3JtX2FsbFxubGV0IGludF9pbmNsdXNpdmUgPSBGb3JfaW50LmluY2x1c2l2ZVxubGV0IGludF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZVxubGV0IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludF9nZW9tZXRyaWMgPSBGb3JfaW50Lmdlb21ldHJpY1xuXG5tb2R1bGUgRm9yX2ludDMyID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICBpbmNsdWRlIEludDMyXG5cbiAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQzMlxuICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQzMlxuZW5kKVxuXG5sZXQgaW50MzIgPSBGb3JfaW50MzIuYWxsXG5sZXQgaW50MzJfdW5pZm9ybSA9IEZvcl9pbnQzMi51bmlmb3JtX2FsbFxubGV0IGludDMyX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5pbmNsdXNpdmVcbmxldCBpbnQzMl91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50MzIubG9nX2luY2x1c2l2ZVxubGV0IGludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQzMl9nZW9tZXRyaWMgPSBGb3JfaW50MzIuZ2VvbWV0cmljXG5cbm1vZHVsZSBGb3JfaW50NjMgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gIGluY2x1ZGUgSW50NjNcblxuICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDYzXG4gIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDYzXG5lbmQpXG5cbmxldCBpbnQ2MyA9IEZvcl9pbnQ2My5hbGxcbmxldCBpbnQ2M191bmlmb3JtID0gRm9yX2ludDYzLnVuaWZvcm1fYWxsXG5sZXQgaW50NjNfaW5jbHVzaXZlID0gRm9yX2ludDYzLmluY2x1c2l2ZVxubGV0IGludDYzX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDYzX2dlb21ldHJpYyA9IEZvcl9pbnQ2My5nZW9tZXRyaWNcblxubW9kdWxlIEZvcl9pbnQ2NCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgaW5jbHVkZSBJbnQ2NFxuXG4gIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjRcbiAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50NjRcbmVuZClcblxubGV0IGludDY0ID0gRm9yX2ludDY0LmFsbFxubGV0IGludDY0X3VuaWZvcm0gPSBGb3JfaW50NjQudW5pZm9ybV9hbGxcbmxldCBpbnQ2NF9pbmNsdXNpdmUgPSBGb3JfaW50NjQuaW5jbHVzaXZlXG5sZXQgaW50NjRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2NF9sb2dfaW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ19pbmNsdXNpdmVcbmxldCBpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjRfZ2VvbWV0cmljID0gRm9yX2ludDY0Lmdlb21ldHJpY1xuXG5tb2R1bGUgRm9yX25hdGl2ZWludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgaW5jbHVkZSBOYXRpdmVpbnRcblxuICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLm5hdGl2ZWludFxuICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5uYXRpdmVpbnRcbmVuZClcblxubGV0IG5hdGl2ZWludCA9IEZvcl9uYXRpdmVpbnQuYWxsXG5sZXQgbmF0aXZlaW50X3VuaWZvcm0gPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1fYWxsXG5sZXQgbmF0aXZlaW50X2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQuaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IG5hdGl2ZWludF9sb2dfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfaW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2dlb21ldHJpYyA9IEZvcl9uYXRpdmVpbnQuZ2VvbWV0cmljXG5sZXQgZmxvYXRfemVyb19leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMC5cbmxldCBmbG9hdF96ZXJvX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSAwLlxuXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9XG4gIEZsb2F0Lm9uZV91bHAgYERvd24gRmxvYXQubWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxuOztcblxubGV0IGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0Lm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZSA9IEZsb2F0Lm1heF9maW5pdGVfdmFsdWVcbmxldCBmbG9hdF9taW5fbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9pbmZfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfaW5mX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBGbG9hdC5pbmZpbml0eVxubGV0IGZsb2F0X25hbl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubmFuXG5sZXQgZmxvYXRfbWluX25hbl9tYW50aXNzYSA9IEludDYzLnN1Y2MgZmxvYXRfaW5mX21hbnRpc3NhXG5sZXQgZmxvYXRfbWF4X25hbl9tYW50aXNzYSA9IGZsb2F0X21heF9ub3JtYWxfbWFudGlzc2FcbmxldCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyA9IDUyXG5cbigqIFdlIHdlaWdodCBtYW50aXNzYXMgc28gdGhhdCBcImludGVnZXItbGlrZVwiIHZhbHVlcywgYW5kIHZhbHVlcyB3aXRoIG9ubHkgYSBmZXcgZGlnaXRzXG4gICBwYXN0IHRoZSBkZWNpbWFsLCBhcmUgcmVhc29uYWJseSBjb21tb24uICopXG5sZXQgZmxvYXRfbm9ybWFsX21hbnRpc3NhID1cbiAgbGV0JWJpbmQgbnVtX2JpdHMgPSBGb3JfaW50LnVuaWZvcm1faW5jbHVzaXZlIDAgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgaW5cbiAgbGV0JW1hcCBiaXRzID1cbiAgICBGb3JfaW50NjMuaW5jbHVzaXZlIEludDYzLnplcm8gKEludDYzLnByZWQgKEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG51bV9iaXRzKSlcbiAgaW5cbiAgSW50NjMuc2hpZnRfbGVmdCBiaXRzIChJbnQuKCAtICkgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgbnVtX2JpdHMpXG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCArICkgbG93ZXJfYm91bmQgb2Zmc2V0XG47O1xuXG5sZXQgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfaGlnaCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGxldCVtYXAgb2Zmc2V0ID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlIDAgKEludC4oIC0gKSB1cHBlcl9ib3VuZCBsb3dlcl9ib3VuZCkgaW5cbiAgSW50LiggLSApIHVwcGVyX2JvdW5kIG9mZnNldFxuOztcblxuKCogV2Ugd2VpZ2h0IGV4cG9uZW50cyBzdWNoIHRoYXQgdmFsdWVzIG5lYXIgMSBhcmUgbW9yZSBsaWtlbHkuICopXG5sZXQgZmxvYXRfZXhwb25lbnQgPVxuICBsZXQgbWlkcG9pbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IDEuIGluXG4gIHVuaW9uXG4gICAgWyBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgbWlkcG9pbnRcbiAgICA7IGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2xvdyBtaWRwb2ludCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50XG4gICAgXVxuOztcblxubGV0IGZsb2F0X3plcm8gPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfemVyb19leHBvbmVudFxuICAgIH5tYW50aXNzYTpmbG9hdF96ZXJvX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPVxuICAgIEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlIGZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EgZmxvYXRfbWF4X3N1Ym5vcm1hbF9tYW50aXNzYVxuICBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9ub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSBmbG9hdF9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBmbG9hdF9ub3JtYWxfbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfaW5maW5pdGUgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbCBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG5cbiAgICB+bmVnYXRpdmVcbiAgICB+ZXhwb25lbnQ6ZmxvYXRfaW5mX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X2luZl9tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25hbiA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IHJldHVybiBmbG9hdF9uYW5fZXhwb25lbnRcbiAgYW5kIG1hbnRpc3NhID0gRm9yX2ludDYzLmluY2x1c2l2ZSBmbG9hdF9taW5fbmFuX21hbnRpc3NhIGZsb2F0X21heF9uYW5fbWFudGlzc2EgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gZmxvYXRfemVyb1xuICB8IFN1Ym5vcm1hbCAtPiBmbG9hdF9zdWJub3JtYWxcbiAgfCBOb3JtYWwgLT4gZmxvYXRfbm9ybWFsXG4gIHwgSW5maW5pdGUgLT4gZmxvYXRfaW5maW5pdGVcbiAgfCBOYW4gLT4gZmxvYXRfbmFuXG47O1xuXG5sZXQgZmxvYXRfd2VpZ2h0X29mX2NsYXNzIGMgPVxuICBtYXRjaCAoYyA6IEZsb2F0LkNsYXNzLnQpIHdpdGhcbiAgfCBaZXJvIC0+IDEuXG4gIHwgU3Vibm9ybWFsIC0+IDEwLlxuICB8IE5vcm1hbCAtPiAxMDAuXG4gIHwgSW5maW5pdGUgLT4gMS5cbiAgfCBOYW4gLT4gMS5cbjs7XG5cbmxldCBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIGZpbHRlciA9XG4gIExpc3QuZmlsdGVyX21hcCBGbG9hdC5DbGFzcy5hbGwgfmY6KGZ1biBjIC0+XG4gICAgaWYgZmlsdGVyIGMgdGhlbiBTb21lIChmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYywgZmxvYXRfb2ZfY2xhc3MgYykgZWxzZSBOb25lKVxuICB8PiB3ZWlnaHRlZF91bmlvblxuOztcblxubGV0IGZsb2F0X2Zpbml0ZSA9XG4gIGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1bmN0aW9uXG4gICAgfCBaZXJvIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IEluZmluaXRlIHwgTmFuIC0+IGZhbHNlKVxuOztcblxubGV0IGZsb2F0X3dpdGhvdXRfbmFuID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgfCBJbmZpbml0ZSAtPiB0cnVlXG4gICAgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXQgPSBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW4gXyAtPiB0cnVlKVxuXG5sZXQgZmxvYXRfZmluaXRlX25vbl96ZXJvID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFN1Ym5vcm1hbCB8IE5vcm1hbCAtPiB0cnVlXG4gICAgfCBaZXJvIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUgPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGVfbm9uX3plcm8gaW5cbiAgRmxvYXQuYWJzIHRcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfcG9zaXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X25lZ2F0aXZlX29yX3plcm8gPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGUgaW5cbiAgfi0uKEZsb2F0LmFicyB0KVxuOztcblxubGV0IGZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0IG9wZW4gRmxvYXQuTyBpblxuICBpZiAobm90IChGbG9hdC5pc19maW5pdGUgbG93ZXJfYm91bmQpKSB8fCBub3QgKEZsb2F0LmlzX2Zpbml0ZSB1cHBlcl9ib3VuZClcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiBib3VuZHMgYXJlIG5vdCBmaW5pdGVcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGxldCBsb3dlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCBpblxuICBsZXQgdXBwZXJfaW5jbHVzaXZlID0gRmxvYXQub25lX3VscCBgRG93biB1cHBlcl9ib3VuZCBpblxuICBpZiBsb3dlcl9pbmNsdXNpdmUgPiB1cHBlcl9pbmNsdXNpdmVcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIkZsb2F0LnVuaWZvcm1fZXhjbHVzaXZlOiByZXF1ZXN0ZWQgcmFuZ2UgaXMgZW1wdHlcIlxuICAgICAgICAgIChsb3dlcl9ib3VuZCA6IGZsb2F0KVxuICAgICAgICAgICh1cHBlcl9ib3VuZCA6IGZsb2F0KV07XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmZsb2F0IHJhbmRvbSB+bG86bG93ZXJfaW5jbHVzaXZlIH5oaTp1cHBlcl9pbmNsdXNpdmUpXG47O1xuXG5sZXQgZmxvYXRfaW5jbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgaWYgRmxvYXQuZXF1YWwgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgdGhlbiByZXR1cm4gbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBGbG9hdC4oID0gKSAoRmxvYXQub25lX3VscCBgVXAgbG93ZXJfYm91bmQpIHVwcGVyX2JvdW5kXG4gIHRoZW4gdW5pb24gWyByZXR1cm4gbG93ZXJfYm91bmQ7IHJldHVybiB1cHBlcl9ib3VuZCBdXG4gIGVsc2VcbiAgICB3ZWlnaHRlZF91bmlvblxuICAgICAgWyAwLjA1LCByZXR1cm4gbG93ZXJfYm91bmRcbiAgICAgIDsgMC4wNSwgcmV0dXJuIHVwcGVyX2JvdW5kXG4gICAgICA7IDAuOSwgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmRcbiAgICAgIF1cbjs7XG5cbmxldCBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aCA9XG4gIGxpc3Rfd2l0aF9sZW5ndGggY2hhcl9nZW4gfmxlbmd0aCB8PiBtYXAgfmY6U3RyaW5nLm9mX2NoYXJfbGlzdFxuOztcblxubGV0IHN0cmluZ19vZiBjaGFyX2dlbiA9XG4gIGJpbmQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQgfmY6KGZ1biBsZW5ndGggLT5cbiAgICBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhcl9nZW4gfmxlbmd0aClcbjs7XG5cbmxldCBzdHJpbmcgPSBzdHJpbmdfb2YgY2hhclxubGV0IHN0cmluZ19ub25fZW1wdHkgPSBzdHJpbmdfbm9uX2VtcHR5X29mIGNoYXJcbmxldCBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aCA9IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyIH5sZW5ndGhcblxubW9kdWxlIEVkaXRfc3RyaW5nID0gc3RydWN0XG4gIGxldCBlZGl0X2luc2VydCBzdHJpbmcgPVxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZykgaW5cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfZ2VvbWV0cmljIDEgfnA6MC41IGluXG4gICAgbGV0JWJpbmQgc3RyID0gc3RyaW5nX3dpdGhfbGVuZ3RoIH5sZW5ndGg6bGVuIGluXG4gICAgWyBTdHJpbmcucHJlZml4IHN0cmluZyBwb3M7IHN0cjsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyBwb3MgXVxuICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICB8PiByZXR1cm5cbiAgOztcblxuICBsZXQgZWRpdF9yZW1vdmUgc3RyaW5nID1cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZyAtIGxlbikgaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIHBvczsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyAocG9zICsgbGVuKSBdXG4gICAgfD4gU3RyaW5nLmNvbmNhdFxuICAgIHw+IHJldHVyblxuICA7O1xuXG4gIGxldCBlZGl0X3JlcGxhY2Ugc3RyaW5nID1cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZyAtIGxlbikgaW5cbiAgICBsZXQlYmluZCBzdHIgPSBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aDpsZW4gaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIHBvczsgc3RyOyBTdHJpbmcuZHJvcF9wcmVmaXggc3RyaW5nIChwb3MgKyBsZW4pIF1cbiAgICB8PiBTdHJpbmcuY29uY2F0XG4gICAgfD4gcmV0dXJuXG4gIDs7XG5cbiAgbGV0IGVkaXRfZG91YmxlIHN0cmluZyA9XG4gICAgbGV0JWJpbmQgbGVuID0gaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSAxIChTdHJpbmcubGVuZ3RoIHN0cmluZykgaW5cbiAgICBsZXQlYmluZCBwb3MgPSBpbnRfdW5pZm9ybV9pbmNsdXNpdmUgMCAoU3RyaW5nLmxlbmd0aCBzdHJpbmcgLSBsZW4pIGluXG4gICAgWyBTdHJpbmcucHJlZml4IHN0cmluZyAocG9zICsgbGVuKTsgU3RyaW5nLmRyb3BfcHJlZml4IHN0cmluZyBwb3MgXVxuICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICB8PiByZXR1cm5cbiAgOztcblxuICBsZXQgZWRpdF9ub25lbXB0eSBzdHJpbmcgPVxuICAgIFsgZWRpdF9pbnNlcnQgc3RyaW5nOyBlZGl0X3JlbW92ZSBzdHJpbmc7IGVkaXRfcmVwbGFjZSBzdHJpbmc7IGVkaXRfZG91YmxlIHN0cmluZyBdXG4gICAgfD4gdW5pb25cbiAgOztcblxuICBsZXQgcmVjIGVkaXQgc3RyaW5nIG5fdGltZXMgPVxuICAgIGlmIG5fdGltZXMgPD0gMFxuICAgIHRoZW4gcmV0dXJuIHN0cmluZ1xuICAgIGVsc2UgKFxuICAgICAgbGV0JWJpbmQgc3RyaW5nID1cbiAgICAgICAgaWYgU3RyaW5nLmlzX2VtcHR5IHN0cmluZyB0aGVuIGVkaXRfaW5zZXJ0IHN0cmluZyBlbHNlIGVkaXRfbm9uZW1wdHkgc3RyaW5nXG4gICAgICBpblxuICAgICAgZWRpdCBzdHJpbmcgKG5fdGltZXMgLSAxKSlcbiAgOztcbmVuZFxuXG5sZXQgc3RyaW5nX2xpa2Ugc3RyaW5nID1cbiAgbGV0JWJpbmQgbl90aW1lcyA9IGludF9nZW9tZXRyaWMgMCB+cDowLjUgaW5cbiAgRWRpdF9zdHJpbmcuZWRpdCBzdHJpbmcgbl90aW1lc1xuOztcblxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmdcblxubGV0IHNleHBfb2YgYXRvbSA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCViaW5kIHNpemUgPSBzaXplIGluXG4gICAgKCogY2hvb3NlIGEgbnVtYmVyIHdlaWdodGVkIGxvdyBzbyB3ZSBoYXZlIGEgZGVjcmVhc2luZywgYnV0IG5vdCB2YW5pc2hpbmcsIGNoYW5jZVxuICAgICAgIHRvIGdlbmVyYXRlIGF0b21zIGFzIHNpemUgZ3Jvd3MgKilcbiAgICBtYXRjaCViaW5kIEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgKHNpemUgKyAxKSB3aXRoXG4gICAgKCogZ2VuZXJhdGUgYW4gYXRvbSB1c2luZyB0aGUgZ2l2ZW4gc2l6ZSAqKVxuICAgIHwgMCAtPlxuICAgICAgbGV0JW1hcCBhdG9tID0gYXRvbSBpblxuICAgICAgU2V4cC5BdG9tIGF0b21cbiAgICAoKiByZWx5aW5nIG9uIFtMaXN0Lmdlbl0gdG8gZGlzdHJpYnV0ZSBbc2l6ZV0gb3ZlciBzdWItc2V4cHMgKilcbiAgICB8IF8gLT5cbiAgICAgIGxldCVtYXAgbGlzdCA9IGxpc3Qgc2VsZiBpblxuICAgICAgU2V4cC5MaXN0IGxpc3QpXG47O1xuXG5sZXQgc2V4cCA9IHNleHBfb2Ygc3RyaW5nXG5cbmxldCBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQlYmluZCBrZXlzID0gbGlzdCBrZXlfZ2VuIGluXG4gIGxldCBrZXlzID0gTGlzdC5kZWR1cF9hbmRfc29ydCBrZXlzIH5jb21wYXJlOmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gIGxldCViaW5kIGRhdGEgPSBsaXN0X3dpdGhfbGVuZ3RoIGRhdGFfZ2VuIH5sZW5ndGg6KExpc3QubGVuZ3RoIGtleXMpIGluXG4gIHJldHVybiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgKExpc3QuemlwX2V4biBrZXlzIGRhdGEpKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlbiA9XG4gIG1hcCAobGlzdCBlbHRfZ2VuKSB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9saXN0IH5jb21wYXJhdG9yKVxuOztcblxubGV0IGNvbXBhcmF0b3Jfb2ZfbVxuICAodHlwZSBhIGMpXG4gIChtb2R1bGUgTSA6IENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGEgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gYylcbiAgPVxuICBNLmNvbXBhcmF0b3Jcbjs7XG5cbmxldCBtYXBfdF9tIG0ga2V5X2dlbiBkYXRhX2dlbiA9XG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvcl9vZl9tIG0gaW5cbiAgbWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfZ2VuIGRhdGFfZ2VuXG4gIHw+IG1hcCB+ZjooTWFwLlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbjs7XG5cbmxldCBzZXRfdF9tIG0gZWx0X2dlbiA9XG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvcl9vZl9tIG0gaW5cbiAgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfZ2VuXG4gIHw+IG1hcCB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbjs7XG5cbmxldCBiaWdhcnJheTEgdCBraW5kIGxheW91dCB+bGVuZ3RoID1cbiAgbGV0JW1hcCBlbHRzID1cbiAgICBtYXRjaCBsZW5ndGggd2l0aFxuICAgIHwgTm9uZSAtPiBsaXN0IHRcbiAgICB8IFNvbWUgbGVuZ3RoIC0+IGxpc3Rfd2l0aF9sZW5ndGggdCB+bGVuZ3RoXG4gIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBkaW0gPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IGRpbSB+ZjooZnVuIGkgLT4gZWx0cy4oaSAtIG9mZnNldCkpXG47O1xuXG5sZXQgYmlnc3RyaW5nX2dlbiA9IGJpZ2FycmF5MSBjaGFyIENoYXIgQ19sYXlvdXRcbmxldCBmbG9hdDMyX3ZlY19nZW4gPSBiaWdhcnJheTEgZmxvYXQgRmxvYXQzMiBGb3J0cmFuX2xheW91dFxubGV0IGZsb2F0NjRfdmVjX2dlbiA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5sZXQgYmlnc3RyaW5nID0gYmlnc3RyaW5nX2dlbiB+bGVuZ3RoOk5vbmVcbmxldCBmbG9hdDMyX3ZlYyA9IGZsb2F0MzJfdmVjX2dlbiB+bGVuZ3RoOk5vbmVcbmxldCBmbG9hdDY0X3ZlYyA9IGZsb2F0NjRfdmVjX2dlbiB+bGVuZ3RoOk5vbmVcbmxldCBiaWdzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aCA9IGJpZ3N0cmluZ19nZW4gfmxlbmd0aDooU29tZSBsZW5ndGgpXG5sZXQgZmxvYXQzMl92ZWNfd2l0aF9sZW5ndGggfmxlbmd0aCA9IGZsb2F0MzJfdmVjX2dlbiB+bGVuZ3RoOihTb21lIGxlbmd0aClcbmxldCBmbG9hdDY0X3ZlY193aXRoX2xlbmd0aCB+bGVuZ3RoID0gZmxvYXQ2NF92ZWNfZ2VuIH5sZW5ndGg6KFNvbWUgbGVuZ3RoKVxuXG5sZXQgYmlnYXJyYXkyX2RpbSA9XG4gIG1hdGNoJWJpbmQgc2l6ZSB3aXRoXG4gIHwgMCAtPiByZXR1cm4gKDAsIDApXG4gIHwgbWF4X3RvdGFsX3NpemUgLT5cbiAgICBsZXQlYmluZCBhID1cbiAgICAgICgqIGNob29zZSBhIGRpbWVuc2lvbiB1cCB0byBbbWF4X3RvdGFsX3NpemVdLCB3ZWlnaHRlZCBsb3cgdG8gZ2l2ZSB0aGUgb3RoZXJcbiAgICAgICAgIGRpbWVuc2lvbiBhIGdvb2QgY2hhbmNlIG9mIGJlaW5nIGNvbXBhcmF0aXZlbHkgaGlnaCAqKVxuICAgICAgaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSAxIG1heF90b3RhbF9zaXplXG4gICAgaW5cbiAgICBsZXQlYmluZCBiID1cbiAgICAgICgqIGNob29zZSBhIGRpbWVuc2lvbiB1cCB0byBbbWF4X3RvdGFsX3NpemUgLyBhXSwgd2VpZ2h0ZWQgaGlnaCB0byByZWFjaCBjbG9zZSB0b1xuICAgICAgICAgW21heF90b3RhbF9zaXplXSBtb3N0IG9mIHRoZSB0aW1lICopXG4gICAgICBsZXQgbWF4X2IgPSBtYXhfdG90YWxfc2l6ZSAvIGEgaW5cbiAgICAgIGxldCVtYXAgYl93ZWlnaHRlZF9sb3cgPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgbWF4X2IgaW5cbiAgICAgIG1heF9iIC0gYl93ZWlnaHRlZF9sb3dcbiAgICBpblxuICAgICgqIGF2b2lkIGFueSBza2V3IG9mIGEgdnMgYiBieSByYW5kb21seSBzd2FwcGluZyAqKVxuICAgIGlmJW1hcCBib29sIHRoZW4gYSwgYiBlbHNlIGIsIGFcbjs7XG5cbmxldCBiaWdhcnJheTIgdCBraW5kIGxheW91dCA9XG4gIGxldCViaW5kIGRpbTEsIGRpbTIgPSBiaWdhcnJheTJfZGltIGluXG4gIGxldCVtYXAgZWx0cyA9IGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0xIChsaXN0X3dpdGhfbGVuZ3RoIH5sZW5ndGg6ZGltMiB0KSBpblxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3RfbWFwIH5mOkFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5pbml0IGtpbmQgbGF5b3V0IGRpbTEgZGltMiB+ZjooZnVuIGkgaiAtPlxuICAgIGVsdHMuKGkgLSBvZmZzZXQpLihqIC0gb2Zmc2V0KSlcbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDMyIEZvcnRyYW5fbGF5b3V0XG5sZXQgZmxvYXQ2NF9tYXQgPSBiaWdhcnJheTIgZmxvYXQgRmxvYXQ2NCBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgRGVidWcgPSBzdHJ1Y3RcbiAgbGV0IGNvdmVyYWdlXG4gICAgKHR5cGUgayBjbXApXG4gICAgKG1vZHVsZSBDbXAgOiBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICBzYW1wbGVcbiAgICA9XG4gICAgU2VxdWVuY2UuZm9sZFxuICAgICAgc2FtcGxlXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IChtb2R1bGUgQ21wKSlcbiAgICAgIH5mOihmdW4gY291bnRzIHZhbHVlIC0+XG4gICAgICAgIE1hcC51cGRhdGUgY291bnRzIHZhbHVlIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiAxXG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldiArIDEpKVxuICA7O1xuXG4gIGxldCBtb25pdG9yIHQgfmYgPVxuICAgIG1hcCB0IH5mOihmdW4gdmFsdWUgLT5cbiAgICAgIGYgdmFsdWU7XG4gICAgICB2YWx1ZSlcbiAgOztcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbG93ZXJfYm91bmQiLCJjc3Rfc3JjX2dlbmVyYXRvcl9tbCIsImNzdF91cHBlcl9ib3VuZCIsImNzdF93ZWlnaHQiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9kaXYiLCJjYW1sX2VxdWFsIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfbXVsIiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfb2JqX3RhZyIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiY2FtbF9jYWxsNiIsImE1IiwiZ2xvYmFsX2RhdGEiLCJCYXNlX01hcCIsIkJhc2VfU2VxdWVuY2UiLCJCYXNlX0FycmF5IiwiQmFzZV9xdWlja2NoZWNrX0JpZ2FycmF5X2hlbHBlIiwiQmFzZV9TZXQiLCJCYXNlX0xpc3QiLCJCYXNlX1N0cmluZyIsIkJhc2VfRmxvYXQiLCJTcGxpdHRhYmxlX3JhbmRvbSIsIkJhc2UiLCJTZXhwbGliMF9TZXhwX2NvbnYiLCJCYXNlX0ludDYzIiwiU3RkbGliIiwiQmFzZV9DaGFyIiwiQmFzZV9MYXp5IiwiQmFzZV9JbnQiLCJCYXNlX0VpdGhlciIsIkJhc2VfT3B0aW9uIiwiQXNzZXJ0X2ZhaWx1cmUiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9FcnJvciIsIkJhc2VfSGFzaCIsIkJhc2VfcXVpY2tjaGVja19PYnNlcnZlcjAiLCJCYXNlX1N0YWdlZCIsIkJhc2VfQXBwbGljYXRpdmUiLCJCYXNlX01vbmFkIiwiQmFzZV9JbnQzMiIsIkJhc2VfSW50NjQiLCJCYXNlX05hdGl2ZWludCIsIkJhc2VfQnl0ZXMiLCJjc3RfQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvcl8iLCJjcmVhdGUiLCJnZW5lcmF0ZSIsInQiLCJzaXplIiwicmFuZG9tIiwicGFyYW0iLCJmbiIsImRvbSIsInJuZyIsIngiLCJoYXNoIiwid2l0aF9zaXplIiwicGVydHVyYiIsInNhbHQiLCJmaWx0ZXJfbWFwIiwibG9vcCIsIm1hdGNoIiwieSIsImZpbHRlciIsInJldHVybiQiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwiRm9yX2FwcGxpY2F0aXZlIiwiYm90aCIsIm1hcDIiLCJtYXAzIiwiaW5jbHVkZSIsInN5bWJvbCIsIkZvcl9tb25hZCIsImlnbm9yZV9tIiwiam9pbiIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5Iiwic3VtIiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwicmVjX2xpc3QiLCJ3IiwibiIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsIm1pbl9sZW5ndGgiLCJtYXhfbGVuZ3RoIiwidXBwZXJfYm91bmQiLCJsZW4iLCJyZW1haW5pbmciLCJtYXhfaW5kZXgiLCJmb3IkIiwiaSIsImoiLCJ1bml0IiwiYm9vbCIsIm9wdGlvbiIsInZhbHVlX3QiLCJlaXRoZXIiLCJmc3RfdCIsInNuZF90IiwicmVzdWx0Iiwib2tfdCIsImVycl90Iiwib2siLCJlcnIiLCJsaXN0X2dlbmVyaWMiLCJlbHRfZ2VuIiwibGlzdF9ub25fZW1wdHkiLCJsaXN0X3dpdGhfbGVuZ3RoIiwibGVuZ3RoIiwibGlzdF9maWx0ZXJlZCIsImVsdHMiLCJsZW5ndGhfb2ZfaW5wdXQiLCJsZW5ndGhfb2Zfb3V0cHV0IiwiaW5kaWNlcyIsImxpc3RfcGVybXV0YXRpb25zIiwicmVmIiwiY2hhcl91bmlmb3JtX2luY2x1c2l2ZSIsImNoYXJfdXBwZXJjYXNlIiwiY2hhcl9sb3dlcmNhc2UiLCJjaGFyX2RpZ2l0IiwiY2hhcl9wcmludF91bmlmb3JtIiwiY2hhcl91bmlmb3JtIiwiY2hhcl9hbHBoYSIsImNoYXJfYWxwaGFudW0iLCJjaGFyX3doaXRlc3BhY2UiLCJjaGFyX3ByaW50IiwiY2hhciIsInNtYWxsX2ludCIsImFsbG93X3plcm8iLCJsb3dlcl9ib3VuZCIsIndlaWdodGVkX2xvdyIsIndlaWdodGVkX2hpZ2giLCJzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCIsInNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCIsImNzdF9nZW9tZXRyaWNfZGlzdHJpYnV0aW9uX3BfbSIsImR1bW15IiwiRm9yX2ludGVnZXIiLCJJbnRlZ2VyIiwiZ2VvbWV0cmljIiwicCIsImRlbm9taW5hdG9yIiwidW5pZm9ybSIsImV4cG9uZW50aWFsIiwiZmxvYXQiLCJpbnQiLCJleG4iLCJ0YWciLCJ1bmlmb3JtX2luY2x1c2l2ZSIsImxvZ191bmlmb3JtX2luY2x1c2l2ZSIsIm5vbl91bmlmb3JtIiwiaW5jbHVzaXZlIiwibG9nX2luY2x1c2l2ZSIsInVuaWZvcm1fYWxsIiwibGV0X3N5bnRheF8wMDQiLCJtYWduaXR1ZGUiLCJuZWdhdGl2ZSIsInRfc2V4cF9ncmFtbWFyIiwib2ZfZmxvYXQiLCJ0b19mbG9hdCIsIm9mX2ludF9leG4iLCJ0b19pbnRfZXhuIiwiaGFzaF9mb2xkX3QiLCJ0X29mX3NleHAiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJlcXVhbCIsImNvbXBhcmUiLCJtaW4iLCJtYXgiLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiYmV0d2VlbiIsImNsYW1wX2V4biIsImNsYW1wIiwiY29tcGFyYXRvciIsInBwIiwiaGFzaGFibGUiLCJpc19wb3NpdGl2ZSIsImlzX25vbl9uZWdhdGl2ZSIsImlzX25lZ2F0aXZlIiwiaXNfbm9uX3Bvc2l0aXZlIiwic2lnbiIsImNvbXBhcmVfbG9jYWwiLCJlcXVhbF9sb2NhbCIsImludmFyaWFudCIsIkhleCIsIkJpbmFyeSIsIm9mX3N0cmluZ19vcHQiLCJ0b19zdHJpbmdfaHVtIiwib25lIiwibWludXNfb25lIiwicmVtIiwicm91bmQiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJyb3VuZF9kb3duIiwicm91bmRfdXAiLCJyb3VuZF9uZWFyZXN0Iiwic3VjYyIsInByZWQiLCJwb3ciLCJiaXRfYW5kIiwiYml0X29yIiwiYml0X3hvciIsImJpdF9ub3QiLCJwb3Bjb3VudCIsInNoaWZ0X2xlZnQiLCJzaGlmdF9yaWdodCIsImRlY3IiLCJpbmNyIiwib2ZfaW50MzJfZXhuIiwidG9faW50MzJfZXhuIiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50X2V4biIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsIm51bV9iaXRzIiwibWF4X3ZhbHVlIiwibWluX3ZhbHVlIiwic2hpZnRfcmlnaHRfbG9naWNhbCIsImNlaWxfcG93MiIsImZsb29yX3BvdzIiLCJjZWlsX2xvZzIiLCJmbG9vcl9sb2cyIiwiaXNfcG93MiIsImNseiIsImN0eiIsIk8iLCJsbm90IiwiYWJzIiwiemVybyIsImxvZ191bmlmb3JtIiwiRm9yX2ludCIsImludF91bmlmb3JtIiwiaW50X2luY2x1c2l2ZSIsImludF91bmlmb3JtX2luY2x1c2l2ZSIsImludF9sb2dfaW5jbHVzaXZlIiwiaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludF9nZW9tZXRyaWMiLCJuZWciLCJsYW5kIiwibG9yIiwibHhvciIsImxzbCIsImFzciIsImxzciIsIkZvcl9pbnQzMiIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludDMyX2dlb21ldHJpYyIsIkZvcl9pbnQ2MyIsImludDYzIiwiaW50NjNfdW5pZm9ybSIsImludDYzX2luY2x1c2l2ZSIsImludDYzX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50NjNfbG9nX2luY2x1c2l2ZSIsImludDYzX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2dlb21ldHJpYyIsIkZvcl9pbnQ2NCIsImludDY0IiwiaW50NjRfdW5pZm9ybSIsImludDY0X2luY2x1c2l2ZSIsImludDY0X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50NjRfbG9nX2luY2x1c2l2ZSIsImludDY0X2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2dlb21ldHJpYyIsIkZvcl9uYXRpdmVpbnQiLCJuYXRpdmVpbnQiLCJuYXRpdmVpbnRfdW5pZm9ybSIsIm5hdGl2ZWludF9pbmNsdXNpdmUiLCJuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX2luY2x1c2l2ZSIsIm5hdGl2ZWludF9sb2dfdW5pZm9ybV9pbmNsdXNpdiIsIm5hdGl2ZWludF9nZW9tZXRyaWMiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X25vcm1hbF9tYW50aXNzYSIsImJpdHMiLCJvZmZzZXQiLCJmbG9hdF9leHBvbmVudCIsImZsb2F0X3plcm8iLCJsZXRfc3ludGF4XzAxMiIsImxldF9zeW50YXhfMDEzIiwiZmxvYXRfc3Vibm9ybWFsIiwibWFudGlzc2EiLCJleHBvbmVudCIsImZsb2F0X25vcm1hbCIsImZsb2F0X2luZmluaXRlIiwibGV0X3N5bnRheF8wMjEiLCJsZXRfc3ludGF4XzAyMiIsImZsb2F0X25hbiIsImZsb2F0X29mX2NsYXNzIiwiYyIsImZsb2F0X21hdGNoaW5nX2NsYXNzZXMiLCJmbG9hdF9maW5pdGUiLCJmbG9hdF93aXRob3V0X25hbiIsImZsb2F0X2Zpbml0ZV9ub25femVybyIsImZsb2F0X3N0cmljdGx5X3Bvc2l0aXZlIiwiZmxvYXRfc3RyaWN0bHlfbmVnYXRpdmUiLCJmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvIiwiZmxvYXRfbmVnYXRpdmVfb3JfemVybyIsImNzdF9GbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZV9ibyIsImNzdF9GbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZV9yZSIsImZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIiwibG93ZXJfaW5jbHVzaXZlIiwidXBwZXJfaW5jbHVzaXZlIiwiZmxvYXRfaW5jbHVzaXZlIiwic3RyaW5nX3dpdGhfbGVuZ3RoX29mIiwiY2hhcl9nZW4iLCJzdHJpbmdfb2YiLCJzdHJpbmdfbm9uX2VtcHR5X29mIiwic3RyaW5nIiwic3RyaW5nX25vbl9lbXB0eSIsInN0cmluZ193aXRoX2xlbmd0aCIsImVkaXRfaW5zZXJ0IiwicG9zIiwic3RyIiwiZWRpdCIsIm5fdGltZXMiLCJzdHJpbmdfbGlrZSIsImJ5dGVzIiwic2V4cF9vZiIsImF0b20iLCJzZXhwIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImtleV9nZW4iLCJkYXRhX2dlbiIsImtleXMiLCJkYXRhIiwic2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciIsIm1hcF90X20iLCJtIiwic2V0X3RfbSIsImJpZ2FycmF5MSIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJiaWdzdHJpbmciLCJmbG9hdDMyX3ZlYyIsImZsb2F0NjRfdmVjIiwiYmlnc3RyaW5nX3dpdGhfbGVuZ3RoIiwiZmxvYXQzMl92ZWNfd2l0aF9sZW5ndGgiLCJmbG9hdDY0X3ZlY193aXRoX2xlbmd0aCIsImJpZ2FycmF5Ml9kaW0iLCJtYXhfdG90YWxfc2l6ZSIsImEiLCJtYXhfYiIsImJfd2VpZ2h0ZWRfbG93IiwiYiIsImJpZ2FycmF5MiIsImRpbTIiLCJkaW0xIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImNvdmVyYWdlIiwiQ21wIiwic2FtcGxlIiwiY291bnRzIiwidmFsdWUiLCJwcmV2IiwibW9uaXRvciIsIkRlYnVnIiwiQmFzZV9xdWlja2NoZWNrX0dlbmVyYXRvciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMs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QUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsd0JEelU3RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUF6RixNQ3lVNkQ7QUFBQSxJQUFBMEYsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBbkYsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBNUksU0FBQTtBQUFB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QUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQTJCLFFBQUE7QUFBQSxJQUFBMUIsd0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBRSxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUosZUFBQTtBQUFBLElBQUFuRixZQUFBO0FBQUEsSUFBQTJGLGdCQUFBO0FBQUEsSUFBQXVCO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQTFHLG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQTVJLFNBQUE7QUFBQSxJQUFBNkksY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUF4TCxZQUFBO0FBQUEsSUFBQXlMLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUEzTCxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBaUcsWUFBQTtBQUFBLElBQUEyRixnQkFBQTtBQUFBLElBQUErQjtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQWxILG1CQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQTVJLFNBQUE7QUFBQSxJQUFBNkksY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUF6SCxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBMEgsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBMEMsU0FBQTtBQUFBLElBQUF6QyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFuSixZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQW9NLFFBQUE7QUFBQSxJQUFBcE0sWUFBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQSxZQUFBO0FBQUEsSUFBQUEsWUFBQTtBQUFBLElBQUFvSixRQUFBO0FBQUEsSUFBQXBKLFlBQUE7QUFBQSxJQUFBcU0sU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQWQsU0FBQTtBQUFBLElBQUFlLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQXBELFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBaUMsUUFBQTtBQUFBLElBQUFoQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUEyQixRQUFBO0FBQUEsSUFBQTFCLHdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBdkYsWUFBQTtBQUFBLElBQUEyRixnQkFBQTtBQUFBLElBQUF1QztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHNCQW9JbkM7QUFBQSxJQUFBQyxzQkFDQTtBQUFBLElBQUFDO0FBQUFBLE1BR3hCO0FBQUEsSUFBQUMsMkJBRzZCO0FBQUEsSUFBQUMsK0JBQ0k7QUFBQSxJQUFBQztBQUFBQSxNQUNBO0FBQUEsSUFBQUMsaUNBQXNEO0FBQUEsSUFBQUMsNEJBRXpEO0FBQUEsSUFBQUM7QUFBQUEsTUFDQTtBQUFBLElBQUFDO0FBQUFBLE1BQ0E7QUFBQSxJQUFBQyxxQkFDUDtBQUFBLElBQUFDLHFCQUNBO0FBQUEsSUFBQUMscUJBQ0E7QUFBQSxJQUFBQyx5QkFDSTtBQUFBLFFBT1A7QUFBQSxJQUFBQztBQUFBQSxNQUFwQjtBQUFBO0FBQUE7QUFBQSxpQkFBQTVFO0FBQUFBO0FBQUFBLFVBQUEsSUFFNkM7QUFBQSxjQUFaO0FBQUEsY0FBL0I7QUFBQSxTQUFpRjtBQUFBO0FBQUE7QUFBQSwyQkFBQTZFO0FBQUFBLG1CQUVuRix5REFBa0U7QUFBQTtBQUFBO0FBQUEsSUFBQXJLLGNBZW5EO0FBQUEsUUFYRTtBQUFBO0FBQUEsTUFBMkQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFBQXNLLFFBQzVFLGdDQUE0QjtBQUFBO0FBQUEsUUFJWDtBQUFBLElBQUFDO0FBQUFBLE1BT2pCO0FBQUE7QUFBQSxTQVA0RTtBQUFBO0FBQUE7QUFBQSxvQkFBQUQsUUFDNUUsZ0NBQTRCO0FBQUE7QUFBQSxJQUFBRTtBQUFBQSxNQWE1QjtBQUFBO0FBQUE7QUFBQSxpQkFBQTlJO0FBQUFBLFNBQ0E7QUFBQSwyRUFHK0I7QUFBQTtBQUFBLElBQUErSSxpQkFLaEI7QUFBQSxJQUFBQztBQUFBQSxNQUViO0FBQUE7QUFBQSxRQUZhO0FBQUEsUUFESTtBQUFBLElBQUFDO0FBQUFBLE1BQW5CO0FBQUE7QUFBQTtBQUFBLGlCQUFBNVI7QUFBQUE7QUFBQUEsVUFBQVcsUUFBQTtBQUFBLFVBQUFrUixXQUFBO0FBQUEsVUFBQUMsV0FBQTtBQUFBLFVBQUFuSixXQUFBO0FBQUEsU0FLQSwrREFBbUQ7QUFBQTtBQUFBLFFBS3BDO0FBQUEsUUFESTtBQUFBLElBQUFvSjtBQUFBQSxNQUFuQjtBQUFBO0FBQUE7QUFBQSxpQkFBQS9SO0FBQUFBO0FBQUFBLFVBQUFXLFFBQUE7QUFBQSxVQUFBa1IsV0FBQTtBQUFBLFVBQUFDLFdBQUE7QUFBQSxVQUFBbkosV0FBQTtBQUFBLFNBR0EsK0RBQW1EO0FBQUE7QUFBQSxJQUFBcUo7QUFBQUEsTUFJbkQ7QUFBQTtBQUFBO0FBQUEsaUJBQUFySjtBQUFBQSxTQUNBO0FBQUEseUVBRzhCO0FBQUE7QUFBQSxJQUFBc0osaUJBS2Y7QUFBQSxJQUFBQztBQUFBQSxNQUNBO0FBQUE7QUFBQSxRQURBO0FBQUEsUUFESTtBQUFBLElBQUFDO0FBQUFBLE1BQW5CO0FBQUE7QUFBQTtBQUFBLGlCQUFBblM7QUFBQUE7QUFBQUEsVUFBQVcsUUFBQTtBQUFBLFVBQUFrUixXQUFBO0FBQUEsVUFBQUMsV0FBQTtBQUFBLFVBQUFuSixXQUFBO0FBQUEsU0FHQSwrREFBbUQ7QUFBQTtBQUFBLFlBQUF5SixlQUFBQztBQUFBQSxJQUluRDtBQUFBO0FBQUEsT0FJYztBQUFBO0FBQUEsT0FDTDtBQUFBO0FBQUEsT0FGRztBQUFBO0FBQUEsT0FERztBQUFBLGVBREw7QUFBQTtBQUFBLEdBSVE7QUFBQSxZQUFBQyx1QkFBQXpSO0FBQUFBLElBYWxCLE9BQzhFO0FBQUEsYUFEOUU7QUFBQTtBQUFBO0FBQUEsd0JBQUF3UjtBQUFBQSxnQkFDSyw0QkFBb0U7QUFBQSx3QkFBdkI7QUFBQSxnQkFWbEQ7QUFBQTtBQUFBLDJCQUdZO0FBQUE7QUFBQSwyQkFERztBQUFBLG1DQUZmO0FBQUE7QUFBQSxnQkFVZ0Q7QUFBQSxlQUE2QixHQUM1RDtBQUFBO0FBQUE7QUFBQSxJQUFBRTtBQUFBQSxNQUlqQixnQ0FBQXZTLE9BQXVCLHlCQUVLO0FBQUEsSUFBQXdTO0FBQUFBLE1BSTVCLGdDQUFBeFMsT0FBdUIsMEJBRU47QUFBQSxJQUFBK0gsUUFHUCxnQ0FBQS9ILE9BQWlDLFNBQUk7QUFBQSxJQUFBeVM7QUFBQUEsTUFHL0M7QUFBQSxpQkFBQXpTLE9BQXVCLGtDQUVZO0FBQUEsSUFBQTBTO0FBQUFBLE1BSW5DO0FBQUE7QUFBQTtBQUFBLGlCQUFBN1MsR0FDQSxtQ0FBVztBQUFBLElBQUE4UztBQUFBQSxNQUlYO0FBQUE7QUFBQTtBQUFBLGlCQUFBOVM7QUFBQUEsYUFBQSxJQUNHO0FBQUEsU0FBYTtBQUFBO0FBQUEsSUFBQStTO0FBQUFBLE1BSWhCO0FBQUE7QUFBQTtBQUFBLGlCQUFBL1MsR0FDQSxtQ0FBVztBQUFBLElBQUFnVDtBQUFBQSxNQUlYO0FBQUE7QUFBQTtBQUFBLGlCQUFBaFQ7QUFBQUEsYUFBQSxJQUNHO0FBQUEsU0FBYTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFpVDtBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyx3QkFBQS9MLGFBQUE1QztBQUFBQTtBQUFBQSxLQUFBLElBS1I7QUFBQSxTQUE2QixTQUFTO0FBQUEsSUFBVDtBQUFBO0FBQUEsVUFNN0I7QUFBQSxVQURBO0FBQUE7QUFBQSxRQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FGSjtBQUFBO0FBQUE7QUFBQSxLQUFBNE8sa0JBS29CO0FBQUEsS0FBQUMsa0JBQ0E7QUFBQSxJQUNuQjtBQUFBO0FBQUEsVUFNSztBQUFBLFVBREE7QUFBQTtBQUFBLFFBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUZKO0FBQUE7QUFBQSxJQUtGO0FBQUEsc0JBQUFsVCxPQUFBRDtBQUFBQSxjQUNFO0FBQUEsc0VBQXNFO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQW9ULGdCQUFBbE0sYUFBQTVDO0FBQUFBLElBSXpFO0FBQUEsS0FDSyxnREFRQTtBQUFBLElBUGU7QUFBQSxhQUNhO0FBQUEsS0FBcEIsT0FBa0IsVUFBbEIsOENBTVI7QUFBQTtBQUFBO0FBQUEsU0FETTtBQUFBLFNBREM7QUFBQSxJQURBLE9BQWtCO0FBQUEsMkJBQWxCLCtDQUdQO0FBQUE7QUFBQSxZQUFBK08sc0JBQUFDLFVBQUF6TjtBQUFBQSxRQUFBLElBSUw7QUFBQSxJQUFpQywrQkFBOEI7QUFBQTtBQUFBLFlBQUEwTixVQUFBRDtBQUFBQSxJQUkvRDtBQUFBO0FBQUEsc0JBQUF6TixRQUNFLDhDQUFzQyxHQUFDO0FBQUE7QUFBQSxZQUFBMk4sb0JBQUFGO0FBQUFBLElBSXpDO0FBQUE7QUFBQSxzQkFBQXpOLFFBQ0UsOENBQXNDLEdBQUM7QUFBQTtBQUFBLE9BQUE0TixTQUc5QixpQkFBQUMsbUJBQ1U7QUFBQSxZQUFBQyxtQkFBQTlOO0FBQUFBLElBQ1UsMENBQWtDO0FBQUE7QUFBQSxZQUFBK04sWUFBQUg7QUFBQUEsUUFBQSxJQUloRCx5QkFBZjtBQUFBLElBQTZEO0FBQUE7QUFBQTtBQUFBLHNCQUFBSTtBQUFBQSxrQkFBQSxJQUM5QztBQUFBLGNBQXNCO0FBQUE7QUFBQTtBQUFBLGdDQUFBaE87QUFBQUEsNEJBQUEsSUFMUjtBQUFBLHdCQU1nQjtBQUFBO0FBQUE7QUFBQSwwQ0FBQWlPO0FBQUFBO0FBQUFBLG1DQUFBO0FBQUEscUNBQ1o7QUFBQSx1Q0FBL0I7QUFBQSx1Q0FBRjtBQUFBLGtDQUNnQixzQ0FDUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsS0FBQU4sUUFBQU87QUFBQUEsSUFrQ1QsaUJBQ0ssMkNBS3VCO0FBQUEsZUFBQVAsUUFBMUIsb0NBQXlCO0FBQUEsSUFGcEI7QUFBQSxhQUE0QjtBQUFBO0FBQUE7QUFBQSxVQWpCcEIsNkJBQWY7QUFBQTtBQUFBLFFBQWlFO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBQUFsUDtBQUFBQTtBQUFBQSxhQUFBO0FBQUEsZUFDbEQ7QUFBQSxvQkFBZjtBQUFBLFlBQW1FO0FBQUE7QUFBQTtBQUFBLDhCQUFBc1A7QUFBQUE7QUFBQUEsdUJBQUEsSUFDL0I7QUFBQTtBQUFBLHlCQUFsQztBQUFBLDJCQUFGO0FBQUEsc0JBQ2dCLHNDQUNQO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFiTSw2QkFBZjtBQUFBO0FBQUEsUUFBaUU7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFBQWhPO0FBQUFBO0FBQUFBLGFBQUE7QUFBQSxlQUNsRDtBQUFBLG9CQUFmO0FBQUEsWUFBbUU7QUFBQTtBQUFBO0FBQUEsOEJBQUFnTztBQUFBQSwwQkFBQSxJQXRCdEM7QUFBQSxzQkF1QmdCO0FBQUE7QUFBQTtBQUFBLHdDQUFBQztBQUFBQTtBQUFBQSxpQ0FBQTtBQUFBLG1DQUNaO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQ0FBL0I7QUFBQSxxQ0FBRjtBQUFBLGdDQUNnQixzQ0FDUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFiTSw2QkFBZjtBQUFBO0FBQUEsUUFBaUU7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFBQXZQO0FBQUFBO0FBQUFBLGFBQUE7QUFBQSxlQUNsRDtBQUFBLG9CQUFmO0FBQUEsWUFBbUU7QUFBQTtBQUFBO0FBQUEsOEJBQUFzUDtBQUFBQTtBQUFBQSx1QkFBQTtBQUFBLHlCQUN2QztBQUFBLDJCQUExQjtBQUFBLDJCQUFGO0FBQUEsc0JBQ2dCLHNDQUNQO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFxQlcsVUFBbEI7QUFBQSxJQVMyQiw0Q0FFRDtBQUFBO0FBQUEsWUFBQUksWUFBQVI7QUFBQUEsUUFBQSxJQUtYO0FBQUEsSUFBc0I7QUFBQTtBQUFBO0FBQUEsc0JBQUFPLFNBQ3pDLDRCQUErQjtBQUFBO0FBQUEsT0FBQUUsUUFHckI7QUFBQSxZQUFBQyxRQUFBQztBQUFBQSxJQUdWO0FBQUEsc0JBQUExUTtBQUFBQSxjQUNFO0FBQUE7QUFBQTtBQUFBLGdDQUFBM0Q7QUFBQUEsNEJBQUEsSUFHVztBQUFBLHdCQUEwQztBQUFBO0FBQUE7QUFBQSwwQ0FBQUU7QUFBQUEsa0NBQXJEO0FBQUEsbUNBR0U7QUFBQTtBQUFBO0FBQUEscURBQUFtVSxNQUNBLGlCQUFjLEVBSUE7QUFBQSwwQ0FEQztBQUFBLGtDQUFTO0FBQUEsNEVBQUE5UyxNQUN4QixpQkFBYztBQUFBO0FBQUE7QUFBQSxlQUFDO0FBQUE7QUFBQSxPQUFBK1MsT0FHVjtBQUFBLFlBQUFDLDBCQUFBdEssWUFBQXVLLFNBQUFDO0FBQUFBLFFBQUEsSUFHTztBQUFBLElBQVk7QUFBQTtBQUFBO0FBQUEsc0JBQUFDO0FBQUFBO0FBQUFBLGVBQUFBLFNBQ2pCO0FBQUE7QUFBQSxpQkFDSywyQkFBa0M7QUFBQSxjQUFrQjtBQUFBO0FBQUE7QUFBQSxnQ0FBQUM7QUFBQUE7QUFBQUEseUJBQUEsSUFDVDtBQUFBLDZCQUFwRDtBQUFBLHdCQUE2RTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLDBCQUFBM0ssWUFBQXRFO0FBQUFBLFFBQUEsSUFJOUQ7QUFBQSxJQUFsQixPQUFjLElBQWQsaUJBQWlFO0FBQUE7QUFBQSxZQUFBa1AsUUFBQUMsR0FBQU4sU0FBQUM7QUFBQUE7QUFBQUEsS0FBQXhLLGFBT3JFO0FBQUEsU0FLQTtBQUFBLElBQ1UsT0FBMEMsT0FBMUMsMENBQTBDO0FBQUE7QUFBQSxZQUFBOEssUUFBQUQsR0FBQW5QO0FBQUFBLFFBQUFzRSxhQU5wRCxVQVdBO0FBQUEsSUFDVSxPQUEwQyxPQUExQyx5Q0FBMEM7QUFBQTtBQUFBLFlBQUErSyxVQUFBalYsR0FBQWtWLE1BQUFDLFFBQUFwUDtBQUFBQSxhQUFBLEVBQUFFO0FBQUFBO0FBQUFBLE1BQUFBLFNBU3pDO0FBQUEsTUFBQW1QLE1BQ1g7QUFBQSxNQUFBMUQsU0FDYTtBQUFBLEtBQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUFBN007QUFBQUEsbUJBQUEsSUFBMEQ7QUFBQSx3REFBaUI7QUFBQSxnQkFBQztBQUFBO0FBQUEsSUFSNUU7QUFBQSxTQUFBa0IsV0FBQSxlQUdtQjtBQUFBO0FBQUEsYUFEUDtBQUFBLElBRlosNENBUTRFO0FBQUE7QUFBQTtBQUFBLFFBekNyRDtBQUFBO0FBQUEsUUE0Q3VCO0FBQUE7QUFBQSxRQUNZO0FBQUE7QUFBQSxJQUFBc1AsWUFEeEM7QUFBQSxJQUFBQyxjQUNFO0FBQUEsSUFBQUMsY0FDQTtBQUFBLFFBR3dCO0FBQUEsWUFBQUMsc0JBQUF6UDtBQUFBQSxJQUwxQix5Q0FNbUQ7QUFBQTtBQUFBLFlBQUEwUCx3QkFBQTFQO0FBQUFBLElBTGpELDBDQU1xRDtBQUFBO0FBQUEsWUFBQTJQLHdCQUFBM1A7QUFBQUEsSUFMckQsMENBTXFEO0FBQUE7QUFBQTtBQUFBLElBQUE0UDtBQUFBQSxNQUd6RTtBQUFBO0FBQUE7QUFBQSxpQkFBQUM7QUFBQUEsU0FBQSx5QkFDTyxzQ0FlMEI7QUFBQSxpQkFWN0I7QUFBQSxTQUEwQztBQUFBO0FBQUE7QUFBQSwyQkFBQUM7QUFBQUE7QUFBQUEsb0JBQUFDLFFBRTVDO0FBQUEsd0JBSTJCO0FBQUE7QUFBQSxzQkFBekI7QUFBQTtBQUFBO0FBQUEsaUNBQUFDLGdCQUNBLGtDQUFzQjtBQUFBO0FBQUE7QUFBQTtBQUFBLHFDQUFBQztBQUFBQSw2QkFHeEI7QUFBQTtBQUFBO0FBQUEsK0NBQUE3VixPQUFBLG9DQUErQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUE4VixVQUFBalcsR0FBQWtWLE1BQUFDO0FBQUFBLElBSWpDO0FBQUE7QUFBQTtBQUFBLHNCQUFBaFY7QUFBQUE7QUFBQUEsZUFBQStWLE9BQUE7QUFBQSxlQUFBQyxPQUFBO0FBQUEsbUJBQ2UsaUJBQThCO0FBQUEsY0FBaUM7QUFBQTtBQUFBO0FBQUEsZ0NBQUFsUTtBQUFBQTtBQUFBQSx5QkFBQUEsU0FDbkU7QUFBQSx5QkFBQXlMO0FBQUFBLDJCQUNFO0FBQUEsd0JBQ2I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQUE3TSxHQUFBQztBQUFBQSxzQ0FBQSxJQUNFO0FBQUE7QUFBQTtBQUFBLGlEQUE4QjtBQUFBLG1DQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBc1IsY0FHakI7QUFBQSxJQUFBQyxjQUNBO0FBQUEsWUFBQUMsU0FBQUMsS0FBQUM7QUFBQUEsUUFBQSxJQVVOO0FBQUEsSUFBd0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUMsUUFBQUM7QUFBQUEsY0FFNUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQ0FBQXZXO0FBQUFBLHdCQUEyQixZQUNmO0FBQUEsNEJBQUF3VyxPQURlO0FBQUEsd0JBRVY7QUFBQSx1QkFBUztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFDLFFBQUE1VyxHQUFBOUM7QUFBQUEsSUFJL0IsdUJBQUF3WixPQUNFLHNCQUFPLGFBQ0YsRUFBQztBQUFBO0FBQUE7QUFBQSxJQUFBRyxRQXBCNEM7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR6ekJ4RCIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3MzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZHMvRG9jdW1lbnRzL3BhdGNod29yay9fb3BhbS9saWIvYmFzZV9xdWlja2NoZWNrL3Nocmlua2VyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgVCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYXRvbWljIDogXyB0XG4gIHZhbCBjcmVhdGUgOiAoJ2EgLT4gJ2EgU2VxdWVuY2UudCkgLT4gJ2EgdFxuICB2YWwgc2hyaW5rIDogJ2EgdCAtPiAnYSAtPiAnYSBTZXF1ZW5jZS50XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIGxldCBhdG9taWMgXyA9IFNlcXVlbmNlLmVtcHR5XG4gIGxldCBjcmVhdGUgPSBGbi5pZFxuICBsZXQgc2hyaW5rID0gRm4uaWRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IG1hcCB0IH5mIH5mX2ludmVyc2UgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLm1hcCB+ZiAoc2hyaW5rIHQgKGZfaW52ZXJzZSB4KSkpXG5sZXQgZmlsdGVyIHQgfmYgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLmZpbHRlciB+ZiAoc2hyaW5rIHQgeCkpXG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgfmZfaW52ZXJzZSA9XG4gIGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyX21hcCB+ZiAoc2hyaW5rIHQgKGZfaW52ZXJzZSB4KSkpXG47O1xuXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLm9mX2xhenkgKGxhenkgKHNocmluayAoZm9yY2UgbGF6eV90KSB4KSkpXG5cbmxldCBmaXhlZF9wb2ludCBvZl9zaHJpbmtlciA9XG4gIGxldCByZWMgbGF6eV90ID0gbGF6eSAob2Zfc2hyaW5rZXIgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSAtPlxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICBbIFNlcXVlbmNlLm1hcCAoc2hyaW5rIGZzdF90IGZzdCkgfmY6KGZ1biBmc3QgLT4gZnN0LCBzbmQpXG4gICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIHNuZF90IHNuZCkgfmY6KGZ1biBzbmQgLT4gZnN0LCBzbmQpXG4gICAgICBdKVxuOztcblxubGV0IHVuaXQgPSBhdG9taWNcbmxldCBib29sID0gYXRvbWljXG5sZXQgY2hhciA9IGF0b21pY1xubGV0IGludCA9IGF0b21pY1xubGV0IGludDMyID0gYXRvbWljXG5sZXQgaW50NjMgPSBhdG9taWNcbmxldCBpbnQ2NCA9IGF0b21pY1xubGV0IG5hdGl2ZWludCA9IGF0b21pY1xubGV0IGZsb2F0ID0gYXRvbWljXG5cbmxldCBiaWdhcnJheTEgc3JjID1cbiAgbGV0IGRpbSA9IEJpZ2FycmF5LkFycmF5MS5kaW0gc3JjIGluXG4gIG1hdGNoIGRpbSB3aXRoXG4gIHwgMCAtPiBTZXF1ZW5jZS5lbXB0eVxuICB8IF8gLT5cbiAgICBsZXQga2luZCA9IEJpZ2FycmF5LkFycmF5MS5raW5kIHNyYyBpblxuICAgIGxldCBsYXlvdXQgPSBCaWdhcnJheS5BcnJheTEubGF5b3V0IHNyYyBpblxuICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgU2VxdWVuY2UuaW5pdCBkaW0gfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICBsZXQgdG9fc2tpcCA9IHRvX3NraXAgKyBvZmZzZXQgaW5cbiAgICAgIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmluaXQga2luZCBsYXlvdXQgKGRpbSAtIDEpIH5mOihmdW4gaSAtPlxuICAgICAgICBzcmMue2lmIGkgPCB0b19za2lwIHRoZW4gaSBlbHNlIGkgKyAxfSkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gY3JlYXRlIGJpZ2FycmF5MVxubGV0IGZsb2F0MzJfdmVjID0gY3JlYXRlIGJpZ2FycmF5MVxubGV0IGZsb2F0NjRfdmVjID0gY3JlYXRlIGJpZ2FycmF5MVxuXG5sZXQgYmlnYXJyYXkyID1cbiAgbGV0IG1vZHVsZSBEaW1zID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgZGltMSA6IGludFxuICAgICAgOyBkaW0yIDogaW50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzIH5maWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPiBTb21lIChTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLmFkZCB0cmVlIH5jb21wYXJhdG9yIHNtYWxsZXJfZWx0KSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2VsdHM7IHNocmlua19lbHRzIF0pXG47O1xuXG5sZXQgbWFwX3Qga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gbWFwX3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG1hcF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV90IGRhdGFfdClcbiAgICAgICAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5mX2ludmVyc2U6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuICAgIGluXG4gICAgc2hyaW5rIHQgbWFwX3QpXG47O1xuXG5sZXQgc2V0X3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBzZXRfdCAtPlxuICAgIGxldCBjb21wYXJhdG9yID0gU2V0LmNvbXBhcmF0b3Igc2V0X3QgaW5cbiAgICBsZXQgdCA9XG4gICAgICBtYXBcbiAgICAgICAgKHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QpXG4gICAgICAgIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IHNldF90KVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9iYV9kaW1fMSIsImNhbWxfYmFfa2luZCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiQmFzZV9TZXQiLCJCYXNlX01hcCIsIkJhc2VfU2VxdWVuY2UiLCJCYXNlX0xpc3QiLCJCYXNlX0VpdGhlciIsIkNhbWxpbnRlcm5hbExhenkiLCJCYXNlX0xhenkiLCJCYXNlX0FycmF5IiwiQmFzZV9PcHRpb24iLCJCYXNlX0ZpZWxkIiwiQmFzZV9xdWlja2NoZWNrX0JpZ2FycmF5X2hlbHBlIiwiQmFzZV9JbnQiLCJCYXNlX1N0cmluZyIsIkJhc2VfQnl0ZXMiLCJhdG9taWMiLCJwYXJhbSIsImNyZWF0ZSIsInNocmluayIsIm1hcCIsInQiLCJmX2ludmVyc2UiLCJ4IiwiZmlsdGVyIiwiZmlsdGVyX21hcCIsIm9mX2xhenkiLCJsYXp5X3QiLCJmaXhlZF9wb2ludCIsIm9mX3Nocmlua2VyIiwiYm90aCIsImZzdF90Iiwic25kX3QiLCJzbmQiLCJmc3QiLCJmbG9hdDMyX3ZlYyIsInNyYyIsImRpbSIsImtpbmQiLCJsYXlvdXQiLCJvZmZzZXQiLCJ0b19za2lwIiwiaSIsImRpbTIiLCJyIiwiZGltMSIsInYiLCJmaWVsZCIsImRpbXMiLCJtYXRjaCIsInNraXAiLCJmbG9hdDMyX21hdCIsIm9wdGlvbiIsInZhbHVlX3QiLCJ2YWx1ZSIsImxpc3QiLCJlbHRfdCIsImxpc3RfdCIsInRhaWwiLCJoZWFkIiwic3RyaW5nIiwiYnl0ZXMiLCJhcnJheSIsInJlZiIsInNleHAiLCJzaHJpbmtlciIsImwiLCJzaHJpbmtfbGlzdCIsInNocmlua190cmVlIiwiZWl0aGVyIiwicmVzdWx0Iiwib2tfdCIsImVycl90Iiwib2siLCJlcnIiLCJtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIiwiY29tcGFyYXRvciIsImtleV90IiwiZGF0YV90IiwidHJlZSIsImFsaXN0IiwiZHJvcF9rZXlzIiwiayIsImRhdGEiLCJrZXkiLCJzbWFsbGVyX2tleSIsInNocmlua19rZXlzIiwic21hbGxlcl9kYXRhIiwic2hyaW5rX2RhdGEiLCJzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIiwiZHJvcF9lbHRzIiwiZWx0Iiwic21hbGxlcl9lbHQiLCJzaHJpbmtfZWx0cyIsIm1hcF90Iiwic2V0X3QiLCJCYXNlX3F1aWNrY2hlY2tfU2hyaW5rZXIiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEs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QUF2RCxJQUZMLElBQ0U7QUFBQSxLQUlKLGVBQWMsRUFSaEI7QUFBQSxHQVFpQjtBQUFBO0FBQUEsSUFBQTJFO0FBQUFBLE1BeEZ3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQxSTNEIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzE4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZV9xdWlja2NoZWNrX1Rlc3RfaW50ZiJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLDRCQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzE5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9iYXNlX3F1aWNrY2hlY2svdGVzdC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgVGVzdF9pbnRmXG5cbm1vZHVsZSBDb25maWcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBOb25kZXRlcm1pbmlzdGljXG4gICAgICB8IERldGVybWluaXN0aWMgb2Ygc3RyaW5nXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbW9kdWxlIFBvdGVudGlhbGx5X2luZmluaXRlX3NlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBzZXF1ZW5jZSA9XG4gICAgICBsZXQgcHJlZml4LCBzdWZmaXggPSBTZXF1ZW5jZS5zcGxpdF9uIHNlcXVlbmNlIDEwMCBpblxuICAgICAgbGV0IHByZWZpeCA9IExpc3QubWFwIHByZWZpeCB+ZjpzZXhwX29mX2VsdCBpblxuICAgICAgbGV0IHN1ZmZpeCA9XG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLmlzX2VtcHR5IHN1ZmZpeCB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBbXVxuICAgICAgICB8IGZhbHNlIC0+IFsgWyVtZXNzYWdlIFwiLi4uXCJdIF1cbiAgICAgIGluXG4gICAgICBTZXhwLkxpc3QgKHByZWZpeCBAIHN1ZmZpeClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgc2VlZCA6IFNlZWQudFxuICAgIDsgdGVzdF9jb3VudCA6IGludFxuICAgIDsgc2hyaW5rX2NvdW50IDogaW50XG4gICAgOyBzaXplcyA6IGludCBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBfb2ZdXG5lbmRcblxubGV0IGRlZmF1bHRfY29uZmlnIDogQ29uZmlnLnQgPVxuICB7IHNlZWQgPSBEZXRlcm1pbmlzdGljIFwiYW4gYXJiaXRyYXJ5IGJ1dCBkZXRlcm1pbmlzdGljIHN0cmluZ1wiXG4gIDsgdGVzdF9jb3VudCA9XG4gICAgICAoKiBbU3BsaXR0YWJsZV9yYW5kb21dIGlzIGJhc2VkIG9uIDY0LWJpdCBhcml0aG1ldGljLCBhbmQgc28gdGVzdHMgcnVuIG11Y2ggc2xvd2VyXG4gICAgICAgICBvbiAzMi1iaXQgdGFyZ2V0cy4gV2UgcnVuIGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBmZXdlciB0cmlhbHMgc28gYXMgbm90IHRvXG4gICAgICAgICBjb21wbGV0ZWx5IGJvZyBkb3duIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gc3lzdGVtcy4gKilcbiAgICAgIChtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICAgICB8IFc2NCAtPiAxMF8wMDBcbiAgICAgICB8IFczMiAtPiAxXzAwMClcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X3Rlc3RfY291bnQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJCYXNlX0JhY2t0cmFjZSIsIkJhc2VfT3JfZXJyb3IiLCJCYXNlX0Vycm9yIiwiU2V4cGxpYjBfU2V4cF9jb252IiwiQmFzZV9TZXF1ZW5jZSIsIkJhc2VfcXVpY2tjaGVja19HZW5lcmF0b3IiLCJCYXNlX3F1aWNrY2hlY2tfU2hyaW5rZXIiLCJCYXNlIiwiU3BsaXR0YWJsZV9yYW5kb20iLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9SYW5kb20iLCJCYXNlX0xpc3QiLCJCYXNlX1dvcmRfc2l6ZSIsInNleHBfb2ZfdCIsInBhcmFtIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsIlNlZWQiLCJzaXplc18wMTAiLCJzaHJpbmtfY291bnRfMDA4IiwidGVzdF9jb3VudF8wMDYiLCJzZWVkXzAwNCIsInNleHBfb2ZfZWx0IiwibWF0Y2giLCJzdWZmaXgiLCJwcmVmaXgiLCJibmRzXzAwMyIsImFyZ18wMTEiLCJhcmdfMDA5IiwiYXJnXzAwNyIsImFyZ18wMDUiLCJjc3RfQmFzZV9xdWlja2NoZWNrX1Rlc3RfcnVuX3QiLCJjc3RfQmFzZV9xdWlja2NoZWNrX1Rlc3RfcnVuX2kiLCJkZWZhdWx0X2NvbmZpZyIsImxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSIsIndpdGhfc2FtcGxlIiwib3B0IiwiZ2VuZXJhdG9yIiwiY29uZmlnIiwiZXhhbXBsZXMiLCJzdHJpbmciLCJyYW5kb20iLCJudW1iZXJfb2Zfc2l6ZV92YWx1ZXMiLCJzaXplcyIsInJlbWFpbmluZ19zaXplcyIsInNpemUiLCJzZXF1ZW5jZSIsInJlc3VsdCIsIm0iLCJpbnB1dCIsImVycm9yIiwic2hyaW5rZXIiLCJzaHJpbmtfY291bnQiLCJhbHRlcm5hdGVzIiwiYWx0ZXJuYXRlIiwicnVuIiwiTSIsIngiLCJ3aXRoX3NhbXBsZV9leG4iLCJydW5fZXhuIiwidGVzdGFibGUiLCJCYXNlX3F1aWNrY2hlY2tfVGVzdCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGlCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxVQUFBQztBQUFBQSxJQ0tJLFlBQ0U7QUFBQSxRQUFBQyxXQURGLFVBQUFDLFdBRUU7QUFBQTtBQUFBLEdBQ2tCO0FBQUE7QUFBQSxJQUFBQyxPRFJ4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUosWUFBQUM7QUFBQUE7QUFBQUEsS0FBQUksWUMwQkU7QUFBQSxLQUFBQyxtQkFB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QUFBQUEsb0JBR0U7QUFBQTtBQUFBO0FBQUEsaUJBQ2pCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFpQ047QUFBQTtBQUFBLGFBQW9CO0FBQUE7QUFBQTtBQUFBLGtCQUFDO0FBQUE7QUFBQSxZQUFBRSxJQUFBN0QsR0FBQTRDLFFBQUFDLFVBQUFpQjtBQUFBQSxhQUFBOUQsSUFBQStEO0FBQUFBLFNBQUEsSUFLVztBQUFBLEtBQStCO0FBQUEsZ0NBQUEzQyxPQUFZLHVCQUFHLEdBQUM7QUFBQTtBQUFBLFFBQUFTLFFBRTdFO0FBQUEsSUFBc0MsbUJBQ2pDO0FBQUE7QUFBQSxLQUFBQSxVQURpQztBQUFBLEtBQUEyQixRQUFBO0FBQUEsS0FBQUQsUUFBQTtBQUFBLFNBSXdCO0FBQUEsU0FBZDtBQUFBO0FBQUEsT0FBeEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUF1RSxzQ0FBQztBQUFBO0FBQUEsWUFBQVMsZ0JBQUFoRSxHQUFBNEMsUUFBQUMsVUFBQUY7QUFBQUEsYUFBQTNDLElBQUErRDtBQUFBQSxLQUk1RTtBQUFBLGdDQUFBM0MsT0FBNkIsdUJBQUcsR0FBQztBQUFBO0FBQUEsWUFDM0M7QUFBQSxJQUEwQyxzQ0FBbUI7QUFBQTtBQUFBLFlBQUE2QyxRQUFBakUsR0FBQTRDLFFBQUFDLFVBQUFxQjtBQUFBQSxhQUFBbEUsSUFBQStEO0FBQUFBLFNBQUEsSUFLOUI7QUFBQSxLQUErQjtBQUFBLGdDQUFBM0MsT0FBWSx1QkFBRyxHQUFDO0FBQUE7QUFBQSxZQUU5RTtBQUFBLElBQWlDLHNDQUFtQjtBQUFBO0FBQUE7QUFBQSxJQUFBK0M7QUFBQUEsTUFqR2tDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDdDeEYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozNDc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2VfcXVpY2tjaGVjay5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfb2JqX3RhZyIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkJhc2VfU2V0IiwiQmFzZV9NYXAiLCJCYXNlX3F1aWNrY2hlY2tfR2VuZXJhdG9yIiwiQmFzZV9IYXNoIiwiU3BsaXR0YWJsZV9yYW5kb20iLCJCYXNlX0xpc3QiLCJDYW1saW50ZXJuYWxMYXp5IiwiQmFzZV9BcnJheSIsIkJhc2UiLCJCYXNlX3F1aWNrY2hlY2tfT2JzZXJ2ZXIwIiwiQmFzZV9Cb29sIiwiQmFzZV9DaGFyIiwiQmFzZV9JbnQiLCJCYXNlX0ludDMyIiwiQmFzZV9JbnQ2MyIsIkJhc2VfSW50NjQiLCJCYXNlX05hdGl2ZWludCIsIkJhc2VfRmxvYXQiLCJCYXNlX1N0cmluZyIsIkJhc2VfcXVpY2tjaGVja19CaWdhcnJheV9oZWxwZSIsIkJhc2VfQnl0ZXMiLCJvcGFxdWUiLCJjcmVhdGUiLCJvYnNlcnZlIiwidW5tYXAiLCJ0IiwieCIsInNpemUiLCJoYXNoIiwib2ZfaGFzaF9mb2xkIiwicGFyYW0iLCJvZl9sYXp5IiwibGF6eV90IiwiZml4ZWRfcG9pbnQiLCJ3cmFwIiwiYm9vbCIsImNoYXIiLCJpbnQiLCJpbnQzMiIsImludDYzIiwiaW50NjQiLCJuYXRpdmVpbnQiLCJmbG9hdCIsInN0cmluZyIsInNleHAiLCJiaWdzdHJpbmciLCJmbG9hdDMyX3ZlYyIsImZsb2F0NjRfdmVjIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImJ5dGVzIiwiZWl0aGVyIiwiZnN0X3QiLCJzbmRfdCIsImZzdCIsInNuZCIsInJlc3VsdCIsIm9rX3QiLCJlcnJfdCIsIm9rIiwiZXJyIiwiYm90aCIsIm9wdGlvbiIsInZhbHVlX3QiLCJ2YWx1ZSIsImxpc3QiLCJlbHRfdCIsInJhbmRvbSIsImxlbmd0aCIsInNpemVzIiwiZWx0IiwiYXJyYXkiLCJyZWYiLCJmbiIsImRvbSIsInJuZyIsIm1hcF90cmVlIiwia2V5X29icyIsImRhdGFfb2JzIiwiYXJnIiwiZXRhIiwic2V0X3RyZWUiLCJlbHRfb2JzIiwibWFwX3QiLCJzZXRfdCIsIkJhc2VfcXVpY2tjaGVja19PYnNlcnZlciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLGVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FBQTlCO0FBQUFBLElDR2lCO0FBQUEsc0JBQUErQixHQUFBQyxNQUFBQztBQUFBQSxjQUF1QyxPQUFLLFdBQUwsNkJBQWlCO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQUMsYUFBQWxDO0FBQUFBLElBQ3JELHVCQUFBK0IsR0FBQUksT0FBQUYsTUFBK0IsNkJBQVEsR0FBQztBQUFBO0FBQUEsWUFBQUcsUUFBQUM7QUFBQUEsSUFDeEM7QUFBQSxzQkFBQU4sR0FBQUMsTUFBQUM7QUFBQUEsa0JBQUEsSUFBNkI7QUFBQTtBQUFBO0FBQUE7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QUNJLE9BQUssYUFBTCw2QkFBaUI7QUFBQSx5QkFBQztBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFrRCxTQUFBQyxTQUFBQztBQUFBQSxRQUFBQyxNQUluQztBQUFBLElBQVksT0FBd0I7QUFBQSxhQUE5QixLQUFNO0FBQUEsc0JBQUFDLEtEdEZkLGlDQ3NGNEU7QUFBQTtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLFFBQUEsSUFHL0M7QUFBQSxXQUFjLE1BQWQsaUJBQW1EO0FBQUE7QUFBQSxZQUFBQyxNQUFBTixTQUFBQztBQUFBQSxRQUFBLElBR3hFO0FBQUEsV0FBMkIsTUFBM0IsK0JBQTJEO0FBQUE7QUFBQSxZQUFBTSxNQUFBRjtBQUFBQSxRQUFBLElBR3pDO0FBQUEsV0FBa0IsTUFBbEIscUJBQWtEO0FBQUE7QUFBQTtBQUFBLElBQUFHO0FBQUFBLE1BbkVqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ1QjNDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzc0NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX3F1aWNrY2hlY2tfR2VuZXJhdG9yIiwiQmFzZV9xdWlja2NoZWNrX09ic2VydmVyIiwiQmFzZV9xdWlja2NoZWNrX1Nocmlua2VyIiwicXVpY2tjaGVja19nZW5lcmF0b3JfdW5pdCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2Jvb2wiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9jaGFyIiwicXVpY2tjaGVja19nZW5lcmF0b3Jfc3RyaW5nIiwicXVpY2tjaGVja19nZW5lcmF0b3JfYnl0ZXMiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9pbnQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9pbnQzMiIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2ludDY0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfbmF0aXZlaW50IiwicXVpY2tjaGVja19nZW5lcmF0b3JfZmxvYXQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9vcHRpb24iLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9saXN0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfYXJyYXkiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9yZWYiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9sYXp5X3QiLCJxdWlja2NoZWNrX29ic2VydmVyX3VuaXQiLCJxdWlja2NoZWNrX29ic2VydmVyX2Jvb2wiLCJxdWlja2NoZWNrX29ic2VydmVyX2NoYXIiLCJxdWlja2NoZWNrX29ic2VydmVyX3N0cmluZyIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfYnl0ZXMiLCJxdWlja2NoZWNrX29ic2VydmVyX2ludCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfaW50MzIiLCJxdWlja2NoZWNrX29ic2VydmVyX2ludDY0IiwicXVpY2tjaGVja19vYnNlcnZlcl9uYXRpdmVpbnQiLCJxdWlja2NoZWNrX29ic2VydmVyX2Zsb2F0IiwicXVpY2tjaGVja19vYnNlcnZlcl9vcHRpb24iLCJxdWlja2NoZWNrX29ic2VydmVyX2xpc3QiLCJxdWlja2NoZWNrX29ic2VydmVyX2FycmF5IiwicXVpY2tjaGVja19vYnNlcnZlcl9yZWYiLCJxdWlja2NoZWNrX29ic2VydmVyX2xhenlfdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfdW5pdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfYm9vbCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfY2hhciIsInF1aWNrY2hlY2tfc2hyaW5rZXJfc3RyaW5nIiwicXVpY2tjaGVja19zaHJpbmtlcl9ieXRlcyIsInF1aWNrY2hlY2tfc2hyaW5rZXJfaW50IiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQzMiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfaW50NjQiLCJxdWlja2NoZWNrX3Nocmlua2VyX25hdGl2ZWludCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfZmxvYXQiLCJxdWlja2NoZWNrX3Nocmlua2VyX29wdGlvbiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbGlzdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfYXJyYXkiLCJxdWlja2NoZWNrX3Nocmlua2VyX3JlZiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfbGF6eV90IiwiQmFzZV9xdWlja2NoZWNrX0V4cG9ydCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGdDQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGdDQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4NTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9xdWlja2NoZWNrLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiQmFzZV9xdWlja2NoZWNrX0V4cG9ydCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX3VuaXQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9ib29sIiwicXVpY2tjaGVja19nZW5lcmF0b3JfY2hhciIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX3N0cmluZyIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2J5dGVzIiwicXVpY2tjaGVja19nZW5lcmF0b3JfaW50IiwicXVpY2tjaGVja19nZW5lcmF0b3JfaW50MzIiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9pbnQ2NCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX25hdGl2ZWludCIsInF1aWNrY2hlY2tfZ2VuZXJhdG9yX2Zsb2F0IiwicXVpY2tjaGVja19vYnNlcnZlcl91bml0IiwicXVpY2tjaGVja19vYnNlcnZlcl9ib29sIiwicXVpY2tjaGVja19vYnNlcnZlcl9jaGFyIiwicXVpY2tjaGVja19vYnNlcnZlcl9zdHJpbmciLCJxdWlja2NoZWNrX29ic2VydmVyX2J5dGVzIiwicXVpY2tjaGVja19vYnNlcnZlcl9pbnQiLCJxdWlja2NoZWNrX29ic2VydmVyX2ludDMyIiwicXVpY2tjaGVja19vYnNlcnZlcl9pbnQ2NCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfbmF0aXZlaW50IiwicXVpY2tjaGVja19vYnNlcnZlcl9mbG9hdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfdW5pdCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfYm9vbCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfY2hhciIsInF1aWNrY2hlY2tfc2hyaW5rZXJfc3RyaW5nIiwicXVpY2tjaGVja19zaHJpbmtlcl9ieXRlcyIsInF1aWNrY2hlY2tfc2hyaW5rZXJfaW50IiwicXVpY2tjaGVja19zaHJpbmtlcl9pbnQzMiIsInF1aWNrY2hlY2tfc2hyaW5rZXJfaW50NjQiLCJxdWlja2NoZWNrX3Nocmlua2VyX25hdGl2ZWludCIsInF1aWNrY2hlY2tfc2hyaW5rZXJfZmxvYXQiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9vcHRpb24iLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9saXN0IiwicXVpY2tjaGVja19nZW5lcmF0b3JfYXJyYXkiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9yZWYiLCJxdWlja2NoZWNrX2dlbmVyYXRvcl9sYXp5X3QiLCJxdWlja2NoZWNrX29ic2VydmVyX29wdGlvbiIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfbGlzdCIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfYXJyYXkiLCJxdWlja2NoZWNrX29ic2VydmVyX3JlZiIsInF1aWNrY2hlY2tfb2JzZXJ2ZXJfbGF6eV90IiwicXVpY2tjaGVja19zaHJpbmtlcl9vcHRpb24iLCJxdWlja2NoZWNrX3Nocmlua2VyX2xpc3QiLCJxdWlja2NoZWNrX3Nocmlua2VyX2FycmF5IiwicXVpY2tjaGVja19zaHJpbmtlcl9yZWYiLCJxdWlja2NoZWNrX3Nocmlua2VyX2xhenlfdCIsIlByaXZhdGUiLCJCYXNlX3F1aWNrY2hlY2siXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLGlDQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsZ0NBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQyxnQ0FBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw2QkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsNEJBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLDZCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fV19
