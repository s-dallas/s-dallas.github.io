// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Ppx_expect_runtime__
//# shape: Ppx_expect_runtime__:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ppx_expect_runtime = [0],
    Ppx_expect_runtime$0 = [0, Ppx_expect_runtime];
   runtime.caml_register_global
    (0, Ppx_expect_runtime$0, "Ppx_expect_runtime__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Types
//# unitInfo: Requires: Base, Base__Comparable, Base__Int
//# shape: Ppx_expect_runtime__Types:[[N,[]],[F(2)*,F(2)],[],N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    global_data = runtime.caml_get_global_data(),
    default$ = [0, 2, 0, "%", "@@"],
    default$0 = [0, cst],
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int = global_data.Base__Int;
   function equal(a, b){
    var c = a[1] === b[1] ? 1 : 0;
    if(c)
     var d = a[2] === b[2] ? 1 : 0, e = d ? a[3] === b[3] ? 1 : 0 : d;
    else
     var e = c;
    return e;
   }
   function a(t){return t[3];}
   var b = Base[129], c = Base_Comparable[2];
   function d(t){return t[2];}
   var
    e = Base[129],
    f = Base_Comparable[2],
    g =
      [0,
       function(a, b){return f(e, d, a, b);},
       [0, function(d, e){return c(b, a, d, e);}, 0]],
    h = Base_Comparable[1];
   function compare_character_range(a, b){return h(g, a, b);}
   var
    Compact_loc = [0, equal, compare_character_range],
    Flexibility = [0],
    Expect_node_formatting = [0, default$, Flexibility],
    Virtual_loc = [0],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash = Base_Int[8],
    sexp_of_t = Base_Int[10],
    compare = Base_Int[14],
    counter = [0, 0];
   function mint(param){
    var id = counter[1];
    counter[1] = id + 1 | 0;
    return id;
   }
   var Hand = [0], Kind = [0], Shape = [0], i = [0, cst];
   function handed(t, hand){return hand ? t ? t : i : t;}
   var
    Ppx_expect_runtime_Types =
      [0,
       Expect_node_formatting,
       Compact_loc,
       Virtual_loc,
       [0, of_int_exn, to_int_exn, compare, sexp_of_t, hash, mint],
       [0, Hand, Kind, Shape, [0, default$0, handed]]];
   runtime.caml_register_global
    (6, Ppx_expect_runtime_Types, "Ppx_expect_runtime__Types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Write_corrected_file
//# unitInfo: Requires: Base, Base__Comparable, Base__List, Base__String, Make_corrected_file, Ppx_expect_runtime__Types, Stdio__Out_channel, Stdlib, Stdlib__Filename, Stdlib__Sys
//# shape: Ppx_expect_runtime__Write_corrected_file:[[],F(7)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Base_String = global_data.Base__String,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Make_corrected_file = global_data.Make_corrected_file,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Comparable = global_data.Base__Comparable,
    Base_List = global_data.Base__List,
    Patch_with_file_contents = [0],
    cst_corrected = ".corrected",
    cst_corrected_tmp = ".corrected.tmp",
    dummy = 0;
   function f
   (use_color,
    in_place,
    diff_command,
    diff_path_prefix,
    filename,
    with$,
    corrections$0){
    var
     dot_corrected = Base[241].call(null, filename, cst_corrected),
     in_channel = Stdlib[80].call(null, filename),
     e = Stdlib[92].call(null, in_channel),
     original_file_contents = Stdlib[86].call(null, in_channel, e);
    Stdlib[93].call(null, in_channel);
    function remove(file){
     if(runtime.caml_sys_file_exists(file)) runtime.caml_sys_remove(file);
    }
    var
     corrections$1 = caml_call2(with$, original_file_contents, corrections$0),
     a = Base[242],
     b = Ppx_expect_runtime_Types[2][2],
     c = Base_Comparable[2],
     corrections =
       Base_List[83].call
        (null, corrections$1, function(d, e){return c(b, a, d, e);}),
     match =
       Base_List[96].call
        (null,
         corrections,
         0,
         function(l_pos, param){
          var
           correction = param[2],
           match = param[1],
           end_pos = match[3],
           start_pos = match[2],
           code_chunk =
             Base_String[3].call
              (null, original_file_contents, l_pos, start_pos - l_pos | 0);
          return [0, end_pos, [0, code_chunk, [0, correction, 0]]];
         }),
     strs = match[2],
     l_pos = match[1],
     d = Base_List[11].call(null, strs),
     result = Base_String[68].call(null, 0, d),
     rest = Base_String[5].call(null, [0, l_pos], 0, original_file_contents),
     next_contents = Base[241].call(null, result, rest);
    if(in_place){
     if
      (1 - Base_String[134].call(null, original_file_contents, next_contents))
      Stdio_Out_channel[37].call(null, filename, next_contents);
     remove(dot_corrected);
     return 0;
    }
    if(diff_command && diff_command[1] === "-"){
     Stdio_Out_channel[37].call(null, dot_corrected, next_contents);
     return 0;
    }
    var
     f = Stdlib_Filename[13].call(null, filename),
     g = [0, Stdlib_Filename[14].call(null, filename)],
     tmp_corrected = Stdlib_Filename[16].call(null, g, f, cst_corrected_tmp);
    return 0
            ===
             Make_corrected_file[1].call
               (null,
                0,
                [0, tmp_corrected],
                [0, use_color],
                diff_command,
                diff_path_prefix,
                next_contents,
                filename,
                0)
              [0]
            ? (remove(dot_corrected), remove(tmp_corrected), 0)
            : (runtime.caml_sys_rename(tmp_corrected, dot_corrected), 1);
   }
   var Ppx_expect_runtime_Write_corre = [0, Patch_with_file_contents, f];
   runtime.caml_register_global
    (12,
     Ppx_expect_runtime_Write_corre,
     "Ppx_expect_runtime__Write_corrected_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Output
//# unitInfo: Requires: Base, Base__List, Base__Printf, Base__String, Ppx_expect_runtime__Types
//# shape: Ppx_expect_runtime__Output:[[],[],N,[F(1)*,F(2)],[F(2)*],[F(1)*,F(1)],F(2)*,F(1)*,F(2),F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Type = [0],
    compare = Base[195],
    Formatted = [0];
   function create(format){return format;}
   function apply(format, str){return caml_call1(format, str);}
   var Formatter = [0, create, apply];
   function compare$0(a, b){
    if(! a) return b ? -1 : 0;
    if(! b) return 1;
    var b$0 = b[1], a$0 = a[1];
    return compare(a$0, b$0);
   }
   var
    Test_result = [0, compare$0],
    a = [0, "\n"],
    b =
      [0,
       [12, 123, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]],
       "{%s|%s|%s}"],
    c = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'];
   function default$(contents){
    return [0, contents, Ppx_expect_runtime_Types[5][4][1]];
   }
   function to_source_code_string(param){
    var tag = param[2], test_output = param[1];
    if(tag){
     var tag$0 = tag[1];
     return caml_call3
             (Base_Printf[2].call(null, b), tag$0, test_output, tag$0);
    }
    var
     d = Base_String[102].call(null, test_output, 10),
     e = Base_List[53].call(null, d, Base_String[69]),
     f = Base_String[68].call(null, a, e);
    return caml_call1(Base_Printf[2].call(null, c), f);
   }
   var
    Payload = [0, default$, to_source_code_string],
    d = [0, [12, 123, [2, 0, [12, 124, 0]]], "{%s|"],
    cst_xxx = "xxx",
    e = [0, [12, 124, [2, 0, [12, 125, 0]]], "|%s}"],
    f =
      [0,
       [12,
        123,
        [2,
         0,
         [2,
          0,
          [12, 32, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]]]]],
       "{%s%s %s|%s|%s}"],
    g =
      [0,
       [12, 123, [2, 0, [2, 0, [12, 124, [2, 0, [11, "|}", 0]]]]]],
       "{%s%s|%s|}"],
    h =
      [0,
       [12, 91, [2, 0, [2, 0, [12, 32, [2, 0, [12, 93, 0]]]]]],
       "[%s%s %s]"];
   function reconcile(expected_output, test_output){
    return Base_String[134].call(null, expected_output, test_output)
            ? 0
            : [0, test_output];
   }
   function fail(error_output){return [0, error_output];}
   function fix_delimiter_conflicts(contents, delimiter){
    if(! delimiter) return 0;
    var tag$1 = delimiter[1], tag = tag$1;
    for(;;){
     let tag$1 = tag;
     var
      tag_conflicts_with =
        function(fstr){
         var a = caml_call1(Base_Printf[2].call(null, fstr), tag$1);
         return Base_String[92].call(null, contents, a);
        };
     if(! tag_conflicts_with(d) && ! tag_conflicts_with(e)) return [0, tag];
     var tag$0 = Base[241].call(null, tag, cst_xxx);
     tag = tag$0;
    }
   }
   function to_formatted_payload(param, contents){
    return [0, contents, fix_delimiter_conflicts(contents, param)];
   }
   function to_source_code_string$0
   (expect_node_formatting, shape, tag, contents){
    var
     delimiter =
       fix_delimiter_conflicts
        (contents,
         caml_call2(Ppx_expect_runtime_Types[5][4][2], tag, shape[2])),
     payload = [0, contents, delimiter];
    if(! shape[2]){
     var
      prefix$0 =
        shape[3] ? expect_node_formatting[3] : expect_node_formatting[4],
      c = to_source_code_string(payload),
      d = shape[1];
     return caml_call3(Base_Printf[2].call(null, h), prefix$0, d, c);
    }
    var prefix = expect_node_formatting[3], tag$0 = delimiter[1];
    if(tag$0 !== ""){
     var a = shape[1];
     return caml_call5
             (Base_Printf[2].call(null, f), prefix, a, tag$0, contents, tag$0);
    }
    var b = shape[1];
    return caml_call3(Base_Printf[2].call(null, g), prefix, b, contents);
   }
   var
    Ppx_expect_runtime_Output =
      [0,
       Type,
       Formatted,
       [0],
       Formatter,
       Test_result,
       Payload,
       reconcile,
       fail,
       to_formatted_payload,
       to_source_code_string$0];
   runtime.caml_register_global
    (15, Ppx_expect_runtime_Output, "Ppx_expect_runtime__Output");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation_intf
//# shape: Ppx_expect_runtime__Expectation_intf:[[[],[],[],[],[]]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Insert_loc = [0],
    Behavior_type = [0],
    Expect_reachability = [0],
    On_unreachable = [0],
    Behavior = [0],
    Definitions =
      [0,
       Insert_loc,
       Behavior_type,
       Expect_reachability,
       On_unreachable,
       Behavior],
    Ppx_expect_runtime_Expectation = [0, Definitions];
   runtime.caml_register_global
    (0,
     Ppx_expect_runtime_Expectation,
     "Ppx_expect_runtime__Expectation_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation
//# unitInfo: Requires: Base, Base__Char, Base__Int, Base__List, Base__Staged, Base__String, Ppx_expect_runtime__Expectation_intf, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
//# shape: Ppx_expect_runtime__Expectation:[[F(1)*],F(2)*,F(2)*,F(3),F(3),F(1)*,F(3),F(1)*,F(1)*,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$6 = " ",
    cst_expect$0 = "expect",
    cst_expect_uncaught_exn = "expect.uncaught_exn",
    cst_test_output$2 = "test output",
    cst_uncaught_exception$1 = "uncaught exception";
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$7,
    cst$0 = cst$7,
    cst$1 = cst$6,
    cst$2 = cst$6,
    cst$3 = cst$7,
    cst = cst$7,
    last_line = cst$6,
    first_line = cst$6,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Staged = global_data.Base__Staged,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Base_Char = global_data.Base__Char,
    Base_List = global_data.Base__List,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types;
   function loc(param){
    if(0 === param[0]){var whole_node = param[1]; return whole_node;}
    var loc = param[1][1];
    return loc;
   }
   var
    Insert_loc = [0, loc],
    a = [0, "\n"],
    b = [0, cst$6, 0],
    cst_test_output = cst_test_output$2,
    cst_expect = cst_expect$0,
    cst_test_output$0 = cst_test_output$2,
    cst_expect_exact = "expect_exact",
    cst_test_output$1 = cst_test_output$2,
    c = [0, cst_expect$0, 0, 1],
    d = [1, 0],
    cst_uncaught_exception = cst_uncaught_exception$1,
    e = [0, cst_expect_uncaught_exn, 0, 0],
    cst_trailing_output = "trailing output",
    f = [0, cst_expect$0, 0, 1],
    cst_uncaught_exception$0 = cst_uncaught_exception$1,
    g = [0, cst_expect_uncaught_exn, 0, 0],
    h = [1, 1];
   function with_behavior(param, behavior){
    var
     inconsistent_outputs_message = param[5],
     on_incorrect_output = param[4],
     payload_type = param[3],
     position = param[1];
    return [0,
            position,
            behavior,
            payload_type,
            on_incorrect_output,
            inconsistent_outputs_message];
   }
   function formatter(expect_node_formatting, param){
    var payload_type = param[3], behavior = param[2], position = param[1];
    function count_leading_spaces(line){
     var
      a = Base_String[25].call(null, line),
      b = 32,
      c = Base_Char[12],
      d = Base_List[141].call(null, a, function(a){return c(b, a);});
     return Base_List[45].call(null, d);
    }
    var
     match = param[4],
     c =
       payload_type
        ? function
         (str){
          var
           d = Base_String[104].call(null, str),
           e = [0, Base_Char[45]],
           f = Base_String[108],
           g = Base_List[53].call(null, d, function(a){return f(e, a);}),
           h = Base_List[142].call(null, g, Base_String[14]),
           i = Base_List[63].call(null, h),
           j = Base_List[142].call(null, i, Base_String[14]),
           stripped = Base_List[63].call(null, j),
           indent_and_contents =
             Base_List[53].call
              (null,
               stripped,
               function(line){
                var a = Base_String[109].call(null, 0, line);
                return [0, count_leading_spaces(line), a];
               }),
           k =
             Base_List[13].call
              (null,
               indent_and_contents,
               function(param){
                var indent = param[1];
                return param[2] !== cst$7 ? [0, indent] : 0;
               }),
           match$0 = Base_List[31].call(null, k, Base_Int[14]);
          if(match$0)
           var
            min_indent = match$0[1],
            lines =
              Base_List[53].call
               (null,
                indent_and_contents,
                function(param){
                 var line = param[2], indent = param[1];
                 return [0,
                         Base_Int[16].call(null, 0, indent - min_indent | 0),
                         line];
                });
          else
           var lines = 0;
          if(0 === behavior[0])
           var tag = behavior[1][2], tag$0 = tag;
          else
           var tag$0 = Ppx_expect_runtime_Types[5][4][1];
          var match$1 = expect_node_formatting[2];
          if(! lines) return tag$0 ? cst$2 : cst$3;
          if(! lines[2] && ! match$1){
           var line = lines[1][2];
           return tag$0
                   ? Base_String[68].call(null, 0, [0, cst$1, [0, line, b]])
                   : line;
          }
          if(0 === position[0])
           var
            match$2 = position[1],
            start_pos = match$2[2],
            start_bol = match$2[1],
            c = start_pos - start_bol | 0;
          else
           var
            match$3 = position[1][2],
            start_pos$0 = match$3[2],
            start_bol$0 = match$3[1],
            m = match[3] ? expect_node_formatting[1] : 0,
            c = (start_pos$0 - start_bol$0 | 0) + m | 0;
          var location_indent = expect_node_formatting[1] + c | 0;
          function spaces(n){return Base_String[66].call(null, n, 32);}
          if(tag$0)
           var
            last_line$0 = spaces(location_indent),
            indentation = location_indent,
            first_line$0 = cst;
          else
           var
            last_line$0 = last_line,
            indentation = 1,
            first_line$0 = first_line;
          var
           lines$0 =
             Base_List[53].call
              (null,
               lines,
               function(param){
                var indent = param[1];
                if(param[2] === cst$7) return cst$0;
                var line = param[2], a = spaces(indentation + indent | 0);
                return Base[241].call(null, a, line);
               }),
           l =
             Base_List[11].call
              (null,
               [0,
                [0, first_line$0, 0],
                [0, lines$0, [0, [0, last_line$0, 0], 0]]]);
          return Base_String[68].call(null, a, l);
         }
        : function(a){return a;};
    return Ppx_expect_runtime_Output[4][1].call(null, c);
   }
   function extension_syntax(extension_name, payload_loc, node_loc){
    if(payload_loc){
     var
      payload_loc$0 = payload_loc[1],
      a = payload_loc$0[2] <= node_loc[2] ? 1 : 0,
      b = a ? node_loc[3] <= payload_loc$0[3] ? 1 : 0 : a;
     if(b) return [0, extension_name, 1, 1];
    }
    return [0, extension_name, 0, 1];
   }
   function possibly_relax_strictness(formatting_flexibility, t){
    if(! formatting_flexibility) return t;
    var
     expect_node_formatting = formatting_flexibility[1],
     fmt = formatter(expect_node_formatting, t),
     a = t[2],
     reachability = a[3],
     on_unreachable = a[2],
     match = a[1],
     tag = match[2],
     contents = match[1],
     b = Ppx_expect_runtime_Output[4][2].call(null, fmt, contents),
     match$0 = Ppx_expect_runtime_Output[7].call(null, contents, b);
    if(! match$0) return t;
    var
     contents$0 = match$0[1],
     payload = Ppx_expect_runtime_Output[9].call(null, tag, contents$0);
    return with_behavior(t, [0, payload, on_unreachable, reachability]);
   }
   function expected_string_and_payload_lo(param){
    if(! param)
     return [0, Ppx_expect_runtime_Output[6][1].call(null, cst$4), 0];
    var match = param[1], b = match[2], a = match[1];
    return [0, a, [0, b]];
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              1,
              extension_syntax(cst_expect, payload_loc, node_loc),
              cst_test_output]);
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              0,
              extension_syntax(cst_expect_exact, payload_loc, node_loc),
              cst_test_output$0]);
   }
   function expect_unreachable(node_loc){
    return [0, [0, node_loc, 0], d, 1, c, cst_test_output$1];
   }
   function expect_uncaught_exn
   (formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 1, 1],
              1,
              e,
              cst_uncaught_exception]);
   }
   function expect_trailing(insert_loc){
    return [0,
            [1, insert_loc],
            [0, Ppx_expect_runtime_Output[6][1].call(null, cst$5), 0, 0],
            1,
            f,
            cst_trailing_output];
   }
   function expect_no_uncaught_exn(insert_loc){
    return [0, [1, insert_loc], h, 1, g, cst_uncaught_exception$0];
   }
   function format_payload(mk_node){
    return Base_Staged[1].call
            (null,
             function
             (expect_node_formatting, payload_loc, node_loc, tag, contents){
              var
               node =
                 caml_call3
                  (mk_node,
                   0,
                   node_loc,
                   [0, [0, [0, contents, tag], payload_loc]]),
               a = formatter(expect_node_formatting, node),
               formatted_contents =
                 Ppx_expect_runtime_Output[4][2].call(null, a, contents),
               match =
                 Ppx_expect_runtime_Output[7].call
                  (null, contents, formatted_contents);
              if(! match) return 0;
              var contents$0 = match[1], node_shape = node[4];
              if(node_shape[2])
               var
                source_code_string =
                  Ppx_expect_runtime_Output[10].call
                   (null, expect_node_formatting, node_shape, tag, contents$0);
              else
               var
                b = Ppx_expect_runtime_Output[9].call(null, tag, contents$0),
                source_code_string =
                  Ppx_expect_runtime_Output[6][2].call(null, b);
              return [0, source_code_string];
             });
   }
   var
    i = format_payload(expect),
    format_expect_payload = Base_Staged[2].call(null, i),
    j = format_payload(expect_uncaught_exn),
    format_uncaught_exn_payload = Base_Staged[2].call(null, j),
    Ppx_expect_runtime_Expectation =
      [0,
       Insert_loc,
       with_behavior,
       formatter,
       expect,
       expect_exact,
       expect_unreachable,
       expect_uncaught_exn,
       expect_trailing,
       expect_no_uncaught_exn,
       [0, format_expect_payload, format_uncaught_exn_payload]];
   runtime.caml_register_global
    (35, Ppx_expect_runtime_Expectation, "Ppx_expect_runtime__Expectation");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_node
//# unitInfo: Requires: Base, Base__Char, Base__Comparable, Base__Error, Base__Hashtbl, Base__List, Base__Option, Base__Printf, Base__Queue, Base__String, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
//# shape: Ppx_expect_runtime__Test_node:[[F(3),F(3),F(1)],F(1),F(1),F(4),N,N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$4 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    tag = [0, cst$4],
    cst$3 = cst$4,
    cst$2 = ";",
    cst = cst$4,
    cst$0 = "\n",
    cst$1 = cst$4,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_List = global_data.Base__List,
    Base_Option = global_data.Base__Option,
    Base_Queue = global_data.Base__Queue,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    a =
      [0,
       [12, 91, [2, 0, [11, "expect.unreachable]", 0]]],
       "[%sexpect.unreachable]"];
   function to_diffs
   (expect_node_formatting, original_file_contents, correction$2){
    function safe_byte_get(string, i){
     if(0 <= i && i < runtime.caml_ml_string_length(string))
      return [0, runtime.caml_string_get(string, i)];
     return 0;
    }
    if(0 === correction$2[0]){
     var
      b = correction$2[1],
      on_incorrect_output = b[4],
      test_output = correction$2[2],
      behavior = b[2],
      position = b[1];
     if(0 === position[0])
      var whitespace = cst;
     else
      var
       match = position[1][2],
       start_pos = match[2],
       start_bol = match[1],
       let_offset = start_pos - start_bol | 0,
       h = on_incorrect_output[3] ? expect_node_formatting[1] : 0,
       indent = let_offset + h | 0,
       i = Base_String[66].call(null, indent, 32),
       whitespace$0 = Base[241].call(null, cst$0, i),
       whitespace = whitespace$0;
     if(0 === behavior[0])
      var tag = behavior[1][2], tag$0 = tag;
     else
      var tag$0 = Ppx_expect_runtime_Types[5][4][1];
     a:
     {
      if(0 === position[0]){
       var loc = position[1], d = position[2];
       if(d && ! on_incorrect_output[2]){
        if(on_incorrect_output[3]){
         var
          payload_loc = d[1],
          g = Ppx_expect_runtime_Output[9].call(null, tag$0, test_output),
          correction$1 = Ppx_expect_runtime_Output[6][2].call(null, g),
          correction$0 = correction$1,
          loc$1 = payload_loc;
         break a;
        }
        var loc$0 = loc;
       }
       else
        var loc$0 = loc;
      }
      else
       var loc$0 = position[1][1];
      var
       correction =
         Ppx_expect_runtime_Output[10].call
          (null,
           expect_node_formatting,
           on_incorrect_output,
           tag$0,
           test_output),
       correction$0 = correction,
       loc$1 = loc$0;
     }
     var
      match$0 =
        [0, [0, loc$1, Base[241].call(null, whitespace, correction$0)]];
    }
    else{
     var
      c = correction$2[1],
      on_incorrect_output$0 = c[4],
      on_unreachable = c[2][2],
      position$0 = c[1],
      loc$2 = Ppx_expect_runtime_Expectation[1][1].call(null, position$0);
     switch(on_unreachable){
       case 0:
        var match$0 = 0; break;
       case 1:
        var match$0 = [0, [0, loc$2, cst$1]]; break;
       default:
        var
         prefix =
           on_incorrect_output$0[3]
            ? expect_node_formatting[3]
            : expect_node_formatting[4],
         match$0 =
           [0, [0, loc$2, caml_call1(Base_Printf[2].call(null, a), prefix)]];
     }
    }
    if(! match$0) return 0;
    var
     match$1 = match$0[1],
     diff = match$1[2],
     loc$3 = match$1[1],
     end_pos = loc$3[3],
     start_pos$0 = loc$3[2],
     start_bol$0 = loc$3[1],
     main_correction = [0, [0, loc$3, diff], 0];
    a:
    {
     if(0 !== correction$2[0] && ! correction$2[1][4][3]){
      var
       match$2 = safe_byte_get(original_file_contents, start_pos$0 - 1 | 0),
       match$3 = safe_byte_get(original_file_contents, end_pos);
      b:
      if(match$2 && 10 === match$2[1]){
       if(match$3 && 10 !== match$3[1]) break b;
       var
        remove_empty_line_from_deleted =
          [0, [0, [0, start_bol$0, start_pos$0 - 1 | 0, start_pos$0], cst$3]];
       break a;
      }
      var remove_empty_line_from_deleted = 0;
      break a;
     }
     var remove_empty_line_from_deleted = 0;
    }
    a:
    {
     if(0 === correction$2[0]){
      var e = correction$2[1], f = e[1];
      if(0 !== f[0] && e[4][3]){
       var
        body_loc = f[1][2],
        add_semicolon_before_trailing_ =
          [0, [0, [0, body_loc[1], body_loc[3], body_loc[3]], cst$2]];
       break a;
      }
     }
     var add_semicolon_before_trailing_ = 0;
    }
    var
     additional_corrections =
       Base_List[14].call
        (null,
         [0,
          remove_empty_line_from_deleted,
          [0, add_semicolon_before_trailing_, 0]],
         Base_Option[42]);
    return Base[222].call(null, additional_corrections, main_correction);
   }
   function record_and_return_result
   (expect_node_formatting, failure_ref, test_output_raw, t){
    var
     results = t[2],
     expectation = t[1],
     a =
       Ppx_expect_runtime_Expectation[3].call
        (null, expect_node_formatting, expectation),
     test_output =
       Ppx_expect_runtime_Output[4][2].call(null, a, test_output_raw),
     match = expectation[2];
    if(0 === match[0])
     var
      match$0 = match[1],
      tag$0 = match$0[2],
      contents = match$0[1],
      tag$1 = tag$0,
      result = Ppx_expect_runtime_Output[7].call(null, contents, test_output);
    else
     var
      result$0 = Ppx_expect_runtime_Output[8].call(null, test_output),
      tag$1 = tag,
      result = result$0;
    if(result) failure_ref[1] = 1;
    Base_Queue[35].call(null, results, [0, [0, result, test_output_raw]]);
    t[3] = 1;
    return [0, result, tag$1];
   }
   function of_expectation(expectation){
    return [0, [0, expectation, Base_Queue[58].call(null, 0, 0), 0]];
   }
   function record_end_of_run(t){
    var
     match = t[1],
     results = match[2],
     reached_this_run = match[3],
     a = 1 - reached_this_run;
    return a ? Base_Queue[35].call(null, results, 0) : a;
   }
   function record_result
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var inner = param[1];
    record_and_return_result
     (expect_node_formatting, failure_ref, test_output_raw, inner);
    return 0;
   }
   var
    global_results_table =
      Base_Hashtbl[4].call
       (null,
        0,
        0,
        [0,
         Base_String[51],
         Base_String[42],
         function(a){return runtime.Base_hash_string(a);}]),
    d =
      [0,
       [11,
        "Internal expect test bug: could not find test\nFile: ",
        [2, 0, [11, "\nID:   ", [4, 0, 0, 0, 0]]]],
       "Internal expect test bug: could not find test\nFile: %s\nID:   %d"];
   function find_test(absolute_filename, test_id){
    var
     a = Base_Hashtbl[56].call(null, global_results_table, absolute_filename),
     b =
       caml_call2
        (Base_Option[22],
         a,
         function(param){
          var expectations = param[1];
          return Base_Hashtbl[56].call(null, expectations, test_id);
         }),
     c = caml_call1(Ppx_expect_runtime_Types[4][2], test_id),
     e = caml_call2(Base_Printf[2].call(null, d), absolute_filename, c),
     f = [0, Base_Error[14].call(null, e)];
    return Base_Option[31].call(null, 0, f, 0, b);
   }
   function initialize_and_register_tests
   (absolute_filename, tests, postprocess){
    var tests_as_in_table = Base_Queue[58].call(null, 0, 0);
    Base_Hashtbl[41].call
     (null,
      global_results_table,
      absolute_filename,
      function(file){
       var
        a = Ppx_expect_runtime_Types[4],
        c =
          [0,
           Base_Hashtbl[4].call(null, 0, 0, [0, a[3], a[4], a[5]]),
           postprocess],
        file$0 = Base_Option[30].call(null, file, c),
        b = Ppx_expect_runtime_Types[4],
        tests$0 =
          Base_Hashtbl[8].call(null, 0, 0, [0, b[3], b[4], b[5]], tests);
       Base_Hashtbl[66].call
        (null,
         tests$0,
         file$0[1],
         function(test_id, new_test, existing_test){
          var test = Base_Option[30].call(null, existing_test, new_test);
          test[1][3] = 0;
          Base_Queue[35].call(null, tests_as_in_table, [0, test_id, test]);
          return [0, test];
         });
       return file$0;
      });
    return Base_Queue[20].call(null, tests_as_in_table);
   }
   function process_each_file(f){
    var
     a = Base_Hashtbl[78].call(null, global_results_table),
     b = Base[242],
     c = Base_String[51],
     d = Base_Comparable[2],
     e = Base_List[83].call(null, a, function(a, e){return d(c, b, a, e);});
    return Base_List[53].call
            (null,
             e,
             function(param){
              var
               match = param[2],
               postprocess = match[2],
               expectations = match[1],
               filename = param[1],
               test_nodes = Base_Hashtbl[68].call(null, expectations);
              return caml_call3(f, filename, test_nodes, postprocess);
             });
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (Ppx_expect_runtime_Expectation[4].call
              (null, formatting_flexibility, node_loc, located_payload));
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (Ppx_expect_runtime_Expectation[5].call
              (null, formatting_flexibility, node_loc, located_payload));
   }
   function expect_unreachable(node_loc){
    return of_expectation
            (Ppx_expect_runtime_Expectation[6].call(null, node_loc));
   }
   var
    Create = [0, expect, expect_exact, expect_unreachable],
    b = [0, 0],
    c =
      [0,
       [11, "<expect test ran without ", [2, 0, [12, 62, 0]]],
       "<expect test ran without %s>"];
   function loc(param){
    var position = param[1][1][1];
    return Ppx_expect_runtime_Expectation[1][1].call(null, position);
   }
   function expectation_of_t(param){
    var expectation = param[1][1], match = expectation[2];
    if(0 !== match[0]) return 0;
    var contents = match[1][1];
    return [0, contents];
   }
   function record_and_return_number_of_li
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var
     inner = param[1],
     a =
       record_and_return_result
        (expect_node_formatting, failure_ref, test_output_raw, inner),
     match = a[1];
    if(! match) return 0;
    var
     tag = a[2],
     contents = match[1],
     b = Ppx_expect_runtime_Output[9].call(null, tag, contents),
     correction = Ppx_expect_runtime_Output[6][2].call(null, b),
     c = 10,
     d = Base_Char[16];
    return [0,
            Base_String[21].call
             (null, correction, function(a){return d(c, a);})
            + 1
            | 0];
   }
   function to_diffs$0
   (cr_for_multiple_outputs,
    expect_node_formatting,
    original_file_contents,
    t){
    var
     match = t[1],
     results = match[2],
     expectation = match[1],
     results_list = Base_Queue[20].call(null, results),
     match$0 =
       Base_List[16].call
        (null,
         results_list,
         function(param){
          if(! param) return b;
          var output = param[1];
          return [1, output];
         }),
     outputs_list = match$0[2],
     unreached_list = match$0[1];
    function a(param){var result = param[1]; return result;}
    var
     d = Ppx_expect_runtime_Output[5][1],
     e = Base_Comparable[2],
     distinct_outputs =
       Base_List[126].call
        (null, outputs_list, function(b, c){return e(d, a, b, c);}),
     was_reached = Base_List[18].call(null, unreached_list),
     match$1 = expectation[2];
    if(0 === match$1[0])
     var reachability = match$1[3], reachability_behavior = reachability;
    else
     var
      reachability_of_corrected = match$1[1],
      reachability_behavior = reachability_of_corrected;
    function correction_for_single_result(param){
     if(! param) return 0;
     var received = param[1];
     return [0, [0, expectation, received]];
    }
    a:
    if(distinct_outputs){
     b:
     if(! distinct_outputs[2]){
      var result = distinct_outputs[1][1];
      if(! was_reached && reachability_behavior) break b;
      var match$2 = correction_for_single_result(result);
      break a;
     }
     var
      outputs =
        Base_List[53].call
         (null,
          results_list,
          function(param){
           if(param){var raw = param[1][2]; return raw;}
           var a = expectation[5];
           return caml_call1(Base_Printf[2].call(null, c), a);
          }),
      f = caml_call2(cr_for_multiple_outputs, expectation[5], outputs),
      g =
        Ppx_expect_runtime_Expectation[3].call
         (null, expect_node_formatting, expectation),
      h = Ppx_expect_runtime_Output[4][2].call(null, g, f),
      match$2 =
        correction_for_single_result
         (Ppx_expect_runtime_Output[8].call(null, h));
    }
    else
     var
      behavior = expectation[2],
      match$2 =
        0 === behavior[0]
         ? [0,
           [1,
            Ppx_expect_runtime_Expectation[2].call
             (null, expectation, behavior)]]
         : 0;
    if(! match$2) return 0;
    var correction = match$2[1];
    return to_diffs
            (expect_node_formatting, original_file_contents, correction);
   }
   var
    Ppx_expect_runtime_Test_node =
      [0,
       Create,
       of_expectation,
       record_end_of_run,
       record_result,
       [0, initialize_and_register_tests, find_test, process_each_file],
       [0, expectation_of_t, record_and_return_number_of_li, loc, to_diffs$0]];
   runtime.caml_register_global
    (23, Ppx_expect_runtime_Test_node, "Ppx_expect_runtime__Test_node");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Current_file
//# unitInfo: Requires: Base, Base__Or_error, Base__Printf, Base__String, CamlinternalLazy, Stdlib__Filename, Stdlib__Sys
//# shape: Ppx_expect_runtime__Current_file:[F(1),F(1),F(1),N,F(1),F(2)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Or_error = global_data.Base__Or_error,
    current = [0, 0],
    cst_new_file = "new_file",
    cst_old_file = "old_file",
    cst_Expect_test_collector_set_ =
      "Expect_test_collector.set: there is already an active file",
    cst_Expect_test_collector_unse =
      "Expect_test_collector.unset: there is no active file",
    cst_Expect_test_collector_get_ =
      "Expect_test_collector.get: there is no active file";
   function set(filename_rel_to_project_root){
    var match = current[1];
    if(match){
     var
      current$0 = match[1],
      a =
        [0,
         [0, cst_new_file, Base[202].call(null, filename_rel_to_project_root)],
         0],
      b = [0, [0, cst_old_file, Base[202].call(null, current$0)], a],
      c = Base[85][8].call(null, cst_Expect_test_collector_set_, b);
     return Base[246].call(null, c);
    }
    current[1] = [0, filename_rel_to_project_root];
    return 0;
   }
   function unset(param){
    if(current[1]){current[1] = 0; return 0;}
    var a = Base[85][8].call(null, cst_Expect_test_collector_unse, 0);
    return Base[246].call(null, a);
   }
   function get(param){
    var match = current[1];
    if(match){var fn = match[1]; return fn;}
    var a = Base[85][8].call(null, cst_Expect_test_collector_get_, 0);
    return Base[246].call(null, a);
   }
   var
    dir_or_error =
      Base_Or_error[31].call
       (null, [0, 1], function(a){return runtime.caml_sys_getcwd(a);}),
    initial_dir =
      [246, function(a){return Base_Or_error[34].call(null, dir_or_error);}],
    a =
      [0,
       [11,
        "Trying to run an expect test from the wrong file.\n- test declared at ",
        [2,
         0,
         [12,
          58,
          [4,
           0,
           0,
           0,
           [11, "\n- trying to run it from ", [2, 0, [12, 10, 0]]]]]]],
       "Trying to run an expect test from the wrong file.\n- test declared at %s:%d\n- trying to run it from %s\n"];
   function absolute_path(file){
    if(! Stdlib_Filename[5].call(null, file)) return file;
    var a = runtime.caml_obj_tag(initial_dir);
    a:
    if(250 === a)
     var b = initial_dir[1];
    else{
     if(246 !== a && 244 !== a){var b = initial_dir; break a;}
     var b = CamlinternalLazy[2].call(null, initial_dir);
    }
    return Stdlib_Filename[4].call(null, b, file);
   }
   function verify_that_file_is_current_ex
   (line_number, filename_rel_to_project_root){
    var registering_tests_for = get(0);
    return Base_String[134].call
             (null, filename_rel_to_project_root, registering_tests_for)
            ? 0
            : caml_call3
              (Base_Printf[4].call(null, Base[244], a),
               filename_rel_to_project_root,
               line_number,
               registering_tests_for);
   }
   var
    Ppx_expect_runtime_Current_fil =
      [0,
       set,
       unset,
       get,
       initial_dir,
       absolute_path,
       verify_that_file_is_current_ex];
   runtime.caml_register_global
    (13, Ppx_expect_runtime_Current_fil, "Ppx_expect_runtime__Current_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_block
//# unitInfo: Requires: Base, Base__Exn, Base__List, Base__Option, Base__Printf, Base__Source_code_position, Base__String, Expect_test_config, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Stdlib, Stdlib__Filename, Stdlib__Format, Stdlib__Obj, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys
//# shape: Ppx_expect_runtime__Test_block:[F(1),[F(1),F(1)*,N],F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst$5 = "\n",
    cst$6 = "(* ",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    partial = [12, 10, [10, 0]],
    cst$3 = cst$4,
    cst$1 = "---------------",
    cst$2 = cst$4,
    cst = "\n\n",
    cst$0 = cst$4,
    Expect_test_config = global_data.Expect_test_config,
    Base_Source_code_position = global_data.Base__Source_code_position,
    Base_Printf = global_data.Base__Printf,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Option = global_data.Base__Option,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_List = global_data.Base__List,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_String = global_data.Base__String,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Format = global_data.Stdlib__Format,
    cst_CR = "CR ",
    b =
      [0,
       [11,
        cst$6,
        [2,
         0,
         [11,
          "expect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)",
          0]]],
       "(* %sexpect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)"],
    c =
      [0,
       [11, "Test ran multiple times with different ", [2, 0, [12, 115, 0]]],
       "Test ran multiple times with different %ss"],
    d =
      [0,
       [11, cst$6, [2, 0, [11, "expect_test: ", [2, 0, [11, " *)", 0]]]]],
       "(* %sexpect_test: %s *)"],
    e =
      [0,
       [11,
        "=== Output ",
        [4, 0, 0, 0, [11, " / ", [4, 0, 0, 0, [11, " ===", 0]]]]],
       "=== Output %d / %d ==="],
    f = [0, [2, 0, [2, 0, [2, 0, 0]]], "%s%s%s"],
    g = [0, cst$5],
    h =
      [0,
       "Raised at ",
       [0, "Called from ", [0, "Raised by primitive operation ", 0]]],
    i =
      [0,
       [11,
        '("',
        [2, 0, [11, '(Cannot print more details, Exn.to_string failed)")', 0]]],
       '("%s(Cannot print more details, Exn.to_string failed)")'],
    j = [0, cst$5];
   function clean_up_block(param){
    var
     test_output_writer = param[5],
     test_output_reader = param[4],
     output_file = param[2];
    Stdlib[93].call(null, test_output_reader);
    runtime.ppx_expect_runtime_after_test(Stdlib[39], Stdlib[40]);
    Stdlib[76].call(null, test_output_writer);
    runtime.caml_sys_remove(output_file);
   }
   function flush(param){
    Stdlib_Format[39].call(null, Stdlib_Format[112], 0);
    Stdlib_Format[39].call(null, Stdlib_Format[114], 0);
    Stdlib[63].call(null, Stdlib[39]);
    Stdlib[63].call(null, Stdlib[40]);
    runtime.ppx_expect_runtime_flush_stubs_streams(0);
   }
   function read_test_output_unsanitized(param){
    var old_offset = param[6], test_output_reader = param[4];
    flush(0);
    var
     new_offset = runtime.ppx_expect_runtime_out_channel_position(Stdlib[39]),
     len = new_offset - old_offset[1] | 0;
    old_offset[1] = new_offset;
    return Stdlib[86].call(null, test_output_reader, len);
   }
   function Configured(C){
    var
     cr_prefix = 15023 <= C[4] ? cst_CR : cst$0,
     cr_for_backtrace = caml_call1(Base_Printf[2].call(null, b), cr_prefix);
    function cr_for_multiple_outputs(output_name, outputs){
     var
      cr_body = caml_call1(Base_Printf[2].call(null, c), output_name),
      cr = caml_call2(Base_Printf[2].call(null, d), cr_prefix, cr_body),
      num_outputs = Base_List[45].call(null, outputs),
      outputs_with_headers =
        Base_List[44].call
         (null,
          outputs,
          function(index, output){
           var
            header =
              caml_call2
               (Base_Printf[2].call(null, e), index + 1 | 0, num_outputs),
            pad_length =
              caml_ml_string_length(cr) - caml_ml_string_length(header) | 0,
            b = [0, output, 0];
           if(0 < pad_length)
            var
             lpad = Base_String[66].call(null, pad_length / 2 | 0, 61),
             rpad =
               Base_String[66].call
                (null, pad_length - (pad_length / 2 | 0) | 0, 61),
             a = caml_call3(Base_Printf[2].call(null, f), lpad, header, rpad);
           else
            var a = header;
           return [0, a, b];
          });
     return Base_String[68].call(null, g, [0, cr, outputs_with_headers]);
    }
    var sanitize = C[3];
    function check_for_backtraces(s){
     if
      (!
       Base_List[23].call
        (null,
         h,
         function(substring){return Base_String[92].call(null, s, substring);}))
      return s;
     var a = Base[241].call(null, cst, s);
     return Base[241].call(null, cr_for_backtrace, a);
    }
    function dump_backtrace(possible_exn){
     try{caml_call1(C[2], possible_exn);}
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       bt = Stdlib_Printexc[12].call(null, 0);
      try{var c = Base_Exn[10].call(null, exn), exn_string = c;}
      catch(exn$0){
       var
        a = Stdlib_Obj[22][1].call(null, exn),
        name = Stdlib_Obj[22][2].call(null, a),
        exn_string = caml_call1(Base_Printf[2].call(null, i), name);
      }
      var
       bt$0 = Stdlib_Printexc[14].call(null, bt),
       b =
         bt$0 !== cst$4
          ? Base_String
             [68].call
            (null, j, [0, cr_for_backtrace, [0, exn_string, [0, bt$0, 0]]])
          : exn_string;
      return [0, b];
     }
     return 0;
    }
    return [0,
            ,
            ,
            cr_for_multiple_outputs,
            sanitize,
            check_for_backtraces,
            dump_backtrace];
   }
   var
    test_is_running = [0, 0],
    k = [0, "line"],
    l = [0, "file"],
    cst_inner_test = "inner_test",
    cst_outer_test = "outer_test",
    cst_Expect_test_runtime_reache =
      "Expect_test_runtime: reached one [let%expect_test] from another. Nesting expect\ntests is prohibited.",
    n =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4,
             0,
             0,
             0,
             [12,
              45,
              [4,
               0,
               0,
               0,
               [11,
                ":\nError: program exited while expect test was running!\nOutput captured so far:\n",
                [2, 0, partial]]]]]]]]]],
       "File %S, line %d, characters %d-%d:\nError: program exited while expect test was running!\nOutput captured so far:\n%s\n%!"],
    o =
      [0,
       [11,
        "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at ",
        [2, 0, 0]],
       "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at %s"];
   function am_running_expect_test(param){
    return Base_Option[53].call(null, test_is_running[1]);
   }
   function current_test(param){
    return caml_call2
            (Base_Option[24],
             test_is_running[1],
             function(param){var test_block = param[4]; return test_block;});
   }
   function current_test_exn(param){
    var a = current_test(0);
    return Base_Option[31].call(null, 0, 0, 0, a);
   }
   function iter(f){return Base_Option[37].call(null, test_is_running[1], f);}
   function assert_no_test_running(basename, line_number){
    return iter
            (function(param){
              var outer_basename = param[2], outer_line_number = param[1];
              function sexp_here(basename, line_number){
               var
                a =
                  [0,
                   [1, [0, k, [0, caml_call1(Base[136], line_number), 0]]],
                   0];
               return [1,
                       [0, [1, [0, l, [0, Base[202].call(null, basename), 0]]], a]];
              }
              var
               a =
                 [0, [0, cst_inner_test, sexp_here(basename, line_number)], 0],
               b =
                 [0,
                  [0,
                   cst_outer_test,
                   sexp_here(outer_basename, outer_line_number)],
                  a],
               c = Base[85][8].call(null, cst_Expect_test_runtime_reache, b);
              return Base[246].call(null, c);
             });
   }
   function at_exit(param){
    return iter
            (function(param){
              var
               test_block = param[4],
               match = param[3],
               end_pos = match[3],
               start_pos = match[2],
               start_bol = match[1],
               basename = param[2],
               line_number = param[1];
              flush(0);
              var
               output_file = test_block[2],
               fin = Stdlib[80].call(null, output_file),
               a = Stdlib[92].call(null, fin),
               all_out = Stdlib[86].call(null, fin, a);
              clean_up_block(test_block);
              return caml_call5
                      (Stdlib_Printf[3].call(null, n),
                       basename,
                       line_number,
                       start_pos - start_bol | 0,
                       end_pos - start_bol | 0,
                       all_out);
             });
   }
   function read_current_test_output_exn(here){
    var match = current_test(0);
    if(match){
     var test_block = match[1], a = read_test_output_unsanitized(test_block);
     return Expect_test_config[3].call(null, a);
    }
    var
     b = Base_Source_code_position[22].call(null, here),
     c = caml_call1(Base_Printf[2].call(null, o), b);
    return Base[244].call(null, c);
   }
   var
    default_cr_for_multiple_output = Configured(Expect_test_config)[3],
    For_external =
      [0,
       read_current_test_output_exn,
       am_running_expect_test,
       default_cr_for_multiple_output],
    cst_output = "output",
    cst_expect_test = "expect-test",
    a = [0, 1, [0, 3, [0, 6, 0]]],
    cst_Trailing_output = "Trailing output",
    m = [0, cst$5],
    Ppx_expect_runtime_Test_block =
      [0,
       function(C){
        var Configured$0 = Configured(C);
        function read_test_output_no_backtrace_(param){
         var a = read_test_output_unsanitized(current_test_exn(0));
         return caml_call1(Configured$0[4], a);
        }
        function read_test_output_sanitized_and(param){
         var a = read_test_output_no_backtrace_(0);
         return Configured$0[5].call(null, a);
        }
        function run_test_inner(test_id, test_output_raw, t){
         var
          src_filename = t[1],
          a =
            caml_call2
             (Ppx_expect_runtime_Test_node[5][2], src_filename, test_id),
          fail = t[3];
         return Ppx_expect_runtime_Test_node[4].call
                 (null,
                  Ppx_expect_runtime_Types[1][1],
                  fail,
                  test_output_raw,
                  a);
        }
        function run_test(test_id){
         var a = current_test_exn(0);
         return run_test_inner(test_id, read_test_output_sanitized_and(0), a);
        }
        function run_suite
        (filename_rel_to_project_root,
         line_number,
         location,
         trailing_loc,
         body_loc,
         formatting_flexibility,
         expected_exn,
         test_to_run,
         exn_test_id,
         description,
         tags,
         inline_test_config,
         expectations,
         f){
         var
          end_pos = location[3],
          start_pos = location[2],
          start_bol = location[1],
          basename =
            Stdlib_Filename[13].call(null, filename_rel_to_project_root);
         assert_no_test_running(basename, line_number);
         return Ppx_inline_test_lib[8].call
                 (null,
                  inline_test_config,
                  [246,
                   function(a){
                    return Base_Option[30].call(null, description, cst$3);
                   }],
                  tags,
                  basename,
                  line_number,
                  start_pos - start_bol | 0,
                  end_pos - start_bol | 0,
                  function(param){
                   Ppx_expect_runtime_Current_fil[6].call
                    (null, line_number, filename_rel_to_project_root);
                   var
                    absolute_filename =
                      Ppx_expect_runtime_Current_fil[5].call(null, basename),
                    c =
                      Ppx_expect_runtime_Expectation[8].call
                       (null,
                        [0,
                         [0, trailing_loc[1], trailing_loc[2], trailing_loc[2]],
                         body_loc]),
                    trailing_test =
                      Ppx_expect_runtime_Test_node[2].call(null, c);
                   if(expected_exn)
                    var
                     d =
                       Ppx_expect_runtime_Expectation[7].call
                        (null, formatting_flexibility, trailing_loc, expected_exn),
                     exn_test = Ppx_expect_runtime_Test_node[2].call(null, d);
                   else
                    var
                     e =
                       Ppx_expect_runtime_Expectation[9].call
                        (null, [0, trailing_loc, body_loc]),
                     exn_test = Ppx_expect_runtime_Test_node[2].call(null, e);
                   var
                    expectations$0 =
                      [0,
                       [0, exn_test_id, exn_test],
                       [0, [0, test_to_run, trailing_test], expectations]],
                    expectations$1 =
                      caml_call3
                       (Ppx_expect_runtime_Test_node[5][1],
                        absolute_filename,
                        expectations$0,
                        function(original_file_contents, ts){
                         var
                          a =
                            caml_call3
                             (Ppx_expect_runtime_Test_node[6][4],
                              Configured$0[3],
                              Ppx_expect_runtime_Types[1][1],
                              original_file_contents);
                         return Base_List[14].call(null, ts, a);
                        });
                   flush(0);
                   var
                    b =
                      Stdlib_Filename[16].call
                       (null, 0, cst_expect_test, cst_output),
                    output_file =
                      Ppx_expect_runtime_Current_fil[5].call(null, b),
                    test_output_writer =
                      Stdlib[62].call(null, a, 420, output_file),
                    test_output_reader = Stdlib[80].call(null, output_file);
                   runtime.ppx_expect_runtime_before_test
                    (test_output_writer, Stdlib[39], Stdlib[40]);
                   var
                    test_block =
                      [0,
                       absolute_filename,
                       output_file,
                       [0, 0],
                       test_output_reader,
                       test_output_writer,
                       [0, 0]],
                    t = [0, line_number, basename, location, test_block];
                   test_is_running[1] = [0, t];
                   var
                    test_exn =
                      Configured$0[6].call
                       (null,
                        function(param){
                         read_test_output_unsanitized(test_block);
                         return caml_call1(f, 0);
                        }),
                    trailing_raw = read_test_output_sanitized_and(0),
                    trailing_output =
                      Base_String[109].call(null, 0, trailing_raw) !== cst$4
                       ? [0, trailing_raw]
                       : 0;
                   if(test_exn){
                    var test_exn$0 = test_exn[1];
                    if(trailing_output)
                     var
                      trailing_output$0 = trailing_output[1],
                      test_to_run$0 = exn_test_id,
                      test_output =
                        Base_String[68].call
                         (null,
                          m,
                          [0,
                           test_exn$0,
                           [0,
                            cst_Trailing_output,
                            [0, cst$1, [0, trailing_output$0, 0]]]]);
                    else
                     var test_to_run$0 = exn_test_id, test_output = test_exn$0;
                   }
                   else
                    var
                     test_output$0 =
                       Base_Option[30].call(null, trailing_output, cst$2),
                     test_to_run$0 = test_to_run,
                     test_output = test_output$0;
                   run_test_inner(test_to_run$0, test_output, test_block);
                   Base_List[19].call
                    (null,
                     expectations$1,
                     function(param){
                      var test_node = param[2];
                      return Ppx_expect_runtime_Test_node[3].call(null, test_node);
                     });
                   clean_up_block(test_block);
                   test_is_running[1] = 0;
                   return 1;
                  });
        }
        return [0, read_test_output_no_backtrace_, run_test, run_suite];
       },
       For_external,
       at_exit];
   runtime.caml_register_global
    (48, Ppx_expect_runtime_Test_block, "Ppx_expect_runtime__Test_block");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime
//# unitInfo: Requires: CamlinternalLazy, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Write_corrected_file, Ppx_inline_test_lib, Stdlib, Stdlib__Sys
//# shape: Ppx_expect_runtime:[[F(1),F(1)],[]]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_expect_runtime_Write_corre =
      global_data.Ppx_expect_runtime__Write_corrected_file,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Stdlib = global_data.Stdlib;
   Ppx_inline_test_lib[16].call
    (null,
     function(param){
      var a = Ppx_expect_runtime_Current_fil[4], b = runtime.caml_obj_tag(a);
      a:
      if(250 === b)
       var c = a[1];
      else{
       if(246 !== b && 244 !== b){var c = a; break a;}
       var c = CamlinternalLazy[2].call(null, a);
      }
      runtime.caml_sys_chdir(c);
      var
       d =
         caml_call1
          (Ppx_expect_runtime_Test_node[5][3],
           function(filename, test_nodes, postprocess){
            var
             a = Ppx_inline_test_lib[14].call(null, 0),
             b = Ppx_inline_test_lib[13].call(null, 0),
             c = Ppx_inline_test_lib[12].call(null, 0),
             d = Ppx_inline_test_lib[11].call(null, 0);
            return Ppx_expect_runtime_Write_corre[2].call
                    (null, d, c, b, a, filename, postprocess, test_nodes);
           });
      return caml_call1(Ppx_inline_test_lib[5][2], d);
     });
   Stdlib[100].call(null, Ppx_expect_runtime_Test_block[3]);
   var
    Current_file =
      [0,
       Ppx_expect_runtime_Current_fil[1],
       Ppx_expect_runtime_Current_fil[2]],
    Test_node = [0],
    Ppx_expect_runtime = [0, Current_file, Test_node];
   runtime.caml_register_global(7, Ppx_expect_runtime, "Ppx_expect_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHB4X2V4cGVjdF9ydW50aW1lLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiUHB4X2V4cGVjdF9ydW50aW1lIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUEsdUJBQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvdHlwZXMubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBDb21wYWN0X2xvYyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3RhcnRfYm9sIDogaW50XG4gICAgOyBzdGFydF9wb3MgOiBpbnRcbiAgICA7IGVuZF9wb3MgOiBpbnRcbiAgICB9XG5cbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgYS5zdGFydF9ib2wgPSBiLnN0YXJ0X2JvbCAmJiBhLnN0YXJ0X3BvcyA9IGIuc3RhcnRfcG9zICYmIGEuZW5kX3BvcyA9IGIuZW5kX3Bvc1xuICA7O1xuXG4gIGxldCBjb21wYXJlX2NoYXJhY3Rlcl9yYW5nZSA9XG4gICAgQ29tcGFyYWJsZS5sZXhpY29ncmFwaGljXG4gICAgICBbIENvbXBhcmFibGUubGlmdCBjb21wYXJlX2ludCB+ZjooZnVuIHQgLT4gdC5zdGFydF9wb3MpXG4gICAgICA7IENvbXBhcmFibGUubGlmdCBjb21wYXJlX2ludCB+ZjooZnVuIHQgLT4gdC5lbmRfcG9zKVxuICAgICAgXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBpbmRlbnQgOiBpbnRcbiAgICA7IGFsd2F5c19vbl9vd25fbGluZSA6IGJvb2xcbiAgICA7IGV4dGVuc2lvbl9zaWdpbCA6IHN0cmluZ1xuICAgIDsgYXR0cmlidXRlX3NpZ2lsIDogc3RyaW5nXG4gICAgfVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICB7IGluZGVudCA9IDJcbiAgICA7IGFsd2F5c19vbl9vd25fbGluZSA9IGZhbHNlXG4gICAgOyBleHRlbnNpb25fc2lnaWwgPSBcIiVcIlxuICAgIDsgYXR0cmlidXRlX3NpZ2lsID0gXCJAQFwiXG4gICAgfVxuICA7O1xuXG4gIG1vZHVsZSBGbGV4aWJpbGl0eSA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPVxuICAgICAgfCBGbGV4aWJsZV9tb2R1bG8gb2YgdFxuICAgICAgfCBFeGFjdGx5X2Zvcm1hdHRlZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVmlydHVhbF9sb2MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGxvYyA6IENvbXBhY3RfbG9jLnRcbiAgICA7IGJvZHlfbG9jIDogQ29tcGFjdF9sb2MudFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgRXhwZWN0YXRpb25faWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgbWludCA9XG4gICAgbGV0IGNvdW50ZXIgPSByZWYgMCBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgbGV0IGlkID0gIWNvdW50ZXIgaW5cbiAgICAgIGNvdW50ZXIgOj0gaWQgKyAxO1xuICAgICAgaWRcbiAgOztcbmVuZFxuXG5tb2R1bGUgU3RyaW5nX25vZGVfZm9ybWF0ID0gc3RydWN0XG4gIHR5cGUgbG9uZ2hhbmQgPSBMb25naGFuZFxuICB0eXBlIHNob3J0aGFuZCA9IFNob3J0aGFuZFxuXG4gIG1vZHVsZSBIYW5kID0gc3RydWN0XG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBMb25naGFuZCA6IGxvbmdoYW5kIHRcbiAgICAgIHwgU2hvcnRoYW5kIDogc2hvcnRoYW5kIHRcbiAgZW5kXG5cbiAgbW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdCA9XG4gICAgICB8IEF0dHJpYnV0ZSA6IGxvbmdoYW5kIHRcbiAgICAgIHwgRXh0ZW5zaW9uIDogXyB0XG4gIGVuZFxuXG4gIG1vZHVsZSBTaGFwZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2hhbmQgdW5wYWNrZWQgPVxuICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICA7IGhhbmQgOiAnaGFuZCBIYW5kLnRcbiAgICAgIDsga2luZCA6ICdoYW5kIEtpbmQudFxuICAgICAgfVxuXG4gICAgdHlwZSB0ID0gVCA6IF8gdW5wYWNrZWQgLT4gdCBbQEB1bmJveGVkXVxuICBlbmRcblxuICBtb2R1bGUgRGVsaW1pdGVyID0gc3RydWN0XG4gICAgdHlwZSBfIHVucGFja2VkID1cbiAgICAgIHwgUXVvdGUgOiBsb25naGFuZCB1bnBhY2tlZFxuICAgICAgfCBUYWcgOiBzdHJpbmcgLT4gXyB1bnBhY2tlZFxuXG4gICAgdHlwZSB0ID0gVCA6IF8gdW5wYWNrZWQgLT4gdCBbQEB1bmJveGVkXVxuXG4gICAgbGV0IGRlZmF1bHQgPSBUIChUYWcgXCJcIilcblxuICAgIGxldCBsb25naGFuZCA9IGZ1bmN0aW9uXG4gICAgICB8IFQgKChRdW90ZSB8IFRhZyBfKSBhcyB1bnBhY2tlZCkgLT4gdW5wYWNrZWRcbiAgICA7O1xuXG4gICAgbGV0IHNob3J0aGFuZCA9IGZ1bmN0aW9uXG4gICAgICB8IFQgKFRhZyBfIGFzIHVucGFja2VkKSAtPiB1bnBhY2tlZFxuICAgICAgfCBUIFF1b3RlIC0+IFRhZyBcIlwiXG4gICAgOztcblxuICAgIGxldCBoYW5kZWQgOiB0eXBlIGEuIHQgLT4gYSBIYW5kLnQgLT4gYSB1bnBhY2tlZCA9XG4gICAgICBmdW4gdCBoYW5kIC0+XG4gICAgICBtYXRjaCBoYW5kIHdpdGhcbiAgICAgIHwgTG9uZ2hhbmQgLT4gbG9uZ2hhbmQgdFxuICAgICAgfCBTaG9ydGhhbmQgLT4gc2hvcnRoYW5kIHRcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHVucGFja2VkID1cbiAgICB7IHNoYXBlIDogJ2EgU2hhcGUudW5wYWNrZWRcbiAgICA7IGRlbGltaXRlciA6ICdhIERlbGltaXRlci51bnBhY2tlZFxuICAgIH1cblxuICB0eXBlIHQgPSBUIDogXyB1bnBhY2tlZCAtPiB0IFtAQHVuYm94ZWRdXG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiZ2xvYmFsX2RhdGEiLCJkZWZhdWx0JCIsIkJhc2UiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX0ludCIsImVxdWFsIiwiYSIsImIiLCJ0IiwiY29tcGFyZV9jaGFyYWN0ZXJfcmFuZ2UiLCJDb21wYWN0X2xvYyIsIkZsZXhpYmlsaXR5IiwiRXhwZWN0X25vZGVfZm9ybWF0dGluZyIsIlZpcnR1YWxfbG9jIiwib2ZfaW50X2V4biIsInRvX2ludF9leG4iLCJoYXNoIiwic2V4cF9vZl90IiwiY29tcGFyZSIsImNvdW50ZXIiLCJtaW50IiwicGFyYW0iLCJpZCIsIkhhbmQiLCJLaW5kIiwiU2hhcGUiLCJoYW5kZWQiLCJoYW5kIiwiUHB4X2V4cGVjdF9ydW50aW1lX1R5cGVzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFBLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FBQUM7QUFBQUEsUUFBQSxJQ1VJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQStFO0FBQUEsY0FBQUMsR0FNbEMsWUFBUztBQUFBLFdBQWxEO0FBQUEsY0FBQUEsR0FEeUMsWUFBVztBQUFBO0FBQUEsUUFBcEQ7QUFBQTtBQUFBO0FBQUEsTUFESjtBQUFBLHNCQUNJO0FBQUEsMEJBQ0E7QUFBQSxRQUZKO0FBQUEsWUFBQUMsd0JBQUE7QUFBQTtBQUFBLElBQUFDLGNBR0c7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsUUFBQUMsS0F3Q0Q7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEdBQUU7QUFBQSxPQUFBQyxPQUhKLEtBQUFDLE9BQUEsS0FBQUMsUUFBQTtBQUFBLFlBQUFDLE9BQUFsQixHQUFBbUIsTUFxREUsMkJBRTBCO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQXZENUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR4REoiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvd3JpdGVfY29ycmVjdGVkX2ZpbGUubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5vcGVuIFR5cGVzXG5cbm1vZHVsZSBQYXRjaF93aXRoX2ZpbGVfY29udGVudHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gb3JpZ2luYWxfZmlsZV9jb250ZW50czpzdHJpbmcgLT4gJ2EgLT4gKENvbXBhY3RfbG9jLnQgKiBzdHJpbmcpIGxpc3RcbmVuZFxuXG5sZXQgcmV3cml0ZV9jb3JyZWN0aW9ucyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyB+Y29ycmVjdGlvbnMgPVxuICAoKiBFbnN1cmUgdGhhdCB3ZSBlbmNvdW50ZXIgdGhlIGNvcnJlY3Rpb25zIGluIG9yZGVyIGFzIHdlIGJ1aWxkIHVwIHRoZSBmaWxlLiAqKVxuICBsZXQgY29ycmVjdGlvbnMgPVxuICAgIExpc3Quc29ydFxuICAgICAgfmNvbXBhcmU6KENvbXBhcmFibGUubGlmdCBDb21wYWN0X2xvYy5jb21wYXJlX2NoYXJhY3Rlcl9yYW5nZSB+Zjpmc3QpXG4gICAgICBjb3JyZWN0aW9uc1xuICBpblxuICBsZXQgbF9wb3MsIHN0cnMgPVxuICAgIExpc3QuZm9sZF9tYXBcbiAgICAgIGNvcnJlY3Rpb25zXG4gICAgICB+aW5pdDowXG4gICAgICB+ZjooZnVuIGxfcG9zICh7IHN0YXJ0X3BvczsgZW5kX3Bvczsgc3RhcnRfYm9sID0gXyB9LCBjb3JyZWN0aW9uKSAtPlxuICAgICAgbGV0IGNvZGVfY2h1bmsgPVxuICAgICAgICBTdHJpbmcuc3ViIG9yaWdpbmFsX2ZpbGVfY29udGVudHMgfnBvczpsX3BvcyB+bGVuOihzdGFydF9wb3MgLSBsX3BvcylcbiAgICAgIGluXG4gICAgICBlbmRfcG9zLCBbIGNvZGVfY2h1bms7IGNvcnJlY3Rpb24gXSlcbiAgaW5cbiAgbGV0IHJlc3VsdCA9IExpc3QuY29uY2F0IHN0cnMgfD4gU3RyaW5nLmNvbmNhdCBpblxuICBsZXQgcmVzdCA9IFN0cmluZy5zdWJvIG9yaWdpbmFsX2ZpbGVfY29udGVudHMgfnBvczpsX3BvcyBpblxuICByZXN1bHQgXiByZXN0XG47O1xuXG5sZXQgZiB+dXNlX2NvbG9yIH5pbl9wbGFjZSB+ZGlmZl9jb21tYW5kIH5kaWZmX3BhdGhfcHJlZml4IH5maWxlbmFtZSB+d2l0aF8gY29ycmVjdGlvbnNcbiAgOiBQcHhfaW5saW5lX3Rlc3RfbGliLlRlc3RfcmVzdWx0LnRcbiAgPVxuICBsZXQgZG90X2NvcnJlY3RlZCA9IGZpbGVuYW1lIF4gXCIuY29ycmVjdGVkXCIgaW5cbiAgbGV0IG9yaWdpbmFsX2ZpbGVfY29udGVudHMgPVxuICAgIGxldCBpbl9jaGFubmVsID0gU3RkbGliLm9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gICAgbGV0IGNvbnRlbnRzID1cbiAgICAgIFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIGluX2NoYW5uZWwgKFN0ZGxpYi5pbl9jaGFubmVsX2xlbmd0aCBpbl9jaGFubmVsKVxuICAgIGluXG4gICAgU3RkbGliLmNsb3NlX2luIGluX2NoYW5uZWw7XG4gICAgY29udGVudHNcbiAgaW5cbiAgbGV0IHJlbW92ZSBmaWxlID0gaWYgU3RkbGliLlN5cy5maWxlX2V4aXN0cyBmaWxlIHRoZW4gU3RkbGliLlN5cy5yZW1vdmUgZmlsZSBpblxuICBsZXQgY29ycmVjdGlvbnMgPSB3aXRoXyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyBjb3JyZWN0aW9ucyBpblxuICBsZXQgbmV4dF9jb250ZW50cyA9IHJld3JpdGVfY29ycmVjdGlvbnMgfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgfmNvcnJlY3Rpb25zIGluXG4gIG1hdGNoIGluX3BsYWNlIHdpdGhcbiAgfCB0cnVlIC0+XG4gICAgaWYgbm90IChTdHJpbmcuZXF1YWwgb3JpZ2luYWxfZmlsZV9jb250ZW50cyBuZXh0X2NvbnRlbnRzKVxuICAgIHRoZW4gU3RkaW8uT3V0X2NoYW5uZWwud3JpdGVfYWxsIGZpbGVuYW1lIH5kYXRhOm5leHRfY29udGVudHM7XG4gICAgcmVtb3ZlIGRvdF9jb3JyZWN0ZWQ7XG4gICAgU3VjY2Vzc1xuICB8IGZhbHNlIC0+XG4gICAgKG1hdGNoIGRpZmZfY29tbWFuZCB3aXRoXG4gICAgIHwgU29tZSBcIi1cIiAoKiBKdXN0IHdyaXRlIHRoZSAuY29ycmVjdGVkIGZpbGUgLSBkbyBub3Qgb3V0cHV0IGEgZGlmZi4gKikgLT5cbiAgICAgICBTdGRpby5PdXRfY2hhbm5lbC53cml0ZV9hbGwgZG90X2NvcnJlY3RlZCB+ZGF0YTpuZXh0X2NvbnRlbnRzO1xuICAgICAgIFN1Y2Nlc3NcbiAgICAgfCBfIC0+XG4gICAgICAgKCogQnkgaW52b2tpbmcgW01ha2VfY29ycmVjdGVkX2ZpbGUuZl0gd2l0aCBhIGZyZXNoIHRlbXBvcmFyeSBmaWxlLCB3ZSBhdm9pZCB0aGVcbiAgICAgICAgICBmb2xsb3dpbmcgcG9zc2libGUgcmFjZSBiZXR3ZWVuIGlubGluZV90ZXN0X3J1bm5lcnMgQSBhbmQgQjpcbiAgICAgICAgICAxLiBBIHJ1bnMgdGVzdCBUMSBhbmQgZ2VuZXJhdGVzIG5leHQgY29udGVudHMgQzEuXG4gICAgICAgICAgMi4gQiBydW5zIHRlc3QgVDIgYW5kIGdlbmVyYXRlcyBuZXh0IGNvbnRlbnRzIEMyLlxuICAgICAgICAgIDMuIEEgd3JpdGVzIEMxIHRvIHRoZSAuY29ycmVjdGVkIGZpbGUuXG4gICAgICAgICAgNC4gQiB3cml0ZXMgQzIgdG8gdGhlIC5jb3JyZWN0ZWQgZmlsZS5cbiAgICAgICAgICA1LiBBIGRpZmZzIHRoZSAuY29ycmVjdGVkIGZpbGUgYWdhaW5zdCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQgcmVwb3J0cyB0aGVcbiAgICAgICAgICByZXN1bHQuIEl0IHRoaW5rcyBpdCBpcyByZXBvcnRpbmcgdGhlIGRpZmYgcHJvZHVjZWQgYnkgVDEsIGJ1dCBpcyBpbiBmYWN0XG4gICAgICAgICAgcmVwb3J0aW5nIHRoZSBkaWZmIHByb2R1Y2VkIGJ5IFQyLiBUaGUga2V5IGFzcGVjdCBvZiB1c2luZyB0ZW1wb3JhcnkgZmlsZXMgaXNcbiAgICAgICAgICB0aGF0IGV2ZW4gaWYgaW4gdGhlIGFib3ZlIHNjZW5hcmlvIHRoZSBmaW5hbCBjb250ZW50cyBvZiB0aGUgLmNvcnJlY3RlZCBmaWxlXG4gICAgICAgICAgYXJlIEMyLCB0aGUgZGlmZiByZXBvcnRlZCBieSBBIGNvbWVzIGZyb20gaXRzIHRtcCBmaWxlIGFuZCB3aWxsIHN0aWxsIGJlIHRoZVxuICAgICAgICAgIGRpZmYgcHJvZHVjZWQgYnkgVDEuICopXG4gICAgICAgbGV0IHRtcF9jb3JyZWN0ZWQgPVxuICAgICAgICAgU3RkbGliLkZpbGVuYW1lLnRlbXBfZmlsZVxuICAgICAgICAgICAoU3RkbGliLkZpbGVuYW1lLmJhc2VuYW1lIGZpbGVuYW1lKVxuICAgICAgICAgICBcIi5jb3JyZWN0ZWQudG1wXCJcbiAgICAgICAgICAgfnRlbXBfZGlyOihTdGRsaWIuRmlsZW5hbWUuZGlybmFtZSBmaWxlbmFtZSlcbiAgICAgICBpblxuICAgICAgIChtYXRjaFxuICAgICAgICAgIE1ha2VfY29ycmVjdGVkX2ZpbGUuZlxuICAgICAgICAgICAgfnVzZV9jb2xvclxuICAgICAgICAgICAgP2RpZmZfY29tbWFuZFxuICAgICAgICAgICAgP2RpZmZfcGF0aF9wcmVmaXhcbiAgICAgICAgICAgIH5jb3JyZWN0ZWRfcGF0aDp0bXBfY29ycmVjdGVkXG4gICAgICAgICAgICB+bmV4dF9jb250ZW50c1xuICAgICAgICAgICAgfnBhdGg6ZmlsZW5hbWVcbiAgICAgICAgICAgICgpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBPayBfIC0+XG4gICAgICAgICAgKCogRXZlbiB0aG91Z2ggdGhpcyBleGVjdXRpb24gb2YgdGhlIGV4cGVjdCB0ZXN0IHJhbiB3aXRob3V0IG1ha2luZ1xuICAgICAgICAgICAgIGNvcnJlY3Rpb25zLCB3ZSBzaG91bGQgZGVsZXRlIGFueSBvbGQgWy5jb3JyZWN0ZWRdIGZpbGVzIHRoYXQgYXJlIGxlZnQgb3ZlclxuICAgICAgICAgICAgIGZyb20gcHJldmlvdXMgYnVpbGRzLiBJbiBwYXJ0aWN1bGFyLCBoeWRyYSByZWxpZXMgb24gdGhpcyBiZWhhdmlvciBmb3JcbiAgICAgICAgICAgICBmbGFreSB0ZXN0czsgaWYgdGhlIHRlc3QgZmFpbHMgdGhlIGZpcnN0IHRpbWUgYW5kIHBhc3NlcyB0aGUgc2Vjb25kLCB0aGVcbiAgICAgICAgICAgICBzZWNvbmQgcnVuIHNob3VsZCBtYWtlIHN1cmUgdGhlIFsuY29ycmVjdGVkXSBmaWxlIGlzIG5vdCBsaW5nZXJpbmcgaW4gdGhlXG4gICAgICAgICAgICAgc2FuZGJveC4gKilcbiAgICAgICAgICByZW1vdmUgZG90X2NvcnJlY3RlZDtcbiAgICAgICAgICByZW1vdmUgdG1wX2NvcnJlY3RlZDtcbiAgICAgICAgICBTdWNjZXNzXG4gICAgICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAgIFN0ZGxpYi5TeXMucmVuYW1lIHRtcF9jb3JyZWN0ZWQgZG90X2NvcnJlY3RlZDtcbiAgICAgICAgICBGYWlsdXJlKSlcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDIiLCJmIiwiYTAiLCJhMSIsImdsb2JhbF9kYXRhIiwiQmFzZSIsIlN0ZGxpYiIsIkJhc2VfU3RyaW5nIiwiU3RkaW9fT3V0X2NoYW5uZWwiLCJTdGRsaWJfRmlsZW5hbWUiLCJNYWtlX2NvcnJlY3RlZF9maWxlIiwiUHB4X2V4cGVjdF9ydW50aW1lX1R5cGVzIiwiQmFzZV9Db21wYXJhYmxlIiwiQmFzZV9MaXN0IiwiUGF0Y2hfd2l0aF9maWxlX2NvbnRlbnRzIiwiY3N0X2NvcnJlY3RlZCIsImNzdF9jb3JyZWN0ZWRfdG1wIiwiZHVtbXkiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsImRpZmZfcGF0aF9wcmVmaXgiLCJmaWxlbmFtZSIsIndpdGgkIiwiY29ycmVjdGlvbnMiLCJkb3RfY29ycmVjdGVkIiwiaW5fY2hhbm5lbCIsIm9yaWdpbmFsX2ZpbGVfY29udGVudHMiLCJyZW1vdmUiLCJmaWxlIiwibWF0Y2giLCJsX3BvcyIsInBhcmFtIiwiY29ycmVjdGlvbiIsImVuZF9wb3MiLCJzdGFydF9wb3MiLCJjb2RlX2NodW5rIiwic3RycyIsInJlc3VsdCIsInJlc3QiLCJuZXh0X2NvbnRlbnRzIiwidG1wX2NvcnJlY3RlZCIsIlBweF9leHBlY3RfcnVudGltZV9Xcml0ZV9jb3JyZSJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsWUFBQWhCO0FBQUFBLElBQUFpQjtBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxnQkNnQ3NCO0FBQUEsS0FBQUMsYUFFRDtBQUFBLFNBRXVCO0FBQUEsS0FBQUMseUJBQXRDO0FBQUEsSUFFRjtBQUFBLGFBQUFDLE9BQUFDO0FBQUFBLEtBR21CLHVDQUFpQztBQUFBLElBQXNCO0FBQUE7QUFBQSxLQUFBTCxnQkFDMUQ7QUFBQSxTQS9CTDtBQUFBO0FBQUE7QUFBQSxLQUFBQTtBQUFBQSxPQURYO0FBQUEsNkNBQ1c7QUFBQSxLQUFBTTtBQUFBQSxPQUlYO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQUFDLE9BQUFDO0FBQUFBO0FBQUFBLFdBQUFDLGFBR0s7QUFBQSxXQUFBSCxRQUFBO0FBQUEsV0FBQUksVUFBQTtBQUFBLFdBQUFDLFlBQUE7QUFBQSxXQUFBQztBQUFBQSxhQUVEO0FBQUE7QUFBQSxVQUVGO0FBQUEsU0FBb0M7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQU4sUUFBQTtBQUFBLFNBRTNCO0FBQUEsS0FBQU8sU0FBQTtBQUFBLEtBQUFDLE9BQ0Y7QUFBQSxLQUFBQyxnQkFDWDtBQUFBLElBa0JBO0FBQUEsS0FFUztBQUFBO0FBQUEsTUFDRjtBQUFBLEtBQ0w7QUFBQSxLQUFvQjtBQUFBO0FBQUEsSUFHcEI7QUFBQSxLQUVHO0FBQUEsS0FBNkQ7QUFBQTtBQUFBO0FBQUEsU0FpQnpEO0FBQUEsU0FFVTtBQUFBLEtBQUFDLGdCQUhaO0FBQUEsSUFNQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBZ0JBLHVCQUNBO0FBQUEsZUFHQSx5REFDUztBQUFBO0FBQUEsT0FBQUMsaUNEaEduQiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvb3V0cHV0Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuXG5tb2R1bGUgVHlwZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRXhhY3RcbiAgICB8IFByZXR0eVxuZW5kXG5cbm1vZHVsZSBSZWNvbmNpbGVkID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZV9zdHJpbmdcbmVuZFxuXG5tb2R1bGUgRm9ybWF0dGVkID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuZW5kXG5cbm1vZHVsZSBGb3JtYXR0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIC0+IEZvcm1hdHRlZC50XG5cbiAgbGV0IGNyZWF0ZSBmb3JtYXQgPSBmb3JtYXRcbiAgbGV0IGFwcGx5IGZvcm1hdCBzdHIgPSBmb3JtYXQgc3RyXG5lbmRcblxubW9kdWxlIFRlc3RfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBQYXNzXG4gICAgfCBGYWlsIG9mIFJlY29uY2lsZWQudFxuXG4gIGxldCBjb21wYXJlIGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBQYXNzLCBQYXNzIC0+IDBcbiAgICB8IFBhc3MsIF8gLT4gLTFcbiAgICB8IF8sIFBhc3MgLT4gMVxuICAgIHwgRmFpbCBhLCBGYWlsIGIgLT4gUmVjb25jaWxlZC5jb21wYXJlIGEgYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQYXlsb2FkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBjb250ZW50cyA6IHN0cmluZ1xuICAgIDsgdGFnIDogU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50XG4gICAgfVxuXG4gIGxldCBkZWZhdWx0IGNvbnRlbnRzID0geyBjb250ZW50czsgdGFnID0gU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci5kZWZhdWx0IH1cblxuICBsZXQgdG9fc291cmNlX2NvZGVfc3RyaW5nIHsgY29udGVudHM7IHRhZyB9ID1cbiAgICBsZXQgZXNjYXBlX2xpbmVzIHRlc3Rfb3V0cHV0ID1cbiAgICAgIHRlc3Rfb3V0cHV0XG4gICAgICB8PiBTdHJpbmcuc3BsaXQgfm9uOidcXG4nXG4gICAgICB8PiBMaXN0Lm1hcCB+ZjpTdHJpbmcuZXNjYXBlZFxuICAgICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCJcbiAgICBpblxuICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgfCBUIChUYWcgdGFnKSAtPiBQcmludGYuc3ByaW50ZiBcInslc3wlc3wlc31cIiB0YWcgY29udGVudHMgdGFnXG4gICAgfCBUIFF1b3RlIC0+IFByaW50Zi5zcHJpbnRmIHt8XCIlc1wifH0gKGVzY2FwZV9saW5lcyBjb250ZW50cylcbiAgOztcbmVuZFxuXG5sZXQgcmVjb25jaWxlIH5leHBlY3RlZF9vdXRwdXQgfnRlc3Rfb3V0cHV0IDogVGVzdF9yZXN1bHQudCA9XG4gIGlmIFN0cmluZy5lcXVhbCBleHBlY3RlZF9vdXRwdXQgdGVzdF9vdXRwdXQgdGhlbiBQYXNzIGVsc2UgRmFpbCB0ZXN0X291dHB1dFxuOztcblxubGV0IGZhaWwgZXJyb3Jfb3V0cHV0IDogVGVzdF9yZXN1bHQudCA9IEZhaWwgZXJyb3Jfb3V0cHV0XG5cbmxldCBmaXhfZGVsaW1pdGVyX2NvbmZsaWN0c1xuICAodHlwZSBoYW5kZWRuZXNzKVxuICB+Y29udGVudHNcbiAgfihkZWxpbWl0ZXIgOiBoYW5kZWRuZXNzIFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudW5wYWNrZWQpXG4gIDogaGFuZGVkbmVzcyBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnVucGFja2VkXG4gID1cbiAgbGV0IHJlYyBmaXhfdGFnX2NvbmZsaWN0cyB+Y29udGVudHMgfnRhZyA9XG4gICAgbGV0IHRhZ19jb25mbGljdHNfd2l0aCBmc3RyID1cbiAgICAgIFN0cmluZy5pc19zdWJzdHJpbmcgfnN1YnN0cmluZzooUHJpbnRmLnNwcmludGYgZnN0ciB0YWcpIGNvbnRlbnRzXG4gICAgaW5cbiAgICBpZiB0YWdfY29uZmxpY3RzX3dpdGggXCJ7JXN8XCIgfHwgdGFnX2NvbmZsaWN0c193aXRoIFwifCVzfVwiXG4gICAgdGhlbiBmaXhfdGFnX2NvbmZsaWN0cyB+Y29udGVudHMgfnRhZzoodGFnIF4gXCJ4eHhcIilcbiAgICBlbHNlIHRhZ1xuICBpblxuICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICB8IFF1b3RlIC0+IFF1b3RlXG4gIHwgVGFnIHRhZyAtPiBUYWcgKGZpeF90YWdfY29uZmxpY3RzIH5jb250ZW50cyB+dGFnKVxuOztcblxubGV0IHRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWc6KFQgZGVsaW1pdGVyIDogU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50KSBjb250ZW50c1xuICA6IFBheWxvYWQudFxuICA9XG4gIHsgY29udGVudHM7IHRhZyA9IFQgKGZpeF9kZWxpbWl0ZXJfY29uZmxpY3RzIH5jb250ZW50cyB+ZGVsaW1pdGVyKSB9XG47O1xuXG5sZXQgdG9fc291cmNlX2NvZGVfc3RyaW5nXG4gIH4oZXhwZWN0X25vZGVfZm9ybWF0dGluZyA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudClcbiAgfm5vZGVfc2hhcGU6KFQgc2hhcGUgOiBTdHJpbmdfbm9kZV9mb3JtYXQuU2hhcGUudClcbiAgfih0YWcgOiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnQpXG4gIGNvbnRlbnRzXG4gID1cbiAgbGV0IGRlbGltaXRlciA9XG4gICAgZml4X2RlbGltaXRlcl9jb25mbGljdHNcbiAgICAgIH5jb250ZW50c1xuICAgICAgfmRlbGltaXRlcjooU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci5oYW5kZWQgdGFnIHNoYXBlLmhhbmQpXG4gIGluXG4gIGxldCBwYXlsb2FkIDogUGF5bG9hZC50ID0geyBjb250ZW50czsgdGFnID0gVCBkZWxpbWl0ZXIgfSBpblxuICBtYXRjaCBzaGFwZS5oYW5kIHdpdGhcbiAgfCBMb25naGFuZCAtPlxuICAgIGxldCBwcmVmaXggPVxuICAgICAgbWF0Y2ggc2hhcGUua2luZCB3aXRoXG4gICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmV4dGVuc2lvbl9zaWdpbFxuICAgICAgfCBBdHRyaWJ1dGUgLT4gZXhwZWN0X25vZGVfZm9ybWF0dGluZy5hdHRyaWJ1dGVfc2lnaWxcbiAgICBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiWyVzJXMgJXNdXCIgcHJlZml4IHNoYXBlLm5hbWUgKFBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nIHBheWxvYWQpXG4gIHwgU2hvcnRoYW5kIC0+XG4gICAgbGV0IHByZWZpeCA9XG4gICAgICBtYXRjaCBzaGFwZS5raW5kIHdpdGhcbiAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZXh0ZW5zaW9uX3NpZ2lsXG4gICAgaW5cbiAgICAobWF0Y2ggZGVsaW1pdGVyIHdpdGhcbiAgICAgfCBUYWcgXCJcIiAtPiBQcmludGYuc3ByaW50ZiBcInslcyVzfCVzfH1cIiBwcmVmaXggc2hhcGUubmFtZSBjb250ZW50c1xuICAgICB8IFRhZyB0YWcgLT4gUHJpbnRmLnNwcmludGYgXCJ7JXMlcyAlc3wlc3wlc31cIiBwcmVmaXggc2hhcGUubmFtZSB0YWcgY29udGVudHMgdGFnKVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJQcHhfZXhwZWN0X3J1bnRpbWVfVHlwZXMiLCJCYXNlX1ByaW50ZiIsIkJhc2VfU3RyaW5nIiwiQmFzZSIsIkJhc2VfTGlzdCIsIlR5cGUiLCJjb21wYXJlIiwiRm9ybWF0dGVkIiwiY3JlYXRlIiwiZm9ybWF0IiwiYXBwbHkiLCJzdHIiLCJGb3JtYXR0ZXIiLCJhIiwiYiIsIlRlc3RfcmVzdWx0IiwiZGVmYXVsdCQiLCJjb250ZW50cyIsInRvX3NvdXJjZV9jb2RlX3N0cmluZyIsInBhcmFtIiwidGFnIiwidGVzdF9vdXRwdXQiLCJQYXlsb2FkIiwiY3N0X3h4eCIsInJlY29uY2lsZSIsImV4cGVjdGVkX291dHB1dCIsImZhaWwiLCJlcnJvcl9vdXRwdXQiLCJmaXhfZGVsaW1pdGVyX2NvbmZsaWN0cyIsImRlbGltaXRlciIsInRhZ19jb25mbGljdHNfd2l0aCIsImZzdHIiLCJ0b19mb3JtYXR0ZWRfcGF5bG9hZCIsImV4cGVjdF9ub2RlX2Zvcm1hdHRpbmciLCJzaGFwZSIsInBheWxvYWQiLCJwcmVmaXgiLCJQcHhfZXhwZWN0X3J1bnRpbWVfT3V0cHV0Il0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxZQUFBQyxPQUFBQyxRQ3NCc0IsY0FBTTtBQUFBLFlBQUFDLE1BQUFELFFBQUFFLEtBQ0gsOEJBQVU7QUFBQSxPQUFBQyxZRHZCbkM7QUFBQSxZQUFBTixVQUFBTyxHQUFBQztBQUFBQSxJQ2dDSSx5QkFJMEM7QUFBQSxJQUoxQyxRQUdhO0FBQUEsUUFBQUEsTUFIYixNQUFBRCxNQUFBO0FBQUEsSUFJb0Isd0JBQXNCO0FBQUE7QUFBQTtBQUFBLElBQUFFLGNEcEM5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFNBQUFDO0FBQUFBLElDOEN5QjtBQUFBLEdBQXdEO0FBQUEsWUFBQUMsc0JBQUFDO0FBQUFBLFFBQUFDLE1BRXJELFVBQUFDLGNBQUE7QUFBQSxJQU94QjtBQUFBLFNBQUFELFFBQUE7QUFBQSxLQUNpQjtBQUFBLHNFQUMyQztBQUFBO0FBQUE7QUFBQSxTQVAxRDtBQUFBO0FBQUEsU0FHRztBQUFBLElBSXVEO0FBQUE7QUFBQTtBQUFBLElBQUFFLFVEekRoRTtBQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsVUFBQUMsaUJBQUFKO0FBQUFBLElDOERLO0FBQUE7QUFBQSw4QkFBd0U7QUFBQTtBQUFBLFlBQUFLLEtBQUFDLGNBR3JDLHlCQUFpQjtBQUFBLFlBQUFDLHdCQUFBWCxVQUFBWTtBQUFBQSxJQWdCdkQsZ0JBQ1c7QUFBQSxRQUFBVCxRQURYLGNBQUFBLE1BRWlCO0FBQUE7QUFBQSxTQUFBQSxRQVRmO0FBQUE7QUFBQSxNQUFBVTtBQUFBQSxRQUFBLFNBQUFDO0FBQUFBLGFBQUEsSUFDaUM7QUFBQSxTQUF5Qiw4Q0FBUztBQUFBO0FBQUEsS0FFaEUsZ0NBQTZCLHVCQU1pQjtBQUFBLFNBQUFYLFFBTFg7QUFBQSxLQUFhO0FBQUE7QUFBQSxHQUtGO0FBQUEsWUFBQVkscUJBQUFiLE9BQUFGO0FBQUFBLElBTS9CLDhEQUE4QztBQUFBLEdBQUU7QUFBQSxZQUFBQztBQUFBQSxJQUFBZSx3QkFBQUMsT0FBQWQsS0FBQUg7QUFBQUE7QUFBQUEsS0FBQVk7QUFBQUEsT0FVbEU7QUFBQTtBQUFBLFNBRWE7QUFBQSxLQUFBTSxVQUVmO0FBQUEsSUFDQTtBQUFBO0FBQUEsTUFBQUM7QUFBQUEsUUFFRTtBQUFBLFVBSzZDO0FBQUEsVUFBdUM7QUFBQSxvRUFRRjtBQUFBO0FBQUEsUUFBQUEsU0FKakUsMkJBQUFoQixRQUVqQjtBQUFBO0FBQUEsYUFFYztBQUFBO0FBQUEsOEVBQW9FO0FBQUE7QUFBQSxZQURyRTtBQUFBLHdFQUNxRTtBQUFBO0FBQUE7QUFBQSxJQUFBaUI7QUFBQUEsTUR2SHRGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzY3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InBweF9leHBlY3RfcnVudGltZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJJbnNlcnRfbG9jIiwiQmVoYXZpb3JfdHlwZSIsIkV4cGVjdF9yZWFjaGFiaWxpdHkiLCJPbl91bnJlYWNoYWJsZSIsIkJlaGF2aW9yIiwiRGVmaW5pdGlvbnMiLCJQcHhfZXhwZWN0X3J1bnRpbWVfRXhwZWN0YXRpb24iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGlDQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mzk2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InBweF9leHBlY3RfcnVudGltZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL3BweF9leHBlY3QvcnVudGltZS9leHBlY3RhdGlvbi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcbmluY2x1ZGUgRXhwZWN0YXRpb25faW50Zi5EZWZpbml0aW9uc1xuXG5tb2R1bGUgSW5zZXJ0X2xvYyA9IHN0cnVjdFxuICBpbmNsdWRlIEluc2VydF9sb2NcblxuICBsZXQgbG9jID0gZnVuY3Rpb25cbiAgICB8IE92ZXJ3cml0ZSB7IHdob2xlX25vZGU7IHBheWxvYWQgPSBfIH0gLT4gd2hvbGVfbm9kZVxuICAgIHwgSW5zZXJ0IHsgbG9jOyBib2R5X2xvYyA9IF8gfSAtPiBsb2NcbiAgOztcbmVuZFxuXG5sZXQgd2l0aF9iZWhhdmlvclxuICB7IHBvc2l0aW9uXG4gIDsgYmVoYXZpb3IgPSBfXG4gIDsgcGF5bG9hZF90eXBlXG4gIDsgb25faW5jb3JyZWN0X291dHB1dFxuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2VcbiAgfVxuICBiZWhhdmlvclxuICA9XG4gIHsgcG9zaXRpb247IGJlaGF2aW9yOyBwYXlsb2FkX3R5cGU7IG9uX2luY29ycmVjdF9vdXRwdXQ7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgfVxuOztcblxubGV0IGZvcm1hdHRlclxuICAodHlwZSBiZWhhdmlvcilcbiAgfihleHBlY3Rfbm9kZV9mb3JtYXR0aW5nIDogRXhwZWN0X25vZGVfZm9ybWF0dGluZy50KVxuICAoeyBwb3NpdGlvblxuICAgOyBiZWhhdmlvclxuICAgOyBwYXlsb2FkX3R5cGVcbiAgIDsgb25faW5jb3JyZWN0X291dHB1dCA9IFQgb25faW5jb3JyZWN0X291dHB1dFxuICAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gX1xuICAgfSA6XG4gICAgYmVoYXZpb3IgdClcbiAgPVxuICBsZXQgY291bnRfbGVhZGluZ19zcGFjZXMgbGluZSA9XG4gICAgbGluZSB8PiBTdHJpbmcudG9fbGlzdCB8PiBMaXN0LnRha2Vfd2hpbGUgfmY6KENoYXIuKCA9ICkgJyAnKSB8PiBMaXN0Lmxlbmd0aFxuICBpblxuICBPdXRwdXQuRm9ybWF0dGVyLmNyZWF0ZVxuICBAQFxuICBtYXRjaCBwYXlsb2FkX3R5cGUgd2l0aFxuICB8IEV4YWN0IC0+IEZuLmlkXG4gIHwgUHJldHR5IC0+XG4gICAgZnVuIHN0ciAtPlxuICAgICAgbGV0IGxpbmVzID1cbiAgICAgICAgKCogSW4gcHJldHR5IHBheWxvYWRzLCB3ZSBub3JtYWxpemUgYWxsIG5ld2xpbmVzIHRvIFsnXFxuJ10uIFtbJWV4cGVjdF9leGFjdCBcIlwiXV1cbiAgICAgICAgICAgY2FuIGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSB1c2VyIHdhbnRzIHRvIGluc3BlY3QgdGhlIHdoaXRlc3BhY2UgcHJvZHVjZWQgYnlcbiAgICAgICAgICAgdGhlaXIgb3V0cHV0IG1vcmUgY2xvc2VseS4gKilcbiAgICAgICAgbGV0IHN0cmlwcGVkID1cbiAgICAgICAgICBzdHJcbiAgICAgICAgICB8PiBTdHJpbmcuc3BsaXRfbGluZXNcbiAgICAgICAgICB8PiBMaXN0Lm1hcCB+ZjooU3RyaW5nLnJzdHJpcCB+ZHJvcDpDaGFyLmlzX3doaXRlc3BhY2UpXG4gICAgICAgICAgfD4gTGlzdC5kcm9wX3doaWxlIH5mOlN0cmluZy5pc19lbXB0eVxuICAgICAgICAgIHw+IExpc3QucmV2XG4gICAgICAgICAgfD4gTGlzdC5kcm9wX3doaWxlIH5mOlN0cmluZy5pc19lbXB0eVxuICAgICAgICAgIHw+IExpc3QucmV2XG4gICAgICAgIGluXG4gICAgICAgIGxldCBpbmRlbnRfYW5kX2NvbnRlbnRzID1cbiAgICAgICAgICBMaXN0Lm1hcCBzdHJpcHBlZCB+ZjooZnVuIGxpbmUgLT5cbiAgICAgICAgICAgICgqIFRoZSBsZWdhY3kgYmVoYXZpb3IgaXMgdG8gb25seSBjb3VudCB0aGUgbG9uZ2VzdCBwcmVmaXggb2YgYWN0dWFsIHNwYWNlc1xuICAgICAgICAgICAgICAgKFsnICddKSBmb3IgaW5kZW50YXRpb24sIGJ1dCB0byBzdHJpcCBhbGwgd2hpdGVzcGFjZSAoaW5jbHVkaW5nLCBlLmcuLFxuICAgICAgICAgICAgICAgWydcXHQnXSkuIE5vdGUgdGhhdCB0aGlzIG1lYW5zIFtcIiBcXHQgY29udGVudHNcIl0gaXMgY291bnRlZCBhcyBoYXZpbmdcbiAgICAgICAgICAgICAgIGNvbnRlbnRzIFtcImNvbnRlbnRzXCJdIGFuZCBpbmRlbnRhdGlvbiBbMV0uICopXG4gICAgICAgICAgICBjb3VudF9sZWFkaW5nX3NwYWNlcyBsaW5lLCBTdHJpbmcuc3RyaXAgbGluZSlcbiAgICAgICAgaW5cbiAgICAgICAgbWF0Y2hcbiAgICAgICAgICBpbmRlbnRfYW5kX2NvbnRlbnRzXG4gICAgICAgICAgfD4gTGlzdC5maWx0ZXJfbWFwIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBfaW5kZW50LCBcIlwiIC0+IE5vbmVcbiAgICAgICAgICAgICAgIHwgaW5kZW50LCBfIC0+IFNvbWUgaW5kZW50KVxuICAgICAgICAgIHw+IExpc3QubWluX2VsdCB+Y29tcGFyZTpJbnQuY29tcGFyZVxuICAgICAgICB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgICB8IFNvbWUgbWluX2luZGVudCAtPlxuICAgICAgICAgIExpc3QubWFwIGluZGVudF9hbmRfY29udGVudHMgfmY6KGZ1biAoaW5kZW50LCBsaW5lKSAtPlxuICAgICAgICAgICAgSW50Lm1heCAwIChpbmRlbnQgLSBtaW5faW5kZW50KSwgbGluZSlcbiAgICAgIGluXG4gICAgICBsZXQgKFQgdGFnKSA9XG4gICAgICAgIG1hdGNoIChiZWhhdmlvciA6IF8gQmVoYXZpb3IudCkgd2l0aFxuICAgICAgICB8IEV4cGVjdCB7IHBheWxvYWQgPSB7IHRhZzsgY29udGVudHMgPSBfIH07IF8gfSAtPiB0YWdcbiAgICAgICAgfCBVbnJlYWNoYWJsZSBfIC0+IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIuZGVmYXVsdFxuICAgICAgaW5cbiAgICAgIChtYXRjaCBsaW5lcywgZXhwZWN0X25vZGVfZm9ybWF0dGluZy5hbHdheXNfb25fb3duX2xpbmUgd2l0aFxuICAgICAgIHwgW10sIF8gLT5cbiAgICAgICAgICgqIEFuIGVtcHR5IGJvZHkgc2hvdWxkIGVpdGhlciBiZSBbe3wgfH1dIG9yIFtcIlwiXSAqKVxuICAgICAgICAgKG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgfCBUYWcgXyAtPiBcIiBcIlxuICAgICAgICAgIHwgUXVvdGUgLT4gXCJcIilcbiAgICAgICB8IFsgKF9pbmRlbnQsIGxpbmUpIF0sIGZhbHNlIC0+XG4gICAgICAgICAoKiBBIHNpbmdsZSBsaW5lIHNob3VsZCBlaXRoZXIgYmUgW3t8IGxpbmUgfH1dIG9yIFtcImxpbmVcIl0gKilcbiAgICAgICAgIChtYXRjaCB0YWcgd2l0aFxuICAgICAgICAgIHwgVGFnIF8gLT4gU3RyaW5nLmNvbmNhdCBbIFwiIFwiOyBsaW5lOyBcIiBcIiBdXG4gICAgICAgICAgfCBRdW90ZSAtPiBsaW5lKVxuICAgICAgIHwgbGluZXMsIF8gLT5cbiAgICAgICAgIGxldCBsb2NhdGlvbl9pbmRlbnQgPVxuICAgICAgICAgICBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmluZGVudFxuICAgICAgICAgICAoKiBUaGUgY29udGVudHMgYXJlIGFsd2F5cyBpbmRlbnRlZCB0d28gc3BhY2VzIHBhc3QgdGhlIGxlZnQgZWRnZSBvZiB0aGVcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uIHBvaW50ICopXG4gICAgICAgICAgICtcbiAgICAgICAgICAgbWF0Y2ggcG9zaXRpb24gd2l0aFxuICAgICAgICAgICB8IE92ZXJ3cml0ZSB7IHdob2xlX25vZGUgPSB7IHN0YXJ0X2JvbDsgc3RhcnRfcG9zOyBlbmRfcG9zID0gXyB9OyBwYXlsb2FkID0gXyB9XG4gICAgICAgICAgICAgLT5cbiAgICAgICAgICAgICAoKiBJZiB3ZSBhcmUgb3ZlcndyaXRpbmcgYW4gZXh0ZW5zaW9uIHBvaW50LCB3ZSBzaG91bGQgdGFrZSBpdHMgbGVmdCBlZGdlICopXG4gICAgICAgICAgICAgc3RhcnRfcG9zIC0gc3RhcnRfYm9sXG4gICAgICAgICAgIHwgSW5zZXJ0IHsgYm9keV9sb2MgPSB7IHN0YXJ0X2JvbDsgc3RhcnRfcG9zOyBlbmRfcG9zID0gXyB9OyBsb2MgPSBfIH0gLT5cbiAgICAgICAgICAgICAoKiBJZiB3ZSBhcmUgaW5zZXJ0aW5nIGEgbmV3IGV4dGVuc2lvbiBwb2ludCwgd2Ugc2hvdWxkIGNvbXB1dGUgaXRzIGxlZnRcbiAgICAgICAgICAgICAgICBlZGdlZCBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIFtsZXQlZXhwZWN0X3Rlc3RdIG5vZGUgKilcbiAgICAgICAgICAgICBzdGFydF9wb3NcbiAgICAgICAgICAgICAtIHN0YXJ0X2JvbFxuICAgICAgICAgICAgICtcbiAgICAgICAgICAgICAobWF0Y2ggb25faW5jb3JyZWN0X291dHB1dC5raW5kIHdpdGhcbiAgICAgICAgICAgICAgfCBFeHRlbnNpb24gLT4gZXhwZWN0X25vZGVfZm9ybWF0dGluZy5pbmRlbnRcbiAgICAgICAgICAgICAgfCBBdHRyaWJ1dGUgLT4gMClcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgc3BhY2VzIG4gPSBTdHJpbmcubWFrZSBuICcgJyBpblxuICAgICAgICAgbGV0IGZpcnN0X2xpbmUsIGluZGVudGF0aW9uLCBsYXN0X2xpbmUgPVxuICAgICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICAgICB8IFF1b3RlIC0+XG4gICAgICAgICAgICAgKCogU2luY2Ugb2NhbWxmb3JtYXQgd2lsbCBzcGxpdCB0aGUgc3RyaW5nIG9udG8gbGluZXMgYW5kIGluZGVudCB0aGVtIGZvclxuICAgICAgICAgICAgICAgIHVzLCB3ZSBzaG91bGRuJ3QgaW5zZXJ0IGxpdGVyYWwgd2hpdGVzcGFjZSB0byBpbmRlbnQgdGhlIHN0cmluZy4gKilcbiAgICAgICAgICAgICBcIiBcIiwgMSwgXCIgXCJcbiAgICAgICAgICAgfCBUYWcgXyAtPiBcIlwiLCBsb2NhdGlvbl9pbmRlbnQsIHNwYWNlcyBsb2NhdGlvbl9pbmRlbnRcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgbGluZXMgPVxuICAgICAgICAgICBMaXN0Lm1hcCBsaW5lcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICB8IF9pbmRlbnQsIFwiXCIgLT4gXCJcIlxuICAgICAgICAgICAgIHwgbGluZV9pbmRlbnQsIGxpbmUgLT4gc3BhY2VzIChpbmRlbnRhdGlvbiArIGxpbmVfaW5kZW50KSBeIGxpbmUpXG4gICAgICAgICBpblxuICAgICAgICAgWyBbIGZpcnN0X2xpbmUgXTsgbGluZXM7IFsgbGFzdF9saW5lIF0gXVxuICAgICAgICAgfD4gTGlzdC5jb25jYXRcbiAgICAgICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiKVxuOztcblxubGV0IGV4dGVuc2lvbl9zeW50YXggZXh0ZW5zaW9uX25hbWUgfnBheWxvYWRfbG9jIH5ub2RlX2xvYyA9XG4gIGxldCBjb250YWlucyAob3V0ZXIgOiBDb21wYWN0X2xvYy50KSB+KGlubmVyIDogQ29tcGFjdF9sb2MudCkgPVxuICAgIG91dGVyLnN0YXJ0X3BvcyA8PSBpbm5lci5zdGFydF9wb3MgJiYgb3V0ZXIuZW5kX3BvcyA+PSBpbm5lci5lbmRfcG9zXG4gIGluXG4gIG1hdGNoIHBheWxvYWRfbG9jIHdpdGhcbiAgfCBTb21lIHBheWxvYWRfbG9jIHdoZW4gY29udGFpbnMgcGF5bG9hZF9sb2MgfmlubmVyOm5vZGVfbG9jIC0+XG4gICAgKCogQW4gZXh0ZW5zaW9uIHBvaW50IHdob3NlIHBheWxvYWQgbG9jYXRpb24gY29udGFpbnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBlbnRpcmVcbiAgICAgICBleHRlbnNpb24gcG9pbnQgaXMgdXNpbmcgdGhlIFwic2hvcnRoYW5kXCIgc3ludGF4LiAqKVxuICAgIChUIHsgbmFtZSA9IGV4dGVuc2lvbl9uYW1lOyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gU2hvcnRoYW5kIH1cbiAgICAgIDogU3RyaW5nX25vZGVfZm9ybWF0LlNoYXBlLnQpXG4gIHwgXyAtPiBUIHsgbmFtZSA9IGV4dGVuc2lvbl9uYW1lOyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gTG9uZ2hhbmQgfVxuOztcblxubGV0IHBvc3NpYmx5X3JlbGF4X3N0cmljdG5lc3NcbiAgfihmb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IDogRXhwZWN0X25vZGVfZm9ybWF0dGluZy5GbGV4aWJpbGl0eS50KVxuICAodCA6IFsgYEV4cGVjdCBdIHQpXG4gID1cbiAgbWF0Y2ggZm9ybWF0dGluZ19mbGV4aWJpbGl0eSB3aXRoXG4gIHwgRXhhY3RseV9mb3JtYXR0ZWQgLT4gdFxuICB8IEZsZXhpYmxlX21vZHVsbyBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nIC0+XG4gICAgbGV0IGZtdCA9IGZvcm1hdHRlciB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB0IGluXG4gICAgbGV0IChFeHBlY3QgeyBwYXlsb2FkID0geyBjb250ZW50czsgdGFnIH07IG9uX3VucmVhY2hhYmxlOyByZWFjaGFiaWxpdHkgfSkgPVxuICAgICAgdC5iZWhhdmlvclxuICAgIGluXG4gICAgKG1hdGNoXG4gICAgICAgT3V0cHV0LnJlY29uY2lsZVxuICAgICAgICAgfmV4cGVjdGVkX291dHB1dDpjb250ZW50c1xuICAgICAgICAgfnRlc3Rfb3V0cHV0OihPdXRwdXQuRm9ybWF0dGVyLmFwcGx5IGZtdCBjb250ZW50cylcbiAgICAgd2l0aFxuICAgICB8IFBhc3MgLT4gdFxuICAgICB8IEZhaWwgY29udGVudHMgLT5cbiAgICAgICBsZXQgcGF5bG9hZCA9IE91dHB1dC50b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnIGNvbnRlbnRzIGluXG4gICAgICAgd2l0aF9iZWhhdmlvciB0IChFeHBlY3QgeyBwYXlsb2FkOyBvbl91bnJlYWNoYWJsZTsgcmVhY2hhYmlsaXR5IH0pKVxuOztcblxubGV0IGV4cGVjdGVkX3N0cmluZ19hbmRfcGF5bG9hZF9sb2MgPSBmdW5jdGlvblxuICB8IFNvbWUgKGEsIGIpIC0+IGEsIFNvbWUgYlxuICB8IE5vbmUgLT4gT3V0cHV0LlBheWxvYWQuZGVmYXVsdCBcIlwiLCBOb25lXG47O1xuXG5sZXQgZXhwZWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgbGV0IHBheWxvYWQsIHBheWxvYWRfbG9jID0gZXhwZWN0ZWRfc3RyaW5nX2FuZF9wYXlsb2FkX2xvYyBsb2NhdGVkX3BheWxvYWQgaW5cbiAgeyBwb3NpdGlvbiA9IE92ZXJ3cml0ZSB7IHdob2xlX25vZGUgPSBub2RlX2xvYzsgcGF5bG9hZCA9IHBheWxvYWRfbG9jIH1cbiAgOyBiZWhhdmlvciA9XG4gICAgICBFeHBlY3RcbiAgICAgICAgeyBwYXlsb2FkOyBvbl91bnJlYWNoYWJsZSA9IFJlcGxhY2Vfd2l0aF91bnJlYWNoYWJsZTsgcmVhY2hhYmlsaXR5ID0gQ2FuX3JlYWNoIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBQcmV0dHlcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gZXh0ZW5zaW9uX3N5bnRheCBcImV4cGVjdFwiIH5wYXlsb2FkX2xvYyB+bm9kZV9sb2NcbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ0ZXN0IG91dHB1dFwiXG4gIH1cbiAgfD4gcG9zc2libHlfcmVsYXhfc3RyaWN0bmVzcyB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuOztcblxubGV0IGV4cGVjdF9leGFjdCB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZCA9XG4gIGxldCBwYXlsb2FkLCBwYXlsb2FkX2xvYyA9IGV4cGVjdGVkX3N0cmluZ19hbmRfcGF5bG9hZF9sb2MgbG9jYXRlZF9wYXlsb2FkIGluXG4gIHsgcG9zaXRpb24gPSBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlID0gbm9kZV9sb2M7IHBheWxvYWQgPSBwYXlsb2FkX2xvYyB9XG4gIDsgYmVoYXZpb3IgPVxuICAgICAgRXhwZWN0XG4gICAgICAgIHsgcGF5bG9hZDsgb25fdW5yZWFjaGFibGUgPSBSZXBsYWNlX3dpdGhfdW5yZWFjaGFibGU7IHJlYWNoYWJpbGl0eSA9IENhbl9yZWFjaCB9XG4gIDsgcGF5bG9hZF90eXBlID0gRXhhY3RcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gZXh0ZW5zaW9uX3N5bnRheCBcImV4cGVjdF9leGFjdFwiIH5wYXlsb2FkX2xvYyB+bm9kZV9sb2NcbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ0ZXN0IG91dHB1dFwiXG4gIH1cbiAgfD4gcG9zc2libHlfcmVsYXhfc3RyaWN0bmVzcyB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuOztcblxubGV0IGV4cGVjdF91bnJlYWNoYWJsZSB+bm9kZV9sb2MgPVxuICB7IHBvc2l0aW9uID0gT3ZlcndyaXRlIHsgd2hvbGVfbm9kZSA9IG5vZGVfbG9jOyBwYXlsb2FkID0gTm9uZSB9XG4gIDsgYmVoYXZpb3IgPSBVbnJlYWNoYWJsZSB7IHJlYWNoYWJpbGl0eV9vZl9jb3JyZWN0ZWQgPSBDYW5fcmVhY2ggfVxuICA7IHBheWxvYWRfdHlwZSA9IFByZXR0eVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIHsgbmFtZSA9IFwiZXhwZWN0XCI7IGtpbmQgPSBFeHRlbnNpb247IGhhbmQgPSBMb25naGFuZCB9XG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidGVzdCBvdXRwdXRcIlxuICB9XG47O1xuXG5sZXQgZXhwZWN0X3VuY2F1Z2h0X2V4biB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZCA9XG4gIGxldCBwYXlsb2FkLCBwYXlsb2FkX2xvYyA9IGV4cGVjdGVkX3N0cmluZ19hbmRfcGF5bG9hZF9sb2MgbG9jYXRlZF9wYXlsb2FkIGluXG4gIHsgcG9zaXRpb24gPSBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlID0gbm9kZV9sb2M7IHBheWxvYWQgPSBwYXlsb2FkX2xvYyB9XG4gIDsgYmVoYXZpb3IgPSBFeHBlY3QgeyBwYXlsb2FkOyBvbl91bnJlYWNoYWJsZSA9IERlbGV0ZTsgcmVhY2hhYmlsaXR5ID0gTXVzdF9yZWFjaCB9XG4gIDsgcGF5bG9hZF90eXBlID0gUHJldHR5XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9XG4gICAgICBUIHsgbmFtZSA9IFwiZXhwZWN0LnVuY2F1Z2h0X2V4blwiOyBraW5kID0gQXR0cmlidXRlOyBoYW5kID0gTG9uZ2hhbmQgfVxuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInVuY2F1Z2h0IGV4Y2VwdGlvblwiXG4gIH1cbiAgfD4gcG9zc2libHlfcmVsYXhfc3RyaWN0bmVzcyB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuOztcblxubGV0IGV4cGVjdF90cmFpbGluZyB+aW5zZXJ0X2xvYyA9XG4gIHsgcG9zaXRpb24gPSBJbnNlcnQgaW5zZXJ0X2xvY1xuICA7IGJlaGF2aW9yID1cbiAgICAgIEV4cGVjdFxuICAgICAgICB7IHBheWxvYWQgPSBPdXRwdXQuUGF5bG9hZC5kZWZhdWx0IFwiIFwiXG4gICAgICAgIDsgb25fdW5yZWFjaGFibGUgPSBTaWxlbnRcbiAgICAgICAgOyByZWFjaGFiaWxpdHkgPSBDYW5fcmVhY2hcbiAgICAgICAgfVxuICA7IHBheWxvYWRfdHlwZSA9IFByZXR0eVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIHsgbmFtZSA9IFwiZXhwZWN0XCI7IGtpbmQgPSBFeHRlbnNpb247IGhhbmQgPSBMb25naGFuZCB9XG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidHJhaWxpbmcgb3V0cHV0XCJcbiAgfVxuOztcblxubGV0IGV4cGVjdF9ub191bmNhdWdodF9leG4gfmluc2VydF9sb2MgPVxuICB7IHBvc2l0aW9uID0gSW5zZXJ0IGluc2VydF9sb2NcbiAgOyBiZWhhdmlvciA9IFVucmVhY2hhYmxlIHsgcmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCA9IE11c3RfcmVhY2ggfVxuICA7IHBheWxvYWRfdHlwZSA9IFByZXR0eVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPVxuICAgICAgVCB7IG5hbWUgPSBcImV4cGVjdC51bmNhdWdodF9leG5cIjsga2luZCA9IEF0dHJpYnV0ZTsgaGFuZCA9IExvbmdoYW5kIH1cbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ1bmNhdWdodCBleGNlcHRpb25cIlxuICB9XG47O1xuXG5tb2R1bGUgRm9yX2FwcGx5X3N0eWxlID0gc3RydWN0XG4gIGxldCBmb3JtYXRfcGF5bG9hZCBta19ub2RlID1cbiAgICBTdGFnZWQuc3RhZ2VcbiAgICBAQCBmdW4gfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfnBheWxvYWRfbG9jIH5ub2RlX2xvYyB0YWcgY29udGVudHMgLT5cbiAgICBsZXQgbm9kZSA9XG4gICAgICBta19ub2RlXG4gICAgICAgIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5OihFeGFjdGx5X2Zvcm1hdHRlZCA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuRmxleGliaWxpdHkudClcbiAgICAgICAgfm5vZGVfbG9jXG4gICAgICAgIH5sb2NhdGVkX3BheWxvYWQ6KFNvbWUgKCh7IHRhZzsgY29udGVudHMgfSA6IE91dHB1dC5QYXlsb2FkLnQpLCBwYXlsb2FkX2xvYykpXG4gICAgaW5cbiAgICBsZXQgZm9ybWF0dGVkX2NvbnRlbnRzID1cbiAgICAgIE91dHB1dC5Gb3JtYXR0ZXIuYXBwbHkgKGZvcm1hdHRlciB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyBub2RlKSBjb250ZW50c1xuICAgIGluXG4gICAgbWF0Y2ggT3V0cHV0LnJlY29uY2lsZSB+ZXhwZWN0ZWRfb3V0cHV0OmNvbnRlbnRzIH50ZXN0X291dHB1dDpmb3JtYXR0ZWRfY29udGVudHMgd2l0aFxuICAgIHwgUGFzcyAtPiBOb25lXG4gICAgfCBGYWlsIGNvbnRlbnRzIC0+XG4gICAgICBsZXQgc291cmNlX2NvZGVfc3RyaW5nID1cbiAgICAgICAgbWF0Y2ggbm9kZS5vbl9pbmNvcnJlY3Rfb3V0cHV0IHdpdGhcbiAgICAgICAgfCBUIHsgaGFuZCA9IExvbmdoYW5kOyBfIH0gLT5cbiAgICAgICAgICBPdXRwdXQudG9fZm9ybWF0dGVkX3BheWxvYWQgfnRhZyBjb250ZW50c1xuICAgICAgICAgIHw+IE91dHB1dC5QYXlsb2FkLnRvX3NvdXJjZV9jb2RlX3N0cmluZ1xuICAgICAgICB8IFQgeyBoYW5kID0gU2hvcnRoYW5kOyBfIH0gYXMgbm9kZV9zaGFwZSAtPlxuICAgICAgICAgIE91dHB1dC50b19zb3VyY2VfY29kZV9zdHJpbmcgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfm5vZGVfc2hhcGUgfnRhZyBjb250ZW50c1xuICAgICAgaW5cbiAgICAgIFNvbWUgc291cmNlX2NvZGVfc3RyaW5nXG4gIDs7XG5cbiAgbGV0IGZvcm1hdF9leHBlY3RfcGF5bG9hZCA9IGZvcm1hdF9wYXlsb2FkIGV4cGVjdCB8PiBTdGFnZWQudW5zdGFnZVxuICBsZXQgZm9ybWF0X3VuY2F1Z2h0X2V4bl9wYXlsb2FkID0gZm9ybWF0X3BheWxvYWQgZXhwZWN0X3VuY2F1Z2h0X2V4biB8PiBTdGFnZWQudW5zdGFnZVxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9leHBlY3QiLCJjc3RfZXhwZWN0X3VuY2F1Z2h0X2V4biIsImNzdF90ZXN0X291dHB1dCIsImNzdF91bmNhdWdodF9leGNlcHRpb24iLCJjYW1sX2NhbGwzIiwiZiIsImEwIiwiYTEiLCJhMiIsImdsb2JhbF9kYXRhIiwibGFzdF9saW5lIiwiZmlyc3RfbGluZSIsIlBweF9leHBlY3RfcnVudGltZV9PdXRwdXQiLCJCYXNlX1N0YWdlZCIsIkJhc2UiLCJCYXNlX1N0cmluZyIsIkJhc2VfSW50IiwiQmFzZV9DaGFyIiwiQmFzZV9MaXN0IiwiUHB4X2V4cGVjdF9ydW50aW1lX1R5cGVzIiwibG9jIiwicGFyYW0iLCJ3aG9sZV9ub2RlIiwiSW5zZXJ0X2xvYyIsImNzdF9leHBlY3RfZXhhY3QiLCJjc3RfdHJhaWxpbmdfb3V0cHV0Iiwid2l0aF9iZWhhdmlvciIsImJlaGF2aW9yIiwiaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSIsIm9uX2luY29ycmVjdF9vdXRwdXQiLCJwYXlsb2FkX3R5cGUiLCJwb3NpdGlvbiIsImZvcm1hdHRlciIsImV4cGVjdF9ub2RlX2Zvcm1hdHRpbmciLCJjb3VudF9sZWFkaW5nX3NwYWNlcyIsImxpbmUiLCJtYXRjaCIsInN0ciIsInN0cmlwcGVkIiwiaW5kZW50X2FuZF9jb250ZW50cyIsImluZGVudCIsIm1pbl9pbmRlbnQiLCJsaW5lcyIsInRhZyIsInN0YXJ0X3BvcyIsInN0YXJ0X2JvbCIsImxvY2F0aW9uX2luZGVudCIsInNwYWNlcyIsIm4iLCJpbmRlbnRhdGlvbiIsImV4dGVuc2lvbl9zeW50YXgiLCJleHRlbnNpb25fbmFtZSIsInBheWxvYWRfbG9jIiwibm9kZV9sb2MiLCJwb3NzaWJseV9yZWxheF9zdHJpY3RuZXNzIiwiZm9ybWF0dGluZ19mbGV4aWJpbGl0eSIsInQiLCJmbXQiLCJyZWFjaGFiaWxpdHkiLCJvbl91bnJlYWNoYWJsZSIsImNvbnRlbnRzIiwicGF5bG9hZCIsImV4cGVjdGVkX3N0cmluZ19hbmRfcGF5bG9hZF9sbyIsImIiLCJhIiwiZXhwZWN0IiwibG9jYXRlZF9wYXlsb2FkIiwiZXhwZWN0X2V4YWN0IiwiZXhwZWN0X3VucmVhY2hhYmxlIiwiZXhwZWN0X3VuY2F1Z2h0X2V4biIsImV4cGVjdF90cmFpbGluZyIsImluc2VydF9sb2MiLCJleHBlY3Rfbm9fdW5jYXVnaHRfZXhuIiwiZm9ybWF0X3BheWxvYWQiLCJta19ub2RlIiwibm9kZSIsImZvcm1hdHRlZF9jb250ZW50cyIsIm5vZGVfc2hhcGUiLCJzb3VyY2VfY29kZV9zdHJpbmciLCJmb3JtYXRfZXhwZWN0X3BheWxvYWQiLCJmb3JtYXRfdW5jYXVnaHRfZXhuX3BheWxvYWQiLCJQcHhfZXhwZWN0X3J1bnRpbWVfRXhwZWN0YXRpb24iXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsMEJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUMsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFWLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBVyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxZQUFBQyxJQUFBQztBQUFBQSxJQ09ZLHVCQUFBQyxhQUFB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QixjQUErQztBQUFBLEtBQUFTLFVBQUE7QUFBQSxJQVF2RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNDQUFpRDtBQUFBO0FBQUEsWUFBQVMsZ0JBQUFDO0FBQUFBLElBT2xDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQ0FBMEI7QUFBQSxHQU8zQztBQUFBLFlBQUFDLHVCQUFBRDtBQUFBQSxJQUlEO0FBQUEsR0FNQztBQUFBLFlBQUFFLGVBQUFDO0FBQUFBLElBS0M7QUFBQTtBQUFBO0FBQUEsY0FBQXpDLHdCQUFBbUIsYUFBQUMsVUFBQVYsS0FBQWlCO0FBQUFBO0FBQUFBLGVBQUFlO0FBQUFBLGlCQUdFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFNdUI7QUFBQSxlQUFBQztBQUFBQSxpQkFBdkI7QUFBQSxlQUFBeEM7QUFBQUEsaUJBRUk7QUFBQTtBQUFBLGNBQTBFLFlBQ3RFO0FBQUEsa0JBQUF3QixhQURzRSxVQUFBaUIsYUFHOUU7QUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLGtCQU1JO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0JBSEE7QUFBQSxnQkFBQUE7QUFBQUEsa0JBQUE7QUFBQSxjQUtKO0FBQUEsYUFBdUI7QUFBQTtBQUFBO0FBQUEsUUFHQztBQUFBLElBQUFDLHdCQUFBO0FBQUEsUUFDTTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBb0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEalJ4RiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjczMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvdGVzdF9ub2RlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuXG5tb2R1bGUgQ29ycmVjdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmV3X3BheWxvYWQgOlxuICAgICAgICBbPCBFeHBlY3RhdGlvbi5CZWhhdmlvcl90eXBlLnQgXSBFeHBlY3RhdGlvbi50ICogT3V0cHV0LlJlY29uY2lsZWQudFxuICAgICAgICAtPiB0XG4gICAgfCBVbnJlYWNoYWJsZSA6IFsgYEV4cGVjdCBdIEV4cGVjdGF0aW9uLnQgLT4gdFxuXG4gICgqKiBbU29tZSAobG9jLCBwYXRjaCldIGlmIFtjb3JyZWN0aW9uXSB3YXJyYW50cyBpbnNlcnRpbmcgW3BhdGNoXSBpbnRvIHRoZSByZXdyaXR0ZW5cbiAgICAgIGZpbGUgYXQgW2xvY10sIFtOb25lXSBpZiBubyBjaGFuZ2UgaXMgbmVlZGVkIGZyb20gW2NvcnJlY3Rpb25dLiAqKVxuICBsZXQgdG9fcGF0Y2hfb3B0IH4oZXhwZWN0X25vZGVfZm9ybWF0dGluZyA6IEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudCkgY29ycmVjdGlvbiA9XG4gICAgbWF0Y2ggY29ycmVjdGlvbiB3aXRoXG4gICAgfCBOZXdfcGF5bG9hZFxuICAgICAgICAoIHsgcG9zaXRpb25cbiAgICAgICAgICA7IGJlaGF2aW9yXG4gICAgICAgICAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCBvbl9pbmNvcnJlY3Rfb3V0cHV0XG4gICAgICAgICAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gX1xuICAgICAgICAgIDsgcGF5bG9hZF90eXBlID0gX1xuICAgICAgICAgIH1cbiAgICAgICAgLCB0ZXN0X291dHB1dCApIC0+XG4gICAgICBsZXQgd2hpdGVzcGFjZSA9XG4gICAgICAgIG1hdGNoIHBvc2l0aW9uIHdpdGhcbiAgICAgICAgfCBJbnNlcnQgeyBib2R5X2xvYyA9IHsgc3RhcnRfcG9zOyBzdGFydF9ib2w7IF8gfTsgXyB9IC0+XG4gICAgICAgICAgKCogW2xldF9vZmZzZXRdIGlzIHRoZSBzcGFjZSB1bnRpbCB0aGUgbGF5ZXIgb2YgaW5kZW50YXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgW2xldCVleHBlY3RfdGVzdF0gYmluZGluZy4gKilcbiAgICAgICAgICBsZXQgbGV0X29mZnNldCA9IHN0YXJ0X3BvcyAtIHN0YXJ0X2JvbCBpblxuICAgICAgICAgICgqIFRoZSBjb250ZW50cyBvZiB0aGUgZXhwZWN0IG5vZGUgYXJlIGluZGVudGVkIGFuIGFkZGl0aW9uYWwgdHdvIHNwYWNlcyBwYXN0XG4gICAgICAgICAgICAgdGhlIG5vZGUgaXRzZWxmLiAqKVxuICAgICAgICAgIGxldCBpbmRlbnQgPVxuICAgICAgICAgICAgbGV0X29mZnNldFxuICAgICAgICAgICAgK1xuICAgICAgICAgICAgbWF0Y2ggb25faW5jb3JyZWN0X291dHB1dC5raW5kIHdpdGhcbiAgICAgICAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuaW5kZW50XG4gICAgICAgICAgICB8IEF0dHJpYnV0ZSAtPiAwXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgd2hpdGVzcGFjZSA9IFwiXFxuXCIgXiBTdHJpbmcubWFrZSBpbmRlbnQgJyAnIGluXG4gICAgICAgICAgd2hpdGVzcGFjZVxuICAgICAgICB8IE92ZXJ3cml0ZSBfIC0+IFwiXCJcbiAgICAgIGluXG4gICAgICBsZXQgdGFnID1cbiAgICAgICAgbWF0Y2ggYmVoYXZpb3Igd2l0aFxuICAgICAgICB8IEV4cGVjdCB7IHBheWxvYWQgPSB7IHRhZzsgXyB9OyBvbl91bnJlYWNoYWJsZSA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfSAtPiB0YWdcbiAgICAgICAgfCBVbnJlYWNoYWJsZSBfIC0+IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIuZGVmYXVsdFxuICAgICAgaW5cbiAgICAgIGxldCBsb2MsIGNvcnJlY3Rpb24gPVxuICAgICAgICBtYXRjaCBwb3NpdGlvbiwgb25faW5jb3JyZWN0X291dHB1dCB3aXRoXG4gICAgICAgIHwgKCBPdmVyd3JpdGUgeyBwYXlsb2FkID0gU29tZSBwYXlsb2FkX2xvYzsgd2hvbGVfbm9kZSA9IF8gfVxuICAgICAgICAgICwgeyBraW5kID0gRXh0ZW5zaW9uOyBoYW5kID0gTG9uZ2hhbmQ7IG5hbWUgPSBfIH0gKSAtPlxuICAgICAgICAgIGxldCBjb3JyZWN0aW9uID1cbiAgICAgICAgICAgIE91dHB1dC50b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnIHRlc3Rfb3V0cHV0XG4gICAgICAgICAgICB8PiBPdXRwdXQuUGF5bG9hZC50b19zb3VyY2VfY29kZV9zdHJpbmdcbiAgICAgICAgICBpblxuICAgICAgICAgIHBheWxvYWRfbG9jLCBjb3JyZWN0aW9uXG4gICAgICAgIHwgKE92ZXJ3cml0ZSB7IHBheWxvYWQgPSBfOyB3aG9sZV9ub2RlID0gbG9jIH0gfCBJbnNlcnQgeyBsb2M7IGJvZHlfbG9jID0gXyB9KSwgX1xuICAgICAgICAgIC0+XG4gICAgICAgICAgKCBsb2NcbiAgICAgICAgICAsIE91dHB1dC50b19zb3VyY2VfY29kZV9zdHJpbmdcbiAgICAgICAgICAgICAgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbiAgICAgICAgICAgICAgfm5vZGVfc2hhcGU6KFQgb25faW5jb3JyZWN0X291dHB1dClcbiAgICAgICAgICAgICAgfnRhZ1xuICAgICAgICAgICAgICB0ZXN0X291dHB1dCApXG4gICAgICBpblxuICAgICAgU29tZSAobG9jLCB3aGl0ZXNwYWNlIF4gY29ycmVjdGlvbilcbiAgICB8IFVucmVhY2hhYmxlXG4gICAgICAgIHsgYmVoYXZpb3IgPSBFeHBlY3QgeyBvbl91bnJlYWNoYWJsZTsgcGF5bG9hZCA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfVxuICAgICAgICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIG9uX2luY29ycmVjdF9vdXRwdXRcbiAgICAgICAgOyBwb3NpdGlvblxuICAgICAgICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBfXG4gICAgICAgIDsgcGF5bG9hZF90eXBlID0gX1xuICAgICAgICB9IC0+XG4gICAgICBsZXQgbG9jID0gRXhwZWN0YXRpb24uSW5zZXJ0X2xvYy5sb2MgcG9zaXRpb24gaW5cbiAgICAgIChtYXRjaCBvbl91bnJlYWNoYWJsZSB3aXRoXG4gICAgICAgfCBTaWxlbnQgLT4gTm9uZVxuICAgICAgIHwgRGVsZXRlIC0+IFNvbWUgKGxvYywgXCJcIilcbiAgICAgICB8IFJlcGxhY2Vfd2l0aF91bnJlYWNoYWJsZSAtPlxuICAgICAgICAgbGV0IHByZWZpeCA9XG4gICAgICAgICAgIG1hdGNoIG9uX2luY29ycmVjdF9vdXRwdXQua2luZCB3aXRoXG4gICAgICAgICAgIHwgRXh0ZW5zaW9uIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZXh0ZW5zaW9uX3NpZ2lsXG4gICAgICAgICAgIHwgQXR0cmlidXRlIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuYXR0cmlidXRlX3NpZ2lsXG4gICAgICAgICBpblxuICAgICAgICAgU29tZSAobG9jLCBQcmludGYuc3ByaW50ZiBcIlslc2V4cGVjdC51bnJlYWNoYWJsZV1cIiBwcmVmaXgpKVxuICA7O1xuXG4gIGxldCB0b19kaWZmcyB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyBjb3JyZWN0aW9uID1cbiAgICBsZXQgc2FmZV9ieXRlX2dldCBzdHJpbmcgaSA9XG4gICAgICBpZiBpID49IDAgJiYgaSA8IFN0cmluZy5sZW5ndGggc3RyaW5nIHRoZW4gU29tZSAoU3RyaW5nLmdldCBzdHJpbmcgaSkgZWxzZSBOb25lXG4gICAgaW5cbiAgICBtYXRjaCB0b19wYXRjaF9vcHQgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgY29ycmVjdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIChsb2MsIGRpZmYpIC0+XG4gICAgICBsZXQgKHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfSA6IENvbXBhY3RfbG9jLnQpID0gbG9jIGluXG4gICAgICBsZXQgbWFpbl9jb3JyZWN0aW9uID0gWyBsb2MsIGRpZmYgXSBpblxuICAgICAgKCogQWRkaXRpb25hbCBjb3JyZWN0aW9ucyBuZWNlc3NhcnkgZm9yIHByb2R1Y2luZyBjb3JyZWN0IGZvcm1hdHRpbmcgKilcbiAgICAgIGxldCBhZGRpdGlvbmFsX2NvcnJlY3Rpb25zID1cbiAgICAgICAgKCogSWYgZGVsZXRpbmcgYW4gW1tAQGV4cGVjdC51bmNhdWdodF9leG5dXSBhdHRyaWJ1dGUgd291bGRcbiAgICAgICAgICAgbGVhdmUgYW4gZW1wdHkgbGluZSwgZGVsZXRlIHRoYXQgbGluZS4gKilcbiAgICAgICAgbGV0IHJlbW92ZV9lbXB0eV9saW5lX2Zyb21fZGVsZXRlZF91bmNhdWdodF9leG4gPVxuICAgICAgICAgIG1hdGNoIGNvcnJlY3Rpb24gd2l0aFxuICAgICAgICAgIHwgVW5yZWFjaGFibGUgeyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCB7IGtpbmQgPSBBdHRyaWJ1dGU7IF8gfTsgXyB9IC0+XG4gICAgICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICAgICggc2FmZV9ieXRlX2dldCBvcmlnaW5hbF9maWxlX2NvbnRlbnRzIChzdGFydF9wb3MgLSAxKVxuICAgICAgICAgICAgICAgLCBzYWZlX2J5dGVfZ2V0IG9yaWdpbmFsX2ZpbGVfY29udGVudHMgZW5kX3BvcyApXG4gICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSAnXFxuJywgKE5vbmUgfCBTb21lICdcXG4nKSAtPlxuICAgICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICAgICAoIHsgQ29tcGFjdF9sb2Muc3RhcnRfcG9zID0gc3RhcnRfcG9zIC0gMVxuICAgICAgICAgICAgICAgICAgIDsgZW5kX3BvcyA9IHN0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgIDsgc3RhcnRfYm9sXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAsIFwiXCIgKVxuICAgICAgICAgICAgIHwgXyAtPiBOb25lKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIGluXG4gICAgICAgICgqIEluY2x1ZGUgdGhlIHNlbWljb2xvbiBuZWVkZWQgYXQgdGhlIGVuZCBvZiB0aGUgYm9keVxuICAgICAgICAgICBmb3IgYSB0cmFpbGluZyBbWyVleHBlY3RdXSBleHRlbnNpb24gcG9pbnQuICopXG4gICAgICAgIGxldCBhZGRfc2VtaWNvbG9uX2JlZm9yZV90cmFpbGluZ19leHBlY3QgPVxuICAgICAgICAgIG1hdGNoIGNvcnJlY3Rpb24gd2l0aFxuICAgICAgICAgIHwgTmV3X3BheWxvYWRcbiAgICAgICAgICAgICAgKCB7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBUIHsga2luZCA9IEV4dGVuc2lvbjsgXyB9XG4gICAgICAgICAgICAgICAgOyBwb3NpdGlvbiA9IEluc2VydCB7IGJvZHlfbG9jOyBfIH1cbiAgICAgICAgICAgICAgICA7IF9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICwgXyApIC0+IFNvbWUgKHsgYm9keV9sb2Mgd2l0aCBzdGFydF9wb3MgPSBib2R5X2xvYy5lbmRfcG9zIH0sIFwiO1wiKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIGluXG4gICAgICAgIExpc3QuY29uY2F0X21hcFxuICAgICAgICAgIH5mOk9wdGlvbi50b19saXN0XG4gICAgICAgICAgWyByZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWRfdW5jYXVnaHRfZXhuXG4gICAgICAgICAgOyBhZGRfc2VtaWNvbG9uX2JlZm9yZV90cmFpbGluZ19leHBlY3RcbiAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgYWRkaXRpb25hbF9jb3JyZWN0aW9ucyBAIG1haW5fY29ycmVjdGlvblxuICA7O1xuZW5kXG5cbnR5cGUgb25lX291dHB1dCA9XG4gIHsgcmVzdWx0IDogT3V0cHV0LlRlc3RfcmVzdWx0LnRcbiAgOyByYXcgOiBzdHJpbmdcbiAgfVxuXG50eXBlIG9uZV9ydW4gPVxuICB8IFJlYWNoZWRfd2l0aF9vdXRwdXQgb2Ygb25lX291dHB1dFxuICB8IERpZF9ub3RfcmVhY2hcblxudHlwZSAnYmVoYXZpb3IgaW5uZXIgPVxuICB8IFRlc3QgOlxuICAgICAgeyBleHBlY3RhdGlvbiA6IChbPCBFeHBlY3RhdGlvbi5CZWhhdmlvcl90eXBlLnQgXSBhcyAnYmVoYXZpb3IpIEV4cGVjdGF0aW9uLnRcbiAgICAgIDsgcmVzdWx0cyA6IG9uZV9ydW4gUXVldWUudFxuICAgICAgOyBtdXRhYmxlIHJlYWNoZWRfdGhpc19ydW4gOiBib29sXG4gICAgICB9XG4gICAgICAtPiAnYmVoYXZpb3IgaW5uZXJcblxudHlwZSB0ID0gVCA6ICdiZWhhdmlvciBpbm5lciAtPiB0XG5cbmxldCB0b19jb3JyZWN0aW9uXG4gIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG4gIH5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0c1xuICAoVCAoVGVzdCB7IGV4cGVjdGF0aW9uOyByZXN1bHRzOyByZWFjaGVkX3RoaXNfcnVuID0gXyB9KSlcbiAgOiBDb3JyZWN0aW9uLnQgb3B0aW9uXG4gID1cbiAgbGV0IHJlc3VsdHNfbGlzdCA9IFF1ZXVlLnRvX2xpc3QgcmVzdWx0cyBpblxuICBsZXQgdW5yZWFjaGVkX2xpc3QsIG91dHB1dHNfbGlzdCA9XG4gICAgTGlzdC5wYXJ0aXRpb25fbWFwIHJlc3VsdHNfbGlzdCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRGlkX25vdF9yZWFjaCAtPiBGaXJzdCAoKVxuICAgICAgfCBSZWFjaGVkX3dpdGhfb3V0cHV0IG91dHB1dCAtPiBTZWNvbmQgb3V0cHV0KVxuICBpblxuICBsZXQgZGlzdGluY3Rfb3V0cHV0cyA9XG4gICAgKCogQWxsb3cgZGlzdGluY3QgcmF3IG91dHB1dHMgYXMgbG9uZyBhcyB0aGVpciBmb3JtYXR0ZWQgW3Jlc3VsdF1zXG4gICAgICAgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudCBhY2NvcmRpbmcgdG8gW1BheWxvYWRfdHlwZV0uICopXG4gICAgTGlzdC5kZWR1cF9hbmRfc29ydFxuICAgICAgfmNvbXBhcmU6XG4gICAgICAgIChDb21wYXJhYmxlLmxpZnQgfmY6KGZ1biB7IHJlc3VsdDsgXyB9IC0+IHJlc3VsdCkgT3V0cHV0LlRlc3RfcmVzdWx0LmNvbXBhcmUpXG4gICAgICBvdXRwdXRzX2xpc3RcbiAgaW5cbiAgbGV0IHdhc19yZWFjaGVkID0gTGlzdC5pc19lbXB0eSB1bnJlYWNoZWRfbGlzdCBpblxuICBsZXQgcmVhY2hhYmlsaXR5X2JlaGF2aW9yID1cbiAgICBtYXRjaCBleHBlY3RhdGlvbi5iZWhhdmlvciB3aXRoXG4gICAgfCBFeHBlY3QgeyByZWFjaGFiaWxpdHk7IHBheWxvYWQgPSBfOyBvbl91bnJlYWNoYWJsZSA9IF8gfSAtPiByZWFjaGFiaWxpdHlcbiAgICB8IFVucmVhY2hhYmxlIHsgcmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCB9IC0+IHJlYWNoYWJpbGl0eV9vZl9jb3JyZWN0ZWRcbiAgaW5cbiAgbGV0IGNvcnJlY3Rpb25fZm9yX3NpbmdsZV9yZXN1bHQgOiBPdXRwdXQuVGVzdF9yZXN1bHQudCAtPiBDb3JyZWN0aW9uLnQgb3B0aW9uXG4gICAgPSBmdW5jdGlvblxuICAgIHwgUGFzcyAtPiBOb25lXG4gICAgfCBGYWlsIHJlY2VpdmVkIC0+IFNvbWUgKE5ld19wYXlsb2FkIChleHBlY3RhdGlvbiwgcmVjZWl2ZWQpKVxuICBpblxuICBtYXRjaCBkaXN0aW5jdF9vdXRwdXRzLCAod2FzX3JlYWNoZWQsIHJlYWNoYWJpbGl0eV9iZWhhdmlvcikgd2l0aFxuICB8IFtdLCAoXywgXykgLT5cbiAgICAoKiBUaGUgdGVzdCB3YXMgbmV2ZXIgcmVhY2hlZCAqKVxuICAgIChtYXRjaCBleHBlY3RhdGlvbi5iZWhhdmlvciB3aXRoXG4gICAgIHwgVW5yZWFjaGFibGUgXyAtPiBOb25lXG4gICAgIHwgRXhwZWN0IF8gYXMgYmVoYXZpb3IgLT5cbiAgICAgICAoKiBFcnJvciBpZiBhbiBleHBlY3QgdGVzdCB3YXMgbm90IHJlYWNoZWQgKilcbiAgICAgICBTb21lIChVbnJlYWNoYWJsZSAoRXhwZWN0YXRpb24ud2l0aF9iZWhhdmlvciBleHBlY3RhdGlvbiBiZWhhdmlvcikpKVxuICB8IFsgeyByZXN1bHQ7IF8gfSBdLCAodHJ1ZSwgXyB8IF8sIENhbl9yZWFjaCkgLT5cbiAgICAoKiBUaGUgdGVzdCBvbmx5IHByb2R1Y2VkIG9uZSB1bmlxdWUgcmVzdWx0IGFuZDpcbiAgICAgICAtIFRoZSB0ZXN0IG5ldmVyIGZhaWxlZCB0byBiZSByZWFjaGVkIE9SXG4gICAgICAgLSBUaGUgdGVzdCBzb21ldGltZXMgZmFpbGVkIHRvIGJlIHJlYWNoZWQsIGJ1dCB0aGUgdGVzdCBpcyBtYXJrZWQgYXMgW0Nhbl9yZWFjaF1cbiAgICAgICAgIChvciByZXdyaXRlcyB0byBvbmUgbWFya2VkIGFzIFtDYW5fcmVhY2hdKSBzbyB0aGF0J3MgT0tcbiAgICAqKVxuICAgIGNvcnJlY3Rpb25fZm9yX3NpbmdsZV9yZXN1bHQgcmVzdWx0XG4gIHwgXyA6OiBfIDo6IF8sIF8gfCBfLCAoZmFsc2UsIE11c3RfcmVhY2gpIC0+XG4gICAgKCogVGhlIHRlc3QgcmVzdWx0cyB3ZXJlIGluY29uc2lzdGVudCBiZWNhdXNlOlxuICAgICAgIC0gVGhlIHRlc3Qgd2FzIHJlYWNoZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgb3V0cHV0cyBPUlxuICAgICAgIC0gVGhlIHRlc3Qgd2FzIHNvbWV0aW1lcyByZWFjaGVkIGFuZCBzb21ldGltZXMgbm90LCBidXQgdGhlIHRlc3QgcmV3cml0ZXMgdG8gYVxuICAgICAgICAgdGVzdCBtYXJrZWQgYXMgW011c3RfcmVhY2hdXG4gICAgKilcbiAgICBsZXQgb3V0cHV0cyA9XG4gICAgICByZXN1bHRzX2xpc3RcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW5jdGlvblxuICAgICAgICAgICB8IFJlYWNoZWRfd2l0aF9vdXRwdXQgeyByYXc7IF8gfSAtPiByYXdcbiAgICAgICAgICAgfCBEaWRfbm90X3JlYWNoIC0+XG4gICAgICAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgIFwiPGV4cGVjdCB0ZXN0IHJhbiB3aXRob3V0ICVzPlwiXG4gICAgICAgICAgICAgICBleHBlY3RhdGlvbi5pbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlKVxuICAgIGluXG4gICAgY3JfZm9yX211bHRpcGxlX291dHB1dHMgfm91dHB1dF9uYW1lOmV4cGVjdGF0aW9uLmluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2Ugfm91dHB1dHNcbiAgICB8PiBPdXRwdXQuRm9ybWF0dGVyLmFwcGx5IChFeHBlY3RhdGlvbi5mb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgZXhwZWN0YXRpb24pXG4gICAgfD4gT3V0cHV0LmZhaWxcbiAgICB8PiBjb3JyZWN0aW9uX2Zvcl9zaW5nbGVfcmVzdWx0XG47O1xuXG5sZXQgcmVjb3JkX2FuZF9yZXR1cm5fcmVzdWx0XG4gICh0eXBlIGJlaGF2aW9yKVxuICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICB+ZmFpbHVyZV9yZWZcbiAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAoVGVzdCAoeyBleHBlY3RhdGlvbjsgcmVzdWx0czsgcmVhY2hlZF90aGlzX3J1biA9IF8gfSBhcyB0KSA6IGJlaGF2aW9yIGlubmVyKVxuICA9XG4gIGxldCB0ZXN0X291dHB1dCA9XG4gICAgT3V0cHV0LkZvcm1hdHRlci5hcHBseVxuICAgICAgKEV4cGVjdGF0aW9uLmZvcm1hdHRlciB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyBleHBlY3RhdGlvbilcbiAgICAgIHRlc3Rfb3V0cHV0X3Jhd1xuICBpblxuICBsZXQgKHJlc3VsdCA6IE91dHB1dC5UZXN0X3Jlc3VsdC50KSwgKHRhZyA6IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudCkgPVxuICAgIG1hdGNoIGV4cGVjdGF0aW9uLmJlaGF2aW9yIHdpdGhcbiAgICB8IFVucmVhY2hhYmxlIF8gLT4gT3V0cHV0LmZhaWwgdGVzdF9vdXRwdXQsIFQgKFRhZyBcIlwiKVxuICAgIHwgRXhwZWN0IHsgcGF5bG9hZCA9IHsgY29udGVudHM7IHRhZyB9OyBvbl91bnJlYWNoYWJsZSA9IF87IHJlYWNoYWJpbGl0eSA9IF8gfSAtPlxuICAgICAgT3V0cHV0LnJlY29uY2lsZSB+ZXhwZWN0ZWRfb3V0cHV0OmNvbnRlbnRzIH50ZXN0X291dHB1dCwgdGFnXG4gIGluXG4gIChtYXRjaCByZXN1bHQgd2l0aFxuICAgfCBGYWlsIF8gLT4gZmFpbHVyZV9yZWYgOj0gdHJ1ZVxuICAgfCBQYXNzIC0+ICgpKTtcbiAgUXVldWUuZW5xdWV1ZSByZXN1bHRzIChSZWFjaGVkX3dpdGhfb3V0cHV0IHsgcmVzdWx0OyByYXcgPSB0ZXN0X291dHB1dF9yYXcgfSk7XG4gIHQucmVhY2hlZF90aGlzX3J1biA8LSB0cnVlO1xuICByZXN1bHQsIHRhZ1xuOztcblxubGV0IG9mX2V4cGVjdGF0aW9uIGV4cGVjdGF0aW9uID1cbiAgVCAoVGVzdCB7IGV4cGVjdGF0aW9uOyByZXN1bHRzID0gUXVldWUuY3JlYXRlICgpOyByZWFjaGVkX3RoaXNfcnVuID0gZmFsc2UgfSlcbjs7XG5cbmxldCByZWNvcmRfZW5kX29mX3J1biB0ID1cbiAgbGV0IChUIChUZXN0IHsgZXhwZWN0YXRpb24gPSBfOyByZXN1bHRzOyByZWFjaGVkX3RoaXNfcnVuIH0pKSA9IHQgaW5cbiAgaWYgbm90IHJlYWNoZWRfdGhpc19ydW4gdGhlbiBRdWV1ZS5lbnF1ZXVlIHJlc3VsdHMgRGlkX25vdF9yZWFjaFxuOztcblxubGV0IHJlY29yZF9yZXN1bHQgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfmZhaWx1cmVfcmVmIH50ZXN0X291dHB1dF9yYXcgKFQgaW5uZXIpID1cbiAgaWdub3JlXG4gICAgKHJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdCB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+ZmFpbHVyZV9yZWYgfnRlc3Rfb3V0cHV0X3JhdyBpbm5lclxuICAgICAgOiBPdXRwdXQuVGVzdF9yZXN1bHQudCAqIFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudClcbjs7XG5cbm1vZHVsZSBHbG9iYWxfcmVzdWx0c190YWJsZSA9IHN0cnVjdFxuICB0eXBlIG5vZGUgPSB0XG4gIHR5cGUgcG9zdHByb2Nlc3MgPSBub2RlIGxpc3QgV3JpdGVfY29ycmVjdGVkX2ZpbGUuUGF0Y2hfd2l0aF9maWxlX2NvbnRlbnRzLnRcblxuICB0eXBlIGZpbGUgPVxuICAgIHsgZXhwZWN0YXRpb25zIDogbm9kZSBIYXNodGJsLk0oRXhwZWN0YXRpb25faWQpLnRcbiAgICA7IHBvc3Rwcm9jZXNzIDogcG9zdHByb2Nlc3NcbiAgICB9XG5cbiAgbGV0IGdsb2JhbF9yZXN1bHRzX3RhYmxlIDogZmlsZSBIYXNodGJsLk0oU3RyaW5nKS50ID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBTdHJpbmcpXG5cbiAgbGV0IGZpbmRfdGVzdCB+YWJzb2x1dGVfZmlsZW5hbWUgfih0ZXN0X2lkIDogRXhwZWN0YXRpb25faWQudCkgPVxuICAgIEhhc2h0YmwuZmluZCBnbG9iYWxfcmVzdWx0c190YWJsZSBhYnNvbHV0ZV9maWxlbmFtZVxuICAgIHw+IE9wdGlvbi5iaW5kIH5mOihmdW4geyBleHBlY3RhdGlvbnM7IF8gfSAtPiBIYXNodGJsLmZpbmQgZXhwZWN0YXRpb25zIHRlc3RfaWQpXG4gICAgfD4gT3B0aW9uLnZhbHVlX2V4blxuICAgICAgICAgfmVycm9yOlxuICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nXG4gICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICBcIkludGVybmFsIGV4cGVjdCB0ZXN0IGJ1ZzogY291bGQgbm90IGZpbmQgdGVzdFxcbkZpbGU6ICVzXFxuSUQ6ICAgJWRcIlxuICAgICAgICAgICAgICAgICBhYnNvbHV0ZV9maWxlbmFtZVxuICAgICAgICAgICAgICAgICAoRXhwZWN0YXRpb25faWQudG9faW50X2V4biB0ZXN0X2lkKSkpXG4gIDs7XG5cbiAgbGV0IGluaXRpYWxpemVfYW5kX3JlZ2lzdGVyX3Rlc3RzIH5hYnNvbHV0ZV9maWxlbmFtZSB0ZXN0cyBwb3N0cHJvY2VzcyA9XG4gICAgbGV0IHRlc3RzX2FzX2luX3RhYmxlID0gUXVldWUuY3JlYXRlICgpIGluXG4gICAgSGFzaHRibC51cGRhdGUgZ2xvYmFsX3Jlc3VsdHNfdGFibGUgYWJzb2x1dGVfZmlsZW5hbWUgfmY6KGZ1biBmaWxlIC0+XG4gICAgICBsZXQgZmlsZSA9XG4gICAgICAgIE9wdGlvbi52YWx1ZVxuICAgICAgICAgIGZpbGVcbiAgICAgICAgICB+ZGVmYXVsdDp7IGV4cGVjdGF0aW9ucyA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgRXhwZWN0YXRpb25faWQpOyBwb3N0cHJvY2VzcyB9XG4gICAgICBpblxuICAgICAgbGV0IHRlc3RzID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBFeHBlY3RhdGlvbl9pZCkgdGVzdHMgaW5cbiAgICAgIEhhc2h0YmwubWVyZ2VfaW50b1xuICAgICAgICB+c3JjOnRlc3RzXG4gICAgICAgIH5kc3Q6ZmlsZS5leHBlY3RhdGlvbnNcbiAgICAgICAgfmY6KGZ1biB+a2V5OnRlc3RfaWQgbmV3X3Rlc3QgZXhpc3RpbmdfdGVzdCAtPlxuICAgICAgICBsZXQgKFQgKFRlc3QgdCkgYXMgdGVzdCkgPSBPcHRpb24udmFsdWUgZXhpc3RpbmdfdGVzdCB+ZGVmYXVsdDpuZXdfdGVzdCBpblxuICAgICAgICB0LnJlYWNoZWRfdGhpc19ydW4gPC0gZmFsc2U7XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdGVzdHNfYXNfaW5fdGFibGUgKHRlc3RfaWQsIHRlc3QpO1xuICAgICAgICBTZXRfdG8gdGVzdCk7XG4gICAgICBmaWxlKTtcbiAgICBRdWV1ZS50b19saXN0IHRlc3RzX2FzX2luX3RhYmxlXG4gIDs7XG5cbiAgbGV0IHByb2Nlc3NfZWFjaF9maWxlIH5mID1cbiAgICBnbG9iYWxfcmVzdWx0c190YWJsZVxuICAgIHw+IEhhc2h0YmwudG9fYWxpc3RcbiAgICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KENvbXBhcmFibGUubGlmdCB+Zjpmc3QgU3RyaW5nLmNvbXBhcmUpXG4gICAgfD4gTGlzdC5tYXAgfmY6KGZ1biAoZmlsZW5hbWUsIHsgZXhwZWN0YXRpb25zOyBwb3N0cHJvY2VzcyB9KSAtPlxuICAgICAgICAgbGV0IHRlc3Rfbm9kZXMgPSBIYXNodGJsLmRhdGEgZXhwZWN0YXRpb25zIGluXG4gICAgICAgICBmIH5maWxlbmFtZSB+dGVzdF9ub2RlcyB+cG9zdHByb2Nlc3MpXG4gIDs7XG5lbmRcblxubW9kdWxlIENyZWF0ZSA9IHN0cnVjdFxuICBsZXQgZXhwZWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgICBvZl9leHBlY3RhdGlvbiAoRXhwZWN0YXRpb24uZXhwZWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkKVxuICA7O1xuXG4gIGxldCBleHBlY3RfZXhhY3QgfmZvcm1hdHRpbmdfZmxleGliaWxpdHkgfm5vZGVfbG9jIH5sb2NhdGVkX3BheWxvYWQgPVxuICAgIG9mX2V4cGVjdGF0aW9uXG4gICAgICAoRXhwZWN0YXRpb24uZXhwZWN0X2V4YWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkKVxuICA7O1xuXG4gIGxldCBleHBlY3RfdW5yZWFjaGFibGUgfm5vZGVfbG9jID1cbiAgICBvZl9leHBlY3RhdGlvbiAoRXhwZWN0YXRpb24uZXhwZWN0X3VucmVhY2hhYmxlIH5ub2RlX2xvYylcbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX21sdCA9IHN0cnVjdFxuICBsZXQgbG9jIChUIChUZXN0IHsgZXhwZWN0YXRpb24gPSB7IHBvc2l0aW9uOyBfIH07IHJlc3VsdHMgPSBfOyByZWFjaGVkX3RoaXNfcnVuID0gXyB9KSkgPVxuICAgIEV4cGVjdGF0aW9uLkluc2VydF9sb2MubG9jIHBvc2l0aW9uXG4gIDs7XG5cbiAgbGV0IGV4cGVjdGF0aW9uX29mX3QgKFQgKFRlc3QgeyBleHBlY3RhdGlvbjsgcmVzdWx0cyA9IF87IHJlYWNoZWRfdGhpc19ydW4gPSBfIH0pKSA9XG4gICAgbWF0Y2ggZXhwZWN0YXRpb24uYmVoYXZpb3Igd2l0aFxuICAgIHwgRXhwZWN0IHsgcGF5bG9hZCA9IHsgY29udGVudHM7IHRhZyA9IF8gfTsgb25fdW5yZWFjaGFibGUgPSBfOyByZWFjaGFiaWxpdHkgPSBfIH0gLT5cbiAgICAgIFNvbWUgY29udGVudHNcbiAgICB8IFVucmVhY2hhYmxlIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCByZWNvcmRfYW5kX3JldHVybl9udW1iZXJfb2ZfbGluZXNfaW5fY29ycmVjdGlvblxuICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG4gICAgfmZhaWx1cmVfcmVmXG4gICAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAgIChUIChUZXN0IGlubmVyKSlcbiAgICA9XG4gICAgbWF0Y2hcbiAgICAgIHJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdFxuICAgICAgICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICAgICAgICB+ZmFpbHVyZV9yZWZcbiAgICAgICAgfnRlc3Rfb3V0cHV0X3Jhd1xuICAgICAgICAoVGVzdCBpbm5lcilcbiAgICB3aXRoXG4gICAgfCBGYWlsIGNvbnRlbnRzLCB0YWcgLT5cbiAgICAgIGxldCBjb3JyZWN0aW9uID1cbiAgICAgICAgT3V0cHV0LnRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWcgY29udGVudHMgfD4gT3V0cHV0LlBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nXG4gICAgICBpblxuICAgICAgU29tZSAoU3RyaW5nLmNvdW50IH5mOihDaGFyLmVxdWFsICdcXG4nKSBjb3JyZWN0aW9uICsgMSlcbiAgICB8IFBhc3MsIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCB0b19kaWZmcyB+Y3JfZm9yX211bHRpcGxlX291dHB1dHMgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgdCA9XG4gICAgbWF0Y2ggdG9fY29ycmVjdGlvbiB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+Y3JfZm9yX211bHRpcGxlX291dHB1dHMgdCB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGNvcnJlY3Rpb24gLT5cbiAgICAgIENvcnJlY3Rpb24udG9fZGlmZnMgY29ycmVjdGlvbiB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+b3JpZ2luYWxfZmlsZV9jb250ZW50c1xuICA7O1xuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsInRhZyIsIlBweF9leHBlY3RfcnVudGltZV9PdXRwdXQiLCJCYXNlX0NoYXIiLCJCYXNlX1N0cmluZyIsIlBweF9leHBlY3RfcnVudGltZV9FeHBlY3RhdGlvbiIsIkJhc2VfSGFzaHRibCIsIkJhc2UiLCJCYXNlX0NvbXBhcmFibGUiLCJCYXNlX0xpc3QiLCJCYXNlX09wdGlvbiIsIkJhc2VfUXVldWUiLCJQcHhfZXhwZWN0X3J1bnRpbWVfVHlwZXMiLCJCYXNlX1ByaW50ZiIsIkJhc2VfRXJyb3IiLCJ0b19kaWZmcyIsImV4cGVjdF9ub2RlX2Zvcm1hdHRpbmciLCJvcmlnaW5hbF9maWxlX2NvbnRlbnRzIiwiY29ycmVjdGlvbiIsInNhZmVfYnl0ZV9nZXQiLCJzdHJpbmciLCJpIiwib25faW5jb3JyZWN0X291dHB1dCIsInRlc3Rfb3V0cHV0IiwiYmVoYXZpb3IiLCJwb3NpdGlvbiIsIndoaXRlc3BhY2UiLCJtYXRjaCIsInN0YXJ0X3BvcyIsInN0YXJ0X2JvbCIsImxldF9vZmZzZXQiLCJpbmRlbnQiLCJsb2MiLCJwYXlsb2FkX2xvYyIsIm9uX3VucmVhY2hhYmxlIiwicHJlZml4IiwiZGlmZiIsImVuZF9wb3MiLCJtYWluX2NvcnJlY3Rpb24iLCJyZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWQiLCJib2R5X2xvYyIsImFkZF9zZW1pY29sb25fYmVmb3JlX3RyYWlsaW5nXyIsImFkZGl0aW9uYWxfY29ycmVjdGlvbnMiLCJyZWNvcmRfYW5kX3JldHVybl9yZXN1bHQiLCJmYWlsdXJlX3JlZiIsInRlc3Rfb3V0cHV0X3JhdyIsInQiLCJyZXN1bHRzIiwiZXhwZWN0YXRpb24iLCJjb250ZW50cyIsInJlc3VsdCIsIm9mX2V4cGVjdGF0aW9uIiwicmVjb3JkX2VuZF9vZl9ydW4iLCJyZWFjaGVkX3RoaXNfcnVuIiwicmVjb3JkX3Jlc3VsdCIsInBhcmFtIiwiaW5uZXIiLCJnbG9iYWxfcmVzdWx0c190YWJsZSIsImZpbmRfdGVzdCIsImFic29sdXRlX2ZpbGVuYW1lIiwidGVzdF9pZCIsImV4cGVjdGF0aW9ucyIsImluaXRpYWxpemVfYW5kX3JlZ2lzdGVyX3Rlc3RzIiwidGVzdHMiLCJwb3N0cHJvY2VzcyIsInRlc3RzX2FzX2luX3RhYmxlIiwiZmlsZSIsIm5ld190ZXN0IiwiZXhpc3RpbmdfdGVzdCIsInRlc3QiLCJwcm9jZXNzX2VhY2hfZmlsZSIsImZpbGVuYW1lIiwidGVzdF9ub2RlcyIsImV4cGVjdCIsImZvcm1hdHRpbmdfZmxleGliaWxpdHkiLCJub2RlX2xvYyIsImxvY2F0ZWRfcGF5bG9hZCIsImV4cGVjdF9leGFjdCIsImV4cGVjdF91bnJlYWNoYWJsZSIsIkNyZWF0ZSIsImV4cGVjdGF0aW9uX29mX3QiLCJyZWNvcmRfYW5kX3JldHVybl9udW1iZXJfb2ZfbGkiLCJjcl9mb3JfbXVsdGlwbGVfb3V0cHV0cyIsInJlc3VsdHNfbGlzdCIsIm91dHB1dCIsIm91dHB1dHNfbGlzdCIsInVucmVhY2hlZF9saXN0IiwiZGlzdGluY3Rfb3V0cHV0cyIsIndhc19yZWFjaGVkIiwicmVhY2hhYmlsaXR5IiwicmVhY2hhYmlsaXR5X2JlaGF2aW9yIiwicmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCIsImNvcnJlY3Rpb25fZm9yX3NpbmdsZV9yZXN1bHQiLCJyZWNlaXZlZCIsIm91dHB1dHMiLCJyYXciLCJQcHhfZXhwZWN0X3J1bnRpbWVfVGVzdF9ub2RlIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsUUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBVCxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFVLDRCQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDO0FBQUFBLElBQUFDLHdCQUFBQyx3QkFBQUM7QUFBQUEsYUFBQUMsY0FBQUMsUUFBQUM7QUFBQUEsS0N1Rk07QUFBQSxNQUFnRCw4Q0FBcUI7QUFBQSxLQUFNO0FBQUEsSUFBSTtBQUFBLElBMUVqRjtBQUFBO0FBQUE7QUFBQSxNQUFBQyxzQkFBQTtBQUFBLE1BQUFDLGNBQUE7QUFBQSxNQUFBQyxXQUFBO0FBQUEsTUFBQUMsV0FBQTtBQUFBLEtBU0U7QUFBQSxVQUFBQyxhQUFBO0FBQUE7QUFB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VUFFRDtBQUFBLFNBQWM7QUFBQSxLQUFBQyxlQUFBO0FBQUEsS0FBQUMsaUJBQUE7QUFBQSxlQUFBL0IsV0FBQUwsU0FPeEIsVUFBc0IsY0FBTztBQUFBO0FBQUEsU0FBakQ7QUFBQTtBQUFBLEtBQUFxQztBQUFBQSxPQUZKO0FBQUEsNENBRUk7QUFBQSxLQUFBQyxjQUdZO0FBQUEsS0FBQTdELFVBQ2xCO0FBQUE7QUFBQSxTQUFBOEQsZUFBQSxZQUFBQyx3QkFFZ0U7QUFBQTtBQUFBO0FBQUEsTUFBQUMsNEJBRmhFO0FBQUEsTUFBQUQsd0JBR2lEO0FBQUEsYUFBQUUsNkJBQUFyQztBQUFBQSxLQUc3QyxZQUNRO0FBQUEsU0FBQXNDLFdBRFI7QUFBQSxLQUVpQjtBQUFBLElBQTBDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUFBM0MsU0FFL0Q7QUFBQTtBQUFBLFVBQUF2QixVQWNFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFBQW1FO0FBQUFBLFFBUUU7QUFBQTtBQUFBO0FBQUEsbUJBQUF2QztBQUFBQSxXQUNlLGNBQUF3QyxNQUFBLGFBQzBCO0FBQUEsbUJBRWxDO0FBQUEsNkRBRTJDO0FBQUE7QUFBQSxVQUVwRDtBQUFBO0FBQUEsUUFDMEI7QUFBQTtBQUFBLFVBQXZCO0FBQUEsTUFBQXBFO0FBQUFBLFFBQ1c7QUFBQSxVQUZkO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFBQUgsV0EzQkE7QUFBQSxNQUFBRztBQUFBQSxRQUFBO0FBQUE7QUFBQTtBQUFBLFlBSXFCO0FBQUE7QUFBQTtBQUFBLElBNktpRCxjQUM1RDtBQUFBLFFBQUFULGFBRDREO0FBQUEsSUFHcEU7QUFBQSx3RUFBOEU7QUFBQTtBQUFBO0FBQUEsSUFBQThFO0FBQUFBLE1BakdFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURqUnRGIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTIwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9kcy9Eb2N1bWVudHMvcGF0Y2h3b3JrL19vcGFtL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvY3VycmVudF9maWxlLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxuXG5sZXQgY3VycmVudCA9IHJlZiBOb25lXG5cbmxldCBzZXQgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3QgPVxuICBtYXRjaCAhY3VycmVudCB3aXRoXG4gIHwgTm9uZSAtPiBjdXJyZW50IDo9IFNvbWUgZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdFxuICB8IFNvbWUgY3VycmVudCAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yLnNldDogdGhlcmUgaXMgYWxyZWFkeSBhbiBhY3RpdmUgZmlsZVwiXG4gICAgICAgICBbIFwib2xkX2ZpbGVcIiwgc2V4cF9vZl9zdHJpbmcgY3VycmVudFxuICAgICAgICAgOyBcIm5ld19maWxlXCIsIHNleHBfb2Zfc3RyaW5nIGZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3RcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgdW5zZXQgKCkgPVxuICBtYXRjaCAhY3VycmVudCB3aXRoXG4gIHwgU29tZSBfIC0+IGN1cnJlbnQgOj0gTm9uZVxuICB8IE5vbmUgLT5cbiAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IudW5zZXQ6IHRoZXJlIGlzIG5vIGFjdGl2ZSBmaWxlXCIgW10pXG47O1xuXG5sZXQgZ2V0ICgpID1cbiAgbWF0Y2ggIWN1cnJlbnQgd2l0aFxuICB8IFNvbWUgZm4gLT4gZm5cbiAgfCBOb25lIC0+IHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkV4cGVjdF90ZXN0X2NvbGxlY3Rvci5nZXQ6IHRoZXJlIGlzIG5vIGFjdGl2ZSBmaWxlXCIgW10pXG47O1xuXG5sZXQgaW5pdGlhbF9kaXIgPVxuICBsZXQgZGlyX29yX2Vycm9yID0gT3JfZXJyb3IudHJ5X3dpdGggfmJhY2t0cmFjZTp0cnVlIFN0ZGxpYi5TeXMuZ2V0Y3dkIGluXG4gIGxhenkgKE9yX2Vycm9yLm9rX2V4biBkaXJfb3JfZXJyb3IpXG47O1xuXG5sZXQgYWJzb2x1dGVfcGF0aCBmaWxlID1cbiAgaWYgU3RkbGliLkZpbGVuYW1lLmlzX3JlbGF0aXZlIGZpbGVcbiAgdGhlbiBTdGRsaWIuRmlsZW5hbWUuY29uY2F0IChMYXp5LmZvcmNlIGluaXRpYWxfZGlyKSBmaWxlXG4gIGVsc2UgZmlsZVxuOztcblxubGV0IHZlcmlmeV90aGF0X2ZpbGVfaXNfY3VycmVudF9leG4gfmxpbmVfbnVtYmVyIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290ID1cbiAgbGV0IHJlZ2lzdGVyaW5nX3Rlc3RzX2ZvciA9IGdldCAoKSBpblxuICBpZiBub3QgKFN0cmluZy5lcXVhbCBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290IHJlZ2lzdGVyaW5nX3Rlc3RzX2ZvcilcbiAgdGhlblxuICAgIFByaW50Zi5rc3ByaW50ZlxuICAgICAgZmFpbHdpdGhcbiAgICAgIFwiVHJ5aW5nIHRvIHJ1biBhbiBleHBlY3QgdGVzdCBmcm9tIHRoZSB3cm9uZyBmaWxlLlxcblxcXG4gICAgICAgLSB0ZXN0IGRlY2xhcmVkIGF0ICVzOiVkXFxuXFxcbiAgICAgICAtIHRyeWluZyB0byBydW4gaXQgZnJvbSAlc1xcblwiXG4gICAgICBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290XG4gICAgICBsaW5lX251bWJlclxuICAgICAgcmVnaXN0ZXJpbmdfdGVzdHNfZm9yXG4gIGVsc2UgKClcbjs7XG4iXSwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDMiLCJmIiwiYTAiLCJhMSIsImEyIiwiZ2xvYmFsX2RhdGEiLCJCYXNlX1N0cmluZyIsIkJhc2UiLCJCYXNlX1ByaW50ZiIsIlN0ZGxpYl9GaWxlbmFtZSIsIkNhbWxpbnRlcm5hbExhenkiLCJCYXNlX09yX2Vycm9yIiwiY3VycmVudCIsImNzdF9uZXdfZmlsZSIsImNzdF9vbGRfZmlsZSIsImNzdF9FeHBlY3RfdGVzdF9jb2xsZWN0b3Jfc2V0XyIsImNzdF9FeHBlY3RfdGVzdF9jb2xsZWN0b3JfdW5zZSIsImNzdF9FeHBlY3RfdGVzdF9jb2xsZWN0b3JfZ2V0XyIsInNldCIsImZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3QiLCJtYXRjaCIsInVuc2V0IiwicGFyYW0iLCJnZXQiLCJmbiIsImRpcl9vcl9lcnJvciIsImluaXRpYWxfZGlyIiwiYWJzb2x1dGVfcGF0aCIsImZpbGUiLCJ2ZXJpZnlfdGhhdF9maWxlX2lzX2N1cnJlbnRfZXgiLCJsaW5lX251bWJlciIsInJlZ2lzdGVyaW5nX3Rlc3RzX2ZvciIsIlBweF9leHBlY3RfcnVudGltZV9DdXJyZW50X2ZpbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsWUFBQUMsSUFBQUM7QUFBQUEsUUFBQUMsUUNLRTtBQUFBO0FBQUE7QUFBQSxNQUFBUixZQUFBO0FBQUE7QUFBQSxRQU9xQjtBQUFBO0FBQUE7QUFBQSxVQURBO0FBQUEsVUFGakI7QUFBQSxLQUlLO0FBQUE7QUFBQSxJQVBDO0FBQUE7QUFBQSxHQU9EO0FBQUEsWUFBQVMsTUFBQUM7QUFBQUEsSUFJVCxlQUNZO0FBQUEsWUFFRjtBQUFBLElBQXdFO0FBQUE7QUFBQSxZQUFBQyxJQUFBRDtBQUFBQSxRQUFBRixRQUlsRjtBQUFBLGtCQUFBSSxLQUFBLFVBQ2E7QUFBQSxZQUNLO0FBQUEsSUFBc0U7QUFBQTtBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFJckU7QUFBQSxrQ0Q5QnJCO0FBQUEsSUFBQUM7QUFBQUEsTUMrQkUsa0JEL0JGO0FBQUE7QUFBQSxNQytCRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLGNBQUFDO0FBQUFBLElBSUcsMENBRUU7QUFBQSxZQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpREFDSTtBQUFBO0FBQUEsWUFBQUM7QUFBQUEsSUFBQUMsYUFBQVg7QUFBQUEsUUFBQVksd0JBSW1CO0FBQUEsSUFDckI7QUFBQTtBQUFBO0FBQUEsY0FFTDtBQUFBO0FBQUE7QUFBQTtBQUFBLHFDQVFLO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1BckJQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQvQkYiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxMzIwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InBweF9leHBlY3RfcnVudGltZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL3BweF9leHBlY3QvcnVudGltZS90ZXN0X2Jsb2NrLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuXG4oKiBbU2hhcmVkXSBhbmQgW0NvbmZpZ3VyZWRdIHByaW1hcmlseSBjb250YWluIGJvaWxlcnBsYXRlIGludm9sdmluZyB0aGUgRkZJIGFuZCBwcmludGluZ1xuICAgW0NSXXMuIFRoZSBpbnRlcmVzdGluZyBsb2dpYyBpcyBpbiBbTWFrZV0uICopXG5cbm1vZHVsZSBTaGFyZWQgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHNyY19maWxlbmFtZSA6IHQgLT4gc3RyaW5nXG4gIHZhbCBvdXRwdXRfZmlsZSA6IHQgLT4gc3RyaW5nXG4gIHZhbCBmYWlsdXJlX3JlZiA6IHQgLT4gYm9vbCByZWZcbiAgdmFsIHNldF91cF9ibG9jayA6IHN0cmluZyAtPiB0XG4gIHZhbCByZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkIDogdCAtPiBzdHJpbmdcbiAgdmFsIGZsdXNoIDogdW5pdCAtPiB1bml0XG4gIHZhbCBjbGVhbl91cF9ibG9jayA6IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBzcmNfZmlsZW5hbWUgOiBzdHJpbmdcbiAgICA7IG91dHB1dF9maWxlIDogc3RyaW5nXG4gICAgOyBmYWlsIDogYm9vbCByZWZcbiAgICA7IHRlc3Rfb3V0cHV0X3JlYWRlciA6IFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgOyB0ZXN0X291dHB1dF93cml0ZXIgOiBTdGRsaWIub3V0X2NoYW5uZWxcbiAgICA7IG9sZF9vZmZzZXQgOiBpbnQgcmVmXG4gICAgfVxuXG4gIGxldCBzcmNfZmlsZW5hbWUgeyBzcmNfZmlsZW5hbWU7IF8gfSA9IHNyY19maWxlbmFtZVxuICBsZXQgb3V0cHV0X2ZpbGUgeyBvdXRwdXRfZmlsZTsgXyB9ID0gb3V0cHV0X2ZpbGVcbiAgbGV0IGZhaWx1cmVfcmVmIHsgZmFpbDsgXyB9ID0gZmFpbFxuXG4gIGV4dGVybmFsIHJlZGlyZWN0X3N0ZG91dFxuICAgIDogIG91dHB1dDpTdGRsaWIub3V0X2NoYW5uZWxcbiAgICAtPiBzdGRvdXQ6U3RkbGliLm91dF9jaGFubmVsXG4gICAgLT4gc3RkZXJyOlN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIC0+IHVuaXRcbiAgICA9IFwicHB4X2V4cGVjdF9ydW50aW1lX2JlZm9yZV90ZXN0XCJcblxuICBleHRlcm5hbCByZXN0b3JlX3N0ZG91dFxuICAgIDogIHN0ZG91dDpTdGRsaWIub3V0X2NoYW5uZWxcbiAgICAtPiBzdGRlcnI6U3RkbGliLm91dF9jaGFubmVsXG4gICAgLT4gdW5pdFxuICAgID0gXCJwcHhfZXhwZWN0X3J1bnRpbWVfYWZ0ZXJfdGVzdFwiXG5cbiAgZXh0ZXJuYWwgcG9zX291dCA6IFN0ZGxpYi5vdXRfY2hhbm5lbCAtPiBpbnQgPSBcInBweF9leHBlY3RfcnVudGltZV9vdXRfY2hhbm5lbF9wb3NpdGlvblwiXG4gIGV4dGVybmFsIGZsdXNoX3N0dWJzIDogdW5pdCAtPiB1bml0ID0gXCJwcHhfZXhwZWN0X3J1bnRpbWVfZmx1c2hfc3R1YnNfc3RyZWFtc1wiXG5cbiAgKCogU2F2ZSBzdGQgZmlsZSBkZXNjcmlwdG9ycywgb3BlbiBhIHRlbXAgZmlsZSBmb3IgdGVzdCBvdXRwdXQsIGFuZCByZXJvdXRlIHN0ZG91dCBhbmRcbiAgICAgc3RkZXJyIHRoZXJlLiAqKVxuICBsZXQgc2V0X3VwX2Jsb2NrIHNyY19maWxlbmFtZSA9XG4gICAgbGV0IG91dHB1dF9maWxlID1cbiAgICAgIEN1cnJlbnRfZmlsZS5hYnNvbHV0ZV9wYXRoIChTdGRsaWIuRmlsZW5hbWUudGVtcF9maWxlIFwiZXhwZWN0LXRlc3RcIiBcIm91dHB1dFwiKVxuICAgIGluXG4gICAgbGV0IHRlc3Rfb3V0cHV0X3dyaXRlciA9XG4gICAgICBTdGRsaWIub3Blbl9vdXRfZ2VuIFsgT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fYmluYXJ5IF0gMG82NDQgb3V0cHV0X2ZpbGVcbiAgICBpblxuICAgIGxldCB0ZXN0X291dHB1dF9yZWFkZXIgPSBTdGRsaWIub3Blbl9pbl9iaW4gb3V0cHV0X2ZpbGUgaW5cbiAgICByZWRpcmVjdF9zdGRvdXQgfm91dHB1dDp0ZXN0X291dHB1dF93cml0ZXIgfnN0ZG91dDpTdGRsaWIuc3Rkb3V0IH5zdGRlcnI6U3RkbGliLnN0ZGVycjtcbiAgICB7IHNyY19maWxlbmFtZVxuICAgIDsgb3V0cHV0X2ZpbGVcbiAgICA7IHRlc3Rfb3V0cHV0X3JlYWRlclxuICAgIDsgdGVzdF9vdXRwdXRfd3JpdGVyXG4gICAgOyBvbGRfb2Zmc2V0ID0gcmVmIDBcbiAgICA7IGZhaWwgPSByZWYgZmFsc2VcbiAgICB9XG4gIDs7XG5cbiAgKCogQ2xvc2UgdGhlIHRlbXAgZmlsZSBhbmQgcmVzdG9yZSBzdGRvdXQgYW5kIHN0ZGVyci4gKilcbiAgbGV0IGNsZWFuX3VwX2Jsb2NrIHsgb3V0cHV0X2ZpbGU7IHRlc3Rfb3V0cHV0X3JlYWRlcjsgdGVzdF9vdXRwdXRfd3JpdGVyOyBfIH0gPVxuICAgIFN0ZGxpYi5jbG9zZV9pbiB0ZXN0X291dHB1dF9yZWFkZXI7XG4gICAgcmVzdG9yZV9zdGRvdXQgfnN0ZG91dDpTdGRsaWIuc3Rkb3V0IH5zdGRlcnI6U3RkbGliLnN0ZGVycjtcbiAgICBTdGRsaWIuY2xvc2Vfb3V0IHRlc3Rfb3V0cHV0X3dyaXRlcjtcbiAgICBTdGRsaWIuU3lzLnJlbW92ZSBvdXRwdXRfZmlsZVxuICA7O1xuXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgU3RkbGliLkZvcm1hdC5wcF9wcmludF9mbHVzaCBTdGRsaWIuRm9ybWF0LnN0ZF9mb3JtYXR0ZXIgKCk7XG4gICAgU3RkbGliLkZvcm1hdC5wcF9wcmludF9mbHVzaCBTdGRsaWIuRm9ybWF0LmVycl9mb3JtYXR0ZXIgKCk7XG4gICAgU3RkbGliLmZsdXNoIFN0ZGxpYi5zdGRvdXQ7XG4gICAgU3RkbGliLmZsdXNoIFN0ZGxpYi5zdGRlcnI7XG4gICAgZmx1c2hfc3R1YnMgKClcbiAgOztcblxuICBsZXQgcmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCB7IHRlc3Rfb3V0cHV0X3JlYWRlcjsgb2xkX29mZnNldDsgXyB9ID1cbiAgICBsZXQgbmV3X29mZnNldCA9XG4gICAgICBmbHVzaCAoKTtcbiAgICAgIHBvc19vdXQgU3RkbGliLnN0ZG91dFxuICAgIGluXG4gICAgbGV0IGxlbiA9IG5ld19vZmZzZXQgLSAhb2xkX29mZnNldCBpblxuICAgIG9sZF9vZmZzZXQgOj0gbmV3X29mZnNldDtcbiAgICBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyB0ZXN0X291dHB1dF9yZWFkZXIgbGVuXG4gIDs7XG5lbmRcblxubW9kdWxlIENvbmZpZ3VyZWQgKEMgOiBFeHBlY3RfdGVzdF9jb25maWdfdHlwZXMuUykgPSBzdHJ1Y3RcbiAgbGV0IGNyX3ByZWZpeCA9XG4gICAgbWF0Y2ggQy51cG9uX3VucmVsZWFzYWJsZV9pc3N1ZSB3aXRoXG4gICAgfCBgQ1IgLT4gXCJDUiBcIlxuICAgIHwgYFdhcm5pbmdfZm9yX2NvbGxlY3Rvcl90ZXN0aW5nIC0+IFwiXCJcbiAgOztcblxuICBsZXQgY3JfZm9yX2JhY2t0cmFjZSA9XG4gICAgUHJpbnRmLnNwcmludGZcbiAgICAgIHt8KCogJXNleHBlY3RfdGVzdF9jb2xsZWN0b3I6IFRoaXMgdGVzdCBleHBlY3RhdGlvbiBhcHBlYXJzIHRvIGNvbnRhaW4gYSBiYWNrdHJhY2UuXG4gICBUaGlzIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkIGFzIGJhY2t0cmFjZXMgYXJlIGZyYWdpbGUuXG4gICBQbGVhc2UgY2hhbmdlIHRoaXMgdGVzdCB0byBub3QgaW5jbHVkZSBhIGJhY2t0cmFjZS4gKil8fVxuICAgICAgY3JfcHJlZml4XG4gIDs7XG5cbiAgbGV0IGNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIH5vdXRwdXRfbmFtZSB+b3V0cHV0cyA9XG4gICAgbGV0IGNyX2JvZHkgPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCJUZXN0IHJhbiBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCAlc3NcIiBvdXRwdXRfbmFtZVxuICAgIGluXG4gICAgbGV0IGNyID0gUHJpbnRmLnNwcmludGYgXCIoKiAlc2V4cGVjdF90ZXN0OiAlcyAqKVwiIGNyX3ByZWZpeCBjcl9ib2R5IGluXG4gICAgbGV0IG51bV9vdXRwdXRzID0gTGlzdC5sZW5ndGggb3V0cHV0cyBpblxuICAgIGxldCBoZWFkZXIgaW5kZXggPVxuICAgICAgbGV0IGhlYWRlciA9IFByaW50Zi5zcHJpbnRmIFwiPT09IE91dHB1dCAlZCAvICVkID09PVwiIChpbmRleCArIDEpIG51bV9vdXRwdXRzIGluXG4gICAgICBsZXQgcGFkX2xlbmd0aCA9IFN0cmluZy5sZW5ndGggY3IgLSBTdHJpbmcubGVuZ3RoIGhlYWRlciBpblxuICAgICAgaWYgcGFkX2xlbmd0aCA8PSAwXG4gICAgICB0aGVuIGhlYWRlclxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBscGFkID0gU3RyaW5nLm1ha2UgKHBhZF9sZW5ndGggLyAyKSAnPScgaW5cbiAgICAgICAgbGV0IHJwYWQgPSBTdHJpbmcubWFrZSAocGFkX2xlbmd0aCAtIChwYWRfbGVuZ3RoIC8gMikpICc9JyBpblxuICAgICAgICBQcmludGYuc3ByaW50ZiBcIiVzJXMlc1wiIGxwYWQgaGVhZGVyIHJwYWQpXG4gICAgaW5cbiAgICBsZXQgb3V0cHV0c193aXRoX2hlYWRlcnMgPVxuICAgICAgTGlzdC5jb25jYXRfbWFwaSBvdXRwdXRzIH5mOihmdW4gaW5kZXggb3V0cHV0IC0+IFsgaGVhZGVyIGluZGV4OyBvdXRwdXQgXSlcbiAgICBpblxuICAgIFN0cmluZy5jb25jYXQgKGNyIDo6IG91dHB1dHNfd2l0aF9oZWFkZXJzKSB+c2VwOlwiXFxuXCJcbiAgOztcblxuICBsZXQgc2FuaXRpemUgPSBDLnNhbml0aXplXG5cbiAgbGV0IGNoZWNrX2Zvcl9iYWNrdHJhY2VzIHMgPVxuICAgIGlmIExpc3QuZXhpc3RzXG4gICAgICAgICB+ZjooZnVuIHN1YnN0cmluZyAtPiBTdHJpbmcuaXNfc3Vic3RyaW5nIH5zdWJzdHJpbmcgcylcbiAgICAgICAgIFsgXCJSYWlzZWQgYXQgXCI7IFwiQ2FsbGVkIGZyb20gXCI7IFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gXCIgXVxuICAgIHRoZW4gY3JfZm9yX2JhY2t0cmFjZSBeIFwiXFxuXFxuXCIgXiBzXG4gICAgZWxzZSBzXG4gIDs7XG5cbiAgbGV0IGR1bXBfYmFja3RyYWNlIHBvc3NpYmxlX2V4biA9XG4gICAgbWF0Y2ggQy5ydW4gcG9zc2libGVfZXhuIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIGxldCBidCA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgbGV0IGV4bl9zdHJpbmcgPVxuICAgICAgICB0cnkgRXhuLnRvX3N0cmluZyBleG4gd2l0aFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBsZXQgbmFtZSA9XG4gICAgICAgICAgICBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuXG4gICAgICAgICAgICB8PiBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgaW5cbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIihcXFwiJXMoQ2Fubm90IHByaW50IG1vcmUgZGV0YWlscywgRXhuLnRvX3N0cmluZyBmYWlsZWQpXFxcIilcIiBuYW1lXG4gICAgICBpblxuICAgICAgU29tZVxuICAgICAgICAobWF0Y2ggU3RkbGliLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIGJ0IHdpdGhcbiAgICAgICAgIHwgXCJcIiAtPiBleG5fc3RyaW5nXG4gICAgICAgICB8IGJ0IC0+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiIFsgY3JfZm9yX2JhY2t0cmFjZTsgZXhuX3N0cmluZzsgYnQgXSlcbiAgICB8IF8gLT4gTm9uZVxuICA7O1xuZW5kXG5cbigqIFRoZSBleHBlY3QgdGVzdCBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIHNvbWUgaW5mbyB3ZSBwcmludCBpZiB0aGUgcHJvZ3JhbVxuICAgY3Jhc2hlcyBpbiB0aGUgbWlkZGxlIG9mIGEgdGVzdC4gKilcbm1vZHVsZSBDdXJyZW50X3Rlc3QgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IGxpbmVfbnVtYmVyIDogaW50XG4gICAgOyBiYXNlbmFtZSA6IHN0cmluZ1xuICAgIDsgbG9jYXRpb24gOiBDb21wYWN0X2xvYy50XG4gICAgOyB0ZXN0X2Jsb2NrIDogU2hhcmVkLnRcbiAgICB9XG5cbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuICB2YWwgdW5zZXQgOiB1bml0IC0+IHVuaXRcbiAgdmFsIGlzX3J1bm5pbmcgOiB1bml0IC0+IGJvb2xcbiAgdmFsIGN1cnJlbnRfdGVzdCA6IHVuaXQgLT4gU2hhcmVkLnQgb3B0aW9uXG4gIHZhbCBjdXJyZW50X3Rlc3RfZXhuIDogdW5pdCAtPiBTaGFyZWQudFxuICB2YWwgaXRlciA6IGY6KHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgYXNzZXJ0X25vX3Rlc3RfcnVubmluZyA6IGJhc2VuYW1lOnN0cmluZyAtPiBsaW5lX251bWJlcjppbnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBsaW5lX251bWJlciA6IGludFxuICAgIDsgYmFzZW5hbWUgOiBzdHJpbmdcbiAgICA7IGxvY2F0aW9uIDogQ29tcGFjdF9sb2MudFxuICAgIDsgdGVzdF9ibG9jayA6IFNoYXJlZC50XG4gICAgfVxuXG4gIGxldCB0ZXN0X2lzX3J1bm5pbmcgOiB0IG9wdGlvbiByZWYgPSByZWYgTm9uZVxuICBsZXQgc2V0IHQgPSB0ZXN0X2lzX3J1bm5pbmcgOj0gU29tZSB0XG4gIGxldCB1bnNldCAoKSA9IHRlc3RfaXNfcnVubmluZyA6PSBOb25lXG4gIGxldCBpc19ydW5uaW5nICgpID0gT3B0aW9uLmlzX3NvbWUgIXRlc3RfaXNfcnVubmluZ1xuXG4gIGxldCBjdXJyZW50X3Rlc3QgKCkgPVxuICAgIE9wdGlvbi5tYXAgIXRlc3RfaXNfcnVubmluZyB+ZjooZnVuIHsgdGVzdF9ibG9jazsgXyB9IC0+IHRlc3RfYmxvY2spXG4gIDs7XG5cbiAgbGV0IGN1cnJlbnRfdGVzdF9leG4gKCkgPSBPcHRpb24udmFsdWVfZXhuIChjdXJyZW50X3Rlc3QgKCkpXG4gIGxldCBpdGVyIH5mID0gT3B0aW9uLml0ZXIgIXRlc3RfaXNfcnVubmluZyB+ZlxuXG4gIGxldCBhc3NlcnRfbm9fdGVzdF9ydW5uaW5nIH5iYXNlbmFtZSB+bGluZV9udW1iZXIgPVxuICAgIGl0ZXJcbiAgICAgIH5mOlxuICAgICAgICAoZnVuXG4gICAgICAgICAgeyBsaW5lX251bWJlciA9IG91dGVyX2xpbmVfbnVtYmVyXG4gICAgICAgICAgOyBiYXNlbmFtZSA9IG91dGVyX2Jhc2VuYW1lXG4gICAgICAgICAgOyBsb2NhdGlvbiA9IF9cbiAgICAgICAgICA7IHRlc3RfYmxvY2sgPSBfXG4gICAgICAgICAgfVxuICAgICAgICAgIC0+XG4gICAgICBsZXQgc2V4cF9oZXJlIH5iYXNlbmFtZSB+bGluZV9udW1iZXIgOiBTZXhwLnQgPVxuICAgICAgICBMaXN0XG4gICAgICAgICAgWyBMaXN0IFsgQXRvbSBcImZpbGVcIjsgc2V4cF9vZl9zdHJpbmcgYmFzZW5hbWUgXVxuICAgICAgICAgIDsgTGlzdCBbIEF0b20gXCJsaW5lXCI7IHNleHBfb2ZfaW50IGxpbmVfbnVtYmVyIF1cbiAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiRXhwZWN0X3Rlc3RfcnVudGltZTogcmVhY2hlZCBvbmUgW2xldCVleHBlY3RfdGVzdF0gZnJvbSBhbm90aGVyLiBOZXN0aW5nIFxcXG4gICAgICAgICAgICBleHBlY3RcXG5cXFxuICAgICAgICAgICAgdGVzdHMgaXMgcHJvaGliaXRlZC5cIlxuICAgICAgICAgICBbICggXCJvdXRlcl90ZXN0XCJcbiAgICAgICAgICAgICAsIHNleHBfaGVyZSB+YmFzZW5hbWU6b3V0ZXJfYmFzZW5hbWUgfmxpbmVfbnVtYmVyOm91dGVyX2xpbmVfbnVtYmVyIClcbiAgICAgICAgICAgOyBcImlubmVyX3Rlc3RcIiwgc2V4cF9oZXJlIH5iYXNlbmFtZSB+bGluZV9udW1iZXJcbiAgICAgICAgICAgXSkpXG4gIDs7XG5lbmRcblxuKCogVGhlIG1haW4gdGVzdGluZyBmdW5jdGlvbnMgb2YgYSB0ZXN0IGJsb2NrLCB3aGljaCBkZXBlbmQgb24gY29uZmlndXJhdGlvbnMuICopXG5tb2R1bGUgTWFrZSAoQyA6IEV4cGVjdF90ZXN0X2NvbmZpZ190eXBlcy5TKSA9IHN0cnVjdFxuICBtb2R1bGUgQ29uZmlndXJlZCA9IENvbmZpZ3VyZWQgKEMpXG5cbiAgbGV0IHJlYWRfdGVzdF9vdXRwdXRfbm9fYmFja3RyYWNlX2NoZWNrICgpID1cbiAgICBDdXJyZW50X3Rlc3QuY3VycmVudF90ZXN0X2V4biAoKVxuICAgIHw+IFNoYXJlZC5yZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkXG4gICAgfD4gQ29uZmlndXJlZC5zYW5pdGl6ZVxuICA7O1xuXG4gIGxldCByZWFkX3Rlc3Rfb3V0cHV0X3Nhbml0aXplZF9hbmRfY2hlY2tlZCAoKSA9XG4gICAgcmVhZF90ZXN0X291dHB1dF9ub19iYWNrdHJhY2VfY2hlY2sgKCkgfD4gQ29uZmlndXJlZC5jaGVja19mb3JfYmFja3RyYWNlc1xuICA7O1xuXG4gIGxldCBydW5fdGVzdF9pbm5lciB+dGVzdF9pZCB+dGVzdF9vdXRwdXRfcmF3IHQgPVxuICAgIFRlc3Rfbm9kZS5yZWNvcmRfcmVzdWx0XG4gICAgICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZzpFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmRlZmF1bHRcbiAgICAgIH5mYWlsdXJlX3JlZjooU2hhcmVkLmZhaWx1cmVfcmVmIHQpXG4gICAgICB+dGVzdF9vdXRwdXRfcmF3XG4gICAgICAoVGVzdF9ub2RlLkdsb2JhbF9yZXN1bHRzX3RhYmxlLmZpbmRfdGVzdFxuICAgICAgICAgfmFic29sdXRlX2ZpbGVuYW1lOihTaGFyZWQuc3JjX2ZpbGVuYW1lIHQpXG4gICAgICAgICB+dGVzdF9pZClcbiAgOztcblxuICBsZXQgcnVuX3Rlc3QgfnRlc3RfaWQgPVxuICAgIEN1cnJlbnRfdGVzdC5jdXJyZW50X3Rlc3RfZXhuICgpXG4gICAgfD4gcnVuX3Rlc3RfaW5uZXJcbiAgICAgICAgIH50ZXN0X2lkXG4gICAgICAgICB+dGVzdF9vdXRwdXRfcmF3OihyZWFkX3Rlc3Rfb3V0cHV0X3Nhbml0aXplZF9hbmRfY2hlY2tlZCAoKSlcbiAgOztcblxuICBsZXQgcnVuX3N1aXRlXG4gICAgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3RcbiAgICB+bGluZV9udW1iZXJcbiAgICB+KGxvY2F0aW9uIDogQ29tcGFjdF9sb2MudClcbiAgICB+KHRyYWlsaW5nX2xvYyA6IENvbXBhY3RfbG9jLnQpXG4gICAgfihib2R5X2xvYyA6IENvbXBhY3RfbG9jLnQpXG4gICAgfmZvcm1hdHRpbmdfZmxleGliaWxpdHlcbiAgICB+ZXhwZWN0ZWRfZXhuXG4gICAgfnRyYWlsaW5nX3Rlc3RfaWRcbiAgICB+ZXhuX3Rlc3RfaWRcbiAgICB+ZGVzY3JpcHRpb25cbiAgICB+dGFnc1xuICAgIH5pbmxpbmVfdGVzdF9jb25maWdcbiAgICB+ZXhwZWN0YXRpb25zXG4gICAgZlxuICAgID1cbiAgICBsZXQgKHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfSA6IENvbXBhY3RfbG9jLnQpID0gbG9jYXRpb24gaW5cbiAgICBsZXQgYmFzZW5hbWUgPSBTdGRsaWIuRmlsZW5hbWUuYmFzZW5hbWUgZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdCBpblxuICAgICgqIEV2ZW4gaWYgdGhlIGN1cnJlbnQgdGFnIHNldCBpbmRpY2F0ZXMgdGhpcyB0ZXN0IHNob3VsZCBiZSBkcm9wcGVkLCBjaGVjayB0aGF0IGl0XG4gICAgICAgd2Fzbid0IHJlYWNoZWQgZnJvbSBhbm90aGVyIGV4cGVjdCB0ZXN0ICopXG4gICAgQ3VycmVudF90ZXN0LmFzc2VydF9ub190ZXN0X3J1bm5pbmcgfmJhc2VuYW1lIH5saW5lX251bWJlcjtcbiAgICBQcHhfaW5saW5lX3Rlc3RfbGliLnRlc3RcbiAgICAgIH5jb25maWc6aW5saW5lX3Rlc3RfY29uZmlnXG4gICAgICB+ZGVzY3I6KGxhenkgKE9wdGlvbi52YWx1ZSBkZXNjcmlwdGlvbiB+ZGVmYXVsdDpcIlwiKSlcbiAgICAgIH50YWdzXG4gICAgICB+ZmlsZW5hbWU6YmFzZW5hbWVcbiAgICAgIH5saW5lX251bWJlclxuICAgICAgfnN0YXJ0X3Bvczooc3RhcnRfcG9zIC0gc3RhcnRfYm9sKVxuICAgICAgfmVuZF9wb3M6KGVuZF9wb3MgLSBzdGFydF9ib2wpXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgICgqIENoZWNrIHRoYXQgdGhlIHRlc3QgaXMgYmVpbmcgcnVuIGZyb20gdGhlIGZpbGUgaW4gd2hpY2ggaXQgd2FzIGRlZmluZWQgKilcbiAgICAgICAgQ3VycmVudF9maWxlLnZlcmlmeV90aGF0X2ZpbGVfaXNfY3VycmVudF9leG5cbiAgICAgICAgICB+bGluZV9udW1iZXJcbiAgICAgICAgICB+ZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdDtcbiAgICAgICAgbGV0IGFic29sdXRlX2ZpbGVuYW1lID0gQ3VycmVudF9maWxlLmFic29sdXRlX3BhdGggYmFzZW5hbWUgaW5cbiAgICAgICAgKCogQ3JlYXRlIHRoZSB0ZXN0cyBmb3IgdHJhaWxpbmcgb3V0cHV0IGFuZCB1bmNhdWdodCBleGNlcHRpb25zICopXG4gICAgICAgIGxldCBleHBlY3RhdGlvbnMgPVxuICAgICAgICAgIGxldCB0cmFpbGluZ190ZXN0ID1cbiAgICAgICAgICAgIEV4cGVjdGF0aW9uLmV4cGVjdF90cmFpbGluZ1xuICAgICAgICAgICAgICB+aW5zZXJ0X2xvYzpcbiAgICAgICAgICAgICAgICB7IGxvYyA9IHsgdHJhaWxpbmdfbG9jIHdpdGggZW5kX3BvcyA9IHRyYWlsaW5nX2xvYy5zdGFydF9wb3MgfTsgYm9keV9sb2MgfVxuICAgICAgICAgICAgfD4gVGVzdF9ub2RlLm9mX2V4cGVjdGF0aW9uXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgZXhuX3Rlc3QgPVxuICAgICAgICAgICAgbWF0Y2ggZXhwZWN0ZWRfZXhuIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgICAgIEV4cGVjdGF0aW9uLmV4cGVjdF91bmNhdWdodF9leG5cbiAgICAgICAgICAgICAgICB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuICAgICAgICAgICAgICAgIH5sb2NhdGVkX3BheWxvYWQ6ZXhwZWN0ZWRfZXhuXG4gICAgICAgICAgICAgICAgfm5vZGVfbG9jOnRyYWlsaW5nX2xvY1xuICAgICAgICAgICAgICB8PiBUZXN0X25vZGUub2ZfZXhwZWN0YXRpb25cbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBFeHBlY3RhdGlvbi5leHBlY3Rfbm9fdW5jYXVnaHRfZXhuXG4gICAgICAgICAgICAgICAgfmluc2VydF9sb2M6eyBsb2MgPSB0cmFpbGluZ19sb2M7IGJvZHlfbG9jIH1cbiAgICAgICAgICAgICAgfD4gVGVzdF9ub2RlLm9mX2V4cGVjdGF0aW9uXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoZXhuX3Rlc3RfaWQsIGV4bl90ZXN0KSA6OiAodHJhaWxpbmdfdGVzdF9pZCwgdHJhaWxpbmdfdGVzdCkgOjogZXhwZWN0YXRpb25zXG4gICAgICAgIGluXG4gICAgICAgICgqIEFkZCB0aGUgdGVzdHMgdG8gdGhlIGdsb2JhbCB0YWJsZSBhbmQgcmVzZXQgdGhlaXIgW3JlYWNoZWRfdGhpc19ydW5dIGZsYWdzICopXG4gICAgICAgIGxldCBleHBlY3RhdGlvbnMgPVxuICAgICAgICAgIFRlc3Rfbm9kZS5HbG9iYWxfcmVzdWx0c190YWJsZS5pbml0aWFsaXplX2FuZF9yZWdpc3Rlcl90ZXN0c1xuICAgICAgICAgICAgfmFic29sdXRlX2ZpbGVuYW1lXG4gICAgICAgICAgICBleHBlY3RhdGlvbnNcbiAgICAgICAgICAgIChmdW4gfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgdHMgLT5cbiAgICAgICAgICAgIExpc3QuY29uY2F0X21hcFxuICAgICAgICAgICAgICB0c1xuICAgICAgICAgICAgICB+ZjpcbiAgICAgICAgICAgICAgICAoVGVzdF9ub2RlLkZvcl9tbHQudG9fZGlmZnNcbiAgICAgICAgICAgICAgICAgICB+Y3JfZm9yX211bHRpcGxlX291dHB1dHM6Q29uZmlndXJlZC5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nOkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzKSlcbiAgICAgICAgaW5cbiAgICAgICAgKCogVG8gYXZvaWQgY2FwdHVyaW5nIG5vdC15ZXQgZmx1c2hlZCBkYXRhIG9mIHRoZSBzdGRvdXQvc3RkZXJyIGJ1ZmZlcnMuICopXG4gICAgICAgIFNoYXJlZC5mbHVzaCAoKTtcbiAgICAgICAgKCogUmVkaXJlY3Qgc3Rkb3V0L3N0ZGVyciAqKVxuICAgICAgICBsZXQgdGVzdF9ibG9jayA9IFNoYXJlZC5zZXRfdXBfYmxvY2sgYWJzb2x1dGVfZmlsZW5hbWUgaW5cbiAgICAgICAgKCogUnVuIHRoZSB0ZXN0ICopXG4gICAgICAgIEN1cnJlbnRfdGVzdC5zZXQgeyBsaW5lX251bWJlcjsgYmFzZW5hbWU7IGxvY2F0aW9uOyB0ZXN0X2Jsb2NrIH07XG4gICAgICAgIGxldCB0ZXN0X2V4biA9XG4gICAgICAgICAgQ29uZmlndXJlZC5kdW1wX2JhY2t0cmFjZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAoKiBJZ25vcmUgb3V0cHV0IHRoYXQgd2FzIHByaW50ZWQgYmVmb3JlIHRoZSB0ZXN0IHN0YXJ0ZWQgKilcbiAgICAgICAgICAgIGxldCAoXyA6IHN0cmluZykgPSBTaGFyZWQucmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCB0ZXN0X2Jsb2NrIGluXG4gICAgICAgICAgICBmICgpKVxuICAgICAgICBpblxuICAgICAgICAoKiBSdW4gdGhlIHRyYWlsaW5nIG91dHB1dCBhbmQgdW5jYXVnaHQgZXhuIHRlc3QgKilcbiAgICAgICAgbGV0IHRlc3Rfb3V0cHV0LCB0ZXN0X3RvX3J1biA9XG4gICAgICAgICAgbGV0IHRyYWlsaW5nX291dHB1dCA9XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdfcmF3ID0gcmVhZF90ZXN0X291dHB1dF9zYW5pdGl6ZWRfYW5kX2NoZWNrZWQgKCkgaW5cbiAgICAgICAgICAgIG1hdGNoIFN0cmluZy5zdHJpcCB0cmFpbGluZ19yYXcgd2l0aFxuICAgICAgICAgICAgfCBcIlwiIC0+IE5vbmVcbiAgICAgICAgICAgIHwgXyAtPiBTb21lIHRyYWlsaW5nX3Jhd1xuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggdGVzdF9leG4gd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBPcHRpb24udmFsdWUgdHJhaWxpbmdfb3V0cHV0IH5kZWZhdWx0OlwiXCIsIHRyYWlsaW5nX3Rlc3RfaWRcbiAgICAgICAgICB8IFNvbWUgdGVzdF9leG4gLT5cbiAgICAgICAgICAgIGxldCB0ZXN0X291dHB1dCA9XG4gICAgICAgICAgICAgIG1hdGNoIHRyYWlsaW5nX291dHB1dCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiB0ZXN0X2V4blxuICAgICAgICAgICAgICB8IFNvbWUgdHJhaWxpbmdfb3V0cHV0IC0+XG4gICAgICAgICAgICAgICAgU3RyaW5nLmNvbmNhdFxuICAgICAgICAgICAgICAgICAgfnNlcDpcIlxcblwiXG4gICAgICAgICAgICAgICAgICBbIHRlc3RfZXhuOyBcIlRyYWlsaW5nIG91dHB1dFwiOyBcIi0tLS0tLS0tLS0tLS0tLVwiOyB0cmFpbGluZ19vdXRwdXQgXVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHRlc3Rfb3V0cHV0LCBleG5fdGVzdF9pZFxuICAgICAgICBpblxuICAgICAgICBydW5fdGVzdF9pbm5lciB0ZXN0X2Jsb2NrIH50ZXN0X291dHB1dF9yYXc6dGVzdF9vdXRwdXQgfnRlc3RfaWQ6dGVzdF90b19ydW47XG4gICAgICAgICgqIFBlcmZvcm0gdGhlIHBlci10ZXN0IHJlYWNoYWJpbGl0eSBjaGVjayAqKVxuICAgICAgICBMaXN0Lml0ZXIgZXhwZWN0YXRpb25zIH5mOihmdW4gKF8sIHRlc3Rfbm9kZSkgLT5cbiAgICAgICAgICBUZXN0X25vZGUucmVjb3JkX2VuZF9vZl9ydW4gdGVzdF9ub2RlKTtcbiAgICAgICAgKCogUmVzdG9yZSBzdGRvdXQvc3RkZXJyICopXG4gICAgICAgIFNoYXJlZC5jbGVhbl91cF9ibG9jayB0ZXN0X2Jsb2NrO1xuICAgICAgICBDdXJyZW50X3Rlc3QudW5zZXQgKCk7XG4gICAgICAgICgqIFJlcG9ydCB0aGF0IHRoaXMgdGVzdCBwYXNzZWQsIGJlY2F1c2Ugd2UgcmVwb3J0IGV4cGVjdCB0ZXN0IGZhaWx1cmVzIGJ5IGFcbiAgICAgICAgICAgIGRpZmZlcmVudCBtZWNoYW5pc20uICopXG4gICAgICAgIHRydWUpXG4gIDs7XG5lbmRcblxubGV0IGF0X2V4aXQgKCkgPVxuICBDdXJyZW50X3Rlc3QuaXRlclxuICAgIH5mOlxuICAgICAgKGZ1blxuICAgICAgICB7IGxpbmVfbnVtYmVyXG4gICAgICAgIDsgYmFzZW5hbWVcbiAgICAgICAgOyBsb2NhdGlvbiA9IHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfVxuICAgICAgICA7IHRlc3RfYmxvY2tcbiAgICAgICAgfVxuICAgICAgICAtPlxuICAgIFNoYXJlZC5mbHVzaCAoKTtcbiAgICBsZXQgZmluID0gU3RkbGliLm9wZW5faW5fYmluIChTaGFyZWQub3V0cHV0X2ZpbGUgdGVzdF9ibG9jaykgaW5cbiAgICBsZXQgYWxsX291dCA9IFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIGZpbiAoU3RkbGliLmluX2NoYW5uZWxfbGVuZ3RoIGZpbikgaW5cbiAgICBTaGFyZWQuY2xlYW5fdXBfYmxvY2sgdGVzdF9ibG9jaztcbiAgICBTdGRsaWIuUHJpbnRmLmVwcmludGZcbiAgICAgIFwiRmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDpcXG5cXFxuICAgICAgIEVycm9yOiBwcm9ncmFtIGV4aXRlZCB3aGlsZSBleHBlY3QgdGVzdCB3YXMgcnVubmluZyFcXG5cXFxuICAgICAgIE91dHB1dCBjYXB0dXJlZCBzbyBmYXI6XFxuXFxcbiAgICAgICAlc1xcblxcXG4gICAgICAgJSFcIlxuICAgICAgYmFzZW5hbWVcbiAgICAgIGxpbmVfbnVtYmVyXG4gICAgICAoc3RhcnRfcG9zIC0gc3RhcnRfYm9sKVxuICAgICAgKGVuZF9wb3MgLSBzdGFydF9ib2wpXG4gICAgICBhbGxfb3V0KVxuOztcblxubW9kdWxlIEZvcl9leHRlcm5hbCA9IHN0cnVjdFxuICBsZXQgcmVhZF9jdXJyZW50X3Rlc3Rfb3V0cHV0X2V4biB+aGVyZSA9XG4gICAgbWF0Y2ggQ3VycmVudF90ZXN0LmN1cnJlbnRfdGVzdCAoKSB3aXRoXG4gICAgfCBTb21lIHRlc3RfYmxvY2sgLT5cbiAgICAgIHRlc3RfYmxvY2sgfD4gU2hhcmVkLnJlYWRfdGVzdF9vdXRwdXRfdW5zYW5pdGl6ZWQgfD4gRXhwZWN0X3Rlc3RfY29uZmlnLnNhbml0aXplXG4gICAgfCBOb25lIC0+XG4gICAgICBmYWlsd2l0aFxuICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgXCJQcHhfZXhwZWN0X3J1bnRpbWUucmVhZF9jdXJyZW50X3Rlc3Rfb3V0cHV0X2V4biBjYWxsZWQgd2hpbGUgdGhlcmUgYXJlIG5vIFxcXG4gICAgICAgICAgICB0ZXN0cyBydW5uaW5nIGF0ICVzXCJcbiAgICAgICAgICAgKFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnRvX3N0cmluZyBoZXJlKSlcbiAgOztcblxuICBsZXQgYW1fcnVubmluZ19leHBlY3RfdGVzdCA9IEN1cnJlbnRfdGVzdC5pc19ydW5uaW5nXG5cbiAgbGV0IGRlZmF1bHRfY3JfZm9yX211bHRpcGxlX291dHB1dHMgPVxuICAgIGxldCBtb2R1bGUgQ29uZmlndXJlZCA9IENvbmZpZ3VyZWQgKEV4cGVjdF90ZXN0X2NvbmZpZykgaW5cbiAgICBDb25maWd1cmVkLmNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzXG4gIDs7XG5lbmRcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw1IiwiYTMiLCJhNCIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJwYXJ0aWFsIiwiRXhwZWN0X3Rlc3RfY29uZmlnIiwiQmFzZV9Tb3VyY2VfY29kZV9wb3NpdGlvbiIsIkJhc2VfUHJpbnRmIiwiQmFzZSIsIlN0ZGxpYiIsIlN0ZGxpYl9QcmludGYiLCJCYXNlX09wdGlvbiIsIlBweF9leHBlY3RfcnVudGltZV9UZXN0X25vZGUiLCJQcHhfZXhwZWN0X3J1bnRpbWVfVHlwZXMiLCJCYXNlX0xpc3QiLCJQcHhfZXhwZWN0X3J1bnRpbWVfQ3VycmVudF9maWwiLCJQcHhfZXhwZWN0X3J1bnRpbWVfRXhwZWN0YXRpb24iLCJCYXNlX1N0cmluZyIsIlN0ZGxpYl9GaWxlbmFtZSIsIlBweF9pbmxpbmVfdGVzdF9saWIiLCJTdGRsaWJfUHJpbnRleGMiLCJCYXNlX0V4biIsIlN0ZGxpYl9PYmoiLCJTdGRsaWJfRm9ybWF0IiwiY3N0X0NSIiwiY2xlYW5fdXBfYmxvY2siLCJwYXJhbSIsInRlc3Rfb3V0cHV0X3dyaXRlciIsInRlc3Rfb3V0cHV0X3JlYWRlciIsIm91dHB1dF9maWxlIiwiZmx1c2giLCJyZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkIiwib2xkX29mZnNldCIsIm5ld19vZmZzZXQiLCJsZW4iLCJDb25maWd1cmVkIiwiQyIsImNyX3ByZWZpeCIsImNyX2Zvcl9iYWNrdHJhY2UiLCJjcl9mb3JfbXVsdGlwbGVfb3V0cHV0cyIsIm91dHB1dF9uYW1lIiwib3V0cHV0cyIsImNyX2JvZHkiLCJjciIsIm51bV9vdXRwdXRzIiwib3V0cHV0c193aXRoX2hlYWRlcnMiLCJpbmRleCIsIm91dHB1dCIsImhlYWRlciIsInBhZF9sZW5ndGgiLCJscGFkIiwicnBhZCIsInNhbml0aXplIiwiY2hlY2tfZm9yX2JhY2t0cmFjZXMiLCJzIiwic3Vic3RyaW5nIiwiZHVtcF9iYWNrdHJhY2UiLCJwb3NzaWJsZV9leG4iLCJleG4iLCJidCIsImV4bl9zdHJpbmciLCJuYW1lIiwidGVzdF9pc19ydW5uaW5nIiwiY3N0X2lubmVyX3Rlc3QiLCJjc3Rfb3V0ZXJfdGVzdCIsImNzdF9FeHBlY3RfdGVzdF9ydW50aW1lX3JlYWNoZSIsImFtX3J1bm5pbmdfZXhwZWN0X3Rlc3QiLCJjdXJyZW50X3Rlc3QiLCJ0ZXN0X2Jsb2NrIiwiY3VycmVudF90ZXN0X2V4biIsIml0ZXIiLCJhc3NlcnRfbm9fdGVzdF9ydW5uaW5nIiwiYmFzZW5hbWUiLCJsaW5lX251bWJlciIsIm91dGVyX2Jhc2VuYW1lIiwib3V0ZXJfbGluZV9udW1iZXIiLCJzZXhwX2hlcmUiLCJhdF9leGl0IiwibWF0Y2giLCJlbmRfcG9zIiwic3RhcnRfcG9zIiwic3RhcnRfYm9sIiwiZmluIiwiYWxsX291dCIsInJlYWRfY3VycmVudF90ZXN0X291dHB1dF9leG4iLCJoZXJlIiwiZGVmYXVsdF9jcl9mb3JfbXVsdGlwbGVfb3V0cHV0IiwiRm9yX2V4dGVybmFsIiwiY3N0X291dHB1dCIsImNzdF9leHBlY3RfdGVzdCIsImNzdF9UcmFpbGluZ19vdXRwdXQiLCJQcHhfZXhwZWN0X3J1bnRpbWVfVGVzdF9ibG9jayIsInJlYWRfdGVzdF9vdXRwdXRfbm9fYmFja3RyYWNlXyIsInJlYWRfdGVzdF9vdXRwdXRfc2FuaXRpemVkX2FuZCIsInJ1bl90ZXN0X2lubmVyIiwidGVzdF9pZCIsInRlc3Rfb3V0cHV0X3JhdyIsInQiLCJzcmNfZmlsZW5hbWUiLCJmYWlsIiwicnVuX3Rlc3QiLCJydW5fc3VpdGUiLCJmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290IiwibG9jYXRpb24iLCJ0cmFpbGluZ19sb2MiLCJib2R5X2xvYyIsImZvcm1hdHRpbmdfZmxleGliaWxpdHkiLCJleHBlY3RlZF9leG4iLCJ0ZXN0X3RvX3J1biIsImV4bl90ZXN0X2lkIiwiZGVzY3JpcHRpb24iLCJ0YWdzIiwiaW5saW5lX3Rlc3RfY29uZmlnIiwiZXhwZWN0YXRpb25zIiwiYWJzb2x1dGVfZmlsZW5hbWUiLCJ0cmFpbGluZ190ZXN0IiwiZXhuX3Rlc3QiLCJvcmlnaW5hbF9maWxlX2NvbnRlbnRzIiwidHMiLCJ0ZXN0X2V4biIsInRyYWlsaW5nX3JhdyIsInRyYWlsaW5nX291dHB1dCIsInRlc3Rfb3V0cHV0IiwidGVzdF9ub2RlIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBZixRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFnQixxQkFBQTtBQUFBLElBQUFDLDRCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsK0JBQUE7QUFBQSxJQUFB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QUFBQSx5QkFBQWQsZ0JBSkosYUFBQWMsY0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFBQTtBQUFBQSx1QkFGUTtBQUFBLHFCQUFBZCxnQkFZWjtBQUFBLHFCQUFBYyxjQUFBO0FBQUE7QUFBQSxtQkFFQTtBQUFBO0FBQUE7QUFBQSw4QkFBQWhHO0FBQUFBLDBCQUFBaUcsWUFBMEI7QUFBQSxzQkFDeEIsNERBQXNDO0FBQUE7QUFBQSxtQkFFeEM7QUFBQSxtQkFuTFM7QUFBQSxtQkFvTFk7QUFBQSxrQkFHakIsRUE5RmtEO0FBQUE7QUFBQSxRRHJSOUQiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InBweF9leHBlY3RfcnVudGltZS5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2RzL0RvY3VtZW50cy9wYXRjaHdvcmsvX29wYW0vbGliL3BweF9leHBlY3QvcnVudGltZS9wcHhfZXhwZWN0X3J1bnRpbWUubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuISBCYXNlXG5cbigqKiBUaGlzIGxpYnJhcnkgcHJvdmlkZXMgdGhlIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24gb2YgZXhwZWN0IHRlc3RzIGFuZCBtdWNoIG9mIHRoZSBsb2dpY1xuICAgIGZvciBydW5uaW5nIHRoZW0uXG5cbiAgICBUaGUgW1Rlc3RfYmxvY2tdIG1vZHVsZSBkZWZpbmVzIHRoZSBydW50aW1lIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB3aG9sZVxuICAgIFtsZXQlZXhwZWN0X3Rlc3RdIGJsb2NrLiBJdCBleHBvcnRzIGEgW01ha2VdIGZ1bmN0b3IgdGhhdCBpcyB1c2VkIGluIGdlbmVyYXRlZCBjb2RlIHRvXG4gICAgcHJvZHVjZSBhIG1vZHVsZSBmcm9tIHRoZSBsb2NhbGx5IGJvdW5kIFtFeHBlY3RfdGVzdF9jb25maWddLiBbcnVuX3N1aXRlXSBmcm9tIHRoZVxuICAgIHJlc3VsdGluZyBtb2R1bGUgdGFrZXMgaW4gcmVtYWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBleHBlY3QgdGVzdCwgaW5jbHVkaW5nXG4gICAgaW5saW5lIHRlc3QgY29uZmlndXJhdGlvbnMsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250YWluZWQgZXhwZWN0YXRpb25zLCBhbmQgYVxuICAgIGNhbGxiYWNrIGNvbnRhaW5pbmcgdGhlIGJvZHkgb2YgdGhlIHRlc3QuXG5cbiAgICBUaGUgW35leHBlY3RhdGlvbnNdIGFyZ3VtZW50IHRvIFtydW5fc3VpdGVdIGlzIGFuIGFzc29jIGxpc3QgbWFwcGluZyB1bmlxdWUgaWRzIHRvXG4gICAgW1Rlc3Rfbm9kZS50XXMuIEEgW1Rlc3Rfbm9kZS50XSBzdG9yZXMgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIFtbJWV4cGVjdF1dIHRlc3RcbiAgICBBU1Qgbm9kZSBhbmQgY29sbGVjdHMgdGhlIHJlc3VsdHMgb2YgdGVzdHMgdGhhdCByZWFjaCB0aGlzIG5vZGUuXG5cbiAgICBJbiB0aGUgYm9keSBvZiB0aGUgdGVzdCwgdGhlIFtbJWV4cGVjdF1dIEFTVCBub2RlcyBhcmUgcmVwbGFjZWQgYnkgY2FsbHMgdG9cbiAgICBbcnVuX3Rlc3RdLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpZCBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG5cbiAgICBGb3IgYW4gZXhhbXBsZSwgY29uc2lkZXIgYSBmaWxlIHRoYXQgY29udGFpbnMganVzdCB0aGUgc2ltcGxlIFtsZXQlZXhwZWN0X3Rlc3RdIGJlbG93OlxuXG4gICAge1tcbiAgICAgIGxldCVleHBlY3RfdGVzdCBfID1cbiAgICAgICAgcHJpbnRfc3RyaW5nIFwiSGVsbG9cIjtcbiAgICAgICAgWyVleHBlY3Qge3wgSGVsbG8gfH1dO1xuICAgICAgICBwcmludF9zdHJpbmcgXCJ3b3JsZFwiO1xuICAgICAgICBbJWV4cGVjdF9leGFjdCB7eHx3b3JsZHx4fV1cbiAgICAgIDs7XG4gICAgXX1cblxuICAgIEl0IHdpbGwgZXhwYW5kIHRvIGNvZGUgdGhhdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuXG4gICAge1tcbiAgICAgICgqIFRoaXMgc3RhdGVtZW50IGlzIGFkZGVkIHRvIHRoZSB0b3Agb2YgZWFjaCByZXdyaXR0ZW4gZmlsZTsgaXQgaXMgdXNlZCB0byBtYWtlXG4gICAgICAgICBzdXJlIHRlc3RzIGFyZSBvbmx5IHJ1biBmcm9tIHRoZSBmaWxlcyBpbiB3aGljaCB0aGV5IGFyZSBkZWNsYXJlZC4gKilcbiAgICAgIGxldCAoKSA9XG4gICAgICAgIFBweF9leHBlY3RfcnVudGltZS5DdXJyZW50X2ZpbGUuc2V0XG4gICAgICAgICAgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3Q6XCJmb28vYmFyL3Rlc3QvdGVzdC5tbFwiXG5cbiAgICAgICgqIEVhY2ggdGVzdCBleHBhbmRzIGludG8gc29tZXRoaW5nIHRoYXQgbG9va3MgYXBwcm94aW1hdGVseSBsaWtlIHRoaXMuIFNvbWUgb2YgdGhlXG4gICAgICAgICBhcmd1bWVudHMgdG8gW1BweF9leHBlY3RfdGVzdF9ibG9jay5ydW5fc3VpdGVdIGFyZSBlbGlkZWQgZm9yIGNsYXJpdHkuICopXG4gICAgICBsZXQgKCkgPVxuICAgICAgICAoKiBQcmVwYXJlIHRvIHJlYWQgdGVzdCBvdXRwdXQgdXNpbmcgdGhlIHNldHRpbmdzIGZyb20gW0V4cGVjdF90ZXN0X2NvbmZpZ10gKilcbiAgICAgICAgbGV0IG1vZHVsZSBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sgPVxuICAgICAgICAgIFBweF9leHBlY3RfcnVudGltZS5NYWtlX3Rlc3RfYmxvY2soRXhwZWN0X3Rlc3RfY29uZmlnKSBpblxuICAgICAgICBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sucnVuX3N1aXRlXG4gICAgICAgICAgKCogVGhlIG5hbWUgb2YgdGhlIGZpbGUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgZGVmaW5lZC4gVGhpcyBsZXRzIHRoZSBydW50aW1lXG4gICAgICAgICAgICAgY2hlY2sgdGhhdCB0aGUgZmlsZW5hbWUgc2V0IGhlcmUgYXQgcHB4LXRpbWUgbWF0Y2hlcyB0aGUgb25lIHRoYXQgaXMgc2V0IGJ5XG4gICAgICAgICAgICAgdGhlIGJsb2NrIGFib3ZlIGF0IHJ1bnRpbWUuIElmIHRoZSB0ZXN0IHdlcmUgZGVmaW5lZCBpbiBhIGZ1bmN0b3IgYW5kIHRoYXRcbiAgICAgICAgICAgICBmdW5jdG9yIGludm9rZWQgZnJvbSBhbm90aGVyIGZpbGUsIHRoZSBmaWxlbmFtZXMgd291bGQgbm90IG1hdGNoLiAqKVxuICAgICAgICAgIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290OlwiZm9vL2Jhci90ZXN0L3Rlc3QubWxcIlxuICAgICAgICAgICgqIFRoZSBpZHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHJlZ2lzdGVyaW5nIHRoZSB0cmFpbGluZyBvdXRwdXQgdGVzdCBhbmQgdGhlXG4gICAgICAgICAgICAgdW5jYXVnaHQgZXhjZXB0aW9uIHRlc3RzLiBUaGV5IGFyZSBtaW50ZWQgYXQgcHB4IHRpbWUgYmVjYXVzZSB0aGF0IGlzIHRoZVxuICAgICAgICAgICAgIHRpbWUgdGhhdCBpdCBpcyBlYXNpZXN0IHRvIGd1YXJhbnRlZSB0aGVpciB1bmlxdWVuZXNzLiAqKVxuICAgICAgICAgIH50cmFpbGluZ190ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDIpXG4gICAgICAgICAgfmV4bl90ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDMpXG4gICAgICAgICAgKCogQW4gYXNzb2MgbGlzdCBtYXBwaW5nIGlkcyB0byByZXByZXNlbnRhdGlvbnMgb2YgZXhwZWN0IG5vZGVzIHRoYXQgYXBwZWFyIGluXG4gICAgICAgICAgICAgdGhpcyB0ZXN0LiBMYXRlciwgd2hlbiBlbmNvdW50ZXJpbmcgZXhwZWN0IG5vZGVzLCBpbmZvcm1hdGlvbiBhYm91dCB0aGVtIGlzXG4gICAgICAgICAgICAgbG9va2VkIHVwIGluIHRoaXMgdGFibGUuICopXG4gICAgICAgICAgfmV4cGVjdGF0aW9uczooKFsoUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBweF9leHBlY3RfcnVudGltZS5UZXN0X25vZGUuQ3JlYXRlLmV4cGVjdF9leGFjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjb250ZW50cyA9IFwid29ybGRcIjsgdGFnID0gKFRhZyBcInhcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydF9ib2wgPSAuLi47IHN0YXJ0X3BvcyA9IC4uLjsgZW5kX3BvcyA9IC4uLiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHB4X2V4cGVjdF9ydW50aW1lLlRlc3Rfbm9kZS5DcmVhdGUuZXhwZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNvbnRlbnRzID0gXCIgSGVsbG8gXCI7IHRhZyA9IChUYWcgXCJcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGFydF9ib2wgPSAuLi47IHN0YXJ0X3BvcyA9IC4uLjsgZW5kX3BvcyA9IC4uLiB9KV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgKCogVGhlIGJvZHkgb2YgdGhlIGxldCBiaW5kaW5nIGlzIHBhc3NlZCBhcyBhIGNhbGxiYWNrLiAqKVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICBwcmludF9zdHJpbmcgXCJIZWxsb1wiO1xuICAgICAgICAgICAgICgqIFRlc3RzIGFyZSBydW4gYnkgcGFzc2luZyBpbiB0aGUgaWQgb2YgdGhlIGVuY291bnRlcmVkIHRlc3Qgbm9kZS4gKilcbiAgICAgICAgICAgICBQcHhfZXhwZWN0X3Rlc3RfYmxvY2sucnVuX3Rlc3RcbiAgICAgICAgICAgICAgIH50ZXN0X2lkOihQcHhfZXhwZWN0X3J1bnRpbWUuRXhwZWN0YXRpb25faWQub2ZfaW50IDApO1xuICAgICAgICAgICAgIHByaW50X3N0cmluZyBcIndvcmxkXCI7XG4gICAgICAgICAgICAgUHB4X2V4cGVjdF90ZXN0X2Jsb2NrLnJ1bl90ZXN0XG4gICAgICAgICAgICAgICB+dGVzdF9pZDooUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAxKSlcblxuICAgICAgKCogVGhpcyBzdGF0ZW1lbnQgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiBlYWNoIGZpbGUgc28gdGhhdCB0aGUgZXhwZWN0IHRlc3QgcnVudGltZVxuICAgICAgICAga25vd3MgdGhlIGZpbGUgaXMgZmluaXNoZWQgZXhlY3V0aW5nIGFuZCBhIG5ldyBvbmUgY2FuIGJlIHNldCBhcyBjdXJyZW50LiAqKVxuICAgICAgbGV0ICgpID0gUHB4X2V4cGVjdF9ydW50aW1lLkN1cnJlbnRfZmlsZS51bnNldCAoKVxuICAgIF19XG4qKVxuXG4oKiBSZWdpc3RlciB0aGUgcmVhY2hhYmlsaXR5IGNoZWNrIGFuZCBjb3JyZWN0ZWQgZmlsZSB3cml0aW5nIGFzIGFuIGV2YWx1YXRvciB3aXRoXG4gICBbUHB4X2lubGluZV90ZXN0X2xpYl0gKilcbmxldCAoKSA9XG4gIFBweF9pbmxpbmVfdGVzdF9saWIuYWRkX2V2YWx1YXRvciB+ZjooZnVuICgpIC0+XG4gICAgU3RkbGliLlN5cy5jaGRpciAoTGF6eS5mb3JjZSBDdXJyZW50X2ZpbGUuaW5pdGlhbF9kaXIpO1xuICAgIFRlc3Rfbm9kZS5HbG9iYWxfcmVzdWx0c190YWJsZS5wcm9jZXNzX2VhY2hfZmlsZVxuICAgICAgfmY6KGZ1biB+ZmlsZW5hbWUgfnRlc3Rfbm9kZXMgfnBvc3Rwcm9jZXNzIC0+XG4gICAgICBXcml0ZV9jb3JyZWN0ZWRfZmlsZS5mXG4gICAgICAgIHRlc3Rfbm9kZXNcbiAgICAgICAgfnVzZV9jb2xvcjooUHB4X2lubGluZV90ZXN0X2xpYi51c2VfY29sb3IgKCkpXG4gICAgICAgIH5pbl9wbGFjZTooUHB4X2lubGluZV90ZXN0X2xpYi5pbl9wbGFjZSAoKSlcbiAgICAgICAgfmRpZmZfY29tbWFuZDooUHB4X2lubGluZV90ZXN0X2xpYi5kaWZmX2NvbW1hbmQgKCkpXG4gICAgICAgIH5kaWZmX3BhdGhfcHJlZml4OihQcHhfaW5saW5lX3Rlc3RfbGliLmRpZmZfcGF0aF9wcmVmaXggKCkpXG4gICAgICAgIH53aXRoXzpwb3N0cHJvY2Vzc1xuICAgICAgICB+ZmlsZW5hbWUpXG4gICAgfD4gUHB4X2lubGluZV90ZXN0X2xpYi5UZXN0X3Jlc3VsdC5jb21iaW5lX2FsbClcbjs7XG5cbigqIEFsZXJ0IG9mIG1pZC10ZXN0IHJ1bnRpbWUgZmFpbHVyZS4gKilcbmxldCAoKSA9IFN0ZGxpYi5hdF9leGl0IFRlc3RfYmxvY2suYXRfZXhpdFxuXG4oKiBFeHBvcnRlZCBkZWZpbml0aW9ucyAqKVxuXG5tb2R1bGUgRXhwZWN0X25vZGVfZm9ybWF0dGluZyA9IFR5cGVzLkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbm1vZHVsZSBDb21wYWN0X2xvYyA9IFR5cGVzLkNvbXBhY3RfbG9jXG5tb2R1bGUgRXhwZWN0YXRpb25faWQgPSBUeXBlcy5FeHBlY3RhdGlvbl9pZFxubW9kdWxlIERlbGltaXRlciA9IFR5cGVzLlN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXJcbm1vZHVsZSBQYXlsb2FkID0gT3V0cHV0LlBheWxvYWRcblxubW9kdWxlIEN1cnJlbnRfZmlsZSA6IHNpZ1xuICB2YWwgc2V0IDogZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdDpzdHJpbmcgLT4gdW5pdFxuICB2YWwgdW5zZXQgOiB1bml0IC0+IHVuaXRcbmVuZCA9XG4gIEN1cnJlbnRfZmlsZVxuXG5tb2R1bGUgVGVzdF9ub2RlID0gc3RydWN0XG4gIHR5cGUgdCA9IFRlc3Rfbm9kZS50XG5cbiAgbW9kdWxlIENyZWF0ZSA9IFRlc3Rfbm9kZS5DcmVhdGVcbiAgbW9kdWxlIEZvcl9tbHQgPSBUZXN0X25vZGUuRm9yX21sdFxuZW5kXG5cbm1vZHVsZSBXcml0ZV9jb3JyZWN0ZWRfZmlsZSA9IFdyaXRlX2NvcnJlY3RlZF9maWxlXG5tb2R1bGUgTWFrZV90ZXN0X2Jsb2NrID0gVGVzdF9ibG9jay5NYWtlXG5tb2R1bGUgRm9yX2V4dGVybmFsID0gVGVzdF9ibG9jay5Gb3JfZXh0ZXJuYWxcbm1vZHVsZSBGb3JfYXBwbHlfc3R5bGUgPSBFeHBlY3RhdGlvbi5Gb3JfYXBwbHlfc3R5bGVcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImdsb2JhbF9kYXRhIiwiUHB4X2lubGluZV90ZXN0X2xpYiIsIlBweF9leHBlY3RfcnVudGltZV9Xcml0ZV9jb3JyZSIsIlBweF9leHBlY3RfcnVudGltZV9DdXJyZW50X2ZpbCIsIkNhbWxpbnRlcm5hbExhenkiLCJQcHhfZXhwZWN0X3J1bnRpbWVfVGVzdF9ub2RlIiwiUHB4X2V4cGVjdF9ydW50aW1lX1Rlc3RfYmxvY2siLCJTdGRsaWIiLCJwYXJhbSIsImZpbGVuYW1lIiwidGVzdF9ub2RlcyIsInBvc3Rwcm9jZXNzIiwiQ3VycmVudF9maWxlIiwiVGVzdF9ub2RlIiwiUHB4X2V4cGVjdF9ydW50aW1lIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQywrQkFBQTtBQUFBLElBQUFDLGdDQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLEdDdUZFO0FBQUE7QUFBQSxjQUFBQztBQUFBQSxVQUFBLElBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQ0E7QUFBQTtBQUFBLG9CQUFBQyxVQUFBQyxZQUFBQztBQUFBQTtBQUFBQSxhQUFBLElBT3NCO0FBQUEsaUJBREo7QUFBQSxpQkFESjtBQUFBLGlCQURDO0FBQUEsWUFBa0M7QUFBQSx5RUFLcEM7QUFBQTtBQUFBLE1BQUMsK0NBQ2dDO0FBQUE7QUFBQSxHQUl6QztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBaUM7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUE7QUFBQTtBQUFBLEVEdkcxQyIsImlnbm9yZUxpc3QiOlswXX19XX0=
